<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>松本行弘的程序世界 2 面向对象 | ZDK&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="电子书笔记,程序语言">
    <meta name="description" content="松本行弘的程序世界 2 面向对象编程和面向对象的关系计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。 颠倒的构造程序员要夺得主动权。 主宰计算机的武器为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。 怎样写程序编程风格 算法 数据结构 设计模式 开发方法 面向对象的编程方法smalltalk为面向对象编程语言之母。 面向对象的难点面向对象编程语">
<meta name="keywords" content="电子书笔记,程序语言">
<meta property="og:type" content="article">
<meta property="og:title" content="松本行弘的程序世界 2 面向对象">
<meta property="og:url" content="https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:description" content="松本行弘的程序世界 2 面向对象编程和面向对象的关系计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。 颠倒的构造程序员要夺得主动权。 主宰计算机的武器为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。 怎样写程序编程风格 算法 数据结构 设计模式 开发方法 面向对象的编程方法smalltalk为面向对象编程语言之母。 面向对象的难点面向对象编程语">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.11.02.png">
<meta property="og:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.14.46.png">
<meta property="og:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8B%E5%8D%885.39.58.png">
<meta property="og:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%889.18.30.png">
<meta property="og:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.41.50.png">
<meta property="og:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.44.57.png">
<meta property="og:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8B%E5%8D%887.10.21.png">
<meta property="og:updated_time" content="2018-07-25T02:33:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="松本行弘的程序世界 2 面向对象">
<meta name="twitter:description" content="松本行弘的程序世界 2 面向对象编程和面向对象的关系计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。 颠倒的构造程序员要夺得主动权。 主宰计算机的武器为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。 怎样写程序编程风格 算法 数据结构 设计模式 开发方法 面向对象的编程方法smalltalk为面向对象编程语言之母。 面向对象的难点面向对象编程语">
<meta name="twitter:image" content="https://github.com/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.11.02.png">
    
        <link rel="alternate" type="application/atom+xml" title="ZDK&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/tmg.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">ZDK</h5>
          <a href="mailto:2822464407@qq.com" title="2822464407@qq.com" class="mail">2822464407@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zdkswd" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">松本行弘的程序世界 2 面向对象</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">松本行弘的程序世界 2 面向对象</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-07-05T14:14:32.000Z" itemprop="datePublished" class="page-time">
  2018-07-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#松本行弘的程序世界-2-面向对象"><span class="post-toc-number">1.</span> <span class="post-toc-text">松本行弘的程序世界 2 面向对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#编程和面向对象的关系"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">编程和面向对象的关系</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#颠倒的构造"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">颠倒的构造</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主宰计算机的武器"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">主宰计算机的武器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#怎样写程序"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">怎样写程序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向对象的编程方法"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">面向对象的编程方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向对象的难点"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">面向对象的难点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多态性"><span class="post-toc-number">1.1.6.</span> <span class="post-toc-text">多态性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#具体的程序"><span class="post-toc-number">1.1.7.</span> <span class="post-toc-text">具体的程序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多态性的优点"><span class="post-toc-number">1.1.8.</span> <span class="post-toc-text">多态性的优点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据抽象和继承"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">数据抽象和继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向对象的历史"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">面向对象的历史</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#simula的“发明”"><span class="post-toc-number">1.2.1.1.</span> <span class="post-toc-text">simula的“发明”</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Smalltalk的发展"><span class="post-toc-number">1.2.1.2.</span> <span class="post-toc-text">Smalltalk的发展</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Lisp的发展"><span class="post-toc-number">1.2.1.3.</span> <span class="post-toc-text">Lisp的发展</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#和c语言的相遇"><span class="post-toc-number">1.2.1.4.</span> <span class="post-toc-text">和c语言的相遇</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Java的诞生"><span class="post-toc-number">1.2.1.5.</span> <span class="post-toc-text">Java的诞生</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#复杂性是面向对象的敌人"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">复杂性是面向对象的敌人</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构化编程"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">结构化编程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据抽象化"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">数据抽象化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#雏形"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">雏形</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#找出相似的部分来继承"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">找出相似的部分来继承</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多重继承的缺点"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">多重继承的缺点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么需要多继承"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">为什么需要多继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多重继承和单一继承不可分离"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">多重继承和单一继承不可分离</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#goto语句和多重继承比较相似"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">goto语句和多重继承比较相似</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解决多重继承的问题"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">解决多重继承的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态语言与动态语言的区别"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">静态语言与动态语言的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态语言的特点"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">静态语言的特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态语言的特点"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">动态语言的特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态语言与动态语言的比较"><span class="post-toc-number">1.3.8.</span> <span class="post-toc-text">静态语言与动态语言的比较</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承的两种含义"><span class="post-toc-number">1.3.9.</span> <span class="post-toc-text">继承的两种含义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口的缺点"><span class="post-toc-number">1.3.10.</span> <span class="post-toc-text">接口的缺点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承实现的方法"><span class="post-toc-number">1.3.11.</span> <span class="post-toc-text">继承实现的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从多重继承变形而来的Mix-in"><span class="post-toc-number">1.3.12.</span> <span class="post-toc-text">从多重继承变形而来的Mix-in</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#积极支持Mix-in的Ruby"><span class="post-toc-number">1.3.13.</span> <span class="post-toc-text">积极支持Mix-in的Ruby</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#两个误解"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">两个误解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向对象的编程"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">面向对象的编程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象的模板-类"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">对象的模板=类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#利用模板的手段-继承"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">利用模板的手段=继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多重继承不好吗"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">多重继承不好吗</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态编程语言也需要多重继承"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">动态编程语言也需要多重继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#驯服多重继承的方法"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">驯服多重继承的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ruby中多重继承的实现方法"><span class="post-toc-number">1.4.7.</span> <span class="post-toc-text">ruby中多重继承的实现方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#java实现多重继承的方法"><span class="post-toc-number">1.4.8.</span> <span class="post-toc-text">java实现多重继承的方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Duck-Typing诞生之前"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">Duck Typing诞生之前</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么需要类型"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">为什么需要类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态的类型是从Lisp中诞生的"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">动态的类型是从Lisp中诞生的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态类型在面向对象中发展起来了"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">动态类型在面向对象中发展起来了</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态类型和静态类型的邂逅"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">动态类型和静态类型的邂逅</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态类型的优点"><span class="post-toc-number">1.5.5.</span> <span class="post-toc-text">静态类型的优点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态类型的优点"><span class="post-toc-number">1.5.6.</span> <span class="post-toc-text">动态类型的优点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#只关心行为的Duck-Typing"><span class="post-toc-number">1.5.7.</span> <span class="post-toc-text">只关心行为的Duck Typing</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#避免明确的类型检查"><span class="post-toc-number">1.5.8.</span> <span class="post-toc-text">避免明确的类型检查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#克服动态类型的缺点"><span class="post-toc-number">1.5.9.</span> <span class="post-toc-text">克服动态类型的缺点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态编程语言"><span class="post-toc-number">1.5.10.</span> <span class="post-toc-text">动态编程语言</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#元编程"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">元编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#元编程-1"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">元编程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#反射"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">反射</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#元编程的例子"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">元编程的例子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用反射功能"><span class="post-toc-number">1.6.4.</span> <span class="post-toc-text">使用反射功能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分布式Ruby的实现"><span class="post-toc-number">1.6.5.</span> <span class="post-toc-text">分布式Ruby的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据库的应用"><span class="post-toc-number">1.6.6.</span> <span class="post-toc-text">数据库的应用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#输出xml"><span class="post-toc-number">1.6.7.</span> <span class="post-toc-text">输出xml</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#元编程和小编程语言"><span class="post-toc-number">1.6.8.</span> <span class="post-toc-text">元编程和小编程语言</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#声明的实现"><span class="post-toc-number">1.6.9.</span> <span class="post-toc-text">声明的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#上下文相关的实现"><span class="post-toc-number">1.6.10.</span> <span class="post-toc-text">上下文相关的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单位的实现"><span class="post-toc-number">1.6.11.</span> <span class="post-toc-text">单位的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#词汇的实现"><span class="post-toc-number">1.6.12.</span> <span class="post-toc-text">词汇的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#层次数据的实现"><span class="post-toc-number">1.6.13.</span> <span class="post-toc-text">层次数据的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#适合DSL的语言，不适合DSL的语言"><span class="post-toc-number">1.6.14.</span> <span class="post-toc-text">适合DSL的语言，不适合DSL的语言</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-松本行弘的程序世界 2 面向对象"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">松本行弘的程序世界 2 面向对象</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-07-05 22:14:32" datetime="2018-07-05T14:14:32.000Z"  itemprop="datePublished">2018-07-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="松本行弘的程序世界-2-面向对象"><a href="#松本行弘的程序世界-2-面向对象" class="headerlink" title="松本行弘的程序世界 2 面向对象"></a>松本行弘的程序世界 2 面向对象</h1><h2 id="编程和面向对象的关系"><a href="#编程和面向对象的关系" class="headerlink" title="编程和面向对象的关系"></a>编程和面向对象的关系</h2><p>计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。</p>
<h3 id="颠倒的构造"><a href="#颠倒的构造" class="headerlink" title="颠倒的构造"></a>颠倒的构造</h3><p>程序员要夺得主动权。</p>
<h3 id="主宰计算机的武器"><a href="#主宰计算机的武器" class="headerlink" title="主宰计算机的武器"></a>主宰计算机的武器</h3><p>为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。</p>
<h3 id="怎样写程序"><a href="#怎样写程序" class="headerlink" title="怎样写程序"></a>怎样写程序</h3><p>编程风格 算法 数据结构 设计模式 开发方法</p>
<h3 id="面向对象的编程方法"><a href="#面向对象的编程方法" class="headerlink" title="面向对象的编程方法"></a>面向对象的编程方法</h3><p>smalltalk为面向对象编程语言之母。</p>
<h3 id="面向对象的难点"><a href="#面向对象的难点" class="headerlink" title="面向对象的难点"></a>面向对象的难点</h3><p>面向对象编程语言中最重要的技术是“多态性”。</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态就是可以把不同种类的东西当做相同的东西处理。<br>操作对象是三个箱子，分别是盖着盖子的箱子、加了锁的箱子、系着彩带的箱子。在编程中，“打开箱子”的命令，称之为消息；打开不同箱子的具体操作，称之为方法。</p>
<h3 id="具体的程序"><a href="#具体的程序" class="headerlink" title="具体的程序"></a>具体的程序</h3><p>调用box_open这个方法，根据参数（箱子的种类）的不同做相应的处理。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.11.02.png" alt="屏幕快照 2018-07-04 上午8.11.02" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-04 上午8.11.02</div>
            </figure></p>
<p>但是如果增加种类代码就要重写，修改的地方越来越多，追加箱子的种类就会变得非常困难。<br>修改程序，实现真正的多态。“.”可以理解为“给前面的式子的值发送一个open消息”。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.14.46.png" alt="屏幕快照 2018-07-04 上午8.14.46" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-04 上午8.14.46</div>
            </figure></p>
<h3 id="多态性的优点"><a href="#多态性的优点" class="headerlink" title="多态性的优点"></a>多态性的优点</h3><p>首先，各种数据可以统一地处理。关注要处理什么，而不是怎么处理。<br>其次，根据对象选择方法，程序内部不会冲突。减轻程序员的负担。<br>再次，新数据简单的追加可以实现，不需要改动以前程序，具备了扩展性。</p>
<h2 id="数据抽象和继承"><a href="#数据抽象和继承" class="headerlink" title="数据抽象和继承"></a>数据抽象和继承</h2><p>面向对象编程的三原则：<strong>多态性</strong>，<strong>数据抽象</strong>，<strong>继承</strong>。别称：多态性：动态绑定，数据抽象：信息隐藏或封装。</p>
<h3 id="面向对象的历史"><a href="#面向对象的历史" class="headerlink" title="面向对象的历史"></a>面向对象的历史</h3><h4 id="simula的“发明”"><a href="#simula的“发明”" class="headerlink" title="simula的“发明”"></a>simula的“发明”</h4><p>面向对象编程思想起源于瑞典20世纪60年代后期发展起来的模拟编程语言Simula。以前，表示模拟对象的数据和实际的模拟方法是互相独立的，需要分别管理。</p>
<h4 id="Smalltalk的发展"><a href="#Smalltalk的发展" class="headerlink" title="Smalltalk的发展"></a>Smalltalk的发展</h4><p>smalltalke的开发宗旨是“让儿童也可以使用”，吸收了Simula的面向对象思想，且独居一格。不仅如此，还有一个很好的图形用户界面。使得世人开始了解面向对象编程的概念。</p>
<h4 id="Lisp的发展"><a href="#Lisp的发展" class="headerlink" title="Lisp的发展"></a>Lisp的发展</h4><p>许多重要的面向对象的概念都是从Lisp的面向对象功能中诞生的。</p>
<h4 id="和c语言的相遇"><a href="#和c语言的相遇" class="headerlink" title="和c语言的相遇"></a>和c语言的相遇</h4><p>C++是直接受到了simula语言的影响而没有受到smalltalk多大影响。</p>
<h4 id="Java的诞生"><a href="#Java的诞生" class="headerlink" title="Java的诞生"></a>Java的诞生</h4><p>java语言放弃了和C语言的兼容性，并增加了Lisp语言中一些好的功能。此外，通过Java虚拟机（JVM），java程序可以不用重新编译而在所有操作系统中运行。<br>Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p>
<h3 id="复杂性是面向对象的敌人"><a href="#复杂性是面向对象的敌人" class="headerlink" title="复杂性是面向对象的敌人"></a>复杂性是面向对象的敌人</h3><p>软件开发的最大敌人是复杂性。人类的大脑无法做台复杂得处理，记忆力和理解力也是有限的。<br>在计算机性能这么高的今天，人们为了找到迅速开发大规模复杂软件的方法，哪怕牺牲一些性能也在所不辞。</p>
<h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><p>如果不考虑黑盒内部的处理，系统复杂性就可以降低到人类的可控范围内。针对程序控制流的复杂问题，结构化编程采用看限制和抽象化的武器解决问题。</p>
<h3 id="数据抽象化"><a href="#数据抽象化" class="headerlink" title="数据抽象化"></a>数据抽象化</h3><p>数据抽象是数据和处理方法结合。对数据内容的处理和操作，必须通过实先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。<br>比如说栈。<br>有了数据抽象，程序处理的数据就不再是单纯的数值或者文字这些概念性的东西，而变成了人脑容易想象的具体事物。而代码的“抽象化”则是把想象的过程“具体化”了。</p>
<h3 id="雏形"><a href="#雏形" class="headerlink" title="雏形"></a>雏形</h3><p>同样的对象大量存在时，为避免重复，可以采用两种方法管理对象。</p>
<ol>
<li>原型。用原始对象的副本来作为新的相同的对象，JS用的原型。</li>
<li>模板，称为类。<br>跟原型不同，面向对象编程语言的类和对象有明显区别。对象又称作实例。</li>
</ol>
<h3 id="找出相似的部分来继承"><a href="#找出相似的部分来继承" class="headerlink" title="找出相似的部分来继承"></a>找出相似的部分来继承</h3><p>类的增多会用到很多性质相似的类。这就违背了我们的DRY（Don’t Repeat Yourself）原则。把这些相似的部分汇总到一起就好了。<br>继承就是这种方法。子类继承父类所有方法，如有需要可以增加新的方法，也可以重写父类方法。<br>Ruby跟多数编程语言一样，一个子类只能有一个父类，即单一继承，C++、Lisp等编程语言中，一个子类可以有多个父类，这称为“多重继承”。</p>
<h2 id="多重继承的缺点"><a href="#多重继承的缺点" class="headerlink" title="多重继承的缺点"></a>多重继承的缺点</h2><p>继承的原本目的实际上是逐步细化。所以为解决抽出类中相似部分的问题并不完全准确。</p>
<h3 id="为什么需要多继承"><a href="#为什么需要多继承" class="headerlink" title="为什么需要多继承"></a>为什么需要多继承</h3><p>一个程序员也可能是一个作家。</p>
<h3 id="多重继承和单一继承不可分离"><a href="#多重继承和单一继承不可分离" class="headerlink" title="多重继承和单一继承不可分离"></a>多重继承和单一继承不可分离</h3><p>单一继承的特点：</p>
<ol>
<li>继承关系单纯，有利有弊</li>
</ol>
<p>多重继承的特点：</p>
<ol>
<li>很自然的做到了单一继承的扩展。</li>
<li>可以继承多个类的功能。<br>单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系变得复杂。这是多重继承的一个缺点。</li>
</ol>
<h3 id="goto语句和多重继承比较相似"><a href="#goto语句和多重继承比较相似" class="headerlink" title="goto语句和多重继承比较相似"></a>goto语句和多重继承比较相似</h3><p>多重继承导致的问题：</p>
<ol>
<li>结构复杂化</li>
<li>优先顺序模糊</li>
<li>功能冲突</li>
</ol>
<h3 id="解决多重继承的问题"><a href="#解决多重继承的问题" class="headerlink" title="解决多重继承的问题"></a>解决多重继承的问题</h3><p>继承作为抽象化的手段，是需要实现多重继承功能的，如果一个类只允许抽出一个功能，那么限制就太多了。<br>受限制的多重继承，这个解决或改善多重继承问题的方法出现了，它在Java中被称为接口（interface）,在Lisp或Ruby中是Mix-in。</p>
<h3 id="静态语言与动态语言的区别"><a href="#静态语言与动态语言的区别" class="headerlink" title="静态语言与动态语言的区别"></a>静态语言与动态语言的区别</h3><p>编程语言可以分为静态语言和动态语言两种。像Java这样规定变量和算式类型的语言称为静态语言。<br>在静态语言中，不能给变量赋不同类型的值，会导致编译错误，不通过执行就可以发现类型不匹配是静态语言的一个优点。<br>如果只能给一个变量赋值同类对象，就不可能根据对象的类自动选择合适的处理方式（多态性）。</p>
<h3 id="静态语言的特点"><a href="#静态语言的特点" class="headerlink" title="静态语言的特点"></a>静态语言的特点</h3><p>当给一个类变量赋值时，既可以用这个类的对象来赋值，也可以用这个类的子类对象来赋值。这样就可以实现多态性。<br>但是这时，如果定义了父类变量，赋值子类对象，变量不能调用子类特有的方法。</p>
<h3 id="动态语言的特点"><a href="#动态语言的特点" class="headerlink" title="动态语言的特点"></a>动态语言的特点</h3><p>动态语言允许调用没有继承关系的方法。静态语言中只能调用有继承关系的方法，数组、哈希表和字符串都能调用的方法，只能是在它们共同的父类（恐怕是Object）中定义。<br>在静态语言中，如果要调用类层次中平行类的方法，那么必须要有一个可以表现这些对象的类型。如果没有这个类型，可调用的方法是十分有限的。由此我们看到静态语言中某种形式的多重继承是不可少的。</p>
<h3 id="静态语言与动态语言的比较"><a href="#静态语言与动态语言的比较" class="headerlink" title="静态语言与动态语言的比较"></a>静态语言与动态语言的比较</h3><p>静态语言即使不通过执行也可以检查出类型是否匹配。但是逐个来定义算式和变量的类型又会使程序变得冗长。只有包含继承关系的类才会具有多态性。<br>对于动态语言来说，静态语言显得限制过多，灵活性差。程序中有没有错误只有执行了才会知道。程序中没有类型定义，这样程序会变得很简洁。只要方法名一样，这些对象可以以相同的方式去处理。这样生产效率会大大提高，这种宽松的编程机制称为Duck Typing（鸭子类型检测）</p>
<h3 id="继承的两种含义"><a href="#继承的两种含义" class="headerlink" title="继承的两种含义"></a>继承的两种含义</h3><p>继承包括两种含义，一种是“<strong>类都有哪些方法</strong>”，也就是说这个类都支持些什么操作，即规格的继承。<br>另一种是“<strong>类中都用了什么数据结构什么算法</strong>”，也就是实现的继承。<br>静态语言中这两者的区别很重要，动态语言中区别规格的继承和实现的继承意义不大。即使没有继承关系，方法也可以自由地调用。<br>java对两者有很明确的区分，实现的继承用extends来继承父类，规格的继承用implements来指定接口。<br>类是用来指定对象实现的，而接口只是指定对象的外观（都有哪些方法）。类的继承是单一的，implements可以指定多个接口。接口对实现没有任何限制，也就是说，接口可以由跟实现的继承没有任何关系的类来实现。</p>
<h3 id="接口的缺点"><a href="#接口的缺点" class="headerlink" title="接口的缺点"></a>接口的缺点</h3><p>为了解决多重继承的问题，人们允许了规格的多重继承，但是还是不允许实现多重继承。</p>
<h3 id="继承实现的方法"><a href="#继承实现的方法" class="headerlink" title="继承实现的方法"></a>继承实现的方法</h3><p>和静态语言Java不同，动态语言本来就没有继承规格这种概念。动态语言需要解决的就是实现的多重继承。<br>Lisp、Perl和Python都提供了多重继承功能，这样就不存在单一继承的问题了。</p>
<h3 id="从多重继承变形而来的Mix-in"><a href="#从多重继承变形而来的Mix-in" class="headerlink" title="从多重继承变形而来的Mix-in"></a>从多重继承变形而来的Mix-in</h3><p>Mix-in是降低多重继承复杂性的一个技术，最初是在Lisp中开始使用的。按以下规则来限制多重继承：</p>
<ol>
<li>通常的继承用单一继承</li>
<li>第二个以及两个以上的父类必须是Mix-in的抽象类。</li>
</ol>
<p>Mix-in类是具有以下特征的抽象类。</p>
<ol>
<li>不能单独生成实例</li>
<li>不能继承普通类</li>
</ol>
<h3 id="积极支持Mix-in的Ruby"><a href="#积极支持Mix-in的Ruby" class="headerlink" title="积极支持Mix-in的Ruby"></a>积极支持Mix-in的Ruby</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8B%E5%8D%885.39.58.png" alt="屏幕快照 2018-07-04 下午5.39.58" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-04 下午5.39.58</div>
            </figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我理解的接口的作用：接口是一种协议，满足同一接口实际上是告诉计算机你们是满足了同一样协议，你们是有关系的，java以这种方式间接实现了多态。当然可以实现多个接口，抽象为不同的“种类”，这样就相当于某种意义上的”多继承“。</span><br><span class="line"></span><br><span class="line">InterA a;</span><br><span class="line">　　a= new B();</span><br><span class="line">　　a.fun();</span><br><span class="line">　　a = new C();</span><br><span class="line">　　a.fun();</span><br><span class="line">　　bc都实现a的接口</span><br></pre></td></tr></table></figure>
<h2 id="两个误解"><a href="#两个误解" class="headerlink" title="两个误解"></a>两个误解</h2><ol>
<li>对象是对现实世界中具体物体的反应，继承是对物体分类的反应。（误）</li>
<li>多重继承是不好的。Mix-in不错。（误）</li>
</ol>
<p>澄清：如果多继承用的不好就会出问题，Mix-in只不过是实现多重继承的一个技巧而已。</p>
<h3 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a>面向对象的编程</h3><p>不管过去怎样，现在面向对象最好的理解是，面向对象编程是结构化编程的延伸。<br>随着软件的复杂化，开发越来越复杂，Dijkstra提倡把程序控制限制为（1）顺序（2）循环（3）分支 使得程序变得简单且容易理解。<strong>面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上对数据的结构化。</strong><br>面向对象编程，封装（黑盒）和多态（减少分支处理）是提高生产率的技术。<br><strong>结构化编程通过整理数据流，提高程序的生成效率和可维护性。同样，面向对象编程通过对数据结构的整理，提高了程序的生产效率和可维护性。</strong></p>
<h3 id="对象的模板-类"><a href="#对象的模板-类" class="headerlink" title="对象的模板=类"></a>对象的模板=类</h3><p>类是吧数据黑盒化的工具，由于对类内部的操作都是通过类的方法来实现的，所以内部数据结构即使在以后发生变化，对外部也没有影响。</p>
<h3 id="利用模板的手段-继承"><a href="#利用模板的手段-继承" class="headerlink" title="利用模板的手段=继承"></a>利用模板的手段=继承</h3><p>类是模块，继承就是利用模块的方法。传统的面向对象编程语言是一下子把规格和实现都继承下来，在最近，有的是把这两种继承分开了。比如java里的接口就是规格继承。</p>
<h3 id="多重继承不好吗"><a href="#多重继承不好吗" class="headerlink" title="多重继承不好吗"></a>多重继承不好吗</h3><p>单一继承的类之间的关系是很单纯的树结构。但是对于多重继承而言，类之间的关系却是复杂得网状结构。<br><strong>静态语言中可以实现多态性只是局限于拥有共通父类的对象。</strong><br>为了解决这个问题，静态面向对象编程语言的代表<strong>C++支持多重继承</strong>。java也可以通过接口来支持规格的多重继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**静态类型语言**: 是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型，某些具有类型推导能力的现代语言可能能够部分减轻这个要求. </span><br><span class="line">**动态类型语言**: 是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 </span><br><span class="line">**强类型语言**: 是一旦变量的类型被确定，就不能转化的语言。实际上所谓的貌似转化，都是通过中间变量来达到，原本的变量的类型肯定是没有变化的。 </span><br><span class="line">**弱类型语言**: 则反之，一个变量的类型是由其应用上下文确定的。比如语言直接支持字符串和整数可以直接用 + 号搞定。当然，在支持运算符重载的强类型语言中也能通过外部实现的方式在形式上做到这一点，不过这个是完全不一样的内涵</span><br></pre></td></tr></table></figure></p>
<h3 id="动态编程语言也需要多重继承"><a href="#动态编程语言也需要多重继承" class="headerlink" title="动态编程语言也需要多重继承"></a>动态编程语言也需要多重继承</h3><p>动态编程语言没有类型检查，从这方面来说没有理由用多重继承，但是动态编程语言肯定需要多重继承。<br>实现共享可以通过多个对象的组合（composition）和委托（delegate）来做到。</p>
<h3 id="驯服多重继承的方法"><a href="#驯服多重继承的方法" class="headerlink" title="驯服多重继承的方法"></a>驯服多重继承的方法</h3><p>多重继承可能引发的问题：</p>
<ol>
<li>类关系复杂化</li>
<li>继承功能名字重复<br>最初的问题是因为类关系从简单的树结构变成了复杂的网状结构。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%889.18.30.png" alt="屏幕快照 2018-07-05 上午9.18.30" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-05 上午9.18.30</div>
            </figure>
</li>
</ol>
<p>父类的优先级并不明确，多重继承设计的一个有效的技巧是Mix-in。用Mix-in做多继承设计时，从第2个父类开始的类要满足以下条件。</p>
<ol>
<li>不能单独生成实例的抽象类。</li>
<li>不能继承Mix-in以外的类。</li>
</ol>
<p><strong>抽象类和接口的对比</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.41.50.png" alt="屏幕快照 2018-07-05 上午10.41.50" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-05 上午10.41.50</div>
            </figure></p>
<p>mix-in的例子<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.44.57.png" alt="屏幕快照 2018-07-05 上午10.44.57" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-05 上午10.44.57</div>
            </figure></p>
<p><strong>通过对功能的分离，多重继承就可以由单一继承加上Mix-in类来实现。</strong>利用Mix-in就可以同时享有单一继承的单纯性和多重继承的共有性。</p>
<p>对于名字重复问题（如函数名），多重继承编程语言都有自己的应对方法，大致分为以下3种：</p>
<ol>
<li>给父类定义优先级</li>
<li>把重复的名字替换掉</li>
<li>指定使用类的名字</li>
</ol>
<h3 id="ruby中多重继承的实现方法"><a href="#ruby中多重继承的实现方法" class="headerlink" title="ruby中多重继承的实现方法"></a>ruby中多重继承的实现方法</h3><p>Mix-in</p>
<h3 id="java实现多重继承的方法"><a href="#java实现多重继承的方法" class="headerlink" title="java实现多重继承的方法"></a>java实现多重继承的方法</h3><p>接口。。</p>
<h2 id="Duck-Typing诞生之前"><a href="#Duck-Typing诞生之前" class="headerlink" title="Duck Typing诞生之前"></a>Duck Typing诞生之前</h2><p>静态是指程序执行之前，从代码中就可以知道一切。程序静态的部分包括变量、方法的名称和类型以及控制程序的结构等等。<br>相对于静态，动态是指在程序执行之前有些地方是不知道的。程序动态的部分包括变量的值、执行时间和使用的内存等等。<br>通常情况下、程序本来就是不被执行就不知道结果的，所以在一定程度上说程序都具有动态特性。因此，严格说静态和动态之间的界限是很微妙的。</p>
<h3 id="为什么需要类型"><a href="#为什么需要类型" class="headerlink" title="为什么需要类型"></a>为什么需要类型</h3><h3 id="动态的类型是从Lisp中诞生的"><a href="#动态的类型是从Lisp中诞生的" class="headerlink" title="动态的类型是从Lisp中诞生的"></a>动态的类型是从Lisp中诞生的</h3><h3 id="动态类型在面向对象中发展起来了"><a href="#动态类型在面向对象中发展起来了" class="headerlink" title="动态类型在面向对象中发展起来了"></a>动态类型在面向对象中发展起来了</h3><p>对象保存着有关自己种类的信息，某个变量可以用各种类型的数据来赋值，这两点是多态这一面向对象重要特性的必要条件。</p>
<h3 id="动态类型和静态类型的邂逅"><a href="#动态类型和静态类型的邂逅" class="headerlink" title="动态类型和静态类型的邂逅"></a>动态类型和静态类型的邂逅</h3><p>20世纪80年代，面向对象编程语言主流是包含动态数据类型的语言，但是在21世纪的今天，使用最广泛的面向对象编程语言是具有静态类型的java和c++。<br>受simula很大影响的c++引入了子类对象可以看成是父类对象这个原则，对象也采用了静态类型。<br>根据这个原则，在编译时就可以知道变量或算式的类型，又可以根据执行时的数据类型自动选择合适的处理，从而同时具备了静态类型的优点和动态类型的多态性。</p>
<h3 id="静态类型的优点"><a href="#静态类型的优点" class="headerlink" title="静态类型的优点"></a>静态类型的优点</h3><ol>
<li>最大的优点是在编译时能够发现不匹配的错误。</li>
<li>如果明确指定了数据类型，在编译时可以用到的信息就很多，利用这种信息可以在编译时对程序做优化，提高程序执行速度。</li>
<li>在读程序时提高理解度，IDE也可以自动补充。</li>
</ol>
<p>问题：</p>
<ol>
<li>不指定类型就写不了程序，数据类型只是一些辅助信息，并不是程序本质。有的类型声明仅仅是为了满足编译器的要求。程序规模也因为数据类型的定义而变大。</li>
<li>灵活性问题。静态类型本身限制了给某个变量只能赋值某种类型的对象，这种限制可能成为妨碍将来变化的枷锁。 <h3 id="动态类型的优点"><a href="#动态类型的优点" class="headerlink" title="动态类型的优点"></a>动态类型的优点</h3></li>
<li>源代码简洁，提高生产力。</li>
<li>会不会更难以理解，更突出程序处理的实质，程序函数相差几十倍并不少见，理解起来反而简单。</li>
<li>会不会运行更缓慢，同样的处理，在大多数情况下，静态类型编程语言运行得要快些。这是因为动态类型程序执行时要做类型检查。另外，静态类型的编程语言大都是通过编译把程序源代码转换成可以直接执行的形式，而动态类型的编程语言大多是边解释源代码（转换成内部形式）边执行，这种编译型处理和解释型处理的区别也是影响程序执行速度的愿意之一。</li>
<li>灵活，灵活性的关键是Duck Typing。</li>
<li>最大的缺点是不执行就检测不出错误。  </li>
</ol>
<h3 id="只关心行为的Duck-Typing"><a href="#只关心行为的Duck-Typing" class="headerlink" title="只关心行为的Duck Typing"></a>只关心行为的Duck Typing</h3><p>If it walks like a duck and quacks like a duck,it must be a duck.（走起路来像鸭子，叫起来也像鸭子，那么他就是鸭子）。<br>根本不考虑一个对象属于什么类，只关心它有什么样的行为（它有哪些方法）。<br><strong>动态语言用Duck Typing的概念设计时需要遵循的原则最低限度是避免明确的类型检查。</strong></p>
<h3 id="避免明确的类型检查"><a href="#避免明确的类型检查" class="headerlink" title="避免明确的类型检查"></a>避免明确的类型检查</h3><h3 id="克服动态类型的缺点"><a href="#克服动态类型的缺点" class="headerlink" title="克服动态类型的缺点"></a>克服动态类型的缺点</h3><ol>
<li>执行时才能发现可以用完备的单元测试来解决，如果能严格实行完备的单元测试的话，即使没有编译时的错误检查，程序的可靠性也不会降低。</li>
<li>读程序时可用到的线索少这一点可以通过完整的文档来解决。可以在源代码中同时写文档，减轻维护文档的负担。</li>
<li>运行速度慢，随着计算机性能的提升已经不再重要，现在的程序开发中，程序的灵活性和生产力更为重要。</li>
</ol>
<h3 id="动态编程语言"><a href="#动态编程语言" class="headerlink" title="动态编程语言"></a>动态编程语言</h3><p>现在我们对程序开发生产力的要求越来越高，也就是说，要在更短的时间内开发出更多的功能。<br>尽快着手开发，快速应对需求变更的开发方式变得越来越重要。<br>在这种快速开发模式中，Duck Typing所代表的执行时的灵活性就非常有用。Ruby、Python、Perl和PHP等优秀的动态类型编程语言，因为它们在执行时所具有的灵活性而越来越受到人们的关注。</p>
<h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><p>元编程是对程序进行编程的意思。</p>
<h3 id="元编程-1"><a href="#元编程-1" class="headerlink" title="元编程"></a>元编程</h3><p>利用元编程可以动态生成类的方法，而且重要的是你可以自己编写生成过程，不支持元编程的编程语言实现这样的功能是很麻烦的，要么需要扩展语言的语法，要么用宏定义等预处理方法来实现。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>元编程的反射（reflection）,在编程语言中它是指在程序执行时取出程序的信息或者改变程序的信息。<br>Ruby彻底实现了对程序的动态操作。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8B%E5%8D%887.10.21.png" alt="屏幕快照 2018-07-05 下午7.10.21" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-05 下午7.10.21</div>
            </figure>
<h3 id="元编程的例子"><a href="#元编程的例子" class="headerlink" title="元编程的例子"></a>元编程的例子</h3><p>Ruby使用Delegator这个库实现了委托功能，调用对象d的方法时可以转变为调用a的方法。我们还可以给这个对象增加特意方法来改变它的部分行为，这就大大扩展了它的应用范围。</p>
<h3 id="使用反射功能"><a href="#使用反射功能" class="headerlink" title="使用反射功能"></a>使用反射功能</h3><h3 id="分布式Ruby的实现"><a href="#分布式Ruby的实现" class="headerlink" title="分布式Ruby的实现"></a>分布式Ruby的实现</h3><p>Delegator将被调用的方法直接委派到其他对象，这一功能在很多领域都有应用。如dRuby。<br>dRuby是通过网络来调用方法的库。dRuby可以生成服务器上存在的远程对象（Proxy），Proxy的方法调用可以通过网络执行。<br>调用的方法在服务器上的远程对象中执行，执行结果可以通过网络返回。这和java的RMI(Remote Method Invocation)功能比较相似。但是，利用Ruby的元编程功能，不用明确定义接口，也可以通过网络调用任一对象的方法。<br>C++和Java的远程调用是用IDL（Interface Definition Language）等语言来定义接口的，自动生成的存根（stub）必须编译和连接。和这些相比，Ruby的元编程更简单。</p>
<h3 id="数据库的应用"><a href="#数据库的应用" class="headerlink" title="数据库的应用"></a>数据库的应用</h3><p>在数据库领域，元编程也很有用。<br>web应用程序框架Ruby on Rails(也称为Rails或RoR)中也应用了元编程。具体地说是在与数据库关联的类库（ActiveRecord）中，利用元编程简单的把数据记录定义为对象。<br>由于元编程功能让我们可以获取类名，在执行时增加方法。元编程的功能使得Rails被称赞为生产效率高的Web应用程序框架。</p>
<h3 id="输出xml"><a href="#输出xml" class="headerlink" title="输出xml"></a>输出xml</h3><p>手工写XML是很麻烦的，利用Ruby块功能则可以很方便的处理。</p>
<h3 id="元编程和小编程语言"><a href="#元编程和小编程语言" class="headerlink" title="元编程和小编程语言"></a>元编程和小编程语言</h3><p>元编程功能可以运用到DSL领域，DSL是针对特定领域强化了功能的小规模编程语言。通过DSL用户可以强化应用程序的功能或者定制一些功能。</p>
<h3 id="声明的实现"><a href="#声明的实现" class="headerlink" title="声明的实现"></a>声明的实现</h3><p>Ruby的方法可以读取或改变程序自身的状态，利用普通的方法调用，可以实现其他编程语言中声明所完成的工作。</p>
<h3 id="上下文相关的实现"><a href="#上下文相关的实现" class="headerlink" title="上下文相关的实现"></a>上下文相关的实现</h3><p>instance_eval方法接受块作为参数，把调用对象置换成self来执行块。</p>
<h3 id="单位的实现"><a href="#单位的实现" class="headerlink" title="单位的实现"></a>单位的实现</h3><h3 id="词汇的实现"><a href="#词汇的实现" class="headerlink" title="词汇的实现"></a>词汇的实现</h3><p>针对特定领域，如果用Ruby来定义需要的类和方法，那么就可以认为Ruby是这个领域的专用语言。这些类和方法可以称为这个领域的词汇。</p>
<h3 id="层次数据的实现"><a href="#层次数据的实现" class="headerlink" title="层次数据的实现"></a>层次数据的实现</h3><h3 id="适合DSL的语言，不适合DSL的语言"><a href="#适合DSL的语言，不适合DSL的语言" class="headerlink" title="适合DSL的语言，不适合DSL的语言"></a>适合DSL的语言，不适合DSL的语言</h3><p>Ruby是非常适合DSL的语言。<br>首先定义好DSL用的小语言，然后编译成C++、java等目标语言。编译器经常用到Ruby这种具有优秀文本处理的语言。<br>另一种实现DSL方法的例子是解释器。比如开发应用程序时从设计到实现是很复杂的，可以利用固定的语法和类库函数来读取程序。具体方法是用XML、DOM等XML处理类库来解释小语言语法。这是Java应用程序的配置文件曹勇XML的原因之一。通过XML文件，不用每次编译Java程序就可以改变配置，定制程序的行为。<br>这种用法可以把XML称为Java界的DSL，或是Java应用程序的脚本语言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。</span><br><span class="line">早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是--解释运行--而非编译。虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。</span><br></pre></td></tr></table></figure></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-07-25T02:33:55.000Z" itemprop="dateUpdated">2018-07-25 10:33:55</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://github.com/zdkswd">
            <img src="/img/tmg.jpg" alt="ZDK">
            ZDK
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/电子书笔记/">电子书笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序语言/">程序语言</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/&title=《松本行弘的程序世界 2 面向对象》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/&title=《松本行弘的程序世界 2 面向对象》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《松本行弘的程序世界 2 面向对象》 — ZDK's blog&url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/07/06/艺术的力量 卡拉瓦乔/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">艺术的力量 卡拉瓦乔</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">周海宏音乐鉴赏 一 打开你的耳朵</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz",
            appKey: "gkBx5soQkBREmER84PWbNJeM",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>ZDK &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/&title=《松本行弘的程序世界 2 面向对象》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/&title=《松本行弘的程序世界 2 面向对象》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《松本行弘的程序世界 2 面向对象》 — ZDK's blog&url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'zdk'blog';
            clearTimeout(titleTime);
        } else {
            document.title = '';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
