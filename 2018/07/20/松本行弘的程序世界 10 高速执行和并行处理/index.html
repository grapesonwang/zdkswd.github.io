<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>松本行弘的程序世界 10 高速执行和并行处理 | ZDK&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="电子书笔记,程序语言">
    <meta name="description" content="松本行弘的程序世界 10 高速执行和并行处理让程序高速执行（前篇）是不是越快越好并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。 高速执行的乐趣与效率在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。 以数据为基础做出判断改善系统调用排序处理任务重时，典型的对策是使用施瓦茨变换。 数据可靠吗误差 只需改善瓶颈性能优化中，“因为是排">
<meta name="keywords" content="电子书笔记,程序语言">
<meta property="og:type" content="article">
<meta property="og:title" content="松本行弘的程序世界 10 高速执行和并行处理">
<meta property="og:url" content="https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:description" content="松本行弘的程序世界 10 高速执行和并行处理让程序高速执行（前篇）是不是越快越好并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。 高速执行的乐趣与效率在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。 以数据为基础做出判断改善系统调用排序处理任务重时，典型的对策是使用施瓦茨变换。 数据可靠吗误差 只需改善瓶颈性能优化中，“因为是排">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8A%E5%8D%8811.05.39.png">
<meta property="og:image" content="https://github.com/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%881.55.11.png">
<meta property="og:image" content="https://github.com/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.05.36.png">
<meta property="og:image" content="https://github.com/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.08.13.png">
<meta property="og:updated_time" content="2018-07-20T10:06:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="松本行弘的程序世界 10 高速执行和并行处理">
<meta name="twitter:description" content="松本行弘的程序世界 10 高速执行和并行处理让程序高速执行（前篇）是不是越快越好并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。 高速执行的乐趣与效率在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。 以数据为基础做出判断改善系统调用排序处理任务重时，典型的对策是使用施瓦茨变换。 数据可靠吗误差 只需改善瓶颈性能优化中，“因为是排">
<meta name="twitter:image" content="https://github.com/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8A%E5%8D%8811.05.39.png">
    
        <link rel="alternate" type="application/atom+xml" title="ZDK&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/tmg.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">ZDK</h5>
          <a href="mailto:2822464407@qq.com" title="2822464407@qq.com" class="mail">2822464407@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zdkswd" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">松本行弘的程序世界 10 高速执行和并行处理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">松本行弘的程序世界 10 高速执行和并行处理</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-07-20T09:58:32.000Z" itemprop="datePublished" class="page-time">
  2018-07-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#松本行弘的程序世界-10-高速执行和并行处理"><span class="post-toc-number">1.</span> <span class="post-toc-text">松本行弘的程序世界 10 高速执行和并行处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#让程序高速执行（前篇）"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">让程序高速执行（前篇）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#是不是越快越好"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">是不是越快越好</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高速执行的乐趣与效率"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">高速执行的乐趣与效率</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#以数据为基础做出判断"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">以数据为基础做出判断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#改善系统调用"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">改善系统调用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据可靠吗"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">数据可靠吗</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#只需改善瓶颈"><span class="post-toc-number">1.1.6.</span> <span class="post-toc-text">只需改善瓶颈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#profiler本身成了累赘"><span class="post-toc-number">1.1.7.</span> <span class="post-toc-text">profiler本身成了累赘</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#算法与数据结构"><span class="post-toc-number">1.1.8.</span> <span class="post-toc-text">算法与数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#理解O记法"><span class="post-toc-number">1.1.9.</span> <span class="post-toc-text">理解O记法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择算法"><span class="post-toc-number">1.1.10.</span> <span class="post-toc-text">选择算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#调查算法的性能"><span class="post-toc-number">1.1.11.</span> <span class="post-toc-text">调查算法的性能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高速执行的悲哀"><span class="post-toc-number">1.1.12.</span> <span class="post-toc-text">高速执行的悲哀</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#徒劳无益的努力"><span class="post-toc-number">1.1.12.1.</span> <span class="post-toc-text">徒劳无益的努力</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#改良绊住了手脚"><span class="post-toc-number">1.1.12.2.</span> <span class="post-toc-text">改良绊住了手脚</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#算法选择的圈套"><span class="post-toc-number">1.1.12.3.</span> <span class="post-toc-text">算法选择的圈套</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#性能优化的格言"><span class="post-toc-number">1.1.13.</span> <span class="post-toc-text">性能优化的格言</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#让程序高速执行（后篇）"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">让程序高速执行（后篇）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#确认程序概要"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">确认程序概要</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#发现瓶颈"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">发现瓶颈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用更好地profiler"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">使用更好地profiler</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高速优化之一：消减对象"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">高速优化之一：消减对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#减少对象"><span class="post-toc-number">1.2.4.1.</span> <span class="post-toc-text">减少对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#减少方法调用"><span class="post-toc-number">1.2.4.2.</span> <span class="post-toc-text">减少方法调用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高速优化之二：利用立即值"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">高速优化之二：利用立即值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高速优化之三：利用C语言"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">高速优化之三：利用C语言</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高速优化之四：采用合适的数据结构"><span class="post-toc-number">1.2.7.</span> <span class="post-toc-text">高速优化之四：采用合适的数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#全部以C语言计算"><span class="post-toc-number">1.2.8.</span> <span class="post-toc-text">全部以C语言计算</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#还存在其他技巧"><span class="post-toc-number">1.2.9.</span> <span class="post-toc-text">还存在其他技巧</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#并行编程"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">并行编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用线程的理由"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">使用线程的理由</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生成线程"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">生成线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程的执行状态"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">线程的执行状态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#传递值给线程的方法"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">传递值给线程的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#信息共享所产生的问题"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">信息共享所产生的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据完整性的丧失"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">数据完整性的丧失</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#死锁"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">死锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用锁来实现对资源的独占"><span class="post-toc-number">1.3.8.</span> <span class="post-toc-text">用锁来实现对资源的独占</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二级互斥"><span class="post-toc-number">1.3.9.</span> <span class="post-toc-text">二级互斥</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用队列协调线程"><span class="post-toc-number">1.3.10.</span> <span class="post-toc-text">用队列协调线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#锁模型与队列模型的比较"><span class="post-toc-number">1.3.11.</span> <span class="post-toc-text">锁模型与队列模型的比较</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#锁模型"><span class="post-toc-number">1.3.11.1.</span> <span class="post-toc-text">锁模型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#队列模型"><span class="post-toc-number">1.3.11.2.</span> <span class="post-toc-text">队列模型</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前景可期的并行编程技术，Actor"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">前景可期的并行编程技术，Actor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#何谓Actor"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">何谓Actor</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作Actor的三种处理系统"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">操作Actor的三种处理系统</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Erlang的程序"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">Erlang的程序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pingpong处理的开始"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">pingpong处理的开始</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#启动pingpong程序"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">启动pingpong程序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Erlang的错误处理"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">Erlang的错误处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Erlang的使用场所"><span class="post-toc-number">1.4.7.</span> <span class="post-toc-text">Erlang的使用场所</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向Ruby的库“Revactor”"><span class="post-toc-number">1.4.8.</span> <span class="post-toc-text">面向Ruby的库“Revactor”</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#另一个库Dramatis"><span class="post-toc-number">1.4.9.</span> <span class="post-toc-text">另一个库Dramatis</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-松本行弘的程序世界 10 高速执行和并行处理"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">松本行弘的程序世界 10 高速执行和并行处理</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-07-20 17:58:32" datetime="2018-07-20T09:58:32.000Z"  itemprop="datePublished">2018-07-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="松本行弘的程序世界-10-高速执行和并行处理"><a href="#松本行弘的程序世界-10-高速执行和并行处理" class="headerlink" title="松本行弘的程序世界 10 高速执行和并行处理"></a>松本行弘的程序世界 10 高速执行和并行处理</h1><h2 id="让程序高速执行（前篇）"><a href="#让程序高速执行（前篇）" class="headerlink" title="让程序高速执行（前篇）"></a>让程序高速执行（前篇）</h2><h3 id="是不是越快越好"><a href="#是不是越快越好" class="headerlink" title="是不是越快越好"></a>是不是越快越好</h3><p>并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。</p>
<h3 id="高速执行的乐趣与效率"><a href="#高速执行的乐趣与效率" class="headerlink" title="高速执行的乐趣与效率"></a>高速执行的乐趣与效率</h3><p>在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。</p>
<h3 id="以数据为基础做出判断"><a href="#以数据为基础做出判断" class="headerlink" title="以数据为基础做出判断"></a>以数据为基础做出判断</h3><h3 id="改善系统调用"><a href="#改善系统调用" class="headerlink" title="改善系统调用"></a>改善系统调用</h3><p>排序处理任务重时，典型的对策是使用施瓦茨变换。</p>
<h3 id="数据可靠吗"><a href="#数据可靠吗" class="headerlink" title="数据可靠吗"></a>数据可靠吗</h3><p>误差</p>
<h3 id="只需改善瓶颈"><a href="#只需改善瓶颈" class="headerlink" title="只需改善瓶颈"></a>只需改善瓶颈</h3><p>性能优化中，“因为是排序，所以就用施瓦茨变换”这种条件反射式的对策并非总管用。为了合理提高速度，确立恰当的策略是很必要的。<br>帕累托法则又称80/20法则，即80%的数值是由20%的构成要素产生的。由帕累托法则可知，有20%的努力可以达到巨大回报，而有80%的努力得不到多少回报。在得不到回报的地方，不管怎么努力都是徒劳的。<br>Donald Knuth也提到，通常一半以上的执行时间都耗费在程序中不到4%的部分。<br>这些耗费了大半以上执行时间的部分称为瓶颈。<br>判定瓶颈，可以用profiler这一工具。</p>
<h3 id="profiler本身成了累赘"><a href="#profiler本身成了累赘" class="headerlink" title="profiler本身成了累赘"></a>profiler本身成了累赘</h3><p>不确定性原理是指测定行为本身对被测对象产生了影响，从原理上可以说不可能正确知道对象的状态。但是知道实际状态的大体倾向。</p>
<h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>选择合适的算法，这是性能改善的第一考虑因素，要记住这条铁则。</p>
<h3 id="理解O记法"><a href="#理解O记法" class="headerlink" title="理解O记法"></a>理解O记法</h3><p>如何从效率方面判定一个算法的好坏呢。一个方法就是O记法，表示某种算法对于变量（比如使用的元素个数）如何变化。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8A%E5%8D%8811.05.39.png" alt="屏幕快照 2018-07-20 上午11.05.39" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-20 上午11.05.39</div>
            </figure></p>
<h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><h3 id="调查算法的性能"><a href="#调查算法的性能" class="headerlink" title="调查算法的性能"></a>调查算法的性能</h3><p>Ruby提供进行算法性能比较时用的benchmark程序。</p>
<h3 id="高速执行的悲哀"><a href="#高速执行的悲哀" class="headerlink" title="高速执行的悲哀"></a>高速执行的悲哀</h3><h4 id="徒劳无益的努力"><a href="#徒劳无益的努力" class="headerlink" title="徒劳无益的努力"></a>徒劳无益的努力</h4><p>很容易在瓶颈无关的地方花费太多徒劳无益的努力。</p>
<h4 id="改良绊住了手脚"><a href="#改良绊住了手脚" class="headerlink" title="改良绊住了手脚"></a>改良绊住了手脚</h4><p>sort_by所依据的施瓦茨变换，是用时间和空间的交换来消减计算量的方法。sort_by方法与sort方法相比，占用了多达三倍以上的内存。所以，模块内的处理本来不是很重，如果一味地占用内存反而可能会变慢。<br>性能优化，光有理论还不行，如果不实际做的话就不知道到底什么是正确的。</p>
<h4 id="算法选择的圈套"><a href="#算法选择的圈套" class="headerlink" title="算法选择的圈套"></a>算法选择的圈套</h4><p>在进行性能优化时，不改变原来程序的执行时一个大原则。</p>
<h3 id="性能优化的格言"><a href="#性能优化的格言" class="headerlink" title="性能优化的格言"></a>性能优化的格言</h3><p><strong>过早的优化是万恶之源。</strong></p>
<p><strong>优化有两条准则。</strong><br><strong>1.别做优化</strong><br><strong>2.（仅适用于专家）先不要做优化</strong></p>
<h2 id="让程序高速执行（后篇）"><a href="#让程序高速执行（后篇）" class="headerlink" title="让程序高速执行（后篇）"></a>让程序高速执行（后篇）</h2><p>例题是曼德勃罗集合的计算程序，指复平面上满足以下条件的复素数的集合：经过某种反复迭代运算以后，其值不会发散到无限大。</p>
<h3 id="确认程序概要"><a href="#确认程序概要" class="headerlink" title="确认程序概要"></a>确认程序概要</h3><h3 id="发现瓶颈"><a href="#发现瓶颈" class="headerlink" title="发现瓶颈"></a>发现瓶颈</h3><p>使用profiler</p>
<h3 id="使用更好地profiler"><a href="#使用更好地profiler" class="headerlink" title="使用更好地profiler"></a>使用更好地profiler</h3><p>ruby-prof程序通过使用扩展库可以实现高速profile</p>
<h3 id="高速优化之一：消减对象"><a href="#高速优化之一：消减对象" class="headerlink" title="高速优化之一：消减对象"></a>高速优化之一：消减对象</h3><p>Ruby高速优化的规则。</p>
<h4 id="减少对象"><a href="#减少对象" class="headerlink" title="减少对象"></a>减少对象</h4><p>高级面向对象语言中对象的生成要花费一定的时间，减少对象，除了会降低生成成本外，还有别的好处。<br>Ruby中不在使用的对象，由被称作垃圾收集的处理自动进行回收。垃圾收集处理需要检查对象的引用关系，任何地方都不再引用的对象会被判定为已经不再使用了。当对象的数量很多时，判断成本就要增大。</p>
<h4 id="减少方法调用"><a href="#减少方法调用" class="headerlink" title="减少方法调用"></a>减少方法调用</h4><p>方法调用中，存在多态性这一面向对象的本质特征，先要评价参数，判定对象种类，然后选出一个合适的方法，再讲控制交给该方法，这是一个缓慢的处理过程。<br>为了避开方法调用，尽可能不用Ruby中实现的方法。Ruby中实现的方法，几乎所有的情况都是调用其他方法来实现的。也就是说，只要使用了一次Ruby中实现的方法，就会有多余的方法调用发生。</p>
<h3 id="高速优化之二：利用立即值"><a href="#高速优化之二：利用立即值" class="headerlink" title="高速优化之二：利用立即值"></a>高速优化之二：利用立即值</h3><p>Ruby中有几类对象并不实际分配内存，而是用引用本身来表示，这种值称为立即值。<br>现在的Ruby中，小的整数（±2    ^30以内）、真假值、nil和符号名等都是立即值。<br>立即值既然不生成对象，就不用担心对象的生成成本，而且也不用垃圾收集处理，所以它具有特别理想的特性。</p>
<h3 id="高速优化之三：利用C语言"><a href="#高速优化之三：利用C语言" class="headerlink" title="高速优化之三：利用C语言"></a>高速优化之三：利用C语言</h3><p>Ruby是解释性语言，单纯计算的循环不是很快。如果将处理交给编译器，就可以变得很快。</p>
<h3 id="高速优化之四：采用合适的数据结构"><a href="#高速优化之四：采用合适的数据结构" class="headerlink" title="高速优化之四：采用合适的数据结构"></a>高速优化之四：采用合适的数据结构</h3><h3 id="全部以C语言计算"><a href="#全部以C语言计算" class="headerlink" title="全部以C语言计算"></a>全部以C语言计算</h3><h3 id="还存在其他技巧"><a href="#还存在其他技巧" class="headerlink" title="还存在其他技巧"></a>还存在其他技巧</h3><p>还有以空间换时间。</p>
<h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><p>与进程不同，同一进程的线程可以共享内存空间，所以，不同的线程能够引用同一对象。不需要经过将数据变为字节流再进行通信这样麻烦的处理，就能交换信息。</p>
<h3 id="生成线程"><a href="#生成线程" class="headerlink" title="生成线程"></a>生成线程</h3><h3 id="线程的执行状态"><a href="#线程的执行状态" class="headerlink" title="线程的执行状态"></a>线程的执行状态</h3><p>Ruby的线程有四种状态。<br>run：执行中<br>stop：停止中<br>to_kill:终止处理中<br>killed:终止<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%881.55.11.png" alt="屏幕快照 2018-07-20 下午1.55.11" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-20 下午1.55.11</div>
            </figure></p>
<h3 id="传递值给线程的方法"><a href="#传递值给线程的方法" class="headerlink" title="传递值给线程的方法"></a>传递值给线程的方法</h3><h3 id="信息共享所产生的问题"><a href="#信息共享所产生的问题" class="headerlink" title="信息共享所产生的问题"></a>信息共享所产生的问题</h3><ol>
<li>数据完整性丧失</li>
<li>死锁</li>
</ol>
<p><strong>与其说是线程的问题，不如说是并行处理本身的问题。</strong></p>
<h3 id="数据完整性的丧失"><a href="#数据完整性的丧失" class="headerlink" title="数据完整性的丧失"></a>数据完整性的丧失</h3><p>原子操作</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>哲学家进餐问题</p>
<h3 id="用锁来实现对资源的独占"><a href="#用锁来实现对资源的独占" class="headerlink" title="用锁来实现对资源的独占"></a>用锁来实现对资源的独占</h3><p>Ruby Mutex类，互斥锁。<br>Java中，方法定义声明为synchronize,该方法被调用时自动加锁。</p>
<h3 id="二级互斥"><a href="#二级互斥" class="headerlink" title="二级互斥"></a>二级互斥</h3><p>很遗憾，锁的问题并不全是Mutex所能覆盖的单纯事例。如数据库中，对数据的访问需要以下多种互斥控制。</p>
<ol>
<li>可以同时引用</li>
<li>禁止同时更新</li>
<li>禁止更新中引用</li>
<li>禁止引用中更新</li>
</ol>
<p>引用与更新这种两个层次的互斥（二级互斥），在文件读取时也经常会发生。</p>
<h3 id="用队列协调线程"><a href="#用队列协调线程" class="headerlink" title="用队列协调线程"></a>用队列协调线程</h3><p>使用锁对资源进行互斥控制，是线程间保证协调的一种机制。除了锁以外，为了保证协调，还有别的方法。<br>问题的根源在于多个进程访问同一资源，为了实现无共享，给每个资源准备一个管理用的线程，各线程间只能交换某些限定的信息。<br>线程间信息交换的方法有代表性的有信息存储，信道及队列。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.05.36.png" alt="屏幕快照 2018-07-20 下午3.05.36" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-20 下午3.05.36</div>
            </figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的生产者消费者问题并不是典型的生成者消费者问题，而是做出了一定的限制，即生产速度小于消费速度。不锁buffer,仅做信息传递的通道来进行说明。</span><br></pre></td></tr></table></figure>
<p>队列也可以用于解决资源的竞争。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.08.13.png" alt="屏幕快照 2018-07-20 下午3.08.13" title="">
                </div>
                <div class="image-caption">屏幕快照 2018-07-20 下午3.08.13</div>
            </figure></p>
<h3 id="锁模型与队列模型的比较"><a href="#锁模型与队列模型的比较" class="headerlink" title="锁模型与队列模型的比较"></a>锁模型与队列模型的比较</h3><h4 id="锁模型"><a href="#锁模型" class="headerlink" title="锁模型"></a>锁模型</h4><p>如果竞争足够少，多数情况下能保持较高性能，对于资源的竞争，不能忘记加锁，要做到完美无缺较难。</p>
<h4 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h4><p>在竞争少的时候，其性能比不上锁模型，比锁模型更容易贯彻，会因线程增多而带来性能低下的恶果。</p>
<h2 id="前景可期的并行编程技术，Actor"><a href="#前景可期的并行编程技术，Actor" class="headerlink" title="前景可期的并行编程技术，Actor"></a>前景可期的并行编程技术，Actor</h2><p>并行编程，要求有更高的抽象度和对人类而言更简单的编程模型。Actor（参与者模式）或许就是答案。</p>
<h3 id="何谓Actor"><a href="#何谓Actor" class="headerlink" title="何谓Actor"></a>何谓Actor</h3><p>所谓Actor，是（仅）通过消息（message）进行通信的实体。<br>与面向对象语言中对象的区别。向对象发送消息（方法调用），调用开始后，会一直等到返回结果，是一种同步方式。面向Actor发送消息，仅仅是发送消息而不返回结果，是一种异步方式。<br>Actor由于仅仅通过消息进行信息交换，所以不能直接共享同一个值，信息传达要多花些代价。<br>Actor由于没有消息以外的信息传递手段，所以不用担心Actor之间的资源竞争。发送给Actor的消息都配送到各个Actor所拥有的邮箱里。多个消息同时到达时竞争由内嵌到系统中的排除机制来处理。<br>Actor的一大优点是安全，更大的优点是易懂。Actor根据消息进行处理，必要的化会向其他Actor传递消息，或向Actor返回消息。<br>这与现实世界中人与人之间相处没有多大的差别。现实世界中，别人在想什么你不知道，想要求什么时，需要通过某种手段传递“消息”。<br>理论上要到达最高性能，一般认为线程更优秀。但如果不注意使用线程的话，会出现与时机相关的很麻烦的问题。在计算机性能日益提高的今天，与理论上最高性能的可能性相比，Actor的安全性和易懂性更引人注目。</p>
<h3 id="操作Actor的三种处理系统"><a href="#操作Actor的三种处理系统" class="headerlink" title="操作Actor的三种处理系统"></a>操作Actor的三种处理系统</h3><p>Actor Model的函数型语言Erlang。<br>Erlang是只允许单一赋值的函数型语言，即一旦赋值，变量的值就不再改变。</p>
<h3 id="Erlang的程序"><a href="#Erlang的程序" class="headerlink" title="Erlang的程序"></a>Erlang的程序</h3><h3 id="pingpong处理的开始"><a href="#pingpong处理的开始" class="headerlink" title="pingpong处理的开始"></a>pingpong处理的开始</h3><h3 id="启动pingpong程序"><a href="#启动pingpong程序" class="headerlink" title="启动pingpong程序"></a>启动pingpong程序</h3><h3 id="Erlang的错误处理"><a href="#Erlang的错误处理" class="headerlink" title="Erlang的错误处理"></a>Erlang的错误处理</h3><p>Erlang中通过发送消息来通知异常终止。收到消息的process（actor）料理死去的process后事。<br>有了这种机制，使得Erlang适合构造抗障碍性强的系统。</p>
<h3 id="Erlang的使用场所"><a href="#Erlang的使用场所" class="headerlink" title="Erlang的使用场所"></a>Erlang的使用场所</h3><p>Erlang在通常的文本处理汇总并不怎么快。Erlang的好处在于其扩展性。对于多个处理并列执行的情况，分割成合适的Erlang process，能够发挥多CPU的威力。<br>同样的多任务分割虽然用操作系统的进程或线程也能实现，但Erlang的process与操作系统的进程或线程相比，能够轻量实现（1个process最小只耗费300字节），即使有大量process也不必顾虑、更进一步说，Erlang设计思想不用process连基本处理都不能实现，process分割在某种意义上可以说是强制的。</p>
<p>适合现代服务器端程序。</p>
<h3 id="面向Ruby的库“Revactor”"><a href="#面向Ruby的库“Revactor”" class="headerlink" title="面向Ruby的库“Revactor”"></a>面向Ruby的库“Revactor”</h3><p>Revactor的目的是为Ruby提供Erlang式的编程。<br>其优点是可以同时体验Ruby和Erlang的好处。但是Revactor中Actor的实现不是靠线程而是靠Fiber。Erlang的目的在于最大限度地利用多核CPU，而Revactor并不适合这种目的。<br>Revactor的最大优点，是能够在等待文件输入输出时，将程序的停止控制在最小程度。</p>
<h3 id="另一个库Dramatis"><a href="#另一个库Dramatis" class="headerlink" title="另一个库Dramatis"></a>另一个库Dramatis</h3><p>Dramatis是Ruby中另一个Actor库。函数型语言Erlang不支持面向对象功能。用Ruby这样的面向对象语言来实现Actor的时候，即使用普通对象来实现Actor，也不可避免地会出现把方法调用和发送消息这两种类似概念混在一起的情况。Dramatis库就是解答这种“概念混淆”。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-07-20T10:06:43.000Z" itemprop="dateUpdated">2018-07-20 18:06:43</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://github.com/zdkswd">
            <img src="/img/tmg.jpg" alt="ZDK">
            ZDK
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/电子书笔记/">电子书笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序语言/">程序语言</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/&title=《松本行弘的程序世界 10 高速执行和并行处理》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/&title=《松本行弘的程序世界 10 高速执行和并行处理》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《松本行弘的程序世界 10 高速执行和并行处理》 — ZDK's blog&url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Android群英传 3 Android控件架构与自定义控件详解</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz",
            appKey: "gkBx5soQkBREmER84PWbNJeM",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>ZDK &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/&title=《松本行弘的程序世界 10 高速执行和并行处理》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/&title=《松本行弘的程序世界 10 高速执行和并行处理》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《松本行弘的程序世界 10 高速执行和并行处理》 — ZDK's blog&url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'zdk'blog';
            clearTimeout(titleTime);
        } else {
            document.title = '';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
