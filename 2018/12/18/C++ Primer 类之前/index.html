<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>C++ Primer 类之前 | ZDK&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++">
    <meta name="description" content="开始学习C++进入C++通常main()被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统的桥梁。 C++必修包含一个名为main()的函数，大小写拼写都要正确。如果没有main(),程序将不完整，编译器将指出未定义main()函数。 存在一些例外情况。例如,在 Windows编程中,可以编写一个动态链接库(DLL)模块,这是其他 Windows程序可以使用的代码。由于DLL模块">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 类之前">
<meta property="og:url" content="https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:description" content="开始学习C++进入C++通常main()被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统的桥梁。 C++必修包含一个名为main()的函数，大小写拼写都要正确。如果没有main(),程序将不完整，编译器将指出未定义main()函数。 存在一些例外情况。例如,在 Windows编程中,可以编写一个动态链接库(DLL)模块,这是其他 Windows程序可以使用的代码。由于DLL模块">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.31.15.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.37.40.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.07.29.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.16.46.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8811.16.54.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%885.31.32.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.06.13.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.12.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.28.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.15.40.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.19.03.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.53.48.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.55.44.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.01.00.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.34.29.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.00.23.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.03.45.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.24.49.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.32.13.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.28.12.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.40.08.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.47.20.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.50.58.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.55.23.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.35.33.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.39.48.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.45.19.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.49.06.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.08.10.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.51.00.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.58.45.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.50.50.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.57.33.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.11.22.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.13.07.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.43.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.56.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.23.35.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.27.27.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.32.27.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.34.24.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.38.00.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.57.51.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.00.46.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.07.31.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.11.34.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.12.35.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.18.59.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.16.46.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.21.48.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.22.43.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.23.07.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.27.13.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.30.45.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.31.11.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.53.50.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.58.29.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.03.35.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.58.11.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.50.00.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.51.34.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.59.47.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.09.51.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.15.31.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.19.56.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.28.33.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.49.29.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%886.12.10.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%884.26.08.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%885.39.32.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%886.15.14.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.08.16.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.10.42.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.21.59.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.31.28.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.32.48.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.34.04.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.36.28.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.47.25.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.55.18.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.56.18.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.59.13.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.00.15.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.12.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.52.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.12.54.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.19.27.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.20.31.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.21.21.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.22.56.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.34.27.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.36.37.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.53.54.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%888.56.12.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%889.00.42.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.36.24.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.37.33.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.54.10.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.07.30.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.09.57.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.14.41.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.21.44.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.25.40.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.51.42.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.56.12.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.03.53.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.12.05.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.25.02.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.22.33.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.31.50.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.06.52.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.10.57.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.15.45.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.17.30.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.24.18.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.40.38.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.00.48.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.05.34.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.18.47.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.39.02.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.40.40.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.43.15.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.15.54.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.44.01.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.46.19.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.54.32.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.26.40.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.40.36.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8810.57.59.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.01.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.41.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.50.33.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.52.13.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.05.02.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.11.15.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.16.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.40.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.54.35.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.12.05.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.13.21.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.23.43.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.07.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.54.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.39.56.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.09.28.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.31.48.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.53.00.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.54.21.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.13.35.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.14.52.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.15.03.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.25.14.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.26.44.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.09.52.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.24.43.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.32.31.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.11.32.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.39.59.png">
<meta property="og:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.48.41.png">
<meta property="og:updated_time" content="2018-12-18T07:31:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Primer 类之前">
<meta name="twitter:description" content="开始学习C++进入C++通常main()被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统的桥梁。 C++必修包含一个名为main()的函数，大小写拼写都要正确。如果没有main(),程序将不完整，编译器将指出未定义main()函数。 存在一些例外情况。例如,在 Windows编程中,可以编写一个动态链接库(DLL)模块,这是其他 Windows程序可以使用的代码。由于DLL模块">
<meta name="twitter:image" content="https://github.com/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.31.15.png">
    
        <link rel="alternate" type="application/atom+xml" title="ZDK&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/tmg.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">ZDK</h5>
          <a href="mailto:2822464407@qq.com" title="2822464407@qq.com" class="mail">2822464407@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zdkswd" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">C++ Primer 类之前</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">C++ Primer 类之前</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-12-18T07:07:56.000Z" itemprop="datePublished" class="page-time">
  2018-12-18
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/教程/">教程</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#开始学习C"><span class="post-toc-number">1.</span> <span class="post-toc-text">开始学习C++</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进入C"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">进入C++</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-预处理器和iostream文件"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">C++预处理器和iostream文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#头文件名"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">头文件名</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#名称空间"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">名称空间</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#处理数据"><span class="post-toc-number">2.</span> <span class="post-toc-text">处理数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简单变量"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">简单变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变量名"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">变量名</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#整型"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">整型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#short、int和long"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">short、int和long</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#符号常量—预处理器方式"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">符号常量—预处理器方式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法-使用关键字-const）-所以不会经常使用-define。不过-有些头文件-尤其是那些被设计成可用于C和C艹中的头文件-必须使用-define"><span class="post-toc-number">3.</span> <span class="post-toc-text">define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法(使用关键字 const）,所以不会经常使用 # define。不过,有些头文件,尤其是那些被设计成可用于C和C艹中的头文件,必须使用 # define</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#无符号类型"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">无符号类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择整型的类型"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">选择整型的类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#整型常量"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">整型常量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-如何确定常量的类型"><span class="post-toc-number">3.0.4.</span> <span class="post-toc-text">C++如何确定常量的类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#char类型：字符和小整数"><span class="post-toc-number">3.0.5.</span> <span class="post-toc-text">char类型：字符和小整数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#wcha-t"><span class="post-toc-number">3.0.6.</span> <span class="post-toc-text">wcha_t</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#const限定符"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">const限定符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#浮点数"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">浮点数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#书写浮点数"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">书写浮点数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#浮点类型"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">浮点类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#浮点数的优缺点"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">浮点数的优缺点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C-算术操作符"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">C++算术操作符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作符优先级和结合性"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">操作符优先级和结合性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#除法分支"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">除法分支</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#求模操作符"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">求模操作符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型转换"><span class="post-toc-number">3.3.4.</span> <span class="post-toc-text">类型转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#赋值时进行的转换"><span class="post-toc-number">3.3.4.1.</span> <span class="post-toc-text">赋值时进行的转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#表达式中的转换"><span class="post-toc-number">3.3.4.2.</span> <span class="post-toc-text">表达式中的转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#传递参数时转换"><span class="post-toc-number">3.3.4.3.</span> <span class="post-toc-text">传递参数时转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#强制类型转换"><span class="post-toc-number">3.3.4.4.</span> <span class="post-toc-text">强制类型转换</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#复合类型"><span class="post-toc-number">4.</span> <span class="post-toc-text">复合类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组的声明"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">数组的声明</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组的初始化规则"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">数组的初始化规则</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符串"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#拼接字符串常量"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">拼接字符串常量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在数组中使用字符串"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">在数组中使用字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串输入"><span class="post-toc-number">4.2.3.</span> <span class="post-toc-text">字符串输入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#每次读取一行字符串输入"><span class="post-toc-number">4.2.4.</span> <span class="post-toc-text">每次读取一行字符串输入</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#面向行的输入：getline"><span class="post-toc-number">4.2.4.1.</span> <span class="post-toc-text">面向行的输入：getline()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#面向行的输入：get"><span class="post-toc-number">4.2.4.2.</span> <span class="post-toc-text">面向行的输入：get()</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#混合输入字符串和数字"><span class="post-toc-number">4.2.5.</span> <span class="post-toc-text">混合输入字符串和数字</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#string类简介"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">string类简介</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#赋值、拼接和附加"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">赋值、拼接和附加</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#string类的其他操作"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">string类的其他操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#string类I-O"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">string类I/O</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结构简介"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">结构简介</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在程序中使用结构"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">在程序中使用结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构可以将string类作为成员吗"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">结构可以将string类作为成员吗</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他结构属性"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">其他结构属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构数组"><span class="post-toc-number">4.4.4.</span> <span class="post-toc-text">结构数组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构中的位字段"><span class="post-toc-number">4.4.5.</span> <span class="post-toc-text">结构中的位字段</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#共用体"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">共用体</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#枚举"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">枚举</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设置枚举量的值"><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">设置枚举量的值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#枚举的取值范围"><span class="post-toc-number">4.6.2.</span> <span class="post-toc-text">枚举的取值范围</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#指针和自由存储空间"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">指针和自由存储空间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#声明和初始化指针"><span class="post-toc-number">4.7.1.</span> <span class="post-toc-text">声明和初始化指针</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针的危险"><span class="post-toc-number">4.7.2.</span> <span class="post-toc-text">指针的危险</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针和数字"><span class="post-toc-number">4.7.3.</span> <span class="post-toc-text">指针和数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用new来分配内存"><span class="post-toc-number">4.7.4.</span> <span class="post-toc-text">使用new来分配内存</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内存被耗尽"><span class="post-toc-number">4.7.5.</span> <span class="post-toc-text">内存被耗尽</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用delete来释放内存"><span class="post-toc-number">4.7.6.</span> <span class="post-toc-text">使用delete来释放内存</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用new来创建动态数组"><span class="post-toc-number">4.7.7.</span> <span class="post-toc-text">使用new来创建动态数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用new创建动态数组"><span class="post-toc-number">4.7.7.1.</span> <span class="post-toc-text">使用new创建动态数组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用动态数组"><span class="post-toc-number">4.7.7.2.</span> <span class="post-toc-text">使用动态数组</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#指针、数组和指针算术"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">指针、数组和指针算术</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针算术："><span class="post-toc-number">4.8.1.</span> <span class="post-toc-text">指针算术：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针和字符串"><span class="post-toc-number">4.8.2.</span> <span class="post-toc-text">指针和字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用new创建动态结构"><span class="post-toc-number">4.8.3.</span> <span class="post-toc-text">使用new创建动态结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自动存储、静态存储和动态存储"><span class="post-toc-number">4.8.4.</span> <span class="post-toc-text">自动存储、静态存储和动态存储</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#自动存储"><span class="post-toc-number">4.8.4.1.</span> <span class="post-toc-text">自动存储</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#静态存储"><span class="post-toc-number">4.8.4.2.</span> <span class="post-toc-text">静态存储</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#动态存储"><span class="post-toc-number">4.8.4.3.</span> <span class="post-toc-text">动态存储</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#堆栈、堆和内存泄露"><span class="post-toc-number">4.8.5.</span> <span class="post-toc-text">堆栈、堆和内存泄露</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#循环和关系表达式"><span class="post-toc-number">5.</span> <span class="post-toc-text">循环和关系表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#for循环"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">for循环</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#表达式与语句"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">表达式与语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递增操作符（-）和递减操作符（—）"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">递增操作符（++）和递减操作符（—）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组合赋值操作符"><span class="post-toc-number">5.1.3.</span> <span class="post-toc-text">组合赋值操作符</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#关系表达式"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">关系表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可能犯的错误"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">可能犯的错误</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#while循环"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">while循环</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for与while"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">for与while</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型别名"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">类型别名</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#do-while循环"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">do while循环</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#嵌套循环和二维数组"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">嵌套循环和二维数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#初始化二维数组"><span class="post-toc-number">5.5.1.</span> <span class="post-toc-text">初始化二维数组</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#分支语句和逻辑操作符"><span class="post-toc-number">6.</span> <span class="post-toc-text">分支语句和逻辑操作符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#if语句"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">if语句</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#if-else语句"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">if else语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#格式化if-else语句"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">格式化if else语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#if-else-if-else结构"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">if else if else结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#逻辑表达式"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">逻辑表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#逻辑OR操作符："><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">逻辑OR操作符：| |</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#逻辑AND操作符：-amp-amp"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">逻辑AND操作符：&amp;&amp;</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#逻辑NOT操作符：！"><span class="post-toc-number">6.2.3.</span> <span class="post-toc-text">逻辑NOT操作符：！</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#逻辑操作符细节"><span class="post-toc-number">6.2.4.</span> <span class="post-toc-text">逻辑操作符细节</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他表示方式"><span class="post-toc-number">6.2.5.</span> <span class="post-toc-text">其他表示方式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符函数库cctype"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">字符函数库cctype</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#？：操作符"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">？：操作符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#switch语句"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">switch语句</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将枚举量作为标签"><span class="post-toc-number">6.5.1.</span> <span class="post-toc-text">将枚举量作为标签</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#switch和if-else"><span class="post-toc-number">6.5.2.</span> <span class="post-toc-text">switch和if else</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#break和continue语句"><span class="post-toc-number">6.6.</span> <span class="post-toc-text">break和continue语句</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简单文件输入-输出"><span class="post-toc-number">6.7.</span> <span class="post-toc-text">简单文件输入/输出</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文本输入"><span class="post-toc-number">6.7.1.</span> <span class="post-toc-text">文本输入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件输出"><span class="post-toc-number">6.7.2.</span> <span class="post-toc-text">文件输出</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数"><span class="post-toc-number">7.</span> <span class="post-toc-text">函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义函数"><span class="post-toc-number">7.0.1.</span> <span class="post-toc-text">定义函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数原型和函数调用"><span class="post-toc-number">7.0.2.</span> <span class="post-toc-text">函数原型和函数调用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#为什么需要原型"><span class="post-toc-number">7.0.2.1.</span> <span class="post-toc-text">为什么需要原型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#原型的句法"><span class="post-toc-number">7.0.2.2.</span> <span class="post-toc-text">原型的句法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#原型的功能"><span class="post-toc-number">7.0.2.3.</span> <span class="post-toc-text">原型的功能</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数参数和按值传递"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">函数参数和按值传递</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数和数组"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">函数和数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将数组作为参数意味着什么"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">将数组作为参数意味着什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用数组区间的函数"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">使用数组区间的函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针和const"><span class="post-toc-number">7.2.3.</span> <span class="post-toc-text">指针和const</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数和二维数组"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">函数和二维数组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数和C-风格字符串"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">函数和C-风格字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将c-风格字符串作为参数的函数"><span class="post-toc-number">7.4.1.</span> <span class="post-toc-text">将c-风格字符串作为参数的函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#返回C-风格字符串的函数"><span class="post-toc-number">7.4.2.</span> <span class="post-toc-text">返回C-风格字符串的函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数指针"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">函数指针</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#获取函数地址"><span class="post-toc-number">7.5.1.</span> <span class="post-toc-text">获取函数地址</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#声明函数指针"><span class="post-toc-number">7.5.2.</span> <span class="post-toc-text">声明函数指针</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用指针来调用函数"><span class="post-toc-number">7.5.3.</span> <span class="post-toc-text">使用指针来调用函数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数探幽"><span class="post-toc-number">8.</span> <span class="post-toc-text">函数探幽</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C-内联函数"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">C++内联函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#引用变量"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">引用变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建引用变量"><span class="post-toc-number">8.2.1.</span> <span class="post-toc-text">创建引用变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将引用用作函数参数"><span class="post-toc-number">8.2.2.</span> <span class="post-toc-text">将引用用作函数参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#引用的属性和特别之处"><span class="post-toc-number">8.2.3.</span> <span class="post-toc-text">引用的属性和特别之处</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#临时变量、引用参数和const"><span class="post-toc-number">8.2.3.1.</span> <span class="post-toc-text">临时变量、引用参数和const</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应尽可能使用const"><span class="post-toc-number">8.2.4.</span> <span class="post-toc-text">应尽可能使用const</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将引用用于结构"><span class="post-toc-number">8.2.5.</span> <span class="post-toc-text">将引用用于结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#何时使用引用参数"><span class="post-toc-number">8.2.6.</span> <span class="post-toc-text">何时使用引用参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#默认参数"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">默认参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数重载"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">函数重载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#何时使用函数重载"><span class="post-toc-number">8.4.1.</span> <span class="post-toc-text">何时使用函数重载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#名称修饰"><span class="post-toc-number">8.4.2.</span> <span class="post-toc-text">名称修饰</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数模板"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">函数模板</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重载的模板"><span class="post-toc-number">8.5.1.</span> <span class="post-toc-text">重载的模板</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#显式具体化"><span class="post-toc-number">8.5.2.</span> <span class="post-toc-text">显式具体化</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#内存模型和名称空间"><span class="post-toc-number">9.</span> <span class="post-toc-text">内存模型和名称空间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单独编译"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">单独编译</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#头文件管理"><span class="post-toc-number">9.1.1.</span> <span class="post-toc-text">头文件管理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#存储持续性、作用域和链接性"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">存储持续性、作用域和链接性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#链接性"><span class="post-toc-number">9.2.1.</span> <span class="post-toc-text">链接性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#作用域和链接"><span class="post-toc-number">9.2.2.</span> <span class="post-toc-text">作用域和链接</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自动存储持续性"><span class="post-toc-number">9.2.3.</span> <span class="post-toc-text">自动存储持续性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#自动变量和堆栈"><span class="post-toc-number">9.2.3.1.</span> <span class="post-toc-text">自动变量和堆栈</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#寄存器变量"><span class="post-toc-number">9.2.3.2.</span> <span class="post-toc-text">寄存器变量</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态持续变量"><span class="post-toc-number">9.2.4.</span> <span class="post-toc-text">静态持续变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#全局变量和局部变量"><span class="post-toc-number">9.2.5.</span> <span class="post-toc-text">全局变量和局部变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态持续性、内部链接性"><span class="post-toc-number">9.2.6.</span> <span class="post-toc-text">静态持续性、内部链接性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态存储持续性、无连接性"><span class="post-toc-number">9.2.7.</span> <span class="post-toc-text">静态存储持续性、无连接性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说明符和限定符"><span class="post-toc-number">9.2.8.</span> <span class="post-toc-text">说明符和限定符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#再谈const"><span class="post-toc-number">9.2.9.</span> <span class="post-toc-text">再谈const</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数和链接性"><span class="post-toc-number">9.2.10.</span> <span class="post-toc-text">函数和链接性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-在哪里查找函数"><span class="post-toc-number">9.2.11.</span> <span class="post-toc-text">C++在哪里查找函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#语言链接性"><span class="post-toc-number">9.2.12.</span> <span class="post-toc-text">语言链接性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#存储方案和动态分配"><span class="post-toc-number">9.2.13.</span> <span class="post-toc-text">存储方案和动态分配</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#布局new操作符"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">布局new操作符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#名称空间-1"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">名称空间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#传统的C-名称空间"><span class="post-toc-number">9.4.1.</span> <span class="post-toc-text">传统的C++名称空间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#新的名称空间特性"><span class="post-toc-number">9.4.2.</span> <span class="post-toc-text">新的名称空间特性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#using声明和using编译指令"><span class="post-toc-number">9.4.2.1.</span> <span class="post-toc-text">using声明和using编译指令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#using编译指令和using声明值比较"><span class="post-toc-number">9.4.2.2.</span> <span class="post-toc-text">using编译指令和using声明值比较</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#名称空间的其他特性"><span class="post-toc-number">9.4.2.3.</span> <span class="post-toc-text">名称空间的其他特性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#未命名的名称空间"><span class="post-toc-number">9.4.2.4.</span> <span class="post-toc-text">未命名的名称空间</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#名称空间的指导原则"><span class="post-toc-number">9.4.3.</span> <span class="post-toc-text">名称空间的指导原则</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-C++ Primer 类之前"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">C++ Primer 类之前</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-12-18 15:07:56" datetime="2018-12-18T07:07:56.000Z"  itemprop="datePublished">2018-12-18</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/教程/">教程</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="开始学习C"><a href="#开始学习C" class="headerlink" title="开始学习C++"></a>开始学习C++</h1><h2 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h2><p>通常main()被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统的桥梁。</p>
<p>C++必修包含一个名为main()的函数，大小写拼写都要正确。如果没有main(),程序将不完整，编译器将指出未定义main()函数。</p>
<p>存在一些例外情况。例如,在 Windows编程中,可以编写一个动态链接库(DLL)模块,这是其他 Windows程序可以使用的代码。由于DLL模块不是独立的程序,因此不需要 main （）。</p>
<p>C++注释 （/ / ）以及（/ <em> 和 </em> /）</p>
<h3 id="C-预处理器和iostream文件"><a href="#C-预处理器和iostream文件" class="headerlink" title="C++预处理器和iostream文件"></a>C++预处理器和iostream文件</h3><p>C++和C一样,也使用一种预处理器,该程序在进行主编译之前对源文件进行处理(有些C++实现使用翻译器程序将C++程序转换为C程序。虽然翻译器也是一种预处理器,但这里不讨论这种预处理器,而只讨论处理名称以 # 开头的编译指令的预处理器)。不必执行任何特殊的操作来调用该预处理器,它会在编译程序时自动运行。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.31.15.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>实际上，iostream文件的内容将取代程序中的代码行# include &lt; iostream&gt;。原始文件没有被修改，而是将源代码文件和iostream组合成一个复合文件，编译的下一阶段将使用该文件。</p>
<h3 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.37.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>像iostream这样的文件由于它们被包含在其他文件中叫做包含文件(include file)；由于它们被包含在文件起始处，也叫头文件(header file)。C++编译器自带了很多头文件，每个头文件都支持一组特定的工具。</p>
<p>C++的用法发生了变化。现在,对老式C的头文件保留了扩展名h(C++程序仍可以使用这种文件),而C++头文件则没有扩展名。有些C头文件被转换为C++头文件,这些文件被重新命名,去掉了扩展名h(使之成为C++风格的名称),并在文件名称前面加上前缀c(表明来自C语言)。例如,C++版本的math.h为 cmath头文件。有时C头文件的C版本和C++版本相同,而有时候新版本做了些修改。对于纯粹的C++头文件(如 iostream)来说,去掉h不只是形式上的变化,没有h的头文件也可以包含名称空间。</p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.07.29.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>这叫做using编译指令。</p>
<p>名称空间支持是C++中一项较新的特性,它是为了使编写将多个厂商已有的代码组合起来的程序更简单而设计的。一个潜在的问题是:可能使用两个已封装好的产品,而它们都包含一个名为 wanda()的函数。这样,使用 wanda函数时,编译器将不知道指的是哪个版本。名称空间让厂商能够将其产品封装在一个叫做名称空间的单元中,这样就可以用名称空间的名称来指出想使用哪个厂商的产品。因此, Microflop Industries可以将其定义放到一个名为 Microflop的名称空间中。这样,其 wanda函数的全称为Microflop:: wanda():同样, Piscine公司的 wandao版本可以表示为 Piscine: :wanda()。这样,程序就可以使用名称空间来区分不同的版本了:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.16.46.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>iostream是C++的标准库，标准库都被放置在命名空间std（standard）中。仅当头文件没有扩展名h时，情况才这样，也就是采用c++的新式风格，即采用了名称空间。头文件为.h由于没有采用名称空间，所以在采用不同库时，是存在命名冲突的风险的，没办法，自己想办法解决吧；）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言与c++，C语言确实是最底层，但是语法不完善，开发效率很低，c++就是为了解决某些问题才诞生的。</span><br><span class="line">鸡先生蛋还是蛋先生鸡，许多语言的编译都是c写的，那么c语言的编译器又是谁写的呢。</span><br><span class="line">1970年Tomphson和Ritchie在BCPL（一种解释型语言）的基础上开发了B语言，1973年又在B语言的基础上成功开发出了现在的C语言。在C语言被用作系统编程语言之前，Tomphson也用过B语言编写过操作系统。可见在C语言实现以前，B语言已经可以投入实用了。因此第一个C语言编译器的原型完全可能是用B语言或者混合B语言与PDP汇编语言编写的。我们现在都知道，B语言的执行效率比较低，但是如果全部用汇编语言来编写，不仅开发周期长、维护难度大，更可怕的是失去了高级程序设计语言必需的移植性。所以早期的C语言编译器就采取了一个取巧的办法：先用汇编语言编写一个C语言的一个子集的编译器，再通过这个子集去递推完成完整的C语言编译器。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编译器为什么会生成汇编语言而不是机器语言？</span><br><span class="line">1)其中有一个好处是方便优化，因为，编译器也是工具，也是机器，毕竟是机器生成的程序，不可以非常 完美的,而汇编是机器指令的助记符，一个汇编指令就对应一条机器指令（特殊指令除外）调试起来肯定会比 机器指令方便的方便，这样优化起来也方便。</span><br><span class="line">2)高级语言只需要编译成汇编代码就可以了,汇编代码到机器码的转换是由硬件实现即可,有必要用软件实 现这样分层可以有效地减弱编译器编写的复杂性,提高了效率.就像网络通讯的实现需要分成很多层一样,主要 目的就是为了从人脑可分析的粒度来减弱复杂性.</span><br><span class="line">3)如果把高级语言的源代码直接编译成机器码的话，那要做高级语言到机器码之间的映射,如果这样做的 话，每个写编译器的都必须熟练机器码。这个不是在做重复劳动么。</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8811.16.54.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>c++在使用函数前需要有函数声明，有了函数声明还要有函数定义。c++不允许将函数定义嵌套在另一个函数定义中。每个函数定义都是独立的，所有函数<br>的创建都是平等的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%885.31.32.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>int main（）时return 0将返回值返回给了操作系统。例如。UNIX外壳脚本和DOS批处理文件都被设计成运行程序。很多操作系统都可以使用程序的返回值（通常也叫退出值）。通常的约定是，退出值为0则意味着程序运行成功，为非0则意味着存在问题。因此，如果c++程序无法打开文件，可以将它设计为返回一个非零值。然后，便可以设计一个外壳脚本或批处理文件来运行该程序，如果程序发出指示失败的消息，则采取其他措施。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.06.13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><h3 id="short、int和long"><a href="#short、int和long" class="headerlink" title="short、int和long"></a>short、int和long</h3><p>如果在所有的系统中，每种类型的宽度都相同，则使用起来将非常方便。但是生活并非那么简单，C++提供了一种灵活的标准，它确保了最小长度（从C语言借鉴而来）：</p>
<ol>
<li>short至少16位</li>
<li>int至少和short一样长。</li>
<li>long至少32位，且至少与int一样长。</li>
</ol>
<p>当前很多系统都使用最小长度,即shot为16位,long为32位。这仍然为int提供了多种选择,其宽度可以是16位、24位或32位,同时又符合标准。通常,在老IMPC的实现中,int的宽度为16位(与short相同),而在 Windows98、 Windows nt、 Windows XP、 Macintosh OS X、VAX和很多其他微型计算机的实现中,为32位(与long相同)。有些实现允许选择如何处理int类型的宽度随实现而异,这可能在将C艹程序从种环境移到另…种环境时引发问题。但只要小心一点就可以最大限度地减少这种问题。</p>
<p>实际上，<strong>short是short int的简称，而long是long int的简称。</strong>这三种类型（int,short和long）都是符号类型，意思是有一位的符号位。</p>
<p>sizeof操作符返回类型或变量的长度，单位为字节。头文件 climits(在老式实现中为 limits h)中包含了关于整型限制的信息。具体地说,它定义了表示各种限制的符号名称。例如, INT_MAX为int的最大取值, CHAR_BIT为字节的位数。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.28.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="符号常量—预处理器方式"><a href="#符号常量—预处理器方式" class="headerlink" title="符号常量—预处理器方式"></a>符号常量—预处理器方式</h3><h1 id="define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法-使用关键字-const）-所以不会经常使用-define。不过-有些头文件-尤其是那些被设计成可用于C和C艹中的头文件-必须使用-define"><a href="#define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法-使用关键字-const）-所以不会经常使用-define。不过-有些头文件-尤其是那些被设计成可用于C和C艹中的头文件-必须使用-define" class="headerlink" title="define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法(使用关键字 const）,所以不会经常使用 # define。不过,有些头文件,尤其是那些被设计成可用于C和C艹中的头文件,必须使用 # define"></a>define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法(使用关键字 const）,所以不会经常使用 # define。不过,有些头文件,尤其是那些被设计成可用于C和C艹中的头文件,必须使用 # define</h1><h3 id="无符号类型"><a href="#无符号类型" class="headerlink" title="无符号类型"></a>无符号类型</h3><p>要创建无符号版本的基本整形，只需要使用关键字unsigned来修改声明即可：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.15.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>climits文件与limits.h文件；老式编译器可能需要使用文件limits.h，有些非常老的编译器可能根本没有这两个文件。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.19.03.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="选择整型的类型"><a href="#选择整型的类型" class="headerlink" title="选择整型的类型"></a>选择整型的类型</h3><p>通常,int被设置为对目标计算机而言最为“自然”的长度。自然长度( natural size)指的是计算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其他类型,则应使用int。</p>
<p>如果知道变量可能表示的整数值大于16位整数的最大可能值,则使用long。即使系统上int为32位也应这样做。这样,当程序移植到16位的系统中时,程序就不会突然无法正常工作。</p>
<p>如果 short比int小,则使用 short可以节省内存。通常,仅当有大型整型数组时,才有必要使用 short(数组是一种数据结构,在内存中连续存储同类型的多个值)。如果节省内存很重要,则应使用 short而不是使用int,即使它们的长度是一样的。例如,假设要将程序从int为16位的 DOS PC系统移到int为32位的Windows XP系统,则用于存储int数组的内存量将加倍,但 short数组不受影响。记住,节省一点是一点。如果只需要一个字节，可使用char。</p>
<h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>十进制，八进制，十六进制。不管书写为10、012还是0xA，都将以相同的方式存储在计算机中—被存储为二进制数。</p>
<h3 id="C-如何确定常量的类型"><a href="#C-如何确定常量的类型" class="headerlink" title="C++如何确定常量的类型"></a>C++如何确定常量的类型</h3><p>程序将把常量1492存储为int、long还是其他整型呢?答案是,除非有理由存储为其他类型(如使用了特殊的后缀来表示特定的类型,或者值太大,不能存储为int),否则C++将整型常量存储为int类型。</p>
<p>首先来看看后缀。后缀是放在数字常量后面的字母,用于表示类型。整数后面的1或L后缀表示该整数为long常量,u或U后缀表示 unsigned int常量,ul(可以采用任何一种顺序,大写小写均可)表示 unsigned long常量(由于小写1看上去像1,因此应使用大写L作后缀)。例如,在int为16位、long为32位的系统上,数字22022被存储为int,占16位,数字2022L被存储为long,占32位。同样,22022LU和2202UL都被存储为 unsigned long。</p>
<p>接下来考察长度。在C艹中,对十进制整数采用的规则,与十六进制和八进制稍微有些不同。对于不带后缀的十进制整数,将使用下面几种类型中能够存储该数的最小类型来表示:int、long或 unsigned long。在int为16位、long为32位的计算机系统上,20000表示为int类型,40000被表示为long类型,3000000被表示为 unsigned long类型。对于不带后缀的十六进制或八进制整数,将使用下面几种类型中能够存储该数的最小类型来表示;int、 unsigned int、long或 unsigned long。在将40000表示为long的计算机系统中,六进制数Ox9C40(40000.将被表示为 unsigned int这是因为十六进制常用来表示内存地址,而内存地址是没有符号的,因此unsigned int比long更适合用来表示16位的地址。</p>
<h3 id="char类型：字符和小整数"><a href="#char类型：字符和小整数" class="headerlink" title="char类型：字符和小整数"></a>char类型：字符和小整数</h3><p>顾名思义，char类型是专为存储类型（如字母和数字）而设计的。编程语言通过字母的数值编码解决了字母的存储问题。因此，char类型是另一种整型（所以可以加1）。它足够长，能够表示目标计算机系统中所有基本符号—所有的字母、数字、标点符号等。实际上，多数系统所支持的字符都不超过256种，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以将它用做比short更小的整型。在美国，最常用的符号集是ASCII字符集，不过不能很好的满足国际需要，c++支持的宽字符类型可以存储更多的值，如国际Unicode字符集使用的值。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.53.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.55.44.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="wcha-t"><a href="#wcha-t" class="headerlink" title="wcha_t"></a>wcha_t</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.01.00.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.34.29.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>提示:如果读者在学习C艹之前学习过C语言,并打算使用 # define来定义符号常量,请不要这样做,而应使用 const。</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="书写浮点数"><a href="#书写浮点数" class="headerlink" title="书写浮点数"></a>书写浮点数</h3><p>第一种是标准小数点表示法12.34。第二种表示浮点值的方法叫做E表示法3.45E(e)6</p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>C++也有3种浮点类型float、double和long double。这些类型是按它们可以表示的有效位数和允许的指数最小范围来描述的。有效位是数字中有意义的位。事实上,C和C++对于有效位数的要求是,foat至少32位, double至少48位,且不少于float, long double至少和 double样多。这种类型的有效位数可以一样多。不过,通常foat为32位, double为64位,long double为80、96或128位。另外,这3种类型的指数范围至少是-37到37。可以从头文件cfloat或 float. h中找到系统的限制( float是C语言的 float h文件的C++版本)。</p>
<h3 id="浮点数的优缺点"><a href="#浮点数的优缺点" class="headerlink" title="浮点数的优缺点"></a>浮点数的优缺点</h3><p>与整数相比,浮点数有两大优点。首先,它们可以表示整数之间的值。其次,由于有缩放因子,它们可以表示的范围大得多。另一方面,浮点运算的速度比整数运算慢,至少在没有数学协处理器的计算机上是如此,而且精度将降低。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.00.23.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="C-算术操作符"><a href="#C-算术操作符" class="headerlink" title="C++算术操作符"></a>C++算术操作符</h2><h3 id="操作符优先级和结合性"><a href="#操作符优先级和结合性" class="headerlink" title="操作符优先级和结合性"></a>操作符优先级和结合性</h3><h3 id="除法分支"><a href="#除法分支" class="headerlink" title="除法分支"></a>除法分支</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.03.45.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="求模操作符"><a href="#求模操作符" class="headerlink" title="求模操作符"></a>求模操作符</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++自动执行很多类型转换：</p>
<ol>
<li>将一种算术类型的值赋给另一种算术类型的变量时，c++将对值进行转换。</li>
<li>表达式中包含不同的类型时，C++将对值进行转换。</li>
<li>将参数传递给函数时，C++将对值进行转换。<h4 id="赋值时进行的转换"><a href="#赋值时进行的转换" class="headerlink" title="赋值时进行的转换"></a>赋值时进行的转换</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.24.49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
将0赋值给bool变量时，将被转换为false，而非零值将被转换为true。<h4 id="表达式中的转换"><a href="#表达式中的转换" class="headerlink" title="表达式中的转换"></a>表达式中的转换</h4>当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换：首先，一些类型在出现时便会自动转换。其次，有些类型在与其他类型同时出现在表达式中将被转换。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.32.13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
还有其他些整型提升: 如果short比int短，则unsigned short 类型将被转换为int;如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。这种规则确保了在对unsigned short进行提升时不会损失数据。</li>
</ol>
<p>同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_ t 取值范围的类型: int. unsigned int、long或unsigned long.</p>
<p>将不同类型进行算术运算时， 也会进行一些转换，例如将int和float相加时。当运算涉及到两种类型时，较小的类型将破转换为较大的类型。例如，程序清单3.11中的程序用9.0除以5。 由于9.0的类型为double, 因此程序在用5除之前，将5转换为double类型。总之，编译器通过校验表来确定在算术表达式<br>中执行的转换。下面是一一个列表， 编译器将依次查阅该列表:<br>①如果有一个操作数的类型是long double, 则将另一个操作数转换为long double.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.28.12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>ANSI C遵循的规则与C++相同，但传统K&amp;R C的规则稍有不同。例如，传统C语言总是将float提升为double,即使两个操作数都是float。</p>
<h4 id="传递参数时转换"><a href="#传递参数时转换" class="headerlink" title="传递参数时转换"></a>传递参数时转换</h4><p>传递参数时的类型转换通常由C++函数原型控制。不过,也可以取消原型对参      数传递的控制,尽管这样做并不明智。在这种情况下,C++将对char和 short类型( signed和 unsigned)应用整型提升。另外,为保持与传统C语言中大量代码的兼容性,在将参数传递给取消原型对参数传递控制的函数时,C+将float参数提升为 double。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>C++还允许通过强制类型转换机制显式地进行类型转换，强制类型转换的格式有两种。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.40.08.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>第一种格式来自C语言,第二种格式是纯粹的C++。新格式的想法是,要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。</p>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>计算机在内存中依次存储数组的各个元素。数组中的每一个元素可以看做一个简单变量。要创建数组，可使用声明语句，应指出三点。</p>
<ol>
<li>存储在每个元素中的值的类型</li>
<li>数组名</li>
<li>数组中的元素数</li>
</ol>
<h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.47.20.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>表达式arraySize指定元素数目，它必须是整型常数(如10)或const值，也可以是常量表达式(如8*sizeof (in)),即其中所有的值在编译时都是已知的。具体地说，arraySize 不能是变量，变量的值是在程序运行时设置的。不过，可以使用new操作符来避开这种限制。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.50.58.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="数组的初始化规则"><a href="#数组的初始化规则" class="headerlink" title="数组的初始化规则"></a>数组的初始化规则</h3><p>只有在定义数组时才能使用初始化，此后就不能使用了， 也不能将一 个数组赋给另一个数组:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.55.23.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>不过， 可以使用下标分别给数组中的元素赋值。<br>初始化数组时，提供的值可以少于数组的元素数目。如果只对数组的部分进行初始化， 则编译器将把其他元素设置为0。<br>如果初始化数组时方括号内([])为空，C++编译器将计算元素个数。</p>
<p>通常，让编译器计算元素个数是一种很糟的做法，因为其计数可能与您想象的不一样。不过，这种方法对于将字符数组初始化为一个字符串来说比较安全。<br>C++标准模板库（STL）一种数组替代品—模板类vector，它比内置复合类型数组更复杂，也更灵活。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是存储在内存的连续字节中的一系列字符。C++处理字符串有两种方式。一，来自C语言，被称为C-风格字符串，还有一种就是基于string类库的方法。</p>
<p>存储在连续字节中的一-系列字符意味着可以将字符串存储在char数组中，每个字符都位于自己的数组元素中。C风格具有一种特殊的性质，以空字符结尾，空字符被写作\ 0 ，其ASCII码为0，用来标记字符串的结尾。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.35.33.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这两个数组都是char数组，但只有第二个数组是子符串。空子符对C-风格子付事心后里大里安。例如，C++有很多处理字符串的函数，其中包括cout使用的那些函数。它们都逐个地处理字符串中的字符， 直到到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示前4个字符，发现空字符后停止。但是，如果使用cout显示上面的dog数组(它不是字符串)，cout 将打印出数组中的5个字母，并接着将内存中随后的各个字节解释为要打印的字符，直到遇到空字符为止。由于空字符(实际上是被设置为0的字节)在内存中很常见，因此这一过程将很快停止。但尽管如此，还是<strong>不应将不是字符串的字符数组当作字符串来处理</strong>。</p>
<p>有一种更好地将字符数组初始化为字符串的方法，使用用引号括起来的字符串<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.39.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>用引号括起的字符串隐式地包括结尾的空字符,因此不用显式地包括它。</p>
<p>应确保数组足够大,能够存储字符串中所有字符包括空字符。使用字符串常量初始化字符数组是这样的一种情况,即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处,只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置,而不是数组长度来进行处理。C++对字符串长度没有限制。<br>记住：在确定存储字符串所需的最短数组时，记得将结尾的空字符计算在内。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.45.19.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><strong>注意</strong>,字符串常量(使用双引号)不能与字符常量(使用单引号)互换。字符常量(如S)是字符串编码的简写表示。在ASCⅡ系统上,S只是83的另一种写法。因此,下面的语句:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.49.06.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>是将内存地址赋给变量。</p>
<h3 id="拼接字符串常量"><a href="#拼接字符串常量" class="headerlink" title="拼接字符串常量"></a>拼接字符串常量</h3><p>任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.08.10.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\ 0 )后面。第一个字符串的\ 0 字符将会被第二个字符串的第一个字符取代。</p>
<h3 id="在数组中使用字符串"><a href="#在数组中使用字符串" class="headerlink" title="在数组中使用字符串"></a>在数组中使用字符串</h3><p>要将字符串存储到数组中，最常用的方法有两种，一是将数组初始化为字符串常量、二将键盘或文件输入读入数组中。</p>
<h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>cin</p>
<h3 id="每次读取一行字符串输入"><a href="#每次读取一行字符串输入" class="headerlink" title="每次读取一行字符串输入"></a>每次读取一行字符串输入</h3><h4 id="面向行的输入：getline"><a href="#面向行的输入：getline" class="headerlink" title="面向行的输入：getline()"></a>面向行的输入：getline()</h4><p>getline()函数读取整行,它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法,可以使用 cin. getline()。该函数有两个参数。第一个参数是用来存储输入行的数组的名称,第二个参数是要读取的字符数。</p>
<h4 id="面向行的输入：get"><a href="#面向行的输入：get" class="headerlink" title="面向行的输入：get()"></a>面向行的输入：get()</h4><h3 id="混合输入字符串和数字"><a href="#混合输入字符串和数字" class="headerlink" title="混合输入字符串和数字"></a>混合输入字符串和数字</h3><p>混合输入数字和面向行的字符串会导致问题。</p>
<h2 id="string类简介"><a href="#string类简介" class="headerlink" title="string类简介"></a>string类简介</h2><p>string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表示方法。</p>
<p>要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，需要提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，可以像处理普通变量那样处理字符串。</p>
<h3 id="赋值、拼接和附加"><a href="#赋值、拼接和附加" class="headerlink" title="赋值、拼接和附加"></a>赋值、拼接和附加</h3><p>使用 string类时,某些操作比使用数组时更简单。例如,不能将一个数组赋给另一个数组,但可以将个 string对象赋给另一个string对象。string类简化的字符串合并操作。可以使用操作符+将两个string对象合并起来,还可以使用操作符+      =一个字符串附加到个 string对象的末尾。</p>
<h3 id="string类的其他操作"><a href="#string类的其他操作" class="headerlink" title="string类的其他操作"></a>string类的其他操作</h3><p>在C艹新增 string类之前,程序员也需要完成诸如给字符串赋值等工作。对于C语言式的字符串,程序员使用C语言库中的函数来完成这些任务。头文件cstring(以前为 string. h)提供了这些函数。例如,可以使用函数 strcpy()将字符串复制到字符数组中,使用函数 strcat()将字符串附加到字符数组末尾:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.51.00.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="string类I-O"><a href="#string类I-O" class="headerlink" title="string类I/O"></a>string类I/O</h3><p>正如读者知道的,可以使用cin和操作符&lt;&lt;来将输入存储到 string对象中,使用cout和操作符&gt;&gt;来显示 string对象,其句法与处理C-风格字符串相同。但每次读取一行而不是一个单词时,使用的句法不同。</p>
<h2 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.58.45.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.50.50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>C++运行在声明结构变量时省略关键字struct。<br>可以使用成员操作符（.）来访问各个成员。访问类成员函数的方式也是类似的。</p>
<h3 id="在程序中使用结构"><a href="#在程序中使用结构" class="headerlink" title="在程序中使用结构"></a>在程序中使用结构</h3><p>结构声明的位置很重要。可以将声明放在main()函数中，紧跟在开始括号的后面，另一种选择是将声明放在main()的前面。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.57.33.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>C++不提倡使用外部变量但提倡使用外部结构声明。<br>初始化结构：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.11.22.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>当然也可以把它们放在同一行中。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.13.07.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="结构可以将string类作为成员吗"><a href="#结构可以将string类作为成员吗" class="headerlink" title="结构可以将string类作为成员吗"></a>结构可以将string类作为成员吗</h3><p>大体上说，答案是肯定的。</p>
<h3 id="其他结构属性"><a href="#其他结构属性" class="headerlink" title="其他结构属性"></a>其他结构属性</h3><p>C++使用户定义的类型与内置类型尽可能相似。例如， 可以将结构作为参数传递给函数, 也可以让函数返同—个结构。另外，还可以使用赋值操作符(=) 将结构賦给另一个同类型的结构， 这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值。</p>
<h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.43.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.56.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="结构中的位字段"><a href="#结构中的位字段" class="headerlink" title="结构中的位字段"></a>结构中的位字段</h3><p>与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整型或枚举(稍后将介绍),接下来是冒号，冒号后面是一一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段(bit field)。下面是一个例子:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.23.35.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.27.27.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>位字段通常用在低级编程中。</p>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体（union）是一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时存储int、long和double,共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。<br>声明：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.32.27.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>可以使用one4all变量来存储int、long或double，条件是在不同的时间进行：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.34.24.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>因此，pail 有时可以是int变量，而有时义可以是double变量。成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。在存储了double后int值就丢失了。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.38.00.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.57.51.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>由于共用体是匿名的，因此id_ num和id_ char被视为prize 的两个成员，它们的地址相同，所以不需要中间标识符id_ val。程序员负责确定当前哪个成员是活动的。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。使用enum的句法与使用结构相似。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.00.46.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这条语句完成两项工作：<br>第一让spectrum称为新类型的名称，spectrum被称为枚举，就像struct变量被称为结构一样。<br>第二将red,orange,yellow等作为符号常量，它们对应整数值0-7.这些常量叫做枚举量。<br>可以用枚举名来声明这种类型的变量：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.07.31.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.11.34.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>对于枚举，只定义了赋值操作符，具体说就是没有为枚举定义算术运算：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.12.35.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>对于最后一个式子<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.18.59.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>枚举时整型，可被提升为Int类型，但int类型不能自动转换为枚举类型：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.16.46.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>枚举的规则相当严格，实际上，枚举更常被用来定义相关的符号常量，而不是新类型。如果打算只使用常量而不创建枚举类型的变量，则可以省略枚举类型的名称。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.21.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="设置枚举量的值"><a href="#设置枚举量的值" class="headerlink" title="设置枚举量的值"></a>设置枚举量的值</h3><p>可以使用赋值操作符来显示地设置枚举量的值。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.22.43.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>指定的值必须是整数。 也可以只显式地定义其中一些枚举量的值:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.23.07.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这里，first在默认情况下为0，后面没有被初始化的枚举量的值将比其前面的枚举量大1，因此，third的值为101。<br>还可以创建多个值相同的枚举量：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.27.13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>在早期版本中，只能将int值（或提升为int的值）赋给枚举量，现在这种限制已经取消了，因此可以使用long类型的值。</p>
<h3 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h3><p>最初，对于枚举来说，只有声明中指出的那些值是有效的。不过，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围(range)， 通过强制类型转换， 可以将取值范围中的任何整数值赋给枚举变量， 即使这个值不是枚举值。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.30.45.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>则如下代码将是合法的：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.31.11.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>其中6不是枚举值，但它位于枚举定义的取值范围中。<br>取值范围的定义如下。首先， 要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1, 得到的便是取值范围的上限。例如， 前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0,则取值范围的下限为0;否则，采用与寻找上限方式相同的方式， 但加上负号。例如， 如果最小的枚举量为-6， 而比它小的、最大的2的幂是-8 (加上负号)，因此下限为-7。</p>
<p>选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举,使用一个字节或更少的空间而对于包含long类型值的枚举,则使用4个字节。</p>
<h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><p>指针是一个变量，其存储的是值的地址而不是值本身，对变量应用地址操作符（&amp;）就可以获得它的位置，如home是一个变量，则&amp;home是它的地址。</p>
<p>面向对象编程与传统过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。即使用new和指定固定长度的数组的区别。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.53.50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="声明和初始化指针"><a href="#声明和初始化指针" class="headerlink" title="声明和初始化指针"></a>声明和初始化指针</h3><p>计算机需要跟踪指针指向的值的类型。例如，char 的地址与double的地址看上去没什么两样，但char和double使用的字节数是不同的，它们存储值时使用的内部格式也不同。因此，指针声明必须指定指针指向的数据的类型。但是地址的格式是相同的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.58.29.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>需要强调的是，int <em> 是一种类型，是指向int的指针。在哪里添加空格对于编译器是没有任何区别的。以下声明：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.03.35.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>将创建一个指针p1和一个常规int变量p2。对每个指针变量名，都需要使用一个 </em> 。</p>
<h3 id="指针的危险"><a href="#指针的危险" class="headerlink" title="指针的危险"></a>指针的危险</h3><p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。</p>
<p><strong>警告</strong>：<strong>一定要在对指针应用解除引用操作符（ * ）之前，将指针初始化为一个确定的、适当的地址。</strong></p>
<h3 id="指针和数字"><a href="#指针和数字" class="headerlink" title="指针和数字"></a>指针和数字</h3><p>指针不是整型，虽然计算机通常把地址当做整数来处理。在C99标准发布前，C语言允许直接对指针赋值整数，但C++在类型一致性上要求更严格，编译器将显示一条错误信息，要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.58.11.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>注意，pt是int值的地址，并不意味着pt本身的类型是int。</p>
<h3 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h3><p>指针的真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc()来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—使用new操作符。</p>
<p>在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new操作符。程序员要告诉new,需要为哪种数据类型分配内存; <strong>new将找到一个长度正确的内存块，并返回该内存块的地址。</strong>程序员的责任是将该地址赋给一个指针。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.50.00.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>在之前是通过如下方式指定指针的地址的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.51.34.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>两种情况都是将一个int变量的地址赋给了指针。第二种情况下还可以通过名称来访问该int，第一种情况下，则只能通过该指针进行访问。pn指向的内存没有名称，该怎么称呼呢？我们称pn指向一个数据对象。这里的对象不是面向对象中的那个对象，术语数据对象比变量更通用，指为数据项分配的内存块，因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。</p>
<p>为一个数据对象(可以是结构，也可以是基本类型)获得并指定分配内存的通用格式如下:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.59.47.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>需要在两个地方指定数据类型:用来指定需要什么样的内存和用来声明合适的指针。由于内存地址形式一样，所以得通过指针的类型知道需要读几个内存单元的值。</p>
<h3 id="内存被耗尽"><a href="#内存被耗尽" class="headerlink" title="内存被耗尽"></a>内存被耗尽</h3><p>计算机可能会由于没有足够的内存而无法满足new的请求。此时，new将返回0。在C++中，值为0的指针被称为空值指针（null pointer）。C++确保空值指针不会指向有效的数据，因此它常被用来表示操作符或函数失效，如果成功，它们将返回一个有用的指针。可以通过if语句来检查new是否返回的是空值指针，从而防止程序超界。如果无法分配内存，new除返回空值指针外，还可能引发bad_alloc异常。</p>
<h3 id="使用delete来释放内存"><a href="#使用delete来释放内存" class="headerlink" title="使用delete来释放内存"></a>使用delete来释放内存</h3><p>当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是delete操作符，它使得在使用完内存后， 能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放(free)的内存可供程序的其他部分使用。使用delete时，后面要加.比指向内存块的指针(这些内存块最初是用new分配的):<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.09.51.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这将释放ps指向的内存，但不会删除指针ps本身。例如，可以将ps重新指向另一个新分配的内存块。一定要配对地使用new和delete: 否则将发生内存泄漏(memory leak), 也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。</p>
<p>不要尝试释放已经释放的内存，这样做的结果是不确定的，不能使用delete来释放声明变量获得的内存。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.15.31.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><strong>只能用delete来释放使用new分配的内存</strong>，不过对空指针使用delete是安全的。</p>
<p>使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.19.56.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>一般来说， 不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。</p>
<h3 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h3><p>如果通过声明来创建数组,则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组,数组都在那里,它占用了内存。在编译时给数组分配内存被称为静态联编( static binding),意味着数组是在编译时加入到程序中的。但使用new时,如果在运行阶段需要数组,则创建它:如果不需要, 则不创建。还可以在程序运行时选择数组的长度。这被称为动态联编(dynamic binding),意味着数组是在程序运行时创建的。这种数组叫作动态数组(dynamic array)使用静态联编时,必须在编写程序时指定数组的长度;使用动态联编时,程序将在运行时确定数组的长度。</p>
<h4 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h4><p>在C++中,创建动态数组很容易;只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号,其中包含元素数目。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.28.33.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>new操作符返回第一个元素的地址，当程序结束使用内存块后，应使用delete释放它们。</p>
<p>使用new创建数组时，应使用另一种格式的delete,它能指出所要释放的是一个数组。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.49.29.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意delete和指针之间的方括号。如果使用new时，不带方括号，则使用delete时，也不应带方括号。如果使用new时带方括号，则使用delete时也应带方括号。</p>
<p>总之, 使用new和delete时，应遵守以下规则:</p>
<ol>
<li>不要使用delete来释放不是new分配的内存。</li>
<li>不要使用delete释放同一个内存块两次。</li>
<li>如果使用new[ ]为数组分配内存，则应使用delete[ ]来释放。</li>
<li>如果使用new[ ]为一个实体分配内存，则应使用delete (没有方括号)来释放。</li>
<li>对空值指针应用delete是安全的。</li>
</ol>
<p>由于动态数组返回的是指向第一个元素的指针，所以程序员需要跟踪内存块中的元素个数，实际上程序跟踪了分配的内存量以便在使用delete[]操作符时能正确地释放这些内存。但是这些信息是不公用的，如，不能使用sizeof操作符来确定动态分配的数组包含的字节数。</p>
<p>为数组分配内存的通用格式：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%886.12.10.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>使用new操作符可以确保内存块足以存储num_elements 个类型为type_ name的元素，而pointer_ name将指向第1个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于new与delete的问题</span><br><span class="line">一般来说在程序结束后操作系统会收回分配的所有资源，不delete也不会造成影响。但是如果程序常驻内存只new不delete就会很快耗尽内存，造成内存泄露，所以要养成new delete的习惯。</span><br></pre></td></tr></table></figure></p>
<h4 id="使用动态数组"><a href="#使用动态数组" class="headerlink" title="使用动态数组"></a>使用动态数组</h4><p>将指针当做数组名使用即可，对于第一个元素，即为p[0]。<br>数组名和指针的根本区别在于，不能修改数组名的值，但指针是变量，因此可以修改它的值。相邻的int地址通常相差2个字节或4个字节，而将p3加1后，它将指向下一个元素的地址，这表明指针算术有:些特别的地方。情况确实如此。</p>
<h2 id="指针、数组和指针算术"><a href="#指针、数组和指针算术" class="headerlink" title="指针、数组和指针算术"></a>指针、数组和指针算术</h2><p>指针和数组基本等价的原因在于指针算术( pointer arithmetic和C++内部处理数组的方式。算术。将整数变量加1后,其值将增加1;但将指针变量加1后,增加的量等于它指向的类型的字节数。将指向double的指针加1后,如果系统对double使用8个字节存储,则数值将增加8;将指向short的指针加1后,如果系统对 short使用2个字节存储,则指针值（存储的地址值）将增加2。C++将数组名解释为地址。</p>
<p>如数组表达式stack[1]，C++编译器将该表达式看作是*(stacks+1)，这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。<br>区别之一在于可以修改指针的值，而数组名是常量。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%884.26.08.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>另一个区别是，对数组应用sizeof操作符得到的数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。</p>
<h3 id="指针算术："><a href="#指针算术：" class="headerlink" title="指针算术："></a>指针算术：</h3><p>C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种运算才有意义;这将得到两个元素的间隔。</p>
<h3 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h3><p>cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。在C++中，用引号括起来的字符串像数组名一样，也是第一个元素的地址。</p>
<p><strong>在cout和多数C++表达式中, char数组名、指向char的指针以及用引号括起的宇符串常量都被解释为字符串第一个字符的地址。</strong></p>
<h3 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用new创建动态结构</h3><p>将new用于结构由两步组成:创建结构和访问其成员。要创建结构，需要同时使用结构类型和new。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%885.39.32.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这将把足以存储infatable结构的 块可用内存的地址赋给ps。 这种句法和C++的内置类型完全相同。</p>
<p>箭头成员操作符（-&gt;），可用于指向结构的指针，就像点操作符可用于结构名一样。如ps指向一个inflatable结构，则ps-&gt;price是被指向的结构的price成员。如果结构标识符是结构名，则使用句点操作符;如果标识符是指向结构的指针，则使用箭头操作符。</p>
<p>另一种访问结构成员的方法是，如果ps是指向结构的指针，则 <em> ps 就是被指向的值一结构本身。 由于 </em> ps是一个结构，因此( * ps) .price 是该结构的price 成员。C++的操作符优先规则要求使用括号。</p>
<h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C++有3种管理数据内存的方式: 自助存储、静态存储和动态存储(有时也叫作自由存储空间或堆)。</p>
<h4 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h4><p>在函数内部定义的常规变量使用自助存储空间，被称为自动变量(automatic variable),这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。</p>
<p>实际上，自动变量是一个局部变量，其作用域为包它的代码块。代码块是被包含在花括号中的一段代码。</p>
<h4 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h4><p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种:一种是在函数外面定义它:另一种是在声明变量时使用关键字static。</p>
<p>自动存储和静态存储的关键在于:这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期(静态变量)，也可能只是在特定函数被执行时存在(自动变量)。</p>
<h4 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h4><p>new和delete操作符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间(free store)。内存池同用于静态变量和自动变量的内存是分开的。new和delete允许在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期就不完全受到程序或函数的生存时间的控制了。与使用常规变量相比， 使用new和delete使程序员对程序如何使用内存有更大的控制权。</p>
<h3 id="堆栈、堆和内存泄露"><a href="#堆栈、堆和内存泄露" class="headerlink" title="堆栈、堆和内存泄露"></a>堆栈、堆和内存泄露</h3><p>如果使用new在自由空间（或堆）上创建变量后，没有调用delete，即使指针由于作用域规则和对象声明周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄露。被泄露的内存将在程序的整个生命周期都不可使用。</p>
<h1 id="循环和关系表达式"><a href="#循环和关系表达式" class="headerlink" title="循环和关系表达式"></a>循环和关系表达式</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%886.15.14.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>循环只执行一次初始化。</p>
<p>测试表达式结果为真，则程序将执行循环体，为假循环结束。<br>C++并没有将test expression的值限制为只能为真或假。可以使用任意表达式，C++将把结果强制转换为bool类型。因此， 值为0的表达式将被转换为bool值false,导致循环结束。 如果表达式的值为非零，则被强制转换为bool值true。</p>
<h3 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h3><p><strong>在C++中，每个表达式都有值。</strong><br>通常值是很明显的，如22+27<br>但x=20这个表达式由两个值和一个赋值操作符组成。C++将赋值表达式的值定义为左侧成员的值。因此maids=（x=20）+2可得maids为22。对于x=y=z=0，赋值操作符是从右向左结合的，因此首先将0赋给z，然后将z=0赋给y，以此类推。</p>
<p>从表达式到语句的转变是很小的一步，只要加一个分号就可以完成。</p>
<h3 id="递增操作符（-）和递减操作符（—）"><a href="#递增操作符（-）和递减操作符（—）" class="headerlink" title="递增操作符（++）和递减操作符（—）"></a>递增操作符（++）和递减操作符（—）</h3><p>a++意味着使用a的当前值计算表达式，然后将a的值加1;而++b的意思是先将b的值加1, 然后使用新的值来计算表达式。</p>
<h3 id="组合赋值操作符"><a href="#组合赋值操作符" class="headerlink" title="组合赋值操作符"></a>组合赋值操作符</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.08.16.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.10.42.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="可能犯的错误"><a href="#可能犯的错误" class="headerlink" title="可能犯的错误"></a>可能犯的错误</h3><p>==与=</p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.21.59.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="for与while"><a href="#for与while" class="headerlink" title="for与while"></a>for与while</h3><p>在C++中， for和while循环本质上是相同的。<br>可以相互改写。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>C++为类型建立别名的方式有两种。一种是使用预处理器<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.31.28.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这样，预处理器将在编译程序时用char替换所有的BYTE,从而使BYTE成为char的别名。<br>第二种方法是使用C++(和C)的关键字typedef来创建别名。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.32.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>如<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.34.04.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>也可以使用#define，不过声明一系列变量时，这种方法不适用。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.36.28.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>typedef方法不会有这样的问题。它能够处理更复杂的类型别名，这使得与使用#define相比，使用typedef时一种更佳的选择，有时也是唯一的选择。</p>
<p>注意, typedef不会创建新类型,而只是为已有的类型建立一个新名称。</p>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.47.25.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="嵌套循环和二维数组"><a href="#嵌套循环和二维数组" class="headerlink" title="嵌套循环和二维数组"></a>嵌套循环和二维数组</h2><p>声明数组：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.55.18.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.56.18.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.59.13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>对于二维数组，由于每个元素本身就是一个数组，因此可以使用与上述代码类似的格式来初始化每一个元素。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.00.15.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>}；</p>
<h1 id="分支语句和逻辑操作符"><a href="#分支语句和逻辑操作符" class="headerlink" title="分支语句和逻辑操作符"></a>分支语句和逻辑操作符</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="格式化if-else语句"><a href="#格式化if-else语句" class="headerlink" title="格式化if else语句"></a>格式化if else语句</h3><p>如果需要多条语句，需要用花括号将它们括起来，组成一个块语句。和有些语言不同的是，由于C++不会自动将if和else之间的所有代码视为一个代码块，因此必须使用花括号将这些语句组合成一个语句块。</p>
<h3 id="if-else-if-else结构"><a href="#if-else-if-else结构" class="headerlink" title="if else if else结构"></a>if else if else结构</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.12.54.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><h3 id="逻辑OR操作符："><a href="#逻辑OR操作符：" class="headerlink" title="逻辑OR操作符：| |"></a>逻辑OR操作符：| |</h3><h3 id="逻辑AND操作符：-amp-amp"><a href="#逻辑AND操作符：-amp-amp" class="headerlink" title="逻辑AND操作符：&amp;&amp;"></a>逻辑AND操作符：&amp;&amp;</h3><h3 id="逻辑NOT操作符：！"><a href="#逻辑NOT操作符：！" class="headerlink" title="逻辑NOT操作符：！"></a>逻辑NOT操作符：！</h3><h3 id="逻辑操作符细节"><a href="#逻辑操作符细节" class="headerlink" title="逻辑操作符细节"></a>逻辑操作符细节</h3><p>OR和AND操作符的优先级都低于关系操作符。这意味着<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.19.27.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>另一方面！操作符的优先级高于所有的关系操作符和算术操作符。因此，要对表达式求反，必须用括号将其括起来。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.20.31.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>逻辑AND操作符的优先级高于逻辑OR操作符。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.21.21.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="其他表示方式"><a href="#其他表示方式" class="headerlink" title="其他表示方式"></a>其他表示方式</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.22.56.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库cctype</h2><p>C++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（老式风格为ctype.h）中定义的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.34.27.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="？：操作符"><a href="#？：操作符" class="headerlink" title="？：操作符"></a>？：操作符</h2><p>C++有一个常被用来代替if else语句的操作符，这个操作符被称为条件操作符（?:），它是C++中唯一一个需要3个操作数的操作符。该操作符通用格式如下：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.36.37.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>如果expressionl 为true, 则整个条件表达式的值为expression2 的值; 否则，整个表达式的值为expression3的值。</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.53.54.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>注意使用break。</p>
<h3 id="将枚举量作为标签"><a href="#将枚举量作为标签" class="headerlink" title="将枚举量作为标签"></a>将枚举量作为标签</h3><h3 id="switch和if-else"><a href="#switch和if-else" class="headerlink" title="switch和if else"></a>switch和if else</h3><p>switch并不是为处理取值范围而设计的。switch语句中的每一个case标签都必须是一个单独的值。另外这个值必须是整数（包括char），因此switch无法处理浮点测试。如果既可以使用if else语句，也可以使用switch语句，则当选项不少于3个时，应使用switch语句。</p>
<h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h2 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h2><h3 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h3><ol>
<li>必须包含头文件iostream</li>
<li>头文件iostream定义了个用处理输入的istream类。</li>
<li>头文件iostream声明了一个名为cin的istream变量(对象)。</li>
<li>必须指明名称空间std;例如,为引用元素cin,必须使用编译指令 using或前缀std::。</li>
<li>可以结合使用cin和操作符&lt;&lt;来读取各种类型的数据。</li>
<li>可以使用cin和get（）方法来读取一个字符,使用cin和 getline（）来读取一行字符。</li>
<li>可以结合使用cin和eof()、fail()方法来判断输入是否成功。</li>
<li>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li>
</ol>
<h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><ol>
<li>必须包含头文件fstream</li>
<li>头文件 fstream定义了一个用于处理输入的 ifstream类。</li>
<li>需要声明一个或多个 ifstream变量(对象),并以自己喜欢的方式对其进行命名,条件是遵守常用的命名规则。</li>
<li>必须指明名称空间std:例如，为引用元素ifstream, 必须使用编译指令using 或前缀std:.。</li>
<li>需要将ifstream对象与文件关联起来。为此， 方法之一是使用open()方法。</li>
<li>使用完文件后，应使用close()方法将其关闭。</li>
<li>可结合使用ifstream对象和操作符&lt;&lt;来读取各种类型的数据。</li>
<li>可以使用ifstream 对象和get() 方法来读取一个字符， 使用ifstream对象和getine()来读取一行字符。</li>
<li>可以结合使用ifstream 和eof()、 fail()等方法来判断输入是否成功。</li>
<li>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true,否则被转换为false。</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>分为有返回值函数和无返回值函数。<br>void：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%888.56.12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>有返回值：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%889.00.42.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>C++对于返回值的类型有一定的限制:不能是数组，但可以是其他任何类型，如整数、浮点数、指针，甚至可以是结构和对象(有趣的是，虽然C++函数不能直接返回数组，但可以将数组作为结构或对象组成部分来返回)。</p>
<p>通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。</p>
<h3 id="函数原型和函数调用"><a href="#函数原型和函数调用" class="headerlink" title="函数原型和函数调用"></a>函数原型和函数调用</h3><h4 id="为什么需要原型"><a href="#为什么需要原型" class="headerlink" title="为什么需要原型"></a>为什么需要原型</h4><p>原型描述了函数到编译器的接口，即，将函数的返回值类型（如果有的话）以及参数的类型和数量告诉编译器。</p>
<h4 id="原型的句法"><a href="#原型的句法" class="headerlink" title="原型的句法"></a>原型的句法</h4><p>函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.36.24.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>在函数原型中不要求提供变量名，有类型列表就足够了。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.37.33.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。</p>
<h4 id="原型的功能"><a href="#原型的功能" class="headerlink" title="原型的功能"></a>原型的功能</h4><p>原型可以帮助编译器完成许多工作，可以极大地降低程序出错的几率，具体说，原型确保：</p>
<ol>
<li>编译器正确处理函数返回值。</li>
<li>编译器检查使用的参数数目是否正确。</li>
<li>编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型（如果可能的话）。</li>
</ol>
<p>静态类型检查可捕获许多在运行阶段非常难以捕获的错误。</p>
<h2 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h2><p>C++使用参数（argument）来表示实参，使用参量（parameter）来表示形参。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.54.10.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.07.30.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。arr实际上并不是数组，而是一个指针。在编写函数的其余部分时，可以将arr看作是数组。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.09.57.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>其中使用int <em> arr 替换了int arr [] 。这证明这两个函数头都是正确的，因为在C++中，当(且仅当)用于函数头或函数原型中，int </em> arr 和int arr[ ]的含义才是相同的。它们都意味着arr是一个int指针。不过，数组表示法(int arr[]) 提醒用户，arr 不仅指向int, 还指向int数组的第一个int。当指针指向数组的第一个元素时， 本书使用数组表示法;而当指针指向一个独立的值时，使用指针表示法。 别忘了，在其他的上下文中，int * arr和int arr[]的含义并不相同。例如， 不能在函数体中使用int tip[ ]来声明指针。<br>两个恒等式：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.14.41.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型长度相等的值。对于遍历数组而言，使用指针加法和数组下标是等效的。</p>
<h3 id="将数组作为参数意味着什么"><a href="#将数组作为参数意味着什么" class="headerlink" title="将数组作为参数意味着什么"></a>将数组作为参数意味着什么</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.21.44.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>将数组地址作为参数可以节省复制整个数组所需的时间和内存。 如果数组很大，则使用拷贝的系统开销将非常大;程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。可以使用const来解决这个问题。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.25.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h3><p>对于处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C、C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供了找到所有数据所需的信息。</p>
<p>还有另一种给两数提供所需信息的方法，即指定元素区间(range), 这可以通过传递两个指针来完成:一个指针标识数组的开头，另一个指针标识数组的尾部。</p>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>可以用两种不同的方式将const用于指针。第一种是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值。第二种是将指针本身声明为常量，这样可以防止改变指针指向的位置。<br>指向常量的指针pt:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.51.42.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt 指向age, 而age不是const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它。</p>
<p>可以将const变量的地址赋给指向const的指针，但不能将const地址赋给常规指针。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.56.12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.03.53.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>上述函数调用试图将const指针赋给非const指针，编译器将禁止这种函数调用。</p>
<p>第二种使用const的方式使得无法修改指针的值。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.12.05.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>关键字const的位置与之前不同。这种声明格式使得finger只能指向sloth,但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。</p>
<h2 id="函数和二维数组"><a href="#函数和二维数组" class="headerlink" title="函数和二维数组"></a>函数和二维数组</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.25.02.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>data是一个数组名，该数组有3个元素。每个元素都是数组，由4个int值组成。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.22.33.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="函数和C-风格字符串"><a href="#函数和C-风格字符串" class="headerlink" title="函数和C-风格字符串"></a>函数和C-风格字符串</h2><h3 id="将c-风格字符串作为参数的函数"><a href="#将c-风格字符串作为参数的函数" class="headerlink" title="将c-风格字符串作为参数的函数"></a>将c-风格字符串作为参数的函数</h3><p>假设要将字符串作为参数传递给函数，表示字符串的方式有3种：</p>
<ol>
<li>char数组。</li>
<li>用引号括起的字符串常量。</li>
<li>被设置为字符串的地址的char指针</li>
</ol>
<p>3种选择的类型都是char指针（即char <em> ），可将其作为字符串处理函数的参数。字符串函数原型应将其表示字符串的形参声明为char </em> 指针。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.31.50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="返回C-风格字符串的函数"><a href="#返回C-风格字符串的函数" class="headerlink" title="返回C-风格字符串的函数"></a>返回C-风格字符串的函数</h3><p>函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。</p>
<p>要创建包含n个字符的字符串，需要能够存储n+1个字符的空间，以便能够存储空值字符。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>分为以下三个步骤。</p>
<h3 id="获取函数地址"><a href="#获取函数地址" class="headerlink" title="获取函数地址"></a>获取函数地址</h3><p>获取函数的地址很简单，只要使用函数名（后面不跟参数）即可。一定要区分传递的是函数的地址还是函数的返回值。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.06.52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="声明函数指针"><a href="#声明函数指针" class="headerlink" title="声明函数指针"></a>声明函数指针</h3><p>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.10.57.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><strong>提示:通常，要声明指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用( * pf)替换函数名，这样pf就是这类函数的指针。</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.15.45.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>正确地声明pf后，便可以将对应函数的地址赋给它：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.17.30.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="使用指针来调用函数"><a href="#使用指针来调用函数" class="headerlink" title="使用指针来调用函数"></a>使用指针来调用函数</h3><p>使用指针来调用被指向的函数。（ <em> pf）扮演的角色与函数名相同，因此使用（ </em> pf）时，只需将它看做函数名即可。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.24.18.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>C++进行了折衷，这2种方式都是正确的。</p>
<h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><p>内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。</p>
<p>内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，然后再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数的10个代码拷贝。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.40.38.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>要使用这项特性，必须采用下述措施之一：</p>
<ol>
<li>在函数声明前加关键字inline。</li>
<li>在函数定义前加上关键字inline。</li>
</ol>
<p>程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己(内联函数不能递归)，因此不将其作为内联函数;而有些编译器没有启用或实现这种特性。</p>
<h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>C和C++使用&amp;符号来指示变量的地址。C++给&amp;符号赋了了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.00.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>其中,  &amp; 不是地址操作符，而是类型标识符的一部分。就像声明中的char * 指的是指向char的指针一样,int  &amp; 指的是指向int的引用。</p>
<p>看似引用和指针用法很类似，其实是有差别的，差别之一是，必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.05.34.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>引用更接近const指针，鼻血在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.18.47.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.39.02.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="引用的属性和特别之处"><a href="#引用的属性和特别之处" class="headerlink" title="引用的属性和特别之处"></a>引用的属性和特别之处</h3><h4 id="临时变量、引用参数和const"><a href="#临时变量、引用参数和const" class="headerlink" title="临时变量、引用参数和const"></a>临时变量、引用参数和const</h4><p>如果实参与引用参数不匹配，C++将生成临时变量。仅当参数为const引用时，C++才允许这样做。</p>
<p>如果引用参数时const，则编译器将在下面两种情况下生成临时变量：</p>
<ol>
<li>实参的类型正确，但不是左值。</li>
<li>实参的类型不正确，但可以转换为正确的类型。</li>
</ol>
<p>左值参数时可被引用的数据对象，例如，变量、数组元素、结构成员、引用和被解除引用的指针都是左值。非左值包括字面常量和包含多项的表达式。</p>
<p>记住:如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p>
<h3 id="应尽可能使用const"><a href="#应尽可能使用const" class="headerlink" title="应尽可能使用const"></a>应尽可能使用const</h3><p>将引用参数声明为常量数据的引用的理由有3个:</p>
<ol>
<li>使用const可以避免无意中修改数据的编程错误。</li>
<li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据。</li>
<li>使用const引用使函数能够正确生成并使用临时变量。</li>
</ol>
<p>因此，应尽可能将引用形参声明为const。</p>
<h3 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>引用非常适合用于结构和类(C++的用户定义类型).确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。</p>
<h3 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h3><p>使用引用参数的主要原因有两个：</p>
<ol>
<li>程序员能够修改调用函数的数据对象。</li>
<li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li>
</ol>
<p>当数据对象较大时(如结构和类对象),第二个原因最重要。这些也是使用指针参数的原因。这是有道理的,因为引用参数实际上是基于指针的代码的另一个接口。</p>
<p>指导原则<br>对于使用传递的值而不作修改的函数:</p>
<ol>
<li>如果数据对象很小,如内置数据类型或小型结构,则按值传递。</li>
<li>如果数据对象是数组,则使用指针,因为这是惟一的选择,并将指针声明为指向 const的指针。</li>
<li>如果数据对象是较大的结构,则使用 const指针或 const引用,以提高程序的效率。这样可以节省复制结构所需的时间和空间。</li>
<li>如果数据对象是类对象,则使用 const引用。类设计的语义常常要求使用引用,这是C+新增这项特性的主要原因。因此,传递类对象参数的标准方式是按引用传递。</li>
</ol>
<p>对于修改调用函数中数据的函数。</p>
<ol>
<li>如果数据对象是内置数据类型，则使用指针。</li>
<li>如果数据对象是数组，则只能使用指针。</li>
<li>如果数据对象是结构， 则使用引用或指针。</li>
<li>如果数据对象是类对象，则使用引用。</li>
</ol>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边所有的参数提供默认值：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.40.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>实参按从左到右的顺序依次被賦给相应的形参，而不能跳过任何参数。下面的调用是不允许的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.43.15.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>默认参数不是编程方面的重大突破，而只是提供了一种便捷的方式。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>所数重载的关键是函数的参数列表一也称为函数特 征标( function signature). 如果两个函数的参数数目和类型相同， 同时参数的排列顺序也相同，则它们的特征标相同， 而变量名是无关紧要的。C++ 允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和或参数类型不同，则特征标也不同。</p>
<p>一些看起来彼此不同的特征标是不能共存的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.15.54.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>为避免混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。</p>
<h3 id="何时使用函数重载"><a href="#何时使用函数重载" class="headerlink" title="何时使用函数重载"></a>何时使用函数重载</h3><p>函数重载很吸引人，但也不能滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时才应采用函数重载。</p>
<p>使用一个带默认参数的函数要简单些。只需编写一个函数(而不是两个函数)，程序也只需为一个函数(而不是两个)请求内存:需要修改函数时，只需修改一个。不过，如果需要使用不同类型的参数时，则默认参数便不管用了， 在这种情况下，应该使用函数重载。</p>
<h3 id="名称修饰"><a href="#名称修饰" class="headerlink" title="名称修饰"></a>名称修饰</h3><p>使用C++开发工具中的编辑器编写和编译程序时，C++将执行一些神奇的操作，名称修饰或名称矫正。根据函数原型中指定的形参类型对每个函数名进行加密。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板是通用的函数描述，就是使用通用类型来定义函数，其中的通用类型可用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.44.01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>建立一个模板，将类型命名为Any。关键字template和class是必需的，类型名可以任意选择。关键字typename可用来替换关键字class，就是说可以编写模板定义：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.46.19.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><strong>提示: 如果需要多个将同一种算法用于不同类型的函数，请使用模板，如果不考虑向后兼容的问题，并愿意键入较长的单词, 则声明类型参数时，应使用关键字typename而不使用class。</strong></p>
<h3 id="重载的模板"><a href="#重载的模板" class="headerlink" title="重载的模板"></a>重载的模板</h3><p>需要多个对不同类型使用同一种算法的函数时，可使用模板。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.54.32.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h3><p>在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。模板并非函数定义，但使用int的模板实例是函数定义。这种实例化方式被称为隐式实例化，因为编译器之所以知道需要进行定义，是由于程序调用Swap（）函数时提供了int参数。</p>
<p>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，C++还允许显示实例化。这意味着可以直接命令编译器创建特定的实例，Swap<int>()。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.26.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>显示具体化使用下面两个等价声明之一：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.40.36.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>显示具体化声明在关键字Template后包含&lt;&gt;，而显式实例化没有。</int></p>
<p><strong>警告：视图在同一个编程单元中使用同一类型的显示实例和显示具体化将出错。</strong></p>
<p>隐式实例化、显式实例化和显式具体化统称为具体化(specialization)。 它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。</p>
<h1 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h1><p>C++为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据（作用域和链接）等。可以使用new来动态地分配内存而布局new操作符提供了这种技术的一种变种。C++名称空间是另一种控制访问权的方式。通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据。这样的程序涉及到程序文件的单独编译。</p>
<h2 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h2><p>和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。 可以单独编译这些文件，然后将它们链接成可执行的程序(通常，C++编译器既编译程序，也管理链接器)。,如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。另外，大多数C++环境都提供了其他工具来帮助管理。例如，UNIX和Linux系统都具有make程序， 可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序所需的步骤。</p>
<p>可以将原来的程序分为三部分：</p>
<ol>
<li>头文件：包含结构声明和使用这些结构的函数的原型</li>
<li>源代码文件：包含与结构有关的函数的代码。</li>
<li>源代码文件：包含调用与结构相关的函数的代码。</li>
</ol>
<p>不要将函数定义或变量声明放到头文件中。例如，如果在头文件包含—个函数定义，然后在其他两个文件(属于同一个程序)中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数是内联的， 否则这将出错。</p>
<p>下面列出了头文件中常包含的内容:</p>
<ol>
<li>函数原型</li>
<li>使用# define或const定义的符号常量</li>
<li>结构声明</li>
<li>类声明</li>
<li>模板声明</li>
<li>内联函数</li>
</ol>
<p>模板声明不是将被编译的代码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。被声明为const的数据和内联函数有特殊的链接属性，因此可将其放在头文件而不会引起问题。</p>
<p>注意，在包含头文件时，<br>我们使用“coordin.h”,而不是&lt; coodin.h &gt;。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找:但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录(或其他目录，这取决于编译器)。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用引号而不是尖括号。</p>
<p>在IDE中，不要将头文件加入到工程列表中，也不要在源代码文件中使用# include 来包含其他源代码文件。</p>
<h3 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h3><p>在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。例如， 可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef(即if not defined)的。下面的代码片段:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8810.57.59.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>意味着仅当以前没有使用预处理器编译指令# define定义名称COORDIN_H_时，才处理# ifndef和# endif之间的语句。</p>
<p>通常，使用# define语句来创建符号常量。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>但只要将# define用于名称，就足以完成该名称的定义。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.41.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>编译器首次遇到该文件时，名称COORDIN_H_没有定义（我们根据include文件名来选择名称，并加一些下划线，以创建一个在其他地方不太可能被定义的名称）。如果在同一个文件中遇到其他包含coordin.h的代码，编译器将知道COORDIN_H_已经被定义了，从而跳到# endif后面的一行上。这种方法并不能防止编译器将文件包含两次，而只是让它忽略了第一次包含之外的所有内容。大多数标准C和C++头文件都使用这种防护(guarding)方案。</p>
<h2 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h2><h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的名称，可在文件间共享，连接性为内部的名称，只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它不能共享。</p>
<h3 id="作用域和链接"><a href="#作用域和链接" class="headerlink" title="作用域和链接"></a>作用域和链接</h3><p>作用域（scope）描述了名称在文件的多大范围内可见。链接性(linkage) 描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。</p>
<h3 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h3><p>在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动， 作用域为局部，没有链接性。当程序开始执行这些变量所属的代码块时，将为其分配<br>内存;当函数结束时，这些变量都将消失(注意，执行到代码块时，将为变量分配内存， 但其作用域的起点为其声明位置)。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.50.33.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>可以使用C++ (和C)关键字auto 来显式地指出存储类别:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.52.13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="自动变量和堆栈"><a href="#自动变量和堆栈" class="headerlink" title="自动变量和堆栈"></a>自动变量和堆栈</h4><p>由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。常用的方法是<strong>留出一段内存，并将其视为堆栈</strong>，以管理变量的增减。之所以被称为堆栈，是由于新数据被象征性地放在原有数据的上面(也就是说，在相邻的内存单元中，而不是在同一个内存单元中)，当程序使用完后，将其从堆栈中删除。堆栈的默认长度取决于实现，但编译器通常提供改变堆栈长度的选项。程序使用两个指针来跟踪堆栈，一个指针指向栈底即堆栈的开始位置，另一个指针指向堆顶即下一个可用内存单元。当函数被调用时，其自动变量将被加入到堆栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p>
<p>堆栈是后进先出的，即最后加入到堆栈中的变量首先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.05.02.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>所以说形参存在于堆栈。堆栈是内存留出的一小段。</p>
<h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>和C语言一样，C++也支持使用register关键字来声明局部变量。寄存器变量是另一种形式的自动变量，因此其存储持续性为自动，作用域为局部，但没有链接性。关键字register提醒编译器，用户希望它通过使用CPU寄存器，而不是堆栈来处理特定的变量，从而提供对变量的快速访问。这里的理念是，CPU访问寄存器中的值的速度比访问堆栈中内存快。要声明寄存器变量，请在类型前加上关键字register:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.11.15.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>现代编译器已经足够聪明，在编写for循环时，编译器可能自动使用寄存器来存储循环计数。</p>
<p>如果变量被存储在寄存器则没有内存地址，因此不能讲地址操作符用于寄存器变量。</p>
<p>简而言之，常规局部变量、使用auto 声明的局部变量以及使用register 声明的局部变量的存储持续性都是自动的， 作用域都是局部的，也都没有链接性。</p>
<p>声明局部变量时，如果没有使用说明符，则与使用auto声明变量等效。通常， 处理这种变量的方式是将其放置到内存堆栈中。使用register说明符指出该变量将被频繁使用，编译器可能会选择使用内存堆栈之外的其他方式(如使用CPU寄存器)来存储它。</p>
<h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><p>和C语言一样，C++也为静态存储持续性变量提供了3种链接性:外部链接性、内部链接性和无链接性。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置(如堆栈)来管理它们。<strong>编译器将分配固定的内存块来存储所有的静态变量</strong>，<strong>这些变量在整个程序执行期间一直存在</strong>。另外， 如果没有显式地初始化静态变量，编译器就将把它<strong>设置为0</strong>。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。</p>
<p>要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它; 要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符:要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.16.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>所有静态持续变量在整个程序执行期间都存在。在funct1（）中声明的变量count的作用域为局部，没有链接性，这意味着只能在funct1（）函数中使用它，就像自动变量一样，但不同之处在于，即使函数没有执行时，count也留在内存中。global和one_file的作用域为整个文件，即在从声明位置到文件结尾的范围内都可以被使用。由于one_file的链接性为内部，因此只能在包含上述代码的文件中；由于global的链接性为外部，因此可以在程序的其他文件中使用它。</p>
<p>所有静态持续变量只能使用常量表达式来初始化静态变量。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.54.35.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言都是外部的。外部变量也称为全局变量。如果定义了与外部变量同名的自动变量，该自动变量将隐藏同名的外部变量。</p>
<p>关键字extern的意思是“通过以前被外部定义的名称使用该变量”。外部变量声明：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.12.05.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>称为定义声明，给该变量分配存储空间。重新声明：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.13.21.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>称为引用声明，或简称为声明。它不给变量分配存储空间，因为它引用已有的变量。只能在引用其他地方（或函数）定义的变量的声明中使用关键字extern。当试图赋值时将会报错。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.23.43.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>仅当声明将为变量分配存储空间时（即定义声明），才能在声明中初始化变量。毕竟，初始化指的是在分配内存单元时给它赋值。</p>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>过多使用全局变量会破坏数据的完整性，外部存储尤其适于表示常量数据，因为这样可以使用关键字const来防止数据被修改。</p>
<h3 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h3><p>对于外部链接变量，有且只有一个文件中包含了该变量的外部定义，其他文件要使用该变量，必须在引用声明中使用关键字extern。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.07.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>如果文件试图定义另一个同名的外部变量将出错：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.54.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.39.56.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="静态存储持续性、无连接性"><a href="#静态存储持续性、无连接性" class="headerlink" title="静态存储持续性、无连接性"></a>静态存储持续性、无连接性</h3><p>如果初始化了静态局部变量，则程序只在启动时进行一次初始化，以后再调用函数时，将不会像自动变量那样再次被初始化。</p>
<h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><p>存储说明符：</p>
<ol>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
</ol>
<p>在同一个声明中不能使用多个说明符。mutable 是为了突破 const 的限制而设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态，即使是 const 函数中也可以改变这个变量的值。</p>
<p>cv限定符：</p>
<ol>
<li>const</li>
<li>volatile(易变的，不稳定的)</li>
</ol>
<p><strong>volatile</strong>关键字表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。听起来似乎很神秘，实际上并非如此。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。在这种情况下，硬件(而不是程序)可能修改其中的内容。或者两个程序可能互相影响，共享数据。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile, 则编译器将进行这种优化;将变量声明为volatile,相当于告诉编译器，不要进行这种优化。避免出现和想象结果不一致的情况。</p>
<h3 id="再谈const"><a href="#再谈const" class="headerlink" title="再谈const"></a>再谈const</h3><p>在C++中，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，在C++看来， 全局const定义就像使用了static说明符一样。（就链接性而言）</p>
<p>内部链接还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量。每个定义都是共所属文件私有的，这就是能够将常量定义放在头文件中的原因。这样，只要在两个源代码文件中包括同一个头文件，则它们将获得同一组常量。</p>
<p>如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.09.28.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这种情况下，必须在所有使用该常量的文件中使用extem关键字来声明它。这与常规外部变量不同，定义常规外部变量时，不必使用extem关键字，但在使用该变量的其他文件中必须使用extem。</p>
<h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><p>C++不允许在一个函数中定义另一个函数，因此所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。可以在函数原型中使用关键字extern来指出函数时再另一个文件中定义的，不过这是可选的（要让程序在另一个文件中查找函数， 该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件)。还可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义汇总使用该关键字。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.31.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这意味着该函数以在这个文件中可见，还意味着可以在其他文件中定义同名的的函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。</p>
<p>C++有一个“单定义规则”，即对于每个非内联函数，程序中只能包含一个定义。对于链接性为外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。</p>
<p>内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定义。不过，C++要求同一个函数的所有内联定义都必须相同。</p>
<h3 id="C-在哪里查找函数"><a href="#C-在哪里查找函数" class="headerlink" title="C++在哪里查找函数"></a>C++在哪里查找函数</h3><p>如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义;否则， 编译器(包括链接程序)将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。<br>如果在程序文件中没有找到， 编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数， 编译器将使用程序员定义的版本， 而不是库函数(不过，C++保留了标准库函数的名称，即程序员不应使用它们).一些编译器-链接程序要求显式地指出要搜索哪些库。</p>
<h3 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h3><p>另一种形式的链接性称为语言链接性，也对函数有影响。链接程序要求每个不同的函数都有不同的符号名。在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。例如， 可能将spiff (int)转换为_spof_i,而将spiff (double, double) 转换为_spif_d_d.这种方法被称为C++语言链接(C++ language linkage)。</p>
<p>链接程序寻找与C++函数调用匹配的函数时，使用的方法与c语言不同。但如果要在c++程序中使用C库中预编译的兩数，将出现什么情况呢?例如，假设有下面的代码:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.53.00.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>它在C库文件中的符号名称为_spif, 但对于我们假设的链接程序来说，C++查询约定是查找符号名称<em>spiff</em> i。为解决这种问题，可以用函数原型来指出要使用的约定:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.54.21.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>第个原型使用C语言链接性:而后面的两个使用C+语言链接性。第二个原型是通过默认方式指出这一点的，而第三个显式地指出了这一点。</p>
<h3 id="存储方案和动态分配"><a href="#存储方案和动态分配" class="headerlink" title="存储方案和动态分配"></a>存储方案和动态分配</h3><p>与自动内存不同，动态内存不是LIFO,其分配和释放顺序要取决于new和delete 在何时以何种方式被使用。通常，<strong>编译器使用3块独立的内存:一块用于静态变量(可能再细分)，一块用于自动变量， 另外一块用于动态存储。</strong></p>
<p>如果将p_fees的链接性声明为外部的，则文件中位于该声明后面的所有函数都<br>可以使用它。另外，通过在另一个文件中使用：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.13.35.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>可以在这个文件中使用该指针。不过，请注意， 使用new来设置p_ fees 的语句必须位于函数中(如下面的代码段所示)，这是因为只能使用常量表达式来初始化静态存储变量:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.14.52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.15.03.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><strong>注意: 在程序结束时，由new分配的内存通常都将被释放，不过情况也并不总是这样。例如,在不那么健壮的操作系统中，在某些情况下，请求大型内存块将导致该代码块在程序结束不会被自动释放。最佳的做法是， 使用delete 来释放new分配的内存。</strong></p>
<h2 id="布局new操作符"><a href="#布局new操作符" class="headerlink" title="布局new操作符"></a>布局new操作符</h2><p>new负责在<strong>堆(heap)</strong> 中找到一个足以能够满足要求的内存块。new操作符还有另一种变体，被称为布局(placement)new操作符，它能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程或处理需要通过特定地址进行访问的硬件。要使用布局new特性，首先需要包含头文件new。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.25.14.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>它提供了new操作符原型，下面是new操作符的四种用法：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.26.44.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>其中如果buffer是静态存储区，那么就new到了静态存储区。而常规new就到了动态管理的堆中。</p>
<p>由于buffer指定的内存是静态内存，而delete只能指向常规new操作符分配的堆内存，就是说数组buffer位于delete的管辖区域之外。</p>
<h2 id="名称空间-1"><a href="#名称空间-1" class="headerlink" title="名称空间"></a>名称空间</h2><p>当随着工程的增大，名称相互冲突的可能性也将增加。使用多个厂商的类库时，可能导致名称冲突。C++标准提供了名称空间工具，以便更好地控制名称的作用域。</p>
<h3 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h3><p>几个概念：<br><strong>声明区域</strong>(declaration region)。 声明区域是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块。</p>
<p><strong>潜在作用域</strong>。变量的潜在作用域从声明点开始,到其声明域的结尾。因此潜在作用域比声明区域小,这是由于变量必须定义后才能使用。</p>
<h3 id="新的名称空间特性"><a href="#新的名称空间特性" class="headerlink" title="新的名称空间特性"></a>新的名称空间特性</h3><p>C++新增了这样一种功能,即通过定义一种新的声明区域来创建命名的名称空间,这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突,同时允许程序的其他部分使用该名称空间中声明的东西。例如,下面的代码使用新的关键字 namespace创建了两个名称空间:Jack和Jill。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.09.52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>名称空间可以是全局的,也可以位于另一个名称空间中,但不能位于代码块中。因此,在默认情况下,在名称空间中声明的名称的链接性为外部的(除非它引用了常量)</p>
<p>除了用户定义的名称空间外，还存在另一个名称空间一全局名称空间(global namespace)。 它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。</p>
<p>任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。</p>
<p>当然, 需要有一种方法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析操作符::,使用名称空间来限定该名称。未被装饰的名称(如pail)被称为未限定的名称(unqualifed name);包含名称空间的名称(如Jack;pail)被称为限定的名称(qualified name).</p>
<h4 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h4><p>如果不希望每次使用名称都使用：：，C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。using声明使特定的表示符可用，using编译指令使整个名称空间可用。</p>
<p>using声明由限定的名称和它前面的关键字using组成：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.24.43.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>using编译命令使所有的名称都可用。using编译命令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析操作符：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.32.31.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="using编译指令和using声明值比较"><a href="#using编译指令和using声明值比较" class="headerlink" title="using编译指令和using声明值比较"></a>using编译指令和using声明值比较</h4><p>使用using编译指令导入一个名称空间中所有的名称与使用using声明是不一样的，而更像是大量使用作用域解析操作符。使用 using声明时,就好像声明了相应的名称一样。如果某个名称已经在函数中声明了,则不能用 using声明导入相同的名称。然而,使用 using编译指令时,将进行名称解析,就像在包含 using声明和名称空间本身的最小声明区域中声明了名称一样。在下面的范例中,名称空间为全局的。如果使用 using编译指令导入一个已经在函数中声明的名称,则局部名称将隐藏名称空间名,就像隐藏同名的全局变量样。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.11.32.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>一般来说，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
<h4 id="名称空间的其他特性"><a href="#名称空间的其他特性" class="headerlink" title="名称空间的其他特性"></a>名称空间的其他特性</h4><p>可以将名称空间声明进行嵌套。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.39.59.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这里flame指的是element:: fire  ::flame。</p>
<h4 id="未命名的名称空间"><a href="#未命名的名称空间" class="headerlink" title="未命名的名称空间"></a>未命名的名称空间</h4><p>可以通过省略名称空间的名称来创建未命名的名称空间：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.48.41.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>不能再未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称，因此这种方法可以替代链接性为内部的静态变量。</p>
<h3 id="名称空间的指导原则"><a href="#名称空间的指导原则" class="headerlink" title="名称空间的指导原则"></a>名称空间的指导原则</h3><ol>
<li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li>
<li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。</li>
<li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。（其实若冲突IDE中会报含糊不清错误）</li>
<li>不要在头文件中使用using 编译指令。首先，这样做掩盖了要让哪些名称可用;另外， 包含头文件的顺序可能影响程序的行为。 如果非要使用编译指令using,应将其放在所有预处理器编译指令#include之后。</li>
<li>导入名称时， 首选使用作用域解析操作符或using声明的方法。</li>
<li>对于using声明，首选将其作用域设置为局部而不是全局。</li>
</ol>
<p>对于简单程序，使用using编译指令并非什么大逆不道的事。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-12-18T07:31:47.000Z" itemprop="dateUpdated">2018-12-18 15:31:47</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://github.com/zdkswd">
            <img src="/img/tmg.jpg" alt="ZDK">
            ZDK
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/&title=《C++ Primer 类之前》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/&title=《C++ Primer 类之前》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++ Primer 类之前》 — ZDK's blog&url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/12/07/具体数学 Interger Functions/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">具体数学 Interger Functions</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz",
            appKey: "gkBx5soQkBREmER84PWbNJeM",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>ZDK &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/&title=《C++ Primer 类之前》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/&title=《C++ Primer 类之前》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++ Primer 类之前》 — ZDK's blog&url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://github.com/zdkswd/2018/12/18/C++ Primer 类之前/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'zdk'blog';
            clearTimeout(titleTime);
        } else {
            document.title = '';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
