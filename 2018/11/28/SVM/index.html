<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>SVM | ZDK&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="机器学习">
    <meta name="description" content="已修改 统计学习方法 支持向量机支持向量机（support vector machines,SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则">
<meta name="keywords" content="机器学习">
<meta property="og:type" content="article">
<meta property="og:title" content="SVM">
<meta property="og:url" content="https://github.com/zdkswd/2018/11/28/SVM/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:description" content="已修改 统计学习方法 支持向量机支持向量机（support vector machines,SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.47.24.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.51.01.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.55.46.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.58.01.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.13.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.36.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.18.41.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.34.11.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.40.56.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.44.47.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.46.45.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.24.01.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.25.49.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.31.50.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.35.40.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.39.04.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.42.43.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.47.50.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.48.18.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.50.43.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.52.53.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.28.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.48.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.06.12.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.07.41.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.17.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.44.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.04.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.23.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.41.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.00.06.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.01.31.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.02.46.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.03.49.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.13.31.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.19.50.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.21.49.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.25.26.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.27.25.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.16.png">
<meta property="og:image" content="https://github.com/img/add/17.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.49.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.05.30.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.13.36.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.17.44.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.18.27.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.20.48.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.27.37.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.30.02.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.33.30.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.03.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.17.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.42.22.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.28.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.39.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.36.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.49.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.29.18.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.28.02.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.32.35.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.34.11.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.18.59.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.19.49.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.20.19.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.23.30.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.25.44.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.29.04.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.32.46.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.34.52.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.43.43.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.44.06.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.46.35.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.52.24.png">
<meta property="og:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.54.40.png">
<meta property="og:image" content="https://github.com/img/add/8.png">
<meta property="og:image" content="https://github.com/img/add/9.png">
<meta property="og:image" content="https://github.com/img/add/10.png">
<meta property="og:image" content="https://github.com/img/add/11.png">
<meta property="og:image" content="https://github.com/img/add/12.png">
<meta property="og:image" content="https://github.com/img/add/13.png">
<meta property="og:image" content="https://github.com/img/add/14.png">
<meta property="og:image" content="https://github.com/img/add/15.png">
<meta property="og:image" content="https://github.com/img/add/16.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_7.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_48.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_49.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_50.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_51.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_52.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_53.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_54.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_55.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_58.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_59.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_60.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_61.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_106.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_107-1.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_108.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml-8-109.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_110.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_111.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_112.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_8_113.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_9_4.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_9_25.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_9_5.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_9_12.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_9_13.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_9_14.png">
<meta property="og:image" content="https://github.com/img/media/SVM/ml_9_15.png">
<meta property="og:image" content="https://github.com/img/add/18.png">
<meta property="og:image" content="https://github.com/img/add/19.png">
<meta property="og:updated_time" content="2018-12-02T11:49:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SVM">
<meta name="twitter:description" content="已修改 统计学习方法 支持向量机支持向量机（support vector machines,SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则">
<meta name="twitter:image" content="https://github.com/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.47.24.png">
    
        <link rel="alternate" type="application/atom+xml" title="ZDK&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/tmg.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">ZDK</h5>
          <a href="mailto:2822464407@qq.com" title="2822464407@qq.com" class="mail">2822464407@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zdkswd" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">SVM</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">SVM</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-11-28T12:48:47.000Z" itemprop="datePublished" class="page-time">
  2018-11-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/知识总结/">知识总结</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#统计学习方法-支持向量机"><span class="post-toc-number">1.</span> <span class="post-toc-text">统计学习方法 支持向量机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线性可分支持向量机与硬间隔最大化"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">线性可分支持向量机与硬间隔最大化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线性可分支持向量机"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">线性可分支持向量机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义（线性可分支持向量机）"><span class="post-toc-number">1.1.1.1.</span> <span class="post-toc-text">定义（线性可分支持向量机）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数间隔和几何间隔"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">函数间隔和几何间隔</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义（函数间隔）"><span class="post-toc-number">1.1.2.1.</span> <span class="post-toc-text">定义（函数间隔）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义（几何间隔）"><span class="post-toc-number">1.1.2.2.</span> <span class="post-toc-text">定义（几何间隔）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#间隔最大化"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">间隔最大化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大间隔分离超平面"><span class="post-toc-number">1.1.3.1.</span> <span class="post-toc-text">最大间隔分离超平面</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#线性可分支持向量机学习——最大间隔法"><span class="post-toc-number">1.1.3.1.1.</span> <span class="post-toc-text">线性可分支持向量机学习——最大间隔法</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大间隔分离超平面的存在唯一性"><span class="post-toc-number">1.1.3.2.</span> <span class="post-toc-text">最大间隔分离超平面的存在唯一性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#定理（最大间隔分离超平面的存在唯一性）"><span class="post-toc-number">1.1.3.2.1.</span> <span class="post-toc-text">定理（最大间隔分离超平面的存在唯一性）</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#支持向量和间隔边界"><span class="post-toc-number">1.1.3.3.</span> <span class="post-toc-text">支持向量和间隔边界</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#例"><span class="post-toc-number">1.1.3.4.</span> <span class="post-toc-text">例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#学习的对偶算法"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">学习的对偶算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定理"><span class="post-toc-number">1.1.4.1.</span> <span class="post-toc-text">定理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#算法（线性可分支持向量机学习算法）"><span class="post-toc-number">1.1.4.2.</span> <span class="post-toc-text">算法（线性可分支持向量机学习算法）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#支持向量"><span class="post-toc-number">1.1.4.3.</span> <span class="post-toc-text">支持向量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#例-1"><span class="post-toc-number">1.1.4.4.</span> <span class="post-toc-text">例</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线性支持向量机与软间隔最大化"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">线性支持向量机与软间隔最大化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线性支持向量机"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">线性支持向量机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义（线性支持向量机）"><span class="post-toc-number">1.2.1.1.</span> <span class="post-toc-text">定义（线性支持向量机）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#学习的对偶算法-1"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">学习的对偶算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定理-1"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">定理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#算法（线性支持向量机学习算法）"><span class="post-toc-number">1.2.2.2.</span> <span class="post-toc-text">算法（线性支持向量机学习算法）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#支持向量-1"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">支持向量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#合页损失函数"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">合页损失函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定理-2"><span class="post-toc-number">1.2.4.1.</span> <span class="post-toc-text">定理</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列最小最优化算法"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">序列最小最优化算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两个变量二次规划的求解方法"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">两个变量二次规划的求解方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定理-3"><span class="post-toc-number">1.3.1.1.</span> <span class="post-toc-text">定理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变量的选择方法"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">变量的选择方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第一个变量的选择"><span class="post-toc-number">1.3.2.1.</span> <span class="post-toc-text">第一个变量的选择</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第二个变量的选择"><span class="post-toc-number">1.3.2.2.</span> <span class="post-toc-text">第二个变量的选择</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#计算阈值b和差值Ei"><span class="post-toc-number">1.3.2.3.</span> <span class="post-toc-text">计算阈值b和差值Ei</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SMO算法"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">SMO算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#非线性支持向量机与核函数"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">非线性支持向量机与核函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#核技巧"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">核技巧</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#非线性分类问题"><span class="post-toc-number">1.4.1.1.</span> <span class="post-toc-text">非线性分类问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#核函数的定义"><span class="post-toc-number">1.4.1.2.</span> <span class="post-toc-text">核函数的定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#核技巧在支持向量机中的应用"><span class="post-toc-number">1.4.1.3.</span> <span class="post-toc-text">核技巧在支持向量机中的应用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正定核"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">正定核</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定理（正定核的充要条件）"><span class="post-toc-number">1.4.2.1.</span> <span class="post-toc-text">定理（正定核的充要条件）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义（正定核的等价定义）"><span class="post-toc-number">1.4.2.2.</span> <span class="post-toc-text">定义（正定核的等价定义）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常用核函数"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">常用核函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多项式核函数"><span class="post-toc-number">1.4.3.1.</span> <span class="post-toc-text">多项式核函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#高斯核函数"><span class="post-toc-number">1.4.3.2.</span> <span class="post-toc-text">高斯核函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#字符串核函数"><span class="post-toc-number">1.4.3.3.</span> <span class="post-toc-text">字符串核函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#非线性支持向量机"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">非线性支持向量机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#定义-非线性支持向量机"><span class="post-toc-number">1.4.4.1.</span> <span class="post-toc-text">定义 非线性支持向量机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#算法-非线性支持向量机学习算法"><span class="post-toc-number">1.4.4.2.</span> <span class="post-toc-text">算法 非线性支持向量机学习算法</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#博客"><span class="post-toc-number">2.</span> <span class="post-toc-text">博客</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#决策面方程"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">决策面方程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#“分类间隔”方程"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">“分类间隔”方程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#核函数与超平面"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">核函数与超平面</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线性"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">线性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#非线性"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">非线性</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#实践"><span class="post-toc-number">3.</span> <span class="post-toc-text">实践</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SVM-simple"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">SVM-simple</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#完整SMO算法"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">完整SMO算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#非线性SVM"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">非线性SVM</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#sklearn-svm-SVC"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">sklearn.svm.SVC</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-SVM"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">SVM</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-11-28 20:48:47" datetime="2018-11-28T12:48:47.000Z"  itemprop="datePublished">2018-11-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/知识总结/">知识总结</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>已修改</p>
<h1 id="统计学习方法-支持向量机"><a href="#统计学习方法-支持向量机" class="headerlink" title="统计学习方法 支持向量机"></a>统计学习方法 支持向量机</h1><p>支持向量机（support vector machines,SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。</p>
<p>支持向量机学习方法包括构建由简至繁的模型：线性可分支持向量机（linear support vector machine in linearly separable case），线性支持向量机（linear support vector machine）及非线性支持向量机（non-linear support vector machine）。简单的模型是复杂模型的基础，也是复杂模型的特殊情况。当训练数据线性可分时，通过硬间隔最大化（hard margin maximization），学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；当训练数据近似线性可分时，通过软间隔最大化（soft margin maximization），也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；当训练数据线性不可分时，通过使用核技巧（kernel trick）及软间隔最大化，学习非线性支持向量机。</p>
<p>当输入空间为欧式空间或离散集合、特征空间为希尔贝特空间时，核函数（kernel function）表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。这样的方法称为核技巧。<strong>核方法（kernel method）是比支持向量机更为一般的机器学习方法。</strong></p>
<h2 id="线性可分支持向量机与硬间隔最大化"><a href="#线性可分支持向量机与硬间隔最大化" class="headerlink" title="线性可分支持向量机与硬间隔最大化"></a>线性可分支持向量机与硬间隔最大化</h2><h3 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h3><p>考虑一个二类分类问题。假设输入空间与特征空间为两个不同的空间。输入空间为欧式空间或离散集合，特征空间为欧式空间或希尔伯特空间，线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应，并将输入空间的输入映射为特征空间中的特征向量。非线性支持向量机利用一个从输入空间到特征空间的非线性映射将输入映射为特征向量。支持向量机的学习是在特征空间进行的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.47.24.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="定义（线性可分支持向量机）"><a href="#定义（线性可分支持向量机）" class="headerlink" title="定义（线性可分支持向量机）"></a>定义（线性可分支持向量机）</h4><p>给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.51.01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.55.46.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>函数间隔不是距离，注意上句话中所说的“能够<strong>相对</strong>地表示”。</p>
<h4 id="定义（函数间隔）"><a href="#定义（函数间隔）" class="headerlink" title="定义（函数间隔）"></a>定义（函数间隔）</h4><p>对于给定的训练数据集T和超平面（w,b），定义超平<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.58.01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>函数间隔可以表示分类预测的正确性及确信度。但是选择分离超平面时，只有函数间隔还不够。因为只要成比例改变w和b，如改为2w和2b，超平面并没有改变，但函数间隔却成为原来的2倍，所以应该对分离超平面的法向量w加以约束，如规范化||w||=1,使得间隔是确定的。这时函数间隔成为几何间隔。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.36.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="定义（几何间隔）"><a href="#定义（几何间隔）" class="headerlink" title="定义（几何间隔）"></a>定义（几何间隔）</h4><p>对于给定的训练数据集T和超平面（w,b）,定义超平<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.18.41.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面.对线性可分的训练数据集而言,线性可分分离超平面有无穷多个(等价于感知机),但是几何间隔最大的分离超平面是唯一的.这里的间隔最大化又称为硬间隔最大化(与将要讨论的训练数据集近似线性可分时的软间隔最大化相对应).</p>
<p>间隔最大化的直观解释是;对训练数据集找到几何间隔最大的超平面意味着<br>以充分大的确信度对训练数据进行分类.也就是说,不仅将正负实例点分开,而      且对最难分的实例点(离超平面最近的点)也有足够大的确信度将它们分开.这<br>样的超平面应该对未知的新实例有很好的分类预测能力。</p>
<h4 id="最大间隔分离超平面"><a href="#最大间隔分离超平面" class="headerlink" title="最大间隔分离超平面"></a>最大间隔分离超平面</h4><p>考虑如何求得一个几何间隔最大的分离超平面,即最大间隔分离超平面.具体地,这个问题可以表示为下面的约束最优化问题:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.34.11.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>函数间隔yhat的取值并不影响最优化问题的解。事实上，假设将w和b按比例改变为λw和λb,这时函数间隔称为λyhat。函数间隔的这一改变对上面最优化问题的不等式约束没有影响，对目标函数的优化也没有影响，也就是说，它产生一<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.40.56.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这是一个凸二次规划(convex quadratic programming)问题。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.44.47.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><strong>仿射函数</strong>，即最高次数为1的多项式函数。常数项为零的仿射函数称为线性函数。</p>
<h5 id="线性可分支持向量机学习——最大间隔法"><a href="#线性可分支持向量机学习——最大间隔法" class="headerlink" title="线性可分支持向量机学习——最大间隔法"></a>线性可分支持向量机学习——最大间隔法</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.46.45.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="最大间隔分离超平面的存在唯一性"><a href="#最大间隔分离超平面的存在唯一性" class="headerlink" title="最大间隔分离超平面的存在唯一性"></a>最大间隔分离超平面的存在唯一性</h4><p>线性可分训练集的最大间隔分离超平面是存在且唯一的。</p>
<h5 id="定理（最大间隔分离超平面的存在唯一性）"><a href="#定理（最大间隔分离超平面的存在唯一性）" class="headerlink" title="定理（最大间隔分离超平面的存在唯一性）"></a>定理（最大间隔分离超平面的存在唯一性）</h5><p>若训练数据集T线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。</p>
<h4 id="支持向量和间隔边界"><a href="#支持向量和间隔边界" class="headerlink" title="支持向量和间隔边界"></a>支持向量和间隔边界</h4><p>在线性可分情况下,训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量( support vector).支持向量是使约束条件式(7.14)等号成立的点,即<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.24.01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.25.49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>在决定分离超平面时只有支持向量起作用,而其他实例点并不起作用.如果移动支持向量将改变所求的解;但是如果在间隔边界以外移动其他实例点,甚至去掉这些点,则解是不会改变的.由于支持向量在确定分离超平面中起着决定性作用,所以将这种分类模型称为支持向量机.支持向量的个数一般很少,所以支持向量机由很少的“重要的”训练样本确定.</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.31.50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>为了求解线性可分支持向量机的最优化问题(7.13,7.14)，将它作为原始最优化问题,应用拉格朗日对偶性,通过求解对偶问题(dual problem)得到原始问题( primal problem)的最优解,这就是线性可分支持向量机的对偶算法( dual algorithm).这样做的优点,一是对偶问题往往更容易求解;二是自然引入核函数,进而推广到非线性分类问题。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.35.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>首先构建拉格朗日函数( Lagrange function).为此,对每一个不等式约束(7.14)引进拉格朗日乘子( Lagrange multiplier )αi≥0,i=1,2,…,N,定义拉格朗日函数:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.39.04.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.42.43.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.47.50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.48.18.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.50.43.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.52.53.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>这种算法称为线性可分支持向量机的对偶学习算法，是线性可分支持向量机学习的基本算法。</p>
<h4 id="算法（线性可分支持向量机学习算法）"><a href="#算法（线性可分支持向量机学习算法）" class="headerlink" title="算法（线性可分支持向量机学习算法）"></a>算法（线性可分支持向量机学习算法）</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.28.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.06.12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.07.41.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.17.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.44.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>对于线性可分问题,上述线性可分支持向量机的学习(硬间隔最大化)算法是完美的,但是,训练数据集线性可分是理想的情形.在现实问题中,训练数据集往往是线性不可分的,即在样本中出现噪声或特异点.此时,有更一般的学习算法。</p>
<h2 id="线性支持向量机与软间隔最大化"><a href="#线性支持向量机与软间隔最大化" class="headerlink" title="线性支持向量机与软间隔最大化"></a>线性支持向量机与软间隔最大化</h2><h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><p>线性可分问题的支持向量机学习方法,对线性不可分训练数据是不适用的,因为这时上述方法中的不等式约束并不能都成立.怎么才能将它扩展到线性不可分问题呢?这就需要修改硬间隔最大化,使其成为软间隔最大化.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.04.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.23.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.41.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>有了上面的思路,可以和训练数据集线性可分时一样来考虑训练数据集线性不可分时的线性支持向量机学习问题相应于硬间隔最大化,它称为软间隔最大化。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.00.06.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="定义（线性支持向量机）"><a href="#定义（线性支持向量机）" class="headerlink" title="定义（线性支持向量机）"></a>定义（线性支持向量机）</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.01.31.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="学习的对偶算法-1"><a href="#学习的对偶算法-1" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.02.46.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.03.49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.13.31.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以通过求解对偶问题而得到原始问题的解，进而确定分离超平面和决策函数.为此，就可以定理的形式叙述原始问题的最优解和对偶问题的最优解的关系.</p>
<h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.19.50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="算法（线性支持向量机学习算法）"><a href="#算法（线性支持向量机学习算法）" class="headerlink" title="算法（线性支持向量机学习算法）"></a>算法（线性支持向量机学习算法）</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.21.49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>符合条件的样本点上的平均值。</p>
<h3 id="支持向量-1"><a href="#支持向量-1" class="headerlink" title="支持向量"></a>支持向量</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.25.26.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.27.25.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>目标函数的第一项是经验损失或经验风险，函数<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.16.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/17.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="序列最小最优化算法"><a href="#序列最小最优化算法" class="headerlink" title="序列最小最优化算法"></a>序列最小最优化算法</h2><p>支持向量机的学习问题可以形式化为求解凸二次规划问题，这样的图二次规划问题具有全局最优解，且有许多最优化算法可以用于这一问题的求解。但当训练样本容量很大时，这些算法往往变得非常低效，以致于无法使用。序列最小最优化算法就是一种快速实现算法。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.05.30.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>SMO算法是一种启发式算法，其基本思路是:如果所有变量的解都满足此最优化问题的KKT条件(Karush-Kuhn-Tucker conditions),那么这个最优化问题的解就得到了。因为KKT条件是该最优化问题的充分必要条件.否则， 选择两个变量，固定其他变量，针对这两个变量构建一个二次规划问题，这个二次规划问题关于这两个变量的解应该更接近原始二次规划问题的解，因为这会使得原始二次规划问题的目标函数值变得更小.重要的是，这时子问题可以通过解析方法求解，这样就可以大大提高整个算法的计算速度.子问题有两个变量，一个是违反KKT条件最严重的那一个，另一个由约束条件自动确定.如此，SMO算法将原问题不断分解为子问题并对子问题求解，进而达到求解原问题的目的.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.13.36.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>整个SMO算法包括两个部分:求解两个变量二次规划的解析方法和选择变量的启发式方法.</p>
<h3 id="两个变量二次规划的求解方法"><a href="#两个变量二次规划的求解方法" class="headerlink" title="两个变量二次规划的求解方法"></a>两个变量二次规划的求解方法</h3><p>不失一般性，假设选择的两个变量是α1，α2，其他变量αi（i=3，4，…，N）是固定的。于是SMO的最优化问题（7.98~7.100）的子问题可以写成：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.17.44.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.18.27.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>为了求解两个变量的二次规划问题(7.101)-(7.103)，首先分析约束条件，然后在此约束条件下求极小。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.20.48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>不等式约束(7.103)使得(a,a2)在盒子[0,C]x[0,C]内，等式约束(7.102)使(α1，α2)在平行于盒子[0,C]x[0,C]的对角线的直线上.因此要求的是目标函数在一条平行于对角线的线段.上的最优值.这使得两个变量的最优化问题成为实质上的单变量的最优化问题，不妨考患为变量α2的最优化问题.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.27.37.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.30.02.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.33.30.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="变量的选择方法"><a href="#变量的选择方法" class="headerlink" title="变量的选择方法"></a>变量的选择方法</h3><p>SMO算法在每个子问题中选择两个变量优化，其中至少一个变量是违反KKT条件的。</p>
<h4 id="第一个变量的选择"><a href="#第一个变量的选择" class="headerlink" title="第一个变量的选择"></a>第一个变量的选择</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.03.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.17.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="第二个变量的选择"><a href="#第二个变量的选择" class="headerlink" title="第二个变量的选择"></a>第二个变量的选择</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.42.22.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="计算阈值b和差值Ei"><a href="#计算阈值b和差值Ei" class="headerlink" title="计算阈值b和差值Ei"></a>计算阈值b和差值Ei</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.28.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.39.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.36.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="非线性支持向量机与核函数"><a href="#非线性支持向量机与核函数" class="headerlink" title="非线性支持向量机与核函数"></a>非线性支持向量机与核函数</h2><p>对解线性分类问题，线性分类支持向量机是一种非常有效的方法。但是，有时分类问题是非线性的，这时可以使用非线性支持向量机，其主要特点是利用核技巧(kernel trick)。核技巧不仅应用于支持向量机，而且应用于其他统计学习问题。</p>
<h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><h4 id="非线性分类问题"><a href="#非线性分类问题" class="headerlink" title="非线性分类问题"></a>非线性分类问题</h4><p>非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题.先看<br>一个例子:如7.7 左图，是一个分类问题，图中“。”表示正实例点，“x”表示负<br>实例点. 由图可，见， 无法用直线(线性模型)将正负实例正确分开，但可以用一条椭圆曲线(非线性模型)将它们正确分开.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.29.18.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.28.02.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决这个问题.所采取的方法是进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题、对图7.7所示的例子， 通过变换，将左图中椭圆变换成右图中的直线,将非线性分类问题变换为线性分类问题.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.32.35.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>用线性分类方法求解非线性分类问题分为两步: 首先使用一个变换将原空间的数据映射到新空间;然后在新空间里用线性分类学习方法从训练数据中学习分类模型. 核技巧就属于这样的方法.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.34.11.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="核函数的定义"><a href="#核函数的定义" class="headerlink" title="核函数的定义"></a>核函数的定义</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.18.59.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.19.49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.20.19.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="核技巧在支持向量机中的应用"><a href="#核技巧在支持向量机中的应用" class="headerlink" title="核技巧在支持向量机中的应用"></a>核技巧在支持向量机中的应用</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.23.30.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.25.44.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="正定核"><a href="#正定核" class="headerlink" title="正定核"></a>正定核</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.29.04.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="定理（正定核的充要条件）"><a href="#定理（正定核的充要条件）" class="headerlink" title="定理（正定核的充要条件）"></a>定理（正定核的充要条件）</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.32.46.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>定理给出了正定核的充要条件，因此可以作为正定核，即核函数的另一定义。</p>
<h4 id="定义（正定核的等价定义）"><a href="#定义（正定核的等价定义）" class="headerlink" title="定义（正定核的等价定义）"></a>定义（正定核的等价定义）</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.34.52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h3><h4 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.43.43.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.44.06.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="字符串核函数"><a href="#字符串核函数" class="headerlink" title="字符串核函数"></a>字符串核函数</h4><p>核函数不仅可以定义在欧氏空间上，还可以定义在离散数据的集合上.比如，字符串核是定义在字符串集合上的核函数.字符串核函数在文本分类信息检索、生物信息学等方面都有应用.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.46.35.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>字符串核函数k,(s,t)给出了字符串s和t中长度等于n的所有子串组成的特征向量的余弦相似度(cosine similarity).直观上，两个字符串相同的子串越多， 它们就越相似，字符串核函数的值就越大.字符串核函数可以由动态规划快速地计算.</p>
<h3 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h3><p>利用核技巧，可以将线性分类的学习方法应用到非线性分类问题中去.将线性支持向量机扩展到非线性支持向量机，只需将线性支持向量机对偶形式中的内积换成核函数.</p>
<h4 id="定义-非线性支持向量机"><a href="#定义-非线性支持向量机" class="headerlink" title="定义 非线性支持向量机"></a>定义 非线性支持向量机</h4><p>从非线性分类训练集，通过核函数与软间隔最大化，或凸二次规划(7.95~7.97)，学习得到的分类决策函数<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.52.24.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="算法-非线性支持向量机学习算法"><a href="#算法-非线性支持向量机学习算法" class="headerlink" title="算法 非线性支持向量机学习算法"></a>算法 非线性支持向量机学习算法</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.54.40.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a href="https://cuijiahua.com/blog/2017/11/ml_8_svm_1.html" target="_blank" rel="noopener">机器学习实战教程（八）：支持向量机原理篇之手撕线性SVM</a></p>
<h2 id="决策面方程"><a href="#决策面方程" class="headerlink" title="决策面方程"></a>决策面方程</h2><p>在二维空间下一条直线的方程为y=ax+b<br>现在我们做一个小小的改变，让原来的x轴变成x1,y轴变成x2<br>x2=ax1+b<br>移项得：ax1-x2+b=0<br>将公式向量化得：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/8.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>进一步向量化，用w列向量和标量r进一步向量化。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/9.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>其中向量w和x分别为：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/10.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这里w1=a,w2=-1。最初的直线方程a和b的几何意义，a表示直线的斜率，b表示截距，向量化后的直线的w和r的几何意义为<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/11.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>向量w和直线的关系为垂直的，标量r的作用也没有变，依然决定了直线的截距。</p>
<p>将其推广到n维空间，就变成了超平面方程，公式没变，依然是：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>不同在于：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="“分类间隔”方程"><a href="#“分类间隔”方程" class="headerlink" title="“分类间隔”方程"></a>“分类间隔”方程</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/14.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>间隔的大小实际上就是支持向量对应的样本点到决策面的距离的二倍。d的求法如下：<br>点到直线的距离距离公式：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/15.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>公式中的直线方程为Ax0+By0+C=0，点P的坐标为(x0,y0)。<br>将直线方程扩展到多维，求得我们现在的超平面方程，对公式进行如下变形：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/16.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这个d就是”分类间隔”。其中||w||表示w的二范数，求所有元素的平方和，然后再开方。</p>
<h2 id="核函数与超平面"><a href="#核函数与超平面" class="headerlink" title="核函数与超平面"></a>核函数与超平面</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_7.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h2><p>1.我们的<strong>最优化问题</strong>是：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>我们要求解的是最小化问题，所以一个直观的想法是如果我能够构造一个函数，使得该函数在可行解区域内与原目标函数完全一致，而在可行解区域外的数值非常大，甚至是无穷大，那么这个没有约束条件的新目标函数的优化问题就与原来有约束条件的原始目标函数的优化问题是等价的问题。这就是使用拉格朗日方程的目的，它将约束条件放到目标函数中，从而将有约束优化问题转换为无约束优化问题。</p>
<p>2.<strong>将有约束的原始目标函数转换为无约束的新构造的拉格朗日目标函数</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>其中αi是拉格朗日乘子，αi大于等于0，是我们构造新目标函数时引入的系数变量(我们自己设置)。现在我们令：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>当样本点不满足约束条件时，即在可行解区域外：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_51.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>此时，我们将αi设置为正无穷，此时θ(w)显然也是正无穷。<br>当样本点满足约束条件时，即在可行解区域内：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>此时，显然θ(w)为原目标函数本身。我们将上述两种情况结合一下，就得到了新的目标函数：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_53.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>此时，再看我们的初衷，就是为了建立一个在可行解区域内与原目标函数相同，在可行解区域外函数值趋近于无穷大的新函数，现在我们做到了。<br>现在，我们的问题变成了求新目标函数的最小值，即：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_54.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这里用p*表示这个问题的最优值，且和最初的问题是等价的。</p>
<p>3.<strong>将不易求解的优化问题转化为易求解的优化</strong><br>我们看一下我们的新目标函数，先求最大值，再求最小值。这样的话，我们首先就要面对带有需要求解的参数w和b的方程，而αi又是不等式约束，这个求解过程不好做。所以，我们需要使用拉格朗日函数对偶性，将最小和最大的位置交换一下，这样就变成了：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_55.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>交换以后的新问题是原始问题的对偶问题，这个新问题的最优值用d<strong>来表示。而且d</strong>&lt;=p*。我们关心的是d=p的时候，这才是我们要的解。需要什么条件才能让d=p呢？首先必须满足这个优化问题是凸优化问题。其次，需要满足KKT条件。<br>求取最小值的目标函数为凸函数的一类优化问题。目标函数是凸函数我们已经知道，这个优化问题又是求最小值。所以我们的最优化问题就是凸优化问题。<br>而且KKT条件也满足了。</p>
<p>求解这个对偶学习问题，可以分为三个步骤：首先要让L(w,b,α)关于w和b最小化，然后求对α的极大，最后利用SMO算法求解对偶问题中的拉格朗日乘子。</p>
<p>4.<strong>让L(w,b,α)关于w和b最小化</strong><br>根据上述推导已知：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_58.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>首先固定α，要让L(w,b,α)关于w和b最小化，我们分别对w和b偏导数，令其等于0，即：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_59.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>将上述结果带回L(w,b,α)得到：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_60.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>从上面的最后一个式子，我们可以看出，此时的L(w,b,α)函数只含有一个变量，即αi。</p>
<p>5.<strong>对α求极大</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_61.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>现在我们的优化问题变成了如上的形式。对于这个问题，我们有更高效的优化算法，即序列最小优化（SMO）算法。我们通过这个优化算法能得到α，再根据α，我们就可以求解出w和b，进而求得我们最初的目的：找到超平面，即”决策平面”。</p>
<p>6.<strong>使用SMO算法</strong><br>步骤一：计算误差<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_106.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>步骤二：计算上下界L和H：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_107-1.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>步骤三：计算η：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_108.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>步骤四：更新αj<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml-8-109.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>步骤五：根据取值范围修剪αj：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_110.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>步骤六：更新αi：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_111.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>步骤七：更新b1和b2：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_112.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>步骤八：根据b1和b2更新b：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_8_113.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h2><p>对于非线性的情况，SVM的处理方式就是选择一个核函数。简而言之：在线性不可分的情况下，SVM通过某种事先选择的非线性映射（核函数）将输入变量映到一个高维特征空间，将其变成在高维空间线性可分，在这个高维空间中构造最优分类超平面。</p>
<p>线性可分的情况下，可知最终的超平面方程为：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_9_4.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>将上述公式用内积来表示：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_9_25.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>对于线性不可分，我们使用一个非线性映射，将数据映射到特征空间，在特征空间中使用线性学习器，分类函数变形如下：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_9_5.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>其中ϕ从输入空间(X)到某个特征空间(F)的映射，这意味着建立非线性学习器分为两步：首先使用一个非线性映射将数据变换到一个特征空间F；然后在特征空间使用线性学习器分类。</p>
<p>如果有一种方法可以在特征空间中直接计算内积 &lt;ϕ(xi),ϕ(x)&gt;，就像在原始输入点的函数中一样，就有可能将两个步骤融合到一起建立一个分线性的学习器，这样直接计算的方法称为核函数方法。</p>
<p>这种将内积替换成核函数的方式被称为核技巧(kernel trick)。<br>如：<br>假设已知映射函数为：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_9_12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>对于两个向量a1=(x1,x2)和a2=(y1,y2)有<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_9_13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>如果我们不进行映射计算，直接运算下面的公式：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_9_14.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>这两个公式的计算结果是相同的。区别在于：一个是根据映射函数，映射到高维空间中，然后再根据内积的公式进行计算，计算量大；另一个则直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果，计算量小。</p>
<p>核函数就是：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/SVM/ml_9_15.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="SVM-simple"><a href="#SVM-simple" class="headerlink" title="SVM-simple"></a>SVM-simple</h2><p>简化版的SMO算法，第二个α的选择是随机的。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-simple.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-simple.py</a></p>
<h2 id="完整SMO算法"><a href="#完整SMO算法" class="headerlink" title="完整SMO算法"></a>完整SMO算法</h2><p>完整的SMO算法可以启发式选择第二个α值。<br>在实现SMO算法的时候，先计算η，再更新αj。为了加快第二个αj乘子的迭代速度，需要让直线的斜率增大，对于αj的更新公式，其中η值没有什么文章可做，于是只能令:max|Ei-Ej|。<br>因此，优化方法为：</p>
<ol>
<li>最外层循环，首先在样本中选择违反KKT条件的一个乘子作为最外层循环，然后用”启发式选择”选择另外一个乘子并进行这两个乘子的优化。</li>
<li>在非边界乘子中寻找使得 |Ei - Ej| 最大的样本<br>3.如果没有找到，则从整个样本中随机选择一个样本</li>
</ol>
<p>完整版SMO算法覆盖整个数据集进行计算，而简化版SMO算法是随机选择的。可以看出，完整版SMO算法选出的支持向量样点更多，更接近理想的分隔超平面。</p>
<p>对比两种算法的运算时间，结果是完整版SMO算法的速度比简化版SMO算法的速度快6倍左右。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-smo.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-smo.py</a></p>
<h2 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h2><p><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svmMLiA.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svmMLiA.py</a><br>高斯核函数<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/18.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>从图像中我们可以看出，离中心点越近，函数值就越接近于1。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/add/19.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>因此以任意一种颜色的同心圆作为决策边界，我们都可以完成对数据集的简单非线性划分。那么问题来了，如何映射到高维空间上去呢？——————高斯核函数！ </p>
<h2 id="sklearn-svm-SVC"><a href="#sklearn-svm-SVC" class="headerlink" title="sklearn.svm.SVC"></a>sklearn.svm.SVC</h2><p>参数说明：<br>C:惩罚项，float类型，可选参数，默认为1.0，C越大，即对分错样本的惩罚程度越大，因此在训练样本中准确率越高，但是泛化能力降低，也就是对测试数据的分类准确率降低。相反，减小C的话，容许训练样本中有一些误分类错误样本，泛化能力强。对于训练样本带有噪声的情况，一般采用后者，把训练样本集中错误分类的样本作为噪声。</p>
<p>kernel：核函数类型，str类型，默认为’rbf’。可选参数为：’linear’：线性核函数，’poly’：多项式核函数，’rbf’：径像核函数/高斯核，’sigmod’：sigmod核函数，’precomputed’：核矩阵，precomputed表示自己提前计算好核函数矩阵，这时候算法内部就不再用核函数去计算核矩阵，而是直接用你给的核矩阵，核矩阵需要为n*n的。</p>
<p>degree：多项式核函数的阶数，int类型，可选参数，默认为3。这个参数只对多项式核函数有用，是指多项式核函数的阶数n，如果给的核函数参数是其他核函数，则会自动忽略该参数。</p>
<p>gamma：核函数系数，float类型，可选参数，默认为auto。只对’rbf’ ,’poly’ ,’sigmod’有效。如果gamma为auto，代表其值为样本特征数的倒数，即1/n_features。</p>
<p>coef0：核函数中的独立项，float类型，可选参数，默认为0.0。只有对’poly’ 和,’sigmod’核函数有用，是指其中的参数c。</p>
<p>probability：是否启用概率估计，bool类型，可选参数，默认为False，这必须在调用fit()之前启用，并且会fit()方法速度变慢。</p>
<p>shrinking：是否采用启发式收缩方式，bool类型，可选参数，默认为True。</p>
<p>tol：svm停止训练的误差精度，float类型，可选参数，默认为1e^-3。</p>
<p>cache_size：内存大小，float类型，可选参数，默认为200。指定训练所需要的内存，以MB为单位，默认为200MB。</p>
<p>class_weight：类别权重，dict类型或str类型，可选参数，默认为None。给每个类别分别设置不同的惩罚参数C，如果没有给，则会给所有类别都给C=1，即前面参数指出的参数C。如果给定参数’balance’，则使用y的值自动调整与输入数据中的类频率成反比的权重。</p>
<p>verbose：是否启用详细输出，bool类型，默认为False，此设置利用libsvm中的每个进程运行时设置，如果启用，可能无法在多线程上下文中正常工作。一般情况都设为False，不用管它。</p>
<p>max_iter：最大迭代次数，int类型，默认为-1，表示不限制。</p>
<p>decision_function_shape：决策函数类型，可选参数’ovo’和’ovr’，默认为’ovr’。’ovo’表示one vs one，’ovr’表示one vs rest。</p>
<p>random_state：数据洗牌时的种子值，int类型，可选参数，默认为None。伪随机数发生器的种子,在混洗数据时用于概率估计。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-12-02T11:49:42.000Z" itemprop="dateUpdated">2018-12-02 19:49:42</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://github.com/zdkswd">
            <img src="/img/tmg.jpg" alt="ZDK">
            ZDK
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/12/04/具体数学 第一章/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">具体数学 第一章</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/11/22/贝叶斯概率/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">贝叶斯概率</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz",
            appKey: "gkBx5soQkBREmER84PWbNJeM",
            avatar: "mm",
            placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>ZDK &copy; 2017 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'zdk'blog';
            clearTimeout(titleTime);
        } else {
            document.title = '';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
