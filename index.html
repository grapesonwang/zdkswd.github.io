<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta property="og:type" content="website">
<meta property="og:title" content="ZDK&#39;s blog">
<meta property="og:url" content="https://github.com/zdkswd/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZDK&#39;s blog">



  <link rel="alternate" href="/atom.xml" title="ZDK's blog" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="https://github.com/zdkswd/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ZDK's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZDK's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/07/14/Tomcat综述/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/Tomcat综述/" class="post-title-link" itemprop="url">Tomcat综述</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-14 10:52:32 / 修改时间：10:58:01" itemprop="dateCreated datePublished" datetime="2019-07-14T10:52:32+08:00">2019-07-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/07/14/Tomcat综述/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/14/Tomcat综述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/07/14/Tomcat综述/" class="post-meta-item leancloud_visitors" data-flag-title="Tomcat综述">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Tomcat综述"><a href="#Tomcat综述" class="headerlink" title="Tomcat综述"></a>Tomcat综述</h1><p><img src="/img/media/tomcat1/1.png" alt=""></p>
<hr>
<p><strong>Web容器</strong></p>
<p>HTTP服务器（比如Apache、Nginx）向浏览器返回静态HTML，浏览器负责解析HTML，将结果呈现给用户。我们希望通过一些交互操作，来获取动态结果，需要一些扩展机制能够让HTTP服务器调用服务端程序。于是Sun公司推出了<strong>Servlet</strong>技术。可以把Servlet简单理解为运行在服务端的Java小程序，Servlet没有main方法，不能独立运行，所以必须把它部署到Servlet容器中，由容器来实例化并调用Servlet。</p>
<p>Tomcat和Jetty就是一个Servlet容器。为了方便使用，它们也具有HTTP服务器的功能，因此<strong>Tomcat或者Jetty就是一个“HTTP服务器 + Servlet容器”，我们也叫它们Web容器。</strong>Tomcat和Jetty算是一个轻量级的应用服务器。</p>
<p><strong>Tomcat是Spring Boot默认的嵌入式Servlet容器。</strong>最新版本Tomcat和Jetty都支持Servlet 4.0规范。</p>
<h1 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a>HTTP相关</h1><h2 id="HTTP本质"><a href="#HTTP本质" class="headerlink" title="HTTP本质"></a>HTTP本质</h2><p>HTTP协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP是基于TCP/IP协议来传递数据的（HTML文件、图片、查询结果等），HTTP协议不涉及数据包（Packet）传输，主要规定了客户端和服务器之间的通信格式。<strong>HTTP协议的本质就是一种浏览器与服务器之间约定好的通信格式</strong>。</p>
<p><img src="/img/media/tomcat1/2.png" alt=""></p>
<p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成的步骤： </p>
<ol>
<li><strong>域名解析</strong></li>
<li><strong>发起TCP的3次握手</strong> </li>
<li><strong>Web浏览器向Web服务器发送http请求命令</strong> 。例如，GET/sample/hello.jsp HTTP/1.1。</li>
<li><strong>Web浏览器发送http请求头信息</strong> ，浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 </li>
<li><strong>Web服务器应答</strong> ，客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</li>
<li><strong>Web服务器发送应答头信息</strong> ，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 </li>
<li><strong>Web服务器向浏览器发送数据</strong> ，Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</li>
<li><strong>Web服务器关闭TCP连接</strong> ，一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive ，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li>
</ol>
<h2 id="HTTP请求响应"><a href="#HTTP请求响应" class="headerlink" title="HTTP请求响应"></a>HTTP请求响应</h2><p><img src="/img/media/tomcat1/3.png" alt=""></p>
<p>HTTP请求数据由三部分组成，分别是<strong>请求行、请求报头、请求正文</strong>。当这个HTTP请求数据到达Tomcat后，Tomcat会把HTTP请求数据字节流解析成一个Request对象，这个Request对象封装了HTTP所有的请求信息。接着Tomcat把这个Request对象交给Web应用去处理，处理完后得到一个Response对象，Tomcat会把这个Response对象转成HTTP格式的响应数据并发送给浏览器。</p>
<p><img src="/img/media/tomcat1/4.png" alt="4"></p>
<p>HTTP的响应也是由三部分组成，分别是<strong>状态行、响应报头、报文主体</strong>。</p>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是HTTP报文的一个请求头，Web应用可以将用户的标识信息或者其他一些信息（用户名等）存储在Cookie中。用户经过验证之后，每次HTTP请求报文中都包含Cookie，这样服务器读取这个Cookie请求头就知道用户是谁了。<strong>Cookie本质上就是一份存储在用户本地的文件，里面包含了每次请求中都需要传递的信息</strong>。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Cookie以明文的方式存储在本地，而Cookie中往往带有用户信息，这样就造成了非常大的安全隐患。而Session的出现解决了这个问题，<strong>Session可以理解为服务器端开辟的存储空间，里面保存了用户的状态</strong>，用户信息以Session的形式存储在服务端。当用户请求到来时，服务端可以把用户的请求和用户的Session对应起来。通过Cookie来将Session和请求对应起来。浏览器在Cookie中填充了一个Session ID之类的字段用来标识请求。</p>
<h3 id="Session创建与存储"><a href="#Session创建与存储" class="headerlink" title="Session创建与存储"></a>Session创建与存储</h3><p>Java中，Web应用程序在调用HttpServletRequest的getSession方法时，由Web容器（比如Tomcat）创建的。</p>
<p>Tomcat的Session管理器提供了多种持久化方案来存储Session，通常会采用高性能的存储方式，比如Redis，并且通过集群部署的方式，防止单点故障，从而提升高可用。同时，Session有过期时间，因此Tomcat会开启后台线程定期的轮询，如果Session过期了就将Session失效。</p>
<h1 id="Servlet规范与容器"><a href="#Servlet规范与容器" class="headerlink" title="Servlet规范与容器"></a>Servlet规范与容器</h1><p>Servlet接口其实是<strong>Servlet容器跟具体业务类之间的接口</strong>。</p>
<p><img src="/img/media/tomcat1/5.png" alt="5"></p>
<p>HTTP服务器不直接调用业务类，而是把请求交给容器来处理，容器通过Servlet接口调用业务类。因此Servlet接口和Servlet容器的出现，达到了HTTP服务器与业务类解耦的目的。</p>
<p>Servlet接口和Servlet容器这一整套规范叫作<strong>Servlet规范</strong>。Tomcat和Jetty都按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。作为Java程序员，如果要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat处理了。</p>
<h2 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h2><p>Servlet接口定义了下面五个方法：</p>
<p><img src="/img/media/tomcat1/6.png" alt="6"></p>
<p>其中最重要是的<strong>service</strong>方法，具体业务类在这个方法里实现处理逻辑。这个方法有两个参数：<strong>ServletRequest</strong>和<strong>ServletResponse</strong>。ServletRequest用来封装请求信息，ServletResponse用来封装响应信息，因此<strong>本质上这两个类是对通信协议的封装。</strong></p>
<p>比如HTTP协议中的请求和响应就是对应了<strong>HttpServletRequest</strong>和<strong>HttpServletResponse</strong>这两个类。可以通过<strong>HttpServletRequest</strong>来获取所有请求相关的信息，包括请求路径、Cookie、HTTP头、请求参数等。此外，还可以通过HttpServletRequest来创建和获取Session。而HttpServletResponse是用来封装HTTP响应的。</p>
<p>可以看到接口中还有两个跟生命周期有关的方法<strong>init</strong>和<strong>destroy</strong>，这是一个比较贴心的设计，Servlet容器在加载Servlet类的时候会调用init方法，在卸载的时候会调用destroy方法。可能会在init方法里初始化一些资源，并在destroy方法里释放这些资源，比如Spring MVC中的DispatcherServlet，就是在init方法里创建了自己的Spring容器。</p>
<p><strong>ServletConfig</strong>的作用就是封装Servlet的初始化参数。可以在web.xml给Servlet配置参数，并在程序里通过<strong>getServletConfig</strong>方法拿到这些参数。</p>
<p>有接口一般就有<strong>抽象类</strong>，抽象类用来实现接口和封装通用的逻辑，因此Servlet规范提供了GenericServlet抽象类，可以通过扩展它来实现Servlet。虽然Servlet规范并不在乎通信协议是什么，但是大多数的Servlet都是在HTTP环境中处理的，因此Servet规范还提供了HttpServlet来继承GenericServlet，并且加入了HTTP特性。这样通过继承HttpServlet类来实现自己的Servlet，只需要重写两个方法：<strong>doGet</strong>和<strong>doPost</strong>。</p>
<h2 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>当客户请求某个资源时，HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来，然后调用Servlet容器的service方法，Servlet容器拿到请求后，根据请求的URL和Servlet的映射关系，找到相应的Servlet，如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来完成初始化，接着调用Servlet的service方法来处理请求，把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端。</p>
<p><img src="/img/media/tomcat1/7.png" alt="7"></p>
<h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><p>一般来说，以Web应用程序的方式来部署Servlet的。根据Servlet规范，Web应用程序有一定的目录结构，在这个目录下分别放置了Servlet的类文件、配置文件以及静态资源，<strong>Servlet容器通过读取配置文件</strong>，就能找到并加载Servlet。Web应用的目录结构大概是下面这样的：</p>
<p><img src="/img/media/tomcat1/8.png" alt="8"></p>
<p>Servlet规范里定义了<strong>ServletContext</strong>这个接口来对应一个Web应用。Web应用部署好后，Servlet容器在启动时会加载Web应用，并为每个Web应用创建唯一的ServletContext对象。</p>
<p>一个Web应用可能有多个Servlet，这些Servlet可以通过全局的ServletContext来共享数据，这些数据包括Web应用的初始化参数、Web应用目录下的文件资源等。由于ServletContext持有所有Servlet实例，还可以通过它来实现Servlet请求的转发。</p>
<h3 id="扩展机制"><a href="#扩展机制" class="headerlink" title="扩展机制"></a>扩展机制</h3><p>设计一个规范或者一个中间件，要充分考虑到可扩展性。Servlet规范提供了两种扩展机制：<strong>Filter</strong>和<strong>Listener</strong>。</p>
<p><strong>Filter</strong>是过滤器，这个接口允许对<strong>请求和响应</strong>做一些统一的定制化处理，比如可以根据请求的频率来限制访问，或者根据国家地区的不同来修改响应内容。过滤器的<strong>工作原理</strong>是这样的：Web应用部署完成后，Servlet容器需要实例化Filter并把Filter链接成一个FilterChain。当请求进来时，获取第一个Filter并调用doFilter方法，doFilter方法负责调用这个FilterChain中的下一个Filter。</p>
<p><strong>Listener</strong>是监听器，是另一种扩展机制。当Web应用在Servlet容器中运行时，Servlet容器内部会不断的发生各种事件，如Web应用的启动和停止、用户请求到达等。 Servlet容器提供了一些默认的监听器来监听这些事件，当事件发生时，Servlet容器会负责调用监听器的方法。当然，可以定义自己的监听器去监听感兴趣的事件，将监听器配置在web.xml中。比如<strong>Spring就实现了自己的监听器，来监听ServletContext的启动事件，目的是当Servlet容器启动时，创建并初始化全局的Spring容器。</strong></p>
<h2 id="Servlet容器与Spring容器"><a href="#Servlet容器与Spring容器" class="headerlink" title="Servlet容器与Spring容器"></a>Servlet容器与Spring容器</h2><p> Tomcat&amp;Jetty在启动时给每个Web应用创建一个全局的上下文环境，这个上下文就是<strong>ServletContext</strong>，其为后面的Spring容器提供宿主环境。</p>
<p>Tomcat&amp;Jetty在启动过程中触发容器初始化事件，Spring的ContextLoaderListener会监听到这个事件，它的contextInitialized方法会被调用，在这个方法中，Spring会初始化全局的Spring根容器，这个就是Spring的IoC容器，IoC容器初始化完毕后，Spring将其存储到ServletContext中，便于以后来获取。</p>
<p>Tomcat&amp;Jetty在启动过程中还会扫描Servlet，一个Web应用中的Servlet可以有多个，以SpringMVC中的DispatcherServlet为例，这个Servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个Servlet请求。</p>
<p>Servlet一般会延迟加载，当第一个请求达到时，Tomcat&amp;Jetty发现DispatcherServlet还没有被实例化，就调用DispatcherServlet的init方法，DispatcherServlet在初始化的时候会建立自己的容器，叫做SpringMVC 容器，用来持有Spring MVC相关的Bean。同时，Spring MVC还会通过ServletContext拿到Spring根容器，并将Spring根容器设为SpringMVC容器的父容器，请注意，Spring MVC容器可以访问父容器中的Bean，但是父容器不能访问子容器的Bean， 也就是说Spring根容器不能访问SpringMVC容器里的Bean。说的通俗点就是，在Controller里可以访问Service对象，但是在Service里不可以访问Controller对象。  </p>
<h1 id="Tomcat目录与webapp项目目录"><a href="#Tomcat目录与webapp项目目录" class="headerlink" title="Tomcat目录与webapp项目目录"></a>Tomcat目录与webapp项目目录</h1><h2 id="Tomcat目录结构"><a href="#Tomcat目录结构" class="headerlink" title="Tomcat目录结构"></a>Tomcat目录结构</h2><p>/bin：存放Windows或Linux平台上启动和关闭Tomcat的脚本文件。<br>/conf：存放Tomcat的各种全局配置文件，其中最重要的是server.xml。<br>/lib：存放Tomcat以及所有Web应用都可以访问的JAR文件。<br>/logs：存放Tomcat执行时产生的日志文件。<br>/work：存放JSP编译后产生的Class文件。<br>/webapps：Tomcat的Web应用目录，默认情况下把Web应用放在这个目录下。</p>
<h2 id="Tomcat安装目录下的logs目录"><a href="#Tomcat安装目录下的logs目录" class="headerlink" title="Tomcat安装目录下的logs目录"></a>Tomcat安装目录下的logs目录</h2><ul>
<li><code>catalina.***.log</code></li>
</ul>
<p>主要是记录Tomcat启动过程的信息，在这个文件可以看到启动的JVM参数以及操作系统等日志信息。</p>
<ul>
<li><code>catalina.out</code></li>
</ul>
<p>catalina.out是Tomcat的标准输出（stdout）和标准错误（stderr），这是在Tomcat的启动脚本里指定的，如果没有修改的话stdout和stderr会重定向到这里。</p>
<ul>
<li><code>localhost.**.log</code></li>
</ul>
<p>主要记录Web应用在初始化过程中遇到的未处理的异常，会被Tomcat捕获而输出这个日志文件。</p>
<ul>
<li><code>localhost_access_log.**.txt</code></li>
</ul>
<p>存放访问Tomcat的请求日志，包括IP地址以及请求的路径、时间、请求协议以及状态码等信息。</p>
<ul>
<li><code>manager.***.log/host-manager.***.log</code></li>
</ul>
<p>存放Tomcat自带的manager项目的日志信息。</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><img src="/img/media/tomcat1/9.png" alt=""></p>
<p><img src="/img/media/tomcat1/8.png" alt=""></p>
<p><img src="https://zdkswd.github.io/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/191992114-5b5c838544f7c_articlex.png" alt=""></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/07/09/大数据综述/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/09/大数据综述/" class="post-title-link" itemprop="url">Hadoop综述</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-09 10:16:47 / 修改时间：22:17:16" itemprop="dateCreated datePublished" datetime="2019-07-09T10:16:47+08:00">2019-07-09</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/07/09/大数据综述/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/09/大数据综述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/07/09/大数据综述/" class="post-meta-item leancloud_visitors" data-flag-title="Hadoop综述">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="大数据发展的历史"><a href="#大数据发展的历史" class="headerlink" title="大数据发展的历史"></a>大数据发展的历史</h1><p>2004 Google发表的三篇论文，“三驾马车”，分别是<strong>分布式文件系统GFS</strong>、<strong>大数据分布式计算框架MapReduce</strong>和<strong>NoSQL数据库系统BigTable。</strong></p>
<p>一个文件系统，一个计算框架，一个数据库系统。Hadoop，主要包括Hadoop分布式文件系统HDFS和大数据计算引擎MapReduce。</p>
<p>Facebook发布了<strong>Hive</strong>，支持SQL语法来进行大数据计算。</p>
<p>在Hadoop早期，MapReduce既是一个执行引擎，又是一个资源调度框架，服务器集群的资源调度管理由MapReduce完成。这样不利于资源复用，也使得MapReduce非常臃肿。于是一个新项目启动了，将MapReduce执行引擎和资源调度分离开来，这就是<strong>Yarn</strong>。<strong>2012年，Yarn成为一个独立的项目开始运营，随后被各类大数据产品支持，成为大数据平台上最主流的资源调度系统</strong>。</p>
<p>MapReduce进行机器学习计算的时候性能非常差，因为机器学习算法通常需要进行很多次的迭代计算，而MapReduce每执行一次Map和Reduce计算都需要重新启动一次作业，带来大量的无谓消耗。还有一点就是MapReduce主要使用磁盘作为存储介质，而2012年的时候，内存已经突破容量和成本限制，成为数据运行过程中主要的存储介质。<strong>Spark</strong>一经推出，立即受到业界的追捧，并逐步替代MapReduce在企业应用中的地位。</p>
<p>一般说来，像MapReduce、Spark这类计算框架处理的业务场景都被称作<strong>批处理计算</strong>，因为它们通常针对以“天”为单位产生的数据进行一次计算，然后得到需要的结果，这中间计算需要花费的时间大概是几十分钟甚至更长的时间。因为计算的数据是非在线得到的实时数据，而是历史数据，所以这类计算也被称为<strong>大数据离线计算</strong>。</p>
<p>而在大数据领域，还有另外一类应用场景，需要对实时产生的大量数据进行即时计算。这类计算称为<strong>大数据流计算</strong>，相应地，有Storm、Flink、Spark Streaming等流计算框架来满足此类大数据应用的场景。 流式计算要处理的数据是实时在线产生的数据，所以这类计算也被称为<strong>大数据实时计算</strong>。</p>
<p>在典型的大数据的业务场景下，数据业务最通用的做法是，采用批处理的技术处理历史全量数据，采用流式计算处理实时新增数据。而像Flink这样的计算引擎，可以同时支持流式计算和批处理计算。</p>
<p>除了大数据批处理和流处理，NoSQL系统处理的主要也是大规模海量数据的存储与访问，所以也被归为大数据技术。 NoSQL曾经在2011年左右非常火爆，涌现出HBase、Cassandra等许多优秀的产品，其中HBase是从Hadoop中分离出来的、基于HDFS的NoSQL系统。<br><img src="/img/add/36.png" alt=""></p>
<h1 id="处理PB级数据"><a href="#处理PB级数据" class="headerlink" title="处理PB级数据"></a>处理PB级数据</h1><p>网站实时处理通常针对单个用户的请求操作，虽然大型网站面临大量的高并发请求，比如天猫的“双十一”活动。但是每个用户之间的请求是独立的，只要网站的分布式系统能将不同用户的不同业务请求分配到不同的服务器上，只要这些分布式的服务器之间耦合关系足够小，就可以通过添加更多的服务器去处理更多的用户请求及由此产生的用户数据。这也正是网站系统架构的<strong>核心原理</strong>。</p>
<p><strong>大数据计算处理通常针对的是网站的存量数据</strong>，也就是刚才我提到的全部用户在一段时间内请求产生的数据，这些数据之间是有大量关联的，比如购买同一个商品用户之间的关系，这是使用协同过滤进行商品推荐；比如同一件商品的历史销量走势，这是对历史数据进行统计分析。<strong>网站大数据系统要做的就是将这些统计规律和关联关系计算出来，并由此进一步改善网站的用户体验和运营决策</strong>。</p>
<p>这套方案的核心思路是，既然数据是庞大的，而程序要比数据小得多，将数据输入给程序是不划算的，那么就反其道而行之，<strong>将程序分发到数据所在的地方进行计算，也就是所谓的移动计算比移动数据更划算</strong>。</p>
<p>两台计算机要想合作构成一个系统，必须要在技术上重新架构。这就是现在互联网企业广泛使用的负载均衡、分布式缓存、分布式数据库、分布式服务等种种分布式系统。</p>
<p>移动计算程序到数据所在位置进行计算的实现：</p>
<ol>
<li>将待处理的大规模数据存储在服务器集群的所有服务器上，主要使用HDFS分布式文件存储系统，将文件分成很多块（Block），以块为单位存储在集群的服务器上。</li>
<li>将待处理的大规模数据存储在服务器集群的所有服务器上，主要使用HDFS分布式文件存储系统，将文件分成很多块（Block），以块为单位存储在集群的服务器上。</li>
<li>使用大数据计算框架支持的编程模型进行编程，比如Hadoop的MapReduce编程模型，或者Spark的RDD编程模型。应用程序编写好以后，将其打包，MapReduce和Spark都是在JVM环境中运行，所以打包出来的是一个Java的JAR包。</li>
<li>用Hadoop或者Spark的启动命令执行这个应用程序的JAR包，首先执行引擎会解析程序要处理的数据输入路径，根据输入数据量的大小，将数据分成若干片（Split），每一个数据片都分配给一个任务执行进程去处理。</li>
<li>任务执行进程收到分配的任务后，检查自己是否有任务对应的程序包，如果没有就去下载程序包，下载以后通过反射的方式加载程序。走到这里，最重要的一步，也就是移动计算就完成了。</li>
<li>加载程序后，任务执行进程根据分配的数据片的文件地址和数据在文件内的偏移量读取数据，并把数据输入给应用程序相应的方法去执行，从而实现在分布式服务器集群中移动计算程序，对大规模数据进行并行处理的计算目标。</li>
</ol>
<p>杀毒软件从服务器更新病毒库，然后在Windows内查杀病毒，就是一种移动计算（病毒库）比移动数据（Windows可能感染病毒的程序）更划算的例子。</p>
<h1 id="垂直伸缩到水平伸缩"><a href="#垂直伸缩到水平伸缩" class="headerlink" title="垂直伸缩到水平伸缩"></a>垂直伸缩到水平伸缩</h1><p>大规模数据存储都需要解决几个核心问题：</p>
<p>1.<strong>数据存储容量的问题</strong>。是数以PB计的数据计算问题，而一般的服务器磁盘容量通常1～2TB，如何存储这么大规模的数据呢？</p>
<p>2.<strong>数据读写速度的问题</strong>。一般磁盘的连续读写速度为几十MB，以这样的速度，几十PB的数据恐怕要读写到天荒地老。</p>
<p>3.<strong>数据可靠性的问题</strong>。磁盘大约是计算机设备中最易损坏的硬件了，通常情况一块磁盘使用寿命大概是一年，如果磁盘损坏了，数据怎么办？</p>
<p>RAID（独立磁盘冗余阵列）技术是将多块普通磁盘组成一个阵列，共同对外提供服务。主要是为了改善磁盘的存储容量、读写速度，增强磁盘的可用性和容错能力。</p>
<p>目前服务器级别的计算机都支持插入多块磁盘（8块或者更多），通过使用RAID技术，实现数据在多块磁盘上的并发读写和数据备份。</p>
<p><strong>RAID 0</strong>是数据在从内存缓冲区写入磁盘时，根据磁盘数量将数据分成N份，这些数据同时并发写入N块磁盘，使得数据整体写入速度是一块磁盘的N倍；读取的时候也一样，因此RAID 0具有极快的数据读写速度。但是RAID 0不做数据备份，N块磁盘中只要有一块损坏，数据完整性就被破坏，其他磁盘的数据也都无法使用了。</p>
<p><strong>RAID 1</strong>是数据在写入磁盘时，将一份数据同时写入两块磁盘，这样任何一块磁盘损坏都不会导致数据丢失，插入一块新磁盘就可以通过复制数据的方式自动修复，具有极高的可靠性。</p>
<p>结合RAID 0和RAID 1两种方案构成了<strong>RAID 10</strong>，它是将所有磁盘N平均分成两份，数据同时在两份磁盘写入，相当于RAID 1；但是平分成两份，在每一份磁盘（也就是N/2块磁盘）里面，利用RAID 0技术并发读写，这样既提高可靠性又改善性能。不过RAID 10的磁盘利用率较低，有一半的磁盘用来写备份数据。</p>
<p><strong>RAID 3</strong>可以在数据写入磁盘的时候，将数据分成N-1份，并发写入N-1块磁盘，并在第N块磁盘记录校验数据，这样任何一块磁盘损坏（包括校验数据磁盘），都可以利用其他N-1块磁盘的数据修复。但是在数据修改较多的场景中，任何磁盘数据的修改，都会导致第N块磁盘重写校验数据。频繁写入的后果是第N块磁盘比其他磁盘更容易损坏，需要频繁更换，所以RAID 3很少在实践中使用。</p>
<p>相比RAID 3，<strong>RAID 5</strong>是使用更多的方案。RAID 5和RAID 3很相似，但是校验数据不是写入第N块磁盘，而是螺旋式地写入所有磁盘中。这样校验数据的修改也被平均到所有磁盘上，避免RAID 3频繁写坏一块磁盘的情况。</p>
<p><strong>RAID 6</strong>和RAID 5类似，但是数据只写入N-2块磁盘，并螺旋式地在两块磁盘中写入校验信息（使用不同算法生成）。<br><img src="/img/add/37.png" alt=""></p>
<p>RAID可以看作是一种垂直伸缩，一台计算机集成更多的磁盘实现数据更大规模、更安全可靠的存储以及更快的访问速度。而HDFS则是水平伸缩，通过添加更多的服务器实现数据更大、更快、更安全存储与访问。<strong>将RAID思想原理应用到分布式服务器集群上，就形成了Hadoop分布式文件系统HDFS的架构思想</strong>。</p>
<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>Hadoop的第一个产品是HDFS，可以说分布式文件存储是分布式计算的基础，也可见分布式文件存储的重要性。<strong>HDFS也许不是最好的大数据存储技术，但依然最重要的大数据存储技术</strong>。</p>
<p>HDFS是在一个大规模分布式服务器集群上，对数据分片后进行并行读写及冗余存储。因为HDFS可以部署在一个比较大的服务器集群上，集群中所有服务器的磁盘都可供HDFS使用，所以整个HDFS的存储空间可以达到PB级容量。<br><img src="/img/add/38.png" alt="img"></p>
<p>两个关键组件：<strong>DataNode</strong>和<strong>NameNode</strong>。</p>
<p><strong>DataNode负责文件数据的存储和读写操作，HDFS将文件数据分割成若干数据块（Block），每个DataNode存储一部分数据块，这样文件就分布存储在整个HDFS服务器集群中</strong>。应用程序客户端（Client）可以并行对这些数据块进行访问，从而使得HDFS可以在服务器集群规模上实现数据并行访问，极大地提高了访问速度。在实践中，HDFS集群的DataNode服务器会有很多台，一般在几百台到几千台这样的规模，每台服务器配有数块磁盘，整个集群的存储容量大概在几PB到数百PB。</p>
<p><strong>NameNode负责整个分布式文件系统的元数据（MetaData）管理，也就是文件路径名、数据块的ID以及存储位置等信息，相当于操作系统中文件分配表（FAT）的角色</strong>。HDFS为了保证数据的高可用，会将一个数据块复制为多份（缺省情况为3份），并将多份相同的数据块存储在不同的服务器上，甚至不同的机架上。这样当有磁盘损坏，或者某个DataNode服务器宕机，甚至某个交换机宕机，导致其存储的数据块不能访问的时候，客户端会查找其备份的数据块进行访问。</p>
<p><img src="/img/add/39.png" alt=""></p>
<p>图中对于文件/ users / sameerp / data / part-0，其复制备份数设置为2，存储的BlockID分别为1、3。Block1的两个备份存储在DataNode0和DataNode2两个服务器上，Block3的两个备份存储DataNode4和DataNode6两个服务器上，上述任何一台服务器宕机后，每个数据块都至少还有一个备份存在，不会影响对文件/ users / sameerp / data / part-0的访问。</p>
<p>和RAID一样，数据分成若干数据块后存储到不同服务器上，可以实现数据大容量存储，并且不同分片的数据可以并行进行读/写操作，进而实现数据的高速访问。你可以看到，HDFS的<strong>大容量存储</strong>和<strong>高速访问</strong>相对比较容易实现，下面就是关于HDFS的<strong>高可用</strong>设计。</p>
<ol>
<li><strong>数据存储故障容错</strong>，磁盘介质在存储过程中受环境或者老化影响，其存储的数据可能会出现错乱。HDFS的应对措施是，对于存储在DataNode上的数据块，计算并存储校验和（CheckSum）。在读取数据的时候，重新计算读取出来的数据的校验和，如果校验不正确就抛出异常，应用程序捕获异常后就到其他DataNode上读取备份数据。</li>
<li><strong>磁盘故障容错</strong>，如果DataNode监测到本机的某块磁盘损坏，就将该块磁盘上存储的所有BlockID报告给NameNode，NameNode检查这些数据块还在哪些DataNode上有备份，通知相应的DataNode服务器将对应的数据块复制到其他服务器上，以保证数据块的备份数满足要求。</li>
<li><strong>DataNode故障容错</strong>，DataNode会通过心跳和NameNode保持通信，如果DataNode超时未发送心跳，NameNode就会认为这个DataNode已经宕机失效，立即查找这个DataNode上存储的数据块有哪些，以及这些数据块还存储在哪些服务器上，随后通知这些服务器再复制一份数据块到其他服务器上，保证HDFS存储的数据块备份数符合用户设置的数目，即使再出现服务器宕机，也不会丢失数据。</li>
<li><strong>NameNode故障容错</strong>，NameNode是整个HDFS的核心，记录着HDFS文件分配表信息，所有的文件路径和数据块存储信息都保存在NameNode，如果NameNode故障，整个HDFS系统集群都无法使用；如果NameNode上记录的数据丢失，整个集群所有DataNode存储的数据也就没用了。所以，NameNode高可用容错能力非常重要。NameNode采用主从热备的方式提供高可用服务。</li>
</ol>
<p><img src="/img/add/40.png" alt=""><br>集群部署两台NameNode服务器，一台作为主服务器提供服务，一台作为从服务器进行热备，两台服务器通过ZooKeeper选举，主要是通过争夺znode锁资源，决定谁是主服务器。而DataNode则会向两个NameNode同时发送心跳数据，但是只有主NameNode才能向DataNode返回控制信息。</p>
<p>正常运行期间，主从NameNode之间通过一个共享存储系统shared edits来同步文件系统的元数据信息。当主NameNode服务器宕机，从NameNode会通过ZooKeeper升级成为主服务器，并保证HDFS集群的元数据信息，也就是文件分配表信息完整一致。</p>
<p>分布式系统可能出故障地方又非常多，内存、CPU、主板、磁盘会损坏，服务器会宕机，网络会中断，机房会停电，所有这些都可能会引起软件系统的不可用，甚至数据永久丢失。<br><strong>常用的保证系统可用性的策略有冗余备份、失效转移和降级限流。</strong></p>
<ol>
<li><strong>冗余备份</strong>，任何程序、任何数据，都至少要有一个备份，也就是说程序至少要部署到两台服务器，数据至少要备份到另一台服务器上。此外，稍有规模的互联网企业都会建设多个数据中心，数据中心之间互相进行备份，用户请求可能会被分发到任何一个数据中心，即所谓的异地多活，在遭遇地域性的重大故障和自然灾害的时候，依然保证应用的高可用。</li>
<li><strong>失效转移</strong>，当要访问的程序或者数据无法访问时，需要将访问请求转移到备份的程序或者数据所在的服务器上。失效转移应该注意的是<strong>失效的鉴定</strong>，像NameNode这样主从服务器管理同一份数据的场景，如果从服务器错误地以为主服务器宕机而接管集群管理，会出现主从服务器一起对DataNode发送指令，进而导致集群混乱，也就是所谓的“<strong>脑裂</strong>”。这也是这类场景选举主服务器时，引入ZooKeeper的原因。</li>
<li>当大量的用户请求或者数据处理请求到达的时候，由于计算资源有限，可能无法处理如此大量的请求，进而导致资源耗尽，系统崩溃。这种情况下，可以拒绝部分请求，即进行<strong>限流</strong>；也可以关闭部分功能，降低资源消耗，即进行<strong>降级</strong>。限流是互联网应用的常备功能，因为超出负载能力的访问流量在何时会突然到来，根本无法预料，所以必须提前做好准备，当遇到突发高峰流量时，就可以立即启动限流。而降级通常是为可预知的场景准备的，比如电商的“双十一”促销，为了保障促销活动期间应用的核心功能能够正常运行，比如下单功能，可以对系统进行降级处理，关闭部分非重要功能，比如商品评价功能。</li>
</ol>
<p>HDFS是通过大规模分布式服务器集群实现数据的大容量、高速、可靠存储、访问的。</p>
<ol>
<li>文件数据以数据块的方式进行切分，数据块可以存储在集群任意DataNode服务器上，所以HDFS存储的文件可以非常大，一个文件理论上可以占据整个HDFS服务器集群上的所有磁盘，实现了大容量存储。</li>
<li>HDFS一般的访问模式是通过MapReduce程序在计算时读取，MapReduce对输入数据进行分片读取，通常一个分片就是一个数据块，每个数据块分配一个计算进程，这样就可以同时启动很多进程对一个HDFS文件的多个数据块进行并发访问，从而实现数据的高速访问。</li>
<li>DataNode存储的数据块会进行复制，使每个数据块在集群里有多个备份，保证了数据的可靠性，并通过一系列的故障容错手段实现HDFS系统中主要组件的高可用，进而保证数据和整个系统的高可用。</li>
</ol>
<h1 id="MapReduce概述"><a href="#MapReduce概述" class="headerlink" title="MapReduce概述"></a>MapReduce概述</h1><p><strong>MapReduce既是一个编程模型，又是一个计算框架</strong>。开发人员必须基于MapReduce编程模型进行编程开发，然后将程序通过MapReduce计算框架分发到Hadoop集群中运行。</p>
<p>其编程模型只包含Map和Reduce两个过程，map的主要输入是一对&lt;Key, Value&gt;值，经过map计算后输出一对&lt;Key, Value&gt;值；然后将相同Key合并，形成&lt;Key, Value集合&gt;；再将这个&lt;Key, Value集合&gt;输入reduce，经过计算输出零个或多个&lt;Key, Value&gt;对。</p>
<p>MapReduce非常强大的，不管是关系代数运算（SQL计算），还是矩阵运算（图计算），大数据领域几乎所有的计算需求都可以通过MapReduce编程来实现。</p>
<p>以wordcount为例</p>
<p><img src="/img/add/41.png" alt=""></p>
<p>少量数据一个哈希表就能够完成。MapReduce版本WordCount程序的核心是一个map函数和一个reduce函数。</p>
<p><strong>map函数</strong>的输入主要是一个&lt;Key, Value&gt;对，map函数的计算过程是，将这行文本中的单词提取出来，针对每个单词输出一个&lt;word, 1&gt;这样的&lt;Key, Value&gt;对。</p>
<p>MapReduce计算框架会将这些<word 1="" ,="">收集起来，将相同的word放在一起，形成&lt;word , &lt;1,1,1,1,1,1,1…&gt;&gt;这样的&lt;Key, Value集合&gt;数据，然后将其输入给reduce函数。</word></p>
<p>这里<strong>reduce</strong>的输入参数Values就是由很多个1组成的集合，而Key就是具体的单词word。reduce函数的计算过程是，将这个集合里的1求和，再将单词（word）和这个和（sum）组成一个&lt;Key, Value&gt;，也就是&lt;word, sum&gt;输出。每一个输出就是一个单词和它的词频统计总和。</p>
<p>一个map函数可以针对一部分数据进行运算，这样就可以将一个大数据切分成很多块（这也正是HDFS所做的），MapReduce计算框架为每个数据块分配一个map函数去计算，从而实现大数据的分布式计算。</p>
<p><img src="/img/add/42.png" alt=""></p>
<p>红圈对应的分别是MapReduce作业启动和运行，以及MapReduce数据合并与连接。</p>
<h2 id="MapReduce作业启动和运行机制"><a href="#MapReduce作业启动和运行机制" class="headerlink" title="MapReduce作业启动和运行机制"></a>MapReduce作业启动和运行机制</h2><p>MapReduce运行过程涉及三类关键进程。</p>
<ol>
<li><strong>大数据应用进程</strong>。这类进程是启动MapReduce程序的主入口，主要是指定Map和Reduce类、输入输出文件路径等，并提交作业给Hadoop集群，比如WordCount程序。</li>
<li><strong>JobTracker进程</strong>。这类进程根据要处理的输入数据量，命令<strong>TaskTracker</strong>进程启动相应数量的Map和Reduce进程任务，并管理整个作业生命周期的任务调度和监控。这是Hadoop集群的<strong>常驻进程</strong>，需要注意的是，JobTracker进程在整个Hadoop集群<strong>全局唯一</strong>。</li>
<li><strong>TaskTracker进程</strong>。这个进程负责启动和管理Map进程以及Reduce进程。因为需要每个数据块都有对应的map函数，TaskTracker进程通常和HDFS的DataNode进程启动在同一个服务器。也就是说，Hadoop集群中绝大多数服务器同时运行DataNode进程和TaskTracker进程。</li>
</ol>
<p><strong>JobTracker</strong>进程和<strong>TaskTracker</strong>进程是主从关系，MapReduce的主服务器就是JobTracker，从服务器就是TaskTracker。HDFS也是主从架构吗，HDFS的主服务器是NameNode，从服务器是DataNode。</p>
<p><img src="/img/add/43.png" alt=""></p>
<p>计算流程为：</p>
<ol>
<li>应用进程JobClient将用户作业JAR包存储在HDFS中，将来这些JAR包会分发给Hadoop集群中的服务器执行MapReduce计算。</li>
<li>应用程序提交job作业给JobTracker。</li>
<li>JobTracker根据作业调度策略创建JobInProcess树，每个作业都会有一个自己的JobInProcess树。</li>
<li>JobInProcess根据输入数据分片数目（通常情况就是数据块的数目）和设置的Reduce数目创建相应数量的TaskInProcess。</li>
<li>TaskTracker进程和JobTracker进程进行定时通信。</li>
<li>如果TaskTracker有空闲的计算资源（有空闲CPU核心），JobTracker就会给它分配任务。分配任务的时候会根据TaskTracker的服务器名字匹配在同一台机器上的数据块计算任务给它，使启动的计算任务正好处理本机上的数据，以实现我们一开始就提到的“移动计算比移动数据更划算”。</li>
<li>TaskTracker收到任务后根据任务类型（是Map还是Reduce）和任务参数（作业JAR包路径、输入数据文件路径、要处理的数据在文件中的起始位置和偏移量、数据块多个备份的DataNode主机名等），启动相应的Map或者Reduce进程。</li>
<li>Map或者Reduce进程启动后，检查本地是否有要执行任务的JAR包文件，如果没有，就去HDFS上下载，然后加载Map或者Reduce代码开始执行。</li>
<li>如果是Map进程，从HDFS读取数据（通常要读取的数据块正好存储在本机）；如果是Reduce进程，将结果数据写出到HDFS。</li>
</ol>
<h2 id="MapReduce数据合并与连接机制"><a href="#MapReduce数据合并与连接机制" class="headerlink" title="MapReduce数据合并与连接机制"></a>MapReduce数据合并与连接机制</h2><p><img src="/img/add/44.png" alt=""></p>
<p>每个Map任务的计算结果都会写入到本地文件系统，等Map任务快要计算完成的时候，MapReduce计算框架会启动<strong>shuffle</strong>过程，在Map任务进程调用一个<strong>Partitioner</strong>接口，对Map产生的每个&lt;Key, Value&gt;进行Reduce分区选择，然后通过HTTP通信发送给对应的Reduce进程。这样不管Map位于哪个服务器节点，相同的Key一定会被发送给相同的Reduce进程。Reduce任务进程对收到的&lt;Key, Value&gt;进行排序和合并，<strong>相同的Key放在一起，组成一个&lt;Key, Value集合&gt;传递给Reduce执行。</strong></p>
<p>map输出的&lt;Key, Value&gt;shuffle到哪个Reduce进程是这里的关键，它是由Partitioner来实现，<strong>MapReduce框架默认的Partitioner用Key的哈希值对Reduce任务数量取模</strong>，相同的Key一定会落在相同的Reduce任务ID上。</p>
<p><strong>分布式计算需要将不同服务器上的相关数据合并到一起进行下一步计算，这就是shuffle</strong>。</p>
<p>shuffle是大数据计算过程中最神奇的地方，不管是MapReduce还是Spark，只要是大数据批处理计算，一定都会有shuffle过程，只有<strong>让数据关联起来</strong>，数据的内在关系和价值才会呈现出来。<strong>shuffle也是整个MapReduce过程中最难、最消耗性能的地方</strong>。</p>
<h1 id="资源调度框架Yarn"><a href="#资源调度框架Yarn" class="headerlink" title="资源调度框架Yarn"></a>资源调度框架Yarn</h1><p>Hadoop主要是由三部分组成，分布式文件系统HDFS、分布式计算框架MapReduce，还有一个是<strong>分布式集群资源调度框架Yarn</strong>。</p>
<p>在MapReduce应用程序的启动过程中，最重要的就是要把MapReduce程序分发到大数据集群的服务器上，在Hadoop 1中，这个过程主要是通过TaskTracker和JobTracker通信来完成。这种架构方案的主要缺点是，<strong>服务器集群资源调度管理和MapReduce执行过程耦合在一起，如果想在当前集群中运行其他计算任务，比如Spark或者Storm，就无法统一使用集群中的资源了</strong>。</p>
<p><strong>Hadoop 2最主要的变化，</strong>就是将Yarn从MapReduce中分离出来，成为一个独立的资源调度框架。</p>
<p><img src="/img/add/45.png" alt=""></p>
<p>Yarn包括两个部分：一个是<strong>资源管理器（Resource Manager）</strong>，一个是<strong>节点管理器（Node Manager）</strong>。这也是Yarn的两种主要进程：<strong>ResourceManager进程</strong>负责整个集群的资源调度管理，<strong>通常部署在独立的服务器</strong>上；<strong>NodeManager进程</strong>负责具体服务器上的资源和任务管理，在集群的每一台计算服务器上都会启动，<strong>基本上跟HDFS的DataNode进程一起出现。</strong></p>
<hr>
<p><strong>资源管理器</strong>又包括两个主要组件：<strong>调度器</strong>和<strong>应用程序管理器</strong>。</p>
<ol>
<li><strong>调度器</strong>其实就是一个资源分配算法，根据应用程序（Client）提交的资源申请和当前服务器集群的资源状况进行资源分配。Yarn内置了几种资源调度算法，包括Fair Scheduler、Capacity Scheduler等，也可以开发自己的资源调度算法供Yarn调用。Yarn进行资源分配的单位是<strong>容器</strong>（Container），每个容器包含了一定量的内存、CPU等计算资源，默认配置下，每个容器包含一个CPU核心。<strong>容器由NodeManager进程启动和管理，NodeManger进程会监控本节点上容器的运行状况并向ResourceManger进程汇报。</strong></li>
<li><strong>应用程序管理器</strong>负责应用程序的提交、监控应用程序运行状态等。应用程序启动后需要在集群中运行一个<strong>ApplicationMaster</strong>，<strong>ApplicationMaster也需要运行在容器里面。每个应用程序启动后都会先启动自己的ApplicationMaster，由ApplicationMaster根据应用程序的资源需求进一步向ResourceManager进程申请容器资源，得到容器以后就会分发自己的应用程序代码到容器上启动，进而开始分布式计算。</strong></li>
</ol>
<hr>
<p>一个MapReduce程序，Yarn的整个工作流程：</p>
<ol>
<li>我们向Yarn提交应用程序，包括MapReduce ApplicationMaster、我们的MapReduce程序，以及MapReduce Application启动命令。</li>
<li>ResourceManager进程和NodeManager进程通信，根据集群资源，为用户程序分配第一个容器，并将MapReduce ApplicationMaster分发到这个容器上面，并在容器里面启动MapReduce ApplicationMaster。</li>
<li>MapReduce ApplicationMaster启动后立即向ResourceManager进程注册，并为自己的应用程序申请容器资源。</li>
<li>MapReduce ApplicationMaster申请到需要的容器后，立即和相应的NodeManager进程通信，将用户MapReduce程序分发到NodeManager进程所在服务器，并在容器中运行，运行的就是Map或者Reduce任务。</li>
<li>Map或者Reduce任务在运行期和MapReduce ApplicationMaster通信，汇报自己的运行状态，如果运行结束，MapReduce ApplicationMaster向ResourceManager进程注销并释放所有的容器资源。</li>
</ol>
<p>MapReduce如果想在Yarn上运行，就需要开发遵循Yarn规范的MapReduce ApplicationMaster，相应地，其他大数据计算框架也可以开发遵循Yarn规范的ApplicationMaster，这样在一个Yarn集群中就可以同时并发执行各种不同的大数据计算框架，实现资源的统一调度管理。</p>
<hr>
<p>管HDFS叫分布式文件<strong>系统</strong>，管MapReduce叫分布式计算<strong>框架</strong>，管Yarn叫分布式集群资源调度<strong>框架</strong>。</p>
<p>框架在架构设计上遵循一个重要的设计原则叫“<strong>依赖倒转原则</strong>”，依赖倒转原则是<strong>高层模块不能依赖低层模块，它们应该共同依赖一个抽象，这个抽象由高层模块定义，由低层模块实现。</strong></p>
<p>实现MapReduce编程接口、遵循MapReduce编程规范就可以被MapReduce框架调用，在分布式集群中计算大规模数据；实现了Yarn的接口规范，比如Hadoop 2的MapReduce，就可以被Yarn调度管理，统一安排服务器资源。所以说，MapReduce和Yarn都是框架。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/06/28/字符串匹配算法 KMP/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/28/字符串匹配算法 KMP/" class="post-title-link" itemprop="url">字符串匹配算法 KMP</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-28 10:24:56" itemprop="dateCreated datePublished" datetime="2019-06-28T10:24:56+08:00">2019-06-28</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-13 22:35:03" itemprop="dateModified" datetime="2019-07-13T22:35:03+08:00">2019-07-13</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/28/字符串匹配算法 KMP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/28/字符串匹配算法 KMP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/06/28/字符串匹配算法 KMP/" class="post-meta-item leancloud_visitors" data-flag-title="字符串匹配算法 KMP">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="字符串匹配算法-KMP"><a href="#字符串匹配算法-KMP" class="headerlink" title="字符串匹配算法 KMP"></a>字符串匹配算法 KMP</h1><p>BM算法是工程中非常常用的一种高效字符串匹配算法，是最高效最常用的字符串匹配算法。在所有字符串匹配算法中，最知名的非KMP算法莫属。</p>
<h1 id="KMP算法基本原理"><a href="#KMP算法基本原理" class="headerlink" title="KMP算法基本原理"></a>KMP算法基本原理</h1><p>KMP算法的核心思想与BM算法非常相近。在模式串与主串匹配过程中，当遇到不可匹配的字符时，通过找到一些规律将模式串往后多滑动几位，跳过肯定不会匹配的情况。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20KMP/17ae3d55cf140285d1f34481e173aebe.jpg" alt=""><br>当遇到坏字符的时候，就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20KMP/f4ef2c1e6ce5915e1c6460c2e26c9469.jpg" alt=""><br>KMP算法就是在试图寻找一种规律: <strong>在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，找到一种规律，将模式串一次性滑动很多位。</strong><br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20KMP/da99c0349f8fac27e193af8d801dbb8f.jpg" alt=""></p>
<p><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20KMP/9e59c0973ffb965abdd3be5eafb492ad.jpg" alt=""><br>求好前缀的最长可匹配前缀和后缀自串不涉及主串，只需要通过模式串本身就能求解。KMP算法也可以提前构建一个数组，用来存储模式串中每个前缀（有可能是好前缀）的最长可匹配前缀自串的结尾字符下标。把这个数组定义为<strong>next数组</strong>，又叫<strong>失效函数</strong>。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20KMP/1661d37cb190cb83d713749ff9feaea8.jpg" alt=""></p>
<h1 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h1><p>最复杂的部分就是next数组计算。</p>
<p>最简单也最低效的是像👆一样依次遍历。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20KMP/1ee5bea573abd033a6aa35d15ef0baec.jpg" alt=""><br>如何更好的理解和掌握 KMP 算法? - 逍遥行的回答 - 知乎<br><a href="https://www.zhihu.com/question/21923021/answer/37475572" target="_blank" rel="noopener">https://www.zhihu.com/question/21923021/answer/37475572</a></p>
<p>在计算next[i]时，前面的next[0],next[1],….,next[i-1]已经计算出来了，利用已经计算出来的next值，可以快速推导出next[i]的值。</p>
<hr>
<p>例子：<br>abababzabababa<br>列个表计算一下：<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20KMP/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-28%20%E4%B8%8A%E5%8D%8810.07.22.png" alt=""><br>对子字符串 abababzababab 来说，前缀有 a, ab, aba, abab, ababa, ababab, abababz, …后缀有 b, ab, bab, abab, babab, ababab, zababab, …所以子字符串 abababzababab 前缀后缀最大匹配了 6 个（ababab），容易看出次大匹配了 4 个（abab），更仔细地观察可以发现，次大匹配的前缀后缀只可能在 ababab 中，所以<strong>次大匹配数就是 ababab 的最大匹配数</strong>。</p>
<p>来计算 ? 的值：既然末尾字母不是 z，那么就不能直接 6+1=7 了，回退到次大匹配 abab，刚好 abab 之后的 a 与末尾的 a 匹配，所以 ? 处的最大匹配数为 5。</p>
<hr>
<h1 id="KMP算法复杂度分析"><a href="#KMP算法复杂度分析" class="headerlink" title="KMP算法复杂度分析"></a>KMP算法复杂度分析</h1><p>空间复杂度：<br>KMP算法只需要一个额外的next数组,数组的大小跟模式串相同。所以空间复杂度是O(m),m表示模式串的长度。</p>
<p>时间复杂度：<br>时间复杂度包括两部分，第一部分是构建next数组，第二部分是借助next数组匹配。</p>
<p>时间复杂度为O(m+n)</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/06/28/字符串匹配算法 BF RK BM/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/28/字符串匹配算法 BF RK BM/" class="post-title-link" itemprop="url">字符串匹配算法 BF RK BM</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-28 10:23:56 / 修改时间：10:24:08" itemprop="dateCreated datePublished" datetime="2019-06-28T10:23:56+08:00">2019-06-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/28/字符串匹配算法 BF RK BM/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/28/字符串匹配算法 BF RK BM/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/06/28/字符串匹配算法 BF RK BM/" class="post-meta-item leancloud_visitors" data-flag-title="字符串匹配算法 BF RK BM">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>java</strong>中的<strong>indexOf(),Python</strong>中的<strong>find()</strong>函数，底层依赖的就是字符串匹配算法。</p>
<p>字符串匹匹配算法有<strong>BF算法，RK算法，BM算法，KMP算法。</strong></p>
<p>其中BF算法RK算法是单模式匹配算法，即为一个串和另一个串进行匹配。</p>
<h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><p>Brute Force，即为暴力匹配算法，比较简单，性能不高。</p>
<p>主串的长度记作n,模式串的长度记作m。因为是在主串中查找模式串,所以n&gt;m。在主串中，检查起始位置分别是0、1、…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/f36fed972a5bdc75331d59c36eb15aa2.jpg" alt=""><br>算法最坏时间复杂度为<strong>O(n * m)</strong></p>
<p>尽管理论上，BF算法的时间复杂度很高，但在实际的开发中，它却是一个比较常用的字符串匹配算法。<br>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n * m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。<br>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是常说的KISS (Keep it Simple and Stupid)设计原则。</p>
<p>在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p>
<h1 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h1><p>RK算法即为BF算法的升级版。</p>
<p>RK算法的思路为:通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等非常快速的，所以模式串和子串比较的效率就提高了。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/015c85a9c2a4adc11236f9a40c6d57ee.jpg" alt=""><br>为了避免遍历字串中的每一个字符，提高算法的效率，需要对哈希算法进行设计。</p>
<p>假设要匹配的字符串的字符集中只包含K个字符，可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/d5c1cb11d9fc97d0b28513ba7495ab04.jpg" alt=""><br>这种哈希算法有一个特点， 在主串中，相邻两个子串的哈希值的计算公式有一定关系。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/f99c16f2f899d19935567102c59661f5.jpg" alt=""><br>规律:相邻两个子串s[i-1]和s[i] (i 表示子串在主串中的起始位置，子串的长度都为m)，对应的哈希值计算公式有交集，可以使用s[i-1]的哈希值很快的计算出s[i]的哈希值。用公式表示:<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/f298f1e5c93b205345b9cd6d9c53fbee.jpg" alt=""><br>26^(m-1)这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好26^0、26^1、 2……26^(m -1),并且存储在一个长度为m的数组中，公式中的“次方”就对应数组的下标。当我们需要计算26的x次方的时候，就可以从数组的下标为x的位置取值，直接使用，省去了计算的时间。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/224b899c6e82ec54594e2683acc4552f.jpg" alt=""><br>RK算法时间复杂度分析：<br>整个RK算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。<br>第一部分，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，这部分的时间复杂度是O(n)。<br>如果模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，为了能将哈希值落在整型数据范围内，可以牺牲一下， 允许哈希冲突。比如可以将字符串中每个字母对应的数字相加得到哈希值，这样产生的哈希值数据范围就小很多。<br>当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。解决方法是当发现一个子串的哈希值跟模式串的哈希值相等的时候，只需要再对比一下子串和模式串本身。</p>
<p>极端情况下，如果存在大量的冲突，每次都要对比字串和模式串本身，时间复杂度会退化为O( n * m)。一般情况下，冲突不会很多，RK算法效率还是比BF算法高。</p>
<h1 id="二维空间"><a href="#二维空间" class="headerlink" title="二维空间"></a>二维空间</h1><p><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/00c353326466a8ce4e790e36924704c9.jpg" alt=""><br>可以同理看做一个字符串来处理。</p>
<h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>BF，RK算法中遇到不匹配，模式串往后滑动一位，然后从模式串第一个字符开始重新匹配。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/4316dd98eac500a01a0fd632bb5e77f9.jpg" alt=""><br>主串中的c，在模式串中是不存在的，模式串向后滑动的时候，只要c与模式串有重合，肯定无法匹配。所以，可以一次性把模式串往后多滑动几位，把模式串移动到c的后面。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/cf362f9e59c01aaf40a34d2f10e1ef15.jpg" alt=""><br>BM算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p>
<h2 id="BM算法原理分析"><a href="#BM算法原理分析" class="headerlink" title="BM算法原理分析"></a>BM算法原理分析</h2><p>BM算法包含两部分，分别是<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。</p>
<h3 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h3><p><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/540809418354024206d9989cb6cdd89e.jpg" alt=""><br>BM算法的匹配顺序比较特别，是按照模式串下标从大到小的顺序，倒着匹配的。当发现某个字符没法匹配的时候。把这个没有匹配的字符叫作<strong>坏字符</strong>(主串中的字符)。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/220daef736418df84367215647bca5da.jpg" alt=""><br>拿坏字符c在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符c与模式串中的任何字符都不可能匹配。这个时候，可以将模式串直接往后滑动三位，将模式串滑动到c后面的位置，再从模式串的末尾字符开始比较。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/4e36c4d48d1b6c3b499fb021f03c7f64.jpg" alt=""><br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/a8d229aa217a67051fbb31b8aeb2edca.jpg" alt=""><br>然后对于模式串中存在的a，滑动两位，让两个串对齐。</p>
<p>总结规律为：<br>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作si。如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作xi。如果不存在，把xi记作-1。那模式串往后移动的位数就等于si-xi。(注意, 这里都是字符在模式串的下标)。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/8f520fb9d9cec0f6ea641d4181eb432e.jpg" alt=""><br>如果坏字符在模式串里多处出现，在计算xi的时候，选择最靠后的那个，这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p>
<p>单纯使用坏字符规则还是不够的。因为根据si-xi计算出来的移动位数，有可能是负数。所以，BM算法还需要用到“好后缀规则”</p>
<h3 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h3><p><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/d78990dbcb794d1aa2cf4a3c646ae58a.jpg" alt=""><br>把已经匹配的bc叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u <em> }，那我们就将模式串滑动到子串{u </em> }与主串中{u}对齐的位置。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/b9785be3e91e34bbc23961f67c234b63.jpg" alt=""><br>如果在模式串中找不到另一个等于{u}的子串，就直接将模式串滑动到主串中{u}的后面。此时有可能存在滑动过头的情况，错过匹配字符串。所以不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/0544d2997d8bb57c10e13ccac4015e23.jpg" alt=""><br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/6caa0f61387fd2b3109fe03d803192f9.jpg" alt=""></p>
<p><strong>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</strong></p>
<h2 id="BM算法代码实现"><a href="#BM算法代码实现" class="headerlink" title="BM算法代码实现"></a>BM算法代码实现</h2><p>坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/bf78f8a0506e069fa318f36c42a95e02.jpg" alt=""></p>
<p><strong>表示模式字串中不同的后缀字串。</strong><br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/7742f1d02d0940a1ef3760faf4929ec8.jpg" alt=""><br>suffix数组下标k，表示后缀字串的长度，下标对应的数组值存储的是在模式串中跟好后缀{u}相匹配的字串{u * }的起始下标值。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/99a6cfadf2f9a713401ba8feac2484c2.jpg" alt=""><br>不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。<br>除了suffix数组外，还需要另一个boolean类的prefix数组，来记录模式串的后缀字串能否匹配模式串的前缀字串。<br><img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/279be7d64e6254dac1a32d2f6d1a2383.jpg" alt=""></p>
<h2 id="BM算法的性能分析及优化"><a href="#BM算法的性能分析及优化" class="headerlink" title="BM算法的性能分析及优化"></a>BM算法的性能分析及优化</h2><p>BM内存消耗，其中bc数组的大小跟字符集大小有关，suffix 数组和prefix数组的大小跟模式串长度m有关。</p>
<p>如果处理字符集很大的字符串匹配问题，bc 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果运行的环境对内存要求苛刻，可以只使用好后缀规则，不使用坏字符规则，这样就可以避免bc数组过多的内存消耗。不过，单纯使用好后缀规则的BM算法效率就会下降一些了。</p>
<p>BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM算法构建的规则有两类，<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，可以只用好后缀规则来实现BM算法。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/06/24/MyBatis基础/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/MyBatis基础/" class="post-title-link" itemprop="url">MyBatis基础</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 19:30:47 / 修改时间：19:31:20" itemprop="dateCreated datePublished" datetime="2019-06-24T19:30:47+08:00">2019-06-24</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/24/MyBatis基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/24/MyBatis基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/06/24/MyBatis基础/" class="post-meta-item leancloud_visitors" data-flag-title="MyBatis基础">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MyBatis可以使用XML或注解进行配置和映射，MyBatis通过将参数映射到配置的SQL形成最终执行的SQL语句，最后将执行SQL的结果映射成Java对象返回。与其他的ORM (对象关系映射)框架不同，MyBatis 并没有将Java对象与数据库表关联起来，而是将Java方法与SQL语句关联。</p>
<p>在实际应用中，一个表一般会对应一个实体，用于INSERT、UPDATE、DELETE 和简单的SELECT操作，所以姑且称这个简单的对象为实体类。</p>
<h1 id="XML方式的基本用法"><a href="#XML方式的基本用法" class="headerlink" title="XML方式的基本用法"></a>XML方式的基本用法</h1><h2 id="一个简单的权限控制需求"><a href="#一个简单的权限控制需求" class="headerlink" title="一个简单的权限控制需求"></a>一个简单的权限控制需求</h2><p><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.37.31.png" alt=""><br>为了方便对表进行直接操作，此处没有创建表之间的外键关系。对于表之间的关系，会通过业务逻辑来进行限制。</p>
<p>创建表和创建实体类。<br><strong>特别注意，由于Java中的基本类型会有默认值，会导致很多隐藏的问题。所以在实体类中不要使用基本类型，基本类型包括byte,int,short,long,float,double,char,boolean。</strong></p>
<h2 id="使用XML方式"><a href="#使用XML方式" class="headerlink" title="使用XML方式"></a>使用XML方式</h2><p>创建数据表对应的XML文件，并创建对应的接口类。<br>将xml文件与对应的接口类产生联系。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.55.30.png" alt=""><br>将创建的mybatis-config.xml配置文件中的mappers元素中配置所有的mapper。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.56.59.png" alt=""><br>也可以进行更简单的配置。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.58.21.png" alt=""><br>这种配置方式会先查找tk. mybatis.simple . mapper包下所有的接口,循环对接口进行如下操作：<br>1.判断接口对应的命名空间是否已经存在，如果存在就抛出异常，不存在就继续进行接下来的操作。<br>2.加载接口对应的XML映射文件，将接口全限定名转换为路径，例如，将接口tk .mybatis. simple . mapper . UserMapper转换为tk/ mybatis/ simple/ mapper/ UserMapper.xml, 以.xml为后缀搜索XML资源，如果找到就解析XML。<br>3.处理接口中的注解方法。</p>
<h2 id="select用法"><a href="#select用法" class="headerlink" title="select用法"></a>select用法</h2><p>在接口中添加一个selectById方法。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.52.06.png" alt=""><br>使用MyBatis时，只需要在XML中添加一个select元素，写一个SQL,做一些简单的配置，就可以将查询的结果直接映射到对象中。<br>在xml中添加代码：<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.17.50.png" alt=""><br>XML中的select标签的id属性值和定义的接口方法名是一样的。MyBatis就是通过这种方式将接口方法和XML中定义的SQL语句关联到一起的，如果接口方法没有和XML中的id属性值相对应，启动程序便会报错。</p>
<p>jdbcType:列对应的数据库类型。JDBC 类型仅仅需要对插入、更新、删除操作可能为空的列进行处理。这是JDBC jdbcType的需要，而不是MyBatis的需要。</p>
<p><strong>自动映射</strong>，使用resultType来设置返回结果的类型，需要在SQL中为所有列名和属性名不一致的列设置别名，通过设置别名使最终的查询结果列和resultType指定对象的属性名保持一致。</p>
<hr>
<p><strong>名称映射规则</strong><br>property属性或别名要和对象中属性的名字相同，但是实际匹配时，MyBatis会先将两者都转换为大写形式， 然后再判断是否相同，即property=“userName” 和property=“username” 都可以匹配到对象的userName属性上。判断是否相同的时候要使用USERNAME,因此在设置property属性或别名的时候，不需要考虑大小写是否一致，但是为了便于阅读，要尽可能按照统一的规则来设置。</p>
<hr>
<p>MyBatis还提供了一个全局属性<strong>mapUnderscoreToCamelCase</strong>,通过配置这个属性为true可以自动将以下划线方式命名的数据库列映射到Java对象的驼峰式命名属性中。这个属性默认为false。需要在MyBatis配置文件中启用。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.39.40.png" alt=""><br>考虑性能，通常都会指定查询列，很少使用星号代替所有列。</p>
<p>多表查询中，方法写在任何一个对应的Mapper接口中都可以。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.45.58.png" alt=""></p>
<h2 id="insert用法"><a href="#insert用法" class="headerlink" title="insert用法"></a>insert用法</h2><p><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%885.59.33.png" alt=""><br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.02.35.png" alt=""><br>返回的int值是指执行的SQL影响的行数。</p>
<h3 id="使用JDBC方式返回主键自增的值"><a href="#使用JDBC方式返回主键自增的值" class="headerlink" title="使用JDBC方式返回主键自增的值"></a>使用JDBC方式返回主键自增的值</h3><p>在xml的标签中配置属性。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.23.18.png" alt=""><br>useGeneratedKeys设置为true后, MyBatis会使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键。获得主键值后将其赋值给keyProperty配置的id属性。SQL上下两部分的列中去掉了id列和对应的#{ id }属性。</p>
<h3 id="使用selectKey返回主键的值"><a href="#使用selectKey返回主键的值" class="headerlink" title="使用selectKey返回主键的值"></a>使用selectKey返回主键的值</h3><p>该方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.37.34.png" alt=""></p>
<h2 id="多个接口参数的用法"><a href="#多个接口参数的用法" class="headerlink" title="多个接口参数的用法"></a>多个接口参数的用法</h2><p>当参数是一个基本类型的时候，它在XML文件中对应的SQL语句只会使用一个参数，例如delete方法。当参数是一个JavaBean类型的时候，它在XML文件中对应的SQL语句会有多个参数，例如insert、update 方法。但并不适合全部的情况，因为不能只为了两三个参数去创建新的JavaBean，参数较少时还可以采用Map类型作为参数或使用@Param注解。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.48.44.png" alt=""><br>给参数配置@Param注解后，MyBatis 就会自动将参数封装成Map类型，@Param 注解值会作为Map中的key,因此在SQL部分就可以通过配置的注解值来使用参数。</p>
<p>当只有一一个参数(基本类型或拥有TypeHandler配置的类型)的时候，在这种情况下(除集合和数组外)，MyBatis不关心这个参数叫什么名字就会直接把这个唯一的参数值拿来使用。</p>
<h2 id="Mapper接口动态代理实现原理"><a href="#Mapper接口动态代理实现原理" class="headerlink" title="Mapper接口动态代理实现原理"></a>Mapper接口动态代理实现原理</h2><p>可以通过动态代理这个桥梁将对接口方法的调用转换为对其他方法的调用。</p>
<h1 id="MyBatis注解"><a href="#MyBatis注解" class="headerlink" title="MyBatis注解"></a>MyBatis注解</h1><p>MyBatis注解方式就是将SQL语句直接写在接口上。这种方式的优点是，对于需求比较简单的系统，效率较高。缺点是，当SQL有变化时都需要重新编译代码，一”般情况下不建议使用注解方式。</p>
<h2 id="Select注解"><a href="#Select注解" class="headerlink" title="@Select注解"></a>@Select注解</h2><p><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.04.53.png" alt=""></p>
<h1 id="Spring集成MyBatis"><a href="#Spring集成MyBatis" class="headerlink" title="Spring集成MyBatis"></a>Spring集成MyBatis</h1><p><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.09.59.png" alt=""><br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.14.23.png" alt=""></p>
<hr>
<p><strong>配置SqlSessionFactoryBean</strong><br>在MyBatis. Spring中,SqlSessionFactoryBean是用于创建SqlSessionFactory的。<br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.17.22.png" alt=""></p>
<hr>
<p><strong>配置MapperScannerConfigurer</strong><br><img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.19.04.png" alt=""></p>
<hr>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/06/21/Spring MVC/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/21/Spring MVC/" class="post-title-link" itemprop="url">Spring MVC</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-21 14:10:47 / 修改时间：14:12:04" itemprop="dateCreated datePublished" datetime="2019-06-21T14:10:47+08:00">2019-06-21</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/21/Spring MVC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/21/Spring MVC/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/06/21/Spring MVC/" class="post-meta-item leancloud_visitors" data-flag-title="Spring MVC">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-MVC起步"><a href="#Spring-MVC起步" class="headerlink" title="Spring MVC起步"></a>Spring MVC起步</h1><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%889.21.30.png" alt=""><br>在请求离开浏览器时，1️⃣：会带有用户所请求内容信息，至少会包含请求的URL。还可能带有其他的信息，例如用户提交的表单信息。</p>
<p>单实例Servlet ，DispatcherServlet将请求委托给应用程序的其他组件来执行实际处理。通过所携带的URL来进行决策。</p>
<p>控制器返回时仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。</p>
<h2 id="搭建Spring-MVC"><a href="#搭建Spring-MVC" class="headerlink" title="搭建Spring MVC"></a>搭建Spring MVC</h2><h3 id="配置DispatcherServlet"><a href="#配置DispatcherServlet" class="headerlink" title="配置DispatcherServlet"></a>配置DispatcherServlet</h3><p>传统方式，DispatcherServlet这样的Servlet会配置在web.xml中。但不是唯一的方法。扩展AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动配置DispatcherServlet和Spring应用上下文。Spring的应用上下文会位于应用程序的Servlet上下文之中。即为dispatchservlet.xml。</p>
<p>在 Servlet3环境中,容器会在类路径中查找实现 javax. servlet.ServletcontainerInitializer接口的类,如果能发现的话,就会用来配置 Servlet容器。Spring提供了这个接口的实现,名为SpringServletcontainerInitializer,这个类反过来又会查找实现 WebApplicationInitializer的类并将配置的任务交给它们来完成。 Spring3.2引入了一个便利的 WebApplicationInitializer基础实现,也就是AbstractAnnotationconfigDispatcherservletInitializer。当扩展了AbstractAnnotationconfigDispatcherServletinitializer，同时也就实现了 WebApplicationInitializer,因此当部署到 Servlet容器中的时候,容器会自动发现它,并用它来配置 Servlet上下文。</p>
<h3 id="两个应用上下文的联系"><a href="#两个应用上下文的联系" class="headerlink" title="两个应用上下文的联系"></a>两个应用上下文的联系</h3><p>当DispatcherServlet启动的时候，它会创建Spring应用上下文，并加载配置文件或配置类中所声明的bean。</p>
<p>在Spring Web应用中，通常还会有另外一个应用上下文。另外的这个应用上下文是由ContextLoaderListener创建的。</p>
<p>DispatcherServlet加载包含Web组件的bean,如控制器、视图解析器以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。 这些bean通常是驱动应用后端的中间层和数据层组件。</p>
<h3 id="启用Spring-MVC"><a href="#启用Spring-MVC" class="headerlink" title="启用Spring MVC"></a>启用Spring MVC</h3><p>传统是使用xml，也可以通过config来配置。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.15.35.png" alt=""></p>
<h2 id="编写基本的控制器"><a href="#编写基本的控制器" class="headerlink" title="编写基本的控制器"></a>编写基本的控制器</h2><p><strong>@Controller</strong>注解与<strong>@Component</strong>注解实现的效果是一样的，表意性会强一些。</p>
<p>@RequestMapping的属性能够接受一个String类型的数组。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.26.39.png" alt=""></p>
<h3 id="传递模型数据到视图中"><a href="#传递模型数据到视图中" class="headerlink" title="传递模型数据到视图中"></a>传递模型数据到视图中</h3><p><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.31.10.png" alt=""><br>将Repository注入Controller。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.34.25.png" alt=""><br>Model作为参数，方法就能将从Repository中获取的东西填充到模型中。Model实际上就是一个Map，它会传递给视图，这样数据就能渲染到客户端了。当调用addAttribute方法不指定key时，key会根据值的对象类型推断确定。如果希望使用非Spring类型，可以用Map来替代Model。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.42.28.png" alt=""><br>在返回时统统返回的是jsp的名称。</p>
<p>JSP访问模型：当视图是JSP时，模型数据会作为请求属性放到请求(request)中，所以可以在jsp文件中使用JSTL的<c :="" foreach="">标签来渲染列表。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.19.43.png" alt=""></c></p>
<h2 id="接受请求的输入"><a href="#接受请求的输入" class="headerlink" title="接受请求的输入"></a>接受请求的输入</h2><p>Spring MVC允许多种方式将客户端的数据传送到控制器的处理器方法中，包括：</p>
<ol>
<li>查询参数(Query Parameter )</li>
<li>表单参数( Form Parameter )</li>
<li>路径变量(Path Variable )</li>
</ol>
<h3 id="处理查询参数"><a href="#处理查询参数" class="headerlink" title="处理查询参数"></a>处理查询参数</h3><p><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.26.10.png" alt=""><br>客户端发的请求形如：<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.27.09.png" alt=""></p>
<h3 id="通过路径参数接受输入"><a href="#通过路径参数接受输入" class="headerlink" title="通过路径参数接受输入"></a>通过路径参数接受输入</h3><p>带有参数的请求尽管可以正常工作，但是从面向资源的角度来看并不理想。<br>理想情况下，要识别的资源应该通过URL路径进行标示，而不是通过查询参数。对“spittles/ 12345”发起 GET 请求要优于对“ / spittles / show?spitte_id=12345”发起请求。前者能够识别出要查询的资源，而后者描述的是带有参数的一个操作，本质上是通过HTTP发起的RPC。</p>
<p>为了实现路径变量，Spring MVC允许在@RequestMapping路径中添加占位符。占位符的名称要用大括号(“{”和“}”)括起来。路径中的其他部分要与所处理的请求完全匹配，但是占位符部分可以是任意的值。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.36.50.png" alt=""><br>spittle ()方法会将参数传递到SpittleRepository的findOone ()方法中，用来获取某个Spittle对象,然后将Spittle对象添加到模型中。模型的key将会是spittle,这是根据传递到addAttribute ()方法中的类型推断得到的。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%888.18.00.png" alt=""><br>如果传递请求中少量的数据，那查询参数和路径变量是很合适的。通常还需要传递很多的数据(也许是表单提交的数据)，查询参数显得有些笨拙和受限了。可以编写控制器方法来处理表单提交。</p>
<h2 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h2><p>Spring MVC控制器为表单处理提供了良好的支持。使用表单分为两个方面:<strong>展现表单以及处理用户通过表单提交的数据。</strong></p>
<h3 id="编写处理表单的控制器"><a href="#编写处理表单的控制器" class="headerlink" title="编写处理表单的控制器"></a>编写处理表单的控制器</h3><p><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%888.48.01.png" alt=""><br>当InternalResourceViewResolver看到视图格式中的“redirect:” 前缀时，就知道要将其解析为重定向的规则，而不是视图的名称。在本例中，它将会重定向到用户基本信息的页面。例如，如果Spitter .username属性的值为“jbauer”, 那么视图将会重定向到“ / spitter / jbauer”.<br>除了“redirect:”, InternalResourceViewResolver 还能识别“forward:” 前缀。当它发现视图格式中以“forward:” 作为前缀时，请求将会前往(forward) 指定的URL路径，而不再是重定向。</p>
<h3 id="校验表单"><a href="#校验表单" class="headerlink" title="校验表单"></a>校验表单</h3><p>与其让校验逻辑弄乱处理器方法，还不如使用Spring对Java校验API 的支持。从Spring 3.0开始，在Spring MVC中提供了对Java校验API的支持。在Spring MVC中要使用Java校验API的话，并不需要什么额外的配置。只要保证在类路径下包含这个Java API的实现，比如Hibernate Validator。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.01.41.png" alt=""><br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.04.26.png" alt=""><br><strong>@Valid</strong>注解，告知Spring，需要确保这个对象满足校验限制。<br>如果没有错误的话，Spitter 对象将会通过Repository 进行保存，控制器会像之前那样重定向到基本信息页面。</p>
<h1 id="渲染Web视图"><a href="#渲染Web视图" class="headerlink" title="渲染Web视图"></a>渲染Web视图</h1><h2 id="理解视图解析"><a href="#理解视图解析" class="headerlink" title="理解视图解析"></a>理解视图解析</h2><p>编写的控制器方法都没有直接产生浏览器中渲染所需的HTML。这些方法只是将一些数据填充到模型中，然后将模型传递给一个用来渲染的视图。这些方法会返回一个String类型的值，这个值是视图的逻辑名称，不会直接引用具体的视图实现。尽管我编写了几个简单的JavaServer Page (JSP) 视图，但是控制器并不关心这些。</p>
<p>将控制器中请求处理的逻辑和视图中的渲染实现解耦是Spring MVC的一个重要特性。控制器只通过逻辑视图名来了解视图，Spring视图解析器来确定使用哪一个视图实现来渲染模型。</p>
<p>Spring MVC定义了一一个名为ViewResolver的接口，<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.18.37.png" alt=""><br>当给resolveViewName(方法传入一个视图名和Locale对象时，它会返回一个View实例。View 是另外一个接口。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.20.10.png" alt=""><br>View接口的任务就是接受模型以及Servlet 的request 和response对象，并将输出结果渲染到response中。<br>其中<strong>InternalResourceViewResolver</strong>只是<strong>ViewResolver</strong>的实现之一，将视图解析为Web应用的内部资源(一般为JSP)。JSP曾经是，而且现在依然还是Java领域占主导地位的视图技术。</p>
<h2 id="创建JSP视图"><a href="#创建JSP视图" class="headerlink" title="创建JSP视图"></a>创建JSP视图</h2><p>Spring 提供了两种支持JSP视图的方式:<br>1.<strong>InternalResourceViewResolver</strong>会将视图名解析为JSP文件。另外，如果在JSP页面中使用了JSP 标准标签库( JSTL)的话，InternalResourceViewResolver 能够将视图名解析为JstIView形式的JSP文件，从而将JSTL本地化和资源bundle变量暴露给JSTL的格式化(formatting)和信息( message)标签。<br>2.Spring提供了两个JSP标签库，一个用于表单到模型的绑定，另一个提供了通用的工具类特性。</p>
<h3 id="配置适用于JSP的视图解析器"><a href="#配置适用于JSP的视图解析器" class="headerlink" title="配置适用于JSP的视图解析器"></a>配置适用于JSP的视图解析器</h3><p>InternalResourceViewResolver所采取的方式并不那么直接。它遵循一种约定，会在视图名上添加前缀和后缀,进而确定一个 Web应用中视图资源的物理路径。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.42.30.png" alt=""></p>
<h3 id="解析JSTL视图"><a href="#解析JSTL视图" class="headerlink" title="解析JSTL视图"></a>解析JSTL视图</h3><p>如果想让InternalResourceViewResolver将视图解析为JstlView,而不是InternalResourceView的话，只需设置viewClass属性即可:<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.49.23.png" alt=""><br>XML中：<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.49.39.png" alt=""><br>JSTL的格式化标签需要- -个 Locale对象，以便于恰当地格式化地域相关的值，如日期和货币。信息标签可以借助Spring的信息资源和Locale,从而选择适当的信息渲染到HTML之中。通过解析JstlView, JSTL能够获得Locale对象以及Spring中配置的信息资源。</p>
<p>不管使用Java配置还是使用XML,都能确保JSTL的格式化和信息标签能够获得Locale对象以及Spring中配置的信息资源。</p>
<h3 id="使用Spring的JSP库"><a href="#使用Spring的JSP库" class="headerlink" title="使用Spring的JSP库"></a>使用Spring的JSP库</h3><p>当为JSP添加功能时，标签库是一种很强大的方式，能够避免在脚本块中直接编写Java代码。Spring 提供了两个JSP标签库，用来帮助定义Spring MVC Web的视图。<br>其中一个标签库会用来渲染HTML表单标签，这些标签可以绑定model中的某个属性。<br>另外一个标签库包含了一些工具类标签，随时都可以非常便利地使用它们。</p>
<h4 id="将表单绑定到模型上"><a href="#将表单绑定到模型上" class="headerlink" title="将表单绑定到模型上"></a>将表单绑定到模型上</h4><p>Spring的表单绑定JSP标签库包含了14个标签,它们中的大多数都用来渲染HTML中的表单标签。但是，与原生HTML标签的区别在于会绑定模型中的一一个对象,能够根据模型中对象的属性填充值。标签库中还包含了一个为用户展现错误的标签，会将错误信息渲染到最终的HTML之中。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%8810.08.52.png" alt=""><br><a href="sf:form" target="_blank" rel="noopener">sf:form</a>会渲染会一个HTML <form>标签，但也会通过commandName属性构建针对某个模型对象的上下文信息。在其他的表单绑定标签中，会引用这个模型对象的属性。模型中必须要有一个key为spitter的对象，否则，表单不能正常渲染（会出现JSP错误）。<br>如果在模型中Spitter对象的firstName属性值为Jack,那么&lt;sf:input  path=“firstName”/&gt; 所渲染的<input>标签中，会存在value=“Jack”。</form></p>
<h4 id="展现错误"><a href="#展现错误" class="headerlink" title="展现错误"></a>展现错误</h4><p>如果存在校验错误的话，请求中会包含错误的详细信息，这些信息是与模型数据放到一起的。所需要做的就是到模型中将这些数据抽取出来，并展现给用户。<a href="sf:errors" target="_blank" rel="noopener">sf:errors</a>能够让这项任务变得很简单。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%8810.14.11.png" alt=""></p>
<h3 id="Spring通用的标签库"><a href="#Spring通用的标签库" class="headerlink" title="Spring通用的标签库"></a>Spring通用的标签库</h3><h4 id="展现国际化"><a href="#展现国际化" class="headerlink" title="展现国际化"></a>展现国际化</h4><h2 id="使用Thymeleaf"><a href="#使用Thymeleaf" class="headerlink" title="使用Thymeleaf"></a>使用Thymeleaf</h2><p>JSP存在一些缺陷，大多数的JSP模板都是采用HTML的形式，但是又掺杂上了各种JSP标签库的标签，使其变得很混乱。这些标签库能够以便利的方式为JSP带来动态渲染的强大功能，但是也摧毁了维持一个格式良好的文档的可能性。</p>
<p>同时，JSP规范是与Servlet 规范紧密耦合的。这意味着它只能用在基于Servlet 的Web应用之中。JSP 模板不能作为通用的模板(如格式化Email),也不能用于非Servlet的Web应用。</p>
<p>Thymeleaf模板是原生的，不依赖于标签库。能在接受原始HTML的地方进行编辑和渲染。因为没有与Servlet规范耦合,因此Thymeleaf模板能够进人JSP所无法涉足的领域。</p>
<h3 id="配置Thymeleaf视图解析器"><a href="#配置Thymeleaf视图解析器" class="headerlink" title="配置Thymeleaf视图解析器"></a>配置Thymeleaf视图解析器</h3><p>为了要在Spring中使用Thymeleaf,我们需要配置三个启用Thymeleaf与Spring集成的bean:<br><strong>ThymeleafViewResolver</strong>:将逻辑视图名称解析为Thymeleaf模板视图;<br><strong>SpringTemplateEngine</strong>:处理模板并渲染结果;<br><strong>TemplateResolver</strong>:加载Thymeleaf模板。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%8811.04.29.png" alt=""><br>不管使用哪种配置方式，Thymeleaf 都可以将响应中的模板渲染到Spring MVC控制器所处理的请求中。</p>
<p><strong>ThymeleafViewResolver</strong>是Spring MVC中ViewResolver的一个实现类。像其他的视图解析器一样， 会接受一个逻辑视图名称,并将其解析为视图。不过在该场景下，视图会是一个Thymeleaf模板。<br>其中<strong>ThymeleafViewResolver</strong>中注入了一个对<strong>SpringTemplateEngine</strong>的引用。SpringTemplateEngine会在Spring中启用Thymeleaf引擎，用来解析模板，并基于这些模板渲染结果。对其注入一个<strong>TemplateResolver</strong> 的引用。<br><strong>TemplateResolver</strong>会最终定位和查找模板。与之前配置InternalResourceViewResolver类似，使用了prefix和suffix属性。前缀和后缀将会与逻辑视图名组合使用,进而定位Thymeleaf引擎。它的templateMode属性被设置成了HTML5，这表明预期要解析的模板会渲染成HTML5输出。</p>
<h3 id="定义Thymeleaf模板"><a href="#定义Thymeleaf模板" class="headerlink" title="定义Thymeleaf模板"></a>定义Thymeleaf模板</h3><p>Thymeleaf在很大程度上就是HTML文件，与JSP不同，没有什么特殊的标签或标签库。Thymeleaf 之所以能够发挥作用，是因为通过自定义的命名空间，为标准的HTML标签集合添加Thymeleaf属性。<br><img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8B%E5%8D%881.56.31.png" alt=""></p>
<h4 id="借助Thymeleaf实现表单绑定"><a href="#借助Thymeleaf实现表单绑定" class="headerlink" title="借助Thymeleaf实现表单绑定"></a>借助Thymeleaf实现表单绑定</h4>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/06/14/图/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/14/图/" class="post-title-link" itemprop="url">图</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-14 21:03:47 / 修改时间：21:03:56" itemprop="dateCreated datePublished" datetime="2019-06-14T21:03:47+08:00">2019-06-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/14/图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/14/图/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/06/14/图/" class="post-meta-item leancloud_visitors" data-flag-title="图">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p><img src="/img/media/%E5%9B%BE/df85dc345a9726cab0338e68982fd1af.jpg" alt=""><br><strong>无向图</strong>，两者之间建立一条边，称为顶点的<strong>度</strong>。就是跟顶点相连接的边的条数。</p>
<hr>
<p><img src="/img/media/%E5%9B%BE/c31759a37d8a8719841f347bd479b796.jpg" alt=""><br><strong>有向图</strong>，在有向图中把度分为<strong>入度</strong>和<strong>出度</strong>。</p>
<hr>
<p><img src="/img/media/%E5%9B%BE/55d7e4806dc47950ae098d959b03ace8.jpg" alt=""><br><strong>带权图</strong>，每条边都有一个权重。</p>
<h1 id="图的存储方法"><a href="#图的存储方法" class="headerlink" title="图的存储方法"></a>图的存储方法</h1><h2 id="邻接矩阵存储法"><a href="#邻接矩阵存储法" class="headerlink" title="邻接矩阵存储法"></a>邻接矩阵存储法</h2><p>图最直观的存储方法就是<strong>邻接矩阵</strong>。<br><img src="/img/media/%E5%9B%BE/625e7493b5470e774b5aa91fb4fdb9d2.jpg" alt=""><br>用邻接表来表示一个图虽然简单直观，比较浪费存储空间。如果存储的是<strong>稀疏图</strong>，就更加浪费空间了。</p>
<p>邻接矩阵的优点在于简单直接，在获取两个顶点关系时非常高效，其次还方便计算。</p>
<h2 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h2><p><img src="/img/media/%E5%9B%BE/039bc254b97bd11670cdc4bf2a8e1394.jpg" alt=""><br>邻接表存储起来比较节省空间，使用起来比较耗时间。</p>
<p>如果链过长，为了提高查找效率，可以将链表换成其他更加高效的数据结构，比如红黑树。也可以使用其他动态数据结构比如跳表和散列表。</p>
<h2 id="存储微博关系"><a href="#存储微博关系" class="headerlink" title="存储微博关系"></a>存储微博关系</h2><p><img src="/img/media/%E5%9B%BE/501440bcffdcf4e6f9a5ca1117e990a1.jpg" alt=""><br>邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。</p>
<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><p><img src="/img/media/%E5%9B%BE/002e9e54fb0d4dbf5462226d946fa1ea.jpg" alt=""><br>借助<strong>队列</strong>。<br><img src="/img/media/%E5%9B%BE/4cd192d4c220cc9ac8049fd3547dba39.jpg" alt=""><br>广度优先搜索的时间复杂度是<strong>O(V+E)</strong>,<strong>V</strong>表示顶点的个数，<strong>E</strong>表示边的个数。</p>
<p>广度优先搜索的控件消耗主要在几个辅助变量visited数组、queue队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数。所以空间复杂度是O(V)。</p>
<h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p><img src="/img/media/%E5%9B%BE/8778201ce6ff7037c0b3f26b83efba85.jpg" alt=""><br>借助<strong>栈</strong>。</p>
<p>深度优先搜索算法的时间复杂度是<strong>O(E)</strong>,E表示边的个数。</p>
<p>深度优先搜索算法的消耗内存主要是visited、 prev 数组和递归调用栈。visited、 prev 数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是<strong>O(V)</strong>。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="ZDK"/>
            
              <p class="site-author-name" itemprop="name">ZDK</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">191</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zdkswd" title="GitHub &rarr; https://github.com/zdkswd"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:2822464407@qq.com" title="E-Mail &rarr; mailto:2822464407@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/zdkswd" title="https://github.com/zdkswd">Title</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </div>

      

      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZDK</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  
  

<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz',
    appKey: 'gkBx5soQkBREmER84PWbNJeM',
    placeholder: 'have fun',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('5');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
