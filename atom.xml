<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2019-06-24T11:31:19.117Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis基础</title>
    <link href="https://github.com/zdkswd/2019/06/24/MyBatis%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/zdkswd/2019/06/24/MyBatis基础/</id>
    <published>2019-06-24T11:30:47.000Z</published>
    <updated>2019-06-24T11:31:19.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MyBatis可以使用XML或注解进行配置和映射，MyBatis通过将参数映射到配置的SQL形成最终执行的SQL语句，最后将执行SQL的结果映射成Java对象返回。与其他的ORM (对象关系映射)框架不同，MyBatis 并没有将Java对象与数据库表关联起来，而是将Java方法与SQL语句关联。</p><p>在实际应用中，一个表一般会对应一个实体，用于INSERT、UPDATE、DELETE 和简单的SELECT操作，所以姑且称这个简单的对象为实体类。</p><h1 id="XML方式的基本用法"><a href="#XML方式的基本用法" class="headerlink" title="XML方式的基本用法"></a>XML方式的基本用法</h1><h2 id="一个简单的权限控制需求"><a href="#一个简单的权限控制需求" class="headerlink" title="一个简单的权限控制需求"></a>一个简单的权限控制需求</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.37.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了方便对表进行直接操作，此处没有创建表之间的外键关系。对于表之间的关系，会通过业务逻辑来进行限制。</p><p>创建表和创建实体类。<br><strong>特别注意，由于Java中的基本类型会有默认值，会导致很多隐藏的问题。所以在实体类中不要使用基本类型，基本类型包括byte,int,short,long,float,double,char,boolean。</strong></p><h2 id="使用XML方式"><a href="#使用XML方式" class="headerlink" title="使用XML方式"></a>使用XML方式</h2><p>创建数据表对应的XML文件，并创建对应的接口类。<br>将xml文件与对应的接口类产生联系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.55.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将创建的mybatis-config.xml配置文件中的mappers元素中配置所有的mapper。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.56.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以进行更简单的配置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%881.58.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种配置方式会先查找tk. mybatis.simple . mapper包下所有的接口,循环对接口进行如下操作：<br>1.判断接口对应的命名空间是否已经存在，如果存在就抛出异常，不存在就继续进行接下来的操作。<br>2.加载接口对应的XML映射文件，将接口全限定名转换为路径，例如，将接口tk .mybatis. simple . mapper . UserMapper转换为tk/ mybatis/ simple/ mapper/ UserMapper.xml, 以.xml为后缀搜索XML资源，如果找到就解析XML。<br>3.处理接口中的注解方法。</p><h2 id="select用法"><a href="#select用法" class="headerlink" title="select用法"></a>select用法</h2><p>在接口中添加一个selectById方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.52.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用MyBatis时，只需要在XML中添加一个select元素，写一个SQL,做一些简单的配置，就可以将查询的结果直接映射到对象中。<br>在xml中添加代码：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.17.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XML中的select标签的id属性值和定义的接口方法名是一样的。MyBatis就是通过这种方式将接口方法和XML中定义的SQL语句关联到一起的，如果接口方法没有和XML中的id属性值相对应，启动程序便会报错。</p><p>jdbcType:列对应的数据库类型。JDBC 类型仅仅需要对插入、更新、删除操作可能为空的列进行处理。这是JDBC jdbcType的需要，而不是MyBatis的需要。</p><p><strong>自动映射</strong>，使用resultType来设置返回结果的类型，需要在SQL中为所有列名和属性名不一致的列设置别名，通过设置别名使最终的查询结果列和resultType指定对象的属性名保持一致。</p><hr><p><strong>名称映射规则</strong><br>property属性或别名要和对象中属性的名字相同，但是实际匹配时，MyBatis会先将两者都转换为大写形式， 然后再判断是否相同，即property=“userName” 和property=“username” 都可以匹配到对象的userName属性上。判断是否相同的时候要使用USERNAME,因此在设置property属性或别名的时候，不需要考虑大小写是否一致，但是为了便于阅读，要尽可能按照统一的规则来设置。</p><hr><p>MyBatis还提供了一个全局属性<strong>mapUnderscoreToCamelCase</strong>,通过配置这个属性为true可以自动将以下划线方式命名的数据库列映射到Java对象的驼峰式命名属性中。这个属性默认为false。需要在MyBatis配置文件中启用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.39.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>考虑性能，通常都会指定查询列，很少使用星号代替所有列。</p><p>多表查询中，方法写在任何一个对应的Mapper接口中都可以。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%882.45.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="insert用法"><a href="#insert用法" class="headerlink" title="insert用法"></a>insert用法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%885.59.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.02.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>返回的int值是指执行的SQL影响的行数。</p><h3 id="使用JDBC方式返回主键自增的值"><a href="#使用JDBC方式返回主键自增的值" class="headerlink" title="使用JDBC方式返回主键自增的值"></a>使用JDBC方式返回主键自增的值</h3><p>在xml的标签中配置属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.23.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>useGeneratedKeys设置为true后, MyBatis会使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键。获得主键值后将其赋值给keyProperty配置的id属性。SQL上下两部分的列中去掉了id列和对应的#{ id }属性。</p><h3 id="使用selectKey返回主键的值"><a href="#使用selectKey返回主键的值" class="headerlink" title="使用selectKey返回主键的值"></a>使用selectKey返回主键的值</h3><p>该方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.37.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多个接口参数的用法"><a href="#多个接口参数的用法" class="headerlink" title="多个接口参数的用法"></a>多个接口参数的用法</h2><p>当参数是一个基本类型的时候，它在XML文件中对应的SQL语句只会使用一个参数，例如delete方法。当参数是一个JavaBean类型的时候，它在XML文件中对应的SQL语句会有多个参数，例如insert、update 方法。但并不适合全部的情况，因为不能只为了两三个参数去创建新的JavaBean，参数较少时还可以采用Map类型作为参数或使用@Param注解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%886.48.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>给参数配置@Param注解后，MyBatis 就会自动将参数封装成Map类型，@Param 注解值会作为Map中的key,因此在SQL部分就可以通过配置的注解值来使用参数。</p><p>当只有一一个参数(基本类型或拥有TypeHandler配置的类型)的时候，在这种情况下(除集合和数组外)，MyBatis不关心这个参数叫什么名字就会直接把这个唯一的参数值拿来使用。</p><h2 id="Mapper接口动态代理实现原理"><a href="#Mapper接口动态代理实现原理" class="headerlink" title="Mapper接口动态代理实现原理"></a>Mapper接口动态代理实现原理</h2><p>可以通过动态代理这个桥梁将对接口方法的调用转换为对其他方法的调用。</p><h1 id="MyBatis注解"><a href="#MyBatis注解" class="headerlink" title="MyBatis注解"></a>MyBatis注解</h1><p>MyBatis注解方式就是将SQL语句直接写在接口上。这种方式的优点是，对于需求比较简单的系统，效率较高。缺点是，当SQL有变化时都需要重新编译代码，一”般情况下不建议使用注解方式。</p><h2 id="Select注解"><a href="#Select注解" class="headerlink" title="@Select注解"></a>@Select注解</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.04.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Spring集成MyBatis"><a href="#Spring集成MyBatis" class="headerlink" title="Spring集成MyBatis"></a>Spring集成MyBatis</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.09.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.14.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p><strong>配置SqlSessionFactoryBean</strong><br>在MyBatis. Spring中,SqlSessionFactoryBean是用于创建SqlSessionFactory的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.17.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><p><strong>配置MapperScannerConfigurer</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/MyBatis%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-24%20%E4%B8%8B%E5%8D%887.19.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;MyBatis可以使用XML或注解进行配置和映射，MyBatis通过将参数映射到配置的SQL形成最终执行的SQL语句，最后将执行SQL的结果
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
      <category term="MyBatis" scheme="https://github.com/zdkswd/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC</title>
    <link href="https://github.com/zdkswd/2019/06/21/Spring%20MVC/"/>
    <id>https://github.com/zdkswd/2019/06/21/Spring MVC/</id>
    <published>2019-06-21T06:10:47.000Z</published>
    <updated>2019-06-21T06:12:04.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC起步"><a href="#Spring-MVC起步" class="headerlink" title="Spring MVC起步"></a>Spring MVC起步</h1><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%889.21.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在请求离开浏览器时，1️⃣：会带有用户所请求内容信息，至少会包含请求的URL。还可能带有其他的信息，例如用户提交的表单信息。</p><p>单实例Servlet ，DispatcherServlet将请求委托给应用程序的其他组件来执行实际处理。通过所携带的URL来进行决策。</p><p>控制器返回时仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。</p><h2 id="搭建Spring-MVC"><a href="#搭建Spring-MVC" class="headerlink" title="搭建Spring MVC"></a>搭建Spring MVC</h2><h3 id="配置DispatcherServlet"><a href="#配置DispatcherServlet" class="headerlink" title="配置DispatcherServlet"></a>配置DispatcherServlet</h3><p>传统方式，DispatcherServlet这样的Servlet会配置在web.xml中。但不是唯一的方法。扩展AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动配置DispatcherServlet和Spring应用上下文。Spring的应用上下文会位于应用程序的Servlet上下文之中。即为dispatchservlet.xml。</p><p>在 Servlet3环境中,容器会在类路径中查找实现 javax. servlet.ServletcontainerInitializer接口的类,如果能发现的话,就会用来配置 Servlet容器。Spring提供了这个接口的实现,名为SpringServletcontainerInitializer,这个类反过来又会查找实现 WebApplicationInitializer的类并将配置的任务交给它们来完成。 Spring3.2引入了一个便利的 WebApplicationInitializer基础实现,也就是AbstractAnnotationconfigDispatcherservletInitializer。当扩展了AbstractAnnotationconfigDispatcherServletinitializer，同时也就实现了 WebApplicationInitializer,因此当部署到 Servlet容器中的时候,容器会自动发现它,并用它来配置 Servlet上下文。</p><h3 id="两个应用上下文的联系"><a href="#两个应用上下文的联系" class="headerlink" title="两个应用上下文的联系"></a>两个应用上下文的联系</h3><p>当DispatcherServlet启动的时候，它会创建Spring应用上下文，并加载配置文件或配置类中所声明的bean。</p><p>在Spring Web应用中，通常还会有另外一个应用上下文。另外的这个应用上下文是由ContextLoaderListener创建的。</p><p>DispatcherServlet加载包含Web组件的bean,如控制器、视图解析器以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。 这些bean通常是驱动应用后端的中间层和数据层组件。</p><h3 id="启用Spring-MVC"><a href="#启用Spring-MVC" class="headerlink" title="启用Spring MVC"></a>启用Spring MVC</h3><p>传统是使用xml，也可以通过config来配置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.15.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="编写基本的控制器"><a href="#编写基本的控制器" class="headerlink" title="编写基本的控制器"></a>编写基本的控制器</h2><p><strong>@Controller</strong>注解与<strong>@Component</strong>注解实现的效果是一样的，表意性会强一些。</p><p>@RequestMapping的属性能够接受一个String类型的数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.26.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="传递模型数据到视图中"><a href="#传递模型数据到视图中" class="headerlink" title="传递模型数据到视图中"></a>传递模型数据到视图中</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.31.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将Repository注入Controller。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.34.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Model作为参数，方法就能将从Repository中获取的东西填充到模型中。Model实际上就是一个Map，它会传递给视图，这样数据就能渲染到客户端了。当调用addAttribute方法不指定key时，key会根据值的对象类型推断确定。如果希望使用非Spring类型，可以用Map来替代Model。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8A%E5%8D%8810.42.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在返回时统统返回的是jsp的名称。</p><p>JSP访问模型：当视图是JSP时，模型数据会作为请求属性放到请求(request)中，所以可以在jsp文件中使用JSTL的<c :="" foreach="">标签来渲染列表。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.19.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></c></p><h2 id="接受请求的输入"><a href="#接受请求的输入" class="headerlink" title="接受请求的输入"></a>接受请求的输入</h2><p>Spring MVC允许多种方式将客户端的数据传送到控制器的处理器方法中，包括：</p><ol><li>查询参数(Query Parameter )</li><li>表单参数( Form Parameter )</li><li>路径变量(Path Variable )</li></ol><h3 id="处理查询参数"><a href="#处理查询参数" class="headerlink" title="处理查询参数"></a>处理查询参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.26.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>客户端发的请求形如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.27.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="通过路径参数接受输入"><a href="#通过路径参数接受输入" class="headerlink" title="通过路径参数接受输入"></a>通过路径参数接受输入</h3><p>带有参数的请求尽管可以正常工作，但是从面向资源的角度来看并不理想。<br>理想情况下，要识别的资源应该通过URL路径进行标示，而不是通过查询参数。对“spittles/ 12345”发起 GET 请求要优于对“ / spittles / show?spitte_id=12345”发起请求。前者能够识别出要查询的资源，而后者描述的是带有参数的一个操作，本质上是通过HTTP发起的RPC。</p><p>为了实现路径变量，Spring MVC允许在@RequestMapping路径中添加占位符。占位符的名称要用大括号(“{”和“}”)括起来。路径中的其他部分要与所处理的请求完全匹配，但是占位符部分可以是任意的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-19%20%E4%B8%8B%E5%8D%882.36.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>spittle ()方法会将参数传递到SpittleRepository的findOone ()方法中，用来获取某个Spittle对象,然后将Spittle对象添加到模型中。模型的key将会是spittle,这是根据传递到addAttribute ()方法中的类型推断得到的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%888.18.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果传递请求中少量的数据，那查询参数和路径变量是很合适的。通常还需要传递很多的数据(也许是表单提交的数据)，查询参数显得有些笨拙和受限了。可以编写控制器方法来处理表单提交。</p><h2 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h2><p>Spring MVC控制器为表单处理提供了良好的支持。使用表单分为两个方面:<strong>展现表单以及处理用户通过表单提交的数据。</strong></p><h3 id="编写处理表单的控制器"><a href="#编写处理表单的控制器" class="headerlink" title="编写处理表单的控制器"></a>编写处理表单的控制器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%888.48.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当InternalResourceViewResolver看到视图格式中的“redirect:” 前缀时，就知道要将其解析为重定向的规则，而不是视图的名称。在本例中，它将会重定向到用户基本信息的页面。例如，如果Spitter .username属性的值为“jbauer”, 那么视图将会重定向到“ / spitter / jbauer”.<br>除了“redirect:”, InternalResourceViewResolver 还能识别“forward:” 前缀。当它发现视图格式中以“forward:” 作为前缀时，请求将会前往(forward) 指定的URL路径，而不再是重定向。</p><h3 id="校验表单"><a href="#校验表单" class="headerlink" title="校验表单"></a>校验表单</h3><p>与其让校验逻辑弄乱处理器方法，还不如使用Spring对Java校验API 的支持。从Spring 3.0开始，在Spring MVC中提供了对Java校验API的支持。在Spring MVC中要使用Java校验API的话，并不需要什么额外的配置。只要保证在类路径下包含这个Java API的实现，比如Hibernate Validator。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.01.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.04.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Valid</strong>注解，告知Spring，需要确保这个对象满足校验限制。<br>如果没有错误的话，Spitter 对象将会通过Repository 进行保存，控制器会像之前那样重定向到基本信息页面。</p><h1 id="渲染Web视图"><a href="#渲染Web视图" class="headerlink" title="渲染Web视图"></a>渲染Web视图</h1><h2 id="理解视图解析"><a href="#理解视图解析" class="headerlink" title="理解视图解析"></a>理解视图解析</h2><p>编写的控制器方法都没有直接产生浏览器中渲染所需的HTML。这些方法只是将一些数据填充到模型中，然后将模型传递给一个用来渲染的视图。这些方法会返回一个String类型的值，这个值是视图的逻辑名称，不会直接引用具体的视图实现。尽管我编写了几个简单的JavaServer Page (JSP) 视图，但是控制器并不关心这些。</p><p>将控制器中请求处理的逻辑和视图中的渲染实现解耦是Spring MVC的一个重要特性。控制器只通过逻辑视图名来了解视图，Spring视图解析器来确定使用哪一个视图实现来渲染模型。</p><p>Spring MVC定义了一一个名为ViewResolver的接口，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.18.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当给resolveViewName(方法传入一个视图名和Locale对象时，它会返回一个View实例。View 是另外一个接口。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.20.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>View接口的任务就是接受模型以及Servlet 的request 和response对象，并将输出结果渲染到response中。<br>其中<strong>InternalResourceViewResolver</strong>只是<strong>ViewResolver</strong>的实现之一，将视图解析为Web应用的内部资源(一般为JSP)。JSP曾经是，而且现在依然还是Java领域占主导地位的视图技术。</p><h2 id="创建JSP视图"><a href="#创建JSP视图" class="headerlink" title="创建JSP视图"></a>创建JSP视图</h2><p>Spring 提供了两种支持JSP视图的方式:<br>1.<strong>InternalResourceViewResolver</strong>会将视图名解析为JSP文件。另外，如果在JSP页面中使用了JSP 标准标签库( JSTL)的话，InternalResourceViewResolver 能够将视图名解析为JstIView形式的JSP文件，从而将JSTL本地化和资源bundle变量暴露给JSTL的格式化(formatting)和信息( message)标签。<br>2.Spring提供了两个JSP标签库，一个用于表单到模型的绑定，另一个提供了通用的工具类特性。</p><h3 id="配置适用于JSP的视图解析器"><a href="#配置适用于JSP的视图解析器" class="headerlink" title="配置适用于JSP的视图解析器"></a>配置适用于JSP的视图解析器</h3><p>InternalResourceViewResolver所采取的方式并不那么直接。它遵循一种约定，会在视图名上添加前缀和后缀,进而确定一个 Web应用中视图资源的物理路径。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.42.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="解析JSTL视图"><a href="#解析JSTL视图" class="headerlink" title="解析JSTL视图"></a>解析JSTL视图</h3><p>如果想让InternalResourceViewResolver将视图解析为JstlView,而不是InternalResourceView的话，只需设置viewClass属性即可:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.49.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XML中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%889.49.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>JSTL的格式化标签需要- -个 Locale对象，以便于恰当地格式化地域相关的值，如日期和货币。信息标签可以借助Spring的信息资源和Locale,从而选择适当的信息渲染到HTML之中。通过解析JstlView, JSTL能够获得Locale对象以及Spring中配置的信息资源。</p><p>不管使用Java配置还是使用XML,都能确保JSTL的格式化和信息标签能够获得Locale对象以及Spring中配置的信息资源。</p><h3 id="使用Spring的JSP库"><a href="#使用Spring的JSP库" class="headerlink" title="使用Spring的JSP库"></a>使用Spring的JSP库</h3><p>当为JSP添加功能时，标签库是一种很强大的方式，能够避免在脚本块中直接编写Java代码。Spring 提供了两个JSP标签库，用来帮助定义Spring MVC Web的视图。<br>其中一个标签库会用来渲染HTML表单标签，这些标签可以绑定model中的某个属性。<br>另外一个标签库包含了一些工具类标签，随时都可以非常便利地使用它们。</p><h4 id="将表单绑定到模型上"><a href="#将表单绑定到模型上" class="headerlink" title="将表单绑定到模型上"></a>将表单绑定到模型上</h4><p>Spring的表单绑定JSP标签库包含了14个标签,它们中的大多数都用来渲染HTML中的表单标签。但是，与原生HTML标签的区别在于会绑定模型中的一一个对象,能够根据模型中对象的属性填充值。标签库中还包含了一个为用户展现错误的标签，会将错误信息渲染到最终的HTML之中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%8810.08.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><a href="sf:form" target="_blank" rel="noopener">sf:form</a>会渲染会一个HTML <form>标签，但也会通过commandName属性构建针对某个模型对象的上下文信息。在其他的表单绑定标签中，会引用这个模型对象的属性。模型中必须要有一个key为spitter的对象，否则，表单不能正常渲染（会出现JSP错误）。<br>如果在模型中Spitter对象的firstName属性值为Jack,那么&lt;sf:input  path=“firstName”/&gt; 所渲染的<input>标签中，会存在value=“Jack”。</form></p><h4 id="展现错误"><a href="#展现错误" class="headerlink" title="展现错误"></a>展现错误</h4><p>如果存在校验错误的话，请求中会包含错误的详细信息，这些信息是与模型数据放到一起的。所需要做的就是到模型中将这些数据抽取出来，并展现给用户。<a href="sf:errors" target="_blank" rel="noopener">sf:errors</a>能够让这项任务变得很简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%8810.14.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Spring通用的标签库"><a href="#Spring通用的标签库" class="headerlink" title="Spring通用的标签库"></a>Spring通用的标签库</h3><h4 id="展现国际化"><a href="#展现国际化" class="headerlink" title="展现国际化"></a>展现国际化</h4><h2 id="使用Thymeleaf"><a href="#使用Thymeleaf" class="headerlink" title="使用Thymeleaf"></a>使用Thymeleaf</h2><p>JSP存在一些缺陷，大多数的JSP模板都是采用HTML的形式，但是又掺杂上了各种JSP标签库的标签，使其变得很混乱。这些标签库能够以便利的方式为JSP带来动态渲染的强大功能，但是也摧毁了维持一个格式良好的文档的可能性。</p><p>同时，JSP规范是与Servlet 规范紧密耦合的。这意味着它只能用在基于Servlet 的Web应用之中。JSP 模板不能作为通用的模板(如格式化Email),也不能用于非Servlet的Web应用。</p><p>Thymeleaf模板是原生的，不依赖于标签库。能在接受原始HTML的地方进行编辑和渲染。因为没有与Servlet规范耦合,因此Thymeleaf模板能够进人JSP所无法涉足的领域。</p><h3 id="配置Thymeleaf视图解析器"><a href="#配置Thymeleaf视图解析器" class="headerlink" title="配置Thymeleaf视图解析器"></a>配置Thymeleaf视图解析器</h3><p>为了要在Spring中使用Thymeleaf,我们需要配置三个启用Thymeleaf与Spring集成的bean:<br><strong>ThymeleafViewResolver</strong>:将逻辑视图名称解析为Thymeleaf模板视图;<br><strong>SpringTemplateEngine</strong>:处理模板并渲染结果;<br><strong>TemplateResolver</strong>:加载Thymeleaf模板。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8A%E5%8D%8811.04.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不管使用哪种配置方式，Thymeleaf 都可以将响应中的模板渲染到Spring MVC控制器所处理的请求中。</p><p><strong>ThymeleafViewResolver</strong>是Spring MVC中ViewResolver的一个实现类。像其他的视图解析器一样， 会接受一个逻辑视图名称,并将其解析为视图。不过在该场景下，视图会是一个Thymeleaf模板。<br>其中<strong>ThymeleafViewResolver</strong>中注入了一个对<strong>SpringTemplateEngine</strong>的引用。SpringTemplateEngine会在Spring中启用Thymeleaf引擎，用来解析模板，并基于这些模板渲染结果。对其注入一个<strong>TemplateResolver</strong> 的引用。<br><strong>TemplateResolver</strong>会最终定位和查找模板。与之前配置InternalResourceViewResolver类似，使用了prefix和suffix属性。前缀和后缀将会与逻辑视图名组合使用,进而定位Thymeleaf引擎。它的templateMode属性被设置成了HTML5，这表明预期要解析的模板会渲染成HTML5输出。</p><h3 id="定义Thymeleaf模板"><a href="#定义Thymeleaf模板" class="headerlink" title="定义Thymeleaf模板"></a>定义Thymeleaf模板</h3><p>Thymeleaf在很大程度上就是HTML文件，与JSP不同，没有什么特殊的标签或标签库。Thymeleaf 之所以能够发挥作用，是因为通过自定义的命名空间，为标准的HTML标签集合添加Thymeleaf属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20MVC/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-21%20%E4%B8%8B%E5%8D%881.56.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="借助Thymeleaf实现表单绑定"><a href="#借助Thymeleaf实现表单绑定" class="headerlink" title="借助Thymeleaf实现表单绑定"></a>借助Thymeleaf实现表单绑定</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-MVC起步&quot;&gt;&lt;a href=&quot;#Spring-MVC起步&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC起步&quot;&gt;&lt;/a&gt;Spring MVC起步&lt;/h1&gt;&lt;h2 id=&quot;处理流程&quot;&gt;&lt;a href=&quot;#处理流程&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
      <category term="Spring" scheme="https://github.com/zdkswd/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/zdkswd/2019/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/"/>
    <id>https://github.com/zdkswd/2019/06/20/字符串匹配算法 BF RK BM/</id>
    <published>2019-06-20T01:08:39.940Z</published>
    <updated>2019-06-28T01:04:32.821Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: ‘字符串匹配算法 BF RK BM’<br>date: 2019-06-24 10:40:47<br>tags: [算法]</p><h2 id="category-知识总结"><a href="#category-知识总结" class="headerlink" title="category: 知识总结"></a>category: 知识总结</h2><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>java</strong>中的<strong>indexOf(),Python</strong>中的<strong>find()</strong>函数，底层依赖的就是字符串匹配算法。</p><p>字符串匹匹配算法有<strong>BF算法，RK算法，BM算法，KMP算法。</strong></p><p>其中BF算法RK算法是单模式匹配算法，即为一个串和另一个串进行匹配。</p><h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><p>Brute Force，即为暴力匹配算法，比较简单，性能不高。</p><p>主串的长度记作n,模式串的长度记作m。因为是在主串中查找模式串,所以n&gt;m。在主串中，检查起始位置分别是0、1、…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/f36fed972a5bdc75331d59c36eb15aa2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>算法最坏时间复杂度为<strong>O(n * m)</strong></p><p>尽管理论上，BF算法的时间复杂度很高，但在实际的开发中，它却是一个比较常用的字符串匹配算法。<br>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n * m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。<br>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是常说的KISS (Keep it Simple and Stupid)设计原则。</p><p>在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p><h1 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h1><p>RK算法即为BF算法的升级版。</p><p>RK算法的思路为:通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等非常快速的，所以模式串和子串比较的效率就提高了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/015c85a9c2a4adc11236f9a40c6d57ee.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了避免遍历字串中的每一个字符，提高算法的效率，需要对哈希算法进行设计。</p><p>假设要匹配的字符串的字符集中只包含K个字符，可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/d5c1cb11d9fc97d0b28513ba7495ab04.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种哈希算法有一个特点， 在主串中，相邻两个子串的哈希值的计算公式有一定关系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/f99c16f2f899d19935567102c59661f5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>规律:相邻两个子串s[i-1]和s[i] (i 表示子串在主串中的起始位置，子串的长度都为m)，对应的哈希值计算公式有交集，可以使用s[i-1]的哈希值很快的计算出s[i]的哈希值。用公式表示:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/f298f1e5c93b205345b9cd6d9c53fbee.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>26^(m-1)这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好26^0、26^1、 2……26^(m -1),并且存储在一个长度为m的数组中，公式中的“次方”就对应数组的下标。当我们需要计算26的x次方的时候，就可以从数组的下标为x的位置取值，直接使用，省去了计算的时间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/224b899c6e82ec54594e2683acc4552f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>RK算法时间复杂度分析：<br>整个RK算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。<br>第一部分，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，这部分的时间复杂度是O(n)。<br>如果模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，为了能将哈希值落在整型数据范围内，可以牺牲一下， 允许哈希冲突。比如可以将字符串中每个字母对应的数字相加得到哈希值，这样产生的哈希值数据范围就小很多。<br>当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。解决方法是当发现一个子串的哈希值跟模式串的哈希值相等的时候，只需要再对比一下子串和模式串本身。</p><p>极端情况下，如果存在大量的冲突，每次都要对比字串和模式串本身，时间复杂度会退化为O( n * m)。一般情况下，冲突不会很多，RK算法效率还是比BF算法高。</p><h1 id="二维空间"><a href="#二维空间" class="headerlink" title="二维空间"></a>二维空间</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/00c353326466a8ce4e790e36924704c9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以同理看做一个字符串来处理。</p><h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>BF，RK算法中遇到不匹配，模式串往后滑动一位，然后从模式串第一个字符开始重新匹配。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/4316dd98eac500a01a0fd632bb5e77f9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>主串中的c，在模式串中是不存在的，模式串向后滑动的时候，只要c与模式串有重合，肯定无法匹配。所以，可以一次性把模式串往后多滑动几位，把模式串移动到c的后面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/cf362f9e59c01aaf40a34d2f10e1ef15.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>BM算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p><h2 id="BM算法原理分析"><a href="#BM算法原理分析" class="headerlink" title="BM算法原理分析"></a>BM算法原理分析</h2><p>BM算法包含两部分，分别是<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。</p><h3 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/540809418354024206d9989cb6cdd89e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>BM算法的匹配顺序比较特别，是按照模式串下标从大到小的顺序，倒着匹配的。当发现某个字符没法匹配的时候。把这个没有匹配的字符叫作<strong>坏字符</strong>(主串中的字符)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/220daef736418df84367215647bca5da.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>拿坏字符c在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符c与模式串中的任何字符都不可能匹配。这个时候，可以将模式串直接往后滑动三位，将模式串滑动到c后面的位置，再从模式串的末尾字符开始比较。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/4e36c4d48d1b6c3b499fb021f03c7f64.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/a8d229aa217a67051fbb31b8aeb2edca.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后对于模式串中存在的a，滑动两位，让两个串对齐。</p><p>总结规律为：<br>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作si。如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作xi。如果不存在，把xi记作-1。那模式串往后移动的位数就等于si-xi。(注意, 这里都是字符在模式串的下标)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/8f520fb9d9cec0f6ea641d4181eb432e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果坏字符在模式串里多处出现，在计算xi的时候，选择最靠后的那个，这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p><p>单纯使用坏字符规则还是不够的。因为根据si-xi计算出来的移动位数，有可能是负数。所以，BM算法还需要用到“好后缀规则”</p><h3 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/d78990dbcb794d1aa2cf4a3c646ae58a.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>把已经匹配的bc叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u <em> }，那我们就将模式串滑动到子串{u </em> }与主串中{u}对齐的位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/b9785be3e91e34bbc23961f67c234b63.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果在模式串中找不到另一个等于{u}的子串，就直接将模式串滑动到主串中{u}的后面。此时有可能存在滑动过头的情况，错过匹配字符串。所以不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/0544d2997d8bb57c10e13ccac4015e23.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/6caa0f61387fd2b3109fe03d803192f9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</strong></p><h2 id="BM算法代码实现"><a href="#BM算法代码实现" class="headerlink" title="BM算法代码实现"></a>BM算法代码实现</h2><p>坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/bf78f8a0506e069fa318f36c42a95e02.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>表示模式字串中不同的后缀字串。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/7742f1d02d0940a1ef3760faf4929ec8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>suffix数组下标k，表示后缀字串的长度，下标对应的数组值存储的是在模式串中跟好后缀{u}相匹配的字串{u * }的起始下标值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/99a6cfadf2f9a713401ba8feac2484c2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。<br>除了suffix数组外，还需要另一个boolean类的prefix数组，来记录模式串的后缀字串能否匹配模式串的前缀字串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20BF%20RK%20BM/279be7d64e6254dac1a32d2f6d1a2383.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="BM算法的性能分析及优化"><a href="#BM算法的性能分析及优化" class="headerlink" title="BM算法的性能分析及优化"></a>BM算法的性能分析及优化</h2><p>BM内存消耗，其中bc数组的大小跟字符集大小有关，suffix 数组和prefix数组的大小跟模式串长度m有关。</p><p>如果处理字符集很大的字符串匹配问题，bc 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果运行的环境对内存要求苛刻，可以只使用好后缀规则，不使用坏字符规则，这样就可以避免bc数组过多的内存消耗。不过，单纯使用好后缀规则的BM算法效率就会下降一些了。</p><p>BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM算法构建的规则有两类，<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，可以只用好后缀规则来实现BM算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: ‘字符串匹配算法 BF RK BM’&lt;br&gt;date: 2019-06-24 10:40:47&lt;br&gt;tags: [算法]&lt;/p&gt;
&lt;h2 id=&quot;category-知识总结&quot;&gt;&lt;a href=&quot;#category-知识总结&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://github.com/zdkswd/2019/06/14/%E5%9B%BE/"/>
    <id>https://github.com/zdkswd/2019/06/14/图/</id>
    <published>2019-06-14T13:03:47.000Z</published>
    <updated>2019-06-14T13:03:56.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/df85dc345a9726cab0338e68982fd1af.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>无向图</strong>，两者之间建立一条边，称为顶点的<strong>度</strong>。就是跟顶点相连接的边的条数。</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/c31759a37d8a8719841f347bd479b796.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>有向图</strong>，在有向图中把度分为<strong>入度</strong>和<strong>出度</strong>。</p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/55d7e4806dc47950ae098d959b03ace8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>带权图</strong>，每条边都有一个权重。</p><h1 id="图的存储方法"><a href="#图的存储方法" class="headerlink" title="图的存储方法"></a>图的存储方法</h1><h2 id="邻接矩阵存储法"><a href="#邻接矩阵存储法" class="headerlink" title="邻接矩阵存储法"></a>邻接矩阵存储法</h2><p>图最直观的存储方法就是<strong>邻接矩阵</strong>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/625e7493b5470e774b5aa91fb4fdb9d2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用邻接表来表示一个图虽然简单直观，比较浪费存储空间。如果存储的是<strong>稀疏图</strong>，就更加浪费空间了。</p><p>邻接矩阵的优点在于简单直接，在获取两个顶点关系时非常高效，其次还方便计算。</p><h2 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/039bc254b97bd11670cdc4bf2a8e1394.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>邻接表存储起来比较节省空间，使用起来比较耗时间。</p><p>如果链过长，为了提高查找效率，可以将链表换成其他更加高效的数据结构，比如红黑树。也可以使用其他动态数据结构比如跳表和散列表。</p><h2 id="存储微博关系"><a href="#存储微博关系" class="headerlink" title="存储微博关系"></a>存储微博关系</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/501440bcffdcf4e6f9a5ca1117e990a1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。</p><h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/002e9e54fb0d4dbf5462226d946fa1ea.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>借助<strong>队列</strong>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/4cd192d4c220cc9ac8049fd3547dba39.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>广度优先搜索的时间复杂度是<strong>O(V+E)</strong>,<strong>V</strong>表示顶点的个数，<strong>E</strong>表示边的个数。</p><p>广度优先搜索的控件消耗主要在几个辅助变量visited数组、queue队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数。所以空间复杂度是O(V)。</p><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%BE/8778201ce6ff7037c0b3f26b83efba85.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>借助<strong>栈</strong>。</p><p>深度优先搜索算法的时间复杂度是<strong>O(E)</strong>,E表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是visited、 prev 数组和递归调用栈。visited、 prev 数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是<strong>O(V)</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的概念&quot;&gt;&lt;a href=&quot;#图的概念&quot; class=&quot;headerlink&quot; title=&quot;图的概念&quot;&gt;&lt;/a&gt;图的概念&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://github.com/zdkswd/2019/06/12/%E5%A0%86/"/>
    <id>https://github.com/zdkswd/2019/06/12/堆/</id>
    <published>2019-06-12T13:49:47.000Z</published>
    <updated>2019-06-12T13:50:33.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆的应用场景非常多，最经典的就是堆排序。堆排序是一种原地，时间复杂度为<strong>O(nlogn)</strong>的排序算法。在实际软件开发中，快速排序性能要比堆排序好。</p><h1 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h1><ol><li>堆是一个完全二叉树;</li><li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。分别对应大顶堆和小顶堆。</li></ol><h1 id="实现一个堆"><a href="#实现一个堆" class="headerlink" title="实现一个堆"></a>实现一个堆</h1><p>用数组存储一个堆。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/4d349f57947df6590a2dd1364c3b0b1e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="1-往堆中插入一个元素"><a href="#1-往堆中插入一个元素" class="headerlink" title="1.往堆中插入一个元素"></a>1.往堆中插入一个元素</h2><p>往堆中插入一个元素后需要继续满足堆的两个特性，就需要进行调整，让其重新满足堆的特性，这个过程就叫做<strong>堆化</strong>。分为从下往上和从上往下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/e578654f930002a140ebcf72b11eb722.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>堆化就是顺着节点所在的路径从上或从下对比交换。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/e3744661e038e4ae570316bc862b2c0e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>让新插入的节点与父节点对比大小，如果不满足子节点小于等于父节点的大小关系，就互换两个节点，一直重复这个过程，直到父子节点之间满足大小关系。即为从下往上。</p><h2 id="2-删除堆顶元素"><a href="#2-删除堆顶元素" class="headerlink" title="2.删除堆顶元素"></a>2.删除堆顶元素</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/110d6f442e718f86d2a1d16095513260.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从上往下。</p><h1 id="基于堆实现排序"><a href="#基于堆实现排序" class="headerlink" title="基于堆实现排序"></a>基于堆实现排序</h1><p>时间复杂度<strong>O(nlogn)</strong>，原地排序算法。堆排序分为两个大步骤，<strong>建堆</strong>和<strong>排序</strong>。</p><h2 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1.建堆"></a>1.建堆</h2><p>有两种思路，<br>第一种，在堆中插入一个元素，起初堆中只包含一个数据，就是下标为1的数据，然后调用插入操作，将下标从2到n的数据依次插入到堆中，这样就将包含n个数据的数据组织成了堆。</p><p>第二种思路，直接从第一个非叶子节点开始，依次堆化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/50c1e6bc6fe68378d0a66bdccfff441e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/aabb8d15b1b92d5e040895589c60419d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>建堆的时间复杂度分析：<strong>O(n)</strong></p><h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h2><p>建堆结束后，数组中数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。不断取出堆顶的元素也就完成了排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/23958f889ca48dbb8373f521708408d1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>堆排序的时间复杂度、空间复杂度以及稳定性：</strong><br>整个堆排序只需要极个别临时存储空间，堆排序是原地排序算法。堆排序包括<strong>建堆</strong>和<strong>排序</strong>两个操作。建堆的时间复杂度是<strong>O(n)</strong>,排序过程的时间复杂度是<strong>O(nlogn)</strong>,所以堆排序整体的时间复杂度是<strong>O(nlogn)</strong>。</p><p>堆排序不是稳定的排序算法，因为在排序过程中，存在将堆最后一个节点与堆顶节点互换的操作，所以就有可能改变相同数据原始相对顺序。</p><p>如果堆从0开始存储，实际上处理思路是没有变化的，唯一变化的是代码实现时计算子节点和父节点的下标公式改变了。</p><h2 id="快排与堆排序"><a href="#快排与堆排序" class="headerlink" title="快排与堆排序"></a>快排与堆排序</h2><p>实际开发中，快排比堆排序性能好的两方面原因。<br><strong>一，堆排序数据访问的方式没有快速排序友好。</strong><br>对于快速排序来说，数据是顺序访问的，对于堆排序来说，数据是跳着访问的。这样对CPU缓存是不友好的。<br><strong>二，对于同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序。</strong>堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。对于一组已经有序的数据，经过建堆，数据变得更无序了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/6e81fdde42ec3fd288d32eb866867fbd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><p>堆有几个非常重要的应用：优先级队列，求TopK和求中位数。</p><h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><p>队列是先进先出，不过在优先级队列里，出队顺序不是先进先出，而是按照优先级来，优先级最高的最先出队。</p><p>一个堆就可以看作是一个优先级队列。</p><p>有很多数据结构和算法都依赖它，比如霍夫曼编码，图的最短路径，最小生成树算法等等。很多语言都提供了优先级队列的实现，比如Java的PriorityQueue，C++的priority_queue等。</p><h3 id="1-合并有序小文件"><a href="#1-合并有序小文件" class="headerlink" title="1.合并有序小文件"></a>1.合并有序小文件</h3><p>假设有100个小文件，每个文件的大小是100MB，每个文件中存储的都是有序的字符串。希望将这些100个小文件合并成一个有序的大文件。 这里就会用到优先级队列。</p><p>从小文件中取出字符串放入小订堆汇总，堆顶的元素，也就是优先级队列队首的元素就是最小的字符串。将这个字符串放入到大文件中，并将其从堆中删除。再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将100个小文件依次放入到大文件中。</p><p>其中，删除堆顶数据和往堆中插入数据的时间复杂度都是O(logn)。</p><h3 id="2-高性能定时器"><a href="#2-高性能定时器" class="headerlink" title="2.高性能定时器"></a>2.高性能定时器</h3><h2 id="堆的应用二：利用堆求TopK"><a href="#堆的应用二：利用堆求TopK" class="headerlink" title="堆的应用二：利用堆求TopK"></a>堆的应用二：利用堆求TopK</h2><p>TopK问题分为两类，一类是针对静态数据集合，就是数据集合事先确定，不会再变。另一类是针对动态数据集合，就是数据集合事先并不确定，有数据动态地加入到集合中。</p><p>针对静态数据，如何在一个包含n个数据的数组中，查找前K大数据呢?我们可以维护一个大小为K的<strong>小顶堆</strong>，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中;如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前K大数据了。遍历数组需要O(n)的时间复杂度，一次堆化操作需要O(logK)的时间复杂度,所以最坏情况下，n个元素都入堆一次，时间复杂度就是<strong>O(nlogK)</strong>。</p><p>动态数据求得Top K就是实时Top K。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前K大数据。</p><p>实际上，我们可以一直都维护一个K大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中;如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前K大数据，都可以立刻返回。</p><h2 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h2><p>对于静态数据，中位数是固定的，可以先排序取中间就是中位数，面对<strong>动态数据</strong>集合，中位数不断变动，如果再用先排序的方法，效率就不高了。<strong>借助堆这种数据结构，不用排序，就可以非常高效地实现求中位数操作。</strong></p><p>需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/08c29d3e014a4baf5f8148c2271e6099.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>大顶堆的堆顶即为要找的中位数。</strong></p><p>当新添加一个数据的时候，如果新加入的数据小于等于大顶堆的堆顶元素，就将这个新数据插入到大顶堆;否则，就将这个新数据插入到小顶堆。</p><p>这个时候就有可能出现，两个堆中的数据个数不符合约定的情况:<strong>如果n是偶数，两个堆中的数据个数都是n / 2;如果n是奇数，大顶堆有 n / 2 +1 个数据，小顶堆有 n / 2 个数据。</strong>这个时候，可以从一个堆中不停地将堆项元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足约定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%A0%86/aee4dcaf9d34111870a1d66a6e109fb1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>插入数据</strong>因为需要涉及堆化，所以时间复杂度为<strong>O(logn)</strong>, 但是求中位数只需要返回大顶堆的堆顶元素，时间复杂度为<strong>O(1)</strong>。</p><p><strong>通过类似的方法可以求任意百分位值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;p&gt;堆的应用场景非常多，最经典的就是堆排序。堆排序是一种原地，时间复杂度为&lt;strong&gt;O(nlogn)&lt;/strong&gt;的排序算法。在实际软件开发中
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://github.com/zdkswd/2019/06/12/%E6%A0%91/"/>
    <id>https://github.com/zdkswd/2019/06/12/树/</id>
    <published>2019-06-12T05:46:47.000Z</published>
    <updated>2019-06-12T13:49:29.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/18413c6597c2850b75367393b401ad60.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="表示（存储）一颗二叉树"><a href="#表示（存储）一颗二叉树" class="headerlink" title="表示（存储）一颗二叉树"></a>表示（存储）一颗二叉树</h2><p>两种方法，一种是基于指针或引用的<strong>二叉链式存储法</strong>，一种是基于数组的<strong>顺序存储法</strong>。</p><h3 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。</p><h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/14eaa820cb89a17a7303e8847a412330.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基于数组，把根节点存储在下标i=1的位置，节点X存储在数组中下标i的位置，下标为2 <em> i的位置存储的就是左子节点，下标为2 </em> i+1的位置存储的就是右子节点。反过来下标i / 2的位置就是父节点。这样，只要知道根节点的位置（一般为了方便计算，根节点会存储在下标为1的位置）就可以把整颗树串起来。</p><p>如果是非完全二叉树，其实会浪费比较多的数组存储空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/08bd43991561ceeb76679fbb77071223.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果某棵二叉树是一棵完全二叉树，用数组存储是最节省内存的一种方式。因为数组存储不需要像链式存储一样额外存储左右子节点的指针。<strong>这也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</strong></p><p><strong>堆其实就是一种完全二叉树，最常用的存储方式就是数组。</strong></p><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/ab103822e75b5b15c615b68560cb2416.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>前序是指先遍历该节点，再遍历左，右节点。后序中序同理。<br><strong>二叉树的前中后序遍历就是个递归的过程。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%889.13.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>二叉树遍历的时间复杂度为：</strong><br>从遍历顺序图可以看出，每个节点最多会被访问两次，所以遍历的时间复杂度跟节点的个数n成正比，也就是二叉树遍历的时间复杂度为O(n)。</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树最大的特点就是支持动态数据集合的快速插入删除查找操作。</p><p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中每个节点的值，都要小于这个节点的值，而右子树节点的值。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/f3bb11b6d4a18f95aa19e11f22b99bae.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="1-二叉查找树的查找操作"><a href="#1-二叉查找树的查找操作" class="headerlink" title="1.二叉查找树的查找操作"></a>1.二叉查找树的查找操作</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/96b3d86ed9b7c4f399e8357ceed0db2a.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="2-二叉查找树的插入操作"><a href="#2-二叉查找树的插入操作" class="headerlink" title="2.二叉查找树的插入操作"></a>2.二叉查找树的插入操作</h2><p>插入操作类似于查找操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/daa9fb557726ee6183c5b80222cfc5c5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a>二叉查找树的删除操作</h2><p>删除操作比较复杂，针对要删除节点的子节点个数的不同，分为三种情况来处理。</p><p><strong>第一种情况</strong>是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为nll。比如图中的删除节点55。</p><p><strong>第二种情况</strong>是，如果要删除的节点只有一个子节点(只有左子节点或者右子节点)，我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。</p><p><strong>第三种情况</strong>是，如果要删除的节点有两个子节点，这就比较复杂了。<strong>我们需要找到这个节点的右子树中的最小节点</strong>，把它替换到要删除的节点上。<strong>然后再删除掉这个最小节点</strong>，因为最小节点肯定没有左子节点(如果有左子结点，那就不是最小节点了)，所以，我们可以应用上面两条规则（情况一二）来删除这个最小节点。比如图中的删除节点18。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/299c615bc2e00dc32225f4d9e3490e2c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><h2 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a>二叉查找树的其他操作</h2><p><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)，非常高效。</strong>二叉查找树也叫二叉排序树。</p><h1 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h1><p>在实际开发中，二叉查找树中存储的都是对象，利用对象的某个字段作为键值(key)来构建二叉查找树，对象中其他字段叫作卫星数据。</p><p>如果存储的两个对象键值相同，有两个解决方法。</p><p><strong>第一种方法比较容易</strong>。二又查找树中每一个节点不仅会存储一个数据， 通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p><p><strong>第二种不好理解但是更加优雅。</strong>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/3f59a40e3d927f567022918d89590a5f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/fb7b320efd59a05469d6d6fcf0c98eff.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/254a4800703d31612c0af63870260517.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/e3d9b2977d350526d2156f01960383d9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是<strong>平衡二叉查找树</strong>。平衡二叉查找树的高度接近logn,所以插入、删除、查找操作的时间复杂度也比较稳定，是<strong>O(logn)</strong>。</p><h1 id="散列表与二叉查找树"><a href="#散列表与二叉查找树" class="headerlink" title="散列表与二叉查找树"></a>散列表与二叉查找树</h1><p>散列表的插入、删除、查找操作的时间复杂度做到常量级O(1),而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)。<br>相比散列表二叉查找树的优势：</p><ol><li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据序列。</li><li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在<strong>O(logn)</strong>。</li><li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为<strong>哈希冲突</strong>的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li><li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li><li>最后，为了避免过多的散列冲突,散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，会浪费一定的存储空间。</li></ol><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><strong>红黑树是一种平衡二叉查找树</strong></p><h2 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h2><p><strong>定义：二叉树中任意一个节点的左右子树高度相差不能大于1.</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/dd9f5a4525f5029a8339c89ad1c8159b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最先发明出的平衡二叉查找树是<strong>AVL树</strong>，严格符合定义。是一种高度平衡的二叉查找树。</p><p>很多平衡二叉查找树其实并没有严格符合上面的定义(树中任意一个节点的左右子树的高度相差不能大于1)。发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。平衡二叉查找树中“<strong>平衡</strong>”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些， 相应的插入、删除、查找等操作的效率高一些。</p><h2 id="定义一颗红黑树"><a href="#定义一颗红黑树" class="headerlink" title="定义一颗红黑树"></a>定义一颗红黑树</h2><p>红黑树：</p><ol><li>根节点是黑色的; </li><li>每个叶子节点都是黑色的空节点(NIL)， 也就是说， 叶子节点不存储数据;</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的;</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点;</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/903ee0dcb62bce2f5b47819541f9069a.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>暂时先将黑色的空的叶子节点都省略掉了。</strong></p><h2 id="红黑树是近似平衡的"><a href="#红黑树是近似平衡的" class="headerlink" title="红黑树是近似平衡的"></a>红黑树是近似平衡的</h2><p><strong>“平衡” 的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。</strong></p><p>红黑树的高度：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/7e6ecc308fe44120f30de809822215ed.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>完全二叉树的高度近似log2n, 这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过logn。</p><p>加上红色节点，最长路径不会超过2logn，也就是红黑树的高度近似2logn。</p><p>红黑树的高度只比高度平衡的AVL树的高度(logn)仅仅大了一倍,在性能上,下降得并不多。这样推导岀来的结果不够精确,实际上红黑树的性能更好。</p><p>Treap、Splay Tree,绝大部分情况下操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说并不适用。<br>AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊, AVL树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。<br>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，更倾向于这种性能稳定的平衡二叉查找树。</p><h2 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h2><p>红黑树的平衡过程跟魔方复原非常神似，大致过程就是:<strong>遇到什么样的节点排布，就对应怎么去调整。</strong>只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。</p><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，“平衡调整”,实际上就是要把被破坏的第三、第四点恢复过来。</p><p>左旋与右旋：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/0e37e597737012593a93105ebbf4591e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h2><p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</strong>关于插入操作的平衡调整，有这样两种<strong>特殊情况</strong>。</p><ol><li>如果插入节点的父节点是黑色的，就什么都不用做，仍然满足红黑树的定义。</li><li>如果插入的节点是根节点，则直接改变它的颜色，把它变成黑色就可以了。</li></ol><p>除此之外，其他情况都会违背红黑树的定义，于是就需要进行调整，调整的过程包含两种基础的操作:<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p><p>红黑树的平衡调整过程是一个<strong>迭代</strong>的过程。正在处理的节点叫作<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p><p>新节点插入后，如果红黑树平衡被打破，一般会有三种情况，需要根据每种情况的特点不断调整，让红黑树继续符合定义，即继续保持平衡。</p><p><strong>case 1:如果关注节点是a，叔叔节点d是红色</strong>，依次执行下面操作：</p><ol><li>将关注节点a的父节点b、叔叔节点d的颜色都设置成黑色;</li><li>将关注节点a的祖父节点c的颜色设置成红色;</li><li>关注节点变成a的祖父节点c;</li><li>跳到CASE 2或者CASE 3。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/603cf91f54b5db21bd02c6c5678ecf40.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>case2:如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点</strong>，依次执行下面操作：</p><ol><li>关注节点变成节点a的父节点b</li><li>围绕新的关注节点b左旋</li><li>跳到CASE3</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/4480a314f9d83c343b8adbb28b6782ad.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>CASE 3:如果关注节点是a,它的叔叔节点d是黑色，关注节点a是其父节点b的左子节点，</strong>依次执行下面的操作:</p><ol><li>围绕关注节点a的祖父节点c右旋;</li><li>将关注节点a的父节点b、兄弟节点c的颜色互换。</li><li>调整结束</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/04650d9470b1e67899f5b8b7b8e33212.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h2><p>删除操作的平衡调整分为两步。<br><strong>第一步是针对删除节点初步调整。</strong>初步调整是保证整颗红黑树在一个节点删除之后，仍然满足最后一条定义的要求，就是每个节点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。<br><strong>第二步是针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p><h3 id="针对删除节点初步调整"><a href="#针对删除节点初步调整" class="headerlink" title="针对删除节点初步调整"></a>针对删除节点初步调整</h3><p>经过初步调整后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色。有些节点会被标记成两种颜色，“红黑”或“黑黑”。</p><p><strong>case1：如果要删除的节点时a，它只有一个子节点b。</strong>依次进行下面的操作：</p><ol><li>删除节点a,并且把节点b替换到节点a的位置，这一部分操作跟普通的二叉查找树的删除操作一样。</li><li>节点a只能是黑色，节点b也只能是红色，其他情况均不符合红黑树的定义。这种情况下，把节点b改为黑色。</li><li>调整结束，不需要进行二次调整。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%A0%91/a6c4c347b7cbdf57662bab399ed36cc3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>CASE 2:如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c</strong>。</p><p>太多且复杂，有的放矢不记了☺</p><h2 id="要求叶子节点为黑的原因"><a href="#要求叶子节点为黑的原因" class="headerlink" title="要求叶子节点为黑的原因"></a>要求叶子节点为黑的原因</h2><p>之所以有这么奇怪的要求就是为了实现起来方便，只要满足这一条要求，在任何时刻，红黑树的平衡操作都可以归结为我们刚刚讲的那几种情况。</p><p>给红黑树添加黑色的空的叶子节点，不会比较浪费存储空间。虽然在讲解或者画图的时候，每个黑色的、空的叶子节点都是独立画出来的。实际上，在具体实现的时候，只需要共用一个黑色的、空的叶子节点就行了。</p><h2 id="红黑树要点"><a href="#红黑树要点" class="headerlink" title="红黑树要点"></a>红黑树要点</h2><p><strong>第一点，把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。</strong></p><p><strong>第二点,找准关注节点,不要搞丢、搞错关注节点。</strong></p><p><strong>第三点，插入操作的平衡调整比较简单，但是删除操作就比较复杂</strong>。针对删除操作，有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbo
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法</title>
    <link href="https://github.com/zdkswd/2019/06/11/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/zdkswd/2019/06/11/哈希算法/</id>
    <published>2019-06-11T11:02:47.000Z</published>
    <updated>2019-06-11T11:03:17.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p><strong>哈希算法</strong>即为将任意长度的二进制值串映射为固定长度的二进制值串。</p><p>哈希算法的一些要求：</p><ol><li>从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法)；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit,最后得到的哈希值也大不相同; </li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小;</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ol><h1 id="哈希算法的应用场景"><a href="#哈希算法的应用场景" class="headerlink" title="哈希算法的应用场景"></a>哈希算法的应用场景</h1><h2 id="应用一-安全加密"><a href="#应用一-安全加密" class="headerlink" title="应用一:安全加密"></a>应用一:安全加密</h2><p>常见的加密算法<strong>MD5</strong>(MD5消息摘要算法)，<strong>SHA</strong>(安全散列算法)，<strong>DES</strong>(数据加密标准)，<strong>AES</strong>(高级加密标准)。</p><p>对于加密算法中四点要求中的两点格外重要，一是很难根据哈希值反向推导出原始数据，第二是散列冲突的概率要很小。</p><p><strong>哈希算法无法做到零冲突</strong>，如MD5，能表示的数据是有限的，最多表示2^128个数据。所以散列冲突的概率要小于1/ 2^128。即便哈希算法存在冲突，在有限的时间和资源下，哈希算法还是很难破解的。</p><p>没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。比如SHA- 256比SHA-1要更复杂、更安全，相应的计算时间就会比较长。密码学界也一直致力于找到一种快速并且很难被破解的哈希算法。在实际的开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。</p><h2 id="应用二-唯一标识"><a href="#应用二-唯一标识" class="headerlink" title="应用二:唯一标识"></a>应用二:唯一标识</h2><p>在海量图库中搜索一张图是否存在时，可以给每个图片取唯一标识比如信息摘要，可以在图片的二进制码串开头取100字节，中间100字节，结尾100字节，然后300个字节放在一起，通过哈希算法得到一个哈希字符串，用作图片的唯一标识符。通过这个来判定是否在图库中可以减少很多工作量。</p><p>如果还想继续提高效率,我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一 标识，然后在散列表中查找是否存在这个唯一标识。</p><p>如果不存在，那就说明这个图片不在图库中;如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在;如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p><h2 id="应用三-数据校验"><a href="#应用三-数据校验" class="headerlink" title="应用三:数据校验"></a>应用三:数据校验</h2><p>哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再下载这个文件块。</p><h2 id="应用四-散列函数"><a href="#应用四-散列函数" class="headerlink" title="应用四:散列函数"></a>应用四:散列函数</h2><p>散列函数也是哈希算法的一种应用。相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，都可以通过开放寻址法或者链表法解决。散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h2 id="应用五-负载均衡"><a href="#应用五-负载均衡" class="headerlink" title="应用五:负载均衡"></a>应用五:负载均衡</h2><p>负载均衡算法有很多，比如轮询、随机、加权轮询等。实现一个会话粘滞(session sticky)的负载均衡算法。也就是同一个客户端在一次会话中的所有请求都路由到同一个服务器上。需要借助哈希算法高效解决：</p><p>对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。这样，我们就可以把同一个IP过来的所有请求，都路由到同一个后端服务器上。</p><h2 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h2><h3 id="1-统计“搜索关键词”出现次数"><a href="#1-统计“搜索关键词”出现次数" class="headerlink" title="1.统计“搜索关键词”出现次数"></a>1.统计“搜索关键词”出现次数</h3><p>假设有1T日志文件记录了用户搜索关键词，需要快速统计每个词的搜索次数。两个难点，一是搜索日志很大，没法放到一台机器内存中，二是只用一台机器处理，处理时间很长。</p><p>可以对数据进行分片，然后采用多态机器并行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。这样，哈希值相同的搜索关键词就被分配到了同-个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p><p>这就是<strong>MapReduce</strong>的基本设计思想。</p><h3 id="2-快速判断图片是否在图库中"><a href="#2-快速判断图片是否在图库中" class="headerlink" title="2.快速判断图片是否在图库中"></a>2.快速判断图片是否在图库中</h3><p>当图片数太多单机存不下时可以分布式存储。</p><p>当要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去编号k的机器构建的散列表中查找。</p><h2 id="应用七-分布式缓存"><a href="#应用七-分布式缓存" class="headerlink" title="应用七:分布式缓存"></a>应用七:分布式缓存</h2><h3 id="朴素分布式缓存"><a href="#朴素分布式缓存" class="headerlink" title="朴素分布式缓存"></a>朴素分布式缓存</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%886.51.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种方式存在缺陷：当增加缓存服务器时，之前缓存全部作废，后端服务器就会面临巨大压力。</p><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p><strong>hash(服务器A的IP地址)%(2^32)</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%886.55.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于图片<br><strong>hash(图片)%2^32</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%886.57.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>假如B服务器坏掉，也只有部分缓存失效。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%886.58.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现实中要处理的是哈希环的倾斜问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%886.58.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>某个服务器承担了太多压力。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%886.59.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以通过<strong>虚拟节点</strong>来解决这个问题。虚拟节点是实际节点在hash环上的复制品，一个实际节点可以对应多个虚拟节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;哈希算法&lt;/strong&gt;即为将任意长度的二进制值串映射为固定长度的二进制值串。&lt;/p&gt;
&lt;p&gt;哈希算法的一
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="https://github.com/zdkswd/2019/06/11/Java%E9%9B%86%E5%90%88/"/>
    <id>https://github.com/zdkswd/2019/06/11/Java集合/</id>
    <published>2019-06-11T03:53:47.000Z</published>
    <updated>2019-06-11T03:54:01.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Queue"><a href="#Java-Queue" class="headerlink" title="Java Queue"></a>Java Queue</h1><p>Java Queue中应当使用offer和poll而不是add和remove，原因是<br>一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。 offer 方法不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。 </p><p>poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p><p>peek，element区别：element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p><h1 id="Vector、ArrayList、LinkedList"><a href="#Vector、ArrayList、LinkedList" class="headerlink" title="Vector、ArrayList、LinkedList"></a>Vector、ArrayList、LinkedList</h1><p><strong>Vector</strong>是Java早期提供的<strong>线程安全</strong>的<strong>动态数组</strong>，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p><p><strong>ArrayList</strong>是应用更加广泛的<strong>动态数组</strong>实现，它本身不是线程安全的，所以性能要好很多。与Vector近似，ArrayL ist也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高1倍，而ArrayList则是增加50%。</p><p><strong>LinkedList</strong>顾名思义是Java提供的<strong>双向链表</strong>，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p><h1 id="Java-asList数组转集合"><a href="#Java-asList数组转集合" class="headerlink" title="Java asList数组转集合"></a>Java asList数组转集合</h1><p>Arrays.asList() 方法，这个方法会返回一个 ArrayList 类型的对象。但是用这个对象对列表进行添加删除更新操作，就会UnsupportedOperationException 异常。这个 ArrayList 类并非 java.util.ArrayList 类，而是 Arrays 类的静态内部类！内部类里面并没有 add、remove 方法，这个类继承的 AbstractList 类里面有这些方法。如果是想将一个数组转化成一个列表并做增加删除操作的话以<br>Arrays.asList() 作为参数新建一个arraylist,真正的arraylist。</p><h1 id="Hashtable、HashMap、TreeMap"><a href="#Hashtable、HashMap、TreeMap" class="headerlink" title="Hashtable、HashMap、TreeMap"></a>Hashtable、HashMap、TreeMap</h1><p><strong>Hashtable</strong>是早期Java类军提供的一个哈希表实现，本身是<strong>同步</strong>的，不支持null 键和值，由于同步导致的性能开销，所以已经<strong>很少被推荐使用</strong>。</p><p><strong>HashMap</strong>是应用更加广泛的哈希表实现，行为上大致上与HashTable 一致，主要区别在于HashMap<strong>不是同步</strong>的，支持null键和值等。通常情况下，HashMap进行put或者get 操作，可以达到常数时间的性能，所以它是绝大部分利用<strong>键值对存取场景的首选</strong>，比如， 实现一个用户ID和用户信息对应的运行时存储结构。不是线程安全的。</p><p><strong>TreeMap</strong>则是基于<strong>红黑树</strong>的一种提供顺序访问的Map,和HashMap不同，它的get、put、remove之类操作都是0 (log(n)) 的时间复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-Queue&quot;&gt;&lt;a href=&quot;#Java-Queue&quot; class=&quot;headerlink&quot; title=&quot;Java Queue&quot;&gt;&lt;/a&gt;Java Queue&lt;/h1&gt;&lt;p&gt;Java Queue中应当使用offer和poll而不是add和remove
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://github.com/zdkswd/2019/06/11/Git/"/>
    <id>https://github.com/zdkswd/2019/06/11/Git/</id>
    <published>2019-06-11T01:32:55.000Z</published>
    <updated>2019-06-11T01:33:18.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h2><p>config的三个作用域  local(default,只对某个仓库有效)    global   system</p><blockquote><p>git config –list//查看现有配置信息</p></blockquote><p>add到的是git暂存区的作用，commit前的一个区域，比如可以用于暂存工作状态，然后再做修改，比较两次的修改，满意了第二次覆盖，不满意将第一次的提交。暂存区中不合适也可以回退。</p><p>因为需要查看暂存区的状态，使用的命令是：</p><blockquote><p>git status</p></blockquote><p>git重命名命令</p><blockquote><p>git mv src dest</p></blockquote><p>git log</p><blockquote><p>git log (–oneline一行显示) (–all所有分支) (-n4最近四个) (–graph绘制图形)</p></blockquote><p>.git目录</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560059022340.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>HEAD存储指向当前工作的分支</p><p>config中记录user的信息，如果设置local配置，则会在此存储local信息。</p><p>refs引用存储heads(分支)  tags(标签信息)</p><p>objects存储对象</p><p>commit,tree和blob对象之间的关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560059639501.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560060359602.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>分离头指针（detached HEAD）指的是HEAD指向一个commit而不是一个分支，很可能会被git当作垃圾清理掉。</p><p>HEAD与branch</p><p>HEAD不仅可以指向分支，最终是落脚于某个commit，还可以指向之前一次commit。所以HEAD指向commit。HEAD可以用于指代所指commit。</p><h2 id="常用场景-在本地维护自己的分支"><a href="#常用场景-在本地维护自己的分支" class="headerlink" title="常用场景(在本地维护自己的分支)"></a>常用场景(在本地维护自己的分支)</h2><p>清除不要分支</p><blockquote><p>git branch -D 分支名</p></blockquote><p> 最新commit描述不准确，进行修改</p><blockquote><p>git commit –amend//双单杠</p></blockquote><p>老旧commit描述不准确，进行修改</p><blockquote><p>git rebase -i 被修改的父类的id</p></blockquote><p>进入交互式界面用于指定对commit要进行的操作</p><p>r </p><p>wq！保存并退出进入交互式界面，来修改message信息。</p><p>wq！保存并退出</p><p>历史多个连续commit合并</p><p>和上面一样的操作选择父节点，不过是r变s。</p><p>历史不连续commit合并</p><p>选择父节点，然后将要和并的不在父节点下的commit显式pick id号,将父节点下要合并的子节点挨着放，s开头。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560068929555.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>比较暂存区与HEAD所含文件</p><blockquote><p>git diff –cached</p></blockquote><p>比较工作区和暂存区</p><blockquote><p>git diff</p></blockquote><p>将暂存区恢复成和HEAD一样</p><blockquote><p>git reset HEAD</p></blockquote><p>将工作区文件恢复成暂存区一样（add后又做了变更，然后不满意时）</p><blockquote><p>git checkout – 文件名</p></blockquote><p>取消暂存区部分文件变更</p><blockquote><p>git reset HEAD –文件名</p></blockquote><p>消除最近几次提交</p><blockquote><p>git reset –hard commit_id</p></blockquote><p>这样HEAD和暂存区都指向了commit_id所指的commit</p><p>比较不同提交的差异</p><blockquote><p>git diff commit_id1 commit_id2</p></blockquote><p>正确的删除一个文件</p><blockquote><p>git rm 文件名</p></blockquote><p>当开发时临时加了紧急任务时，将自己现在做的修改压入堆栈。</p><blockquote><p>git stash</p></blockquote><p>取回使用apply，取栈顶信息，不出栈。</p><blockquote><p>git stash apply</p></blockquote><p>取回使用pop，栈顶出栈</p><blockquote><p>git stash pop</p></blockquote><p>.gitignore用于指定不需要Git管理的文件，将文件名加在其中或者使用通配符来指定不需要git管理的文件。</p><p>git传输的协议分为哑协议和智能协议。在本地也存在git备份，类比于远端库有一个本地库。</p><h1 id="Github常用操作"><a href="#Github常用操作" class="headerlink" title="Github常用操作"></a>Github常用操作</h1><p>配置公私钥 ssh 本地生产公私钥，将公钥粘贴到github中。</p><p>git pull是分两步走，先是fetch然后是merge。</p><p>当远端有文件，本地没有，这时fetch不是fast-forward方式，要通过merge合并。</p><p>也可以用rebase方式。</p><p>不同人修改不同文件如何处理</p><p>远端新建分支，本地建分支与远端相关联</p><blockquote><p>git chechout -b(切换到新建分支)  本地分支命名  远端分支命名</p></blockquote><p>查看分支情况,本地以及远端</p><blockquote><p>git branch -av</p></blockquote><p>修改相同文件不同区域，同理，可以不用人介入的merge。</p><p>当多人修改同一区域的时候，pull(fetch and merge)会失败，自动merge会失败。文件中会显式标出冲突的地方。</p><p>此时有两个选择，一，终止merge git merge –abort</p><p>二，解决冲突的地方，然后commit  然后push到远端</p><p>同时变更了文件名和文件内容，git可以正常的合并。</p><p>禁止向集成分支执行push -f操作。</p><p>高效搜索github项目。in:readme stars:&gt;1000 advanced search</p><h1 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h1><p>保证代码质量 fork下来，pull request</p><p>organization</p><p>项目分支情况 insights-&gt;network</p><p>merge rebase合并分支</p><p>分支和master产生冲突时，master会合并到分支解决冲突，解决完然后再提交pull request，又回到master产生一个commit。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;一些命令&quot;&gt;&lt;a href=&quot;#一些命令&quot; class=&quot;headerlink&quot; title=&quot;一些命令&quot;&gt;&lt;/a&gt;一些命
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Git" scheme="https://github.com/zdkswd/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常处理</title>
    <link href="https://github.com/zdkswd/2019/06/07/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2019/06/07/Java 异常处理/</id>
    <published>2019-06-07T14:22:47.000Z</published>
    <updated>2019-06-07T14:22:50.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="码出高效"><a href="#码出高效" class="headerlink" title="码出高效"></a>码出高效</h1><h2 id="throw-throws"><a href="#throw-throws" class="headerlink" title="throw throws"></a>throw throws</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/WechatIMG122.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>throw</strong>是方法内部抛出具体异常类对象的关键字，<strong>throws</strong>则用在方法上，表示方法调用者可以通过此方法声明向上抛出异常对象。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>在Exception中，unchecked异常是运行时异常，它们都继承自<strong>RuntimeException</strong>，不需要程序进行显式的捕捉和处理。</p><h2 id="try代码块"><a href="#try代码块" class="headerlink" title="try代码块"></a>try代码块</h2><p><strong>（1）try代码块</strong>：监视代码执行过程，一旦发现异常直接跳转catch，没有catch。则直接跳转至finally。<br><strong>（2）catch代码块</strong>。<br><strong>（3）finally代码块</strong>：try存在时，可以只有catch代码块，也可以只有finally代码块。不管有没有异常发生，即使发生OutOfMemoryError也会执行，通常用于处理善后清理工作。</p><p><strong>finally是在return表达式运行后执行的，此时将要return的结果已经被暂存起来，待finally代码块执行结束后再将之暂存的结果返回。</strong></p><p><strong>finally</strong>代码块中使用<strong>return</strong>语句使返回值的判断变得复杂，所以避免返回值不可控，<strong>不要在finally代码块中使用return语句。</strong></p><p>Lock、ThreadLocal、InputStream等这些需要进行强制释放和清除的对象都得在finally代码块中进行显式的清理，避免产生内存泄露，或者资源消耗。</p><h1 id="java核心技术36讲"><a href="#java核心技术36讲" class="headerlink" title="java核心技术36讲"></a>java核心技术36讲</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/accba531a365e6ae39614ebfa3273900.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>业界有一种争论，甚至可以算是某种程度的共识，Java语言的Cheaked Exception也许是一个<strong>设计错误</strong>。<br>（1）Checked Exception的假设是捕获了异常然后恢复程序。但是实际上大多数情况下根本不可能恢复。Checked Exception的使用已经大大偏离了最初的设计目的。<br>（2）Checked Exception不兼容functional编程。</p><p>但是确实有意向异常，比如和环境相关的IO、网络等其实是存在可恢复性的。</p><p>从性能角度看Java异常处理机制，有两个比较昂贵的地方：<br>（1）try-catch代码段会产生额外的性能开销，它往往会<strong>影响JVM对代码进行优化</strong>，所以建议仅捕获必要的代码段，不要一个大的try包住整段代码；与此同时用异常控制代码流程远比通常意义上的条件语句要低效。<br>（2）Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的比较频繁，这个开销就不能忽略了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;码出高效&quot;&gt;&lt;a href=&quot;#码出高效&quot; class=&quot;headerlink&quot; title=&quot;码出高效&quot;&gt;&lt;/a&gt;码出高效&lt;/h1&gt;&lt;h2 id=&quot;throw-throws&quot;&gt;&lt;a href=&quot;#throw-throws&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java I/O</title>
    <link href="https://github.com/zdkswd/2019/06/05/java%20io/"/>
    <id>https://github.com/zdkswd/2019/06/05/java io/</id>
    <published>2019-06-05T12:56:47.000Z</published>
    <updated>2019-06-19T06:12:32.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-编程思想"><a href="#java-编程思想" class="headerlink" title="java 编程思想"></a>java 编程思想</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>file类名字具有一定的误导性，它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果指的是一个文件集，就可以对此集合调用list（）方法。返回一个字符数组，如果想要取得不同目录列表，只需再创建一个不同的File对象。</p><p>File类不仅仅只代表存在的文件或目录。也可以用File对象来<strong>创建</strong>新的目录或尚不存在的整个目录路径。我们还可以查看文件的特性（如：大小，最后修改日期，读/写）检查某个File对象代表的是一个文件还是一个目录，并可以删除文件。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>有时我们必须把来自于“字节”层次结构中的类和“字符”层次结构中的类结合起来使用。为了实现这个目的，要用到“适配器”（adapter）类：InputStreamReader可以把InputStream转换为Reader，而OutputStreamWriter可以把OutputStream转换为Writer。</p><p>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化。老的I/ O流继承层次结构仅支持8位字节流，并且不能很好地处理16位的Unicode字符。由于Unicode用于字符国际化（Java本身的char也是16位的Unicode），所以添加Reader和Writer继承层次结构就是为了在所有的I/O操作中都支持Unicode。另外，新类库的设计使得它的操作比旧类库更快。</p><h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><h2 id="缓冲（缓存）处理"><a href="#缓冲（缓存）处理" class="headerlink" title="缓冲（缓存）处理"></a>缓冲（缓存）处理</h2><p><strong>缓存处理是所有IO操作的基础，术语输入输出只对数据移入移出缓存有意义。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><blockquote><p>用户空间与内核空间对应内存中不同的位置划分。通常<strong>32位Linux内核</strong>地址空间划分0~3G为用户空间，3~4G为内核空间。用户空间与内核空间也可以进行内存共享，以避免大量的数据复制。</p></blockquote><p>进程执行操作系统的I/O请求包括数据从缓冲区排出（写操作）和数据填充缓冲区（读操作）。</p><p>例如一个磁盘，移动到进程的存储区域（例如RAM）中。首先，进程要求其缓冲通过read()系统调用填满。这个系统调用导致内核向磁盘控制硬件发出一条命令要从磁盘获取数据。磁盘控制器通过<strong>DMA</strong>直接将数据写入内核的内存缓冲区，不需要主CPU进一步帮助。当请求read()操作时，一旦磁盘控制器完成了缓存的填写，内核从内核空间的临时缓存拷贝数据到进程指定的缓存中。</p><blockquote><p>DMA技术的出现，使得外围设备可以通过DMA控制器直接访问内存，与此同时，CPU可以继续执行程序。DMA控制器获得总线控制权后，CPU即刻挂起或只执行内部操作，由DMA控制器输出读写命令，直接控制RAM与I/O接口进行DMA传输。</p></blockquote><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote><p>虚拟<a href="https://baike.baidu.com/item/内存" target="_blank" rel="noopener">内存</a>是<a href="https://baike.baidu.com/item/计算机系统/7210959" target="_blank" rel="noopener">计算机系统</a><a href="https://baike.baidu.com/item/内存管理/5633616" target="_blank" rel="noopener">内存管理</a>的一种技术。它使得<a href="https://baike.baidu.com/item/应用程序/5985445" target="_blank" rel="noopener">应用程序</a>认为它拥有连续的可用的<a href="https://baike.baidu.com/item/内存/103614" target="_blank" rel="noopener">内存</a>（一个连续完整的<a href="https://baike.baidu.com/item/地址空间/1423980" target="_blank" rel="noopener">地址空间</a>），而实际上，它通常是被分隔成多个<a href="https://baike.baidu.com/item/物理内存/2502263" target="_blank" rel="noopener">物理内存</a>碎片，还有部分暂时存储在外部<a href="https://baike.baidu.com/item/磁盘存储器/2386684" target="_blank" rel="noopener">磁盘存储器</a>上，在需要时进行<a href="https://baike.baidu.com/item/数据交换/1586256" target="_blank" rel="noopener">数据交换</a>。</p></blockquote><p>之所以要从内核空间拷贝到最终用户空间而不直接从磁盘到用户空间是由于虚拟内存的存在。</p><p>通过将内核空间地址映射到相同的物理地址作为一个用户空间的虚拟地址。这个缓存同时对内核和用户空间进程可见。</p><h1 id="close与flush"><a href="#close与flush" class="headerlink" title="close与flush"></a>close与flush</h1><p>A:close()关闭流对象，但是<strong>先刷新一次缓冲区</strong>，关闭之后，流对象不可以继续再使用了。close（）中会调用flush。<br>B:flush()仅仅是刷新缓冲区(一般写字符时要用,因为字符是先进入的缓冲区)，流对象还可以继续使用</p><p><strong>在io中，为了提高效率，通常是在缓存区满时进行一次读写，所以对于缓存区未满的情况下需要手动调用刷新将缓存区数据取出。</strong></p><h1 id="reader、writer与Stream"><a href="#reader、writer与Stream" class="headerlink" title="reader、writer与Stream"></a>reader、writer与Stream</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>InputStream 是字节输入流的所有类的超类,一般我们使用它的子类,如FileInputStream等.一个byte一个byte的读。<br>InputStreamReader 是字节流通向字符流的桥梁,它将字节流转换为字符流.</p><p>bufferedwriter与filewriter的关系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>BufferedWriter<br>1.有缓冲区（默认8192字符=16384字节）可以通过构造方法来修改（一般不需修改）<br>2.由于有缓冲区所以效率要比FileWriter高<br>3.缓冲区能缓存8192个字符满了或者close、flush之后才会进行查码表之后再缓存在StreamEncoder的缓冲区中（8192字节）<br>4.内部是使用FileWriter来读写的<br>FileWriter<br>1.其实内部也有缓冲区（8192字节）<br>2.FileWriter效率低<br>3.来一个字符查一次码表缓冲在StreamEncoder的缓冲区中（8192字节）。</p><p>读写操作应该close的一个原因是其对文件操作会占用操作系统的文件描述符，操作系统的文件描述符有上限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-编程思想&quot;&gt;&lt;a href=&quot;#java-编程思想&quot; class=&quot;headerlink&quot; title=&quot;java 编程思想&quot;&gt;&lt;/a&gt;java 编程思想&lt;/h1&gt;&lt;h2 id=&quot;File类&quot;&gt;&lt;a href=&quot;#File类&quot; class=&quot;header
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="https://github.com/zdkswd/2019/06/05/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://github.com/zdkswd/2019/06/05/散列表/</id>
    <published>2019-06-05T12:18:47.000Z</published>
    <updated>2019-06-05T12:19:51.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h2><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>将键（关键字）转化为数组下标的映射方法就叫做<strong>散列函数</strong>（Hash函数），散列函数计算得到的值就是<strong>散列值</strong>（Hash值）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/92c89a57e21f49d2f14f4424343a2773.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数构造的设计基本要求。</p><ol><li>散列函数计算得到的散列值是一个非负整数。</li><li>如果key1=key2，那么hash(key1)==hash(key2);</li><li>如果key1≠key2，那么hash(key1)≠hash(key2)。</li></ol><p>对于第三点，即便是业界著名的MD5，SHA，CRC等哈希算法，也无法完全避免<strong>散列冲突</strong>，数组的存储空间有限，也会加大散列冲突的概率。几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，需要通过其他途径来解决。</p><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>再好的散列函数也无法避免散列冲突，常用的散列冲突解决方法有两类，<strong>开放寻址法</strong>，<strong>链表法</strong>。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突,我们就重新探测一个空闲位置,将其插入。<br>其中一个简单的实现是<strong>线性探测法</strong>：插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>黄色代表空闲，橙色代表存储了数据<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在散列表中查找元素类似于插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则就是我们要找的元素，否则就顺序往后依次查找。如果遍历到数组中的空闲位置还没有找到，就说明要查找的元素并没有在散列表中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/9126b0d33476777e7371b96e676e90ff.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，不能单纯把要删除元素设为空。<br>可以将删除的元素特殊标记为deleted。当线性探测查找遇到标记为deleted的控件，不是停下来而是继续往下探测。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>线性探测法的主要问题在于，当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间越来越久，极端下需要探测整个散列表，最坏情况时间复杂度是O(n)。同理，在删除和查找时，也有可能线性探测整张散列表，才能找到查找或者删除数据。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外,还有另外两种比较经典的探测方法，<strong>二次探测</strong>(Quadratic probing)和<strong>双重散列</strong>(Double hashing)。</p><p>所谓<strong>二次探测</strong>，跟线性探测很像，线性探测每次探测的步长是1,那它探测的下标序列就是hash(key)+0, hash(key)+1, hash(key)+2…..二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是hash(key)+0, hash(key)+1^ 2, hash(key)+2^ 2…..</p><p>所谓<strong>双重散列</strong>，意思就是不仅要使用一个散列函数。 我们使用一组散列函数 hash1(key),hash2(key)，hash3(key)….. 先用第一个散列函数， 如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>(load factor)来表示空位的多少。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-03%20%E4%B8%8B%E5%8D%887.54.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当插入时，只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度是O(1)。当查找，删除一个元素时，同样通过散列函数计算出对应的槽，这两个操作的时间复杂度与链表的长度k成正比。</p><h2 id="word文档单词拼写检查"><a href="#word文档单词拼写检查" class="headerlink" title="word文档单词拼写检查"></a>word文档单词拼写检查</h2><p>常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确;如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p><h1 id="工业级水平的散列表"><a href="#工业级水平的散列表" class="headerlink" title="工业级水平的散列表"></a>工业级水平的散列表</h1><p>散列表的查询效率不能笼统地说成是O(1)，跟散列函数、装载因子、散列冲突都有关系，如果散列函数设计不好，或装载因子过高，都可能导致散列冲突发生概率升高，查询效率下降。极端情况下，一些恶意攻击者可能通过精心构造的数据使得所有数据经过散列函数之后都散列到同一个槽里，这时散列表就会退化为链表，查询时间复杂度从O(1)退化到O(n)。</p><p>如果散列表中有10万个数据，退化后的散列表查询的效率就下降了10 万倍。更直接点说，如果之前运行100次查询只需要0.1秒，那现在就需要1万秒。这样就有可能因为查询操作消耗大量CPU或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击(DoS) 的目的。这也就是<strong>散列表碰撞攻击</strong>的基本原理。</p><h2 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h2><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。</p><p>首先，<strong>散列函数的设计不能太复杂。</strong>过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响散列表的性能。</p><p>其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><p>还需要综合考虑各种因素，包括关键字的长度，特点，分布、还有散列表的大小等。</p><p>第一个例子就是学生运动会的例子,通过分析参赛编号的特征，把编号中的后两位作为散列值。还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，可以取手机号的后四位作为散列值。这种散列函数的设计方法，一般叫作“<strong>数据分析法</strong>”。</p><p>第二个例子是Word拼写检查功能，可以将单词中每个字母的ASCII码值进位相加，然后再跟散列表的大小求余，取模，作为散列值。</p><h2 id="装载因子过大怎么办"><a href="#装载因子过大怎么办" class="headerlink" title="装载因子过大怎么办"></a>装载因子过大怎么办</h2><p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。</p><p>针对散列表，当装载因子过大时，也可以进行动态扩容，重新申请一个更大的散列表， 将数据搬移到这个新散列表中。假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了0.4。针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/67d12e07a7d673a9c1d14354ad029443.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是O(1)。最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据,所以时间复杂度是O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是O(1)。</p><p>对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空间会越来越多。如果对空间消耗敏感，可以在装载因子小于某个值后，启动动态缩容，如果更加在意执行效率，能容忍多消耗一点内存空间，就不用费劲缩容。<br>装载因子阈值需要选择得当，如果太大，会导致冲突过多，如果太小，会导致内存浪费严重。</p><h2 id="如何避免低效地扩容？"><a href="#如何避免低效地扩容？" class="headerlink" title="如何避免低效地扩容？"></a>如何避免低效地扩容？</h2><p>在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>极端如当散列表大小为1GB，想要扩容为原来的两倍大小，就要对1GB的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，十分耗时，一次搬移就会造成用户等待过久。</p><p>为了解决一次性扩容耗时过久，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表。</p><p>当有新数据要插入时，将新数据插入到新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复操作。经过多次插入操作之后，老的散列表中的数据就一点一点搬移到新散列表中了。这样没有集中的一次性数据搬移，插入操作就都变得很快了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/6d6736f986ec4b75dabc5472965fb9cb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于查询操作，先从新散列表中查找，如果没有找到，再去老的散列表查找。</p><p>通过这样的均摊方法，将一次性扩容的代价，均摊到多次插入操作，避免了一次性扩容耗时过多。任何情况下，插入一个数据的时间复杂度都是O(1)。</p><h2 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h2><p>Java中LinkedHashMap采用链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突。</p><h3 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p><strong>优点</strong>：<br>开放寻址法不像链表法,需要拉很多链表。散列表中的数据都存储在数组中,可以有效地利用CPU缓存加快查询速度。而且,这种方法实现的散列表,序列化起来比较简单。链表法包含指针,序列化起来就没那么容易。</p><p><strong>缺点</strong>：用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中， 比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p><p><strong>总结</strong>：<strong>当数据量较小，装载因子小时，适合采用开放寻址法。</strong></p><h3 id="链表法-1"><a href="#链表法-1" class="headerlink" title="链表法"></a>链表法</h3><p>因为链表节点可以在需要时再创建，并不需要事先申请好，所以链表法对内存的利用率比开放寻址法要高。</p><p>链表法对比开放寻址法对大装载因子容忍度更高。开放寻址法只适用于装载因子小于1的情况。接近1时，就可能会有大量的散列冲突。对于链表法，也只是链表长度变长了，虽然查找效率有所下降，但是比顺序查找快很多。</p><p>由于链表中的节点时零散分布在内存中不是连续的，所以对CPU缓存是不友好的，对于执行效率有一定的影响。</p><p>对链表法稍加改造就可以实现一个更加高效的散列表。将链表改造成其他高效的动态数据结构，即便出现散列冲突，极端情况下，所有数据都散列到一个桶内，最终退化的散列表查找时间也不过是O(logn)。就有效避免了散列碰撞攻击。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/103b84d7173277c5565607b413c40129.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>总结</strong>：<strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p><h2 id="工业级散列表举例"><a href="#工业级散列表举例" class="headerlink" title="工业级散列表举例"></a>工业级散列表举例</h2><p>Java中的HashMap。</p><h3 id="初始大小"><a href="#初始大小" class="headerlink" title="初始大小"></a>初始大小</h3><p>HashMap默认的初始大小是16,当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高HashMap的性能。</p><h3 id="装载因子和动态扩容"><a href="#装载因子和动态扩容" class="headerlink" title="装载因子和动态扩容"></a>装载因子和动态扩容</h3><p>最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity (capacity 表示散列表的容量)的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><h3 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h3><p>HashMap底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，- -旦出现拉链过长,则会严重影响HashMap的性能。</p><p>在JDK1.8版本中，为了对HashMap做进一步优化， 引入了红黑树。而当链表长度太长(默认超过8)时，链表就转换为红黑树。可以利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于8个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h3 id="散列函数-1"><a href="#散列函数-1" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数设计的并不复杂，追求的是简单高效，分布均匀。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-04%20%E4%B8%8B%E5%8D%889.59.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="散列表与链表"><a href="#散列表与链表" class="headerlink" title="散列表与链表"></a>散列表与链表</h1><p>散列表与链表经常放在一起使用。</p><h2 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h2><p>缓存系统包括三个操作：添加（先要查找是否存在），删除，查找数据。都需要进行查找操作。只使用链表，时间复杂度是O(n)，散列表+链表，时间复杂度O(1)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>查找：</strong>散列表中查找数据的时间复杂度接近O(1)。通过散列表，可以很快地在缓存中找到一个数据，当找到后还需要将它移动到双向链表的尾部。</p><p><strong>删除：</strong>需要找到数据所在结点，将结点删除。借助散列表，可以在O(1)时间内找到要删除的节点。因为链表是双向链表，删除结点只需要O(1)时间复杂度。</p><p><strong>添加</strong>：添加到缓存稍微有点麻烦，需要先看是否在缓存中，如果已经在其中，需要将其移动到双向链表的尾部，如果不在，就要看缓存有没有满，如果满了，则将双向链表头部结点删除，然后再将数据放到链表尾部。如果没有满就直接将数据放到链表的尾部。</p><h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><p>Redis有序集合的操作就是下面这些：<br>1.添加一个成员对象。<br>2.按照键值来删除一个成员对象。<br>3.按照键值来查找一个成员对象。<br>4.按照分值区间查找数据，比如查找在[100,356]之间的成员对象。<br>5.按照分值从小到大排序成员变量。</p><p>如果只采用跳表，按key来删除，查询就会很慢。可以再按照键值构建一个散列表，这样按照key来删除，查找一个成员对象的时间复杂度就变成了O(1)。</p><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>Linked并不仅仅代表它是通过链表法解决散列冲突的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-05%20%E4%B8%8B%E5%8D%888.01.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这段代码的打印结果是1，2，3，5.<br>每次调用put函数添加数据时，都会将数据添加到尾部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/17ac41d9dac454e454dcb289100bf198.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>插入key=3时，已存在，将原来的删除，并将新的放在尾部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/fe313ed327bcf234c73ba738d975b18c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当访问key为5时，将被访问的数据移动到链表的尾部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/b5e07bb34d532d46d127f4fcc4b78f11.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以发现与LRU缓存策略一模一样。<br><strong>LinkedHashMap是通过双向链表和散列表组合的，Linked实际是指双向链表。</strong></p><h1 id="散列表和链表"><a href="#散列表和链表" class="headerlink" title="散列表和链表"></a>散列表和链表</h1><p>为什么散列表和链表经常一块使用?</p><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表(或者跳表)结合在一起使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列表&lt;/h1&gt;&lt;h2 id=&quot;散列思想&quot;&gt;&lt;a href=&quot;#散列思想&quot; class=&quot;headerlink&quot; title=&quot;散列思想&quot;&gt;&lt;/a&gt;散列思
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳表</title>
    <link href="https://github.com/zdkswd/2019/05/31/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://github.com/zdkswd/2019/05/31/跳表/</id>
    <published>2019-05-31T12:56:47.000Z</published>
    <updated>2019-05-31T12:56:35.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>二分查找是依赖数组随机访问的特性。如果数据是存储在链表中，则要对链表进行改造，支持类似二分的查找算法。改造后的数据结构叫做<strong>跳表</strong>。</p><p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>。可以支持快速的插入删除查找，甚至可以替代红黑树。</p><p>Redis中的有序集合(Sorted Set)就是用跳表来实现的。</p><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>对于单链表查找数据只能从头到尾遍历，O(n)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/14753c824a5ee4a976ea799727adc78e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>加上一层索引之后，查找一个结点需要遍历的结点数减少了，也就是查找效率提高了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/492206afe5e2fef9f683c7cff83afa65.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当链表的长度比较大时，在构建索引之后，查找效率的提升就会非常明显。</p><p><strong>这种链表加多级索引的结构就是跳表。</strong></p><h2 id="用跳表查询到底有多快"><a href="#用跳表查询到底有多快" class="headerlink" title="用跳表查询到底有多快"></a>用跳表查询到底有多快</h2><p>O(logn)</p><h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>等比数列求和。空间复杂度还是O(n)。<br>在实际的软件开发中，原始链表存储的可能是很大的对象，索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引节点大很多时，索引占用的额外空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>插入操作时间复杂度也是O(logn)。先要查找要插入的位置，再插入结点。<br>删除操作是，如果这个结点在索引中也有出现，除了删除原始链表汇总的结点，还要删除索引中的。在查找要删除的结点的时候，一定要获取前驱结点。如果使用的是双向链表，就不用考虑这个问题。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/c863074c01c26538cf0134eaf8dc67c5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果不停插入数据而不更新索引，就有可能出现某两个索引节点之间数据非常多的情况，极端情况下，跳表会退化为单链表。</p><p>可以通过<strong>随机函数</strong>来维护平衡性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/a861445d0b53fc842f38919365b004a7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>随机函数生成了值K，那么久将这个结点添加到第一级到第K级这K级索引中。</p><p>Redis有序集合支持的核心操作包括：（1）插入（2）删除（3）查找（4）按照区间查找数据（5）迭代输出有序序列</p><p>其中,插入、删除、查找以及迭代输岀有序序列这几个操作,红黑树也可以完成,时间复杂度跟跳表是一样的。但是,按照区间来查找数据这个操作,红黑树的效率没有跳表高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跳表&quot;&gt;&lt;a href=&quot;#跳表&quot; class=&quot;headerlink&quot; title=&quot;跳表&quot;&gt;&lt;/a&gt;跳表&lt;/h1&gt;&lt;p&gt;二分查找是依赖数组随机访问的特性。如果数据是存储在链表中，则要对链表进行改造，支持类似二分的查找算法。改造后的数据结构叫做&lt;strong&gt;跳
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring实战  Spring核心</title>
    <link href="https://github.com/zdkswd/2019/05/30/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/"/>
    <id>https://github.com/zdkswd/2019/05/30/Spring实战  Spring核心/</id>
    <published>2019-05-30T12:07:47.000Z</published>
    <updated>2019-05-30T12:10:43.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简要概念"><a href="#简要概念" class="headerlink" title="简要概念"></a>简要概念</h1><p> <strong>依赖注入</strong><br>方式1：构造器注入。</p><p>创建应用组件之间协作行为通常称为<strong>装配(wiring)</strong>。<br>可以用xml或java实现。</p><p>Spring通过<strong>应用上下文(Application Context)</strong>装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p><p>对于XML使用CLassPathXMLApplication，对于Java配置，使用AnnotationConfigApplicationContext。</p><hr><p> <strong>应用切面</strong><br>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</p><p>可以把切面想象为覆盖在很多组件上的一个外壳。应用是由那些实现各自业务功能的模块组成的。</p><p>可以在xml中将某个bean声明为一个切面。</p><hr><p><strong>使用模板消除样板式代码</strong><br>比如jdbcTemplate。</p><hr><p><strong>容纳Bean</strong><br>在基于Spring的应用中，应用对象生存于Spring容器(container)中。Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡。</p><p>容器是 Spring框架的核心。 Spring容器使用DI管理构成应用的组件,它会创建<br>相互协作的组件之间的关联。毫无疑问,这些对象更简单干净,更易于理解,更易于重用并且更易于进行单元测试。</p><p>spring自带了多种容器实现，归为两种类型，bean工厂与应用上下文。bean工厂对于大多数应用来说往往太低级，因此，应用上下文要比bean工厂更受欢迎。</p><hr><p><strong>使用应用上下文</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%884.24.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>无论是从文件系统中装载应用上下文还是从类路径下装载应用上下文，将bean加载到bean工厂的过程都是相似的。区别在于前者在指定的文件系统路径下查找xml文件，后者是在所有的类路径(包括JAR文件)下查找xml文件。AnnotationConfigApplicationContext通过一个配置类加载bean。<br>应用上下文准备就绪之后，就可以调用上下文的getBean()方法从Spring容器中获取bean。</p><hr><p><strong>bean的生命周期</strong><br>在传统的Java应用中,bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%884.34.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%885.52.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>Spring核心容器</strong><br>容器是Spring框架最核心的部分，它管理着Spring 应用中bean的创建、配置和管理。在该模块中，包括了Spring bean 工厂，它为Spring提供了DI的功能。基于bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。所有的Spring模块都构建于核心容器之上，当配置应用时，其实隐式地使用了这些类。</p><p><strong>Spring的AOP模块</strong><br>在AOP模块中，Spring 对面向切面编程提供了丰富的支持。这个模块是Spring 应用系统中开发切面的基础。与DI一样, AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点(例如事务和安全)从它们所应用的对象中解耦出来。</p><h1 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h1><p>在Spring中，对象无需自己查找或创建与其所关联的其他对象。容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间协作关系的行为称为装配，也是依赖注入的本质。</p><h2 id="Spring配置的可选方案"><a href="#Spring配置的可选方案" class="headerlink" title="Spring配置的可选方案"></a>Spring配置的可选方案</h2><p>Spring提供三种主要的装配机制：</p><ol><li>在XML中进行显式配置；</li><li>在java中进行显式配置；</li><li>隐式地bean发现机制和自动装配。</li></ol><p>作者建议尽可能地使用自动配置机制，显式配置越少越好，当必须要显式配置bean时，推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有想使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。</p><h2 id="自动化装配bean"><a href="#自动化装配bean" class="headerlink" title="自动化装配bean"></a>自动化装配bean</h2><p>Spring从两个角度来实现自动化装配：</p><ol><li>组件扫描(component scanning):Spring会自动发现应用上下文中所创建的bean。</li><li>自动装配(autowiring):Spring自动满足bean之间的依赖。</li></ol><p>组件扫描和自动装配组合在一起就能发挥出强大的威力，能够将显式配置降低到最少。</p><h3 id="创建可被发现的bean"><a href="#创建可被发现的bean" class="headerlink" title="创建可被发现的bean"></a>创建可被发现的bean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%886.54.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>@Component</strong>注解表明该类会作为组件类，并告知Spring要为这个类创建bean。</p><p>不过组件扫描默认是不启用的，还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.19.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@ComponentScan</strong>注解可以在Spring中启用组件扫描。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包，Spring将会扫描这个包以及包下的所有子包，查找带有@Component注解的类并且在Spring中自动为其创建一个bean。</p><p>还可以使用XML来启动组件扫描。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.27.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还是基于Java的配置用的多，喜好问题。</p><p>一个实例：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.31.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@ContextConfiguration</strong>注解说明需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类中包括了<strong>@ComponentScan</strong>,所有带有@Component注解的类都会创建为bean。</p><h3 id="为组件扫描的bean命名"><a href="#为组件扫描的bean命名" class="headerlink" title="为组件扫描的bean命名"></a>为组件扫描的bean命名</h3><p>Spring应用上下文中所有的bean都会给定一个ID，就是将类名的第一个字母变为小写。也可以使用@Component为bean设置不同的ID。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.52.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="设置组件扫描的基础包"><a href="#设置组件扫描的基础包" class="headerlink" title="设置组件扫描的基础包"></a>设置组件扫描的基础包</h3><p>默认扫描的是配置类所在的包作为基础包(base package)来扫描组件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.59.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以指定多个包，扫描多个包。但是basePackages有一个问题是其是字符串，所以当包不存在时IDE也不会第一时间报错。可以设置basePackageClasses,设置数组中包含了类，这些类所在的包将会作为组件扫描的基础包。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%888.05.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="通过为bean添加注解实现自动装配"><a href="#通过为bean添加注解实现自动装配" class="headerlink" title="通过为bean添加注解实现自动装配"></a>通过为bean添加注解实现自动装配</h3><p>自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。可以借助<strong>@Autowired</strong>注解进行自动装配。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%888.58.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Autowired</strong>注解不仅能够用在构造器上，还能用在属性的Setter方法上。如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%889.01.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在Spring初始化bean之后，会尽可能去满足bean的依赖。不管是构造器，Setter还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖，假设有且只有一个bean匹配依赖的话，那么这个bean将会被装配进来，如果没有匹配的bean，那么在应用上下文创建时，Spring会抛出一个异常，也可以将@Autowired的required属性设置为false避免抛异常，当设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态，此时需要谨慎对待这个bean，如果代码没有进行null检查的话，这个处于未装配的属性有可能会出现NullPointerException。</p><p>如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。</p><p>@Autowired是Spring特有的注解。如果你不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，可以考虑将其替换为@Inject。<br>@Inject注解来源于Java依赖注入规范，该规范同时还定义了@Named注解。在自动装配中，Spring 同时支持@Inject和@Autowired. 尽管@Inject和@Autowired之间有着一些细微的差别, 但是在大多数场景下，它们都是可以互相替换的。</p><h2 id="通过Java代码装配bean"><a href="#通过Java代码装配bean" class="headerlink" title="通过Java代码装配bean"></a>通过Java代码装配bean</h2><p>尽管在很多场景下通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如说，想要将第三方库中的组件装配到应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。</p><p>此时就需要采用显示装配的方式，分为Java和XML。在进行显式配置时，JavaConfig是更好的方案，因为其更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。同时JavaConfig与其他的Java代码又有所区别，JavaConfig是配置代码，这意味着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码之中，通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开。</p><h3 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h3><p>创建JavaConfig类的关键在于为其添加<strong>@Configuration</strong>注解，<strong>@Configuration</strong>注解表明这个类是一个配置类, 该类应该包含在Spring应用上下文中如何创建bean的细节。对于显式配置，将@ConponentScan注解移除。此时那些bean不会被发现，配置类也没有作用了。</p><h3 id="声明简单的bean"><a href="#声明简单的bean" class="headerlink" title="声明简单的bean"></a>声明简单的bean</h3><p>要在JavaConfig中声明bean，需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%889.29.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Bean</strong>注解告诉Spring方法返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。</p><h3 id="借助JavaConfig实现注入"><a href="#借助JavaConfig实现注入" class="headerlink" title="借助JavaConfig实现注入"></a>借助JavaConfig实现注入</h3><p>在JavaConfig中装配bean的最简单方式就是引用创建bean的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%889.33.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过调用方法来引用bean令人困惑，还有一种理解起来更为简单的方式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%889.36.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里使用构造器实现了DI功能，但是完全可以使用其他风格的DI配置，比如可以通过Setter方法注入：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.04.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例。构造器和Setter方法只是@Bean方法的两个简单样例。</p><h2 id="通过XML装配bean"><a href="#通过XML装配bean" class="headerlink" title="通过XML装配bean"></a>通过XML装配bean</h2><p>在装配bean时还可以选择XML，现在已经不太合乎大家的心意了，但是在Spring中已经有很长的历史了。</p><h3 id="创建XML配置规范"><a href="#创建XML配置规范" class="headerlink" title="创建XML配置规范"></a>创建XML配置规范</h3><p>在XML配置中，意味着要创建一个XML文件。并且要以<beans>元素为根。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.10.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></beans></p><h3 id="声明一个简单的"><a href="#声明一个简单的" class="headerlink" title="声明一个简单的"></a>声明一个简单的<bean></bean></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.16.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="借助构造器注入初始化bean"><a href="#借助构造器注入初始化bean" class="headerlink" title="借助构造器注入初始化bean"></a>借助构造器注入初始化bean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.18.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="导入和混合配置"><a href="#导入和混合配置" class="headerlink" title="导入和混合配置"></a>导入和混合配置</h2><p>关于混合配置，首先不要在意装配的bean来自哪里，自动装配会考虑到Spring容器中所有bean，不管是在JavaConfig或XML中声明还是组件扫描获得的。</p><h3 id="在JavaConfig中引用XML配置"><a href="#在JavaConfig中引用XML配置" class="headerlink" title="在JavaConfig中引用XML配置"></a>在JavaConfig中引用XML配置</h3><p>可以有一个更高级别的配置类，在类中使用<strong>@Import</strong>将两个配置类组合在一起：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.58.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.57.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>假如配置在了XML中，则Spring可以使用<strong>@ImportResource</strong>注解加载。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8811.00.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两个bean，配置在JavaConfig中以及配置在XML中都会被加载到Spring容器中。</p><h3 id="在XML配置中引入JavaConfig"><a href="#在XML配置中引入JavaConfig" class="headerlink" title="在XML配置中引入JavaConfig"></a>在XML配置中引入JavaConfig</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%881.41.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不管使用JavaConfig还是使用XML进行装配，通常都会创建一个根配置(root configuration)，这个配置会将两个或更多的装配类和或XML文件组合起来。也会在根配置中启用组件扫描(通过<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>或@ComponentScan)。</p><h1 id="高级装配"><a href="#高级装配" class="headerlink" title="高级装配"></a>高级装配</h1><h2 id="环境与profile"><a href="#环境与profile" class="headerlink" title="环境与profile"></a>环境与profile</h2><h3 id="配置profile-bean"><a href="#配置profile-bean" class="headerlink" title="配置profile bean"></a>配置profile bean</h3><p>要使用profile，首先要讲所有不同的bean定义整理到一个或多个profile之中，将应用部署到每个环境时，要确保对应的profile处于激活(active)的状态。在Java配置中，可以使用<strong>@Profile</strong>注解指定某个bean属于哪个profile。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%881.54.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Profile</strong>注解应用在了类级别上，它会告诉Spring这个配置类中的bean只有在dev profile激活时才会被创建，如果没有激活的话，那么带有@Bean注解的方法都会被忽略掉。</p><h3 id="在XML中配置profile"><a href="#在XML中配置profile" class="headerlink" title="在XML中配置profile"></a>在XML中配置profile</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%882.01.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="激活profile"><a href="#激活profile" class="headerlink" title="激活profile"></a>激活profile</h3><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性:spring.profiles.active和spring.profiles.default. 如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile 是激活的。但如果没有设置spring .profiles.active属性的话，那Spring 将会查找spring.profiles.default的值。如果spring.profiles.active 和spring.profiles.default均没有设置的话，那就没有激活的profile,因此只会创建那些没有定义在profile中的bean。</p><p>有多种方式来设置这两个属性：<br>1.作为DispatcherServlet的初始化参数;<br>2.作为Web应用的上下文参数;<br>3.作为JNDI条目;<br>4.作为环境变量;<br>5.作为JVM的系统属性;<br>6.在集成测试类上，使用@ActiveProfiles注解设置。</p><h2 id="条件化的bean"><a href="#条件化的bean" class="headerlink" title="条件化的bean"></a>条件化的bean</h2><p><strong>@Conditional</strong>注解可以用到带有@Bean注解的方法上，如果给定的条件计算结果为true，就会创建这个bean，否则，这个bean会被忽略。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%882.12.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>设置给<strong>@Conditional</strong>的类可以是任意实现了Condition接口的类型。这个接口实现起来很简单直接，只需提供matches()方法实现即可。如果matches()方法返回true，就会创建带有<strong>@Conditional</strong>注解的bean，返回false则不会创建这些bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.10.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过ConditionContext，可以做到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.15.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>AnnotatedTypeMetadata则能够让我们检查带有@Bean注解的方法还有其他什么注解。借助isAnnotated()方法，我们能够判断带有@Bean注解的方法是不是还有其他特定的注解。借助其他的那些方法,我们能够检查@Bean注解的方法上其他注解的属性。</p><p>@Profile注解如下所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.40.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>@Profile本身也使用了@Conditional注解，并且在做出决策的过程中，考虑到了ConditionContext和AnnotatedTypeMetadata中的多个因素。</p><h2 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h2><p>仅有一个bean匹配所需的结果时，自动装配才是有效的，如果不仅有一个bean能匹配结果的话，这种歧义性会阻碍Spring自动装配属性，构造器参数或方法参数。可以将可选bean中的某一个设为首选(primary)的bean，或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。</p><h3 id="标示首选的bean"><a href="#标示首选的bean" class="headerlink" title="标示首选的bean"></a>标示首选的bean</h3><p>使用<strong>@Primary</strong>注解<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.52.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果是通过Java配置显式声明，应该如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.54.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用XML<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.12.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="限定自动装配的bean"><a href="#限定自动装配的bean" class="headerlink" title="限定自动装配的bean"></a>限定自动装配的bean</h3><p>Spring的限定符能够在所有可选的bean上进行缩小范围的操作,最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性,那么可以继续使用更多的限定符来缩小选择范围。</p><p>@Qualifier注解是使用限定符的主要方式，它可以与<strong>@Autowired</strong>和<strong>@Inject</strong>协同使用，在注入时指定想要注入进去的是哪个bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.42.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>@Qualifier注解所设置的参数就是想要注入的bean的ID。</p><h3 id="创建自定义的限定符"><a href="#创建自定义的限定符" class="headerlink" title="创建自定义的限定符"></a>创建自定义的限定符</h3><p>自己为bean设置自己的限定符。在bean声明上添加<strong>@Qualifier</strong>注解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.43.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在注入的地方，只要引用cold限定符就可以了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.46.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过Java配置显式定义bean时，@Qualifier也可以与@Bean注解一起使用：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.47.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用自定义的限定符注解"><a href="#使用自定义的限定符注解" class="headerlink" title="使用自定义的限定符注解"></a>使用自定义的限定符注解</h3><p>比如自定义<strong>@Cold</strong>注解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在注入点使用必要的限定符注解进行任意组合，从而将可选范围缩小到只有一个bean满足需求。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.07.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过声明自定义的限定符注解，可以同时使用多个限定符。</p><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><p>在默认情况下，Spring 应用上下文中所有bean都是作为以单例(singleton) 的形式创建的。也就是说，不管给定的一个bean被注人到其他bean多少次，每次所注入的都是同一个实例。</p><p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括：<br>1.单例( Singleton):在整个应用中，只创建bean的一个实例。<br>2.原型( Prototype):每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。<br>3.会话(Session): 在Web应用中，为每个会话创建一个bean实例。<br>4.请求(Rquest):在Web应用中，为每个请求创建一个bean实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.30.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里使用ConfigurableBeanFactory类的SCOPE_ PROTOTYPE 常量设置了原型作用城。当然也可以使用@Scope (“prototype”),但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。</p><p>java配置中声明为原型bean则使用：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.44.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>XML配置bean，使用<bean>元素的scope属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.46.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></bean></p><h3 id="使用会话和请求作用域"><a href="#使用会话和请求作用域" class="headerlink" title="使用会话和请求作用域"></a>使用会话和请求作用域</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.50.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>就购物车bean而言，会话作用域是最为合适的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.00.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>proxyMode</strong>属性的配置表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean。<br>如果ShoppingCart是接口而不是类的话，这是可以的(最为理想的代理模式)。但如果ShoppingCart是一个具体的类的话, Spring 就没有办法创建基于接口的代理了。此时，它必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体类的话,我们必须要将proxyMode属性设置为ScopedProxyMode .TARGET_ CLASS,以此来表明要以生成目标类扩展的方式创建代理。</p><h3 id="在XML中声明作用域代理"><a href="#在XML中声明作用域代理" class="headerlink" title="在XML中声明作用域代理"></a>在XML中声明作用域代理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.11.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><a href="aop:scoped-proxy" target="_blank" rel="noopener">aop:scoped-proxy</a>是与@Scope注解的proxyMode属性功能相同的SpringXML配置元素。它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLib创建目标类的代理。但是我们也可以将proxy-target-class 属性设置为false,进而要求它生成基于接口的代理。</p><h2 id="运行时值注入"><a href="#运行时值注入" class="headerlink" title="运行时值注入"></a>运行时值注入</h2><p>当讨论依赖注入的时候，我们通常所讨论的是将一个 bean引用注入到另一个bean的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象进行关联。</p><p>bean装配的另外一个方面指的是将一个值注入到bean的属性或者构造器参数中。Spring提供了两种在运行时求值的方式：<br>1.属性占位符<br>2.Spring表达式语言(SpEL)</p><h3 id="注入外部的值"><a href="#注入外部的值" class="headerlink" title="注入外部的值"></a>注入外部的值</h3><p>处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.55.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.55.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="解析属性占位符"><a href="#解析属性占位符" class="headerlink" title="解析属性占位符"></a>解析属性占位符</h3><p>Spring一直支持将属性定义到外部的属性的文件中，并使用占位符值将其插入到Spring bean中，占位符的形式为”${…}”<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%887.02.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XML配置没有使用任何硬编码的值。</p><h3 id="使用Spring表达式语言进行装配"><a href="#使用Spring表达式语言进行装配" class="headerlink" title="使用Spring表达式语言进行装配"></a>使用Spring表达式语言进行装配</h3><h1 id="面向切面的Spring"><a href="#面向切面的Spring" class="headerlink" title="面向切面的Spring"></a>面向切面的Spring</h1><p>在软件开发中，散布于应用多处的功能被称为横切关注点。这些横切关注点从概念上是与应用的业务逻辑相分离的。把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。</p><h2 id="什么是面向切面编程"><a href="#什么是面向切面编程" class="headerlink" title="什么是面向切面编程"></a>什么是面向切面编程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8A%E5%8D%8810.14.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果要重用通用功能的话，最常见的面向对象技术是继承或委托。但是如果在应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系；使用委托可能需要对委托对象进行复杂得调用。切面提供了取代继承和委托的另一种可选方案，在很多场景下更清晰简洁，在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面。</p><p>这样做有两个好处:首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中;其次，服务模块更简洁，因为它们只包含主要关注点(或核心功能)的代码，而次要关注点的代码被转移到切面中了。</p><h3 id="定义AOP术语"><a href="#定义AOP术语" class="headerlink" title="定义AOP术语"></a>定义AOP术语</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8A%E5%8D%8810.27.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>通知(Advice)：</strong><br>在AOP术语中，切面的工作被称为通知。<br>Spring切面可以应用5种类型的通知：</p><ol><li>前置通知(Before):在目标方法被调用之前调用通知功能;</li><li>后置通知(After): 在目标方法完成之后调用通知，此时不会关心方法的输出是什么;</li><li>返回通知(After-returning):在目标方法成功执行之后调用通知;</li><li>异常通知( After-throwing):在目标方法抛出异常后调用通知;</li><li>环绕通知( Around):通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ol><p><strong>连接点(Join point):</strong><br>切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p><strong>切点(Poincut):</strong><br>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。</p><p><strong>切面(Aspect):</strong><br>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容一它是什么 ,在何时和何处完成其功能。</p><p><strong>引入(Introduction):</strong><br>引入允许我们向现有的类添加新方法或属性。</p><p><strong>织入(Weaving):</strong><br>织人是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入:</p><ol><li>编译期:切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期:切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入( load-time weaving, LTW )就支持以这种方式织入切面。</li><li>运行期:切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ol><h3 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h3><p>Spring 提供了4种类型的AOP支持:</p><ol><li>基于代理的经典Spring AOP;</li><li>纯POJO切面;</li><li>@AspectJ注解驱动的切面; </li><li>注入式AspectJ切面( 适用于Spring各版本)。</li></ol><hr><p><strong>Spring通知是Java编写的</strong><br>Spring所创建的通知都是用标准的Java类编写的。可以使用与普通Java开发一样的(IDE) 来开发切面。定义通知所应用的切点通常会使用注解或在Spring配置文件里采用XML来编写,这两种语法对于Java开发者来说都是相当熟悉的。</p><p>AspectJ与之相反。虽然AspectJ现在支持基于注解的切面,但AspectJ 最初是以Java语言扩展的方式实现的。这种方式有优点也有缺点。通过特有的AOP语言，可以获得更强大和细粒度的控制，以及更丰富的AOP工具集，但是需要额外学习新的工具和语法。</p><hr><p><strong>Spring在运行时通知对象</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%8812.42.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法前，会执行切面逻辑。</p><p>直到应用需要被代理的bean 时，Spring 才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring 才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织人Spring AOP的切面。</p><hr><p><strong>Spring只支持方法级别的连接点</strong><br>因为Spring基于动态代理，所以Spring只支持方法连接点。这与一些其他的AOP框架是不同的，例如AspectJ和JBoss，除了方法切点，还提供了字段和构造器接入点。Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，无法在bean创建时应用通知。</p><p>但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么我们可以利用Aspect来补充Spring AOP的功能。</p><h2 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h2><p>在SpringAOP中，要使用AspectJ的切点表达式语言来定义切点。</p><h3 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.13.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.13.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用execution ()指示器选择Performance的perform()方法。方法表达式以“*”号开始，表明不关心方法返回值的类型。然后指定了全限定类名和方法名。对于方法参数列表，使用两个点好(..)表明切点要选择任意的perform()方法，无论该方法的入参是什么。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.18.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="在切点中选择bean"><a href="#在切点中选择bean" class="headerlink" title="在切点中选择bean"></a>在切点中选择bean</h3><p>Spring引入一个新的bean()指示器，允许在切点表达式中使用bean的ID来标识bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.39.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h2><h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.44.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.45.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以使用<strong>@Pointcut</strong>注解设置一个切点表达式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.48.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>performance ()方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供@Pointcut注解依附。</p><p>接下来在JavaConfig的配置类级别上通过使用<strong>@EnableAspectJAutoProxy</strong>注解启动自动代理功能。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%883.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XML装配bean需要使用Spring aop。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%883.03.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h3><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.13.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Around</strong>注解表明方法作为切点的环绕通知。这个通知所达到的效果与之前的前置通知和后置通知是一样的。现在它们在同一个方法中，不像之前分散。</p><p>它接受ProceedingJoinPoint作为参数。这个对象是必须要有的，因为要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用ProceedingJoinPoint的proceed()方法。</p><p>别忘记调用proceed()方法，如果不调用这个方法，通知实际上会阻塞对被通知方法的调用。</p><h3 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.37.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.37.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h3><p>利用被称为引入的AOP概念，切面可以为Spring bean添加新方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.50.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.01.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@DeclareParents</strong>注解由三部分组成：<br>1.value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现Performance的类型。(标记符后面的加号表示是Performance的所有子类型，而不是Performance本身。)<br>2.defaultImpl属性指定了为引入功能提供实现的类。在这里，我们指定的是De faultEncoreable提供实现。<br>3.@DeclareParents注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是Encoreable接口。</p><h2 id="在XML中声明切面"><a href="#在XML中声明切面" class="headerlink" title="在XML中声明切面"></a>在XML中声明切面</h2><p>如果需要声明切面，但又不能Wie通知类添加注解时，就必须转向XML配置了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.37.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>定义命名切点<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.41.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.41.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在切点是在一个地方定义的，并且被多个通知元素所引用。</p><h3 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.48.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.48.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.51.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.51.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.52.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.54.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>delegate-ref属性引用了一个Spring bean作为引入的委托。这需要在Spring上下文中存在一个ID为encoreableDelegate的bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.57.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用default-impl来直接标识委托和间接使用delegate-ref 的区别在于后者是Spring bean,它本身可以被注人、通知或使用其他的Spring配置。</p><h2 id="注入AspectJ切面"><a href="#注入AspectJ切面" class="headerlink" title="注入AspectJ切面"></a>注入AspectJ切面</h2><p>虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP是一个功能比较弱的AOP解决方案。AspectJ提供了Spring AOP所不能支持的许多类型的切点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>AOP是面向对象编程的一个强大补充。通过AspectJ,我们现在可以把之前分散在应用各处的行为放人可重用的模块中。我们显示地声明在何处如何应用该行为。这有效减少了代码冗余，并让我们的类关注自身的主要功能。</p><p>Spring提供了一个AOP框架，让我们把切面插人到方法执行的周围。现在我们已经学会如何把通知织人前置、后置和环绕方法的调用中，以及为处理异常增加自定义的行为。</p><p>关于在Spring应用中如何使用切面，我们可以有多种选择。通过使用@AspectJ注解和简化的配置命名空间，在Spring中装配通知和切点变得非常简单。</p><p>最后，当Spring AOP不能满足需求时，我们必须转向更为强大的AspectJ。对于这些场景，我们了解了如何使用Spring为AspectJ切面注入依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简要概念&quot;&gt;&lt;a href=&quot;#简要概念&quot; class=&quot;headerlink&quot; title=&quot;简要概念&quot;&gt;&lt;/a&gt;简要概念&lt;/h1&gt;&lt;p&gt; &lt;strong&gt;依赖注入&lt;/strong&gt;&lt;br&gt;方式1：构造器注入。&lt;/p&gt;
&lt;p&gt;创建应用组件之间协作行为通常称为&lt;s
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
      <category term="Spring" scheme="https://github.com/zdkswd/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Android梳理</title>
    <link href="https://github.com/zdkswd/2019/05/27/Android%E6%A2%B3%E7%90%86/"/>
    <id>https://github.com/zdkswd/2019/05/27/Android梳理/</id>
    <published>2019-05-27T07:28:47.000Z</published>
    <updated>2019-05-27T07:29:41.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h2><p>其核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。要使用多态，在声明对象时就应该遵循一条法则：声明的总是父类类型或接口类型，创建的是实际类型。</p><blockquote><p>List list =newArrayList(); ✔️<br>ArrayList list =newArrayList(); ❎  </p></blockquote><p>在定义方法参数时也通常总是应该优先使用父类类型或接口类型。</p><blockquote><p>publicvoid doSomething(List list);✅<br>publicvoid doSomething(ArrayList list);❎  </p></blockquote><p>这样声明最大的好处在于结构的灵活性：假如某一天我认为ArrayList的特性无法满足我的要求，我希望能够用LinkedList来代替它，那么只需要在对象创建的地方把new ArrayList()改为new LinkedList即可，其它代码一概不用改动。</p><p>虚拟机会在执行程序时动态调用实际类的方法，它会通过一种名为动态绑定（又称延迟绑定）的机制自动实现，这个过程对程序员来说是透明的。</p><h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/u=2881300128,2318356091&fm=173&app=25&f=JPEG.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Throwable 是所有异常类型的基类，Throwable 下一层分为两个分支，Error 和 Exception.</p><p>Error 描述了 JAVA 程序运行时系统的内部错误，通常比较严重，除了通知用户和尽力使应用程序安全地终止之外，无能为力，应用程序不应该尝试去捕获这种异常。通常为一些虚拟机异常，如 StackOverflowError 等。</p><p>Exception 类型下面又分为两个分支，一个分支派生自 RuntimeException，这种异常通常为程序错误导致的异常；另一个分支为非派生自 RuntimeException 的异常，这种异常通常是程序本身没有问题，由于像 I/O 错误等问题导致的异常，每个异常类用逗号隔开。</p><p>受查异常<br>受查异常会在编译时被检测。如果一个方法中的代码会抛出受查异常，则该方法必须包含异常处理，即 try-catch 代码块，或在方法签名中用 throws 关键字声明该方法可能会抛出的受查异常，否则编译无法通过。</p><blockquote><p>private static void readFile(String filePath) throws IOException {  </p></blockquote><p>非受查异常不会在编译时被检测。JAVA 中 Error 和 RuntimeException 类的子类属于非受查异常，除此之外继承自 Exception 的类型为受查异常。</p><p>处理RuntimeException的原则是：如果出现RuntimeException，那么一定是程序员的错误。受检查的异常（IOException等）：这类异常如果没有try……catch也没有throws抛出，编译是通不过的。这类异常一般是外部错误，例如文件找不到、试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。</p><h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><h3 id="8种基本数据类型（所占字节数）"><a href="#8种基本数据类型（所占字节数）" class="headerlink" title="8种基本数据类型（所占字节数）"></a>8种基本数据类型（所占字节数）</h3><p>byte(1) char(2) short(2) int(4) float(4) double(8) long(8) boolean(1)<br>boolean类型比较特别，多个boolean可能共同占用一个字节。 </p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String不是基本数据类型，是引用类型，底层用char数组实现的，因为String是final类，在java中被final修饰的类不能被继承，因此String不可以被继承。</p><h2 id="Java的IO"><a href="#Java的IO" class="headerlink" title="Java的IO"></a>Java的IO</h2><h3 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h3><p>首先明确“字节（Byte）”和“字符（Character）”的大小：<br>1 byte = 8 bit<br>1 char = 2 byte = 16 bit (Java默认UTF-16编码)</p><p>总而言之，一切都是字节流，其实没有字符流这个东西。字符只是根据编码集对字节流翻译之后的产物。面向字节流的InputStream和OutputStream<br>面向字符的Reader和Writer，即为字节流继承于InputStream和OutputStream，字符流继承于InputStreamReader和OutputStreamWriter。</p><h3 id="字节流转字符流"><a href="#字节流转字符流" class="headerlink" title="字节流转字符流"></a>字节流转字符流</h3><p>字节输入流转字符输入流通过InputStreamReader实现,该类的构造函数可以传入InputStream对象。字节输出流转字符输出流通过OutputStreamWriter实现,该类的构造函数可以传入OutputStream对象。</p><h3 id="将java对象序列化到文件"><a href="#将java对象序列化到文件" class="headerlink" title="将java对象序列化到文件"></a>将java对象序列化到文件</h3><p>在java中能够被序列化的类必须先实现Serializable接口，该接口没有任何抽象方法只是起到一个标记作用。当试图对一个对象进行序列化的时候，如果该对象没有实现 Serializable 接口，将抛出NotSerializableException<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%889.43.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%889.44.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>s​e​r​i​a​l​V​e​r​s​i​o​n​U​I​D​:​ ​字​面​意​思​上​是​序​列​化​的​版​本​号​，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量</p><p>显式地定义serialVersionUID有两种用途：<br>1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p><h2 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h2><p>容器Container，和Array的最大区别就是它们的长度都是自动变化的，根本无需你干预。<br>Container 从总体上来看分为两类，一类叫做集合Collection ，另一类则叫做映射Map。<br>区别很简单在Map中，对象必须是成对存放的，这个对就叫做key-value，而集合则不是。集合又分为集<strong>Set</strong>、序列<strong>List</strong>和队列<strong>Queue</strong>。向Map中添加元素的方法是put(K key, V value)，而向Collection中添加则是add(E e)。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>集Set、序列List和队列Queue 之所以说他们属于Collection，是因为他们都实现了Collection这个interface。并且他们也不是“实现类”，而是interface，他们并不能直接使用。</p><h3 id="对集合排序"><a href="#对集合排序" class="headerlink" title="对集合排序"></a>对集合排序</h3><p>凡是对集合的操作，应该保持一个原则就是能用JDK中的API就用JDK中的API，比如排序算法不应去用冒泡或者选择排序，而是首先想到用Collections集合工具类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/2C0DE4ED-7B71-4EF6-8D65-EE2586A71797.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Collection常用的方法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8A%E5%8D%889.15.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="集合的实现类"><a href="#集合的实现类" class="headerlink" title="集合的实现类"></a>集合的实现类</h3><p>List：ArrayList(数组实现) LinkedList（链表实现）</p><p>Set：HashSet TreeSet LinkedHashMap （三种与Map实现类相同）<br>Set的特点是元素不能重复，在元素添加过程中，最重要的一个步骤就是进行对比，将对象通过Hash后对比速度飞起。</p><p>Queue：ArrayDeque(双端队列) PriorityQueue(保证最小的在顶上，并不是全部排序)</p><h3 id="集合的安全性问题"><a href="#集合的安全性问题" class="headerlink" title="集合的安全性问题"></a>集合的安全性问题</h3><p>ArrayList,HashSet,HashMap不是没有加锁，显然都是线程不安全的。</p><p>在集合中 Vector和 HashTable倒是线程安全的。你打开源码会发现其实就是把各自核心方法添加上了<strong>synchronized</strong>关键字</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-1448f5b62001bb691d1577ab574d3d13_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>单看Key，不就是Set吗，Set就是用Map实现的，可以说Set是Map的一种特殊应用。Map中也有一个叫做KeySet()的方法，直接返回一个Set。</p><h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="创建的两种方式"><a href="#创建的两种方式" class="headerlink" title="创建的两种方式"></a>创建的两种方式</h3><p>java.lang.Thread类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行,由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread类或者直接实现Runnable接口来重写run()方法实现线程。</p><h3 id="sleep和wait"><a href="#sleep和wait" class="headerlink" title="sleep和wait"></a>sleep和wait</h3><p>最大的不同是在等待时wait会释放锁,而sleep 一直持有锁。wait通常被用于线程间交互, sleep通常被用于暂停执行。</p><h3 id="synchronized和volatile关键字"><a href="#synchronized和volatile关键字" class="headerlink" title="synchronized和volatile关键字"></a>synchronized和volatile关键字</h3><p>一旦一个共享变量(类的成员变量、类的静态成员变量)被<strong>volatile</strong>修饰之后,那么就具备了两层语义:<br>1 )保证了不同线程对这个变量进行操作时的可见性,即一个线程修改了某个变量的值,这新值对其他线程来说是立即可见的。<br>2 )禁止进行指令重排序。<br>volatile本质是在告诉jvm当前变量在寄存器(工作内存)中的值是不确定的,需要从主存中读取，精确地说就是，编译优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p><p><strong>synchronized</strong>则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住。</p><p>两者的区别：<br>1.voltile仅能使用在变量级别;synchronized 则可以使用在变量、方法、和类级别的。<br>2.volatile仅能实现变量的修改可见性,并不能保证原子性;synchronized 则可以保证变量的修改可见性和原子性。<br>3.volatile不会造成线程的阻塞;synchronized 可能会造成线程的阻塞。<br>4.volatile标记的变量不会被编译器优化;synchronized 标记的变量可以被编译器优化。</p><h3 id="一道线程安全的题"><a href="#一道线程安全的题" class="headerlink" title="一道线程安全的题"></a>一道线程安全的题</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8B%E5%8D%881.48.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述代码执行后输出的结果不等于1000。</p><p>在java的内存模型中每一个线程运行时都有一个线程栈,线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候,首先通过对象的引用找到对应在堆内存的变量的值,然后把堆内存变量的具体值load到线程本地内存中,建立-个变量副本 ,之后线程就不再和对象在堆内存变量值有任何关系,而是直接修改副本变量的值，在修改完之后的某一个时刻(线程退出之前) ,自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。</p><p>也就是说上面主函数中开启了1000 个子线程,每个线程都有一个变量副本,每个线程修改变量只是临时修改了自己的副本,当线程结束时再将修改的值写入在主内存中, 这样就出现了线程安全问题。因此结果就不可能等于1000了。一般都会小于1000。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8B%E5%8D%881.50.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="线程池与使用"><a href="#线程池与使用" class="headerlink" title="线程池与使用"></a>线程池与使用</h3><p>线程池就是事先将多个线程对象放到一个容器中,当使用的时候就不用new线程而是直接去池中拿线程即可,节省了开辟子线程的时间,提高的代码执行效率。</p><h1 id="Java-SE高级"><a href="#Java-SE高级" class="headerlink" title="Java SE高级"></a>Java SE高级</h1><h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java中的反射首先是能够获取到Java中要反射类的字节码.获取字节码有三种方法，1.Class.forName(className) 2.类名.class 3.this.getClass(). 然后将字节码中的方法,变量,构造函数等映射成相应的Method. Filed, Constructor 等类,这些类提供了丰富的方法可以被我们所使用。</p><h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p>创建对象的过程<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-9cd31ab516bd967e1b8e68736931f8ba_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-eddc430b991c58039dfc79dd6f3139cc_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建一个实例，最关键的就是得到对应的Class对象。</p><p>代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-e302487f952bdf8e284afc0d8d6a770b_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>动态代理的使用场景：<br>(1)设计模式中有一个设计原则是开闭原则，是说对修改关闭对扩展开放，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑<br>，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行增强。</p><p>(2)我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。</p><p>(3)Spring的AOP机制就是采用动态代理的机制来实现切面编程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8B%E5%8D%882.52.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Java中的设计模式"><a href="#Java中的设计模式" class="headerlink" title="Java中的设计模式"></a>Java中的设计模式</h1><p>设计模式供分为三大类：<br>1、创建型模式，共五种:<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>单例模式</strong>、<strong>建造者模式</strong>。原型模式。<br>2、结构型模式,共七种:<strong>适配器模式</strong>、装饰器模式、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。<br>3、行为型模式，共十一种:<strong>策略模式</strong>，模板方法模式、<strong>观察者模式</strong>，迭代子模式、责任链模式、命令模式、 备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h1><h2 id="如何避免ANR"><a href="#如何避免ANR" class="headerlink" title="如何避免ANR"></a>如何避免ANR</h2><p>ANR：Application Not Responding。不同组件发生ANR的时间不一样，主线程(Activity,Service)是5秒，BroadCastReceiver是10秒。</p><p>解决方案：将所有耗时操作,比如访问网络, Socket通信,查询大量SQL语句,复杂逻辑计算等都放在子线程中去,然后通过handler.sendMessage. runonUITread. AsyncTask等方式更新UI,无论如何都要确保用户界面操作的流畅度。如果耗时操作需要让用户等待,那么可以在界面上显示进度条。</p><h2 id="sim卡的EF文件"><a href="#sim卡的EF文件" class="headerlink" title="sim卡的EF文件"></a>sim卡的EF文件</h2><p>基本文件EF(Elementary File)是SIM卡文件系统的一部分。</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="什么是Activity"><a href="#什么是Activity" class="headerlink" title="什么是Activity"></a>什么是Activity</h3><p>四大组件之一，一般一个用户交互界面对应一个activity<br>activity是Context的子类，同时实现了window.callback和keyevent.callback,可以处理与窗体用户交互事件。</p><h3 id="activity生命周期"><a href="#activity生命周期" class="headerlink" title="activity生命周期"></a>activity生命周期</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/4aa93209cbaef5c2a9bbd2003d928641_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一般情况下<br>按下<strong>home</strong>键:前台Activity依次回调onPause, onStop；<br>按下<strong>back</strong>键:前台Activity依次回调onPause, onStop, onDestroy；<br>按下<strong>电源键</strong>：前台Activity依次onPause, onStop；<br>对于<strong>进程管理器</strong>，采用的force-stop的方式，也是直接强杀进程，并且连广播都会隔断。</p><p>横竖屏切换：在未做任何处理的情况，旋转后，Activity生命周期重新运行:onPause, onStop, onDestroy, onCreate, onStart, onRestoreInstanceState, onResume。<br> 常用Activity：FragmentActivity,ListActivity,TabActivity。</p><h3 id="如何保存Activity的状态？"><a href="#如何保存Activity的状态？" class="headerlink" title="如何保存Activity的状态？"></a>如何保存Activity的状态？</h3><p>覆写onSaveInstanceState()方法，该方法接受一个Bundle类型的参数，开发者可以将状态数据存储到这个Bundle对象中，这样即使Activity被系统摧毁，开发者也可以利用这些数据将Activity恢复到被摧毁前的状态。</p><h3 id="Activity跳转"><a href="#Activity跳转" class="headerlink" title="Activity跳转"></a>Activity跳转</h3><p>两个activityAB，A里面激活B时，A会调用onPause()方法，然后B调用onCreate(),onStart(),onResume()方法。B覆盖窗体，A会调用onStop()方法。如果B是个透明的，或者是对话框的样式，就不会调用A的onStop()方法。</p><h3 id="Context，Activity，Application的区别"><a href="#Context，Activity，Application的区别" class="headerlink" title="Context，Activity，Application的区别"></a>Context，Activity，Application的区别</h3><p>Context维护的是当前的Activity的生命周期，Application维护的是整个项目的生命周期。</p><h3 id="两个Activity之间传递数据，除了intent，广播接收者，Content-provider还有什么？"><a href="#两个Activity之间传递数据，除了intent，广播接收者，Content-provider还有什么？" class="headerlink" title="两个Activity之间传递数据，除了intent，广播接收者，Content provider还有什么？"></a>两个Activity之间传递数据，除了intent，广播接收者，Content provider还有什么？</h3><p>1、利用static静态数据，public static成员变量。<br>2、利用外部存储的传输，File文件存储，SharedPreferences，Sqlite数据库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;Java多态&quot;&gt;&lt;a href=&quot;#Java多态&quot; class=&quot;headerlink&quot; title=&quot;Java多
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot实战 入门</title>
    <link href="https://github.com/zdkswd/2019/05/27/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/zdkswd/2019/05/27/Spring Boot实战 入门/</id>
    <published>2019-05-27T07:00:47.000Z</published>
    <updated>2019-05-27T07:21:22.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h1><p><strong>初始化后的项目</strong><br>Application.java不仅是启动引导类，还是配置类。<br><strong>@SpringBootApplication</strong>开启组件扫描和自动配置。将三个有用的注解组合在了一起。<br>1.Spring的<strong>@Configuration</strong>:标明该类使用Spring基于Java的配置。<br>2.Spring的<strong>@ComponentScan</strong>:启用组件扫描，这样所写的Web控制器类和其他组件才能被自动发现并注册为Spring应用程序上下文中里的Bean。<br>3.Spring Boot的<strong>@EnableAutoConfiguration</strong>:这一行配置开启了Spring Boot自动配置的魔力，可以不再写成篇的配置了。</p><p><strong>application.properties</strong>可以很方便地细粒度调整Spring Boot的自动配置。完全不用告诉Spring Boot加载application.properties,只要存在就会被加载。</p><p> <strong>Spring Boot项目构建插件</strong><br>Spring Boot的构建插件对构建过程有所帮助，如Maven钟spring-boot-maven-plugin。构建插件的主要功能是把项目打包成一个可执行的超级JAR，包括把应用程序的所有依赖打入JAR文件中，并为JAR添加一个描述文件，其中的内容能用java -jar来运行应用程序。</p><p><strong>指定基于功能的依赖</strong><br>并不需要指定版本号，起步依赖本身的版本是由正在使用的Spring Boot的版本来决定的，而起步依赖则会决定它们引入的传递依赖版本。<br>Maven和gradle中使用构建工具来显示包含项目汇总每一个库以及它们的版本。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.13.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>![]<br>(/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.13.40.png)</p><p><strong>覆盖起步依赖引入的传递依赖</strong><br>gradle</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.15.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Maven<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.16.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要指定版本的依赖，则可以在pom.xml中覆盖传递依赖引入的另一个依赖。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.18.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>gradle则是倾向于使用更新的依赖，若要指定老版本的生效，则要先将较新版本的exclude。</p><p><strong>使用自动配置</strong><br>Spring Boot的自动配置是一个运行时的过程，考虑了众多的因素，才决定Spring配置应该用哪一个不该用哪一个。例如。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.22.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>专注于应用程序功能：1.定义领域模型如一个实体。2.定义仓库接口。3.创建Web界面。</p><p>1.<strong>@Entity</strong>注解表明对象是一个JPA实体。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.25.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>id属性加了<strong>@Id</strong>和<strong>@GeneratedValue</strong>注解，说明这个字段是实体的唯一标识，并且这个字段的值是自动生成的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.26.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>2.通过扩展JpaRepository,ReadingListRespository直接继承了18个执行常用持久化操作的方法。JpaRepository是个泛型接口，有两个参数：仓库操作的领域对象类型，及ID属性的类型。以及自己增加的方法findByReader()。只需定义仓库接口，在应用程序启动后，该接口在运行时会自动实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>3.使用SpringMVC为应用程序处理HTTP请求。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.37.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Controller</strong>注解，组件扫描会自动将其注册为Spring应用程序上下文的一个Bean。<br><strong>@RequestMapping</strong>注解，将其中所有的处理器方法都映射到了”/”这个URL路径上。</p><p>在向应用程序加入 Spring boot时,有个名为<strong>spring-boot-autoconfigurel.JAR</strong>文件,其中包含了很多配置类。每个配置类都在应用程序的Classpath里,都有机会为应用程序的配置添砖加瓦。这些配置类里有用于 Thymeleaf的配置,有用于 Spring data JPa的配置,有用于 Spiring mvc的配置<br>还有很多其他东西的配置,你可以自己选择是否在 Spring应用程序里使用它们。其中利用了Spring的条件化配置，条件化配置运行配置存在于应用程序中，但在满足某些特定条件之前都忽略这个配置。在Spring里可以很方便地编写自己的条件，要做的就是实现Condition接口，覆盖它的matches方法。</p><p>下面的简单条件类只有在Classpath里存在JdbcTemplate时才会生效。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%8812.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当用Java来声明Bean时，可以用自定义条件类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%8812.42.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在这个例子中，只有当JdbcTemplateCondition类的条件成立时才会创建MyService这个Bean。也就是说，MyService Bean创建条件是Classpath里有JdbcTemplate。否则，这个Bean的声明就会被忽略。</p><p><strong>Classpath</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/191992114-5b5c838544f7c_articlex.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>自动配置会做出以下配置决策，它们和之前的例子息息相关。<br>1.因为Classpath里有H2，所以会创建一个嵌入式H2数据库Bean，它的类型是javax.sql.DataSource,JPA实现( Hibernate )需要它来访问数据库。<br>2.因为Classpath里有Hibernate ( Spring Data JPA传递引入的)的实体管理器，所以自动配置会配置与Hibernate相关的Bean，包括Spring的LocalContainerEntityManagerFactory Bean和JpaVendorAdapter。<br>3.因为Classpath里有Spring Data JIPA，所以它会自动配置为根据仓库的接口创建仓库实现。<br>4.因为Classpath里有Thymeleaf,所以Thymeleaf会配置为Spring MVC的视图，包括一个Thymeleaf的模板解析器、模板引擎及视图解析器。视图解析器会解析相对于Classpath根目录的 / templates目录里的模板。<br>5.因为Classpath里有SpringMVC(归功于Web起步依赖)，所以会配置Spring的DispatcherServlet并启用Spring MVC。<br>6.因为这是一个Spring MVC Web应用程序,所以会注册一个资源处理器,把相对于Classpath根目录的 / static目录里的静态内容提供出来。(这个资源处理器还能处理 / public、/ resources和_META-INF_resources的静态内容。)<br>7.因为Classpath里有Tomcat(通过Web起步依赖传递引用),所以会启动一个嵌入式的Tomcat容器，监听8080端口。</p><h1 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h1><p><strong>覆盖Spring Boot自动配置</strong><br>正如上面所讲。</p><p><strong>@Configuration</strong>用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p><p><strong>通过属性文件外置配置。</strong><br>另一种方式是通过applocation.properties,yml也可以。</p><p>Spring Boot能从多种属性源获得属性，优先级从高到低是：<br>(1)命令行参数<br>(2) java: comp / env里的JNDI属性<br>(3)JVM系统属性<br>(4)操作系统环境变量<br>(5)随机生成的带random. * 前缀的属性<br>(6)应用程序以外的application. properties或者appliaction.yml文件<br>(7)打包在应用程序内的application.properties或者appliaction.yml文件<br>(8)通过@PropertySource标注的属性源<br>(9)默认属性</p><p>application. properties和application.yml文件能放在以下四个位置。优先级有高到低<br>(1)外置，在相对于应用程序运行目录的 / config子目录里。<br>(2)外置，在应用程序运行的目录里。<br>(3)内置，在config包内 。<br>(4)内置，在Classpath根目录。</p><p>同一优先级位置上，application.yml会覆盖application.properties的属性。</p><p>在application.yml / prop通常你都无需指定JDBC驱动，Spring Boot会根据数据库URL识别出需要的驱动，但如果识别出问题了，你还可以设置spring datasource.driver-class-name属性。在自动配置DataSourceBean的时候，SpringBoot会使用这里的连接数据。</p><p>DataSourceBean是一个连接池，如果Classpath里有Tomcat的连接池DataSource,那么就会使用这个连接池;否则，Spring Boot会在Classpath里查找以下连接池:HikariCP，Commons DBCP 2。还可以自己配置DataSource Bean,使用自己喜欢的各种连接池。</p><p><strong>应用程序Bean的配置外置</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%882.44.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@ConfigurationProperties</strong>注解说明该Bean的属性应该是（通过setter）从配置属性值注入的，更具体就是说明应该注入带amazon前缀的属性。</p><p>本例中ReadingListController只有一个setter方法，就是设置associateId属性用的setter方法。因此，设置Amazon Associate ID唯一要做的就是添加amazon.associateId属性，把它加入支持的任一属性源位置里即可。<br>例如在application.properties中设置：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%882.51.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>开启配置属性</strong>从技 术上来说，<strong>@ConfigurationProperties</strong>注解不会生效，除非先向Spring配置类添加<strong>@EnableConfigurationProperties</strong>注解。但通常无需这么做，因为Spring Boot自动配置后面的全部配置类都已经加上了<strong>@EnableConfigurationProperties</strong>注解。因此，除非你完全不使用自动配置，否则就无需显式地添加<strong>@EnableConfigurationProperties</strong>。</p><p>需要注意，Spring Boot的属性解析器非常智能，它会自动把驼峰规则的属性和使用连字符或下划线的同名属性关联起来。换句话说，amazon. associateId这个属性和amazon. associate_ id以及amazon.associate-id都是等价的。</p><p><strong>在一个类里收集属性</strong>，创建一个单独的Bean,为它加上<strong>@ConfigurationProperties</strong>注解，让这个Bean收集所有配置属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.08.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了加载amazon.associateld配置属性的AmazonProperties后，我们可以调整ReadingListController ,让它从注入的AmazonProperties中获取Amazon Associate ID。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.13.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>使用Profile进行配置</strong><br>Profile是一种条件化配置，基于运行时激活Profile，会使用或者忽略不同的Bean或配置类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.51.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Profile</strong>注解要求运行时激活production Profile,这样才能应用该配置。如果production Profile没有激活，就会忽略该配置。设置spring.profiles.active属性就能激活Profile，任意设置配置属性的方式都能用于设置这个值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.57.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果正在使用application.properties，可以创建额外的属性文件，遵循application-{profile}.properties命名格式，就能提供特定于Profile的属性了。<br>比如说生产环境，就是application-production.properties。</p><p>使用YAML就可以把所有的Profile的配置属性都放在一个application.yml文件里，例如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%882.48.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动配置&quot;&gt;&lt;a href=&quot;#自动配置&quot; class=&quot;headerlink&quot; title=&quot;自动配置&quot;&gt;&lt;/a&gt;自动配置&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;初始化后的项目&lt;/strong&gt;&lt;br&gt;Application.java不仅是启动引导类，还是配置类。&lt;br
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
      <category term="Spring" scheme="https://github.com/zdkswd/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>百面 优化算法</title>
    <link href="https://github.com/zdkswd/2019/05/14/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/zdkswd/2019/05/14/百面 优化算法/</id>
    <published>2019-05-14T01:45:47.000Z</published>
    <updated>2019-05-14T01:47:09.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百面-优化算法"><a href="#百面-优化算法" class="headerlink" title="百面 优化算法"></a>百面 优化算法</h1><p>机器学习算法=模型表征+模型评估+优化算法<br>优化算法所做的事情就是在模型表征空间中找到模型评估指标最好的模型。<br>经典的支持向量机对应的模型表征和评估指标分别为线性分类模型和最大间隔，逻辑回归对应的模型表征和评估指标则分别为线性分类模型和交叉熵。</p><h1 id="有监督学习的损失函数"><a href="#有监督学习的损失函数" class="headerlink" title="有监督学习的损失函数"></a>有监督学习的损失函数</h1><p><strong>问：有监督学习涉及的损失函数有哪些？请列举并简述它们的特点。</strong></p><p>答：在有监督学习中，损失函数刻画了模型和训练样本的匹配程度。<br>对于二分类问题，最自然地损失函数是0-1损失。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.33.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中1p是指示函数，当且仅当p为真时取值为1，否则取值为0。该损失函数能够直观地刻画分类的错误率，但是由于其非凸非光滑的特点，使得算法很难直接对其进行优化。<br>0-1损失的一个代理损失函数是hinge损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.35.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>hinge损失函数是0-1损失函数相对紧的凸上界，且当fy&gt;=1时，该函数不对其做任何惩罚。hinge损失在fy=1处不可导，因此不能用梯度下降法进行优化，而是用<strong>次梯度下降法</strong>。<br>0-1损失的另一个代理损失函数是logistic损失函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.38.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>logistic损失函数也是0-1损失函数的凸上界，且该函数处处光滑，因此可以用梯度下降法进行优化。但是，该损失函数对所有样本点都有所惩罚，因此对异常值相对更敏感一些。<br>当预测值f属于[-1,1]时，另一个代理损失函数就是交叉熵损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.56.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>交叉熵损失函数也是0-1损失函数的光滑凸上界。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.57.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>对于回归问题，最常用的损失函数是平方损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.58.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>平方损失函数是光滑函数，能够用梯度下降法进行优化。当预测值距离真实值越远时，平方损失函数的惩罚力度越大，因为它对异常点比较敏感。可以采用绝对损失函数来解决这个问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.02.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>绝对损失对异常点更鲁棒一些，但是绝对损失函数在f=y处无法求导数。综合考虑可导性和对异常点的鲁棒性，可以采用huber损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.18.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> huber损失函数在|f-y|较小时为平方损失，在|f-y|较大时为线性损失，处处可导，且对异常点鲁棒。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.21.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="机器学习中的优化问题"><a href="#机器学习中的优化问题" class="headerlink" title="机器学习中的优化问题"></a>机器学习中的优化问题</h1><p><strong>问： 机器学习中优化问题，哪些是凸优化问题，哪些是非凸优化问题？</strong></p><p>答：凸函数，函数L是凸函数当且仅当对定义域中的任意两点x，y和任意实数λ∈[0,1]总有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.25.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>逻辑回归对应的就是凸优化问题，对于二分类问题，Y={1,-1},假设模型参数为θ，则逻辑回归的优化问题为。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.27.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以通过计算目标函数的二阶Hessian矩阵来验证凸性。令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.37.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对该函数求一阶导，得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.38.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>继续求导，得到函数的Hessian矩阵<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.39.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>该矩阵满足半正定的性质。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.40.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.41.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>函数L为凸函数。对于凸优化问题，所有的局部极小值都是全局极小值，因此这类问题一般认为是比较容易求解的问题。</p><p>主成分分析的优化问题为非凸优化问题。一般来说，非凸优化问题被认为是比较南求解的问题，但主成分分析是一个特例，我们可以借助SVD直接得到主成分分析的全局极小值。</p><p><strong>总结与扩展：</strong>其他凸优化的例子包括支持向量机，线性回归等线性模型，非凸优化问题的例子包括低秩模型(如矩阵分解),深度神经网络模型。</p><h1 id="经典优化算法"><a href="#经典优化算法" class="headerlink" title="经典优化算法"></a>经典优化算法</h1><p><strong>问题：无约束优化问题的优化方法有哪些？</strong>对于无约束优化问题：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.54.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中目标函数L是光滑的，求解该问题的优化算法有哪些，适用场景是什么。</p><p>答：优化算法分为<strong>直接法</strong>和<strong>迭代法</strong>。<br>直接法，就是能够直接给出优化问题的最优解。直接法不是万能的。直接法要求目标函数需要满足两个条件，第一个是，L是凸函数。二，若L是凸函数，那么θ是最优解的充分必要条件是L在θ处的梯度为0。<br>即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.00.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>经典的例子是岭回归，其最优解为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.04.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>直接法要满足的这两个条件限制了它的应用范围。因此，在很多实际问题中，会采用迭代法。迭代法就是迭代地修正对最优解得估计。迭代法又分为一阶法和二阶法两类。<br>一阶法的迭代公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.20.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中α称为学习率，一阶法也称为梯度下降法，梯度就是目标函数的一阶信息。<br>二阶法的迭代公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.22.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>二阶法也称为牛顿法，Hessian矩阵就是目标函数的二阶信息，二阶法的收敛速度一般要远快于一阶法，但是在高维情况下，Hessian矩阵求逆的计算复杂度很大，而且当目标函数非凸时，二阶法有可能会收敛到鞍点。</p><h1 id="梯度验证"><a href="#梯度验证" class="headerlink" title="梯度验证"></a>梯度验证</h1><p>在实际应用中，写出计算梯度的代码后，通常需要验证自己写的代码是否正确。<br><strong>问：如何验证求目标函数梯度功能的正确性？</strong></p><p>答：ei是单位向量，维度与θ相同，仅在第i个位置取值为1，其余位置取值为0。可以取h为一个比较小的数(例如10的-7次方)，则有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8811.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8811.03.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在实际应用中，随机初始化θ，取h为较小的数(例如10的-7次方)，并对i=1,2,…,n,依次验证<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8811.01.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>是否成立。如果对于某个下标i，该不等式不成立，则有以下两种可能。<br>1 该下标对应的M过大<br>2 该梯度分量计算不正确</p><p>此时可以固定θ，减小h为原来的十分之一，并再次计算下标i对应的近似误差，若近似误差越减小为原来的百分之一，则对应第一种可能，我们应该采用更小的h重新做一次梯度验证，否则对应第二种可能，应检查梯度的代码是否有错误。</p><h1 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h1><p><strong>问：当训练数据量特别大时，经典的梯度下降法存在什么问题，需要做如何改进？</strong></p><p>答：经典的梯度下降法在每次对模型参数进行更新时，需要遍历所有的训练数据。当M很大时，这需要很大的计算量，耗费很长的计算时间，在实际应用中基本不可行。为了解决该问题，随机梯度下降法(SGD)用单个训练样本的损失来近似平均损失，即随机梯度下降法用单个训练数据即可对模型参数进行一次更新，大大加快了收敛速率。该方法也非常适用于数据源源不断到来的在线更新场景。</p><p>为了降低随机梯度的方差，从而使得迭代算法更加稳定，也为了充分利用高度优化的矩阵运算操作，在实际应用中我们会同时处理若干训练数据，该方法被称为小批量梯度下降法(Mini-Batch Gradient Descent)<br>有三个需要注意的地方：<br>1.选取参数m，在不同的应用中，最优的m通常会不一样，需要通过调参选取。一般m取2的幂次能充分利用矩阵运算操作，所以可以在2的幂次中挑选出最优的取值，例如32，64，128，256等。<br>2.挑选m个训练数据，为了避免数据的特定顺序给算法收敛带来的影响，一般会在每次遍历训练数据之前，先对所有的数据进行随机排序，然后在每次迭代时按顺序挑选m个训练数据直至遍历完所有的数据。<br>3.选取学习速率α，为了加快收敛速率，同时提高求解精度，通常会采用衰减学习速率的方案:一开始算法采用较大的学习速率，当误差曲线进入平台期后，减小学习速率做更精细的调整。最优的学习速率方案也通常需要调参才能得到。</p><p>综上，通常采用小批量梯度下降法解决训练数据量过大的问题。每次更新模型参数时，只需要处理m个训练数据即可，其中m是一个远小于总数据量M的常数，这样能够大大加快训练过程。</p><h1 id="随机梯度下降法的加速"><a href="#随机梯度下降法的加速" class="headerlink" title="随机梯度下降法的加速"></a>随机梯度下降法的加速</h1><p>提到深度学习中的优化方法，人们通常会想到随机梯度下降法。但是，随机梯度下降法并不是万金油，有时候反而会成为一个坑。当设计出一个深度神经网络时，如果只知道用随机梯度下降法来训练模型，那么当得到一个比较差的训练结果时，可能会放弃在这个模型上继续投入精力。然而，造成训练效果差的真正原因，可能并不是模型的问题，而是随机梯度下降法在优化过程中失效了，这可能会导致你丧失一次新发现的机会。</p><p><strong>问：随机梯度下降法偶尔也会失效，无法给出满意的训练结果，这是为什么？</strong></p><p>答：随机梯度下降法放弃了对梯度准确性的追求，每步仅仅随机采样一个或少量样本来估计当前梯度，计算速度快，内存开销小。但由于每步接受的信息量有限，随机梯度下降法对梯度的估计常常出现偏差，造成目标函数曲线收敛得很不稳定，伴有剧烈波动，有时甚至出现不收敛的情况。</p><p>深度学习中的优化问题本身就很难，有太多局部最优点的陷阱。这些陷阱对随机梯度下降法和批量梯度下降法都是普遍存在的。但对随机梯度下降法来说，可怕的不是局部最优点，而是<strong>山谷</strong>和<strong>鞍点</strong>两类地形。</p><p>山谷顾名思义就是狭长的山间小道，左右两边是峭璧;鞍点的形状像是一个马鞍，一个方向上两头翘，另一个方向上两头垂，而中心区域是一片近乎水平的平地。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/f08834008016f4c23a67e931d2f5a281_b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>山谷地形</p><p>在山谷中，准确的梯度方向是沿山道向下，稍有偏离就会撞向山壁，而粗糙的梯度估计使得它在两山壁间来回反弹震荡，不能沿山道方向迅速下降，导致收敛不稳定和收敛速度慢。在鞍点处，随机梯度下降法会走入一片平坦之地，结果就停滞下来。</p><p><strong>问：解决之道—惯性保持和环境感知。</strong></p><p>答：1.动量(<strong>Momentum</strong>)方法。<br>随机梯度下降法更新公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%887.56.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>动量方法模型参数迭代公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%887.56.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>具体来说，前进步伐-v,由两部分组成。一是学习速率乘以当前估计的梯度g;二是带衰减的前一次步伐v。这里，惯性就体现在对前一次步伐信息的重利用上。类比中学物理知识，当前梯度就好比当前时刻受力产生的加速度，前一次步伐好比前一时刻的速度，当前步伐好比当前时刻的速度。为了计算当前时刻的速度，应当考虑前一时刻速度和当前加速度共同作用的结果，因此vt直接依赖于vt-1 和gt, 而不仅仅是gt。另外，衰减系数y扮演了阻力的作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/3e0e36c25cfc4dccb28e651aa7a47b01_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/a1a5fe431b8ab803d778337c8be2f275_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/20180515233015431.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>AdaGrad方法</strong><br>随机梯度下降法对环境的感知是指在参数空间中，根据不同参数的一些经验性判断，自适应地确定参数的学习速率，不同参数的更新步幅是不同的。例如，在文本处理中训练词嵌入模型的参数时，有的词或词组频繁出现，有的词或词组则极少出现。数据的稀疏性导致相应参数的梯度的稀疏性，不频繁出现的词或词组的参数的梯度在大多数情况下为零，从而这些参数被更新的频率很低。在应用中，我们希望更新频率低的参数可以拥有较大的更新步幅，而更新频率高的参数的步幅可以减小。<strong>AdaGrad方法采用“历史梯度平方和”来衡量不同参数的梯度的稀疏性，取值越小表明越稀疏</strong>，具体的更新公式表示为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.09.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>分母求和的形式实现了退火过程，这是很多优化技术中常见的策略，意味着随着时间推移，学习速率越来越小，从而保证了算法的最终收敛。</p><p><strong>Adam方法</strong><br>Adam方法将惯性保持和环境感知这两个优点集于一身。一方面，Adam记录梯度的一阶矩(first moment) ，即过往梯度与当前梯度的平均，这体现了惯性保持;另一方面，Adam还记录梯度的二阶矩(second moment)，即过往梯度平方与当前梯度平方的平均，这类似AdaGrad方法，体现了环境感知能力，为不同参数产生自适应的学习速率。</p><p>一阶矩和二阶矩采用类似于滑动窗口内求平均的思想进行融合，即当前梯度和近一段时间内梯度的平均值，时间久远的梯度对当前平均值的贡献呈指数衰减。具体来说，一阶矩和二阶矩采用指数衰退平均(exponentialdecay average)技术，计算公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.16.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中β，β2为衰减系数，m是一阶矩，v是二阶矩。</p><p> 一阶矩相当于估计E[g]:由于当下梯度g,是随机采样得到的估计结果，因此更关注它在统计意义上的期望;二阶矩相当于估计E[g2]，这点与AdaGrad方法不同，不是g2从开始到现在的加和，而是它的期望。它们的物理意义是，当|m|大且v大时， 梯度大且稳定，这表明遇到一个明显的大坡，前进方向明确;当|m|趋于零 且v,大时，梯度不稳定，表明可能遇到一个峡谷，容易引起反弹震荡;当lm|大 且v,趋于零时，这种情况不可能出现;当|m|趋于零且v趋于零时，梯度趋于零，可能到达局部最低点，也可能走到一片坡度极缓的平地，此时要避免陷入平原(plateau) 。另外，Adam方法还考虑了m， v,在零初始值情况下的偏置矫正。具体来说，Adam的更新公式为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.23.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.24.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="L1正则化与稀疏性"><a href="#L1正则化与稀疏性" class="headerlink" title="L1正则化与稀疏性"></a>L1正则化与稀疏性</h1><p><strong>问：L1正则化使得模型参数具有稀疏性的原理是什么？</strong></p><p>角度1：解空间形状。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.27.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在二维的情况下，黄色的部分是L2和L1正则项约束后的解空间，绿色的等高线是凸优化问题中目标函数的等高线。由图可知，L2正则项约束后的解空间是圆形，而L1正则项约束的解空间是多边形。显然，多边形的解空间更容易在尖角处与等高线碰撞出稀疏解。</p><p>事实上，带正则项和带约束条件是等价的。为了约束w的可能取值空间从而防止过拟合，我们为该最优化问题加上一个约束，就是w的L2范数的平方不能大于m:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.54.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了求解带约束条件的凸优化问题，写出拉格朗日函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.56.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若w <em>  和λ </em> 分别是原问题和对偶问题的最优解，根据KKT条件，它们应满足<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-14%20%E4%B8%8A%E5%8D%888.48.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>L2正则化相当于为参数定义了一个圆形的解空间(因为必须保证L2范数不能大于m),而L1正则化相当于为参数定义了个棱形的解空间。如果原问题目标函数的最优解不是恰好落在解空间内,那么约束条件下的最优解一定是在解空间的边界上,而L1“棱角分明”的解空间显然更容易与目标函数等高线在角点碰撞,从而产生稀疏解。</p><p>L2的切点只有一个点，L1的话，一个尖尖可以和无数个圆连着。</p><p><strong>角度2：函数叠加</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-14%20%E4%B8%8A%E5%8D%888.55.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>棕线是原始目标函数L(w)的曲线图，最小值点在蓝点处，且对应w * 值非0。</p><p>考虑加上L2正则化项，目标函数变成L(w)+Cw2,其函数曲线为黄色。此时，最小值点在黄点处，对应w * 的绝对值减小了，但仍然非0.</p><p>考虑加上L1正则化项，目标函数变成L(w)+C|w|,其函数曲线为绿色，最小值点在红色处，对应的w是0，产生了稀疏性。</p><p>原因很直观，加入L1正则化后，对带正则项的目标函数求导，正则项部分产生的导数在原点左边部分是-C，在原点右边部分是C，因此，只要原目标函数的导数绝对值小于C，那么带正则项的目标函数在原点左边部分始终是递减的，在原点右边部分始终是递增的，最小值点自然在原点处。相反，L2正则项在原点处的导数是0，只要原目标函数在原点处的导数不为0，那么最小值点就不会在原点，所以L2只有减小w绝对值的作用，对解空间的稀疏性没有贡献。</p><p>在一些在线梯度下降算法中，往往会采用截断梯度法来产生稀疏性，这同L1正则项产生稀疏性的原理是类似的。<br><strong>由上可以看出，L1产生稀疏性的概率比L2大很多，L2只有原目标函数导数为0这一种情况，L1则是原目标函数的导数绝对值小于C即可。</strong></p><p><strong>角度3：贝叶斯先验</strong><br>从贝叶斯的角度来理解L1正则化和L2正则化，简单的解释是，L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正 则化相当于引入了高斯先验，而拉普拉斯先验使参数为0的可能性更大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;百面-优化算法&quot;&gt;&lt;a href=&quot;#百面-优化算法&quot; class=&quot;headerlink&quot; title=&quot;百面 优化算法&quot;&gt;&lt;/a&gt;百面 优化算法&lt;/h1&gt;&lt;p&gt;机器学习算法=模型表征+模型评估+优化算法&lt;br&gt;优化算法所做的事情就是在模型表征空间中找到模型评估
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode分类练习</title>
    <link href="https://github.com/zdkswd/2019/05/07/leetcode%E5%88%86%E7%B1%BB%E7%BB%83%E4%B9%A0/"/>
    <id>https://github.com/zdkswd/2019/05/07/leetcode分类练习/</id>
    <published>2019-05-07T11:56:47.000Z</published>
    <updated>2019-05-07T11:56:40.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>15.3sum<br>169.majority element<br>41.first missing positive</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>141.linked list cycle<br>23.merge k sorted list</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>20.valid parenthess<br>32.longest valid parentheses<br>150.evaluate reverse polish notation</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>641.design circular deque<br>239.sliding window maxumum</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>70.climbing stairs</p><h1 id="排序与二分查找"><a href="#排序与二分查找" class="headerlink" title="排序与二分查找"></a>排序与二分查找</h1><p>69.sqrt(x)</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>344.reverse string<br>151.reverse words in a string<br>8.string to integer(atoi)</p><h1 id="二叉树和堆"><a href="#二叉树和堆" class="headerlink" title="二叉树和堆"></a>二叉树和堆</h1><p>226.invert binary tree<br>104.maximum depth of binary tree<br>98.validate binary search tree<br>112.path sum</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>200.number of islands<br>36.vaild sudoku</p><h1 id="回溯分治动态规划"><a href="#回溯分治动态规划" class="headerlink" title="回溯分治动态规划"></a>回溯分治动态规划</h1><p>10.regular expression matching<br>64.minimum path sum<br>322.coin change<br>121.best time to buy and sell stock<br>152.maximum product subarray<br>120.triangle</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;15.3sum&lt;br&gt;169.majority element&lt;br&gt;41.first missing positive&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://github.com/zdkswd/2019/05/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://github.com/zdkswd/2019/05/07/二分查找/</id>
    <published>2019-05-07T08:53:47.000Z</published>
    <updated>2019-05-07T08:54:04.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/9dadf04cdfa7b3724e0df91da7cacd9b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/8bce81259abf0e9a06f115e22586b829.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>二分查找针对的是一个有序的数据集合,查找思想有点类似分治思想。每次都通过跟区间的中间元素对比,将待查找的区间缩小为之前的一半,直到找到要查找的元素,或者区间被缩小为0。</p><p><strong>惊人的查找速度O(logn)。</strong>比如n等于2的32次方，大约是32亿，但是在42亿个数据中用二分查找一个数据，最多需要比较32次。常量级时间复杂度的算法有时候可能还没有O(logn)的算法执行效率高。</p><h1 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h1><p>对于最简单的情况，即不存在重复数据的情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%883.33.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>三个容易出错的地方：<br>1.循环退出条件<br>是low&lt;=high,而不是low&lt;high。<br>2.mid的取值<br>实际上,mid=(ow+high)/2这种写法是有问题的。因为如果low和high比较大的话,两者之和就有可能会溢出。改进的方法是将md的计算方式写成low+(high-low)/2。更进一步,如果要将性能优化到极致的话,我们可以将这里的除以2操作转化成位运算low+(high-low)&gt;&gt;1)。因为相比除法运算来说,计算机处理位运算要快得多。<br>3.low和hign的更新<br>low=md+1,high=mid-1。注意这里的+1和-1,如果直接写成low=mid或者high=mid,就可能会发生死循环。比如,当high=3,low=3时,如果a3]不等于value,就会导致一直循环不退出。</p><p>二分查找除了用循环来实现，还可以用递归来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%883.45.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><p><strong>首先，二分查找依赖的是顺序表结构，简单说就是数组。</strong><br><strong>其次，二分查找针对的是有序数据。</strong>如果数据没有序，我们需要先排序。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。<br><strong>再次，数据量太小不适合二分查找。</strong>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。只有数据量比较大时，二分查找的优势才会比较明显。如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。<br><strong>最后，数据量太大也不适合二分查找。</strong>二分查找的底层需要依赖数组，需要有大量的连续的内存空间，对于1gb的数据，需要有1gb<strong>连续</strong>内存空间。</p><p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决，但是不论是散列表还是二叉树都会需要比较多的额外的内存空间。二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式。</p><h1 id="二分查找简单情况的变形"><a href="#二分查找简单情况的变形" class="headerlink" title="二分查找简单情况的变形"></a>二分查找简单情况的变形</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/4221d02a2e88e9053085920f13f9ce36.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/503c572dd0f9d734b55f1bd12765c4f8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于之前简单情况的代码进行一些变形。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%884.30.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>查找的是任意一个值等于给定值的元素，当a[mid]等于要查找的值时，a[mid]就是我们要找的元素，此时需要确认是否是第一个值等于给定值的元素。经检查发现a[mid]前面一个元素a[mid-1]也等于value，那么说明此时的a[mid]肯定不是第一个值等于给定值的元素，就更新high=mid-1。</p><h2 id="变体二-查找最后一个值等于给定值的元素"><a href="#变体二-查找最后一个值等于给定值的元素" class="headerlink" title="变体二 查找最后一个值等于给定值的元素"></a>变体二 查找最后一个值等于给定值的元素</h2><p>同理可得</p><h2 id="变体三-查找第一个大于等于给定值的元素"><a href="#变体三-查找第一个大于等于给定值的元素" class="headerlink" title="变体三 查找第一个大于等于给定值的元素"></a>变体三 查找第一个大于等于给定值的元素</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%884.40.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>思路类似</p><h2 id="变体四-查找最后一个小于等于给定值的元素"><a href="#变体四-查找最后一个小于等于给定值的元素" class="headerlink" title="变体四 查找最后一个小于等于给定值的元素"></a>变体四 查找最后一个小于等于给定值的元素</h2><p>类似</p><h1 id="快速定位出一个ip地址归属地"><a href="#快速定位出一个ip地址归属地" class="headerlink" title="快速定位出一个ip地址归属地"></a>快速定位出一个ip地址归属地</h1><p>首先将ip地址排序，将问题转化为在有序数组中，查找最后一个小于等于某个给定值的元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性排序 O(n)  排序优化</title>
    <link href="https://github.com/zdkswd/2019/05/07/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2019/05/07/线性排序 O(n)  排序优化/</id>
    <published>2019-05-07T06:32:32.000Z</published>
    <updated>2019-05-07T06:33:45.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性排序-O-n-排序优化"><a href="#线性排序-O-n-排序优化" class="headerlink" title="线性排序 O(n)  排序优化"></a>线性排序 O(n)  排序优化</h1><p>桶排序，计数排序，基数排序的时间复杂度是线性的，之所以能做到线性的时间复杂度主要是因为这些算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>核心思想是将要排序的数据分到几个有序的桶中，每个桶里的数据再单独进行排序。桶内排完序后，再将每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/987564607b864255f81686829503abae.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>时间复杂度分析：</strong>如果要排序的数据有n个，把它们均匀地划分到m个桶内，每个桶里就有k=n / m个元素。每个桶内部使用快速排序，时间复杂度为O(k <em> logk)。m个桶排序的时间复杂度就是O(m </em> k <em> logk),因为k=n / m,所以整个桶排序的时间复杂度就是O(n </em> log(n / m))。当桶的个数m接近数据个数n时，log(n / m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p><p>桶排序对要排序数据的要求是非常苛刻的：<strong>首先</strong>要排序的数据需要很容易能划分成m个桶，并且桶与桶之间有着天然的大小顺序。这样每个桶内数据都排序完之后，桶与桶之间的数据不需要进行排序。<strong>其次</strong>，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中。</strong></p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p><strong>计数排序其实是桶排序的一种特殊情况。</strong>当要排序的n个数据，所处的范围并不大时，比如最大值为k，就可以将数据划分为k个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>比如高考成绩排序，考生的满分是750，最小是0，就可以分为751个桶，根据考生成绩，将50万考生划分到751个桶中，桶内的数据都是分数相同的学生，所以并不需要再进行排序，只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序，因为只涉及扫描遍历操作，所以时间复杂度是O(n)。</p><p>计数排序的名字计数有何而来呢？比如8个考生分数在0-5之间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/adc75672ef33fa54b023a040834fcbc9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C[6]内存储的不是考生，而是对应的考生的个数。将C[6]数组顺序求和。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C[k]里存储小于等于分数k的考生个数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/1d730cb17249f8e92ef5cab53ae65784.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种利用另外一个数组来计数的实现方式非常巧妙，这也是为什么这种排序算法叫计数排序的原因。</p><p><strong>计数排序只能用在数据范围不大的场景中，</strong>如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要在其不改变相对大小的情况下，转化为非负整数。</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于每一位的排序的算法需要是稳定的。可以使用桶排序或者计数排序，其中桶排序中每个桶不能用快排而要用归并排序。</p><p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的‘位’来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。</strong></p><h1 id="选择合适的排序算法"><a href="#选择合适的排序算法" class="headerlink" title="选择合适的排序算法"></a>选择合适的排序算法</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中默认桶排序是不稳定的。</p><h1 id="排序优化，实现高性能的排序函数"><a href="#排序优化，实现高性能的排序函数" class="headerlink" title="排序优化，实现高性能的排序函数"></a>排序优化，实现高性能的排序函数</h1><p>线性排序算法的时间复杂度较低，但是适用场景比较特殊。所以如果要写一个通用的排序函数,不能选择线性排序算法。</p><p>如果对小规模数据进行排序,可以选择时间复杂度是o(n2)的算法;如果对大规模数据进行排序,时间复杂度是 o(nlogn)的算法更加高效。所以,为了兼顾任意规模数据的排序,一般都会首选时间复杂度是o( nlogn)的排序算法来实现排序函数。</p><p>然而归并排序使用的并不多，虽然其稳定O(nlogn)，但是由于其不是原地排序算法，空间复杂度是O(n)，所以并没有得到很多的使用。</p><h1 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h1><p>最坏的情况下快排的时间复杂度是O(n2),如果数据原来就是有序或者接近有序的，每次分区点都选择最后一个数据，那么快速排序算法就会变得非常糟糕，时间复杂度就会退化为O(n2)，出现的主要原因是我们分区点选的不够合理。理想的分区点是，<strong>被分区点分开的两个分区中，数据的数量差不多。</strong>为了提高排序算法的性能，要尽可能地让每次分区都比较平均。</p><h2 id="三数取中法"><a href="#三数取中法" class="headerlink" title="三数取中法"></a>三数取中法</h2><p>我们从区间的首、尾、中间,分别取出一个数,然后对比大小,取这3个数的中间值作为分区点。这样每间隔某个固定的长度,取数据岀来比较,将中间值作为分区点的分区算法,肯定要比单纯取某一个数据更好。但是,如果要排序的数组比较大,那“三数取中”可能就不够了,可能要“五数取中”或者“十数取中”。</p><h2 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h2><p>随机法就是每次从要排序的区间中,随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好,但是从概率的角度来看,也不大可能会出现每次分区点都选的很差的情况,所以平均情况下,这样选的分区点是比较好的。时间复杂度退化为最糟糕的O(n2)的情况,出现的可能性不大。</p><p>快速排序是用递归来实现的。我们在递归那一节讲过,递归要警惕堆栈溢出。为了避免快速排序里,递归过深而堆栈过小,导致堆栈溢岀,我们有两种解决办法:第一种是限制递归深度。一旦递归过深,超过了我们事先设定的阈值,就停止递归。第二种是通过在堆上模拟实现一个函数调用栈,手动模拟递归压栈、岀栈的过程,这样就没有了系统栈大小的限制。</p><h1 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h1><p>比如<strong>qsort()函数</strong>，会优先使用归并排序来处理小数据量的排序。使用空间来换时间，当数据量太大，就会改用快速排序算法来排序。选取分区点的方法便是三数取中法。对于递归太深导致堆栈溢出的问题，是通过自己实现一个堆上的栈，手动模拟递归来解决的。qsort()并不仅仅用到了归并排序和快速排序，还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于4时，qsort()就退化为插入排序，在小规模数据前，O(n2)时间复杂度的算法并不一定比O(nlogn)的算法执行时间长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性排序-O-n-排序优化&quot;&gt;&lt;a href=&quot;#线性排序-O-n-排序优化&quot; class=&quot;headerlink&quot; title=&quot;线性排序 O(n)  排序优化&quot;&gt;&lt;/a&gt;线性排序 O(n)  排序优化&lt;/h1&gt;&lt;p&gt;桶排序，计数排序，基数排序的时间复杂度是线性
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
