<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-10-23T13:34:44.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习数学基础下</title>
    <link href="https://github.com/zdkswd/2018/10/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/"/>
    <id>https://github.com/zdkswd/2018/10/23/机器学习数学基础下/</id>
    <published>2018-10-23T13:28:47.000Z</published>
    <updated>2018-10-23T13:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性代数进阶"><a href="#线性代数进阶" class="headerlink" title="线性代数进阶"></a>线性代数进阶</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.26.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="矩阵的标准型：相似变换（把矩阵看做线性映射）"><a href="#矩阵的标准型：相似变换（把矩阵看做线性映射）" class="headerlink" title="矩阵的标准型：相似变换（把矩阵看做线性映射）"></a>矩阵的标准型：相似变换（把矩阵看做线性映射）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.30.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.15.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.16.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="矩阵的标准型：相合变换（二次型）"><a href="#矩阵的标准型：相合变换（二次型）" class="headerlink" title="矩阵的标准型：相合变换（二次型）"></a>矩阵的标准型：相合变换（二次型）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.34.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.35.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.36.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.36.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h3><p>PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</p><p>选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/e01296f282109b59e18086843866f81a_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如图中如果想要将二维转化为一维，若想少丢失信息，则应将投影尽可能的分散。而这种分散程度，可以用数学上的方差来表述。</p><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</p><p>考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。数学上可以用两个字段的协方差表示其相关性。</p><p>至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。</p><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.07.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.16.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.17.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.18.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.19.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.19.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>最后需要说明的是，PCA是一种无参数技术，也就是说面对同样的数据，如果不考虑清洗，谁来做结果都一样，没有主观参数的介入，所以PCA便于通用实现，但是本身无法个性化的优化。</p><h3 id="（奇异值分解）SVD"><a href="#（奇异值分解）SVD" class="headerlink" title="（奇异值分解）SVD"></a>（奇异值分解）SVD</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.48.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.54.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.55.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="SVD与PCA"><a href="#SVD与PCA" class="headerlink" title="SVD与PCA"></a>SVD与PCA</h3><p>我们讲到要用PCA降维，需要找到样本协方差矩阵的最大的k个特征向量，然后用这最大的k个特征向量张成的矩阵来做低维投影降维。 SVD也可以得到协方差矩阵最大的k个特征向量张成的矩阵。 就是说，PCA算法可以不用做特征分解，而是做SVD来完成。</p><h1 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.06.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.08.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.14.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.08.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最小二乘法是经常使用的优化算法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.38.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/v2-079ffd6e8865d3644fd2cfa1e7521e79_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于目标函数，我们限定是凸函数；对于优化变量的可行域（注意，还要包括目标函数定义域的约束），我们限定它是凸集。同时满足这两个限制条件的最优化问题称为凸优化问题，这类问题有一个非常好性质，那就是局部最优解一定是全局最优解。</p><p><strong>凸集</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.00.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.19.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.42.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%887.47.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%887.50.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%888.22.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%889.34.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%888.24.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.09.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.21.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="优化问题举例：EM算法简介与混合高斯模型"><a href="#优化问题举例：EM算法简介与混合高斯模型" class="headerlink" title="优化问题举例：EM算法简介与混合高斯模型"></a>优化问题举例：EM算法简介与混合高斯模型</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.38.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.39.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.44.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.46.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.49.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.51.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.51.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>第一步（E）:如果这个混合模型中，每一次的输出我们知道它是从哪一个模型里边出来的就好了</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>第二步（M）：最大化似然函数</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.53.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%8812.47.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>逐次逼近最优解。</p><h1 id="凸优化进阶"><a href="#凸优化进阶" class="headerlink" title="凸优化进阶"></a>凸优化进阶</h1><h2 id="机器学习与优化"><a href="#机器学习与优化" class="headerlink" title="机器学习与优化"></a>机器学习与优化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.57.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="共轭函数与对偶方法"><a href="#共轭函数与对偶方法" class="headerlink" title="共轭函数与对偶方法"></a>共轭函数与对偶方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.05.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>给定一个优化问题，如果比较复杂，可以转化为优化问题的对偶问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.10.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.29.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>勒让德（Legendre）变化的理解：函数上境图的支撑超平面的截距。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.09.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对偶（共轭）函数抓住了原来函数的一些性质，没有抓住全部性质，抓住了原来函数凸闭包的性质。非凸函数的凸闭包函数是最接近其性质的凸函数，所以可以拿来做近似。第一个结论告诉我勒让德变换抓的是凸包的性质，第二个性质告诉我们，如果是凸函数了。变成共轭函数了没有丢失信息，再做一次变换还能变回来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.48.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第三点说明对于一般的函数，共轭变换是丢失了一部分信息的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.50.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>第二点说的就是几何性质。</p><h2 id="对偶问题：拉格朗日对偶问题"><a href="#对偶问题：拉格朗日对偶问题" class="headerlink" title="对偶问题：拉格朗日对偶问题"></a>对偶问题：拉格朗日对偶问题</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.38.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于没有约束条件的问题，可以使用牛顿法。对于有约束条件的问题，最优解可能不在可行域里，这时就不太好解了。</p><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.35.31.png" alt=""><br>当对一群线性函数取逐点极小值的时候，得到的是一个凹函数。所以g函数是一个凹函数。其中x属于全部定义域，是没有约束条件的，这样再做就比较简单。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们将一个待求函数比较简单但约束条件比较复杂得问题转换为了一个待求函数比较复杂但约束条件比较简单的问题。把问题的复杂性转化到了函数里面去。待求函数不管凸的凹的可以用牛顿法去做逼近。</p><p>那转化后的问题与原问题有什么关系呢？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.25.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.28.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用g的上界提供了原问题的下界。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.52.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>d是g的最大值，p是f的最小值。</p><h2 id="强对偶性条件"><a href="#强对偶性条件" class="headerlink" title="强对偶性条件"></a>强对偶性条件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.50.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>凸优化问题比较容易去求解，但是为什么还需要求对偶变化呢，是因为约束条件比较复杂。需要简化。</p><p>当你是对偶问题时，在凸性上一定是变好的，但是不一定能抓住原来问题的所有性质。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.43.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.43.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.45.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.19.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.20.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.22.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.52.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>琴生不等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.54.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.47.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.48.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上确界（Supremum）：一个集合的最小上界， 数学符号sups<br>下确界（greatest lower boundinf）：一个集合的最大下界,数学符号inf<br>上确界与最大值：上确界类似于最大值，但是和最大值不同的是，最大值有时候会遇到无法取到的情况。比如x∈R,x&lt;2这样的情况下就不存在一个确定的最大值。但是可以确定上确界为2。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.50.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.53.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.21.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>a,x都是向量，b是常数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.24.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.26.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.26.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>简单来说仿射变换就是线性变换加平移。线性变化中原点还在原点，但仿射变换后，原点就移动了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%889.18.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如何通俗地讲解「<em>仿射变换</em>」这个概念？ - 马同学的回答 - 知乎<br><a href="https://www.zhihu.com/question/20666664/answer/157400568" target="_blank" rel="noopener">https://www.zhihu.com/question/20666664/answer/157400568</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.28.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将前z维每一项都除以最后一维t,将最后一项t舍弃。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.29.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.30.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.32.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.33.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.34.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.35.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.41.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.47.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.51.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>分割使用的是n-1维的超平面。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.53.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.56.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.00.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>等式条件定义了一个球面，球面不是一个凸集合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.20.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时把支持向量机问题转化为了一个凸优化问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.32.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.36.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.40.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.44.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.48.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.56.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>允许c和d有一部分交叉。<br>或者使用核方法，将维度增加，再进行划分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.58.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.01.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.03.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>C抜D抜离得最近的两个点的垂直平分线。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.06.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.08.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="压缩感知与图像处理"><a href="#压缩感知与图像处理" class="headerlink" title="压缩感知与图像处理"></a>压缩感知与图像处理</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.13.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.20.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.22.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.24.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.24.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.25.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.25.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="算法和理论与数学知识点"><a href="#算法和理论与数学知识点" class="headerlink" title="算法和理论与数学知识点"></a>算法和理论与数学知识点</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.52.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性代数进阶&quot;&gt;&lt;a href=&quot;#线性代数进阶&quot; class=&quot;headerlink&quot; title=&quot;线性代数进阶&quot;&gt;&lt;/a&gt;线性代数进阶&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常见的几种最优化方法</title>
    <link href="https://github.com/zdkswd/2018/10/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/zdkswd/2018/10/22/常见的几种最优化方法/</id>
    <published>2018-10-22T13:32:51.000Z</published>
    <updated>2018-10-22T13:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/maybe2030/p/4751804.html" target="_blank" rel="noopener">Math 常见的几种最优化方法 - Poll的笔记 - 博客园</a><br>最优化方法与凸优化，我们研究凸优化，是因为凸优化比较好研究，其实正确的叫法应当叫最优化方法。</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>梯度下降法是最早最简单，也是最为常用的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。<strong>梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/350px-Gradient_descent.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>梯度下降的缺点：</p><ol><li>靠近极小值时收敛速度减慢，如下图所示</li><li>直线搜索时可能会产生一些问题</li><li>可能会“之字形”地下降。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/Banana-SteepDesc.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><h2 id="批量梯度下降法（BGD）"><a href="#批量梯度下降法（BGD）" class="headerlink" title="批量梯度下降法（BGD）"></a>批量梯度下降法（BGD）</h2><p>最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</p><h2 id="随机梯度下降法（SGD）"><a href="#随机梯度下降法（SGD）" class="headerlink" title="随机梯度下降法（SGD）"></a>随机梯度下降法（SGD）</h2><p>最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。</p><p><strong>两者的关系可以这样理解：随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</strong></p><h1 id="牛顿法和拟牛顿法"><a href="#牛顿法和拟牛顿法" class="headerlink" title="牛顿法和拟牛顿法"></a>牛顿法和拟牛顿法</h1><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p><a href="https://matongxue.com/madocs/205.html" target="_blank" rel="noopener">如何通俗易懂地讲解牛顿迭代法？</a><br>五次及以上多项式方程没有根式解（就是没有像二次方程那样的万能公式）。没有根式解不意味着方程解不出来，数学家也提供了很多方法，牛顿迭代法就是其中一种。</p><h3 id="代数解法"><a href="#代数解法" class="headerlink" title="代数解法"></a>代数解法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-18%20%E4%B8%8A%E5%8D%8810.30.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="不总是收敛（不总是能求得足够近似的根）"><a href="#不总是收敛（不总是能求得足够近似的根）" class="headerlink" title="不总是收敛（不总是能求得足够近似的根）"></a>不总是收敛（不总是能求得足够近似的根）</h3><p>充分条件：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-18%20%E4%B8%8A%E5%8D%8810.28.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也就是说有很多情况下选择牛顿法，根不收敛。</p><p>而且不能完整求出所有的根，只能求到起始点附近的根。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>应用牛顿法最好：</p><ol><li>函数在整个定义域内最好是二阶可导的</li><li>起始点对求根计算影响重大，可以增加一些别的手段进行试错。</li></ol><h3 id="求解最值问题"><a href="#求解最值问题" class="headerlink" title="求解最值问题"></a>求解最值问题</h3><p>牛顿法也被用于求函数的最值。由于函数取最值的点处的导数值为零，故可用牛顿法求导函数的零点，其迭代式为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/b812c8fcc3cec3fddbb30b10dd88d43f869427c1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="高维情况的牛顿迭代式"><a href="#高维情况的牛顿迭代式" class="headerlink" title="高维情况的牛顿迭代式"></a>高维情况的牛顿迭代式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/0_1307264790QzWk.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>高维情况依然可以用牛顿迭代求解，但是问题是Hessian矩阵引入的复杂性，使得牛顿迭代求解的难度大大增加，但是已经有了解决这个问题的办法就是Quasi-Newton methond，不再直接计算hessian矩阵，而是每一步的时候使用梯度向量更新hessian矩阵的近似。</p><h3 id="关于牛顿法与梯度下降法效率的对比"><a href="#关于牛顿法与梯度下降法效率的对比" class="headerlink" title="关于牛顿法与梯度下降法效率的对比"></a>关于牛顿法与梯度下降法效率的对比</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/697b070fjw1dvpdvu65zij.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</p><p>根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：二阶收敛，收敛速度快；<br>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</p><h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2><p><strong>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。</strong>拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p><p>针对牛顿法中海塞矩阵的计算问题，拟牛顿法主要是使用一个海塞矩阵的近似矩阵来代替原来的还塞矩阵，通过这种方式来减少运算的复杂度。其主要过程是先推导出海塞矩阵需要满足的条件，即拟牛顿条件（也可以称为拟牛顿方程）。然后我们构造一个满足拟牛顿条件的近似矩阵来代替原来的海塞矩阵。</p><p>外，在满足拟牛顿条件的基础上如何构造近似的海塞矩阵，这有很多种方法，比如：DFP算法，BFGS算法，L-BFGS算法以及Broyden类算法等。常用前两种。</p><p>在牛顿法推导中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090055594094281.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后对f(x)求偏导：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090056311435787.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令x=xk得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090057071597116.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>g等于f的一阶导。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090057354245982.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>简化：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090058041599302.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>于是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090100178627788.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在满足此条件的基础上如何构造近似海塞矩阵呢？下面介绍两个方法：DFP算法和BFGS算法。</p><h3 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a>DFP算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324000528609.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324000539484.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="BFGS算法"><a href="#BFGS算法" class="headerlink" title="BFGS算法"></a>BFGS算法</h3><p>　　BFGS算法是用直接逼近海塞矩阵的方式来构造近似海塞矩阵，同样，我们使用迭代的方式来逐步逼近。我们使用B来表示海塞矩阵的近似矩阵，而在DFP算法中我们是直接使用D来构造近似海塞矩阵的逆矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324001108453.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324001126671.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h1><p><strong>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。</strong> 在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/220px-Conjugate_gradient_illustration.svg.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注：绿色为梯度下降法，红色代表共轭梯度法</strong></p><h1 id="启发式优化方法"><a href="#启发式优化方法" class="headerlink" title="启发式优化方法"></a>启发式优化方法</h1><p>启发式方法指人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。启发式优化方法种类繁多，包括经典的模拟退火方法、遗传算法、蚁群算法以及粒子群算法等等。</p><p>　　还有一种特殊的优化算法被称之多目标优化算法，它主要针对同时优化多个目标（两个及两个以上）的优化问题，这方面比较经典的算法有NSGAII算法、MOEA/D算法以及人工免疫算法等。</p><h1 id="解决约束优化问题—拉格朗日乘数法"><a href="#解决约束优化问题—拉格朗日乘数法" class="headerlink" title="解决约束优化问题—拉格朗日乘数法"></a>解决约束优化问题—拉格朗日乘数法</h1><h2 id="拉格朗日乘数法的基本思想"><a href="#拉格朗日乘数法的基本思想" class="headerlink" title="拉格朗日乘数法的基本思想"></a>拉格朗日乘数法的基本思想</h2><p>　<strong>作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数</strong></p><p>　　<strong>如何将一个含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题？拉格朗日乘数法从数学意义入手，通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解。</strong></p><h2 id="拉格朗日乘数法的基本形态"><a href="#拉格朗日乘数法的基本形态" class="headerlink" title="拉格朗日乘数法的基本形态"></a>拉格朗日乘数法的基本形态</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-22%20%E4%B8%8B%E5%8D%888.56.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="拉格朗日乘数法与KKT条件"><a href="#拉格朗日乘数法与KKT条件" class="headerlink" title="拉格朗日乘数法与KKT条件"></a>拉格朗日乘数法与KKT条件</h2><p>我们上述讨论的问题均为等式约束优化问题，但等式约束并不足以描述人们面临的问题，不等式约束比等式约束更为常见，大部分实际问题的约束都是不超过多少时间，不超过多少人力，不超过多少成本等等。所以有几个科学家拓展了拉格朗日乘数法，增加了KKT条件之后便可以用拉格朗日乘数法来求解不等式约束的优化问题了。</p><p>　<strong>KKT条件是指在满足一些有规则的条件下, 一个非线性规划(Nonlinear Programming)问题能有最优化解法的一个必要和充分条件.</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-22%20%E4%B8%8B%E5%8D%889.07.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/maybe2030/p/4751804.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Math 常见的几种最优化方法 - Poll的笔记 - 博客园&lt;/a&gt;&lt;br&gt;最优化方法与凸优化
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM 事件模型</title>
    <link href="https://github.com/zdkswd/2018/10/21/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/zdkswd/2018/10/21/JavaScript标准参考教程 DOM 事件模型/</id>
    <published>2018-10-21T06:53:56.000Z</published>
    <updated>2018-10-21T06:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件。</p><h1 id="EventTarget接口"><a href="#EventTarget接口" class="headerlink" title="EventTarget接口"></a>EventTarget接口</h1><p>DOM 的事件操作（监听和触发），都定义在<strong>EventTarget</strong>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<strong>XMLHttpRequest</strong>、<strong>AudioNode</strong>、<strong>AudioContext</strong>）也部署了这个接口。</p><p>该接口主要提供三个实例方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.51.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h2><p>EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.52.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>该方法接受三个参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.54.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>例子：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.56.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>关于参数：</p><ol><li>第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.58.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.03.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><p>addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除。</p><p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.06.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>监听函数内部的this，指向当前事件所在的那个对象。</p><h2 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h2><p>EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.08.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p><p>注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.11.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h2><p>EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.15.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>dispatchEvent方法的参数是一个Event对象的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.28.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果dispatchEvent方法的参数为空，或者不是一个有效的事件对象，将报错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.32.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h1><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p><p>JavaScript有三种方法，可以为事件绑定监听函数。</p><h2 id="HTML的on-属性"><a href="#HTML的on-属性" class="headerlink" title="HTML的on-属性"></a>HTML的on-属性</h2><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.34.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，这些属性的值是将会执行的代码，而不是一个函数。一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p><p>使用这个方法指定的监听代码，只会在冒泡阶段触发。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.38.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，&lt; button&gt;是&lt; div&gt;的子元素。&lt; button&gt;的click事件，也会触发&lt; div&gt;的click事件。由于on-属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出1，再输出2，即事件从子元素开始冒泡到父元素。</p><p>直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.38.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h2><p>元素节点对象的事件属性，同样可以指定监听函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.42.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p><p>注意，这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。</p><h2 id="EventTarget-addEventListener-1"><a href="#EventTarget-addEventListener-1" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h2><p>所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.43.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</li><li>“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。</li><li>EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.50.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1>监听函数内部的this指向触发事件的那个元素节点。<h1 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h1>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.54.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.58.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.59.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h1>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8811.00.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>上面代码中，click事件的监听函数定义在&lt; ul&gt;节点，但是实际上，它处理的是子节点&lt; li&gt;的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个&lt; li&gt;节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</li></ol><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。</p><p>但是，stopPropagation方法只会阻止事件的传播，不会阻止该事件触发&lt; p&gt;节点的其他click事件的监听函数。也就是说，不是彻底取消click事件。</p><p>如果想要彻底阻止这个事件的传播，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.31.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Event对象概述"><a href="#Event对象概述" class="headerlink" title="Event对象概述"></a>Event对象概述</h1><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。</p><p>Event对象本身就是一个构造函数，可以用来生成新的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.35.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.36.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.38.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码新建一个look事件实例，然后使用dispatchEvent方法触发该事件。</p><p>注意，如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数。</p><h1 id="Event对象的实例属性"><a href="#Event对象的实例属性" class="headerlink" title="Event对象的实例属性"></a>Event对象的实例属性</h1><h2 id="Event-bubbles，Event-eventPhase"><a href="#Event-bubbles，Event-eventPhase" class="headerlink" title="Event.bubbles，Event.eventPhase"></a>Event.bubbles，Event.eventPhase</h2><p>Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，Event构造函数生成的事件，默认是不冒泡的。</p><p>Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.51.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Event.eventPhase的返回值有四种可能。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.51.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Event-cancelable，Event-cancelBubble，event-defaultPrevented"><a href="#Event-cancelable，Event-cancelBubble，event-defaultPrevented" class="headerlink" title="Event.cancelable，Event.cancelBubble，event.defaultPrevented"></a>Event.cancelable，Event.cancelBubble，event.defaultPrevented</h2><p>Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p><p>大多数浏览器的原生事件是可以取消的。比如，取消click事件，点击链接将无效。但是除非显式声明，Event构造函数生成的事件，默认是不可以取消的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.54.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。</p><p>如果事件不能取消，调用Event.preventDefault()会没有任何效果。所以使用这个方法之前，最好用Event.cancelable属性判断一下是否可以取消。</p><p>Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。</p><h2 id="Event-currentTarget，Event-target"><a href="#Event-currentTarget，Event-target" class="headerlink" title="Event.currentTarget，Event.target"></a>Event.currentTarget，Event.target</h2><p>Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</p><p>Event.target属性返回原始触发事件的那个节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.07.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也就是currentTarget—&gt;p节点。&lt; em&gt;子节点上面点击，则e.target指向&lt; em&gt;子节点，导致&lt; em&gt;子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个para都将不可见。</p><h2 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h2><p>Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.09.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Event-timeStamp"><a href="#Event-timeStamp" class="headerlink" title="Event.timeStamp"></a>Event.timeStamp</h2><p>Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.10.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p><h2 id="Event-isTrusted"><a href="#Event-isTrusted" class="headerlink" title="Event.isTrusted"></a>Event.isTrusted</h2><p>Event.isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个click事件，该事件是用户产生的；Event构造函数生成的事件，则是脚本产生的。</p><h2 id="Event-detail"><a href="#Event-detail" class="headerlink" title="Event.detail"></a>Event.detail</h2><p>Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于click和dbclick事件，Event.detail是鼠标按下的次数（1表示单击，2表示双击，3表示三击）；对于鼠标滚轮事件，Event.detail是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p><h1 id="Event-对象的实例方法"><a href="#Event-对象的实例方法" class="headerlink" title="Event 对象的实例方法"></a>Event 对象的实例方法</h1><h2 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h2><p>Event.preventDefault方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的cancelable属性为true，如果为false，调用该方法没有任何效果。</p><p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用stopPropagation()或stopImmediatePropagation()方法。</p><h2 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h2><p>stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p><h2 id="Event-stopImmediatePropagation"><a href="#Event-stopImmediatePropagation" class="headerlink" title="Event.stopImmediatePropagation()"></a>Event.stopImmediatePropagation()</h2><p>Event.stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比Event.stopPropagation()更彻底。</p><h2 id="Event-composedPath"><a href="#Event-composedPath" class="headerlink" title="Event.composedPath()"></a>Event.composedPath()</h2><p>Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p><h1 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h1><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.32.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>CustomEvent()构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。CustomEvent的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.34.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.35.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有detail属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件。&lt;/p&gt;
&lt;h1 id=&quot;EventTarget接口&quot;&gt;&lt;a href=&quot;#EventTarget接口&quot; class=&quot;headerlink&quot; title=&quot;EventTarge
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown线性代数</title>
    <link href="https://github.com/zdkswd/2018/10/15/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/10/15/3Blue1Brown线性代数/</id>
    <published>2018-10-15T10:05:32.000Z</published>
    <updated>2018-10-15T10:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量究竟是什么"><a href="#向量究竟是什么" class="headerlink" title="向量究竟是什么"></a>向量究竟是什么</h1><p>在数学中向量以原点为起点，在空间中是一个有向的箭头，每一个位置上的数值代表在对应轴上的数值。为了与点区分，所以向量竖着写。</p><p>向量的加法<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.07.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>向量的乘法<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.11.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.14.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>线性代数围绕两种基本运算：向量加法与向量数乘。</strong></p><h1 id="线性组合、张成的空间与基"><a href="#线性组合、张成的空间与基" class="headerlink" title="线性组合、张成的空间与基"></a>线性组合、张成的空间与基</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.17.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基向量。</p><p><strong>当我们用数字描述向量时，都依赖于我们所选择的基。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.20.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在二维空间中，如果<strong>v</strong>,<strong>w</strong>不共线且不为零向量，那么理论上a<strong>v</strong>+b<strong>w</strong>就可以表示二维空间中所有的向量。 </p><p>为什么叫线性组合，如果固定其中一个向量那么只能表示部分向量，这些向量的末端构成一条直线。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.28.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.30.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么。</strong></p><p><strong>向量VS点</strong>：<br><strong>可以用点来代替一个起点为原点，终点在该点上的一个向量。</strong></p><p>三维向量：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.36.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>三个向量的线性组合的张成空间同理。 </p><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.46.04.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.46.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>线性相关：一个向量在其他向量线性组合的张成空间中，即这个向量没有提高所有向量组成的张成空间的维度。</p><p>线性无关：每一个向量都起到了提高张成空间维度的作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.49.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="矩阵与线性变换"><a href="#矩阵与线性变换" class="headerlink" title="矩阵与线性变换"></a>矩阵与线性变换</h1><p>变换只不过是函数的一种花哨说法，它接收输入内容，并输出对应结果。在线性代数中考虑的是向量输入，输出一个向量。那为什么不用函数这个词呢？变换这个词在暗示用<strong>运动</strong>去思考。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.55.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果一个变换有以下两条性质，我们就称它是线性的：一是直线在变换后仍然保持为直线，不能有所弯曲。二是原点保持固定。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.30.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如上不是线性变换。 </p><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.30.34.png" alt=""><br>如上为线性变换</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.31.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.31.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>变换后的坐标。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.34.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于线性变换后对于基向量的线性组合的值不变，所以只需要知道基向量的变换就可以算出变换后的任意向量的坐标。<br> 变换后的<strong>i</strong>,<strong>j</strong>。一个在<strong>标准网格</strong>的坐标系中的一个向量(x,y)<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.36.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标（<strong>标准网格下的坐标</strong>）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.39.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 矩阵在这里只是一个记号，它含有描述一个线性变换的信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.44.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="矩阵乘法与线性变换复合"><a href="#矩阵乘法与线性变换复合" class="headerlink" title="矩阵乘法与线性变换复合"></a>矩阵乘法与线性变换复合</h1><p>两个独立变换可以进行复合变换<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.50.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>先旋转再剪切。</p><p>两个矩阵相乘有着几何意义，也就是两个线性变换相继作用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.52.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>之所以能这么做是因为它们都在同一个坐标系下，即标准网格坐标系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.03.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>三维空间中的线性变换同理。</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.14.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>描述一个线性变换是让面积（对二维来说是面积，三维就是体积）拉伸还是挤压了。</p><p>也就是说如果一个行列式为0，那就是变换后成了一条线（对二维俩说）。推广就是计算一个矩阵的行列式，我们就能了解这个矩阵代表的变换是否将空间压缩到更小的维度上。</p><p>当空间定向改变的情况发生时，原本j在i的左侧，现在j在i的右侧了，行列式为负。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.28.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="逆矩阵、列空间与零空间"><a href="#逆矩阵、列空间与零空间" class="headerlink" title="逆矩阵、列空间与零空间"></a>逆矩阵、列空间与零空间</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.39.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.39.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>逆矩阵就是逆变换。只要变换不讲空间压缩到更低维度，就有逆变换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.21.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>即使压缩到更低的维度，解依然有可能存在，当<strong>x</strong>恰好在直线上时，解就存在。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.48.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.53.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>列空间就是矩阵的列所张成的空间。秩的更精确的定义是列空间的维数。满秩是指输入空间的维度等于矩阵的秩。对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身。对于非满秩的变换，将维度压缩到更低的维度，也就是说会有一系列的向量会压缩到原点。在变换后落在原点的向量集合，被称为所选矩阵的<strong>零空间</strong>或<strong>核</strong>。</p><h1 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.40.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.50.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>几何意义是将二维空间映射到三维空间上。矩阵有两列表明输入空间有两个基向量，三维是表明变换到了三维空间坐标系中，张成空间为三维空间的一个过原点的二维平面，矩阵依然是满秩的，因为列空间的维数与输入空间的维数相等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.46.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.47.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="点积与对偶性"><a href="#点积与对偶性" class="headerlink" title="点积与对偶性"></a>点积与对偶性</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.52.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.53.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里可以看做是二维空间压缩到一维的数轴上，由于变换是线性的，所以可以用一个1*2的矩阵来表示变换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8811.07.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.19.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="叉乘的标准介绍"><a href="#叉乘的标准介绍" class="headerlink" title="叉乘的标准介绍"></a>叉乘的标准介绍</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.08.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>顺序不同，正负不同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这里才是真正的叉乘：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.13.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>方向右手定则。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.15.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="以线性变换的眼光看叉乘"><a href="#以线性变换的眼光看叉乘" class="headerlink" title="以线性变换的眼光看叉乘"></a>以线性变换的眼光看叉乘</h1><p>为什么上述的式子中要用到ijk?下面就来解释。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.22.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>真正的三维向量的叉乘接收两个向量并输出一个向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.37.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.31.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个函数的几何意义在于，对于任一输入的向量（x,y,z),你都考虑它和v,w确定的平行六面体得到它的体积，然后根据取向确定符号。<strong>这个函数是线性的</strong>。</p><p>一旦知道它是线性的，就可以知道可以通过矩阵乘法来描述这个函数。具体地说，因为这个函数从三维空间到一维空间，就会存在一个1*3矩阵来代表这个变换。根据对偶性，从多维空间到一维空间的变换的特别之处在于可以将整个变换看做与这个特定向量的点积。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.42.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.45.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们要找的就是<strong>P</strong>，使得p与其他任意向量（x,y,z）的点积等于一个3* 3矩阵的行列式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.51.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从算数角度上来说<strong>p</strong>就是 （。。。。）i+（。。。。）j+（。。。。）k<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.56.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从几何的角度：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.33.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>左边式子，向量p与其他向量的点积的几何解释，是将其他向量投影到p上。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.59.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>右面式子是(x,y,z)的垂直分量*底部面积。和垂直于v,w且长度等于平行四边形面积的向量与（x,y,z）点乘一样。所以p垂直v,w且长度为平行四边形的面积。</p><p>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.33.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h1><p>线性变换中一个坐标系中的所有向量都跟着动，变换后的向量仍旧是相同的线性组合，不过使用的是新的基向量。基变换中，一个向量是不动的，动的是坐标系。</p><p>詹的坐标系：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.52.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>一个我们坐标系中的向量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.53.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>詹系中对它的描述：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.54.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>詹的基在我们系中的向量坐标：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.55.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>詹的基自己的坐标：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.56.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>不同的坐标系（基）对于空间内同一个向量的描述是不同的，也就是描述的语言不同。</p><p>不同的基的坐标原点是重合的。如何在不同的坐标系之间进行转化：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.00.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.02.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>式1</p><p>就是将（-1，2）进行线性变换后，可以变为黄色的向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.10.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以把这个式子看作是我们把我们对詹的误解（詹的坐标系下的数值直接拿到标准网格坐标系里）转化为真实的詹的所指，都是在标准网格坐标系下。</p><p>同理，如果取逆。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.14.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这时可以求在标准网格坐标系中的某点，在詹坐标系下的值。可在式一两侧左边同时乘以逆来很好的推出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.43.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果想要旋转90度，詹的基该如何表示？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.24.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>开始是一个詹下的向量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.24.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们转为我们的语言，在标准网格下的一个向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.25.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>此时再进行旋转操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.27.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>最后左乘一个逆矩阵，将其转换为詹的语言。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.28.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这就是詹的语言下旋转的操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.29.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h1><p>在线性变换中，有的向量并不改变方向，只是拉伸或者缩小。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.36.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.36.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.37.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>、<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.37.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这些向量就叫特征向量，每个特征向量都有一个所属的值，拉伸倍数叫做特征值。</p><p>如果在三维变化中找到这个特征向量，那它就是旋转轴</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.44.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="抽象空间本质"><a href="#抽象空间本质" class="headerlink" title="抽象空间本质"></a>抽象空间本质</h1><p>向量是什么？</p><p>从某种意义上来说函数也是向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%884.55.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%884.56.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>x,y,z是三个点的纵坐标。</p><p>同时也存在另一个函数转换为另一个函数的操作（对应线性变化），例如求导。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.03.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可见函数是线性的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.13.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.13.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>抽象性带来的好处是我们能得到一般性的结论。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.16.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.16.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.17.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.19.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.21.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所以，什么是向量？数学中有许多类似向量的事物，只要你处理的对象集具有合理的数乘和相加概念，线性代数中所有关于向量、线性变换和其他等产生的概念都应该适用于它。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.23.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这些类似向量的事物，比如箭头、一组数、函数等，它们构成的集合被称为“向量空间”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.24.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.26.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.28.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足八条公理。这些公理是一个接口，一边连着应用线代的人，另一边是数学家。</p><p>只要满足八条公理，就可以将线代应用到你的研究对象上，而数学家则是根据这些公理证明了你的结论。</p><p>向量可以是任何东西，只要它满足公理。回答向量是什么，就像回答3是什么一样。</p><p><strong>普适的代价是抽象。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向量究竟是什么&quot;&gt;&lt;a href=&quot;#向量究竟是什么&quot; class=&quot;headerlink&quot; title=&quot;向量究竟是什么&quot;&gt;&lt;/a&gt;向量究竟是什么&lt;/h1&gt;&lt;p&gt;在数学中向量以原点为起点，在空间中是一个有向的箭头，每一个位置上的数值代表在对应轴上的数值。为了与点
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础上</title>
    <link href="https://github.com/zdkswd/2018/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/"/>
    <id>https://github.com/zdkswd/2018/10/13/机器学习数学基础上/</id>
    <published>2018-10-13T11:08:47.000Z</published>
    <updated>2018-10-13T07:41:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><p>见李宏毅第0课。</p><h2 id="得分函数"><a href="#得分函数" class="headerlink" title="得分函数"></a>得分函数</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>权重需要训练得到。</p><h2 id="损失函数最优化"><a href="#损失函数最优化" class="headerlink" title="损失函数最优化"></a>损失函数最优化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.13.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>左边是非凸函数，右边是凸函数。通过优化损失函数来调整权值。</p><h2 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h2><p>琴生不等式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.45.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="微积分基础"><a href="#微积分基础" class="headerlink" title="微积分基础"></a>微积分基础</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.19.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>梯度是一个点上升最快的方向。<br>梯度下降法。</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>通俗语言适合于说给对方听，数学记号适合于写给对方看，精确描述比较啰嗦但是非常精确不会造成误解，主要用于证明。不会出错。</p><p>无穷小的阶数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.17.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.18.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="微分学"><a href="#微分学" class="headerlink" title="微分学"></a>微分学</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.28.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.30.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.30.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.35.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.38.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>求导用链式法则。</p><h2 id="积分学"><a href="#积分学" class="headerlink" title="积分学"></a>积分学</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.19.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.20.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="泰勒级数。"><a href="#泰勒级数。" class="headerlink" title="泰勒级数。"></a>泰勒级数。</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.51.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.56.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="牛顿法与梯度下降法"><a href="#牛顿法与梯度下降法" class="headerlink" title="牛顿法与梯度下降法"></a>牛顿法与梯度下降法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.29.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.32.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.38.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为什么不用牛顿法：<br>原因一：牛顿法需要用到梯度和Hessian矩阵，这两个都难以求解。因为很难写出深度神经网络拟合函数的表达式，遑论直接得到其梯度表达式，更不要说得到基于梯度的Hessian矩阵了。<br>原因二：即使可以得到梯度和Hessian矩阵，当输入向量的维度NNN较大时，Hessian矩阵的大小是N×NN×NN\times N，所需要的内存非常大。<br>原因三：在高维非凸优化问题中，鞍点相对于局部最小值的数量非常多，而且鞍点处的损失值相对于局部最小值处也比较大。而二阶优化算法是寻找梯度为0的点，所以很容易陷入鞍点。</p><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.40.10.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.50.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="为什么研究凸函数，凸优化？"><a href="#为什么研究凸函数，凸优化？" class="headerlink" title="为什么研究凸函数，凸优化？"></a>为什么研究凸函数，凸优化？</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.52.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%889.21.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="概率与统计基础"><a href="#概率与统计基础" class="headerlink" title="概率与统计基础"></a>概率与统计基础</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.48.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.49.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>统计问题是概率问题的逆向工程。<br>概率问题是已知总体的情况，求一次的概率。统计问题则是根据样本的情况反推总体的情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.55.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.57.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="概率统计与机器学习的关系"><a href="#概率统计与机器学习的关系" class="headerlink" title="概率统计与机器学习的关系"></a>概率统计与机器学习的关系</h2><p><strong>概率统计与机器学习天然相关</strong>，训练的过程可以看做是统计过程，预测过程可以看做是概率过程。预测分类就是选择一个概率最大的分类。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%885.02.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以观察各个特征的分布以及标签的分布，筛选出相关性强的特征。</p><ul><li>可基于各个分布的特性来评估模型和样本。</li><li>统计估计的是分布，机器学习训练出来的是模型，模型可能包含了很多的分布。</li><li>训练与预测过程的一个核心评价指标就是模型的误差</li><li>误差本身就可以使概率形式，与概率紧密相关。</li><li>对误差的不同定义方式就演化成了不同损失函数的定义方式。</li><li>机器学习是概率与统计的进阶版本。（不严谨的说法）</li></ul><p>方差<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.40.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>协方差<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.19.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可评估两个分布之间的关系。定义公式几何意义：协方差可以理解成特征进行预处理之后（去均值化，机器学习里比较重要的一个数据预处理的方法）对应的向量的几何的<strong>内积</strong>。协方差是评价两个变量的线性关系。如果是非线性关系，评价不出来。</p><p>相关系数是研究变量之间线性相关程度地量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.30.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>var是方差。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.34.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.22.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.23.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.26.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.28.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.32.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.34.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>先验——根据若干年的统计（经验）或者气候（常识），某地方下雨（因）的概率；</p><p>似然/类条件概率——在下雨（因）的情况下，观测到了乌云（果）的概率，即原因已知时，结果出现的概率；</p><p>后验——根据天上有乌云（果），得到的下雨（因）的概率，即给定结果估计原因的概率；</p><p>x:观察得到的结果。</p><p>θ：决定数据分布的原因。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.01.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>矩</strong>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%888.54.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>其中t是一个实数，i是虚数单位，E表示期望值。此乃原点矩。E(（X-0）^n)中心矩就是-μ。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.29.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.29.29%202.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.06.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>即大部分都分布在均值周围。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.30.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.03.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.05.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%888.55.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.00.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.13.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.16.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.20.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>没法研究随机变量就研究其特征函数。</p><p>当一个分布不是常见的分布时，根据大数定理，反复做实验就可以得到其期望和方差。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.42.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>大数定理是告诉我们趋近一个数，中心极限定理是告诉我们以何种方式趋近一个数。一个正态分布。</p><h1 id="参数估计（统计学）"><a href="#参数估计（统计学）" class="headerlink" title="参数估计（统计学）"></a>参数估计（统计学）</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.47.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h2><p>利用样本来估计总体分布，总体分布的参数很多情况下是未知的。如均值μ、方差\sigma ^{2} 、泊松分布的λ、二项分布的比例π，其它分布还会有更多的未知参数，需要通过样本进行相应的估计，这种估计值就是点估计。</p><h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.56.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.58.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.03.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.10.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.13.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.16.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.17.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以把概率密度看作是θ和x的联合概率密度，把x固定，那么概率密度最大的地方就是θ最可能的地方。</p><p>不是概率是因为相加起来和不等于1，类似于概率是因为数值大小是有意义的，代表了可能性的大小。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.30.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="点估计的评判准则"><a href="#点估计的评判准则" class="headerlink" title="点估计的评判准则"></a>点估计的评判准则</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.03.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><p>对于未知参数，点估计值只是一个近似值，会存在或大或小误差，这时给一个范围可能是更合适，也是更可信的。比如从北京到张家界旅游5天，你恐怕不能准确说出要花多少钱，但你可以给出一个范围，比如10000—13000，你会觉得比较可信。如果给的范围太大，比如10000—30000，虽然可信度更高一些，但这么大的范围参考意义不大；如果给的范围很小，如10000——10500，则准确性提高了，但可信度就似乎不会很高。找到一个合适的估值范围，这是<strong>置信区间</strong>要解决的问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.13.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="线性代数基础"></a>线性代数基础</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.52.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.53.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.55.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%8812.05.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>（1）保持加法（2）保持乘法。<br>线性映射是最简单的研究对象，用线性映射去逼近别的东西。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%8812.11.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>线性变换与矩阵的关系，对任何向量x进行线性变换T的结果向量，是一个对基向量组进行线性变换T之后的新向量组的一个线性组合，<strong>系数</strong>没变。</p><p>只需要知道两个基向量i向量和j向量转换之后的的结果，而不用知道转换本身，我们就能推导出二维空间中所有向量转换之后的结果。</p><h2 id="Ax的几何意义"><a href="#Ax的几何意义" class="headerlink" title="Ax的几何意义"></a>Ax的几何意义</h2><p>矩阵乘向量，列向量的线性组合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.45.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="svd的几何意义。"><a href="#svd的几何意义。" class="headerlink" title="svd的几何意义。"></a>svd的几何意义。</h2><p>一个很重要的降维算法。</p><h2 id="矩阵乘法在计算中的优势"><a href="#矩阵乘法在计算中的优势" class="headerlink" title="矩阵乘法在计算中的优势"></a>矩阵乘法在计算中的优势</h2><ul><li>将很多for循环写成矩阵或者向量乘法的方式。</li><li>矩阵计算模块在底层有优化。</li><li>numpy进行矩阵运算很快。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习基础&quot;&gt;&lt;a href=&quot;#机器学习基础&quot; class=&quot;headerlink&quot; title=&quot;机器学习基础&quot;&gt;&lt;/a&gt;机器学习基础&lt;/h1&gt;&lt;p&gt;见李宏毅第0课。&lt;/p&gt;
&lt;h2 id=&quot;得分函数&quot;&gt;&lt;a href=&quot;#得分函数&quot; class=&quot;head
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment</title>
    <link href="https://github.com/zdkswd/2018/10/12/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/"/>
    <id>https://github.com/zdkswd/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/</id>
    <published>2018-10-12T13:13:56.000Z</published>
    <updated>2018-10-12T13:13:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h1><p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p><p>属性本身是一个对象（Attr对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（HTMlElement对象）来操作属性。本章介绍如何操作这些属性。</p><h2 id="Element-attributes属性"><a href="#Element-attributes属性" class="headerlink" title="Element.attributes属性"></a>Element.attributes属性</h2><p>元素对象有一个attributes属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有attributes属性，但返回的都是null，因此可以把这个属性视为元素对象独有的。</p><p>单个属性可以通过序号引用，也可以通过属性名引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.41.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>返回的都是属性节点对象，而不是属性值。属性节点对象有name和value属性，对应该属性的属性名和属性值，等同于nodeName属性和nodeValue属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.43.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="元素的标准属性"><a href="#元素的标准属性" class="headerlink" title="元素的标准属性"></a>元素的标准属性</h2><p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.46.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这些属性都是可写的。这种修改属性的方法，常常用于添加表单的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.47.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码为表单添加提交网址和提交方法。</p><p>注意，这种用法虽然可以读写属性，但是无法删除属性，delete运算符在这里不会生效。</p><p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如onClick。</p><p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改<br>名。主要是以下两个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.48.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="headerlink" title="属性操作的标准方法"></a>属性操作的标准方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>元素节点提供四个方法，用来操作属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.49.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ol><li>适用性   这四个方法对所有的属性（包括用户自定义的属性）都适用。</li><li>返回值    getAttribute()只返回字符串，不会返回其他类型的值。</li><li>属性名     这些方法只接受属性的标准名称，不用改写保留字，比如for和class都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</li></ol><h3 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h3><p>lement.getAttribute方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。</p><h3 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h3><p>Element.setAttribute方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。</p><h3 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h3><p>Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p><h3 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h3><p>Element.removeAttribute方法用于从当前元素节点移除属性。</p><h2 id="dataset-属性"><a href="#dataset-属性" class="headerlink" title="dataset 属性"></a>dataset 属性</h2><p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。使用标准提供的data-*属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.54.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后，使用元素节点对象的dataset属性，它指向一个对象，可以用来操作 HTML 元素标签的data-*属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.55.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过dataset.foo读写data-foo属性。删除一个data-*属性，可以直接使用delete命令。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.57.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>除了dataset属性，也可以用getAttribute(‘data-foo’)、removeAttribute(‘data-foo’)、setAttribute(‘data-foo’)、hasAttribute(‘data-foo’)等方法操作data-*属性。</p><h1 id="Text节点和DocumentFragment节点"><a href="#Text节点和DocumentFragment节点" class="headerlink" title="Text节点和DocumentFragment节点"></a>Text节点和DocumentFragment节点</h1><h2 id="Text节点的概念"><a href="#Text节点的概念" class="headerlink" title="Text节点的概念"></a>Text节点的概念</h2><p>文本节点（Text）代表元素节点（Element）和属性节点（Attribute）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p><p>通常我们使用父节点的firstChild、nextSibling等属性获取文本节点，或者使用Document节点的createTextNode方法创造一个文本节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.29.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>浏览器原生提供一个Text构造函数。它返回一个文本节点实例。它的参数就是<br>该文本节点的文本内容。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>文本节点继承了Node接口，所以属性和方法都和Node一样。</p><h2 id="Text节点的属性"><a href="#Text节点的属性" class="headerlink" title="Text节点的属性"></a>Text节点的属性</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data属性等同于nodeValue属性，用来设置或读取文本节点的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.33.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="wholeText"><a href="#wholeText" class="headerlink" title="wholeText"></a>wholeText</h3><p>wholeText属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，wholeText属性的返回值，与data属性和textContent属性相同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.36.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>length属性返回当前文本节点的文本长度。</p><h3 id="nextElementSibling，previousElementSibling"><a href="#nextElementSibling，previousElementSibling" class="headerlink" title="nextElementSibling，previousElementSibling"></a>nextElementSibling，previousElementSibling</h3><p>nextElementSibling属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回null。</p><p>previousElementSibling属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回null：。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.38.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Text节点的方法"><a href="#Text节点的方法" class="headerlink" title="Text节点的方法"></a>Text节点的方法</h2><h3 id="appendData-，deleteData-，insertData-，replaceData-，subStringData"><a href="#appendData-，deleteData-，insertData-，replaceData-，subStringData" class="headerlink" title="appendData()，deleteData()，insertData()，replaceData()，subStringData()"></a>appendData()，deleteData()，insertData()，replaceData()，subStringData()</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>remove方法用于移除当前Text节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.53.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="splitText"><a href="#splitText" class="headerlink" title="splitText()"></a>splitText()</h3><p>splitText方法将Text节点一分为二，变成两个毗邻的Text节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p><p>分割后，该方法返回分割位置后方的字符串，而原Text节点变成只包含分割位置前方的字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.55.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>父元素的normalize方法可以实现逆操作，将它们合并。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.56.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="DocumentFragment节点"><a href="#DocumentFragment节点" class="headerlink" title="DocumentFragment节点"></a>DocumentFragment节点</h2><p>DocumentFragment节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，parentNode返回null，但是可以插入任意数量的子节点。它不属于当前文档，操作DocumentFragment节点，要比直接操作 DOM 树快得多。</p><p>它一般用于构建一个 DOM 结构，然后插入当前文档。document.createDocumentFragment方法，以及浏览器原生的DocumentFragment构造函数，可以创建一个空的DocumentFragment节点。然后再使用其他 DOM 方法，向其添加子节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.58.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码创建了一个DocumentFragment节点，然后将一个li节点添加在它里面，最后将DocumentFragment节点移动到原文档。</p><p><strong>注意</strong>，DocumentFragment节点本身不能被插入当前文档。当它作为appendChild()、insertBefore()、replaceChild()等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦DocumentFragment节点被添加进当前文档，它自身就变成了空节点（textContent属性为空字符串），可以被再次使用。如果想要保存DocumentFragment节点的内容，可以使用cloneNode方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%889.03.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面这样添加DocumentFragment节点进入当前文档，不会清空DocumentFragment节点。</p><p>DocumentFragment节点对象没有自己的属性和方法，全部继承自Node节点和ParentNode接口。也就是说，DocumentFragment节点比Node节点多出以下四个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%889.04.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;属性的操作&quot;&gt;&lt;a href=&quot;#属性的操作&quot; class=&quot;headerlink&quot; title=&quot;属性的操作&quot;&gt;&lt;/a&gt;属性的操作&lt;/h1&gt;&lt;p&gt;HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。&lt;/p&gt;
&lt;p&gt;属性本身是一
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于JavaScript的对象的理解</title>
    <link href="https://github.com/zdkswd/2018/10/11/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://github.com/zdkswd/2018/10/11/关于JavaScript的对象的理解/</id>
    <published>2018-10-11T11:26:32.000Z</published>
    <updated>2018-10-11T11:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于JavaScript的对象的理解"><a href="#关于JavaScript的对象的理解" class="headerlink" title="关于JavaScript的对象的理解"></a>关于JavaScript的对象的理解</h1><p>JavaScript的对象可以分为狭义的和广义的对象。广义的对象由数组，狭义的对象和函数组成。</p><p>狭义的对象就是{}，里面是键值对。广义的对象其实本质也是键值对。只不过声明的方式多了一些。比如new Object()。Object就是一个构造函数，既然是函数，本身也就是一个对象，可以对Object中添加方法，和狭义对象的方法一样。比如Object.test=Function (){};这时候在外部可以调用Object.test()方法，即Object对象的静态方法。</p><p>这里Object是构造函数名，但是函数也是对象啊，我估计函数本质上也是一个键值对，函数可以是构造函数Function.prototype的实例对象。所以称为Object对象。</p><p>既然是构造函数，里面是有语句的，执行完语句得到一个键值对，这又是一个对象，称为Object.prototype。这时就是一个纯粹的键值对。就是原型对象。Object.prototype也有很多方法可以调用。至于原型链，就是对象与对象之间的一条链。对象都是构造函数.prototype。继承是通过构造函数的继承来实现的，一般就是在子类中要实现父类的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于JavaScript的对象的理解&quot;&gt;&lt;a href=&quot;#关于JavaScript的对象的理解&quot; class=&quot;headerlink&quot; title=&quot;关于JavaScript的对象的理解&quot;&gt;&lt;/a&gt;关于JavaScript的对象的理解&lt;/h1&gt;&lt;p&gt;JavaSc
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM模型 实际使用DOM Element节点</title>
    <link href="https://github.com/zdkswd/2018/10/09/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%E6%A8%A1%E5%9E%8B%20%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8DOM%20Element%E8%8A%82%E7%82%B9/"/>
    <id>https://github.com/zdkswd/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/</id>
    <published>2018-10-09T11:42:56.000Z</published>
    <updated>2018-10-09T13:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实战中的使用DOM"><a href="#实战中的使用DOM" class="headerlink" title="实战中的使用DOM"></a>实战中的使用DOM</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8A%E5%8D%8811.44.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8A%E5%8D%8811.50.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8B%E5%8D%883.07.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8B%E5%8D%883.26.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果加了括号就会直接执行了。</p><h1 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h1><p>Element对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。</p><p>元素节点的nodeType属性都是1。</p><p>Element对象继承了Node接口，因此Node的属性和方法在Element对象都存在。此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如&lt; a&gt;元素的节点对象由HTMLAnchorElement构造函数生成，&lt; button&gt;元素的节点对象由HTMLButtonElement构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承Element的属性和方法，还有各自构造函数的属性和方法。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="headerlink" title="元素特性的相关属性"></a>元素特性的相关属性</h3><h4 id="Element-id"><a href="#Element-id" class="headerlink" title="Element.id"></a>Element.id</h4><p>Element.id属性返回指定元素的id属性，该属性可读写。</p><p>id属性的值是大小写敏感。</p><h4 id="Element-tagName"><a href="#Element-tagName" class="headerlink" title="Element.tagName"></a>Element.tagName</h4><p>Element.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。</p><h4 id="Element-dir"><a href="#Element-dir" class="headerlink" title="Element.dir"></a>Element.dir</h4><p>Element.dir属性用于读写当前元素的文字方向，可能是从左到右（”ltr”），也可能是从右到左（”rtl”）。</p><h4 id="Element-accessKey"><a href="#Element-accessKey" class="headerlink" title="Element.accessKey"></a>Element.accessKey</h4><p>Element.accessKey属性用于读写分配给当前元素的快捷键。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.46.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面代码中，btn元素的快捷键是h，按下Alt + h就能将焦点转移到它上面。</p><h4 id="Element-draggable"><a href="#Element-draggable" class="headerlink" title="Element.draggable"></a>Element.draggable</h4><p>Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p><h4 id="Element-lang"><a href="#Element-lang" class="headerlink" title="Element.lang"></a>Element.lang</h4><p>Element.lang属性返回当前元素的语言设置。该属性可读写。</p><h4 id="Element-tabIndex"><a href="#Element-tabIndex" class="headerlink" title="Element.tabIndex"></a>Element.tabIndex</h4><p>Element.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p><p>abIndex属性值如果是负值（通常是-1），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的tabIndex属性的正整数值相同，则按照出现的顺序遍历。遍历完所有tabIndex为正整数的元素以后，再遍历所有tabIndex等于0、或者属性值是非法值、或者没有tabIndex属性的元素，顺序为它们在网页中出现的顺序。</p><h4 id="Element-title"><a href="#Element-title" class="headerlink" title="Element.title"></a>Element.title</h4><p>Element.title属性用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p><h3 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="headerlink" title="元素状态的相关属性"></a>元素状态的相关属性</h3><h4 id="Element-hidden"><a href="#Element-hidden" class="headerlink" title="Element.hidden"></a>Element.hidden</h4><p>Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。</p><p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，Element.hidden并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p><p>CSS 的设置高于Element.hidden。如果 CSS 指定了该元素不可见（display: none）或可见（display: hidden），那么Element.hidden并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p><h4 id="Element-contentEditable，Element-isContentEditable"><a href="#Element-contentEditable，Element-isContentEditable" class="headerlink" title="Element.contentEditable，Element.isContentEditable"></a>Element.contentEditable，Element.isContentEditable</h4><p>HTML 元素可以设置contentEditable属性，使得元素的内容可以编辑。</p><p>Element.contentEditable属性返回一个字符串，表示是否设置了contenteditable属性，有三种可能的值。该属性可写。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.49.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Element.isContentEditable属性返回一个布尔值，同样表示是否设置了contenteditable属性。该属性只读。</p><h3 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h3><p>Element.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。</p><h4 id="Element-className，Element-classList"><a href="#Element-className，Element-classList" class="headerlink" title="Element.className，Element.classList"></a>Element.className，Element.classList</h4><p>className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割</p><p>classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。</p><p>classList对象有下列方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.52.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>toggle方法可以接受一个布尔值，作为第二个参数。如果为true，则添加该属性；如果为false，则去除该属性。</p><h3 id="Element-dataset"><a href="#Element-dataset" class="headerlink" title="Element.dataset"></a>Element.dataset</h3><p>网页元素可以自定义data-属性，用来添加数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.53.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Element.dataset属性返回一个对象，可以从这个对象读写data-属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.54.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，dataset上面的各个属性返回都是字符串。</p><p>HTML 代码中，data-属性的属性名，只能包含英文字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_）。它们转成 JavaScript 对应的dataset属性名，规则如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.54.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>因此，data-abc-def对应dataset.abcDef，data-abc-1对应dataset[“abc-1”]。</p><p>除了使用dataset读写data-属性，也可以使用Element.getAttribute()和Element.setAttribute()，通过完整的属性名读写这些属性。</p><h3 id="Element-innerHTML"><a href="#Element-innerHTML" class="headerlink" title="Element.innerHTML"></a>Element.innerHTML</h3><p>Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<html>和<body>元素。</body></html></p><p>如果将innerHTML属性设为空，等于删除所有它包含的所有节点。</p><p>注意，读取属性值的时候，如果文本节点包含 \&amp;、小于号（ &lt;）和大于号（ &gt;），innerHTML属性会将它们转为实体形式 \&amp; amp;、\&amp; lt;、\&amp; gt;。如果想得到原文，建议使用element.textContent属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%883.53.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，如果文本之中含有&lt; script&gt;标签，虽然可以生成script节点，但是插入的代码不会执行。</p><p>为了安全考虑，如果插入的是文本，最好用textContent属性代替innerHTML。</p><h3 id="Element-outerHTML"><a href="#Element-outerHTML" class="headerlink" title="Element.outerHTML"></a>Element.outerHTML</h3><p>Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%883.57.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>outerHTML属性是可读写的，对它进行赋值，等于替换掉当前元素。</p><p>注意，如果一个节点没有父节点，设置outerHTML属性会报错。</p><h3 id="Element-clientHeight，Element-clientWidth"><a href="#Element-clientHeight，Element-clientWidth" class="headerlink" title="Element.clientHeight，Element.clientWidth"></a>Element.clientHeight，Element.clientWidth</h3><p>Element.clientHeight属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度。</p><p>除了元素本身的高度，它还包括padding部分，但是不包括border、margin。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p><p>Element.clientWidth属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p><p>document.documentElement的clientHeight属性，返回当前视口的高度（即浏览器窗口的高度），等同于window.innerHeight属性减去水平滚动条的高度（如果有的话）。document.body的高度则是网页的实际高度。一般来说，document.body.clientHeight大于document.documentElement.clientHeight。</p><h3 id="Element-clientLeft，Element-clientTop"><a href="#Element-clientLeft，Element-clientTop" class="headerlink" title="Element.clientLeft，Element.clientTop"></a>Element.clientLeft，Element.clientTop</h3><p>Element.clientLeft属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的padding和margin。如果没有设置左边框，或者是行内元素（display: inline），该属性返回0。该属性总是返回整数值，如果是小数，会四舍五入。</p><p>Element.clientTop属性等于网页元素顶部边框的宽度（单位像素），其他特点都与clientTop相同。</p><h3 id="Element-scrollHeight，Element-scrollWidth"><a href="#Element-scrollHeight，Element-scrollWidth" class="headerlink" title="Element.scrollHeight，Element.scrollWidth"></a>Element.scrollHeight，Element.scrollWidth</h3><p>Element.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。</p><p>Element.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读。</p><p>整张网页的总高度可以从document.documentElement或document.body上读取。</p><p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，scrollHeight属性仍然返回元素的总高度。</p><h3 id="Element-scrollLeft，Element-scrollTop"><a href="#Element-scrollLeft，Element-scrollTop" class="headerlink" title="Element.scrollLeft，Element.scrollTop"></a>Element.scrollLeft，Element.scrollTop</h3><p>Element.scrollLeft属性表示当前元素的水平滚动条向右侧滚动的像素数量，Element.scrollTop属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p><p>如果要查看整张网页的水平的和垂直的滚动距离，要从document.documentElement元素上读取。</p><p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p><h3 id="Element-offsetParent"><a href="#Element-offsetParent" class="headerlink" title="Element.offsetParent"></a>Element.offsetParent</h3><p>Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。</p><p>该属性主要用于确定子元素位置偏移的计算基准，Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。</p><p>如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），则offsetParent属性返回null。</p><p>如果某个元素的所有上层节点的position属性都是static，则Element.offsetParent属性指向<body>元素。</body></p><h3 id="Element-offsetHeight，Element-offsetWidth"><a href="#Element-offsetHeight，Element-offsetWidth" class="headerlink" title="Element.offsetHeight，Element.offsetWidth"></a>Element.offsetHeight，Element.offsetWidth</h3><p>Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。</p><p>Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。</p><p>这两个属性都是<strong>只读</strong>属性，只比Element.clientHeight和Element.clientWidth多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如display: none;），则返回0。</p><h3 id="Element-offsetLeft，Element-offsetTop"><a href="#Element-offsetLeft，Element-offsetTop" class="headerlink" title="Element.offsetLeft，Element.offsetTop"></a>Element.offsetLeft，Element.offsetTop</h3><p>Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移</p><h3 id="Element-style"><a href="#Element-style" class="headerlink" title="Element.style"></a>Element.style</h3><p>每个元素节点都有style用来读写该元素的行内样式信息。</p><h3 id="Element-children，Element-childElementCount"><a href="#Element-children，Element-childElementCount" class="headerlink" title="Element.children，Element.childElementCount"></a>Element.children，Element.childElementCount</h3><p>Element.children属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p><p>这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p><p>Element.childElementCount属性返回当前元素节点包含的子元素节点的个数，与Element.children.length的值相同。</p><h3 id="Element-firstElementChild，Element-lastElementChild"><a href="#Element-firstElementChild，Element-lastElementChild" class="headerlink" title="Element.firstElementChild，Element.lastElementChild"></a>Element.firstElementChild，Element.lastElementChild</h3><p>Element.firstElementChild属性返回当前元素的第一个元素子节点，Element.lastElementChild返回最后一个元素子节点。</p><p>如果没有元素子节点，这两个属性返回null。</p><h3 id="Element-nextElementSibling，Element-previousElementSibling"><a href="#Element-nextElementSibling，Element-previousElementSibling" class="headerlink" title="Element.nextElementSibling，Element.previousElementSibling"></a>Element.nextElementSibling，Element.previousElementSibling</h3><p>Element.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回null。</p><p>Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回null。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="属性相关方法"><a href="#属性相关方法" class="headerlink" title="属性相关方法"></a>属性相关方法</h3><h4 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h4><p>Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。</p><h4 id="Element-getAttributeNames"><a href="#Element-getAttributeNames" class="headerlink" title="Element.getAttributeNames()"></a>Element.getAttributeNames()</h4><p>Element.getAttributeNames()返回一个<strong>数组</strong>，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用Element.attributes属性，也可以拿到同样的结果，唯一的区别是它返回的是<strong>类似数组</strong>的对象。</p><h4 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h4><p>Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。</p><p>属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值true就会变成字符串true。</p><h4 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h4><p>Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否有指定的属性。</p><h4 id="Element-hasAttributes"><a href="#Element-hasAttributes" class="headerlink" title="Element.hasAttributes()"></a>Element.hasAttributes()</h4><p>Element.hasAttributes方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回false，否则返回true。</p><h4 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h4><p>Element.removeAttribute方法移除指定属性。该方法没有返回值。</p><h3 id="Element-querySelector"><a href="#Element-querySelector" class="headerlink" title="Element.querySelector()"></a>Element.querySelector()</h3><p>Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回null。</p><p>注意，这个方法无法选中伪元素。</p><p>它可以接受多个选择器，它们之间使用逗号分隔。</p><h3 id="Element-querySelectorAll"><a href="#Element-querySelectorAll" class="headerlink" title="Element.querySelectorAll()"></a>Element.querySelectorAll()</h3><p>Element.querySelectorAll方法接受 CSS 选择器作为参数，返回一个NodeList实例，包含所有匹配的子元素。</p><p>该方法的执行机制与querySelector方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p><p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的NodeList实例。</p><h3 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h3><p>Element.getElementsByClassName方法返回一个HTMLCollection实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p><p>注意，该方法的参数大小写敏感。</p><p>由于HTMLCollection实例是一个活的集合，document对象的任何变化会立刻反应到实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%884.59.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面代码中，matches集合的第一个成员，一旦被拿掉 class 里面的foo，就会立刻从matches里面消失，导致出现上面的结果。</p><h3 id="Element-getElementsByTagName"><a href="#Element-getElementsByTagName" class="headerlink" title="Element.getElementsByTagName()"></a>Element.getElementsByTagName()</h3><p>Element.getElementsByTagName方法返回一个HTMLCollection实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p><p><strong>注意</strong>，该方法的参数是大小写不敏感的。</p><h3 id="Element-closest"><a href="#Element-closest" class="headerlink" title="Element.closest()"></a>Element.closest()</h3><p>Element.closest方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回null。</p><h3 id="Element-matches"><a href="#Element-matches" class="headerlink" title="Element.matches()"></a>Element.matches()</h3><p>Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p><h3 id="事件相关方法"><a href="#事件相关方法" class="headerlink" title="事件相关方法"></a>事件相关方法</h3><p>以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="Element.scrollIntoView()"></a>Element.scrollIntoView()</h3><p>Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。</p><p>该方法可以接受一个布尔值作为参数。如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为true。</p><h3 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h3><p>Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p><p>只读。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.54.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意，getBoundingClientRect方法的所有属性，都把边框（border属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，width和height包括了元素本身 + padding + border。</p><h3 id="Element-getClientRects"><a href="#Element-getClientRects" class="headerlink" title="Element.getClientRects()"></a>Element.getClientRects()</h3><p>Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的Rect用的是复数）。每个矩形都有bottom、height、left、right、top和width六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p><p>对于盒状元素（比如&lt; div&gt;和&lt; p&gt;），该方法返回的对象中只有该元素一个成员。对于行内元素（比如&lt; span&gt;、&lt; a&gt;、&lt; em&gt;），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和Element.getBoundingClientRect()方法的主要区别，后者对于行内元素总是返回一个矩形。</p><h3 id="Element-insertAdjacentElement"><a href="#Element-insertAdjacentElement" class="headerlink" title="Element.insertAdjacentElement()"></a>Element.insertAdjacentElement()</h3><p>Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回null。</p><p>Element.insertAdjacentElement方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p><p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%886.12.22.png" alt=""></p><p>注意，beforebegin和afterend这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p><h3 id="Element-insertAdjacentHTML-，Element-insertAdjacentText"><a href="#Element-insertAdjacentHTML-，Element-insertAdjacentText" class="headerlink" title="Element.insertAdjacentHTML()，Element.insertAdjacentText()"></a>Element.insertAdjacentHTML()，Element.insertAdjacentText()</h3><p>Element.insertAdjacentHTML方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p><p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%886.22.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比innerHTML方法快得多。</p><p>注意，该方法会使 HTML 字符串显示为网页结构，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p><h3 id="Element-focus-，Element-blur"><a href="#Element-focus-，Element-blur" class="headerlink" title="Element.focus()，Element.blur()"></a>Element.focus()，Element.blur()</h3><p>Element.focus方法用于将当前页面的焦点，转移到指定元素上。</p><p>该方法可以接受一个对象作为参数。参数对象的preventScroll属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p><p>Element.blur方法用于将焦点从当前元素移除。</p><h3 id="Element-click"><a href="#Element-click" class="headerlink" title="Element.click()"></a>Element.click()</h3><p>Element.click方法用于在当前元素上模拟一次鼠标点击，相当于触发了click事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实战中的使用DOM&quot;&gt;&lt;a href=&quot;#实战中的使用DOM&quot; class=&quot;headerlink&quot; title=&quot;实战中的使用DOM&quot;&gt;&lt;/a&gt;实战中的使用DOM&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
               
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>html+css</title>
    <link href="https://github.com/zdkswd/2018/10/06/html+css/"/>
    <id>https://github.com/zdkswd/2018/10/06/html+css/</id>
    <published>2018-10-06T13:31:32.000Z</published>
    <updated>2018-10-11T07:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html-css"><a href="#html-css" class="headerlink" title="html+css"></a>html+css</h1><p>chrome市场份额多。</p><h1 id="常见浏览器内核介绍："><a href="#常见浏览器内核介绍：" class="headerlink" title="常见浏览器内核介绍："></a>常见浏览器内核介绍：</h1><p>浏览器内核又可以分成两个部分：渲染引擎（layout engineer或者Rendering Engine）和JS引擎。</p><p><strong>渲染引擎</strong>它负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入Css等),以及计算网页的显示方式,然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同,所以渲染的效果也不相同。</p><p><strong>JS引擎</strong>则是解析Javascript语言,执行 Javascript语言来实现网页的动态效果。</p><p>最开始渲染引擎和J5引擎并没有区分的很明确,后来]S引擎越来越独立,内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了个ACID来测试引擎的兼容性和性能。内核的种类很多,如加上没什么人使用的非商业的免费内核,可能会有10多种,但是常见的浏览器内核可以分这四种: Trident、 Gecko、 Blink、 Webkit。 </p><p>(1) Trident(IE内核)<br>国内很多的双核浏览器的其中一核便是 Trident,美其名曰”兼容模式”。<br>代表:、傲游、世界之窗浏览器、 Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。<br>Window10发布后,正将其内置浏览器命名为Edge,Edge最显著的特点就是新内核 EdgeHTML。</p><p>(2)Gecko(firefox)<br>Gecko( Firefox内核): Mozilla fire fox(火狐浏览器)采用该内核, Gecko的特点是代码完全公开,因此,其可开发程度很高,全世界的程序员都可以为其编写代码,增加功能。可惜这几年已经没落了,比如打开速度慢、升级频繁、猪一样的队友flash、神一样的对手 chrome。</p><p>(3) webkit(Safari)<br>Safari是苹果公司开发的浏览器,所用浏览器内核的名称是大名鼎鼎的 Webkit.<br>现在很多人错误地把 webkit叫做 chrome内核(即使 chrome内核已经是 blink了),苹果感觉像被别人抢了媳妇,都哭晕再厕所里面了。代表浏览器:傲游浏览器3、 Apple Safari(Win/ Mac_iPhone_iPad)、 Symbian手机浏览器、 Android默认浏览器。</p><p>(4) Chromium/Blink(chrome)<br>在 Chromium项目中研发 Blink渲染引擎(即浏览器核心),内置于 Chrome浏览器之中。 Blink其实是 Webkit的分支。<br>大部分国产浏览器最新版都采用Bink内核。</p><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p><p>Android手机而言,使用率最高的就是 Webkit内核,大部分国产浏览器宣称的自己的内核,基本上也是属于 webkit二次开发。</p><p>IOS以及WP7平台上,由于系统原因,系统大部分自带浏览器内核,一般是 Safari或者IE内核 Trident的。</p><h1 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h1><p>通过Web标准不同的浏览器内核展示统一内容。</p><h2 id="Web标准构成"><a href="#Web标准构成" class="headerlink" title="Web标准构成"></a>Web标准构成</h2><p>主要包括：结构（HTML）（<strong>最重要</strong>），表现（CSS），和行为（JS）。</p><h1 id="HTMl初识"><a href="#HTMl初识" class="headerlink" title="HTMl初识"></a>HTMl初识</h1><p>超（除了文字之外还有其他的，还可以链接），文本，标签，语言（有规范）。</p><p>语法骨架，一万年不变：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.08.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>h4之前标签是不分大小写的，h5之后最好小写。</p><p>头部是指标签栏位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.15.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>页面内容基本在body中。</p><h2 id="HTML标签分类"><a href="#HTML标签分类" class="headerlink" title="HTML标签分类"></a>HTML标签分类</h2><h3 id="双标签"><a href="#双标签" class="headerlink" title="双标签"></a>双标签</h3><p>一对尖括号。</p><p><head></head></p><h3 id="单标签"><a href="#单标签" class="headerlink" title="单标签"></a>单标签</h3><p><br><br>单标签数量非常少，用脚趾能数过来。<br>其中都有’/ ‘,’/‘表示关闭符。</p><h2 id="HTML标签关系"><a href="#HTML标签关系" class="headerlink" title="HTML标签关系"></a>HTML标签关系</h2><h3 id="嵌套关系"><a href="#嵌套关系" class="headerlink" title="嵌套关系"></a>嵌套关系</h3><p>父子关系</p><h3 id="并列关系"><a href="#并列关系" class="headerlink" title="并列关系"></a>并列关系</h3><p> <strong>倡议</strong>：如果两个标签之间的关系是嵌套关系，子元素最好缩进一个Tab的身位。如果是并列关系，最好上下对齐。</p><h2 id="HTML开发"><a href="#HTML开发" class="headerlink" title="HTML开发"></a>HTML开发</h2><p>使用sublime，输入html:5或者！后按下tab键自动生成骨骼框架。</p><p>右键在浏览器中打开，快捷键f12。</p><h3 id="文档类型-lt-DOCTYPE-gt"><a href="#文档类型-lt-DOCTYPE-gt" class="headerlink" title="文档类型&lt;!DOCTYPE&gt;"></a>文档类型&lt;!DOCTYPE&gt;</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.44.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>图中就是h5版本。</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.55.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>UTF-16固定用2个字节来存储。<br>UTF-8（国际通用）,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个..反正是根据字符对应的数字大小来确定。</p><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p>核心：在合适的地方给个合适的标签。</p><h2 id="HTMl常用标签"><a href="#HTMl常用标签" class="headerlink" title="HTMl常用标签"></a>HTMl常用标签</h2><h3 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h3><h4 id="（内容）标题标签（熟记）"><a href="#（内容）标题标签（熟记）" class="headerlink" title="（内容）标题标签（熟记）"></a>（内容）标题标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.05.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="段落标签（熟记）"><a href="#段落标签（熟记）" class="headerlink" title="段落标签（熟记）"></a>段落标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.28.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="水平线标签（认识）"><a href="#水平线标签（认识）" class="headerlink" title="水平线标签（认识）"></a>水平线标签（认识）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.34.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="语义化后的效果："><a href="#语义化后的效果：" class="headerlink" title="语义化后的效果："></a>语义化后的效果：</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.37.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="换行标签（熟记）"><a href="#换行标签（熟记）" class="headerlink" title="换行标签（熟记）"></a>换行标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.44.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="div-span标签（重点）"><a href="#div-span标签（重点）" class="headerlink" title="div span标签（重点）"></a>div span标签（重点）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.47.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常css+div<br>div独占一行，span一行可以放多个。</p><h4 id="文本格式化标签（熟记）"><a href="#文本格式化标签（熟记）" class="headerlink" title="文本格式化标签（熟记）"></a>文本格式化标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.51.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.54.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="图像标签img-重点"><a href="#图像标签img-重点" class="headerlink" title="图像标签img(重点)"></a>图像标签img(重点)</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.59.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.00.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.02.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>单独给宽高会等比缩放。</p><h4 id="链接标签（重点）"><a href="#链接标签（重点）" class="headerlink" title="链接标签（重点）"></a>链接标签（重点）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.22.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="锚点定位（难点）"><a href="#锚点定位（难点）" class="headerlink" title="锚点定位（难点）"></a>锚点定位（难点）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.40.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h4><p>base可以设置整体链接的打开状态。<br>在head中使用，单标签。</p><h4 id="特殊字符标签"><a href="#特殊字符标签" class="headerlink" title="特殊字符标签"></a>特殊字符标签</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8A%E5%8D%8811.52.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8A%E5%8D%8811.58.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="路径（重点难点）"><a href="#路径（重点难点）" class="headerlink" title="路径（重点难点）"></a>路径（重点难点）</h2><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.00.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.02.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>整齐有序。</p><h3 id="无序列表ul（重点）"><a href="#无序列表ul（重点）" class="headerlink" title="无序列表ul（重点）"></a>无序列表ul（重点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>先到先得，先到先显示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.09.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="有序列表ol-了解"><a href="#有序列表ol-了解" class="headerlink" title="有序列表ol(了解)"></a>有序列表ol(了解)</h3><p>注意事项和ul类似，使用也类似。</p><h3 id="自定义列表（理解）"><a href="#自定义列表（理解）" class="headerlink" title="自定义列表（理解）"></a>自定义列表（理解）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.17.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由三个标签组成。</p><p>效果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.19.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.20.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="表格table（会使用）"><a href="#表格table（会使用）" class="headerlink" title="表格table（会使用）"></a>表格table（会使用）</h2><p>表格不是用来布局的，常见处理，显示表格式数据。</p><h3 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.55.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.02.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.02.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.04.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>三参为0 border  cellpadding cellspacing 为0</p><h3 id="表头标签"><a href="#表头标签" class="headerlink" title="表头标签"></a>表头标签</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.11.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 一般第一行或第一列使用。居中且加粗。</p><h3 id="表格标题"><a href="#表格标题" class="headerlink" title="表格标题"></a>表格标题</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.14.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="表格结构（了解）"><a href="#表格结构（了解）" class="headerlink" title="表格结构（了解）"></a>表格结构（了解）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.21.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.23.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="合并单元格（难点）"><a href="#合并单元格（难点）" class="headerlink" title="合并单元格（难点）"></a>合并单元格（难点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%882.34.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 在td属性中使用。</p><h2 id="表单标签（掌握）"><a href="#表单标签（掌握）" class="headerlink" title="表单标签（掌握）"></a>表单标签（掌握）</h2><p>收集用户信息。<br>一个完整的表单通常由三部分组成：<br>表单控件（也称为表单元素）、提示信息和表单域。</p><h3 id="input控件（重点）"><a href="#input控件（重点）" class="headerlink" title="input控件（重点）"></a>input控件（重点）</h3><p>单标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.00.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> 用name来控制单选组，多选组。</p><h3 id="label标签（理解）"><a href="#label标签（理解）" class="headerlink" title="label标签（理解）"></a>label标签（理解）</h3><p>label标签为input元素定义标注（标签）。<br>作用：用于绑定一个表单元素，当点击label标签时，被绑定的表单元素就会获得输入焦点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.23.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="textarea控件（文本域）"><a href="#textarea控件（文本域）" class="headerlink" title="textarea控件（文本域）"></a>textarea控件（文本域）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.27.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.17.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.19.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>层叠样式表。</p><h2 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h2><h3 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.48.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式，其中属性和值的书写规范与CSS样式规范相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。注意是冒号。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.56.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。</p><p>type=“text/CSS”在H5中可以省略，写上也比较符合规范，所以这个地方可以写也可以省略。</p><h3 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.50.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在外部样式中，不用style标签，直接写就完事了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.14.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.22.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="选择器（重点）"><a href="#选择器（重点）" class="headerlink" title="选择器（重点）"></a>选择器（重点）</h2><h3 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h3><h4 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.24.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.31.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%885.20.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.27.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.29.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>id选择器和类选择器最大的不同在于使用次数。<br>id选择器id只能使用一次。<br> 使用‘#’ 定义，使用 id= 调用</p><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.39.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>几乎不用。</p><h2 id="CSS字体样式属性"><a href="#CSS字体样式属性" class="headerlink" title="CSS字体样式属性"></a>CSS字体样式属性</h2><h3 id="font-size：字号大小"><a href="#font-size：字号大小" class="headerlink" title="font-size：字号大小"></a>font-size：字号大小</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.44.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>统一用px</p><h3 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family:字体"></a>font-family:字体</h3><p>font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.49.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果字体都没有，就使用系统默认的字体。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.57.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了照顾浏览器的兼容性，可以使用Unicode编码。</p><h3 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight:字体粗细"></a>font-weight:字体粗细</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>bold字体加粗。使用normal也可以让标题不加粗。</p><h3 id="font-style：字体风格"><a href="#font-style：字体风格" class="headerlink" title="font-style：字体风格"></a>font-style：字体风格</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.05.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="综合设置字体样式（重点）"><a href="#综合设置字体样式（重点）" class="headerlink" title="综合设置字体样式（重点）"></a>综合设置字体样式（重点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.12.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="CSS外观属性"><a href="#CSS外观属性" class="headerlink" title="CSS外观属性"></a>CSS外观属性</h2><h3 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color:文本颜色"></a>color:文本颜色</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>十六进制时 # ff0000由于数值一样，可以简写为 # f00。</p><h3 id="line-height-行间距"><a href="#line-height-行间距" class="headerlink" title="line-height:行间距"></a>line-height:行间距</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.25.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="text-align-水平对齐方式"><a href="#text-align-水平对齐方式" class="headerlink" title="text-align:水平对齐方式"></a>text-align:水平对齐方式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.27.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>css中没有垂直对齐的方式。</p><p>是让盒子里面的内容居中，而不是让盒子居中。</p><h3 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent:首行缩进"></a>text-indent:首行缩进</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%8812.45.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="text-decoration文本的装饰"><a href="#text-decoration文本的装饰" class="headerlink" title="text-decoration文本的装饰"></a>text-decoration文本的装饰</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%8812.52.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%881.47.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>用空格隔开。</p><p>是选择所有的后代。</p><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><p>只选亲儿子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%881.55.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="并集选择器（重点）"><a href="#并集选择器（重点）" class="headerlink" title="并集选择器（重点）"></a>并集选择器（重点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，比如可以选择第一个，第n个元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.27.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.27.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>active是按下鼠标还没弹起的状态。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.35.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.24.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.25.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="标签的显示（display）"><a href="#标签的显示（display）" class="headerlink" title="标签的显示（display）"></a>标签的显示（display）</h2><h3 id="块级元素（block-level）"><a href="#块级元素（block-level）" class="headerlink" title="块级元素（block-level）"></a>块级元素（block-level）</h3><p>每个块元素通常都会<strong>独自占据一整行或者多整行</strong>，<strong>可以对其设置宽度、高度、对齐等属性</strong>，常用于网页布局和网页结构的搭建。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.33.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.35.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="行内元素（inline-level）"><a href="#行内元素（inline-level）" class="headerlink" title="行内元素（inline-level）"></a>行内元素（inline-level）</h3><p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.36.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.37.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>a里面可以放块级元素。</strong></p><p><strong>注意</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.38.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.41.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="显示模式转换"><a href="#显示模式转换" class="headerlink" title="显示模式转换"></a>显示模式转换</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.47.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每一个标签都是一个小盒子。</p><p><strong>如果是行内元素，行内块元素，我们可以看做文本，可以在块级使用text-align:center进行居中对齐。</strong></p><p><strong>使行高等于盒子的高度，可以让单行文本垂直居中。</strong></p><h2 id="行高的测量"><a href="#行高的测量" class="headerlink" title="行高的测量"></a>行高的测量</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.18.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.19.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.20.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a>CSS层叠性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.40.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.43.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.49.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.54.36.png" alt=""></p><h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><p>CSS可以添加背景颜色和背景图片，以及来进行图片设置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.06.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="背景颜色与背景图片"><a href="#背景颜色与背景图片" class="headerlink" title="背景颜色与背景图片"></a>背景颜色与背景图片</h3><p>同时设置的话背景图片会在背景颜色之上。</p><h3 id="backgroud-repeat"><a href="#backgroud-repeat" class="headerlink" title="backgroud-repeat"></a>backgroud-repeat</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.33.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="backgroud-position"><a href="#backgroud-position" class="headerlink" title="backgroud-position"></a>backgroud-position</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.34.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="backgroud-attachment"><a href="#backgroud-attachment" class="headerlink" title="backgroud-attachment"></a>backgroud-attachment</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.35.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.28.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="背景透明（CSS3）"><a href="#背景透明（CSS3）" class="headerlink" title="背景透明（CSS3）"></a>背景透明（CSS3）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.49.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="盒子边框"><a href="#盒子边框" class="headerlink" title="盒子边框"></a>盒子边框</h3><p>盒子边框即border,有border-width,border-style,border-color.<br>可简写为 border: 1px solid red;<br>其中border-style常用值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.12.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>border亦可单边进行设置。border-top;border-bottom;border-left;border-right。</p><h4 id="合并相邻边框"><a href="#合并相邻边框" class="headerlink" title="合并相邻边框"></a>合并相邻边框</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.13.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h3><p>默认贴在左上角。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.16.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.17.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>padding和border会<strong>撑开</strong>带有width和height的盒子。对于没有给定的就是盒子大小不变，内容进行了移动。</p><h3 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.54.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>margin值的个数表达的意思和padding类似。</p><p>使盒子水平居中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.20.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上下是0，左右是auto。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.23.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.24.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使块中的内容居中：text-align=center。</p><h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.33.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以比较大的为准。</p><p>解决方法：避免</p><h3 id="垂直外边距嵌套元素合并"><a href="#垂直外边距嵌套元素合并" class="headerlink" title="垂直外边距嵌套元素合并"></a>垂直外边距嵌套元素合并</h3><p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.40.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>只有垂直会发生这种情况。</p><p>解决方案：</p><ol><li>可以为父元素定义1像素的上外边框或上内边距。</li><li>可以为父元素添加overflow:hidden.</li></ol><h3 id="盒子布局的稳定性"><a href="#盒子布局的稳定性" class="headerlink" title="盒子布局的稳定性"></a>盒子布局的稳定性</h3><p>按照优先使用顺序：width&gt;padding&gt;margin<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.52.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="插入图片与背景图片"><a href="#插入图片与背景图片" class="headerlink" title="插入图片与背景图片"></a>插入图片与背景图片</h3><p> 插入图片 最多比如产品展示类；背景图片我们一般用于小图标背景或者超大背景图片。</p><h3 id="圆角边框（CSS3）"><a href="#圆角边框（CSS3）" class="headerlink" title="圆角边框（CSS3）"></a>圆角边框（CSS3）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.54.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也可以是px。值越大越圆。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%887.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第一个左上，顺时针。</p><h3 id="盒子阴影（CSS3）"><a href="#盒子阴影（CSS3）" class="headerlink" title="盒子阴影（CSS3）"></a>盒子阴影（CSS3）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.03.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.09.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="浮动（float）"><a href="#浮动（float）" class="headerlink" title="浮动（float）"></a>浮动（float）</h2><h3 id="普通流（normal-flow）"><a href="#普通流（normal-flow）" class="headerlink" title="普通流（normal flow）"></a>普通流（normal flow）</h3><p>也称为标准流，CSS的定位机制有三种：普通流、浮动和定位。</p><p>普通流实际就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思。比如块级元素会独占一行，行内元素会按顺序依次前后排列。</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>浮动让盒子浮起来，盒子的位置就由其他盒子占据。</p><p>浮动有个很有意思的事情：就是让任何盒子可以一行排列，我们就慢慢地利用浮动的特性来布局了。</p><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.19.38.png" alt=""></p><p>为什么不用inline-block?是有的时候需要右对齐，这时就不好知道具体的位置。需要量出来，不同的屏幕显示的效果不一样。而且块之间有缝隙。这时使用浮动就效果比较好。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.23.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>只有<strong>左右</strong>。浮动的和浮动的又符合标准流。</p><p>浮动的盒子跨越不了padding值。</p><p>一个盒子浮动，会影响后面的位置，影响不了前面的位置，也就是说不会往上面的元素上浮。</p><p>浮动有一个隐藏的模式转换，浮动可以让元素默认转换为<strong>行内块元素</strong>，宽度取决于元素的大小。</p><p>如果已经给行内元素添加了浮动，此时不需要转换该元素也可以有宽高。</p><h2 id="版心和布局流程"><a href="#版心和布局流程" class="headerlink" title="版心和布局流程"></a>版心和布局流程</h2><p>为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下：</p><ol><li>确定页面的版心（可视区）。</li><li>分析页面中的行模块，以及每个行模块中的列模块。</li><li>制作HTML结构。</li><li>CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;html-css&quot;&gt;&lt;a href=&quot;#html-css&quot; class=&quot;headerlink&quot; title=&quot;html+css&quot;&gt;&lt;/a&gt;html+css&lt;/h1&gt;&lt;p&gt;chrome市场份额多。&lt;/p&gt;
&lt;h1 id=&quot;常见浏览器内核介绍：&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="https://github.com/zdkswd/tags/CSS/"/>
    
      <category term="HTML" scheme="https://github.com/zdkswd/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第四章 谈谈中文分词</title>
    <link href="https://github.com/zdkswd/2018/09/26/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B0%88%E8%B0%88%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    <id>https://github.com/zdkswd/2018/09/26/数学之美 第四章 谈谈中文分词/</id>
    <published>2018-09-26T10:16:32.000Z</published>
    <updated>2018-09-26T10:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中文分词方法的演变"><a href="#中文分词方法的演变" class="headerlink" title="中文分词方法的演变"></a>中文分词方法的演变</h1><p>对于西方拼音语言来说，词之间有明显的分界符，统计和使用语言模型非常直接。而对于中日韩泰等语言，词之间没有明确的分界符。</p><p>最容易想到的分词方法,也是最简单的办法,就是查字典。“查字典”的办法,其实就是把一个句子从左向右扫描一遍,遇到字典里有的词就标识出来,遇到复合词(比如“上海大学”)就找最长的词匹配,遇到不认识的字串就分割成单字词,于是简单的分词就完成了。</p><p>这个最简单的方法可以解决七八成以上的分词问题,遇到稍微复杂一点的问题就无能为力了。这种方法的一个明显不足时当遇到有二义性的分割时无能为力，另外并非所有的最长匹配都是一定正确的。</p><p>利用统计语言模型分词的方法,可以用几个数学公式简单概括如下:假定一个句子S可以有几种分词方法,为了简单起见,假定有以下三种:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B0%88%E8%B0%88%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%885.52.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中,A1,A2…B1,B2…,C1,C2…等等都是汉语的词,那么最好的一种分词方法应该保证分完词后这个句子出现的概率最大。</p><p>当然,这里面有一个实现的技巧。如果穷举所有可能的分词方法并计算出每种可能性下句子的概率,那么计算量是相当大的。因此,可以把它看成是一个动态规划( Dynamic Programming)的问题,并利用维特比( Viterbi)算法快速地找到最佳分词。(我们在后面的章节会介绍该算法。)</p><p>一般来讲,根据不同应用,汉语分词的颗粒度大小应该不同。</p><p>中文分词方法可以帮助判别英语单词的边界。因为手写英文字符时已经不能明显的区分边界了。</p><p>最后,需要指出的是任何方法都有它的局限性,虽然利用统计语言模型进行分词,可以取得比人工更好的结果,但是也不可能做到百分之百准确。因为统计语言模型很大程度上是依照“大众的想法”,或者“多数句子的用法”,而在特定情况下可能是错的。</p><h1 id="工程上的细节"><a href="#工程上的细节" class="headerlink" title="工程上的细节"></a>工程上的细节</h1><h2 id="分词的一致性"><a href="#分词的一致性" class="headerlink" title="分词的一致性"></a>分词的一致性</h2><p>如何衡量分词结果的对与错,好与坏看似容易,其实不是那么简单。说它看似容易,是因为只要对计算机分词的结果和人工分词的结果进行比较就可以了。说它不是那么简单,是因为不同的人对同一个句子可能有不同的分词方法。不同的人对词的切分看法上的差异性远比我们想象的要大得多。当统计语言模型被广泛应用后,不同的分词器产生的结果的差异要远远小于不同人之间看法的差异,这时简单依靠与人工分词的结果比较来衡量分词器的准确性就很难,甚至是毫无意义的了。中文分词现在是一个已经解决了的问题,提高的空间微乎其微了。只要采用统计语言模型,效果都差不到哪里去。</p><h2 id="词的颗粒度和层次"><a href="#词的颗粒度和层次" class="headerlink" title="词的颗粒度和层次"></a>词的颗粒度和层次</h2><p>人工分词产生不一致性的原因主要在于人们对词的颗粒度的认识问题。在这里不去强调谁的观点对,而是要指出在不同的应用中,会有一种颗粒度比另一种更好的情况。比如在机器翻译中,一般来讲,颗粒度大翻译效果好。比如“联想公司”作为一个整体,很容易找到它对应的英语翻译 Lenovo,如果分词时将它们分开,很有可能翻译失败。</p><p>虽然可以对不同的应用构造不同的分词器,但是这样做不仅非常浪费,而且也不必要。更好的方法是让一个分词器同时支持不同层次的词的切分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中文分词方法的演变&quot;&gt;&lt;a href=&quot;#中文分词方法的演变&quot; class=&quot;headerlink&quot; title=&quot;中文分词方法的演变&quot;&gt;&lt;/a&gt;中文分词方法的演变&lt;/h1&gt;&lt;p&gt;对于西方拼音语言来说，词之间有明显的分界符，统计和使用语言模型非常直接。而对于中日韩
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 常用内建库</title>
    <link href="https://github.com/zdkswd/2018/09/24/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97%20/"/>
    <id>https://github.com/zdkswd/2018/09/24/Python廖雪峰 常用内建模块 /</id>
    <published>2018-09-24T09:05:56.000Z</published>
    <updated>2018-09-24T09:07:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><p>datetime是Python处理日期和时间的标准库。</p><h2 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.11.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。</p><p>如果仅导入import datetime，则必须引用全名datetime.datetime。</p><p>datetime.now()返回当前日期和时间，其类型是datetime。</p><h2 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h2><p>直接用参数构造一个datetime。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.14.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h2><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</p><p>timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p><p>把一个datetime类型转换为timestamp只需要简单调用timestamp()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.17.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>注意</strong>Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。</p><p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p><h2 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h2><p>要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.22.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这个得到的时间就是当前操作系统设定的时区，timestamp也可以直接被转换到UTC标准时区的时间。datetime.utcfromtimestamp</p><h2 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h2><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.26.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h2><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.28.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h2><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.34.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="本地时间转换为UTC时间"><a href="#本地时间转换为UTC时间" class="headerlink" title="本地时间转换为UTC时间"></a>本地时间转换为UTC时间</h2><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p><h2 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h2><p>我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间。</p><p>datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p><h1 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h1><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.43.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。</p><p>作用是更直接，像类一样表明这个的用途，但又不是类，没那么重。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.05.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.10.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。</p><p>除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。</p><h2 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p><p>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序。</p><p>dict内是无序的。</p><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>Counter是一个简单的计数器，例如，统计字符出现的个数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.40.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Counter实际上也是dict的一个子类。</p><h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p><p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%。6bit表示一个字符在表中的位置。表中共有64个字符。</p><p>Python内置的base64可以直接进行base64的编解码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符+和/分别变成-和_<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.54.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。</p><p>尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p><h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p><p>摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p><p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p><p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p><p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p><p>这个函数是一个单向函数，可以通过对比结果的不同来判断原文是否发生过篡改。当然有可能发生两个不同的数据通过某个摘要算法得到了相同的摘要，这种情况叫做碰撞，非常非常罕见。</p><p>可以用来在数据库中存储使用md5加密过后的密码，用户登录时，经过计算再与数据库中的摘要作比较。</p><h1 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h1><p>Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p><p>Python自带的hmac模块实现了标准的Hmac算法。</p><p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%883.26.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。</p><p>Python内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。</p><h1 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h1><p>Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。</p><h2 id="chain"><a href="#chain" class="headerlink" title="chain()"></a>chain()</h2><p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器</p><h2 id="groupby"><a href="#groupby" class="headerlink" title="groupby()"></a>groupby()</h2><p>groupby()把迭代器中相邻的重复元素挑出来放在一起。</p><h1 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h1><p>实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句。实现上下文管理是通过<strong>enter</strong>和<strong>exit</strong>这两个方法实现的。 一个是with触发的时候，一个是退出的时候。编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法。</p><p>contextlib是个比with优美的东西，也是提供上下文机制的模块，它是通过Generator装饰器实现的。不再是采用<strong>enter</strong>和<strong>exit</strong>。contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制。</p><p>一个上下文管理器通过with声明激活, 而且API包含两个方法。__enter__()方法运行执行流进入到with代码块内。他返回一个对象共上下文使用。当执行流离开with块时，__exit__()方法上下文管理器清除任何资源被使用。</p><h2 id="closing"><a href="#closing" class="headerlink" title="@closing"></a>@closing</h2><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()。</p><p>closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%884.47.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p><h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><p>urllib提供了一系列用于操作URL的功能。</p><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应。</p><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p><h2 id="DOM-vs-SAX"><a href="#DOM-vs-SAX" class="headerlink" title="DOM vs SAX"></a>DOM vs SAX</h2><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p><p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p><p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%884.57.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。</p><h1 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h1><p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p><p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。</p><p>Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码。</p><p>利用HTMLParser，可以把网页中的文本、图像等解析出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;datetime&quot;&gt;&lt;a href=&quot;#datetime&quot; class=&quot;headerlink&quot; title=&quot;datetime&quot;&gt;&lt;/a&gt;datetime&lt;/h1&gt;&lt;p&gt;datetime是Python处理日期和时间的标准库。&lt;/p&gt;
&lt;h2 id=&quot;获取当前日期
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第三章 统计语言模型</title>
    <link href="https://github.com/zdkswd/2018/09/18/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/zdkswd/2018/09/18/数学之美 第三章 统计语言模型/</id>
    <published>2018-09-18T12:25:32.000Z</published>
    <updated>2018-09-18T12:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>自然语言从它产生开始,逐渐演变成一种上下文相关的信息表达和传递的方式,因此让计算机处理自然语言,一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型( Statistical Language Model),它是今天所有自然语言处理的基础,并且广泛应用于机器翻译、语音识别、印刷体或手写体识别、拼写纠错、汉字输入和文献查询。</p><h1 id="用数学的方法描述语言规律"><a href="#用数学的方法描述语言规律" class="headerlink" title="用数学的方法描述语言规律"></a>用数学的方法描述语言规律</h1><p>统计语言模型产生的初衷是为了解决语音识别问题。</p><p>相比较于传统的基于语法语义的分析。贾里尼克的出发点很简单:一个句子是否合理,就看看它的可能性大小如何。至于可能性就用概率来衡量。第一个句子出现的概率大致是十的负二十次方，第二个句子出现的概率是十的负二十五次方,第三个句子出现的概率是十的负七十次方。因此,第一个最有可能,它的可能是第二个句子的10万倍,是第三个句子的一百亿亿亿亿亿亿倍。这个方法更普通而严格的描述是:</p><p>假定S表示某一个有意义的句子，由一连串特定顺序排列的词w1,w2,…,wn组成，这里n是句子的长度。若是想知道S在文本中出现的可能性，即数学上所说的S的概率P（S）。当然可以把世界上所有出现过的话统计一下，便知道这句话出现的概率了。当然这是不可能做到的。因此，需要有个模型来估算它。S=w1,w2,…,wn,那么P(S)=P(w1,w2,…,wn)<br>利用条件概率公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.36.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>到了词wn，它的出现概率取决于它前面的所有词，到了最后一个词wn，条件概率P的可能性太多，无法估算。</p><p>俄罗斯数学家提出了一个偷懒且颇为有效的方法，即<strong>马尔科夫假设</strong>。假设任意一个词wi出现的概率只同它前面的词wi-1有关。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.46.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>公式对应的统计语言模型是二元模型。假设一个词由前面N-1个词决定，对应的模型稍微复杂些，被称为N元模型。</p><p><img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.55.16.png" alt=""></p><p>估计联合概率P(wi-1，wi)和边缘概率P(wi-1),现在变得很简单。因为有了大量机读文本,也就是专业人土讲的语料库,只要数一数wi-1,wi这对词在统计的文本中前后相邻出现了多少次#（w-1,w),以及W-1本身在同样的文本中出现了多少次#(wi-1),然后用两个数分别除以语料库的大小#,即可得到这些词或者二元组的相对频度:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.53.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>根据大数定理，只要统计量足够，相对频度就等于概率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.59.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="统计语言模型的工程诀窍"><a href="#统计语言模型的工程诀窍" class="headerlink" title="统计语言模型的工程诀窍"></a>统计语言模型的工程诀窍</h1><h2 id="高阶语言模型"><a href="#高阶语言模型" class="headerlink" title="高阶语言模型"></a>高阶语言模型</h2><p>显然一个词只跟前面一个词有关，似乎太简化，因此，更普遍的假设是某个词和前面若干个词有关。</p><p>假定文本中的每个词wi和前面N-1个词有关，而与更前面的词无关，这样当前词wi的概率只取决于前面N-1个词P。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%883.06.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这就是N-1阶马尔可夫假设，对应的语言模型称为N元模型。而实际应用中使用最多的是N=3的三元模型，更高阶的模型就很少使用了。</p><p>主要是因为N元模型的空间复杂度几乎是N的指数函数，即O（|V|^N），这里|V|是一种语言词典的词汇量，一般在几万到几十万个。同样时间复杂度也几乎是一个指数函数O（|V|^（N-1）），因此N不能很大。当N从1到2，再从2到3时，模型的效果上升显著。当模型从3到3时，效果的提升就不是很显著了，而资源的耗费增加却非常快，所以，除非是不惜资源为了做到极致，很少有人使用四元以上<br>的模型。Google的罗塞塔翻译系统和语言搜索系统,使用的是四元模型,该模型存储于500台以上的 Google服务器中。</p><h2 id="模型的训练、零概率问题和平滑方法"><a href="#模型的训练、零概率问题和平滑方法" class="headerlink" title="模型的训练、零概率问题和平滑方法"></a>模型的训练、零概率问题和平滑方法</h2><p>使用语言模型需要知道模型中所有的条件概率,我们称之为模型的参数。通过对语料的统计,得到这些参数的过程称作模型的训练。</p><p>在数理统计中,我们之所以敢于用对采样数据的观察结果来预测概率,是因为有大数定理( Law of Large Numbers)在背后做支持,它的要求是有足够的观测值。</p><p>一个直接的办法就是增加数据量,但是即使如此,依然会遇到零概率或者统计量不足的问题。假定要训练一个汉语的语言模型,汉语的词汇量大致是20万这个量级,训练一个三元模型就有8*10的15次方个不同的参数。假如从互联网上刨去垃圾数据,有100亿个有意义的中文网页,这已经是相当高估的数据,每个网页平均1000词。那么,即使将互联网上全部的中文内容都用作训练,依然只有10的13次方,因此,如果用<br>直接的比值计算概率,大部分条件概率依然是零,这种模型我们称之为不平滑。在实际应用中,统计语言模型的零概率问题是无法回避的。</p><p>古德-图灵估计可以解决这个问题。当一个词出现的频次过小时，统计可能不可靠，计算它们的概率时要使用一个更小一点的次数,是dr(而不直接使用r),古德-图灵估计按照下面的公式计算dr：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%884.16.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在语料库中出现r次的词有Nr个，语料库的大小为N。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%884.22.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>一般来说,出现一次的词的数量比出现两次的多,出现两次的比出现三次的多。这种规律称为zipf定律(zipf’s Law)。</p><p>r越大词的数量Nr越小。因此一般情况下dr&lt;r,而d0&gt;0。这样就给未出现的词赋予了一个很小的非零值，从而解决了零概率的问题。同时下调了出现频率很低的词的概率。当然,在实际的自然语言处理中,一般对出现次数超过某个阈值的词,频率不下调,只对出现次数低于这个阈值的词,频率才下调,下调得到的频率总和给未出现的词。</p><p>这样出现r次的词的概率估计为dr/N。于是,对于频率超过一定阈值的词,它们的概率估计就是它们在语料库中的相对频度,对于频率小于这个阈值的词,它们的概率估计就小于它们的相对频度,出现次数越少的,折扣越多。对于未看见的词,也给予了一个比较小的概率。这样所有词的概率估计都很平滑了。</p><p>例如对于三元模型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%888.15.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>函数fgt()表示经过古德-图灵估计后的相对频度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%888.16.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="语料的选取问题"><a href="#语料的选取问题" class="headerlink" title="语料的选取问题"></a>语料的选取问题</h1><p>训练数据应当相关，训练数据通常是越多越好。虽然介绍了相关的方法去解决缺数据的问题，但是在数据量最多的时候概率模型的参数可以估计得比较准确，高阶的模型因为参数多,需要的训练数据也相应会多很多。遗憾的是,并非所有的应用都能得到足够的训练数据,比如说机器翻译的双语语料就非常少,在这种情况下片面追求高阶的大模型就变得一点意义也没有了。</p><p>在训练数据和应用数据一致并且训练量足够大的情况下,训练语料的噪音高低也会对模型的效果产生一定的影响,因此,在训练以前有时需要对训练数据进行预处理。一般情况下,少量的(没有模式的)随机噪音清除起来成本非常髙,通常就不做处理了。但是对于能找到模式( Pattern)的、量比较大的噪音还是需要进行过滤的,而且它们也比较容易处理,比如网页文本中大量的制表符。因此,在成本不高的情况<br>下,过滤训练数据还是需要做的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自然语言从它产生开始,逐渐演变成一种上下文相关的信息表达和传递的方式,因此让计算机处理自然语言,一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型( Statistical Language Model),它是今
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第二章 自然语言处理--从规则到统计</title>
    <link href="https://github.com/zdkswd/2018/09/18/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86--%E4%BB%8E%E8%A7%84%E5%88%99%E5%88%B0%E7%BB%9F%E8%AE%A1/"/>
    <id>https://github.com/zdkswd/2018/09/18/数学之美 第二章 自然语言处理--从规则到统计/</id>
    <published>2018-09-18T01:07:32.000Z</published>
    <updated>2018-09-18T01:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何语言都是一种编码的方式，而语言的语法规则则是编解码的算法。</p><p>在上世纪70年代之前，计算机对自然语言的处理集中在分析语句和获取语义，基于规则的自然语言处理。主要是因为当时的学术界存在误区，即要让计算机完成翻译或者是语音识别这样只有人类能做到的事情，就必须先让计算机理解自然语言。因为从直觉上大家都会这么认为。但是相比于上下文无关文法，自然语言这种上下文有关的文法对于同样长度的句子复杂度是前者的万倍，因为上下文有关，所以需要更多额外的信息来表示现在的上下文，以及将自然语言变成及其复杂得树，在计算能力没法跟上的那个年代根本没有办法商用。</p><h1 id="从规则到统计"><a href="#从规则到统计" class="headerlink" title="从规则到统计"></a>从规则到统计</h1><p>随着保守的教授陆续的退休，慢慢地研究方向从基于规则逐渐转向了基于统计。</p><p>15年,对于一个学者来讲是一段非常长的时间,如果哪个人从做博士开始就选错了方向并且坚持错误,到15年后发现时,基本上这一辈子可能就一事无成了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>基于统计的自然语言处理方法，在数学模型和通信是相通的，甚至就是相同的。因此，在数学意义上自然语言处理又和语言的初衷–通信联系在一起了。但是，科学家们认识到这个联系却花了几十年的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;任何语言都是一种编码的方式，而语言的语法规则则是编解码的算法。&lt;/p&gt;
&lt;p&gt;在上世纪70年代之前，计算机对自然语言的处理集中在分析语句和获取语义，基于规则的自然语言处理。主要是因为当时的学术界存在误区，即要让计算机完成翻译或者是语音识别这样只有人类能做到的事情，就必须先让
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第一章 文字和语言vs数字和信息</title>
    <link href="https://github.com/zdkswd/2018/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%96%87%E5%AD%97%E5%92%8C%E8%AF%AD%E8%A8%80vs%E6%95%B0%E5%AD%97%E5%92%8C%E4%BF%A1%E6%81%AF/"/>
    <id>https://github.com/zdkswd/2018/09/14/数学之美 第一章 文字和语言vs数字和信息/</id>
    <published>2018-09-14T12:41:32.000Z</published>
    <updated>2018-09-14T12:41:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15369247546524/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-14%20%E4%B8%8B%E5%8D%888.03.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="文字和数字"><a href="#文字和数字" class="headerlink" title="文字和数字"></a>文字和数字</h1><p>当语言和词汇多到一定程度时，人类仅靠大脑已经记不住所有的词汇了。高效记录信息的需求就产生了，这便是文字。</p><p>最早是象形文字，当文字的数量多到一定程度时便不再增加了，于是开始了对概念的概括与归类。比如中文的一字多意。对于概念的聚类在原理上与今天自然语言处理或机器学习的聚类有很大的相似性。</p><p>文字按照意思来聚类，最终会带来一些歧义性，解决这个问题的方法过去与现在并没有什么不同，都是依靠上下文。但是还是会有有歧义的情况发生。今天的情况也是这样，对上下文建立的概率模型再好也有失灵的时候。这些事语言从产生开始就固有的特点。</p><p>翻译之所以能够进行，仅仅是因为不同的文字系统在记录信息上的能力是等价的（这一点非常重要）。文字只是信息的载体，而非信息本身。即使不用文字使用如数字的载体也可以存储同样意义的信息。这便是现代通信的基础。</p><p>当然,不同的文明进行交流时,或许会用不同的文字记载同一件事情。这就有可能为我们破解无人能懂的语言提供一把钥匙。</p><p><strong>罗塞塔</strong>石碑使用了三种语言记录的同一件事情，罗塞塔石碑的破解有两点指导意义。首先，信息的冗余是信息安全的保障，其次，语言的数据，又称为语料尤其是双语或者多语对照语料对翻译至关重要。</p><p>既然文字是出现在远古“信息爆炸”导致人们的头脑装不下这些信息的时候,那么数字的出现则是在人们的财产多到需要数一数才搞清楚有多少的时候。</p><p>最开始是掰手指头来计数的，所以自然而然的就是十进制了。当然，也有连脚指头算上去的民族，所以他们是二十进制。当十进制不够用时，我们的祖先很聪明,他们发明了进位制,也就是我们今天说的逢十进一。这是人类在科学上的一大飞跃,因为我们的祖先懂得对数量开始编码了,不同的数字代表不同的量。比如二百，就是编过码的数字，解码的方法是乘法2*100。从编码的有效性来说，中国人的做法比罗马人高明。</p><p>阿拉伯人传播的古印度发明的数字123是革命性的，标志着数字和文字的分离。</p><h1 id="文字和语言背后的数学"><a href="#文字和语言背后的数学" class="headerlink" title="文字和语言背后的数学"></a>文字和语言背后的数学</h1><p>但是,任何事物的规律性是内在的,并不随它的载体而改变。自然语言的发展在冥冥之中,都受着信息科学规律的引导。</p><p>从象形文字到拼音文字是一个飞跃,因为人类在描述物体的方式上,从物体的外表到抽象的概念,同时不自觉地采用了对信息的编码。不仅如此,我们的祖先对文字的编码还非常合理。常用的较短，不常用的较长。这完全符合信息论中的最短编码原理。</p><p>在蔡伦发明纸张以前,书写文字不是一件容易的事情。就以中文为例在东汉以前要将文字刻在其他物件比如龟壳、石碑和竹简上。由于刻个字的时间相当长,因此要惜墨如金。这就使得我们的古文(书面文字)非常简洁,但是非常难懂,而同时期的口语却和今天的白话差别不大,语句较长但是易懂。(岭南客家话基本上保留了古代口语的原貌,写出来和我们清末民初的白话颇为相似。)这种现象非常符合今天信息科学(和工程)的一些基本原理,就是在通信时,如果信道较宽,信息不必压缩就可以直接传递;而如果信道很窄,信息在传递前需要尽可能地压缩,然后在接收端进行解压缩。</p><p>犹太人在抄写《圣经》时,抄写错误还是难以避免。于是犹<br>太人发明了一种类似于我们今天计算机和通信中<strong>校验码</strong>的方法。他们把每一个希伯来字母对应于一个数字,这样每行文字加起来便得到一个特殊的数字,这个数字便成为了这一行的校验码。同样,对于每一列也是这样处理。当犹太学者抄完一页《圣经》时,他们需要把每一行的文字加起来,看看新的校验码是否和原文的相同,然后对每一页进行同样的处理。如果这一页每一行和每一列的校验码和原文完全相同,说明这一页的抄写无误。如果某行的校验码和原文中的对应不上,则说明这行至少有一个抄写错误。当然,错误对应列的校验码也一定和原文对不上,这样可以很快找到出错的地方。</p><p>如果说从字母到词的构词法(Morphology)是词的编码规则,那么语法则是语言的编码和解码规则。不过,相比较而言,词可以被认为是有限而且封闭的集合,而语言则是无限和开放的集合。从数学上讲,对于前者可以有完备的编解码规则,而后者则不具备这个特性。因此,任何语言都有语法规则覆盖不到的地方,这些例外或者说不精确性,让我们的语言丰富多彩。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这些今天自然语言处理学者们研究的问题,我们的祖先在设计语言的时候其实已经遇到了,并且用类似今天的方法解决了,虽然他们的认识大多是自发的,而不是自觉的。他们过去遵循的法则和我们今天探求的研究方法背后有着共同的东西,这就是数学规律。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;

      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>浪潮之巅读书笔记</title>
    <link href="https://github.com/zdkswd/2018/09/14/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/zdkswd/2018/09/14/浪潮之巅读书笔记/</id>
    <published>2018-09-14T11:08:47.000Z</published>
    <updated>2018-09-14T11:09:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转载加修改，自用。"><a href="#转载加修改，自用。" class="headerlink" title="转载加修改，自用。"></a>转载加修改，自用。</h1><h1 id="对书名《浪潮之巅》中“浪潮”的理解"><a href="#对书名《浪潮之巅》中“浪潮”的理解" class="headerlink" title="对书名《浪潮之巅》中“浪潮”的理解"></a>对书名《浪潮之巅》中“浪潮”的理解</h1><p>书名为“浪潮之巅”。顾名思义，本书就是讲述那些曾经或正站在互联网浪潮的巅峰的企业。书中列举了好多我们耳熟能详的企业名称，例如苹果公司、微软、诺基亚等等，“之巅”大家都能理解，即”巅峰“的意思，这些公司无疑能让大家所知，无疑都是在各自领域中极有成就的，然而成就它们达到巅峰状态的，除了自身的内功之外，无一例外的，就是这些伟大的公司都赶上了IT产业的兴起、发展与升级。<br>因而“浪潮”可以这样理解：科技革命的浪潮，同时也可以专指信息技术革命的浪潮。</p><h1 id="那些曾经或正在浪潮之巅的弄潮儿们"><a href="#那些曾经或正在浪潮之巅的弄潮儿们" class="headerlink" title="那些曾经或正在浪潮之巅的弄潮儿们"></a>那些曾经或正在浪潮之巅的弄潮儿们</h1><h2 id="帝国黄昏之AT-amp-T公司"><a href="#帝国黄昏之AT-amp-T公司" class="headerlink" title="帝国黄昏之AT&amp;T公司"></a>帝国黄昏之AT&amp;T公司</h2><p>AT&amp;T公司创始人，说起来很有名，即使电话的发明人贝尔，后来AT&amp;T公司旗下有闻名于世的贝尔实验室，该实验室出过十一位诺贝尔奖得主。</p><p>AT&amp;T可谓老字号，于1877年成立，一百年来发展的顺风顺水，很长时期内垄断整个北美的通信业务。虽然有美国政府的反垄断调查，但是每次调查都会帮AT&amp;T公司剪除枝叶，让它更加茁壮。例如1913年美国司法部的调查，避免了AT&amp;T公司的大肆扩张，这反而让它顺利度过了大萧条时期。</p><p>时间到了1984年，AT&amp;T终于挺不过<strong>反垄断调查</strong>，公司进行了拆分，由一家分成7家，这次修剪让AT&amp;T公司从以通话业务为主转向了新兴的网络和移动通信方面。</p><p>1995年在华尔街<strong>逐利的资本驱动</strong>下，这一次公司高管自我拆分，而正是这个举动让AT&amp;T伤筋动骨。然而明白人大有人在，但是禁不住股票期权的诱惑，公司的未来在目前金钱的诱惑下一文不值。接下来的2000年公司又被拆分为四家，而此时AT&amp;T公司已经错过了互联网的浪潮。由于AT&amp;T主营业务是固定电话业务，互联网兴起后，人们可以直接用网络通话，再也不想用AT&amp;T那昂贵的通话业务了。<br>曾经最能代表行业发展的AT&amp;T，由于华尔街资本的贪婪和技术浪潮的波动，已经变成了明日黄花。</p><h2 id="科技界常青树之IBM"><a href="#科技界常青树之IBM" class="headerlink" title="科技界常青树之IBM"></a>科技界常青树之IBM</h2><p>IBM公司成立于1924年，由托马斯·华生创立。<br>IBM成立的时间正好是第二次工业革命的末期，它发明一种机器，能够帮助政府和大型企业组织进行统计数据的整理和简单分析，因而早期的IBM，<strong>其主要客户就是政府和大型组织。</strong></p><p>二战结束后，公司由托马斯·华生的儿子小华生接任，他是一位伟大的领导者，正是在他的带领下，IBM走向辉煌，并引领了第三次科技革命。</p><p>“电子计算机和IBM的名字是分不开的，就如同电话和AT&amp;T分不开一样”。吴军博士的这句话充分说明了IBM公司同电子计算机的相互促进作用。</p><p>在小华生的带领下，IBM投注计算机行业，在提高研究经费的同时也召来很多优秀工程师，并且参与了计算机行业标准的制定。正是这样的举动，IBM公司在小华生执掌期间，业绩年均增长30%，同时IBM公司很高的薪水也吸引了优秀的年轻人加入计算机行业。</p><p>从1950年代到1980年代这时期的IBM公司可以说是独孤求败。而这种垄断地位自然而然遭到了美国政府的反垄断调查。IBM公司不得不进行拆分，并想社会公布自己的一些专利和技术。</p><p>然而，由于IBM的业务重心一直在政府和大型企业这边，它就不可能把工作重点放在个人电脑业务上，此时一位天才人物比尔·盖茨看到了个人电脑的伟大前景，伴随着摩尔定律的作用，日渐强大的个人计算机不断蚕食IBM的主营业务，IBM就像一个走向坟墓的巨人。</p><p>1993年，郭士纳临危受命，拯救IBM。郭士纳果断出售不赚钱的硬件业务，把个人电脑业务卖给联想，从硬件制造商转型为服务政府和大型企业组织。这次转型是相当成功的，IBM公司成功从坟墓中爬了出来。</p><p>目前IBM公司是拥有专利最多的公司，在2001年起市值一度超过了微软。</p><h2 id="向死而生之苹果"><a href="#向死而生之苹果" class="headerlink" title="向死而生之苹果"></a>向死而生之苹果</h2><p>说起苹果公司，就一定要讲到史蒂夫·乔布斯。在吴军博士看来，他可谓是硅谷最具传奇色彩的人物。他是唯一一个大学没有超过一年就获得美国工程院院士的人，而他获选院士的理由是：在个人计算机领域的伟大贡献。</p><p>1976年苹果公司成立，当时乔布斯和他的小伙伴们的愿望是把昂贵的计算机商业化，让计算机走进千家万户。当时的计算机很昂贵，价值几万美元。而当苹果电脑一代出来时，只需花费数百美元。</p><p>虽然现在看起来苹果一代几乎做不了什么事，但这代表了计算机不再是大型组织的专属用品，它有可能走进千家万户。<br>与此同时，1980年代的IT产业巨人IBM也向个人计算机领域进军，一出售就占据了当时个人电脑市场的75%。针对于此，乔布斯致力于开发苹果二代，终于1984年研制出来，这是真正意义上有交互式图形界面并且有鼠标的个人电脑。而这个产品也广受市场欢迎，同时助推苹果股价攀上高峰<br>然而好景不长，此时的苹果公司邀请了原百事可乐总裁斯库利加盟，一年之后乔布斯出走。而苹果公司在斯库利的带领下，凭借乔布斯留下的财产，还能坚挺一阵子，然而苹果的摊子越铺越大，虽然开展了不少项目，但收效甚微。同时苹果电脑业务在微软的挤压下日薄西山。</p><p>1998年的苹果决定请回乔布斯，让他执掌苹果这艘破船，而乔布斯也不愿意看着自己所创立的公司倒闭，在他的带领下，苹果公司逐渐走出低谷，获得新生。</p><p>进入21世纪的苹果公司发展了两项业务：一个是iPod，一个是iPhone。</p><p>iPod的成功是因为乔布斯利用了音乐的数字化浪潮，而iPhone的成功同样借助3G时代的东风，如果这两件产品提前几年，估计不会有现在的成功，而乔布斯天才的地方在于他牢牢抓住了这两次浪潮，才成就了今天的苹果。</p><h2 id="前途未知的微软帝国"><a href="#前途未知的微软帝国" class="headerlink" title="前途未知的微软帝国"></a>前途未知的微软帝国</h2><p>吴军博士这样形容微软：“微软永远是所有公司最可怕的敌人。微软靠它在操作系统上的垄断地位和无比雄厚的财力，在计算机领域几乎是无往而不胜。</p><p>这句话放在《浪潮之巅》成书的那一年2008年——2009年还成立，但是现在由于谷歌和苹果的双重夹击，微软，这个被吴军博士称之为“IT业的罗马帝国”的人，前途还真的堪忧。</p><p>此话暂且不表，今日就来说说微软帝国如何成立的。<br>1980年代的微软，在乔布斯眼里还只是个小小的软件公司。然而微软有个天才，就是比尔·盖茨。虽然比尔·盖茨在其他领域可能不如乔布斯，但是他在商业经营上的天赋要高于乔布斯，通过两手抓的方式狙击了苹果。</p><p>一方面盖茨对苹果方面要求研发软件采用拖字诀；另一方面联合当时强大的IBM，开发新的、与苹果不同的操作系统。<br>没想到盖茨还有第三部，就是微软的操作系统便宜，他采用薄利多销的态度，因而吸引了大量计算机爱好者和软件研发者，他们在上面开发了各种各样的软件，这样用户就逐渐对微软的系统产生依赖。</p><p>就这样微软依靠自己相对廉价的操作系统，以及系统良好的兼容性，加上对手苹果公司存在的战略失误，帝国就这样建立起来。</p><p>1997年微软市场首次超过IBM，然而微软还不放心，它继续进行维护自己垄断地位的战争。这次它的手段是通过模仿比竞争对手更加廉价的产品，以及依靠自己的垄断地位来打击对手的。</p><p>然而没有永远的帝国，微软帝国在取得操作系统的绝对领先后，想进一步扩大优势，于是把眼光瞄向了互联网领域，这次迎接微软挑战的是新兴的雅虎，它比微软更绝，因为雅虎的服务是免费的。经过这次战役后，加上2000年的互联网泡沫，<strong>微软错过了进军互联网的最佳时机</strong>。</p><p>2015年下半年，微软将发布windows 10,它想实现所有操作平台的一体化，不知微软能否通过这一举动，实现王者归来？</p><h2 id="互联网中的福特——雅虎"><a href="#互联网中的福特——雅虎" class="headerlink" title="互联网中的福特——雅虎"></a>互联网中的福特——雅虎</h2><p>之所以称呼雅虎为互联网中的福特，是因为吴军博士认为雅虎对互联网的影响是可以同福特对汽车工业的影响相提并论的。</p><p>在汽车工业中，尽管汽车不是福特发明的，但是福特的生产模式，重新定义了汽车行业，并让普通工薪阶层买得起汽车。而雅虎对互联网行业的影响，在这一意义上，与福特对汽车产业的影响是相似的。</p><p>早期的互联网，其信息提供是面向用户收费的。不仅用户入网要收费，而且浏览信息也要收费，如果这样下去，互联网的发展将会和有线电视一样，几乎没有可能发展成现在的样子，而正是雅虎改变了这种状况，它把互联网办成了开放的、免费的，而且更重要的是，盈利的。</p><p>雅虎面向用户提供的服务是<strong>免费</strong>的，例如雅虎邮箱业务，而雅虎转而面向企业收取广告费，这样就形成了良性循环：免费模式吸引了更多的用户，而更多的用户意味着更多的流量，流量意味着广告商的投入更高效。</p><p>1996年雅虎上市，成为当时互联网的第一品牌，而其两位创始人——杨致远和大卫·肥罗——立刻成为了亿万富翁。</p><p>然而雅虎面对<strong>资本市场的疯狂追逐</strong>，它没有进行理性衡量，反而把自己的摊子越铺越大，因为雅虎要回应资本市场对它的期望，以支撑住它的股价。2000年，互联网泡沫崩溃，雅虎的股价下跌了90%。</p><p>从这之后，雅虎的股价再也没回到高峰，而更严重的是，雅虎并没有非常雄厚的技术积累，这个曾经的互联网巨头，按照吴军博士的话来说，已经进入了“红巨星”时代——恒星的最后一个阶段。</p><h2 id="消失的贵族——摩托罗拉"><a href="#消失的贵族——摩托罗拉" class="headerlink" title="消失的贵族——摩托罗拉"></a>消失的贵族——摩托罗拉</h2><p>曾经，没落罗拉就是无线通信的代名词，同时它还是品质和技术的保证。而现在它在浪潮的冲击下，从被谷歌收购，到现在转手联想，这其中的曲折让人叹息，然而我们不能忘记摩托罗拉曾经的荣耀，它也引领过浪潮。</p><p>摩托罗拉公司创立于1928年，原名加尔文制造公司，由创始人之一的保罗·加尔文的名字命名。最早生产汽车收音机，二战时该公司的一些工程师帮助政府研究无线通信工具，并获得军方的认可，由此开始，可以表现出该公司在无线通讯上的强悍技术。</p><p>二战后，由于摩托罗拉的品牌越来越响，加尔文公司干脆就改名为摩托罗拉。</p><p>从二战结束到20世纪90年代，可谓是摩托罗拉的黄金时代，摩托罗拉在模拟无线通信方面有任何公司都无法比拟的技术优势。</p><p>摩托罗拉最大的贡献是在20世纪80年代发明了“大哥大”，而且其品质受到人们的交口称赞。正是因为摩托罗拉的品质和技术优势，它很自然地垄断了第一代移动通信市场。当时的摩托罗拉手机占据了全球市场的70%。</p><p>然而时间进入到九十年代，以GSM为标准的第二代移动通信技术普及开来，由于这一技术标准是由欧洲制定，作为欧洲公司的诺基亚具有很大的地理优势和后发优势。另一方面摩托罗拉公司错误估计了信息技术的更新换代技术，而且<strong>摩托罗拉过度注重技术，忽视了消费者的需求</strong>，导致它的产品不如诺基亚和三星等亚洲公司的产品畅销。</p><p>尽管后来摩托罗拉推出过多款经典机型，例如著名的刀锋系列，但是已经回天乏术，2014年转手一次的摩托罗拉进入了联想。</p><h2 id="没落的雷神之锤——诺基亚"><a href="#没落的雷神之锤——诺基亚" class="headerlink" title="没落的雷神之锤——诺基亚"></a>没落的雷神之锤——诺基亚</h2><p>诺基亚是《浪潮之巅》中介绍的唯一一家欧洲公司，然而现在的命运也是堪称坎坷。从2007年的市占率40%到如今的黯然退出手机市场，诺基亚的名字貌似距离现在越来越远。</p><p>曾几何时诺基亚还是芬兰的一家木工厂，曾经它的业务也如摊大饼一般，不断寻找大的发展方向，其中一个尝试很重要，就是它在20世纪60年代为军方和商业用户提供对讲机，从这些业务中诺基亚积累了一定的技术。</p><p>1982年诺基亚研制出了一种可以移动的电话，然而此时的它还不能与当时的巨头摩托罗拉相比，直到20世纪80年代末因为项目太多，出现严重的亏损。</p><p>直到1992年通信业务才成为诺基亚的核心，这一转型使得诺基亚由一个普通的电子公司成为全球移动通信的领导者，除了正确的转型方向外，还有三点对诺基亚的成功很重要：第一，抓住了移动通信技术的转型浪潮；第二，芬兰政府的大力支持；第三，科技以换壳为本。</p><p>诺基亚在2G浪潮中比摩托罗拉更注重外观、用户的便捷程度，而且一直保持产品开发的快速和灵活性，又是换一个外壳就是一部新手机，因此有人戏称诺基亚——”科技以换壳为本“。</p><p>然而诺基亚在3G浪潮中没落，最终被迫与微软走到一起，出了几款Windows Phone手机，最近的新闻是诺基亚手机部门被微软收购，而变成了Lumia品牌，诺基亚这个曾经的”雷神之锤“黯然退出手机市场。</p><h2 id="奔腾的芯–英特尔"><a href="#奔腾的芯–英特尔" class="headerlink" title="奔腾的芯–英特尔"></a>奔腾的芯–英特尔</h2><h3 id="时势造英雄"><a href="#时势造英雄" class="headerlink" title="时势造英雄"></a>时势造英雄</h3><p>英特尔公司由戈登•摩尔(Gordon E. Moore)和罗伯特.诺伊斯(Robert Noyce)于 1968 年 创立于硅谷。此前，摩尔和诺伊斯在 1956 年还和另外六个人一起创办了仙童(Fairchild)半 导体公司。 </p><p>一开始英特尔生产的是性能低的微处理器，是用来补充大计算机公 司看不上的低端市场。在很长时间里，英特尔的产品被认为 是低性能、低价格。虽然它的性价比很高，但并不是尖端产品。 </p><p>1981 年，IBM 为了短平快地搞 出 PC，也懒得自己设计处理器，拿来英特尔的 8086 就直接用上了。这一下子，英特尔一举 成名。 </p><p>为了和 IBM PC 兼容，处理器都得是英特尔公司的。 </p><p>英特尔的崛起就成为历史的必然。这正是时势造英雄。 </p><p>八十年代，英特尔果断地停掉了它的内存业务，将这个 市场完全让给了日本人，从此专心做处理器。当时日本半导体公司在全市界挣了很多钱，日 本一片欢呼，认为它们打败了美国人。其实，这不过是英特尔等美国公司弃子求势的一招棋。 </p><p>到今天， 即使是最早生产工作站的太阳公司和世界上最大的计算机公司 IBM 以及以前从不使用英特 尔处理器的苹果公司，都开始在自己的计算机中使用英特尔的或者和英特尔兼容的处理器了。 现在，英特尔已经垄断了计算机处理器市场。 </p><h3 id="英特尔与摩托罗拉之战"><a href="#英特尔与摩托罗拉之战" class="headerlink" title="英特尔与摩托罗拉之战"></a>英特尔与摩托罗拉之战</h3><p>资金密集型的日本半导体公司终究不可能是技术密集型的英特尔公司的对手。英特尔公 司迄今唯一遇到的重量级对手只有八十年代的摩托罗拉。 </p><p>正如同罗马帝国的崛起是通过在布 匿战争中打败原有的霸主迦太基而完成的，英特尔的崛起是靠击败老牌半导体公司摩托罗拉 而实现的。 </p><p>英特尔公司从外部得到了强援。由于 IBM PC 兼容机的逐步普及，技术上相对落 后的英特尔反而占了更多的市场份额。 </p><p>要分析摩托罗拉之败，我们不妨来比较一下英特尔和摩托罗拉这两个公司。首先，这是 两个不同时代的公司。总部在美国中部伊利诺斯州的摩托罗拉虽然也是一个高技术公司，也 经历了八十年代的信息革命，但是它的作态完全还是五六十年代的传统的公司。虽然摩托罗 拉对雇员在工资和福利上待遇不错，但是公司和员工，基本上还是传统的雇佣关系，公司内 部管理层次较多，大部分员工基本上没有多少股票期权。因此，公司的业绩和员工的利益关 系不大。英特尔公司则是一的典型的硅谷公司。每个员工的工作强度比摩托罗拉要大很多， 但是每个人平均的股票期权也多很多。硅谷几个比较好的学区的房子，不少被英特尔公司的 早期员工买走了，而这些房子靠工资是一辈子也买不起的。 </p><p>几年前，美国历史频道(History Channel)在节目中评论了中日甲午战争。美国的历史学家认为，这是两个不同时代军队之间 的战争，虽然双方武器相差不多，战争的结果不会有任何悬念，因为一个在专制的农业时代 后期的军队很难打赢一个兴起的工业化国家的军队。英特尔和摩托罗拉之间的竞争也是如此。 </p><p>两个公司的统帅水平相去甚远。英特尔公司八九十年代的 CEO 格罗夫虽然是学 者出身，同时也是微机时代最优秀的领导者和管理者，他几次被评为世界上最好的 CEO。摩 托罗拉公司由加尔文(Galvin)兄弟创办，公司六十年代传到了儿子手里，八九十年代传到了 孙子手里，是个典型的家族公司。俗话说富不过三代，这话果然应验在加尔文家族上，三代 人可以说是一代不如一代。 </p><p>在业务上，半导体只是摩托罗拉的一个部门，而微机处理器又只是其半导体部门的一项 业务，可是它对于英特尔来讲却是全部。 </p><h3 id="指令集之争"><a href="#指令集之争" class="headerlink" title="指令集之争"></a>指令集之争</h3><p>英特尔在微软的帮助下，在商业上打赢了对摩托罗拉一战。在接下来的十年里，它在技术上又和全世界打了一战。如果转到精简指令的道路上，英特尔的市场优势会荡然无存;如果坚持 走复杂指令的道路，它就必须逆着全世界处理器发展潮流前进。 </p><p>英特尔为了兼容性，一直坚持使用CISC，但是并没有放弃RISC。应该讲英特尔在精简指令处理器的工作没有白花，它在奔腾及以后的处理器设计上吸取 了 RISC 的长处，使得处理器内部流水线的效率提高很多。英特尔通过高强度的投入，保证 了它处理器性能提升得比精简指令还要快。而在精简指令阵营，九十年代五大工作站厂家太 阳、SGI、IBM、DEC 和 HP 各自为战，每家都生产自己的精简指令处理器，加上摩托罗拉 为苹果生产的 PowerPC，六家瓜分一个市场，最后谁也做不大、做不好。 </p><p>英特尔经过十年努力终于打赢了对精简指令集的处理器之战。需要强调的是，英特尔不 是靠技术，而是靠市场打赢的此战。英特尔的表现在很多地方很值得圈点。首先，英特尔坚持自己系列产品的兼容性，即保证以往的软件程序肯定能在新的处理器上运行。这样时间一 长，用户便积累了很多在英特尔处理器上运行的软件。每次处理器升级，用户原来的软件都 能使，非常方便。因此大家就不愿意轻易更换其它厂家的处理器，即使那些处理器更快。而 其它处理器生产厂家这点做的都没有英特尔好，它们常常每过几年就重起炉灶，害得用户以 前很多软件不能用了，必须花钱买新的。时间一长，用户就换烦了。第二，英特尔利用规模 经济的优势，大强度投入研发，让业界普遍看衰的复杂指令集处理器一代代更新。在九十年 代初，英特尔的 x86 系列和精简指令集的处理器相比在实数运算上要略逊一筹。但是，英特 尔十几年来坚持不懈地努力，后来居上，而其它厂商因为各自市场不够大，每一个单独的处 理器芯片的投入远远不如英特尔，因此反倒落在了后面。 </p><p>英特尔并没有拒绝新技术，它也曾经研制出两个不错的精简 指令的处理器，只是看到它们前途不好时，立即停掉了它们。 </p><p>英特尔运气很好，在精简指令处理器阵营中，群龙无首。 </p><h3 id="英特尔和AMD的关系"><a href="#英特尔和AMD的关系" class="headerlink" title="英特尔和AMD的关系"></a>英特尔和AMD的关系</h3><p>英特尔和 AMD 的关系基 本上是既联合又斗争。如果不是反垄 断法的约束，英特尔很可能已经把 AMD 击垮或者收购了。另外，英特尔和 AMD 的关系基 本上是既联合又斗争。 </p><p>英特尔并没有想彻底把 AMD 打死。因为留着 AMD 对它利大于弊。 首先，它避免了反垄断的很多麻烦。今天 AMD 的股值只有英特尔的 5%，后者靠手中的现 金就足以买下前者。但是，英特尔不能这么做，否则会有反垄断的大麻烦。其次，留着 AMD 这个对手对英特尔自身的技术进步有好处。 </p><p>AMD 不同于英特尔以往的对手，它从来没有另起炉灶做一种和英特尔不同的芯片，而是 不断推出和英特尔兼容的、更便宜的替代品。 </p><h3 id="填补艰难"><a href="#填补艰难" class="headerlink" title="填补艰难"></a>填补艰难</h3><p>当一个公司的市场份额超过 50% 以后，就不用再想去将市场份额翻番了。 </p><p>英特尔虽然雄霸个人电脑处理器市场，但随着个人微机市场的饱和，它远景不容乐观。 从某种程度上讲，它是反摩尔定理最大的受害者，因为处理器的价格在不断下降。同时，它 在新市场的开拓上举步艰难，很难摆脱“诺威格效应”的阴影。好在英特尔同时也是安迪-比尔 定理的直接受益者，在可以预见的将来，它的发展很大程度上必须依赖于微软等公司软件的 更新。 </p><h2 id="互联网的金门大桥（思科）"><a href="#互联网的金门大桥（思科）" class="headerlink" title="互联网的金门大桥（思科）"></a>互联网的金门大桥（思科）</h2><h3 id="好风凭借力"><a href="#好风凭借力" class="headerlink" title="好风凭借力"></a>好风凭借力</h3><p>思科公司的图标正是旧金山的金门大桥，创始人的意思是要建起连接不同网络的桥梁。 </p><p>由斯坦福大学的一对夫妇创办，这对夫妇恐怕开始也没有想到以后思科能变成世界上最大的设备制造商。 </p><p>思科早期成功的关键在于它的两个创始人在最合适的时机创办了一个世界上最需要的公司。假如 思科早创立两年，它可能在市场还没有起来时就烧完了它的投资而关门了，反过来也一样， 如果它迟了两年，就可能被别的公司占了先机。在思科还是一个小公司时，各大计算机公司 各自有自己很大的市场，它们首先想的是在网络市场上打败对手们而不是研制包容各公司网 络产品的路由器，因此，没有公司和思科争夺多协议路由器的市场。而等到互联网兴起时， 思科已经占据了路由器市场的领先地位。 </p><p>思科的幸运正好和以朗讯为代表的传统电信公司的不幸互补，互联网的兴起，使得世界上数据传输量急剧增加，而语音通话量下降。 </p><p>思科的办法很像在大航海时代西班牙和葡萄牙国王对待探险者的做法。那时，包括哥伦 布和麦哲伦在内的很多航海家都得到了王室的资助。 </p><p>思科具体的做法是，如果公司里有人愿意自己创业，公司又觉 得他们做的东西是好东西，就让他们留在公司内部创业而不要到外面去折腾，而思科会作为 投资者而不再是管理者来对待这些创业的人。一旦这些小公司成功了，思科有优先权把它们 买回来，思科的地盘就得到扩大。而这些独立的小公司的创办者和员工，又可以得到很高的 回报。这样本来想离开思科出去创业的人也就不用麻烦了，接着上自己的班，只是名以上换 了一家公司。当然，如果这些小公司没办好关门了，那么思科除了赔上一些风险投资的钱， 没有额外的负担。这种做法不仅调动了各种员工尤其是早期员工的积极性，也避免这些员工 将来成为自己的对手或者加入对手的阵营。 </p><p>思科通过这种做法，基本上垄断了互联网路由器和其它重要设备的技术。因为一旦有更 新更好的技术出现，思科总是能有钱买回来。如果说微软是赤裸裸地直接垄断市场，那么思 科则是通过技术间接垄断了互联网设备的市场。 </p><p>既然思科这种办法证明有效，为什么别的公司学不来。当然这一方面因 为并非所有公司的领袖都有思科 CEO 钱伯斯(John Chambers)的胸怀和远见卓识，更重要 的是思科的基因使然。思科自己的创建就是用到了两个创始人的职务发明。 </p><p>另外，思科员工的发明，一般很难单独成为一种产品，而必须应用到现有 网络通信系统或设备中，因此它们最好的出路就是卖给思科。所以，思科倒是不怕这些小公 司将来反了天。 </p><h3 id="竞争者"><a href="#竞争者" class="headerlink" title="竞争者"></a>竞争者</h3><p>思科真正的竞争对只有一假一真两个。让我们先来看看假的—Juniper Networks。这个公 司基本上是思科的影子公司，相当于 AMD 对英特尔的地位。Juniper 的产品定位在高端，而 不像思科从小到 IP 电话机，大到高端路由器都做。 </p><p>思科真正的对手是中国的小弟弟华为。 </p><p>中国制造”的效应。它基本的影响是，当一个原本只能在美欧生产的产品，经过一段时间则可以过渡到日本和韩国，进而落脚于中国。 美欧公司能赚钱的时间只有从美国到中国这段时间差，以前这段时间可以长达数十年，现在 只有几年。一旦一项产品可以由中国制造，那么它的利润空间就会薄到让美欧公司退出市场。 </p><h3 id="诺威格定理的宿命"><a href="#诺威格定理的宿命" class="headerlink" title="诺威格定理的宿命"></a>诺威格定理的宿命</h3><p>谷歌研究院院长彼得.诺威格博士说，当一个公司的市场占有率超过50%以后，就不要再指望在市场占有率上翻番了。 </p><h2 id="硅谷的见证人（惠普公司）"><a href="#硅谷的见证人（惠普公司）" class="headerlink" title="硅谷的见证人（惠普公司）"></a>硅谷的见证人（惠普公司）</h2><h3 id="昔日的硅谷之星"><a href="#昔日的硅谷之星" class="headerlink" title="昔日的硅谷之星"></a>昔日的硅谷之星</h3><p>由两个斯坦福的毕业生创办。</p><p>斯坦福工业园(Stanford Industrial Park)，惠普公司成为进驻工业园的第一批公司。惠普公司的从这里起步，生意得到 了长足的发展，很多公司也随着进驻斯坦福工业园。到了计算机时代，由于这些公司大多从 事和半导体有关的技术，从此这里便被称为硅谷。而斯坦福大学，不但度过了难关，而且从六十年代起，一跃成为世界顶尖名校。惠普则成为硅谷神话的典型代表。 </p><p>几十年来，惠普和斯坦福互相提携，堪称厂校合作的典范。惠普从斯坦福获得了无数优秀毕业生，同时在财政上给予斯坦福极大的支持。就是在很长时间里，惠普是斯坦福最大的 捐助者，包括帕克特捐给斯坦福电子工程系的系馆。 </p><p>如果在九十年代 初问一问硅谷最有名的公司是哪一家，十个人中有十个会回答惠普。当时，惠普是很多斯坦 福学生首选的工作公司。 </p><p>九十年代后期，惠普经历了不很成功的转型，这个曾经辉煌的硅谷巨星渐渐黯淡下来了。 </p><h3 id="有争议的生死抉择"><a href="#有争议的生死抉择" class="headerlink" title="有争议的生死抉择"></a>有争议的生死抉择</h3><p>惠普衰落的原因大致有两个，领导者的错误和“日本/中国制造”的冲击。 </p><p>一般来讲，公司会卖出利润率低的、对自己没有用的，前景不好的部门并买进对公司长 远发展有帮助的公司，比如郭士纳领导下的 IBM 就是这样。但是，惠普接下来的发展史上最 大的两次拆分和并购，却是反其道而行之，因此科技界和华尔街至今很有争议。 </p><p>应该讲，1999 年的惠普虽然大，但是并不强。这有点像中国战国时候的楚国。惠普的董 事会当然希望把惠普搞得强大。它必须决定分出去哪个部门，保留哪个部门。医疗仪器部门 虽然利润率高，但是在 GE 的打压下发展有限，经过长期酝酿，才决定将科学仪器和医疗仪器 部门都分出去，成立一个新的公司安捷伦，然后新的惠普好集中精力于计算机行业。这么大 的公司重组当然要有个有经验的人来执行，惠普公司董事会看中了菲奥莉娜拆分和并购公司 的经验，破例选择了她出任硅谷最老的惠普公司的 CEO ，来实施安捷伦上市的事宜。 </p><h3 id="亚洲制造的冲击"><a href="#亚洲制造的冲击" class="headerlink" title="亚洲制造的冲击"></a>亚洲制造的冲击</h3><p>从 2003 、2004 年起，整个硅谷开始复苏，很多公司回到并超过 2000 年的水平。但是， 惠普一点没有好转的迹象。华尔街不断看空惠普的股票，忍无可忍的股东们终于决定赶走毫 无建树的菲奥莉娜。根据美国公司的惯例，惠普提供给她一笔丰厚的退休金，然后由她自己 提出辞职，这样大家面子上都好看。菲奥莉娜临走还从惠普投资者手中拿走了上亿美元的现 金和股票。但是，股东们宁可花钱请她走。菲奥莉娜离职的当天，惠普的股票大涨了 10% 。 这是一次惨痛的教训，它说明如果一个公司不能挑选好掌舵人，以后替换掉他成本也是很高 的。 </p><p>惠普虽然是一个大公司，但是它从来没有领导过哪次技术浪潮。因此，它开创出一个新 行业的可能性不大。(它不同于苹果，后者从来就有创新的基因，因此可以完成从微机到 iPod 再到 iPhone 的过渡。前者则很难转型。)它是当年以半导体和计算机硬件为核心时代的硅谷 的代表，而今天的硅谷，半导体已经变得越来越不重要了。惠普已经不能代表今天硅谷的潮 流了，这也是我在开始时讲惠普是黯淡了的巨星的原因。 </p><h2 id="下一个帝国——谷歌公司"><a href="#下一个帝国——谷歌公司" class="headerlink" title="下一个帝国——谷歌公司"></a>下一个帝国——谷歌公司</h2><p>长期以来，硅谷的公司在对决微软时都会处于下风，不仅在市场上被挤占，而且在人才争夺战中也会被微软挤压。从苹果到网景公司，他们都被微软后来居上，然而最终有一个公司从小发展，直至虎口拔牙，终于这家公司有资本正面对决微软了，那就是谷歌公司。</p><p>谷歌公司的成立也离不开20世纪末的互联网泡沫，当时还在学校读博士的拉里·佩奇和谢尔盖·布林面对时代的浪潮，他们觉得自己应该做点什么，他们瞄准了新兴的搜索引擎业务，于是谷歌成立。</p><p>谷歌英文名Google，原意为一个非常大的数字Googol，即10的一百次方，“实际上宇宙中都没有任何事物能有这么大，甚至宇宙中全部的基本粒子数目也没有这么多，佩奇和布林用这个数字的用意为，他们的搜索引擎很大。</p><p>1997年9月，佩奇和布林注册了google.com的域名，然而此时二人只能靠刷信用卡度日，于是他们去寻找投资人，找到了同为<strong>斯坦福大学的校友</strong>、<strong>太阳公司创始人</strong>安迪·贝托谢姆。</p><p>贝托谢姆看到二人展示的搜索技术，果断决定给他们10万美元的支票。虽然这笔钱看起来不多，然而这在无形中给新兴的谷歌公司做了一次成功的<strong>广告</strong>。</p><p>同时<strong>斯坦福大学</strong>也向佩奇和布林伸出了援手，为其提供了专利，同时成为谷歌的股东。而为了更好发展，佩奇和布林休学，去进行光荣的创业之旅了。</p><p>他们在进行创业之旅的时候”顺走“了另一个技术大牛——克雷格·希尔福斯坦，”他几乎一个人写出了谷歌的第一个商业版本……而早期佩奇和布林忙于商业筹资，技术上只剩下了这个技术大牛。</p><p>随着业务发展，谷歌开始招人了，佩奇等人认为谷歌要坚持宁缺毋滥，每招一个人必须所有人同意才行，而且进去谷歌的人必须以一挡百，正是这一个个精英，谷歌才能成为今天的谷歌。谷歌前工程副总裁毫不讳言：“我们只需要天才。”</p><p>另外谷歌坚持精英战略， “杀鸡就是要用牛刀。”因此谷歌称为全世界单位办公面积博士最集中的地方。”谷歌不仅喜欢招博士，而且特别喜欢大学成绩优异的，这表明这个人自制力强，有责任心，而且一般而言学习好的学生更聪明。</p><p>另一方面谷歌在“品质”的坚持上类似于日本公司，它认为为了保持搜索品质，就一定要用更优秀的才人，因为即使一项工作本科生能完成，然而用硕士生效率和质量会更高，这样反而能节省更多的时间。</p><p>这样子的谷歌朝气蓬勃，同时也坚持自己“不作恶”的态度，赢得了其他公司的善意。</p><p>而当互联网从桌面上向移动端转移的时候，谷歌比微软响应的速度要快，它推出了安卓操作系统，同时在微软擅长的操作系统领域推出了Chrome。</p><p>谷歌正在进行新的布局，它已然成为一个帝国。</p><h1 id="推动浪潮的三大定律"><a href="#推动浪潮的三大定律" class="headerlink" title="推动浪潮的三大定律"></a>推动浪潮的三大定律</h1><p>有三大定律主宰IT行业尤其是计算机产业的发展，分别是摩尔定律（Moore’s Law），安迪-比尔定律（Andy and Bill‘s Law）以及反摩尔定律（Reverse Mooore’s Law）。</p><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p>所谓摩尔定律，就是每过18个月，IT产品的性能会翻一番，或者说相同性能的电子产品，每过18个月价格会下降一半。</p><p>这一定律是由英特尔公司创始人戈登·摩尔（Gordon Moore）于1965年提出的。而自从摩尔定律提出以来，计算机行业始终按照摩尔定律的速度向前发展。<br>然而摩尔定律为什么会实现呢？这要归功于IT行业的特殊性。</p><p>IT行业与其他行业不太一样的一点在于，它的成本大部分都是研发成本，而在硬件制造上的成本相对来说比例不是很高，它的硬件制造成本主要集中在制造设备上。</p><p>可以说摩尔定律主导计算机行业的发展：<br>首先，摩尔定律要实现，硬件制造厂商不得不加快研究速度，在上一代商品出来之后就立马着手下一代产品的研发，而这需要大量的研发资金，因而从某种意义上来说，进入计算机行业有一定的资金壁垒。<br>其次，摩尔定律促使计算机性能得以快速提升，而这为软件的升级提供了硬件上的支持，希望未来计算机行业继续发展，嘻嘻，我想体验更高的网速。</p><h2 id="安迪-比尔定律"><a href="#安迪-比尔定律" class="headerlink" title="安迪-比尔定律"></a>安迪-比尔定律</h2><p>这条定律，顾名思义，安迪——英特尔公司CEO安迪·格鲁夫（Andy Grove）；比尔——微软公司创始人比尔·盖茨，（PS，这一条定律就是赤裸裸的暗示微软-英特尔联盟啊！）<br>这一条定律的产生与摩尔定律有关，如果按照摩尔定律的说法，如果消费者暂时不想花或者不能花很多的钱，他可以等18个月之后花一半的钱去买相同的产品。<br>那这样的话厂商怎么挣钱？<br>这个时候安迪-比尔定律就出现了。<br>按照摩尔定律，过去几十年计算机的硬件性能得到了飞速提升，然而似乎以微软为代表的软件性能貌似提升并不如硬件性能那样多，然而软件占据的空间越来越大，这就逼迫消费者在使用一台计算机之后，由于软件性能的限制，不得不重新购买升级。<br>这听起来一个阴谋，本来电子产品，就像白色家电一样，是耐用消费品，而安迪-比尔定律硬生生的让计算机和手机变成了快消品。<br>然而事实并不是那么简单。<br>几十年前，软件开发人员在编写程序时非常注意程序的大小，他们要充分利用计算机的空间，而现在的软件开发人员，似乎越来越浪费了。</p><p>这似乎不能怪罪软件开发人员，因为他们也要人性化，以前的编程的客观要求软件开发人员极低，而现在由于摩尔定律生效，软件工程师可以比较自由地利用硬件资源做自己喜欢的工作。而另一方面<strong>由于人力成本的提高</strong>，<strong>为了编程人员的最大利用化和缩短编程时间，因此编程语言越来越易懂、好用，而编程语言越来越臃肿。</strong></p><h2 id="反摩尔定律"><a href="#反摩尔定律" class="headerlink" title="反摩尔定律"></a>反摩尔定律</h2><p>这一定律是由谷歌前CEO埃里克·施密特提出的，“如果你反过来看摩尔定律，一个IT公司如果今天和十八个月前卖掉同样多的、同样的产品，它的营业额就要下降一半”（吴军）。</p><p>这样子下去的话IT公司就很惨了，因为他们花了同样的劳动，却只得到十八个月之前营业额的一半。而反摩尔定律就是硬逼着硬件公司跟上摩尔定律的速度。</p><p>反摩尔定律也有积极作用，就是促进IT行业不断寻找<strong>质变</strong>，而非像传统行业更多的是量变，而且反摩尔定律对新兴的小公司也是有极大好处的，因为在<strong>新的浪潮</strong>到来之时，新兴小公司和大公司站在同一起跑线。</p><p>读后感：看过吴军博士对计算机行业三大定律的介绍，解答了以前的一个疑惑：例如为什么计算机和电脑越用越卡，是不是他们的阴谋？这个问题就是第二条定律能解答的。</p><h1 id="行业兴衰的推手——资本"><a href="#行业兴衰的推手——资本" class="headerlink" title="行业兴衰的推手——资本"></a>行业兴衰的推手——资本</h1><h2 id="幕后英雄——风险投资"><a href="#幕后英雄——风险投资" class="headerlink" title="幕后英雄——风险投资"></a>幕后英雄——风险投资</h2><p>传统上创业时的资金来源为自己财产积累或借贷。然而年轻人一般没有什么钱，此时资金的不足就成了创业的瓶颈。<br>而敢于冒险的美国人发明了一种非常规多投资方式——风险投资，这种投资不需要抵押，也不需要偿还，如果投资成功，资本家将获得几倍、乃至几十倍上百倍多利润，而不成功，就当交学费了。而这对年轻人太具有了吸引力了，他不用因为创业失败而背上债务，这样年轻人就敢于创业，因此风险资本促使美国成为创业的国度。</p><h2 id="科技公司兴衰背后的重要角色——投资银行"><a href="#科技公司兴衰背后的重要角色——投资银行" class="headerlink" title="科技公司兴衰背后的重要角色——投资银行"></a>科技公司兴衰背后的重要角色——投资银行</h2><p>2008年的那场金融危机，深刻表露出华尔街的贪婪所造成的恶果，同时他们也对科技公司施加着影响：一方面，科技公司上市时的吹捧者，是他们；另一方面，打压科技公司的也是他们。</p><p>华尔街——美国的金融中心，这里坐落着诸多金融公司，而这些公司大致分为以下几类：商业银行（类似于我国的工商银行）、投资银行（替别人买卖任何有价值的商品，是股市的主力军）、共同基金公司（掌管美国所有的退休账户和世界上的很多财富）以及对冲基金（著名的有金融大鳄索罗斯的量子基金）。</p><p>而其中对科技公司影响最大的乃是投资银行。著名的投资公司有高盛公司（投资银行的NO.1)、摩根斯坦利（美国大银行家摩根创立）等。</p><p>风投公司要收回投资，科技公司的从业人员要获得回报，只有两条路可选：第一是<strong>被收购</strong>；第二是<strong>上市</strong>。而<strong>上市就需要高盛等公司当承包商</strong>，承包商以<strong>上市价格</strong>从被承包的公司收购一定数量的股票，并且以同样的价格分配给它们的客户。而承包商从中获得两笔收入：佣金（包销股票总金额）、以后用上市价购买科技公司一定股份的权利（这笔钱只有当科技公司股票上涨时才有意义）。<br>而当投资银行认为一家科技公司有前途时，其股票会上涨，反之则会下降。股票价格下降对科技公司的影响有时是灾难性的。诚可谓“成也萧何，败也萧何。”</p><h2 id="硅谷的摇篮——斯坦福大学"><a href="#硅谷的摇篮——斯坦福大学" class="headerlink" title="硅谷的摇篮——斯坦福大学"></a>硅谷的摇篮——斯坦福大学</h2><p>硅谷的传奇与斯坦福大学多方位的支持是分不开关系的。很多当今时尚著名的科技公司都是由斯坦福大学的教授和学生创立的。它们包括惠普公司、思科公司、太阳公司、雅虎、谷歌以及英特尔。斯坦福在科技业的这种契机是任何大学都无法比拟的。</p><p>首先，按照斯坦福人自己的说法，一个斯坦福等于一个哈佛加麻省理工。这句话粗看略显自大，但实际是有道理的。斯坦福大学在专业设置上人文理工兼修，同时比东岸名校更重视实践。</p><p>斯坦福的学生，在这里能够体现更加丰富的多样性，在这里培养了他们创业时需要的沟通能力和团队协作能力。<br>其次，斯坦福大学给予新兴的科技公司以专利和土地。斯坦福大学，其面积的相当大部分都租给了企业，这些企业绝大部分都是高科技企业，同时斯坦福大学也给予自己学校的毕业生和在读生创业上的优惠。</p><p>斯坦福大学的这一举动无疑是双赢。这些斯坦福的毕业生们成功之后就会投桃报李，他们会给母校丰厚的捐赠。</p><h2 id="怎样做到基业长青——硅谷成功的商业模式-印钞机"><a href="#怎样做到基业长青——硅谷成功的商业模式-印钞机" class="headerlink" title="怎样做到基业长青——硅谷成功的商业模式 印钞机"></a>怎样做到基业长青——硅谷成功的商业模式 印钞机</h2><p>日本经营之神——松下幸之助有句名言:一个企业必须要盈利，否则就是对全人类的犯罪。因为无法盈利的企业是浪费资源，还不如把这些人力物力用在更需要的地方。因此很多大公司的兴起，不是靠技术的革新，还是靠商业模式的转变，这里吴军博士介绍了硅谷那些成功的商业模式。<br><strong>什么是好的商业模式</strong><br>通常，好的商业模式都<strong>非常简单</strong>，<strong>即使是外行人也能看得清楚</strong>。AT&amp;T从事固定电话业务时（19世纪末），就懂得只收服务费而不是高的吓人的安装费，这点中国电信到2000年都不明白，而英特尔开发出比IBM以及惠普更便宜的处理器，分别卖给这些公司，这也是双赢。</p><p>相反，如果一种商业模式好几个小时都说不清楚，在巴菲特看来要么是骗人、要不根本不存在。而最理想的商业模式就是如同印钞机一样自动挣钱的模式，这里吴军介绍了三种印钞机模式——谷歌的广告系统、eBay的电子商务系统以及戴尔的微机直销系统。</p><h3 id="Google的广告系统"><a href="#Google的广告系统" class="headerlink" title="Google的广告系统"></a>Google的广告系统</h3><p>谷歌的广告系统大大降低了全国性广告乃至全球广告的门槛，深受中小企业欢迎，另一方面谷歌的技术实力强悍，机器会自动学习，强化个性化广告推荐，这样广告效果更好，广告上自然更加喜欢。</p><h3 id="ebay和亚马逊的在线市场"><a href="#ebay和亚马逊的在线市场" class="headerlink" title="ebay和亚马逊的在线市场"></a>ebay和亚马逊的在线市场</h3><p>而eBay的模式类似于阿里巴巴，坐收卖家和卖家之间的佣金和中介费，只要网上有交易，它就永远会有收入，但有个问题没有解决:就是信用问题和付款问题。付款问题靠PalPal（国外的支付宝）解决，但是信用问题是让eBay头疼的。</p><h3 id="戴尔的虚拟工厂"><a href="#戴尔的虚拟工厂" class="headerlink" title="戴尔的虚拟工厂"></a>戴尔的虚拟工厂</h3><p>第三个是戴尔的虚拟工厂。戴尔自己没有工厂，只有一个商标，它的创始人精简了从设计到零售的环节，精简了不少费用，一度戴尔电脑的市占率为美国第一。</p><h2 id="下一个浪潮"><a href="#下一个浪潮" class="headerlink" title="下一个浪潮"></a>下一个浪潮</h2><p>没有不消亡的帝国，同样也没有永不衰退的企业，浪潮不断推动企业兴衰更替，而从投资银行到求职者，都希望找到下一个浪潮，能站在下一个浪潮之巅的必将是下一个谷歌一般的企业。</p><p>吴军博士断言：云计算很可能成为下一个科技浪潮，因为它将使用户摆脱桌面，通过浏览器，借助高速网络和云端服务器，随时随地享受上网的乐趣。（画外音：话说这不是谷歌的笔记本Chromebook吗？到底吴军博士是谷歌的人啊！）<br>”科技产业让人振奋的是，有新一代技术的革命同时拌嘴这新一代公司的诞生，这个时间可能会很长，但终究会来到。而代表新的技术公司有时是新生的，有时却是以前的公司进化而来，不论是哪一种都足以让人振奋。寻找下一个这样的机会，永远是和所有现代生活相关的人追求或谈论的主题。</p><h1 id="涨姿势"><a href="#涨姿势" class="headerlink" title="涨姿势"></a>涨姿势</h1><h2 id="有关罗斯柴尔德家族的阴谋论到底是不是真的？"><a href="#有关罗斯柴尔德家族的阴谋论到底是不是真的？" class="headerlink" title="有关罗斯柴尔德家族的阴谋论到底是不是真的？"></a>有关罗斯柴尔德家族的阴谋论到底是不是真的？</h2><p>吴军博士的回答：罗斯柴尔德家族早已是过眼云烟，在华尔街眼里，这个家族就是二三流的水平，而美国，这个家族被人认知，还是因为葡萄酒。</p><p>按照一些中国作家的观点，一两百年前这个家族的财富作为原始资本，以每年6%的速度递增，现在该家族有几万亿美元，至于为何没有人看到，是因为这个家族的财务不向外界公开。</p><p>几万亿美元，相当于整个中国的经济规模，然而金钱只有流动才有可能增值，这么一大笔钱在世界上不可能藏得住。另外这些作者的假设也是错误的。这里可以举个反例：春秋时代的陶朱公，留给后人1两银子，现在应该变成10的60次方两银子，这远比现今世界上所有财富的加总还要多。这显然不可能，既然陶朱公不可能，凭什么罗斯柴尔德家族就可能呢？</p><p>罗斯柴尔德家族衰落与几个大事件有关：第一个，错失19世纪末飞速发展的美国；第二，纳粹德国的抢掠。<br>在华尔街看来，罗斯柴尔德家族的投资公司顶多算三流的投资公司。</p><h1 id="硅谷的另一面"><a href="#硅谷的另一面" class="headerlink" title="硅谷的另一面"></a>硅谷的另一面</h1><h2 id="成王败寇"><a href="#成王败寇" class="headerlink" title="成王败寇"></a>成王败寇</h2><p>在硅谷创业成功的几率比中六合彩大奖的概率大不了多少，就如同好莱坞的明星带给了无数少男少 女的明星梦一样。这正是风险投资资本家和华尔街所希望的。只有越来越多的人加入这种创 业的游戏，投资者才能有好的项目投资。 </p><p>毕竟，硅谷的 竞争太残酷了，成功的机会太低了。我有时会开玩笑地说“如果你不相信这辈子会被汽车撞死， 为什么相信能中硅谷大奖?后者的可能性更小。”他们会开玩笑地说:“也许是利令智昏吧。” </p><p>小公司想要成功，有很多因素必须同时具备。</p><ol><li>创始人很重要，所有的成功者都是实干家。成功的创业者必须有一个小而精的好团队，里面每个 人都得不计较个人得失，同甘共苦，否则成则争功，败则互相推诿。在技术上，他们必须有 自己的金刚钻，他们的技术必须是不容易被别人学会和模仿的。</li><li>但是光有好的团体和技术又远远不够，他们有商业头脑而且必须找到一个能盈利的商业 模型(Business Model)。</li><li>再接下来是判断力和执行力。</li><li>外部环境。</li><li>运气。</li></ol><p>硅谷汇集了美国三、四成的风险投资，每天硅谷都有成百上千的公司成立，但同时又有 成百上千的公司关门。对于那些失败的公司，大家并不关心，甚至无人知道它们的存在。即 使很多曾经辉煌过的公司，像网景公司、SGI 公司，人们很快也就忘却了它们。在这些成千 上万家硅谷的公司中，最终创造出了一些像思科、谷歌那样的传奇故事。仿佛间在硅谷办一 个公司就能成一个。岂不知，一将功成万骨枯，无数失败的公司在为少数几个成功者做分母。 </p><h2 id="嗜血的地方"><a href="#嗜血的地方" class="headerlink" title="嗜血的地方"></a>嗜血的地方</h2><p>在硅谷，加班很正常，与国内有过之而无不及。但是薪水却不是线性的增长，所以单位时间的薪水反而少了。</p><p>硅谷就是这样一个“嗜血”的地方。坦率地讲，硅谷的生活质量达不到美国的平均水平。 </p><h2 id="机会均等"><a href="#机会均等" class="headerlink" title="机会均等"></a>机会均等</h2><p>硅谷能成为科技之都，而且长盛不衰，必有它高明之处。其中最关键的一条是保证机会 均等。任何人、任何国家和制度都无法保证我们的社会绝对公平，(事实上也没有必要追求绝 对公平。)但是，一个好的制度要保证每个人有均等的机会。 </p><p>硅谷是一个到处可见权威却从不相信权威的地方。 </p><p>任何人要想在这里获得成功，都得真刀真枪地拿出真本事 干出个样子。在美国很多地方，尤其是传统产业中，普遍看中甚至过于看重个人的经历 (Resume)而不是做事情的本领。 </p><p>在硅谷谋职，简历固然重要， 但是个人的本事(包括和人打交道的软本领)才是各个公司真正看中的。由于每个公司产品 的压力很大，同行业公司之间的淘汰率很高，硅谷的公司需要的不是指手画脚的权威而是实 实在在干事情的人。 </p><p>对创业者来讲，资历固然有用，但就重要性而言远排不进前几位。名气大、职位高的创 业者经验丰富、交际广，容易找到钱和市场，但是闯劲远不如初出茅庐的牛犊那么足。在风 险投资家看来，一个人的能力，包括处理人际关系的“软”能力(Soft Skills)是决定创业成败 的关键。一个人的职位只代表过去，而财富和地位有时反而成为创业的负担。这也是为什么 硅谷很多著名的公司如思科、苹果、Yahoo 和谷歌，包括中国人创办的 Netscreen 和 Webex 都 是原来默默无名的年轻人办成的，但是却很少听说那个成功公司是一位原某公司老总办的 。</p><p>自古英雄出少年，这是风险投资家们普遍承认的事实。红杉风投的投资家们和我谈过他 们选择投资对象的原则，其中一条就是创业者一定要有饥渴感(Hungry)。很难想象一个腰缠 万贯的富翁能比一个急于脱离贫困现状的缀学生更有把公司办好的可能。因为前者办公司不 过是为了锦上添花而后者则是要置于死地而后生。这就是乔布斯勉励年轻人要保持饥渴感 (Keep Hungry)的原因。关于风险投资家如何选择投资对象我以后还会详述。因此资深创业 者和毫无经验的年轻人各有优势，但是机会均等。硅谷各个层次的成功者几乎无一例外是靠 自己的双手从零干起，获得成功的。 </p><p>由于有一些淘到金子的“冒险家”—科技新贵，就产生了替他们打理财务的需求，今天旧金 山和硅谷就成为投资银行最集中的地区之一。 </p><p>硅谷相对于美国其它地方是机会最多也是最均等的。因此虽然这里工作压力大，竞争激 烈，还是不断有人愿意来。全世界很多国家想学习硅谷建立自己的科技园，但是至今没有一 个能像硅谷这么成功的。我想这些科技园的管理者们，也许首先应该问问自己是否为创业者 提供了同等的机会，还是将人按照财富、经历、名气预先分为了三六九等。(我对一些科技园 按照学历、职称引进人才和投资额招商很不以为然。) 自古英雄不问出处，今天落魄的学子可能就是明天业界的领袖。 </p><h2 id="硅含量不断降低"><a href="#硅含量不断降低" class="headerlink" title="硅含量不断降低"></a>硅含量不断降低</h2><p>今天知道仙童公司的人已经不多了，但它在半导体历史上占据着独一无二的地位。 </p><p>硅谷没有了硅，那么留下了什么呢?</p><h2 id="亘古而常青"><a href="#亘古而常青" class="headerlink" title="亘古而常青"></a>亘古而常青</h2><p>半导体并不是硅谷真正的本质。硅谷的灵魂是创新。硅没有了，创新的灵魂留下了，它保证了硅谷的繁荣和发展。 </p><p>在硅谷的人，不论是投资者还是创业者，已经习惯了这种快速的产业变迁，人们不断在 寻找着下一个思科、下一个 Google 。其实，硅谷的创新并不局限于 IT 领域。生物科技无疑 是硅谷另一个亮点。今天的硅谷，也是世界上新兴生物公司最集中的地方。 </p><p>创新必须依靠技术实力。和 Google 一样，基因科技也是世界上单位办公面积博士密度最 高的公司。就连它的七名董事中都有五名博士，九名执行官中也有六名博士。基因科技里的 科学家在同行中是佼佼者，在公司内部地位也很高。 </p><p>美国的专利保护机制，一个药物只有一段时间的专利保护期，这一段时间用于回收成本，过了一段时间就不保护。对于药厂来说，必须不断的推出新药，而不能躺在功劳簿上吃一辈子。</p><h1 id="与机会失之交臂的公司"><a href="#与机会失之交臂的公司" class="headerlink" title="与机会失之交臂的公司"></a>与机会失之交臂的公司</h1><h2 id="太阳公司"><a href="#太阳公司" class="headerlink" title="太阳公司"></a>太阳公司</h2><p>太阳公司不乏能人，它不仅为 Google 培养了 CEO 埃里克.施密特和首任工程部副总裁韦恩.罗森(Wayne Rosen)，并且在一定程度上奠定了今天 Google 工程部门的基础。 </p><p>太阳公司从 1982 年成立到 2000 年达到顶峰用了近二十年时间，而走下坡路只用了一年，足以令经营者为戒。 </p><p>太阳公司名称的由来很多人不知道，它其实是斯坦福大学校园网(Stanford University Network)的首字母缩写。 </p><p>太阳公司，它的操作系统 Solaris 在技术上比 Windows NT 有明显的优势。 包括 Solaris 在内的 各种 Unix 操作系统比 Windows NT 能更好地利用计算机资源，尤其是当计算机系统庞大、 用户数量巨大增加时。对太阳来讲，取胜的关键在于是否能将它在 Unix 上的技术优势转换为市场优势。 </p><p>马可尼里等人的“思维”锁定在卖硬件上了。虽然太阳公司的工作站当年每台要上万美元、服务器要十万美元，但是比 DEC 的小型机和 IBM 的大型机便宜多了。在九十年代末由于互联网的兴起，太阳公司的服务器和工作站销路太好了、太挣钱了。虽然太阳公司的中小企业市场份额不断 被微软/英特尔联盟侵蚀，但是它也在不断占领原来 DEC 和 HP 小型机的市场并有足够的处女地可以开发。这很像十六世纪的西班牙王国，虽然它 的无敌舰队已经被英国人打败了，并失去了海上霸主的地位，但是由于世界上可殖民的处女地仍然很多，支撑着这个海上老二繁荣了两个世纪，直到十九世纪全世界再无殖民地可开拓 时，西班牙早期埋下的危机才表现出来。当然，衰落要比繁荣来得快。</p><h2 id="Novell公司"><a href="#Novell公司" class="headerlink" title="Novell公司"></a>Novell公司</h2><p>虽然 Novell 采用的是 DRDOS， 但是用户使用起来和微软的 MSDOS 一模一样，对程序开发者来讲也是一样。Novell 无疑是 在帮助微软和 UNIX 争夺企业级的市场。当时，微软在网络操作系统上毫无可圈点之处，它 甚至临时性地选择了 IBM 的 OS/2 LAN Server 来抵消 Novell 在网络上的优势，但是 OS/2 LAN Server 从来就没有成为过一种主流的网络操作系统。 </p><p>从 1995 年起，微软和 Novell 之争起了质的变化。微软一年前推出的 Windows NT 对 Novell 的影响开始显现出来了。用户已经从 DOS 转向了 Windows，Novell 的操作系统对微 软的 Windows NT 几乎没有优势可言。很难想象一个局域网在其网络服务器上安装 Novell 的操作系统，同时在联网的微机上使用 Windows 。显然从服务器到微机一律采用微软的 Windows 是更好的办法，这时胜利的天平开始向微软倾斜，并成为不可逆转的趋势。 </p><h2 id="网景公司"><a href="#网景公司" class="headerlink" title="网景公司"></a>网景公司</h2><p>其网络浏览器被微软公司通过捆绑ie浏览器给打败了。</p><h2 id="real-networks"><a href="#real-networks" class="headerlink" title="real networks"></a>real networks</h2><p>播放器同理。</p><h1 id="成功的转基因"><a href="#成功的转基因" class="headerlink" title="成功的转基因"></a>成功的转基因</h1><h2 id="道琼斯的常青树（3M）"><a href="#道琼斯的常青树（3M）" class="headerlink" title="道琼斯的常青树（3M）"></a>道琼斯的常青树（3M）</h2><p>3M 公司至今发明了六万种大大小小的产品，全世界有一半的人每天直接或者间接地接触 3M 的产品。该公司营业额中有三分之一来自于近五年的发明，其中相当大的一部分是员工利 于工作时间从事非工作的研究搞出来的。3M 允许员工用 15% 的时间干任何自己喜欢做的 事，后来这个做法被 Google 学去了，变成了 Google 的“百分之二十项目”。在最具有创新力 的公司里，3M 的排名更在 Google 和苹果这些以创新而闻名的公司前面。 </p><h2 id="世界最大的联合体（GE）"><a href="#世界最大的联合体（GE）" class="headerlink" title="世界最大的联合体（GE）"></a>世界最大的联合体（GE）</h2><p>今 天的 GE 是全球最大的联合体，到 2007 年底，它包括六大部门，每个部门如果独立，在各自的领域都是佼佼者。 </p><h1 id="信息产业的规律性"><a href="#信息产业的规律性" class="headerlink" title="信息产业的规律性"></a>信息产业的规律性</h1><h2 id="70-20-10律"><a href="#70-20-10律" class="headerlink" title="70 20 10律"></a>70 20 10律</h2><p>一般在全球容不下三个以上的主要竞争者。这个行业一定有一 个老大，斯库利把它比喻成一个猴王，它是这个行业的主导者。毫无疑问，它虽然想顺顺当 当地统领好整个行业，就像猴王想让猴子们永远臣服一样，但是，它一定会遇到一两个主要 的挑战者，也就是老二(也许还有一个老三)。剩下来的是一大群小商家，就像一大群猴子。 老大是这个领域的主导者，不仅占据着超过一半，通常是百分之六七十的市场，并且制定了 这个领域的游戏规则。老二有自己稳定的百分之二三十的市场份额，有时也会挑战老大并给 老大一些颜色看看，但是总的来讲是受老大欺负的时间多。剩下的一群小猴子数量虽然多， 但是却只能占到百分之十甚至更少的市场，它们基本上唯老大马首是瞻。老大总是密切注视 着老二，并时不时地打压它，防止它做大。老大和老二通常都不会太在意剩下的小企业，这 样就让这一群小的企业能有挣一些小钱的地方。这里面的百分比数字 70、20 和 10 是我加 的，因为信息产业大公司之间的市场份额大抵如此。 </p><h2 id="诺维格定理"><a href="#诺维格定理" class="headerlink" title="诺维格定理"></a>诺维格定理</h2><p>当一个公司的市场占有率超过 50% 后，就无法再使市场占有率翻番了。 </p><h2 id="基因决定定理"><a href="#基因决定定理" class="headerlink" title="基因决定定理"></a>基因决定定理</h2><p>一个公司可以不相信基因的决定性，但是最终无法摆脱它的影响。 </p><h1 id="估值与创始人"><a href="#估值与创始人" class="headerlink" title="估值与创始人"></a>估值与创始人</h1><p>公司上市估值过高与过低都不好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转载加修改，自用。&quot;&gt;&lt;a href=&quot;#转载加修改，自用。&quot; class=&quot;headerlink&quot; title=&quot;转载加修改，自用。&quot;&gt;&lt;/a&gt;转载加修改，自用。&lt;/h1&gt;&lt;h1 id=&quot;对书名《浪潮之巅》中“浪潮”的理解&quot;&gt;&lt;a href=&quot;#对书名《浪潮之巅
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="商业" scheme="https://github.com/zdkswd/tags/%E5%95%86%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>petri网理论及其应用 0 形式化表示</title>
    <link href="https://github.com/zdkswd/2018/09/13/petri%E7%BD%91%E7%90%86%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%200%20%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%A1%A8%E7%A4%BA/"/>
    <id>https://github.com/zdkswd/2018/09/13/petri网理论及其应用 0 形式化表示/</id>
    <published>2018-09-13T11:09:56.000Z</published>
    <updated>2018-09-13T11:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="petri网理论及其应用-0-形式化表示"><a href="#petri网理论及其应用-0-形式化表示" class="headerlink" title="petri网理论及其应用 0 形式化表示"></a>petri网理论及其应用 0 形式化表示</h1><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>热点必须要了解，结合趋势。</p><h2 id="为什么要形式化方法"><a href="#为什么要形式化方法" class="headerlink" title="为什么要形式化方法"></a>为什么要形式化方法</h2><p>形式化方法的研究高潮始于 20世纪60年代后期，针对当时所谓“软件危机”,人们提出种种解决方法,归纳起来有两类：一是采用工程方法来组织、管理软件的开发过程；二是深入探讨程 序和程序开发过程的规律，建立严密的理论，以其用来指导软件开发实践。前者导致“软件工程”的出现和发展，后者则推动了形式化方法的深入研究。</p><p>形式化方法的基本含义是借助数学的方法来研究CS中的有关问题。目的是为开发过程提供一些技术和工具，用于发现并指出软件实现中潜在的缺陷问题。数学是完美的，无二义性的，可以用在航空航天工程中，当然工业界也在慢慢的从软件测试逐步变为形式化方法。</p><h2 id="什么是形式化方法"><a href="#什么是形式化方法" class="headerlink" title="什么是形式化方法"></a>什么是形式化方法</h2><p>根据表达能力，形式化方法可以分为五类：</p><ol><li>基于模型的方法：通过明确定义状态和操作来建立一个系统模型（使系统从一个状态转换到另一个状态）。用这种方法虽可以表示非功能性需求（诸如时间需求），但不能很好地表示并发性。如：Z语言，VDM，B方法等。</li><li>基于逻辑的方法：用逻辑描述系统预期的性能，包括底层规约、时序和可能性行为。采用与所选逻辑相关的公理系统证明系统具有预期的性能。用具体的编程构 造扩充逻辑从而得到一种广谱形式化方法，通过保持正确性的细化步骤集来开发系统。如：ITL（区间时序逻辑），区段演算（DC），hoare 逻辑，WP演算，模态逻辑，时序逻辑，TAM（时序代理模型），RTTL（实时时序逻辑）等。</li><li>代数方法：通过将未定义状态下不同的操作行为相联系，给出操作的显式定义。与基于模型的方法相同的是，没有给出并发的显式表示。如：OBJ， Larch族代数规约语言等；</li><li>进程代数方法：通过限制所有容许的可观察的过程间通信来表示系统行为。此类方法允许并发过程的显式表示。如：通信顺序过程（CSP），通信系统演算 （CCS），通信过程代数（ACP），时序排序规约语言（LOTOS），计时CSP(TCSP），通信系统计时可能性演算（TPCCS）等。</li><li>基于网络的方法：由于图形化表示法易于理解，而且非专业人员能够使用，因此是一种通用的系统确定表示法。该方法采用具有形式语义的图形语言，为系统开发和再工程带来特殊的好处。如 <strong>Petri图</strong>，计时Petri图，状态图等。</li></ol><h3 id="形式化语言与自动机"><a href="#形式化语言与自动机" class="headerlink" title="形式化语言与自动机"></a>形式化语言与自动机</h3><p>以四类形式语言（短语结构语言、上下文有关语言、上下文无关语言、正则语言）</p><p>四种自动机（有穷自动机、下推自动机、图灵机、线性有界自动机）</p><h3 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h3><p>自动机是有限状态机(FSM)的数学模型。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15368328512934/15368361353633.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在编译当中有所应用。自动机描述的是顺序的，线性的。</p><p>有限自动机是指有限个状态，在语法，词法分析中有用到。编译解决的主要是上下文无关文法，日常生活中所用的语言是上下文有关的文法。科大讯飞在解决日常语言识别时使用到了大数据。</p><h3 id="λ-演算与图灵机"><a href="#λ-演算与图灵机" class="headerlink" title="λ-演算与图灵机"></a>λ-演算与图灵机</h3><p>这两者是等价的，都是回答了计算机可计算的边界这一问题。</p><p>不同的是，λ-演算使用的是数学的演算，而图灵机则是具有了一个物理的模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;petri网理论及其应用-0-形式化表示&quot;&gt;&lt;a href=&quot;#petri网理论及其应用-0-形式化表示&quot; class=&quot;headerlink&quot; title=&quot;petri网理论及其应用 0 形式化表示&quot;&gt;&lt;/a&gt;petri网理论及其应用 0 形式化表示&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="课堂笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="petri网" scheme="https://github.com/zdkswd/tags/petri%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>人工智能第一课</title>
    <link href="https://github.com/zdkswd/2018/09/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
    <id>https://github.com/zdkswd/2018/09/13/人工智能第一课/</id>
    <published>2018-09-13T08:49:32.000Z</published>
    <updated>2018-09-13T08:54:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="考核方式"><a href="#考核方式" class="headerlink" title="考核方式"></a>考核方式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/4.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="学术组织，会议"><a href="#学术组织，会议" class="headerlink" title="学术组织，会议"></a>学术组织，会议</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="刊物"><a href="#刊物" class="headerlink" title="刊物"></a>刊物</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;考核方式&quot;&gt;&lt;a href=&quot;#考核方式&quot; class=&quot;headerlink&quot; title=&quot;考核方式&quot;&gt;&lt;/a&gt;考核方式&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="课堂笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人工智能" scheme="https://github.com/zdkswd/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 IO编程 进程和线程 正则表达式</title>
    <link href="https://github.com/zdkswd/2018/09/13/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20IO%E7%BC%96%E7%A8%8B%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/09/13/Python廖雪峰 IO编程 进程和线程 正则表达式/</id>
    <published>2018-09-13T08:46:56.000Z</published>
    <updated>2018-09-13T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p><p>比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p><p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p><p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p><p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p><p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p><p>注意，本章的IO编程都是同步模式，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。</p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p><p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;/Users/michael/test.txt&apos;, &apos;r&apos;)</span><br></pre></td></tr></table></figure><p>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p><p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在。</p><p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示。</p><p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure><p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p><p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p><p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便。</p><h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p><p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节</span><br></pre></td></tr></table></figure><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">'测试'</span><br></pre></td></tr></table></figure></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p><p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure></p><p>要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</p><p>以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入’a’以追加（append）模式写入。</p><h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p><p>StringIO顾名思义就是在内存中读写str。</p><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></p><p>getvalue()方法用于获得写入后的str。</p><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!\nHi!\nGoodbye!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>    s = f.readline()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure><p>StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。</p><h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</p><p>打开Python交互式命令行，我们来看看如何使用os模块的基本功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.name <span class="comment"># 操作系统类型</span></span><br><span class="line"><span class="string">'posix'</span></span><br></pre></td></tr></table></figure><p>要获取详细的系统信息，可以调用uname()函数。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看。</p><p>要获取某个环境变量的值，可以调用os.environ.get(‘key’)。</p><h3 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)</span><br></pre></td></tr></table></figure></p><p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。</p><p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。</p><p>os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便。</p><p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p><p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br></pre></td></tr></table></figure><p>但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，读写文件就可以完成文件复制。</p><p>shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p><p>我们要列出当前目录下的所有目录，只需要一行代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; [x for x in os.listdir(<span class="string">'.'</span>) if os.path.isdir(x)]</span><br><span class="line">[<span class="string">'.lein'</span>, <span class="string">'.local'</span>, <span class="string">'.m2'</span>, <span class="string">'.npm'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'.vim'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, ...]</span><br></pre></td></tr></table></figure></p><p>要列出所有的.py文件，也只需一行代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; [x for x in os.listdir(<span class="string">'.'</span>) if os.path.isfile(x) and os.path.splitext(x)[<span class="number">1</span>]==<span class="string">'.py'</span>]</span><br><span class="line">[<span class="string">'apis.py'</span>, <span class="string">'config.py'</span>, <span class="string">'models.py'</span>, <span class="string">'pymonitor.py'</span>, <span class="string">'test_db.py'</span>, <span class="string">'urls.py'</span>, <span class="string">'wsgiapp.py'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p><p>Python提供了pickle模块来实现序列化。</p><p>把一个对象序列化并写入文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b'\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'</span><br></pre></td></tr></table></figure></p><p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p><p>看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure><p>当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p><p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。</p><h3 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h3><p>Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化，但是Student对象不是一个可序列化为JSON的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2dict</span><span class="params">(std)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'name'</span>: std.name,</span><br><span class="line">        <span class="string">'age'</span>: std.age,</span><br><span class="line">        <span class="string">'score'</span>: std.score</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;<span class="string">"age"</span>: <span class="number">20</span>, <span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"score"</span>: <span class="number">88</span>&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以偷个懒，把任意class的实例变为dict：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</span><br></pre></td></tr></table></figure></p><p>因为通常class的实例都有一个<strong>dict</strong>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<strong>slots</strong>的class。</p><p>同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict2student</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Student(d[<span class="string">'name'</span>], d[<span class="string">'age'</span>], d[<span class="string">'score'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x10cd3c190</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p><p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p><p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于Windows没有fork调用，上面的代码在Windows上无法运行。由于Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的，推荐大家用Mac学Python！</p><p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p><h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>针对Windows没有fork，由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。</p><p>multiprocessing模块提供了一个Process类来代表一个进程对象。</p><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。</p><p>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。</p><p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。</p><p>Pool的默认大小是CPU的核数。</p><h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</p><p>在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p><p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p><p>Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2……</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>创建一个锁就是通过threading.Lock()来实现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h3 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h3><p>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p><p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p><p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p><p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦。</p><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p><h2 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h2><p>要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p><p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p><p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p><p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p><p>多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p><p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的<strong>缺点</strong>就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p><p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去。</p><p>切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p><h3 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h3><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p><p>对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</p><h2 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h2><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p><p>Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p><p>举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p><p>原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。</p><p>服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务。</p><p>请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。</p><p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。</p><p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p><p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>规则和javascript一样，实现形式通过re模块来实现。</p><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>由于Python的字符串本身也用\转义，所以要特别注意。</p><p>因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了。</p><p>match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p>用正则表达式切分字符串比用固定的字符更灵活。<br>在split（）函数中可以使用正则表达式。</p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。</p><p>如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。</p><p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。</p><p>和javascript一样，加个?就可以让\d+采用非贪婪匹配。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p><ol><li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li><li>用编译后的正则表达式去匹配字符串。</li></ol><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO编程&quot;&gt;&lt;a href=&quot;#IO编程&quot; class=&quot;headerlink&quot; title=&quot;IO编程&quot;&gt;&lt;/a&gt;IO编程&lt;/h1&gt;&lt;p&gt;IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 面向对象 异常处理</title>
    <link href="https://github.com/zdkswd/2018/09/02/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/09/02/Python廖雪峰 面向对象 异常处理/</id>
    <published>2018-09-02T07:00:56.000Z</published>
    <updated>2018-09-24T06:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>在Python中，定义类是通过class关键字。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.05.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p><p>创建实例是通过类名+()实现的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.05.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.06.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<strong>init</strong>方法，在创建实例的时候，就把name，score等属性绑上去。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.31.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身。</p><p>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</p><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.49.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入。</p><p>封装的另一个好处是可以给Student类增加新的方法。</p><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p><p>从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性。</p><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p><p>已经无法从外部访问实例变量.__name和实例变量.__score了</p><p>需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。</p><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.55.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>对私有数据操作用getter以及setter啦。</p><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。</p><p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：<strong>多态</strong>。</p><p>多态真正的威力：调用方只管调用，不管细节。</p><p>当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则。对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p><h3 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h3><p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">维基百科</span><br><span class="line">在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。</span><br></pre></td></tr></table></figure><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><p>判断对象类型，使用type()函数。<br>基本类型都可以用type()判断，如果一个变量指向函数或者类，也可以用type()判断。返回对应的Class类型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.18.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>判断一个对象是否是函数怎么办？可以使用types模块中定义的常量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.18.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p><p>isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p><p>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</p><h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.28.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>类似<strong>xxx</strong>的属性和方法在Python中都是有特殊用途的，比如<strong>len</strong>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.27.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.28.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.30.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.30.39.png" alt="屏幕快照 2018-08-31 下午4.30.39" title="">                </div>                <div class="image-caption">屏幕快照 2018-08-31 下午4.30.39</div>            </figure></p><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p><p>给实例绑定属性的方法是通过实例变量，或者通过self变量。</p><p>可以直接在class中定义属性，这种属性是类属性，归Student类所有。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.32.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。</p><h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><h2 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h2><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p><p>为了给所有实例都绑定方法，可以给class绑定方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.01.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p><p>Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.02.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.03.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p><h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改。</p><p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数。</p><p>调用方法又略显复杂，没有直接用属性这么直接简单。</p><p>对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法（图中为getter方法）变成属性调用的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.13.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.13.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.23.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h3><p><img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.30.44.png" alt=""></p><p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p><p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.27.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这样一来，<strong>我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</strong></p><p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p><p>只允许单一继承的语言（如Java）不能使用MixIn的设计。</p><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><p>定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.34.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这是因为直接显示变量调用的不是<strong>str__()，而是</strong>repr__()，两者的区别是<strong>str__()返回用户看到的字符串，而</strong>repr__()返回程序开发者看到的字符串，也就是说，<strong>repr</strong>()是为调试服务的。</p><p>解决办法是再定义一个<strong>repr__()。但是通常</strong>str__()和<strong>repr</strong>()代码都是一样的，所以，有个偷懒的写法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.39.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h3><p> 如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的</strong>next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.45.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a>__getitem__</h3><p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.48.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>但是如果想要正确实现一个<strong>getitem</strong>()还是要有很多工作要做的。</p><p>此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。</p><p>与之对应的是<strong>setitem、__()方法，把对象视作list或dict来对集合赋值。最后，还有一个</strong>delitem__()方法，用于删除某个元素。</p><p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p><h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。</p><p>要避免这个错误，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.55.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当调用不存在的属性时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值。</p><p>返回函数也是完全可以的。</p><p>注意，只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性，比如name，不会在<strong>getattr</strong>中查找。</p><p>此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的<strong>getattr</strong>默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误。          </p><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。</p><p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%8810.26.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%8810.27.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p><p>更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%8810.35.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</p><h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><p>Python提供了Enum类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.31.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.33.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h2><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。</p><p>type()函数既可以返回一个对象的类型，又可以创建出新的类型。</p><p>要创建一个class对象，type()函数依次传入3个参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.37.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p><p>正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p><h3 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h3><p>除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p><p>metaclass，直译为元类，简单的解释就是，当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p><p>先定义metaclass，就可以创建类，最后创建实例。metaclass允许你创建类或者修改类，可以把类看成是metaclass创建出来的“实例”。</p><p>按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.43.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。</p><p>编写ORM会用到。</p><h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%881.40.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</p><p>可以有多个except来捕获不同类型的错误。</p><p>可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%881.41.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</p><p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p><h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>Python内置的logging模块可以非常容易地记录错误信息。</p><p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出。</p><p>通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p><p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.47.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</p><p>raise语句如果不带参数，就会把当前错误原样抛出。</p><p>捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看</p><p>用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>凡是用print()来辅助查看的地方，都可以用断言（assert）来替代。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.53.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p><p>如果断言失败，assert语句本身就会抛出AssertionError。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.55.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.55.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>关闭后，你可以把所有的assert语句当成pass来看。</p><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件。</p><p>这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p>logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p><h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。</p><p>以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt; s = ‘0’。输入命令l来查看代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.57.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>输入命令n可以单步执行代码。</p><p>任何时候都可以输入命令p 变量名来查看变量。</p><p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</p><h3 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h3><p>这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.58.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.59.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有，Visual Studio Code，需要安装Python插件。PyCharm。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p><p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的</p><p>为了编写单元测试，我们需要引入Python自带的unittest模块。</p><p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.54.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</p><p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.50.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.53.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.56.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。</p><p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程&quot;&gt;&lt;/a&gt;面向对象编程&lt;/h1&gt;&lt;h2 id=&quot;类和实例&quot;&gt;&lt;a href=&quot;#类和实例&quot; class=&quot;headerlink&quot; title=&quot;类
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 高级特性 函数式编程 模块</title>
    <link href="https://github.com/zdkswd/2018/08/31/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%20%E6%A8%A1%E5%9D%97/"/>
    <id>https://github.com/zdkswd/2018/08/31/Python廖雪峰 高级特性 函数式编程 模块/</id>
    <published>2018-08-31T07:00:56.000Z</published>
    <updated>2018-09-24T08:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取数组前3个元素，用一行代码就可以完成切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.21.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从索引0开始取，直到索引3为止，但不包括索引3。</p><p>如果第一个索引是0，还可以省略。</p><p>Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片。</p><p>后10个数，L[-10:]。前10个数，每两个取一个，L[:10:2]。甚至什么都不写，只写[:]就可以原样复制一个list。</p><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。</p><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串。</p><p>Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</p><p>通过collections模块的Iterable类型判断一个对象是可迭代对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.34.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.35.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环里，同时引用了两个变量，在Python里是很常见的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.36.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))。</p><p>列表生成式则可以用一行语句代替循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.38.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环后面还可以加上if判断。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以使用两层循环，还可以使用两层循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.45.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.46.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>如果列表元素可以按照某种算法推算出来，可以在循环的过程中不断推算出后续的元素，就不必创建完整的list。Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>把一个列表生成式的[]改成()，就创建了一个generator。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.50.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>通过next()函数获得generator的下一个返回值。</p><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%889.57.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果一个函数定义中包含<strong>yield</strong>关键字，那么这个函数就不再是一个普通函数，而是一个<strong>generator</strong>。</p><p>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.20.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.22.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.32.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以直接作用于for循环的对象统称为可迭代对象：<strong>Iterable</strong>。如集合数据类型，如list、tuple、dict、set、str等，generator，包括生成器和带yield的generator function。</p><p>可以使用isinstance()判断一个对象是否是Iterable对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.35.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：<strong>Iterator</strong>。</p><p>可以使用isinstance()判断一个对象是否是Iterator对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.36.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</strong></p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.37.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。所以list、dict、str等数据类型不是Iterator。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>Python内建了map()和reduce()函数。</p><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.41.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p><p>所以，map()作为高阶函数，事实上它把运算规则抽象了，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list。</p><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.45.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.47.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的filter()函数用于过滤序列。</p><p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.48.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>Python内置的sorted()函数就可以对list进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.50.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.51.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.18.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>返回的函数并没有立刻执行，而是直到调用了f()才执行。</p><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数lambda x: x * x实际上就是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.35.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.37.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>同样，也可以把匿名函数作为返回值返回，比如。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.38.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><p>函数对象有一个<strong>name</strong>属性，可以拿到函数的名字。</p><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。</p><p>我们要定义一个能打印日志的decorator，可以定义如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.42.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们要借助Python的@语法，把decorator置于函数的定义处。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.42.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>把@log放到now()函数的定义处，相当于执行了语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.43.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>将原函数now传入log函数之中，返回wrapper函数，包含了原本的now功能以及加上了新的功能。将值赋予now。这样就完成了装饰。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.45.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p><p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.51.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。</p><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p><p>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<strong>author</strong>，<strong>name</strong>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<strong>doc</strong>访问，我们自己的变量一般不要用这种变量名；</p><p>类似_xxx和<strong>xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，</strong>abc等；</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public，这也是一种非常有用的代码封装和抽象的方法。</p><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。</p><p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.57.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="安装常用模块"><a href="#安装常用模块" class="headerlink" title="安装常用模块"></a>安装常用模块</h3><p>我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。</p><p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</p><p>如果我们要添加自己的搜索目录，有两种方法<br>一是直接修改sys.path，添加要搜索的目录。<br>第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高级特性&quot;&gt;&lt;a href=&quot;#高级特性&quot; class=&quot;headerlink&quot; title=&quot;高级特性&quot;&gt;&lt;/a&gt;高级特性&lt;/h1&gt;&lt;h2 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
</feed>
