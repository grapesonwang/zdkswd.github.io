<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-11-08T07:57:45.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>scikit-learn介绍</title>
    <link href="https://github.com/zdkswd/2018/11/08/scikit-learn%E4%BB%8B%E7%BB%8D/"/>
    <id>https://github.com/zdkswd/2018/11/08/scikit-learn介绍/</id>
    <published>2018-11-08T07:56:56.000Z</published>
    <updated>2018-11-08T07:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习：问题背景"><a href="#机器学习：问题背景" class="headerlink" title="机器学习：问题背景"></a>机器学习：问题背景</h1><p>学习问题分以下几类：</p><h2 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>聚类，密度估计等</p><h1 id="加载示例数据集"><a href="#加载示例数据集" class="headerlink" title="加载示例数据集"></a>加载示例数据集</h1><p>有几个标准数据集，鸢尾花和手写字用于分类，以及波士顿房价数据集用于回归。<br>鸢尾花与手写字数据集的导入。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.30.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>数据集就是一个字典对象，包含了所有的数据以及一些关于数据的元数据。数据存储在.data成员中，它是一个n个样本，n个特征的数组。在监督学习的问题中，因变量存在.target成员中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.37.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.41.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数据数组的形状"><a href="#数据数组的形状" class="headerlink" title="数据数组的形状"></a>数据数组的形状</h2><p>数据总是二维数组，（n_sample,n_features）的形状，即使原始数据可能有着不同的形状。在手写字识别中，每个原始例子是（8 <em> 8）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.48.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但是在data中变成了（1</em>64）。</p><h1 id="学习以及预测"><a href="#学习以及预测" class="headerlink" title="学习以及预测"></a>学习以及预测</h1><p>在scikit-learn中，分类器是一个实现了方法fit(x,y)和predict(T)的Python对象。</p><p>先把分类器当做是一个黑盒。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.57.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>选择模型的参数<br>在这个例子中我们是人工选择的参数，为了寻找这些参数的更好的值，我们能使用例如网格搜索和交叉验证的工具。</p><p>分类器实例拟合模型是通过传递训练集给fit方法。对于训练集，我们使用除了最后一张图片的所有图片，最后一张图片用来做预测。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.48.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>来预测：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.49.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="模型持久化"><a href="#模型持久化" class="headerlink" title="模型持久化"></a>模型持久化</h1><p>使用pickle。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.50.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用joblib，joblib在大数据方面更加高效，但是遗憾的是它只能把数据持久化到硬盘而不是字符串（搬到字符串意味着数据在内存中）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.57.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>之后可以重新加载模型（也可以在其他的Python进程中）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.59.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注意</strong>：joblib.dump和joblib.load也接收像文件一样的对象而不是文件名。</p><h1 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>除非特别指明，输入将被转换为float64:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%882.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>x是float32型，可以通过fit_transform(x)转换为float64。</p><p>回归的目标类型转化为float64，分类的目标类型保留下来。</p><h2 id="改装和更新参数"><a href="#改装和更新参数" class="headerlink" title="改装和更新参数"></a>改装和更新参数</h2><p>超参数在通过set_params()方法创建后能够更新。调用fit()函数超过一次将会重写之前fit()所学的内容。</p><h2 id="多类别vs多标签拟合"><a href="#多类别vs多标签拟合" class="headerlink" title="多类别vs多标签拟合"></a>多类别vs多标签拟合</h2><p>当使用多类别分类器，所执行的学习和预测任务取决于适合于目标数据的格式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习：问题背景&quot;&gt;&lt;a href=&quot;#机器学习：问题背景&quot; class=&quot;headerlink&quot; title=&quot;机器学习：问题背景&quot;&gt;&lt;/a&gt;机器学习：问题背景&lt;/h1&gt;&lt;p&gt;学习问题分以下几类：&lt;/p&gt;
&lt;h2 id=&quot;有监督学习&quot;&gt;&lt;a href=&quot;#有监
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>决策树和随机森林</title>
    <link href="https://github.com/zdkswd/2018/11/07/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <id>https://github.com/zdkswd/2018/11/07/决策树和随机森林/</id>
    <published>2018-11-07T11:55:47.000Z</published>
    <updated>2018-11-07T11:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习升级版-决策树和随机森林"><a href="#机器学习升级版-决策树和随机森林" class="headerlink" title="机器学习升级版 决策树和随机森林"></a>机器学习升级版 决策树和随机森林</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.26.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.29.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.31.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.32.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.50.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.55.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.55.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.21.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.22.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.24.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.25.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.28.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.31.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.32.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.44.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.50.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基于样本和特征的双重随机性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.59.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>之所以有那么多种的处理办法，是因为没有某一种是十分有效的。</p><p>CART<br>classification and regression tree</p><h1 id="统计学习方法-决策树"><a href="#统计学习方法-决策树" class="headerlink" title="统计学习方法 决策树"></a>统计学习方法 决策树</h1><p>决策树( decision tree)是一种基本的分类与回归方法。这里主要是用于分类的决策树.决策树模型呈树形结构,在分类问题中,表示基于特征对实例进行分类的过程。它可以认为是 if-then规则的集合,也可以认为是定义在特征空间与类空间上的条件概率分布。</p><p>其主要优点是模型具有可读性,分类速度快。学习时,利用训练数据根据损失函数最小化的原则建立决策树模型。预测时,对新的数据,利用决策树模型进行分类。</p><p>决策树学习通常包括3个步骤:特征选择、决策树的生成和决策树的修剪。</p><h2 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h2><h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><p>分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边( directed edge)组成。<br>结点有两种类型:内部结点( internal node)和叶结点( leaf node)。内部结点表示一个特征或属性,叶结点表示一个类。</p><p>用决策树分类,从根结点开始,对实例的某一特征进行测试,根据测试结果,将实例分配到其子结点;这时,每一个子结点对应着该特征的一个取值.如此递归地对实例进行测试并分配,直至达到叶结点.最后将实例分到叶结点的类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%884.41.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>圆代表内部节点，方框代表叶节点。</p><h3 id="决策树与if-then规则"><a href="#决策树与if-then规则" class="headerlink" title="决策树与if-then规则"></a>决策树与if-then规则</h3><p>可以将决策树看成一个 if-then规则的集合.将决策树转换成 if-then规则的过程是这样的:由决策树的根结点到叶结点的每一条路径构建一条规则;路径上内部结点的特征对应着规则的条件,而叶结点的类对应着规则的结论.决策树的路径或其对应的 if-then规则集合具有一个重要的性质:互斥并且完备.这就是说,每一个实例都被一条路径或一条规则所覆盖,而且只被一条路径或一条规则所覆盖.这里所谓覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p><h3 id="决策树与条件概率分布"><a href="#决策树与条件概率分布" class="headerlink" title="决策树与条件概率分布"></a>决策树与条件概率分布</h3><p>决策树还表示给定特征条件下类的条件概率分布。假设X为表示特征的随机变量,Y为表示类的随机变量,那么这个条件概率分布可以表示为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%884.49.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>X取值与给定划分下单元的集合，Y取值于类的集合。各叶节点上的条件概率往往偏向某一类，即属于某一类的概率较大。决策树分类时将该节点的实例强行分到条件概率大的那一类去。</p><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习本质上是从训练数据集中归纳出一组分类规则。与训练数据集不<br>相矛盾的决策树(即能对训练数据进行正确分类的决策树)可能有多个,也可能<br>一个也没有。我们需要的是一个与训练数据矛盾较小的决策树,同时具有很好的<br>泛化能力。</p><p>决策树学习用损失函数表示这一目标,如下所述,决策树学习的损失函数通常是正则化的极大似然函数.决策树学习的策略是以损失函数为目标函数的最小化。</p><p>当损失函数确定以后,学习问题就变为在损失函数意义下选择最优决策树的问题,因为从所有可能的决策树中选取最优决策树是NP完全问题,所以现实中决策树学习算法通常采用<strong>启发式方法</strong>,近似求解这一最优化问题.这样得到的决策树是次最优(sub- optimal)的。</p><p>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。</p><p>生成的决策树可能对训练数据有很好的分类能力,但对未知的测试数据却未必有很好的分类能力,即可能发生过拟合现象.我们需要对已生成的树自下而上进行剪枝,将树变得更简单,从而使它具有更好的泛化能力。</p><p>如果特征数量很多,也可以在决策树学习开始的时候,对特征进行选择,只留下对训练数据有足够分类能力的特征。</p><p>决策树学习算法包含特征选择、决策树的生成与决策树的剪枝过程.由于决策树表示一个条件概率分布,所以深浅不同的决策树对应着不同复杂度的概率模型.决策树的生成对应于模型的局部选择,决策树的剪枝对应于模型的全局选择.决策树的生成只考虑局部最优,相对地,决策树的剪枝则考虑全局最优。</p><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><h3 id="特征选择问题"><a href="#特征选择问题" class="headerlink" title="特征选择问题"></a>特征选择问题</h3><p>特征选择在于选取对训练数据具有分类能力的特征.这样可以提高决策树学习的效率.如果利用一个特征进行分类的结果与随机分类的结果没有很大差别,则称这个特征是没有分类能力的,经验上扔掉这样的特征对决策树学习的精度影响不大,通常特征选择的准则是<strong>信息增益</strong>或<strong>信息增益比</strong>。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><h4 id="信息增益的算法"><a href="#信息增益的算法" class="headerlink" title="信息增益的算法"></a>信息增益的算法</h4><p>输入训练集D和特征A：<br>输出：特征A对训练数据集D的信息增益g(D,A)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.38.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.39.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.44.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>A3，A4类似，最后比较各特征的信息增益值。由于特征A3的信息增益值最大，所以选择特征A3作为最优特征。</p><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><h4 id="信息增益比定义"><a href="#信息增益比定义" class="headerlink" title="信息增益比定义"></a>信息增益比定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.47.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法的<strong>核心</strong>是在决策树各个结点上应用<strong>信息增益</strong>准则选择特征,递归地构建决策树.具体方法是:从根结点( root node)开始,对结点计算所有可能的特征的信息增益,选择信息增益最大的特征作为结点的特征,由该特征的不同取值建立子结点;再对子结点递归地调用以上方法,构建决策树;直到所有特征的信息增益均很小或没有特征可以选择为止,最后得到一个决策树.ID3相当于用极大似然法进行概率模型的选择。</p><h4 id="算法（ID3算法）"><a href="#算法（ID3算法）" class="headerlink" title="算法（ID3算法）"></a>算法（ID3算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.51.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.52.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.54.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ID3算法只有树的生成，所以该算法生成的树容易产生过拟合。</p><h3 id="C4-5的生成算法"><a href="#C4-5的生成算法" class="headerlink" title="C4.5的生成算法"></a>C4.5的生成算法</h3><p>C4.5算法与ID3算法相似，C4.5算法对ID3算法进行了改进。C4.5在生成的过程中，用<strong>信息增益比</strong>来选择特征。</p><h4 id="算法（C4-5的生成算法）"><a href="#算法（C4-5的生成算法）" class="headerlink" title="算法（C4.5的生成算法）"></a>算法（C4.5的生成算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.57.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><p>决策树生成算法递归地产生决策树,直到不能继续下去为止,这样产生的树往往对训练数据的分类很准确,但对未知的测试数据的分类却没有那么准确,即出现过拟合现象.过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类,从而构建出过于复杂的决策树,解决这个问题的办法是考虑决策树的复杂度,对已生成的决策树进行简化。</p><p>在决策树学习中将已生成的树进行简化的过程称为剪枝( pruning).具体地,剪枝从已生成的树上裁掉一些子树或叶结点,并将其根结点或父结点作为新的叶结点,从而简化分类树模型。</p><p>决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。设树T的叶节点个数为|T|，t是树T的叶节点，该<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%889.18.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C（T）表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型复杂度，参数α≥0控制两者之间的影响。较大的α促使选择较简单的模型（树），较小的α促使选择较复杂的模型（树）。α=0意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。</p><p>剪枝,就是当α确定时,选择损失函数最小的模型,即损失函数最小的子树.当α值确定时,子树越大,往往与训练数据的拟合越好,但是模型的复杂度就越髙;相反,子树越小,模型的复杂度就越低,但是往往与训练数据的拟合不好,损失函数正好表示了对两者的平衡。</p><h3 id="算法（树的剪枝算法）"><a href="#算法（树的剪枝算法）" class="headerlink" title="算法（树的剪枝算法）"></a>算法（树的剪枝算法）</h3><p>输入：生成算法产生的整个树T，参数α；<br>输出：修剪后的子树Tα。</p><ol><li>计算每个结点的经验熵。</li><li>递归地从树的叶节点向上回缩。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%889.30.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="3"><li>返回2，直至不能继续为止，得到损失函数最小的子树Tα。</li></ol><p>式(515)只需考虑两个树的损失函数的差,其计算可以在局部进行,所以,决策树的剪枝算法可以由一种动态规划的算法实现。</p><h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><p>CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小(模型变简单)，从而能够对未知数据有更准确的预测。</p><p> CART剪枝算法由两步组成:首先从生成算法产生的决策树To底端开始不断剪枝,直到To的根结点，形成一个子树序列{T1,…,Tn};然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p><h4 id="剪枝，形成一个子树序列"><a href="#剪枝，形成一个子树序列" class="headerlink" title="剪枝，形成一个子树序列"></a>剪枝，形成一个子树序列</h4><p>在剪枝过程中，计算子树的损失函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.24.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>T为任意子树，C（T）为训练数据的预测误差（如基尼指数），|T|为子树的叶节点个数，α≥0为参数，Cα（T）为参数是α时的子树T的整体损失。参数α权衡训练数据的拟合程度与模型的复杂度。</p><p>对固定的α,一定存在使损失函数C(T)最小的子树，将其表示为Tα. Tα在损失函数Cα(T)最小的意义下是最优的.容易验证这样的最优子树是唯一的.当α大的时候，最优子树Tα偏小;当α小的时候，最优子树Tα偏大. 极端情况，当α=0时，整体树是最优的，当α趋近正无穷时，根结点组成的单结点树是最优的.</p><p>从整体树T0开始剪枝，对T0的任意内部节点t，以t为单结点树的损失函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.55.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>以t为根结点的子树Tt的损失函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.56.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α=0及α充分小时，有不等式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.02.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α增大时，在某一α有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.02.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α再增大时，不等式反向。只要<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Tt与t有相同的损失函数值，而t的节点少，因此t比Tt更可取，对Tt进行剪枝。</p><p>为此，对T0中每一内部结点t，计算<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.05.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它表示剪枝后整体损失函数减少的程度.在T0中剪去g(t)最小的Tt,将得到的子<br>树作为T1，同时将最小的g(t)设为α1. T1为区间[α1,α2)的最优子树.</p><p>如此剪枝下去，直到得到根节点。在这一过程中，不断增加α的值，产生新的区间。</p><h4 id="在剪枝得到的子树序列T0-T1-…-Tn中通过交叉验证选取最优子树Tα"><a href="#在剪枝得到的子树序列T0-T1-…-Tn中通过交叉验证选取最优子树Tα" class="headerlink" title="在剪枝得到的子树序列T0,T1,…,Tn中通过交叉验证选取最优子树Tα"></a>在剪枝得到的子树序列T0,T1,…,Tn中通过交叉验证选取最优子树Tα</h4><p>具体地，利用独立的验证数据集，测试子树序列T0,T1,…,Tn中各棵子树的平方误差或基尼指数.平方误差或基尼指数最小的决策树被认为是最优的决策树.在子树序列中，每棵子树T1,T2,.,Tn都对应于一个参数α1,α2,…,αn,.所以，当最优子树Tk确定时，对应的ak也确定了，即得到最优决策树Tα。</p><h3 id="CART剪枝算法"><a href="#CART剪枝算法" class="headerlink" title="CART剪枝算法"></a>CART剪枝算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.11.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习升级版-决策树和随机森林&quot;&gt;&lt;a href=&quot;#机器学习升级版-决策树和随机森林&quot; class=&quot;headerlink&quot; title=&quot;机器学习升级版 决策树和随机森林&quot;&gt;&lt;/a&gt;机器学习升级版 决策树和随机森林&lt;/h1&gt;&lt;figure class=&quot;im
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow基础知识上</title>
    <link href="https://github.com/zdkswd/2018/11/04/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/"/>
    <id>https://github.com/zdkswd/2018/11/04/TensorFlow基础知识上/</id>
    <published>2018-11-04T10:56:41.000Z</published>
    <updated>2018-11-05T04:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%887.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>自底向上为设备层和网络层、数据操作层、图计算层、API层、应用层。</p><p>其中设备层和网络层、数据操作层、图计算层是TensorFlow的核心层。</p><h2 id="网络通信层和设备管理层"><a href="#网络通信层和设备管理层" class="headerlink" title="网络通信层和设备管理层"></a>网络通信层和设备管理层</h2><p>网络通信层包括gRPC( google Remote Procedure Call Protocol)和远程直接数据存取( Remote direct Memory Access,RDMA),这都是在分布式计算时需要用到的。设备管理层包括 TensorFlow分别在CPU、GPU、FPGA等设备上的实现,也就是对上层提供了一个统一的接口,使上层只需要处理卷积等逻辑,而不需要关心在硬件上的卷积的实现过程。</p><h2 id="数据操作层"><a href="#数据操作层" class="headerlink" title="数据操作层"></a>数据操作层</h2><p>主要包括卷积函数、激活函数等操作。</p><h2 id="图计算层（了解的核心）"><a href="#图计算层（了解的核心）" class="headerlink" title="图计算层（了解的核心）"></a>图计算层（了解的核心）</h2><p>包含本地计算图和分布式计算图的实现。</p><h2 id="API层和应用层"><a href="#API层和应用层" class="headerlink" title="API层和应用层"></a>API层和应用层</h2><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>TensorFlow的设计理念主要体现在以下两个方面。</p><h2 id="将图的定义和图的运行完全分开"><a href="#将图的定义和图的运行完全分开" class="headerlink" title="将图的定义和图的运行完全分开"></a>将图的定义和图的运行完全分开</h2><p>编程模式通常分为<strong>命令式编程</strong>和<strong>符号式编程</strong>。命令式编程就是我们理解的通常意义上的程序，很容易理解和调试，按照原有的逻辑执行。符号式编程涉及很多的嵌入和优化,不容易理解和调试,但<strong>运行速度相对有所提升</strong>。现有的深度学习框架中, Torch是典型的命令式的,Cafe、 MXNet采用了两种编程模式混合的方法,而 TensorFlow完全釆用符号式编程。</p><p>符号式计算一般是先定义各种变量,然后建立一个数据流图,在数据流图中规定各个变量之间的计算关系,最后需要对数据流图进行编译,但此时的数据流图还是一个空壳儿,里面没有任何实际数据,只有把需要运算的输入放进去后,才能在整个模型中形成数据流,从而形成输出值。</p><p>在传统的程序操作中,定义了t的运算,在运行时就执行了,并输出17。而在TensorFlow中,数据流图中的节点,实际上对应的是 Tensor Flow APi中的一个操作,并没有真正去运行:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%887.56.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="TensorFlow中涉及的运算都要放在图中-而图的运行只发生在会话-session-中"><a href="#TensorFlow中涉及的运算都要放在图中-而图的运行只发生在会话-session-中" class="headerlink" title="TensorFlow中涉及的运算都要放在图中,而图的运行只发生在会话( session)中"></a>TensorFlow中涉及的运算都要放在图中,而图的运行只发生在会话( session)中</h2><p>开启会话后,就可以用数据去填充节点,进行运算;关闭会话后,就不能进行计算了。因此,会话提供了操作运行和 Tensor求值的环境。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%887.57.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h1><h2 id="边"><a href="#边" class="headerlink" title="边"></a>边</h2><p>TensorFlow的边有两种连接关系:数据依赖和控制依赖。</p><h3 id="实线边表示数据依赖"><a href="#实线边表示数据依赖" class="headerlink" title="实线边表示数据依赖"></a>实线边表示数据依赖</h3><p>代表数据，即张量。任意纬度的数据统称为张量。在机器学习算法中，张量在数据流图中从前往后流动一遍就完成了一次前向传播，而残差从后向前流动一遍就完成了一次反向传播。（在数理统计中，残差是指实际观察值与训练的估计值之间的差。）</p><h3 id="虚线边表示控制依赖（control-dependency-）"><a href="#虚线边表示控制依赖（control-dependency-）" class="headerlink" title="虚线边表示控制依赖（control dependency ）"></a>虚线边表示控制依赖（control dependency ）</h3><p>可以用于控制操作的运行，这被确保happens-before关系，这类边上没有数据流过，但源节点必须在目的节点开始执行前完成执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%889.06.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>TensorFlow 支持的张量具有表 4-1 所示的数据属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%889.07.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>图中的节点又称为算子，它代表一个操作(operation，OP)，一般用来表示施加的数学运算，也可以表示数据输入(feed in)的起点以及输出(push out)的终点，或者是读取/写入持久变量(persistent variable)的终点。 表 4-2 列举了一些 TensorFlow 实现的算子。算子支持表 4-1 所示的张量的各种数据属性，并且需要在建立图的时候确定下来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%889.18.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与操作相关的代码位于 tensorflow-1.1.0/tensorflow_python_ops_目录下。以数学运算为例，代 码为上述目录下的 math_ops.py，里面定义了 add、subtract、multiply、scalar_mul、div、divide、 truediv、floordiv 等数学运算，每个函数里面调用了 gen_math_ops.py 中的方法，这个文件是在 编译(安装时)TensorFlow 时生成的，位于 Python 库 site-packages_tensorflow_python_ops_gen_ math_ops.py 中，随后又调用了 tensorflow-1.1.0_tensorflow_core_kernels/下面的核函数实现。 </p><h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>把操作任务描述成有向无环图。构建图的第一步是创建各个节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.30.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>启动图的第一步是创建一个 Session对象。会话( session)提供在图中执行操作的一些方法。一般的模式是,建立会话,此时会生成一张空图,在会话中添加节点和边,形成一张图,然后执行。</p><p>要创建一张图并运行操作的类,在 Python的API中使用tf. Session,在C++的API中使用tensorflow: Session。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.33.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在调用 Session对象的run（）方法来执行图时,传入一些 Tensor,这个过程叫填充(feed)返回的结果类型根据输入的类型而定,这个过程叫取回( fetch)。</p><p>与会话相关的源代码位于 tensorfow-11.0/ tensorfow/ python/ client/session. py。</p><p><strong>会话</strong>是<strong>图交互的一个桥梁,</strong>一个会话可以有多个图,会话可以修改图的结构,也可以往图中注入数据进行计算。因此,会话主要有两个AP接口: <strong>Extend</strong>和<strong>Run</strong>。 <strong>Extend</strong>操作是<strong>在 Graph中添加节点和边</strong>,<strong>Run</strong>操作是<strong>输入计算的节点和填充必要的数据后,进行运算,并输出运算结果。</strong></p><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>设备（device）是指一块可以用来运算并且拥有自己的地址空间的硬件，如GPU和CPU。</p><p>TensorFlow为了实现分布式执行操作,充分利用计算资源,可以明确指定操作在哪个设备上执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.40.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与设备相关的源代码位于 tensorfow-1.1.0 tensorflow_python_ framework/device. py。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量( variable）是一种特殊的数据,<strong>它在图中有固定的位置,不像普通张量那样可以流动</strong>。例如,创建一个变量张量,使用tf.Variable()构造函数,这个构造函数需要一个初始值,初始值的形状和类型决定了这个变量的形状和类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.45.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建一个常量张量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.46.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>TensorFlow还提供了填充机制,可以在构建图时使用tf.placeholder临时替代任意操作的张量,在调用 Session对象的run（）方法去执行图时,使用填充数据作为调用的参数,调用结束后,填充数据就消失。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.52.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与变量相关的源代码位于 tensorflow/ tensorflow/ python_ops_ variables. py。</p><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>我们知道操作( operation)是对抽象操作(如 matmul或者ad)的一个统称,而内核( kemel)则是能够运行在特定设备(如CPU、GPU)上的一种对操作的实现。因此,同一个操作可能会对应多个内核。</p><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="图、操作和张量"><a href="#图、操作和张量" class="headerlink" title="图、操作和张量"></a>图、操作和张量</h2><p>与图相关的API均位于tf.Graph类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.57.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>tf.Operation类代表图中的一个节点，用于<strong>计算张量数据</strong>。该类型由节点构造器（如tf.matmul()或者Graph.create_op()）产生。例如，c=tf.matmul(a,b)<br>创建一个Operation类，其类型为MatMul的操作类。与操作相关的API均位于tf.Operation类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%8810.13.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%8810.14.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>tf.Tensor类是操作输出的符号句柄,它不包含操作输出的值,而是提供了一种在tf.Session中计算这些值的方法。这样就可以在操作之间构建一个数据流连接,使 TensorFlow能够执行一个表示大量多步计算的图形。与张量相关的API均位于tf.Tensor类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%8810.33.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>在 TensorFlow中有两个作用域( scope),一个是 name_scope,另一个是 variable_scope。简而言之, name_scope主要是给 variable_name加前缀,也可以给 op_ name加前缀; name_scope是给 op_name加前缀。</p><h2 id="variable-scope"><a href="#variable-scope" class="headerlink" title="variable_scope"></a>variable_scope</h2><p>variable_scope变量作用域机制在 TensorFlow中主要由两部分组成:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.29.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建或是返回一个变量，或是为变量指定命名空间。</p><p>当 tf. get_variable_scope. reuse==False时, variable_scope作用域只能用来创建新变量:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.32.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上述程序会抛出ValueError错误，因为v这个变量已经被定义过了，但tf.get_variable_scope().reuse默认为False，所以不能重用。</p><p>当tf.get_variable_scope().reuse=True时,作用域可以共享变量:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.38.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="获取变量作用域"><a href="#获取变量作用域" class="headerlink" title="获取变量作用域"></a>获取变量作用域</h3><p>可以直接通过 tf.variable_scope()来获取变量作用域:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.41.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果在开启的一个变量作用域里使用之前预先定义的一个作用域,则会跳过当前变量的作用域,保持预先存在的作用域不变。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.43.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="变量作用域的初始化"><a href="#变量作用域的初始化" class="headerlink" title="变量作用域的初始化"></a>变量作用域的初始化</h3><p>变量作用域可以默认携带一个初始化器,在这个作用域中的子作用域或变量都可以继承或者重写父作用域初始化器中的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.46.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在variable_scope作用域下的操作op_name也会被加上前缀。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.50.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.50.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>variable scope主要用在循环神经网络(RNN)的操作中,其中需要大量的共享变量。</p><h2 id="name-scope示例"><a href="#name-scope示例" class="headerlink" title="name_scope示例"></a>name_scope示例</h2><p>TensorFlow中常常会有数以千计的节点,在可视化的过程中很难一下子展示出来,因此用name_scope为变量划分范围,在可视化中,这表示在计算图中的一个层级。name_scope会影响op_name,不会影响get_variableo创建的变量,而会影响通过 Variableo创建的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.59.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="批标准化"><a href="#批标准化" class="headerlink" title="批标准化"></a>批标准化</h1><p>批标准化( batch normalization,BN)是为了克服神经网络层数加深导致难以训练而诞生的我们知道,深度神经网络随着网络深度加深,训练起来会越来越困难,收敛速度会很慢,常常会导致梯度弥散问题( vanishing gradient problem)。</p><p>统计机器学习中有一个<strong>ICS</strong>( Internal Covariate shift)理论,这是一个经典假设:源域( source domain)和目标域( target domain)的数据分布是一致的。也就是说,训练数据和测试数据是满足相同分布的。这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。</p><p><strong>Covariate shift</strong>是指训练集的样本数据和目标样本集分布不一致时,训练得到的模型无法很好地泛化( generalization)。它是分布不一致假设之下的一个分支问题,也就是指源域和目标域的条件概率是一致的,但是其边缘概率不同。的确,对于神经网络的各层输出,在经过了层内操作后,各层输出分布就会与对应的输入信号分布不同,而且差异会随着网络深度增大而加大,但是每一层所指向的样本标记( label)仍然是不变的。</p><p>解决思路一般是根据训练样本和目标样本的比例对训练样本做一个矫正。因此，通过引入批标准化来规范化某些层或者所有层的输入，从而固定每层输入信号的均值与方差。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>批标准化一般用在非线性映射(激活函数)之前,对x=Wu+b做规范化,使结果(输出信号各个维度)的均值为0,方差为1。让每一层的输入有一个稳定的分布会有利于网络的训练。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>批标准化通过规范化让激活函数分布在线性区间,结果就是加大了梯度,让模型更加大胆地进行梯度下降,于是有如下优点：</p><ol><li>加大探索的步长，加快收敛的速度。</li><li>更容易跳出局部最小值。</li><li>破坏原来的数据分布，一定程度上缓解过拟合。</li></ol><p>在遇到神经网络收敛速度很慢或梯度爆炸等无法训练的情况下，都可以尝试用批标准化来解决。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>对每层的Wx_plus_b进行批标准化，这个步骤在激活函数之前。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%886.52.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>规范化，也可以称为标准化，是将数据按比例缩放，使之落在一个小的特定区间。这里是指数据减去平均值，再除以标准差。</p><h1 id="tf-add-a-b-与-a-b"><a href="#tf-add-a-b-与-a-b" class="headerlink" title="tf.add(a, b) 与 a+b"></a>tf.add(a, b) 与 a+b</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统架构&quot;&gt;&lt;a href=&quot;#系统架构&quot; class=&quot;headerlink&quot; title=&quot;系统架构&quot;&gt;&lt;/a&gt;系统架构&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="TensorFlow" scheme="https://github.com/zdkswd/tags/TensorFlow/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习升级版 回归</title>
    <link href="https://github.com/zdkswd/2018/11/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/"/>
    <id>https://github.com/zdkswd/2018/11/04/机器学习升级版 回归/</id>
    <published>2018-11-04T08:28:47.000Z</published>
    <updated>2018-11-06T07:53:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.12.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.13.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.15.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 通过样本拟合直线，线性回归。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.27.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>做一个理论的假定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.30.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.35.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.36.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>目标函数不就是个最小二乘法了吗。</p><p>关于假设：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.39.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.40.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.41.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.49.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.59.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.06.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至于为什么要跟西塔有关，因为在震荡很大的函数中θ系数很大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.07.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Ridge是θ的平方和，LASSO是θ绝对值相加。</p><p>L2范数，L1范数与混合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.13.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>LASSO有一定的特征选择能力，随着次数的增高，高次项系数趋近于0了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.44.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>L1的形式很像拉格拉日乘子法，正方形区域内是可行域，当取最小值时，某些轴上会取0值。推广一下，轴数高了，某些权值是0，也就具有了一定选择能力。</p><p>对于L1范数中的λ，就是超参数，我们无法从样本中确定λ的值，只能通过验证数据去选。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.34.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.45.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.46.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个函数是个凸函数，解出来的一定是全局最小的。可以看到式中的求和符号，所有样本求和下降一回。BSD</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.52.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>式中没有求和符号，一个样本下降一回。SGD，适合做在线学习。适合跳出局部极小值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.58.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>mini-batchSGD，简称了SGD，其实这种叫法并不严谨。习惯用语。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%889.06.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们的线性回归是对参数的线性。对样本无所谓。</p><h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><p>分类问题的首选算法，多分类：softmax回归。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.14.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.25.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.32.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里的目标函数取最大值，因为是最大似然估计。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.48.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.50.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>逻辑回归是一个对数上的线性模型。 </p><p>若是想让一个几率是线性的函数，反过来求概率，就是逻辑回归的形式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.53.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>损失函数就是似然函数取负号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.19.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个损失函数不那么漂亮，我们可以把它写得漂亮一些。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.21.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.56.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>关于似然函数的解释：最靠近p的那个乘积由于是one-hot编码所以其实连乘的话只有一项就是表达式其他项均为1。<br>由于是求随机梯度下降，所以可以不管第一个求和符号，目标函数为后一部分。<br>logistic回归中式子中的1其实是e的零次方。</p><h2 id="定义信息量"><a href="#定义信息量" class="headerlink" title="定义信息量"></a>定义信息量</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>期望的结果就是信息熵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.35.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>底无所谓是几，因为有换底公式，无非就是多了个系数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.37.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> 这个图像说明当两点分布时如果概率相同，熵是最大的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.46.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.48.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.50.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="联合熵和条件熵"><a href="#联合熵和条件熵" class="headerlink" title="联合熵和条件熵"></a>联合熵和条件熵</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.54.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.56.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.58.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.04.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.06.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.05.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.07.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>相对熵（relative entropy）就是KL散度（Kullback–Leibler divergence），用于衡量两个概率分布之间的差异。相对熵的特点，是只有p(x)=q(x)时，其值为0。若p(x)和q(x)略有差异，其值就会大于0。</p><p>假设我们想知道某个策略和最优策略之间的差异，我们就可以用相对熵来衡量这两者之间的差异。即，相对熵 = 某个策略的交叉熵 - 信息熵（根据系统真实分布计算而得的信息熵，为最优策略）</p><p>后半部分相当于了一个常数，相对熵达到最小值的时候，也意味着交叉熵达到了最小值。</p><h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>负对数似然就等于交叉熵损失。我们可以把Logstic回归损失叫做交叉熵损失。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h2><p>评价分类的指标。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%882.40.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="差分与取对数"><a href="#差分与取对数" class="headerlink" title="差分与取对数"></a>差分与取对数</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%882.54.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8D%87%E7%BA%A7%E7%89%88%20%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%883.01.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>滑动平均值是从一个有n项的时间序列中来计算多个连续m项序列的平均值。</p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>关键词：正则化，get_Variable,sess.run<br><a href="https://github.com/zdkswd/myTensorflowExamples/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92.py">https://github.com/zdkswd/myTensorflowExamples/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92.py</a></p><h2 id="逻辑回归与Softmax回归"><a href="#逻辑回归与Softmax回归" class="headerlink" title="逻辑回归与Softmax回归"></a>逻辑回归与Softmax回归</h2><p>softmax就是多分类的逻辑回归，使用的损失函数是交叉熵，交叉熵就是负的逻辑回归的极大似然估计。<br>softmax成为了激活函数。<br><a href="https://github.com/zdkswd/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py">https://github.com/zdkswd/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;headerlink&quot; title=&quot;线性回归&quot;&gt;&lt;/a&gt;线性回归&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python数据科学手册 Matplotlib数据可视化</title>
    <link href="https://github.com/zdkswd/2018/11/01/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2018/11/01/Python数据科学手册 Matplotlib数据可视化/</id>
    <published>2018-11-01T13:00:56.000Z</published>
    <updated>2018-11-01T13:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib是建立在 NumPy数组基础上的多平台数据可视化程序库。</p><p>Matplotlib最重要的特性之一就是具有良好的操作系统兼容性和图形显示底层接口兼容性( graphics backend)。 Matplotlib支持几十种图形显示接口与输出格式,这使得用户无论在哪种操作系统上都可以输出自己想要的图形格式。这种跨平台、面面俱到的特点已经成为 Matplotlib最强大的功能之一, Matplotlib也因此吸引了大量用户,进而形成了一个活跃的开发者团队,晋升为 Python科学领域不可或缺的强大武器。</p><h1 id="Matplotlib常用技巧"><a href="#Matplotlib常用技巧" class="headerlink" title="Matplotlib常用技巧"></a>Matplotlib常用技巧</h1><h2 id="导入-Matplotlib"><a href="#导入-Matplotlib" class="headerlink" title="导入 Matplotlib"></a>导入 Matplotlib</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%889.53.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="设置绘图样式"><a href="#设置绘图样式" class="headerlink" title="设置绘图样式"></a>设置绘图样式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%889.54.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="用不用show-如何显示图形"><a href="#用不用show-如何显示图形" class="headerlink" title="用不用show()?如何显示图形"></a>用不用show()?如何显示图形</h2><h3 id="在脚本中画图"><a href="#在脚本中画图" class="headerlink" title="在脚本中画图"></a>在脚本中画图</h3><p>如果你在一个脚本文件中使用 Matplotlib,那么显示图形的时候必须使用plt.show()。plt.show()会启动一个事件循环( event lop),并找到所有当前可用的图形对象,然后打开一个或多个交互式窗口显示图形。</p><p>plt,show()这行代码在后面完成了许多事情,它需要与你使用的操作系统的图形显示接口进行交互。虽然具体的操作细节会因操作系统和安装过程不同而有很大的差异,但是 Matplotlib为你隐藏所有的细节,非常省心。</p><p>不过有一点需要注意,一个 Python会话( session)中只能使用一次plt.show(),因此通常都把它放在脚本的最后。多个plt.show()命令会导致难以预料的显示异常,应该尽量避免。</p><h3 id="在IPython-shell中画图"><a href="#在IPython-shell中画图" class="headerlink" title="在IPython shell中画图"></a>在IPython shell中画图</h3><h3 id="在IPython-Notebook中画图"><a href="#在IPython-Notebook中画图" class="headerlink" title="在IPython Notebook中画图"></a>在IPython Notebook中画图</h3><h2 id="将图形保存为文件"><a href="#将图形保存为文件" class="headerlink" title="将图形保存为文件"></a>将图形保存为文件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%8810.00.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%8810.01.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当你保存图形文件时,不需要使用plt.show()。</p><h1 id="两种画图接口"><a href="#两种画图接口" class="headerlink" title="两种画图接口"></a>两种画图接口</h1><p> Matplotlib有一个容易让人混淆的特性,就是它的两种画图接口,一个是便捷的 MATLAB风格接口,另一个是功能更强大的面向对象接口。</p><h2 id="MATLAB风格接口"><a href="#MATLAB风格接口" class="headerlink" title="MATLAB风格接口"></a>MATLAB风格接口</h2><p>Matplotlib最初作为 MATLAB用户的 Python替代品,许多语法都和MATLAB类似。 MATLAB风格的工具位于 pyplot(plt)接口中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.35.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种接口最重要的特性是有状态的( stateful):它会持续跟踪“当前的图形和坐标轴,所有plt命令都可以应用。你可以用plt.gcf()(获取当前图形)和plt,gca()(获取当前坐标轴)来查看具体信息。</p><p>虽然这个有状态的接口画起来图又快又方便，但是也很容易出问题。当创建上面的第二个子图时,怎么才能回到第一个子图,并增加新内容呢?虽然用 MATLAB风格接口也能实现,但未免过于复杂,好在还有一种更好的办法!</p><h2 id="面向对象接口"><a href="#面向对象接口" class="headerlink" title="面向对象接口"></a>面向对象接口</h2><p>面向对象接口可以适应更复杂的场景,更好地控制你自己的图形。在面向对象接口中,画图函数不再受到当前“活动”图形或坐标轴的限制,而变成了显式的 Figure和Axes的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.40.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然在画简单图形时,选择哪种绘图风格主要看个人喜好,但是在画比较复杂的图形时,面向对象方法会更方便。在本章中,我们将在MATLAB风格接口与面向对象接口间来回转换,具体内容根据实际情况而定。在绝大多数场中,plt.plot()与ax.plot()的差异非常小,但是其中会有一些陷阱。</p><h1 id="简易线形图"><a href="#简易线形图" class="headerlink" title="简易线形图"></a>简易线形图</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.41.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在 Matplotlib里面, figure(plt.Figure类的一个实例)可以被看成是个能够容纳各种坐标轴、图形、文字和标签的容器。就像你在图中看到的那样,axes(plt.Axes类的一个实例)是一个带有刻度和标签的矩形,最终会包含所有可视化的图形元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.59.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.13.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="调整图形：线条的颜色与风格"><a href="#调整图形：线条的颜色与风格" class="headerlink" title="调整图形：线条的颜色与风格"></a>调整图形：线条的颜色与风格</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.14.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果不指定颜色, Matplotlib就会为多条线自动循环使用一组默认的颜色。</p><p>与之类似，也可以用linestyle调整线条的风格。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.15.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.15.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一种更简洁的方式,则可以将linstyle和 color编码组合起来,作为plt.plot()函数的一个非关键字参数使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.27.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.27.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="调整图形：坐标轴上下限"><a href="#调整图形：坐标轴上下限" class="headerlink" title="调整图形：坐标轴上下限"></a>调整图形：坐标轴上下限</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.29.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果你想要让坐标轴逆序显示,那么也可以逆序设置坐标轴刻度值。</p><p>还有一个方法是plt,axis()(注意不要搞混axes和axis)。通过传入[xmin,xmax,ymin,ymax]对应的值,plt,axis()方法可以让你用一行代码设置x或y的限值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.31.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>plt axis（）还可以按照图形的内容自动收紧坐标轴，不留空白区域。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.32.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以xy轴单位长度相等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.33.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="设置图形标签"><a href="#设置图形标签" class="headerlink" title="设置图形标签"></a>设置图形标签</h2><p>图形标题与坐标轴标题是最简单的标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.34.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Matplotlib内置了一个简单快速的方法,可以用来创建图例,那就是plt. legend()。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.39.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在用面向对象接口画图时，不需要单独调用这些函数，通常采用ax.set()方法一次性设置所有的属性是更简便的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.41.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.41.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="简易散点图"><a href="#简易散点图" class="headerlink" title="简易散点图"></a>简易散点图</h1><p>另一种常用的图形是简易散点图( scatter plot),与线形图类似。这种图形不再由线段连接,而是由独立的点、圆圈或其他形状构成。开始的时候需要导入函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.43.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="用plt-plot画散点图"><a href="#用plt-plot画散点图" class="headerlink" title="用plt.plot画散点图"></a>用plt.plot画散点图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.45.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>函数的第三个参数是一个字符，表示图形符号的类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.47.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这些代码还可以与线条、颜色代码组合起来，画出一条连接散点的线。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.48.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.50.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="用plt-scatter画散点图"><a href="#用plt-scatter画散点图" class="headerlink" title="用plt.scatter画散点图"></a>用plt.scatter画散点图</h2><p>另一个可以创建散点图的函数是plt.scatter。它的功能非常强大其用法与plt.plot函数类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.52.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>plt scatter与p1t.plot的主要差别在于,前者在创建散点图时具有更高的灵活性,可以单独控制每个散点与数据匹配,也可以让每个散点具有不同的属性(大小、表面颜色、边框颜色、透明度等)。</p><h2 id="plot与scatter：效率对比"><a href="#plot与scatter：效率对比" class="headerlink" title="plot与scatter：效率对比"></a>plot与scatter：效率对比</h2><p>plt.plot与plt.scatter除了特征上的差异之外,还有什么影响我们选择的因素呢?在数据量较小的时候,两者在效率上的差异不大。但是当数据变大到几千个散点时,plt.plot的效率将大大高于plt.scatter。这是由于plt.scatter会对每个散点进行单独的大小与颜色的渲染,因此渲染器会消耗更多的资源。而在plt.plot中,散点基本都彼此复制,因此整个数据集中所有点的颜色、尺寸只需要配置一次。由于这两种方法在处理大型数据集时有很大的性能差异,因此面对大型数据集时,plt.plot方法比plt.scatter方法好。</p><h1 id="可视化异常处理"><a href="#可视化异常处理" class="headerlink" title="可视化异常处理"></a>可视化异常处理</h1><h2 id="基本误差线"><a href="#基本误差线" class="headerlink" title="基本误差线"></a>基本误差线</h2><p>基本误差线( errorbar)可以通过一个 Matplotlib函数来创建。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%8812.49.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%8812.50.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>除了这些选项之外,你还可以设置水平方向的误差线(xerr)、单侧误差线( one-sided errorbar),以及其他形式的误差线。</p><h2 id="连续误差"><a href="#连续误差" class="headerlink" title="连续误差"></a>连续误差</h2><h1 id="密度图与等高线图"><a href="#密度图与等高线图" class="headerlink" title="密度图与等高线图"></a>密度图与等高线图</h1><p>Matplotlib提供了三个函数来解决这个问题:用plt.contour画等高线图、用plt.contourf画带有填充色的等高线图( filled contour plot)的色彩、用plt.imshow显示图形。</p><h2 id="三维函数的可视化"><a href="#三维函数的可视化" class="headerlink" title="三维函数的可视化"></a>三维函数的可视化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.04.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.04.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当图形中只使用一种颜色时,默认使用虚线表示负数,使用实线表示正数。我们可以通过plt.contourf()函数来填充等高线图，它的语法和plt.contour()是一样的。</p><p>还可以通过plt. colorbar()命令自动创建一个表示图形各种颜色对应标签信息的颜色条。但是图形还有一点不尽如人意的地方,就是看起来有点儿“污渍斑斑“不是那么干净。这是由于颜色的改变是一个离散而非连续的过程,这并不是我们想要的效果。你当然可以通过将等高线的数量设置得非常多来解决这个问题,但是最终获得的图形性能会很不好,因为 Matplotlib必须渲染每一级的等高线。其实有更好的做法,那就是通过plt.imshow()函数来处理,它可以将二维数组渲染成渐变图。</p><p>使用imshow（）函数有一些注意事项。</p><ol><li>plt.imshow()不支持用x轴和y轴数据设置网格，而是必须通过extent参数设置图形的坐标范围[xmin,xmax,ymin,ymax]。</li><li>plt.imshow()默认使用标准的图形数组定义，就是原点位于左上角，而不是绝大多数等高线图中使用的左下角，这一点在显示网格数据图形时必须调整。</li><li>plt.imshow()会自动调整坐标轴的精度以适应数据显示。可以通过plt.axis(aspect=‘image’)来设置x轴与y轴的单位。</li></ol><h1 id="频次直方图、数据区间划分和分布密度"><a href="#频次直方图、数据区间划分和分布密度" class="headerlink" title="频次直方图、数据区间划分和分布密度"></a>频次直方图、数据区间划分和分布密度</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.38.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>hist()有许多用来调整计算过程和显示效果的选项。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.39.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>histtype=‘ stepfilled’与透明性设置参数 alpha搭配使用的效果:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.41.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.41.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="二维频次直方图与数据区间划分"><a href="#二维频次直方图与数据区间划分" class="headerlink" title="二维频次直方图与数据区间划分"></a>二维频次直方图与数据区间划分</h2><p>就像将一维数组分为区间创建一维频次直方图一样,我们也可以将二维数组按照二维区间进行切分,来创建二维频次直方图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.50.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="plt-hist2d-二维频次直方图"><a href="#plt-hist2d-二维频次直方图" class="headerlink" title="plt.hist2d:二维频次直方图"></a>plt.hist2d:二维频次直方图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.50.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>plt.hist2d类似的函数式np.histogram2d。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.51.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="plt-hexbin-六边形区间划分"><a href="#plt-hexbin-六边形区间划分" class="headerlink" title="plt.hexbin:六边形区间划分"></a>plt.hexbin:六边形区间划分</h3><p>二维频次直方图是由于坐标轴正交的方块分割而成的，还有一种常用的方式是用正六边形分割。Matplotlib提供的plt.hexbin满足此类需求，将二维数据集分割成蜂窝状。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.02.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a>核密度估计</h3><p>有一种评估多维数据分布密度的常用方法是核密度估计KDE。KDE方法通过不同的平滑带宽长度( smoothing length)在拟合函数的准确性与平滑性之间作出权衡(无处不在的偏差与方差的取舍问题的一个例子)。想找到恰当的平滑带宽长度是件很困难的事, gaussian_kde通过一种经验方法试图找到输入数据平滑长度的近似最优解。</p><h1 id="配置图例"><a href="#配置图例" class="headerlink" title="配置图例"></a>配置图例</h1><p>设置图例的位置，并取消外框。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.11.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以用ncol参数设置图例的标签列数。还可以为图例定义圆角边框( fancybox)、增加阴影、改变外边框透明度( framealpha值),或者改变文字间距。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.13.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="选择图例显示的元素"><a href="#选择图例显示的元素" class="headerlink" title="选择图例显示的元素"></a>选择图例显示的元素</h2><p>图例会默认显示所有元素的标签。如果你不想显示全部,可以通过一些图形命令来指定显示图例中的哪些元素和标签。plt.plot()命令可以一次创建多条线,返回线条实例列表。一种方法是将需要显示的线条传入plt.legend(),另一种方法是只为需要在图例中显示的线条设置标签。默认情况下图例会忽略那些不带标签的元素。</p><h2 id="在图例中显示不同尺寸的点"><a href="#在图例中显示不同尺寸的点" class="headerlink" title="在图例中显示不同尺寸的点"></a>在图例中显示不同尺寸的点</h2><h2 id="同时显示多个图例"><a href="#同时显示多个图例" class="headerlink" title="同时显示多个图例"></a>同时显示多个图例</h2><p>我们可以通过从头开始创建一个图例艺术家对象（legend artist），然后用底层的（lower-level）ax.add_artiest()方法在图上添加第二个图例。</p><h1 id="配置颜色条"><a href="#配置颜色条" class="headerlink" title="配置颜色条"></a>配置颜色条</h1><p>在Matplotlib中，颜色条是一个独立的坐标轴，可以指明图形中颜色的含义。</p><h2 id="配置颜色条-1"><a href="#配置颜色条-1" class="headerlink" title="配置颜色条"></a>配置颜色条</h2><p>可以通过cmap参数为图形设置颜色条的配色方案。</p><h3 id="选择配色方案"><a href="#选择配色方案" class="headerlink" title="选择配色方案"></a>选择配色方案</h3><h4 id="顺序配色方案"><a href="#顺序配色方案" class="headerlink" title="顺序配色方案"></a>顺序配色方案</h4><p>由一组连续的颜色构成的配色方案(例如 binary或viridis)。</p><h4 id="互逆配色方案"><a href="#互逆配色方案" class="headerlink" title="互逆配色方案"></a>互逆配色方案</h4><p>通常由两种互补的颜色构成,表示正反两种含义(例如RdBu或PuOr)。</p><h4 id="定性配色方案"><a href="#定性配色方案" class="headerlink" title="定性配色方案"></a>定性配色方案</h4><p>随机顺序的一组颜色(例如 rainbow或jet)。</p><h3 id="颜色条刻度的限制与扩展功能的设置"><a href="#颜色条刻度的限制与扩展功能的设置" class="headerlink" title="颜色条刻度的限制与扩展功能的设置"></a>颜色条刻度的限制与扩展功能的设置</h3><p>Matplotlib提供了丰富的颜色条配置功能。由于可以将颜色条本身仅看作是一个plt.Axes实例,因此前面所学的所有关于坐标轴和刻度值的格式配置技巧都可以派上用场。</p><h3 id="离散型颜色条"><a href="#离散型颜色条" class="headerlink" title="离散型颜色条"></a>离散型颜色条</h3><p>虽然颜色条默认都是连续的,但有时你可能也需要表示离散数据。最简单的做法就是使用plt.cm.get_cmap()函数,将适当的配色方案的名称以及需要的区间数量传进去即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.54.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="多子图"><a href="#多子图" class="headerlink" title="多子图"></a>多子图</h1><h2 id="plt-axes-手动创建子图"><a href="#plt-axes-手动创建子图" class="headerlink" title="plt.axes:手动创建子图"></a>plt.axes:手动创建子图</h2><p>创建坐标轴最基本的方法就是使用p1t.axes函数。前面已经介绍过,这个函数的默认配置是创建一个标准的坐标轴,填满整张图。它还有个可选参数,由图形坐标系统的四个值构成。这四个值分别表示图形坐标系统的[bottom,Left, width, height](底坐标、左坐标、宽度、高度),数值的取值范围是左下角(原点)为0,右上角为1。</p><p>如果想要在右上角创建一个画中画,那么可以首先将x与y设置为0.65(就是坐标轴原点位于图形高度65%和宽度65%的位置),然后将x与y扩展到0,2(也就是将坐标轴的宽度与高度设置为图形的20%)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%883.00.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%883.00.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>面向对象画图接口中类似的命令有fig.add_axes()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.12.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="plt-subplot-简易网格子图"><a href="#plt-subplot-简易网格子图" class="headerlink" title="plt.subplot:简易网格子图"></a>plt.subplot:简易网格子图</h2><p>最底层的方法是用plt.subplot()在一个网格中创建一个子图。这个命令有三个整型参数—将要创建的网格子图行数、列数和索引值,索引值从1开始,从左上角到右下角依次增大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.17.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>plt.subplots_adjust命令可以调整子图之间的间隔。用面向对象接口的命令fig.ad_subplot()可以取得同样的效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.20.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="plt-subplots-用一行代码创建网格"><a href="#plt-subplots-用一行代码创建网格" class="headerlink" title="plt.subplots:用一行代码创建网格"></a>plt.subplots:用一行代码创建网格</h2><p>想隐藏内部子图的x轴与y轴标题时。出于这一需求,plt.subplots()实现了你想要的功能(需要注意此处 subplots结尾多了个s)。这个函数不是用来创建单个子图的,而是用一行代码创建多个子图,并返回一个包含子图的 NumPy数组。关键参数是行数与列数,以及可选参数 sharex与 sharey,通过它们可以设置不同子图之间的关联关系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.27.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>设置 sharex与 sharey参数之后,我们就可以自动去掉网格内部子图的标签,让图形看起来更整洁。坐标轴实例网格的返回结果是一个NumPy数组,这样就可以通过标准的数组取值方式轻松获取想要的坐标轴了。</p><p>与plt.subplot()相比,p1t. subplots()与 Python索引从0开始的习惯保持一致。</p><h2 id="plt-Gridspec-实现更复杂的排列方式"><a href="#plt-Gridspec-实现更复杂的排列方式" class="headerlink" title="plt.Gridspec:实现更复杂的排列方式"></a>plt.Gridspec:实现更复杂的排列方式</h2><p>如果想实现不规则的多行多列子图网格,plt. Gridspec()是最好的工具。plt.Gridspec()对象本身不能直接创建一个图形,它只是plt.subplot()命令可以识别的简易接口。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.32.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.32.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.32.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="文字与注释"><a href="#文字与注释" class="headerlink" title="文字与注释"></a>文字与注释</h1><h2 id="坐标变换与文字位置"><a href="#坐标变换与文字位置" class="headerlink" title="坐标变换与文字位置"></a>坐标变换与文字位置</h2><ol><li>ax.transData，以数据为基准的坐标变换。</li><li>ax.transAxes，以坐标轴为基准的坐标变换（以坐标轴维度为单位）。</li><li>fig.transFigure，以图形为基准的坐标变换（以图形维度为单位）。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>transData坐标用x轴与y轴的标签作为数据坐标。 transAxes坐标以坐标轴(图中白色矩形)左下角的位置为原点,按坐标轴尺寸的比例呈现坐标。 trans Figure坐标与之类似,不过是以图形(图中灰色矩形)左下角的位置为原点,按图形尺寸的比例呈现坐标。</p><h2 id="箭头与注释"><a href="#箭头与注释" class="headerlink" title="箭头与注释"></a>箭头与注释</h2><p>在 Matplotlib里面画箭头通常比你想象的要困难。虽然有一个plt.arrow()函数可以实现这个功能,但是我不推荐使用它,因为它创建出的箭头是SvG向量图对象,会随着图形分辨率的变化而改变,最终的结果可能完全不是用户想要的。我要推荐的是plt.annotate()函数。这个函数既可以创建文字,也可以创建箭头,而且它创建的箭头能够进行非常灵活的配置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.21.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>箭头的风格是通过arrowprops字典控制的。</p><h1 id="自定义坐标轴刻度"><a href="#自定义坐标轴刻度" class="headerlink" title="自定义坐标轴刻度"></a>自定义坐标轴刻度</h1><p>在介绍示例之前,我们最好先对 Matplotlib图形的对象层级有更深入的理解。 Matplotlib的目标是用 Python对象表现任意图形元素。例如,figure对象其实就是一个盛放图形元素的包围盒( bounding box)。可以将每个 Matplotlib对象都看成是子对象(sub-object)的容器,例如每个 figure都会包含一个或多个axes对象,每个aXes对象又会包含其他表示图形内容的对象。</p><p>坐标轴刻度线也不例外。每个axeS都有 axis和 yaxis属性,每个属性同样包含构成坐标轴的线条、刻度和标签的全部属性。</p><h2 id="主要刻度与次要刻度"><a href="#主要刻度与次要刻度" class="headerlink" title="主要刻度与次要刻度"></a>主要刻度与次要刻度</h2><p>我们发现每个主要刻度都显示为一个较大的刻度线和标签,而次要刻度都显示为一个较小的刻度线,且不显示标签。</p><p>可以通过设置每个坐标轴的 formatter与 locator对象,自定义这些刻度属性(包括刻度线的位置和标签)。</p><p>主要刻度标签和次要刻度标签的位置都是通过一个LogLocator对象(在对数图中可以看到)设置的。然而,次要刻度有个NullFormatter对象处理标签,这样标签就不会在图上显示了。</p><h2 id="隐藏刻度与标签"><a href="#隐藏刻度与标签" class="headerlink" title="隐藏刻度与标签"></a>隐藏刻度与标签</h2><p>最常用的刻度/标签格式化操作可能就是隐藏刻度与标签了,可以通过plt. NullLocator()与plt.NullFormatter()实现。</p><h2 id="增减刻度数量"><a href="#增减刻度数量" class="headerlink" title="增减刻度数量"></a>增减刻度数量</h2><p>默认刻度标签有一个问题,就是显示较小图形时,通常刻度显得十分拥挤。数字几乎都重叠在一起,辨识起来非常困难。我们可以用plt. MaxNLocator()来解决这个问题,通过它可以设置最多需要显示多少刻度。根据设置的最多刻度数量, Matplotlib会自动为刻度安排恰当的位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.36.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="花哨的刻度格式"><a href="#花哨的刻度格式" class="headerlink" title="花哨的刻度格式"></a>花哨的刻度格式</h2><p>可以通过设置一个MultipleLocator来实现将刻度放在你提供的数值的倍数上。让图形会更加自然。</p><h2 id="格式生成器与定位器小结"><a href="#格式生成器与定位器小结" class="headerlink" title="格式生成器与定位器小结"></a>格式生成器与定位器小结</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.42.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.43.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.43.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.43.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Matplotlib自定义：配置文件与样式表"><a href="#Matplotlib自定义：配置文件与样式表" class="headerlink" title="Matplotlib自定义：配置文件与样式表"></a>Matplotlib自定义：配置文件与样式表</h1><h2 id="手动配置图形"><a href="#手动配置图形" class="headerlink" title="手动配置图形"></a>手动配置图形</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.45.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.45.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次都要手动配置一番太麻烦了，可以配置一次默认图形将其应用到所有图形上。</p><h2 id="修改默认配置：rcParams"><a href="#修改默认配置：rcParams" class="headerlink" title="修改默认配置：rcParams"></a>修改默认配置：rcParams</h2><p>Matplotlib每次加载时,都会定义一个运行时配置(rc),其中包含了所有你创建的图形元素的默认风格。你可以用plt.rc简便方法随时修改这个配置。</p><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><h3 id="默认风格"><a href="#默认风格" class="headerlink" title="默认风格"></a>默认风格</h3><h3 id="FiveThirtyEight风格"><a href="#FiveThirtyEight风格" class="headerlink" title="FiveThirtyEight风格"></a>FiveThirtyEight风格</h3><h3 id="ggplot风格"><a href="#ggplot风格" class="headerlink" title="ggplot风格"></a>ggplot风格</h3><h3 id="bmh风格"><a href="#bmh风格" class="headerlink" title="bmh风格"></a>bmh风格</h3><h3 id="黑色背景风格"><a href="#黑色背景风格" class="headerlink" title="黑色背景风格"></a>黑色背景风格</h3><h3 id="灰度风格"><a href="#灰度风格" class="headerlink" title="灰度风格"></a>灰度风格</h3><h3 id="Seaborn风格"><a href="#Seaborn风格" class="headerlink" title="Seaborn风格"></a>Seaborn风格</h3><h1 id="用Matplotlib画三维图"><a href="#用Matplotlib画三维图" class="headerlink" title="用Matplotlib画三维图"></a>用Matplotlib画三维图</h1><p>我们可以导入 Matplotlib自带的plot3d工具箱来画三维图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.53.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>导入这个子模块之后,就可以在创建任意一个普通坐标轴的过程中加入projection=‘3d’关键字,从而创建一个三维坐标轴。</p><h2 id="三维数据点与线"><a href="#三维数据点与线" class="headerlink" title="三维数据点与线"></a>三维数据点与线</h2><p>最基本的三维图是由(x,y,z)三维坐标点构成的线图与散点图。与前面介绍的普通二维图类似,可以用 ax.plot3D与ax.scatter3D函数来创建它们。三维图函数的参数与前面二维图函数的参数基本相同。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.57.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>默认情况下，散点会自动改变透明度，以在平面上呈现出立体感。</p><h2 id="三维等高线"><a href="#三维等高线" class="headerlink" title="三维等高线"></a>三维等高线</h2><p>与之前的等高线类似,mplot3d也有用同样的输入数据创建三维晕渲( relief)图的工具。与二维ax.contour图形一样,ax.contour3D要求所有数据都是二维网格数据的形式,并且由函数计算z轴数值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.02.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="线框图和曲面图"><a href="#线框图和曲面图" class="headerlink" title="线框图和曲面图"></a>线框图和曲面图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.04.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.04.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>曲面图与线框图类似,只不过线框图的每个面都是由多边形构成的。只要增加一个配色方案来填充这些多边形。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.05.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>画曲面图需要二维数据,但可以不是直角坐标系(也可以用极坐标)。</p><h2 id="曲面三角剖分"><a href="#曲面三角剖分" class="headerlink" title="曲面三角剖分"></a>曲面三角剖分</h2><h1 id="用Basemap可视化地理数据"><a href="#用Basemap可视化地理数据" class="headerlink" title="用Basemap可视化地理数据"></a>用Basemap可视化地理数据</h1><p>地理数据可视化是数据科学中一种十分常见的可视化类型。 Matplotlib做此类可视化的主要工具是 Basemap工具箱。</p><p>安装并导入 Basemap工具箱后,只用几行代码就可以画出地理图形。</p><h1 id="用Seaborn做数据可视化"><a href="#用Seaborn做数据可视化" class="headerlink" title="用Seaborn做数据可视化"></a>用Seaborn做数据可视化</h1><p>虽然 Matplotlib已经证明了自己绝对是一款超级实用且流行的数据可视化工具,但是即使骨灰粉也不得不承认它不支持的功能还有很多。</p><p>Seaborn在Matplotlib的基础上开发了一套API,为默认的图形样式和颜色设置提供了理智的选择,为常用的统计图形定义了许多简单的高级函数,并与Pandas dataFrame的功能有机结合。</p><h2 id="Seaborn与Matplotlib"><a href="#Seaborn与Matplotlib" class="headerlink" title="Seaborn与Matplotlib"></a>Seaborn与Matplotlib</h2><p>Seaborn不仅有许多高级的画图功能,而且可以改写 Matplotlib的默认参数,从而用简单的Matplotlib脚本获得更好的效果。可以用 Seaborn的set()方法设置样式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.54.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.54.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.55.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.55.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Seaborn图形介绍"><a href="#Seaborn图形介绍" class="headerlink" title="Seaborn图形介绍"></a>Seaborn图形介绍</h2><h3 id="频次直方图、KDE和密度图"><a href="#频次直方图、KDE和密度图" class="headerlink" title="频次直方图、KDE和密度图"></a>频次直方图、KDE和密度图</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Matplotlib是建立在 NumPy数组基础上的多平台数据可视化程序库。&lt;/p&gt;
&lt;p&gt;Matplotlib最重要的特性之一就是具有良好的操作系统兼容性和图形显示底层接口兼容性( graphics backend)。 Matplotlib支持几十种图形显示接口与输出格式
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据科学手册 Pandas数据处理</title>
    <link href="https://github.com/zdkswd/2018/10/31/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/10/31/Python数据科学手册 Pandas数据处理/</id>
    <published>2018-10-31T13:00:56.000Z</published>
    <updated>2018-10-31T13:07:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas是在NumPy基础上建立的新程序库,提供了一种高效的 DataFrame数据结构。 DataFrame本质上是一种带行标签和列标签、支持相同类型数据和缺失值的多维数组。 Pandas不仅为带各种标签的数据提供了便利的存储界面,还实现了许多强大的操作,这些操作对数据库框架和电子表格程序的用户来说非常熟悉。</p><p>建立在NumPy数组结构上的 Pandas,尤其是它的 Series和 DataFrame对象,为数据科学家们处理那些消耗大量时间的“数据清理”(data munging)任务提供了捷径。</p><h1 id="安装并使用Pandas"><a href="#安装并使用Pandas" class="headerlink" title="安装并使用Pandas"></a>安装并使用Pandas</h1><p>在安装Pandas之前，确保操作系统中有NumPy。</p><h1 id="Pandas对象简介"><a href="#Pandas对象简介" class="headerlink" title="Pandas对象简介"></a>Pandas对象简介</h1><p>如果从底层视角观察Pandas对象，可以把它们看成增强版的NumPy结构化数组，行列都不再只是简单的整数索引，还可以带上标签。Pandas的三个基本数据结构：Series、DataFrame和Index。</p><h2 id="Pandas的Series对象"><a href="#Pandas的Series对象" class="headerlink" title="Pandas的Series对象"></a>Pandas的Series对象</h2><p>Pandas的 Series对象是一个带索引数据构成的一维数组。可以用一个数组创建 Series对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%888.45.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从上面的结果中,你会发现 Series对象将一组数据和一组索引绑定在一起,我们可以通过 values属性和 index属性获取数据。 values属性返回的结果与 NumPy数组类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.33.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>index属性返回的结果是一个类型为pd. Index的类数组对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.34.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>和 NumPy数组一样,数据可以通过 Python的中括号索引标签获取。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.35.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Pandas的 Series对象比它模仿的一维 NumPy数组更加通用、灵活。</p><h3 id="Serise是通用的-NumPy数组"><a href="#Serise是通用的-NumPy数组" class="headerlink" title="Serise是通用的 NumPy数组"></a>Serise是通用的 NumPy数组</h3><p>Series对象和一维 NumPy数组两者间的本质差异其实是索引: NumPy数组通<br>过隐式定义的整数索引获取数值,而 Pandas的 Series对象用一种显式定义的索引与数值关联。显式索引的定义让 Series对象拥有了更强的能力。例如,索引不<br>再仅仅是整数,还可以是任意想要的类型。如果需要,完全可以用字符串定义索引。也可以使用不连续或不按顺序的索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.39.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.40.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Series是特殊的字典"><a href="#Series是特殊的字典" class="headerlink" title="Series是特殊的字典"></a>Series是特殊的字典</h3><p>可以把 Pandas的 Series对象看成一种特殊的 Python字典。字典是一种将任意键映射到一组任意值的数据结构,而 Series对象其实是一种将类型键映射到一组类型值的数据结构。类型至关重要:就像 NumPy数组背后特定类型的经过编译的代码使得它在某些操作上比普通的 Python列表更加高效一样, Pandas series的类型信息使得它在某些操作上比 Python的字典更高效。用字典创建 Series对象时,其索引默认按照顺序排列。典型的字典数值获取方式仍然有效。和字典不同, Series对象还支持数组形式的操作,比如切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.45.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="创建Series对象"><a href="#创建Series对象" class="headerlink" title="创建Series对象"></a>创建Series对象</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.06.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中，index是一个可选参数，data参数支持多种数据类型。data可以是列表或 NumPy数组,这时 index默认值为整数序列，data也可以是一个标量,创建 Series对象时会重复填充到每个索引上。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.08.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>data还可以是一个字典，index默认是排序的字典键。每一种形式都可以通过显式指定索引筛选需要的结果，这里需要注意的是, Series对象只会保留显式定义的键值对。</p><h2 id="Pandas的-DataFrame对象"><a href="#Pandas的-DataFrame对象" class="headerlink" title="Pandas的 DataFrame对象"></a>Pandas的 DataFrame对象</h2><p>DataFrame既可以作为一个通用型 NumPy数组,也可以看作特殊的 Python字典。</p><h3 id="Dataframe是通用的-NumPy数组"><a href="#Dataframe是通用的-NumPy数组" class="headerlink" title="Dataframe是通用的 NumPy数组"></a>Dataframe是通用的 NumPy数组</h3><p>把 DataFrame看成是有序排列的若干 Series对象。这里的“排<br>列指的是它们拥有共同的索引。</p><p>再结合之前创建的 population的 Series对象,用一个字典创建<br>个包含这些信息的二维对象<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.36.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.36.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>和 Series对象一样, DataFrame也有一个 index属性可以获取索引标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.37.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另外, DataFrame还有一个 columns属性,是存放列标签的Index对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.05.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> Dataframe可以看作一种通用的 NumPy二维数组,它的行与列都可以通过索引获取。</p><h3 id="DataFrame是特殊的字典"><a href="#DataFrame是特殊的字典" class="headerlink" title="DataFrame是特殊的字典"></a>DataFrame是特殊的字典</h3><p>与 Series类似,我们也可以把 DataFrame看成一种特殊的字典。字典是一个键映射一个值,而 DataFrame是一列映射一个Series的数据。例如,通过’area’的列属性可以返回包含面积数据的Series对象。</p><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><h4 id="通过单个Series对象创建"><a href="#通过单个Series对象创建" class="headerlink" title="通过单个Series对象创建"></a>通过单个Series对象创建</h4><p>DataFrame是一组 Series对象的集合,可以用单个 Series创建一个单列的 Dataframe。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.15.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="通过字典列表创建"><a href="#通过字典列表创建" class="headerlink" title="通过字典列表创建"></a>通过字典列表创建</h4><p>任何元素是字典的列表都可以变成DataFrame。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即使字典中有些键不存在, Pandas也会用缺失值NaN(不是数字,not a number)来表示。</p><h4 id="通过Series对象字典创建"><a href="#通过Series对象字典创建" class="headerlink" title="通过Series对象字典创建"></a>通过Series对象字典创建</h4><p>DataFrame也可以用一个由 Series对象构成的字典创建。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.24.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="通过NumPy二维数组创建"><a href="#通过NumPy二维数组创建" class="headerlink" title="通过NumPy二维数组创建"></a>通过NumPy二维数组创建</h4><p>假如有一个二维数组,就可以创建个可以指定行列索引值的 DataFrame。如果不指定行列索引值那么行列默认都是整数索引值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.28.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="通过NumPy结构化数组创建"><a href="#通过NumPy结构化数组创建" class="headerlink" title="通过NumPy结构化数组创建"></a>通过NumPy结构化数组创建</h4><p>由于 Pandas的 DataFrame与结构化数组十分相似,因此可以通过结<br>构化数组创建 Dataframe。</p><h2 id="Pandas的Index对象"><a href="#Pandas的Index对象" class="headerlink" title="Pandas的Index对象"></a>Pandas的Index对象</h2><p>Series和 DataFrame对象都使用便于引用和调整的显式索引。 Pandas的 Index对象是一个很有趣的数据结构,可以将它看作是一个不可变数组或有序集合(实际上是一个多集,因为 Index对象可能会包含重复值)。这两种观点使得 Index对象能呈现一些有趣的功能。让我们用一个简单的整数列表来创建一个 Index对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.36.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="将Index看作不可变数组"><a href="#将Index看作不可变数组" class="headerlink" title="将Index看作不可变数组"></a>将Index看作不可变数组</h3><p>Index对象的许多操作都像数组。例如,可以通过标准 Python的取值方法获取数值,也可以通过切片获取数值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.38.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Index对象与 NumPy数组之间的不同在于, Index对象的索引是不可变的,也就是说不能通过通常的方式进行调整。Index对象的不可变特征使得多个DataFrame和数组之间进行索引共享时更加安全,尤其是可以避免因修改索引时粗心大意而导致的副作用。</p><h3 id="将Index看作有序集合"><a href="#将Index看作有序集合" class="headerlink" title="将Index看作有序集合"></a>将Index看作有序集合</h3><p>Pandas对象被设计用于实现许多操作,如连接(join)数据集,其中会涉及许多集合操作。Index对象遵循 Python标准库的集合(set)数据结构的许多习惯用法,包括并集、交集、差集等。</p><h1 id="数据取值与选择"><a href="#数据取值与选择" class="headerlink" title="数据取值与选择"></a>数据取值与选择</h1><h2 id="Series数据选择方法"><a href="#Series数据选择方法" class="headerlink" title="Series数据选择方法"></a>Series数据选择方法</h2><h3 id="将-Series看作字典"><a href="#将-Series看作字典" class="headerlink" title="将 Series看作字典"></a>将 Series看作字典</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.46.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们还可以用 Python字典的表达式和方法来检测键/索引和值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.49.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Series对象还可以用字典语法调整数据。就像你可以通过增加新的键扩展字典一样,你也可以通过增加新的索引值扩展 Series。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.50.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Series对象的可变性是一个非常方便的特性: Pandas在底层已经为可能发生的内存布局和数据复制自动决策,用户不需要担心这些问题。</p><h3 id="将-Series看作一维数组"><a href="#将-Series看作一维数组" class="headerlink" title="将 Series看作一维数组"></a>将 Series看作一维数组</h3><p>Series不仅有着和字典一样的接口,而且还具备和 NumPy数组一样的数组数据选择功能,包括索引、掩码、花哨的索引等操作。切片是绝大部分混乱之源。需要注意的是,当使用显式索引(即data[‘a’:’c’])作切片时,结果包含最后一个索引;而当使用隐式索引(即data[0:2])作切片时,结果不包含最后一个索引。</p><h3 id="索引器：loc、iloc和ix"><a href="#索引器：loc、iloc和ix" class="headerlink" title="索引器：loc、iloc和ix"></a>索引器：loc、iloc和ix</h3><p>这些切片和取值的习惯用法经常会造成混乱。例如,如果你的Series是显式整数索引,那么data[1]这样的取值操作会使用显式索引,而data[1:3]这样的切片操作却会使用隐式索引。由于整数索引很容易造成混淆,所以 Pandas提供了一些索引器( indexer)属性来作为取值的方法。它们不是 Series对象的函数方法,而是暴露切片接口的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.00.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.01.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即从0开始，左闭右开区间。<br>第三种取值属性是ix,它是前两种索引器的混合形式,在 Series对象中ix等价于标准的<a href="Python列表"></a>取值方式。ix索引器主要用于DataFrame对象。</p><p>Python代码的设计原则之一是“显式优于隐式”。使用loc和iloc可以让代码更容易维护,可读性更高。特别是在处理整数索引的对象时,强烈推荐使用这两种索引器。它们既可以让代码阅读和理解起来更容易,也能避免因误用索引/切片而产生的小bug。</p><h2 id="DataFrame数据选择方法"><a href="#DataFrame数据选择方法" class="headerlink" title="DataFrame数据选择方法"></a>DataFrame数据选择方法</h2><p>Dataframe在有些方面像二维或结构化数组,在有些方面又像一个共享索引的若干 Series对象构成的字典。</p><h3 id="将-Dataframe看作字典"><a href="#将-Dataframe看作字典" class="headerlink" title="将 Dataframe看作字典"></a>将 Dataframe看作字典</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.20.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>两个 Series分别构成 Dataframe的一列,可以通过对列名进行字典形式( dictionary- style)的取值获取数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然属性形式的数据选择方法很方便,但是它并不是通用的。如果列名不是纯字符串,或者列名与 DataFrame的方法同名,那么就不能用属性索引。例如, Dataframe有一个pop()方法,如果用data.pop就不会获取’pop’列,而是显示为方法。另外,还应该避免对用属性形式选择的列直接赋值(即可以用data[‘pop’]=z,但不要用data.pop=z)。</p><h3 id="将DataFrame看作二维数组"><a href="#将DataFrame看作二维数组" class="headerlink" title="将DataFrame看作二维数组"></a>将DataFrame看作二维数组</h3><p>可以把 Dataframe看成是一个增强版的二维数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.29.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>理解了这一点,就可以把许多数组操作方式用在 DataFrame上。例如,可以对 DataFrame进行行列转置。<br>获取一行数据时。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>获取一列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.39.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在进行数组形式的取值时，我们就需要用另一种方法。loc、iloc和ix。通过iloc索引器，我们就可以像对待NumPy数组一样索引Pandas的底层数组（Python的隐式索引）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.44.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用ix索引器可以实现一种混合效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.46.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是,ix索引器对于整数索引的处理和之前在 Series对象中介绍的一样,都容易让人混淆。任何用于处理 NumPy形式数据的方法都可以用于这些索引器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.51.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="其他取值方法"><a href="#其他取值方法" class="headerlink" title="其他取值方法"></a>其他取值方法</h3><p>还有一些取值方法看着有点奇怪，但在实践中还是好用。首先，如果对单个标签取值就选择列，而对多个标签用切边就选择行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%887.01.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>切片也可以不用索引值，而直接用行数来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%887.02.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与此类似，掩码操作也可以直接对每一行进行过滤，而不需要使用loc索引器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.12.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Pandas数值运算方法"><a href="#Pandas数值运算方法" class="headerlink" title="Pandas数值运算方法"></a>Pandas数值运算方法</h1><p>NumPy的基本能力之一是快速对每个元素进行运算,既包括基本算术运算(加、减、乘、除),也包括更复杂的运算(三角函数、指数函数和对数函数等)。 Pandas继承了 NumPy的功能,通用函数是关键。</p><h2 id="通用函数：保留索引"><a href="#通用函数：保留索引" class="headerlink" title="通用函数：保留索引"></a>通用函数：保留索引</h2><p>因为 Pandas是建立在 NumPy基础之上的,所以 NumPy的通用函数同样适用于 Pandas的 Series和 DataFrame对象。</p><h2 id="通用函数：索引对齐"><a href="#通用函数：索引对齐" class="headerlink" title="通用函数：索引对齐"></a>通用函数：索引对齐</h2><p>当在两个 Series或 DataFrame对象上进行二元计算时, Pandas会在计算过程中对齐两个对象的索引。</p><h3 id="Series索引对齐"><a href="#Series索引对齐" class="headerlink" title="Series索引对齐"></a>Series索引对齐</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.25.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于缺失位置的数据, Pandas会用NaN填充,表示“此处无数”。这种索引对齐方式是通过 Python内置的集合运算规则实现的,任何缺失值默认都用NaN填充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.29.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果用NaN值不是我们想要的结果,那么可以用适当的对象方法代替运算符。例如，A.add(B)等价于A+B，也可以设置参数自定义A或B缺失的数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.31.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="DataFrame索引对齐"><a href="#DataFrame索引对齐" class="headerlink" title="DataFrame索引对齐"></a>DataFrame索引对齐</h3><p>在计算两个 DataFrame时,类似的索引对齐规则也同样会出现在共同(并集)列中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.42.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>你会发现,两个对象的行列索引可以是不同顺序的,结果的索引会自动按顺序排列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.45.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="通用函数-DataFrame与-Series的运算"><a href="#通用函数-DataFrame与-Series的运算" class="headerlink" title="通用函数: DataFrame与 Series的运算"></a>通用函数: DataFrame与 Series的运算</h2><p>对一个 DataFrame和一个 Series进行计算,行列对齐方式与之前类似。也就是说, DataFrame和 Series的运算规则,与NumPy中二维数组与一维数组的运算规则是一样的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.11.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.11.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>根据 NumPy的广播规则，让二维数组减自身的行数据会按行计算。在 Pandas里默认也是按行运算的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.13.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果你想按列计算,那么就需要利用前面介绍过的运算符方法,通过axis参数设置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.16.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h1><p>大多数教程里使用的数据与现实工作中的数据的区别在于后者很少是干净整齐的,许多目前流行的数据集都会有数据缺失的现象。更为甚者处理不同数据源缺失值的方法还不同。</p><h2 id="选择处理缺失值的方法"><a href="#选择处理缺失值的方法" class="headerlink" title="选择处理缺失值的方法"></a>选择处理缺失值的方法</h2><p>在数据表或 DataFrame中有很多识别缺失值的方法。一般情况下可以分为两种:一种方法是通过一个覆盖全局的掩码表示缺失值,另一种方法是用一个标签值( sentinel value)表示缺失值。在掩码方法中,掩码可能是一个与原数组维度相同的完整布尔类型数组,也可能是用一个比特(0或1)表示有缺失值的局部状态。在标签方法中,标签值可能是具体的数据(例如用9999表示缺失的整数),也可能是些极少出现的形式。另外,标签值还可能是更全局的值,比如用NaN(不是一个数)表示缺失的浮点数,它是IEEE浮点数规范中指定的特殊字符。</p><p>使用这两种方法之前都需要先综合考量:使用单独的掩码数组会额外出现一个布尔类型数组,从而增加存储与计算的负担;而标签值方法缩小了可以被表示为有效值的范围,可能需要在CPU或GPU算术逻辑单元中增加额外的(往往也不是最优的)计算逻辑。通常使用的NaN也不能表示所有数据类型。</p><p>大多数情况下,都不存在最佳选择,不同的编程语言与系统使用不同的方法。</p><h2 id="Pandas的缺失值"><a href="#Pandas的缺失值" class="headerlink" title="Pandas的缺失值"></a>Pandas的缺失值</h2><p>Pandas里处理缺失值的方式延续了 NumPy程序包的方式,并没有为浮点数据类型提供内置的NA作为缺失值。</p><p>Pandas原本也可以按照R语言采用的比特模式为每一种数据类型标注缺失值，但是这种方法非常笨拙。其工作量几乎相当于创建一个新的NumPy程序包。另外，对于一些较小的数据类型，牺牲一个比特作为缺失值标注的掩码还会导致其数据范围缩小。当然, NumPy也是支持掩码数据的,也就是说可以用一个布尔掩码数组为原数组标注“无缺失值”或“有缺失值”。 Pandas也集成了这个功能,<br>但是在存储、计算和编码维护方面都需要耗费不必要的资源,因此这种方式并不可取。</p><p>综合考虑各种方法的优缺点, Pandas最终选择用标签方法表示缺失值,包括两种 Python原有的缺失值:浮点数据类型的NaN值,以及 Python的None对象。后面我们将会发现,虽然这么做也会有一些副作用,但是在实际运用中的效果还是不错的。</p><h3 id="None：Python对象类型的缺失值"><a href="#None：Python对象类型的缺失值" class="headerlink" title="None：Python对象类型的缺失值"></a>None：Python对象类型的缺失值</h3><p>Pandas可以使用的第一种缺失值标签是None,它是一个 Python单体对象,经常在代码中表示缺失值。由于None是一个 Python对象,所以不能作为任何 NumPy/ Pandas数组类型的缺失值,只能用于object数组类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.42.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里 dtype= object表示 NumPy认为由于这个数组是 Python对象构成的,因此将其类型判断为 object。虽然这种类型在某些情景中非常有用,对数据的任何操作最终都会在 Python层面完成,但是在进行常见的快速操作时,这种类型比其他原生类型数组要消耗更多的资源。</p><p>使用 Python对象构成的数组就意味着如果你对一个包含None的数组进行累计操作,如sum()或者min(),那么通常会出现类型错误。这就是说,在 Python中没有定义整数与None之间的加法运算。</p><h3 id="NaN-数值类型的缺失值"><a href="#NaN-数值类型的缺失值" class="headerlink" title="NaN:数值类型的缺失值"></a>NaN:数值类型的缺失值</h3><p>另一种缺失值的标签是NaN(全称 Not a number,不是一个数字),是一种按照IEEE浮点数标准设计、在任何系统中都兼容的特殊浮点数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.47.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>NumPy会为这个数组选择一个原生浮点类型,这意味着和之前的 object类型数组不同,这个数组会被编译成C代码从而实现快速操作。你可以把NaN看作是一个数据类病毒它会将与它接触过的数据同化。无论和NaN进行何种操作,最终结果都是NaN。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.48.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>NumPy也提供了一些特殊的累计函数,它们可以忽略缺失值的影响。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.49.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>谨记,NaN是一种特殊的浮点数,不是整数、字符串以及其他数据类型。</p><h3 id="Pandas中NaN与None的差异"><a href="#Pandas中NaN与None的差异" class="headerlink" title="Pandas中NaN与None的差异"></a>Pandas中NaN与None的差异</h3><p>虽然NaN与None各有各的用处,但是 Pandas把它们看成是可以等价交换的,在适当的时候会将两者进行替换。</p><p>Pandas会将没有标签值的数据类型自动转换为NA。例如,当我们将整型数组中的一个值设置为np.nan时,这个值就会强制转换成浮点数缺失值NA。除了将整型数组的缺失值强制转换为浮点数, Pandas还会自动将None转换为NaN。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.36.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是, Pandas中字符串类型的数据通常是用 object类型存储的。</p><h2 id="处理缺失值-1"><a href="#处理缺失值-1" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><p>Pandas基本上把None和NaN看成是可以等价交换的缺失值形式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.40.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>返回一个填充看缺失值的数据副本。</p><h3 id="发现缺失值"><a href="#发现缺失值" class="headerlink" title="发现缺失值"></a>发现缺失值</h3><p>Pandas数据结构有两种有效的方法可以发现缺失值:isnull()和notnull()。每种方法都返回布尔类型的掩码数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.42.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>布尔类型掩码数组可以直接作为 Series或 DataFrame的索引使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.43.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在 Series里使用的isnull()和notnull()同样适用于Dataframe,产生的结果同样是布尔类型。</p><h3 id="剔除缺失值"><a href="#剔除缺失值" class="headerlink" title="剔除缺失值"></a>剔除缺失值</h3><p>dropna（）（剔除缺失值）和fillna（）（填充缺失值）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.49.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们没法从 DataFrame中单独剔除一个值,要么是剔除缺失值所在的整行,要么是整列。根据实际需求,有时你需要剔除整行,有时可能是整列, DataFrame中的 drona()会有一些参数可以配置。默认情况下, drona()会剔除任何包含缺失值的整行数据。可以设置按不同的坐标轴剔除缺失值,比如axis=1(或axis=‘ columns’)会剔除任何包含缺失值的整列数据。</p><p>但是这么做也会把非缺失值一并剔除,因为可能有时候只需要剔除全部是缺失值的行或列,或者绝大多数是缺失值的行或列。这些需求可以通过设置how或 thresh参数来满足,它们可以设置剔除行或列缺失值的数量阈值。</p><p>默认设置是how=‘any’,也就是说只要有缺失值就剔除整行或整列(通过axis设置坐标轴)。你还可以设置how=‘all’,这样就只会剔除全部是缺失值的行或列了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.53.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以通过 thresh参数设置行或列中非缺失值的最小数量,从而实现更加个性化的配置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.54.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h3><p>有时候你可能并不想移除缺失值,而是想把它们替换成有效的数值。有效的值可能是像0、1、2那样单独的值,也可能是经过填充( Imputation)或转换( interpolation)得到的。Pandas为此专门提供了一个fillna（）方法，将返回填充了缺失值后的数组副本。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.56.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以用缺失值前面的有效值来从前往后填充。也可以用缺失值后面的有效值来从后往前填充(back-fil)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.20.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Dataframe的操作方法与 Series类似,只是在填充时需要设置坐标轴参数axis。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.24.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是,假如在从前往后填充时,需要填充的缺失值前面没有值,那么它就仍然是缺失值。</p><h1 id="层级索引"><a href="#层级索引" class="headerlink" title="层级索引"></a>层级索引</h1><p>当目前为止,我们接触的都是一维数据和二维数据,用 Pandas的Series和 DataFrame对象就可以存储。但我们也经常会遇到存储多维数据的需求,数据索引超过一两个键。因此, Pandas提供了 Panel和Pane4D对象解决三维数据与四维数据。而在实践中,更直观的形式是通过层级索引( hierarchical indexing,也被称为多级索引,muli- indexing)配合多个有不同等级( level)的一级索引一起使用,这样就可以将高维数组转换成类似一维 Series和二维DataFrame对象的形式。</p><h2 id="所及索引Series"><a href="#所及索引Series" class="headerlink" title="所及索引Series"></a>所及索引Series</h2><h3 id="笨方法"><a href="#笨方法" class="headerlink" title="笨方法"></a>笨方法</h3><p>使用元组。</p><h3 id="好方法：Pandas多级索引"><a href="#好方法：Pandas多级索引" class="headerlink" title="好方法：Pandas多级索引"></a>好方法：Pandas多级索引</h3><p>用元组表示索引其实是多级索引的基础。Pandas的 MultiIndex类型提供了更丰富的操作方法。我们可以用元组创建一个多级索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.35.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="高维数据的多级索引"><a href="#高维数据的多级索引" class="headerlink" title="高维数据的多级索引"></a>高维数据的多级索引</h3><p>unstack()方法可以快速将一个多级索引的 Series转化为普通索引的DataFrame。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.46.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当然了，也有stack（）方法实现相反的效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.47.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果我们可以用含多级索引的一维 Series数据表示二维数据,那么我们就可以用 Series或 Dataframe表示三维甚至更高维度的数据。多级索引每增加一级,就表示数据增加一维,利用这一特点就可以轻松表示任意维度的数据了。假如要增加一列显示每一年各州的人口统计指标(例如18岁以下的人口),那么对于这种带有<br>Multiindexⅹ的对象,增加一列就像 DataFrame的操作一样简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.35.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.40.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多级索引的创建方法"><a href="#多级索引的创建方法" class="headerlink" title="多级索引的创建方法"></a>多级索引的创建方法</h2><p>为 Series或 DataFrame创建多级索引最直接的办法就是将 index参数设置为至少二维的索引数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.42.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.42.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Multiindex的创建工作将在后台完成。同理,如果你把将元组作为键的字典传递给 Pandas, Pandas也会默认转MultiIndex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.44.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="显式地创建多级索引"><a href="#显式地创建多级索引" class="headerlink" title="显式地创建多级索引"></a>显式地创建多级索引</h3><p>可以通过一个有不同等级的若干简单数组组成的列表来构建 Multiindex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.48.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以通过包含多个索引值的元组构成的列表创建 MultiIndex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.56.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以用两个索引的笛卡尔积( Cartesian product)创建Multiindex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.58.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>更可以直接提供levels(包含每个等级的索引值列表的列表)和labels(包含每个索引值标签列表的列表)创建 MultiIndex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.00.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在创建 Series或 Dataframe时,可以将这些对象作为 index参数,或者通过 reindex方法更新 Series或 Dataframe的索引。</p><h3 id="多级索引的等级名称"><a href="#多级索引的等级名称" class="headerlink" title="多级索引的等级名称"></a>多级索引的等级名称</h3><p>给MultIindex的等级加上名称会为一些操作提供便利。你可以在前面任何一个 Multiindex构造器中通过 names参数设置等级名称,也可以在创建之后通过索引的names属性来修改名称。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.09.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="多级列索引"><a href="#多级列索引" class="headerlink" title="多级列索引"></a>多级列索引</h3><p>每个 Dataframe的行与列都是对称的,也就是说既然有多级行索引,那么同样可以有多级列索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.14.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多级索引的取值与切片"><a href="#多级索引的取值与切片" class="headerlink" title="多级索引的取值与切片"></a>多级索引的取值与切片</h2><h3 id="Series多级索引"><a href="#Series多级索引" class="headerlink" title="Series多级索引"></a>Series多级索引</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.18.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>MultIindex也支持局部取值( partial indexing),即只取索引的某一个层级。假如只取最高级的索引,获得的结果是一个新的Series,未被选中的低层索引值会被保留。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.20.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>类似的还有局部切片,不过要求MultiIndex是按顺序排列的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.21.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果索引已经排序,那么可以用较低层级的索引取值,第一层级的索引可以用空切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其他取值与数据选择的方法也都起作用。下面的例子是通过布尔掩码选择数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.25.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.25.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以用花哨的索引选择数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.26.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="DataFrame多级索引"><a href="#DataFrame多级索引" class="headerlink" title="DataFrame多级索引"></a>DataFrame多级索引</h3><p>DataFrame多级索引的用法与 Series类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.32.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于Dataframe的基本索引是列索引,因此 Series中多级索引的用法到了 DataFrame中就应用在列上了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.35.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.35.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与单索引类似，loc、iloc和ix索引器都可以使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.36.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然这些索引器将多维数据当作二维数据处理,但是在loc和iloc中可以传递多个层级的索引元组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.38.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种索引元组的用法不是很方便,如果在元组中使用切片还会导致语法错误。<br>虽然可以用Python内置的slice（）函数获取想要的切片，但是还可以使用IndexSlice对象，Pandas专门用它解决这些问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.42.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多级索引行列转换"><a href="#多级索引行列转换" class="headerlink" title="多级索引行列转换"></a>多级索引行列转换</h2><h3 id="有序的索引和无序的索引"><a href="#有序的索引和无序的索引" class="headerlink" title="有序的索引和无序的索引"></a>有序的索引和无序的索引</h3><p>如果MultiIndex不是有序的索引，那么大多数切片操作都会失败。局部切片和许多其他相似的操作都要求MultiIndex的各级索引是有序的（即按照字典顺序由A至Z）。为此Pandas提供了许多便捷的操作完成排序，如sort_index()和sortlevel()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.55.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>索引排序之后,局部切片就可以正常使用了。</p><h3 id="索引stack与unstack"><a href="#索引stack与unstack" class="headerlink" title="索引stack与unstack"></a>索引stack与unstack</h3><p>我们可以将一个多级索引数据集转换成简单的二维形式,可以通过level参数设置转换的索引层级。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.01.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>unstack()是 stack()的逆操作,同时使用这两种方法让数据保持不变。</p><h3 id="索引的设置与重置"><a href="#索引的设置与重置" class="headerlink" title="索引的设置与重置"></a>索引的设置与重置</h3><p>层级数据维度转换的另一种方法是行列标签转换,可以通过reset_index方法实现。</p><h2 id="多级索引的数据累计方法"><a href="#多级索引的数据累计方法" class="headerlink" title="多级索引的数据累计方法"></a>多级索引的数据累计方法</h2><p>对于层级索引数据，可以设置参数level实现对数据子集的累计操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.27.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要计算每一年的各项平均值，可以将参数level设置为索引year。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.28.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果再设置axis参数,就可以对列索引进行类似的累计操作了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.29.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="合并数据集：Concat与Append操作"><a href="#合并数据集：Concat与Append操作" class="headerlink" title="合并数据集：Concat与Append操作"></a>合并数据集：Concat与Append操作</h1><h2 id="使用pd-concat实现简易合并"><a href="#使用pd-concat实现简易合并" class="headerlink" title="使用pd.concat实现简易合并"></a>使用pd.concat实现简易合并</h2><p>Pandas有一个pd.concat()函数与 np. concatenate语法类似,但是配置参数更多,功能也更强大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.38.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>pd. concat()可以简单地合并一维的 Series或 Dataframe对象,与np. concatenate()合并数组一样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.39.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.39.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它也可以用来合并高维数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.02.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认情况下，DataFrame的合并都是逐行进行的（默认设置是axis=0）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.03.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里使用axis=1效果是一样的，但是用axis=‘col’会更直观。</p><h3 id="索引重复"><a href="#索引重复" class="headerlink" title="索引重复"></a>索引重复</h3><p>np. concatenate与pd. concat最主要的差异之一就是 Pandas在合并时会保留索引,即使索引是重复的!<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.06.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="捕捉索引重复的错误"><a href="#捕捉索引重复的错误" class="headerlink" title="捕捉索引重复的错误"></a>捕捉索引重复的错误</h4><p>可以设置verify_integrity参数为True，合并时若有索引重复就会触发异常。</p><h4 id="忽略索引"><a href="#忽略索引" class="headerlink" title="忽略索引"></a>忽略索引</h4><p>有时索引无关紧要，那么合并时就可以忽略它们，可以通过设置ignore_index参数来实现，如果参数设置为True，那么合并时会创建一个新的整数索引。</p><h4 id="增加多级索引"><a href="#增加多级索引" class="headerlink" title="增加多级索引"></a>增加多级索引</h4><p>另一种处理方法是通过keys参数为数据源设置多级索引标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.12.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>结果是多级索引的DataFrame。</p><h3 id="类似join的合并"><a href="#类似join的合并" class="headerlink" title="类似join的合并"></a>类似join的合并</h3><p>实际中，需要合并的数据往往不带有相同的列名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.37.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认下，某个位置上的缺失会用NaN表示。如果不想这样，可以用join和join_axes参数设置合并方式。默认的合并方式是对所有的输入列进行并集合并（join=‘outer’）,当然也可以用join=‘inner’实现对输入列的交集合并。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.40.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一种合并方式是直接确定结果使用的列名,设置 join_axes参数,里面是索引对象构成的列表(是列表的列表)。</p><h3 id="append-方法"><a href="#append-方法" class="headerlink" title="append()方法"></a>append()方法</h3><p>可以使用df1. append(df2),效果与pd. concat([df1,df2])一样。Pandas的 append()不直接更新原有对象的值,而是为合并后的数据创建一个新对象。因此,它不能被称之为一个非常高效的解决方案,因为每次合并都需要重新创建索引和数据缓存。总之,如果你需要进行多个 append操作,还是建议先创建一个 Dataframe列表,然后用 concat()函数一次性解决所有合并任务。</p><h1 id="合并数据集：合并与连接"><a href="#合并数据集：合并与连接" class="headerlink" title="合并数据集：合并与连接"></a>合并数据集：合并与连接</h1><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>pd. merge()实现的功能基于关系代数( relational algebra)的一部分关系代数是处理关系型数据的通用理论,绝大部分数据库的可用操作都以此为理论基础。</p><h2 id="数据连接的类型"><a href="#数据连接的类型" class="headerlink" title="数据连接的类型"></a>数据连接的类型</h2><h3 id="一对一连接"><a href="#一对一连接" class="headerlink" title="一对一连接"></a>一对一连接</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.48.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.48.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="多对一连接"><a href="#多对一连接" class="headerlink" title="多对一连接"></a>多对一连接</h3><p>多对一连接是指,在需要连接的两个列中,有一列的值有重复。通过多对一连接获得的结果 DataFrame将会保留重复值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.56.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="多对多连接"><a href="#多对多连接" class="headerlink" title="多对多连接"></a>多对多连接</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.02.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.02.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="设置数据合并的键"><a href="#设置数据合并的键" class="headerlink" title="设置数据合并的键"></a>设置数据合并的键</h2><h3 id="参数on的用法"><a href="#参数on的用法" class="headerlink" title="参数on的用法"></a>参数on的用法</h3><p>最简单的方法就是直接将参数on设置为一个列名字符串或者一个包含多列名称的列表。这个参数只能在两个 DataFrame有共同列名的时候才可以使用。</p><h3 id="left-on与right-on参数"><a href="#left-on与right-on参数" class="headerlink" title="left_on与right_on参数"></a>left_on与right_on参数</h3><p>有时你也需要合并两个列名不同的数据集,例如前面的员工信息表中有一个字段不是“ employee’,而是 name”。在这种情况下,就可以用left on和 right on参数来指定列名:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.08.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>获取的结果中会有一个多余的列,可以通过 Dataframe的drop()方法将这列去掉。</p><h3 id="left-index与right-index参数"><a href="#left-index与right-index参数" class="headerlink" title="left index与right index参数"></a>left index与right index参数</h3><p>除了合并列之外,你可能还需要合并索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.11.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="设置数据连接的集合操作规则"><a href="#设置数据连接的集合操作规则" class="headerlink" title="设置数据连接的集合操作规则"></a>设置数据连接的集合操作规则</h2><p>通过前面的示例,我们总结出数据连接的一个重要条件:集合操作规则。当一个值出现在一列,却没有出现在另一列时,就需要考虑集合操作规则了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.17.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以用how参数设置连接方式，默认值为‘inner’，还有‘outer’、‘left’和‘right’。</p><h2 id="重复列名：suffixes参数"><a href="#重复列名：suffixes参数" class="headerlink" title="重复列名：suffixes参数"></a>重复列名：suffixes参数</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.43.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于输出结果中有两个重复的列名,因此pd. merge()函数会自动为它们增加后缀_x或_y,当然也可以通过 suffixes参数自定义后缀名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.44.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>suffixes参数同样适用于任何连接方式,即使有三个及三个以上的重复列名时也同样适用。</p><h1 id="累计与分组"><a href="#累计与分组" class="headerlink" title="累计与分组"></a>累计与分组</h1><p>在对较大的数据进行分析时,一项基本的工作就是有效的数据累计( summarization):计算累计( aggregation)指标,如sum()、mean()、 median()、min()和max(),其中每一个指标都呈现了大数据集的特征。</p><h2 id="Pandas的简单累计功能"><a href="#Pandas的简单累计功能" class="headerlink" title="Pandas的简单累计功能"></a>Pandas的简单累计功能</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.47.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.48.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Pandas的 Series和 DataFrame支持所有24节中介绍的常用累计函数。另外,还有一个非常方便的 describe()方法可以计算每一列的若干常用统计值。</p><p><img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.50.19.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.50.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DataFrame和 Series对象支持以上所有方法。</p><h2 id="GroupBy-分割、应用和组合"><a href="#GroupBy-分割、应用和组合" class="headerlink" title="GroupBy:分割、应用和组合"></a>GroupBy:分割、应用和组合</h2><h3 id="分割、应用和组合"><a href="#分割、应用和组合" class="headerlink" title="分割、应用和组合"></a>分割、应用和组合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.53.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>GroupBy的用处就是将这些步骤进行抽象:用户不需要知道在底层如何计算,只要把操作看成一个整体就够了。</p><p>我们可以用 DataFrame的 groupby()方法进行绝大多数常见的分割-应用-组合操作,将需要分组的列名传进去即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.57.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是,这里的返回值不是一个 DataFrame对象,而是个 DataFrame GroupBy对象。这个对象的魔力在于,你可以将它看成是一种特殊形式的 DataFrame,里面隐藏着若干组数据,但是在没有应用累计函数之前不会计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.02.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>sum()只是众多可用方法中的一个。你可以用 Pandas或 NumPy的任意一种累计函数,也可以用任意有效的 DataFrame对象。</p><h3 id="GroupBy对象"><a href="#GroupBy对象" class="headerlink" title="GroupBy对象"></a>GroupBy对象</h3><p>GroupBy对象是一种非常灵活的抽象类型。在大多数场景中,你可以将它看成是 Dataframe的集合,在底层解决所有难题。</p><h4 id="按列取值"><a href="#按列取值" class="headerlink" title="按列取值"></a>按列取值</h4><p>GroupBy对象与 Dataframe一样,也支持按列取值,并返回一个修改过的 GroupBy对象。</p><p>这里从原来的 DataFrame中取某个列名作为一个 Series组。与GroupBy对象一样,直到我们运行累计函数,才会开始计算。</p><h4 id="按组迭代"><a href="#按组迭代" class="headerlink" title="按组迭代"></a>按组迭代</h4><p>GroupBy对象支持直接按组进行迭代,返回的每组都是 Series或 Dataframe。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.17.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>借助 Python类的魔力(@ classmethod),可以让任何不由 GroupBy对象直接实现的方法直接应用到每一组,无论是 Dataframe还是 Series对象都同样适用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.17.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="累计、过滤、转换和应用"><a href="#累计、过滤、转换和应用" class="headerlink" title="累计、过滤、转换和应用"></a>累计、过滤、转换和应用</h3><h4 id="累计"><a href="#累计" class="headerlink" title="累计"></a>累计</h4><p>aggregate()可以支持更复杂得操作。比如字符串、函数或者函数列表，并且能一次性计算所有累计值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.27.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.27.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一种用法是通过Python字典指定不同列需要累计的函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.28.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>过滤操作可以让呢按照分组的属性丢弃若干数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.59.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.59.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>累计操作返回的是对组内全量数据缩减过的结果,而转换操作会返回一个新的全量数据。数据经过转换之后,其形状与原来的输入数据是一样的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8810.00.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply()方法"></a>apply()方法</h4><p>apply()方法让你可以在每个组上应用任意方法。这个函数输入一个 DataFrame,返回一个 Pandas对象( Data Frame或 Series)或一个标量( scalar,单个数值)。</p><h3 id="设置分割的键"><a href="#设置分割的键" class="headerlink" title="设置分割的键"></a>设置分割的键</h3><h4 id="将列表、数组、Series或索引作为分组键"><a href="#将列表、数组、Series或索引作为分组键" class="headerlink" title="将列表、数组、Series或索引作为分组键"></a>将列表、数组、Series或索引作为分组键</h4><h4 id="用字典或Series将索引映射到分组名称"><a href="#用字典或Series将索引映射到分组名称" class="headerlink" title="用字典或Series将索引映射到分组名称"></a>用字典或Series将索引映射到分组名称</h4><h4 id="任意Python函数"><a href="#任意Python函数" class="headerlink" title="任意Python函数"></a>任意Python函数</h4><h4 id="多个有效键构成的列表"><a href="#多个有效键构成的列表" class="headerlink" title="多个有效键构成的列表"></a>多个有效键构成的列表</h4><h1 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h1><h1 id="向量化字符串操作"><a href="#向量化字符串操作" class="headerlink" title="向量化字符串操作"></a>向量化字符串操作</h1><h2 id="Pandas字符串操作简介"><a href="#Pandas字符串操作简介" class="headerlink" title="Pandas字符串操作简介"></a>Pandas字符串操作简介</h2><p>Pandas为包含字符串的 Series和 Index对象提供的str属性堪称两全其美的方法,它既可以满足向量化字符串操作的需求,又可以正确地处理缺失值。例如,我们用前面的数据data创建了一个 Pandas的Series。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.25.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以直接调用转换大写方法capitalize()将所有的字符串变成大写形式，缺失值会被跳过。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.27.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Pandas字符串方法列表"><a href="#Pandas字符串方法列表" class="headerlink" title="Pandas字符串方法列表"></a>Pandas字符串方法列表</h2><h3 id="与Python字符串方法相似的方法"><a href="#与Python字符串方法相似的方法" class="headerlink" title="与Python字符串方法相似的方法"></a>与Python字符串方法相似的方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.29.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意，这些方法的返回值不同。有的返回一个字符串Series，有的返回数值，有的返回布尔值，有的返回列表或其他复合值。</p><h3 id="使用正则表达式的方法"><a href="#使用正则表达式的方法" class="headerlink" title="使用正则表达式的方法"></a>使用正则表达式的方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.32.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.34.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>还可以用正则表达式中的开始符号（\^）与结尾符号（\$）来实现。能将正则表达式应用到Series与DataFrame之中的话，就有可能实现更多的数据分析与清洗方法。</p><h3 id="其他字符串方法"><a href="#其他字符串方法" class="headerlink" title="其他字符串方法"></a>其他字符串方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.36.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="处理时间序列"><a href="#处理时间序列" class="headerlink" title="处理时间序列"></a>处理时间序列</h1><p>Pandas最初是为金融模型而创建的，因此它拥有一些功能非常强大的日期、时间、带时间索引数据的处理工具。</p><p><strong>时间戳</strong>表示某个具体的时间点(例如2015年7月4日上午7点)。</p><p><strong>时间间隔与周期</strong>表示开始时间点与结束时间点之间的时间长度,例如2015年(指的是2015年1月1日至2015年12月31日这段时间间隔)。周期通常是指一种特殊形式的时间间隔,每个间隔长度相同,彼此之间不会重叠(例如,以24小时为周期构成每天）。</p><p><strong>时间增量</strong>( time delta)或<strong>持续时间</strong>( duration)表示精确的时间长度(例如,某程序运行持续时间2256秒)。</p><h2 id="Python的日期与时间工具"><a href="#Python的日期与时间工具" class="headerlink" title="Python的日期与时间工具"></a>Python的日期与时间工具</h2><h3 id="原生Python的日期与时间工具：datetime与dateutil"><a href="#原生Python的日期与时间工具：datetime与dateutil" class="headerlink" title="原生Python的日期与时间工具：datetime与dateutil"></a>原生Python的日期与时间工具：datetime与dateutil</h3><p>datetime和 dateuti1模块在灵活性与易用性方面都表现出色你可以用这些对象及其相应的方法轻松完成你感兴趣的任意操作但如果你处理的时间数据量比较大,那么速度就会比较慢。就像之前介绍过的 Python的原生列表对象没有 NumPy中已经被编码的数值类型数组的性能好一样, Python的原生日期对象同样也没有NumPy中已经被编码的日期( encoded dates)类型数组的性能好。</p><h3 id="时间类型数组：NumPy的datetime64类型"><a href="#时间类型数组：NumPy的datetime64类型" class="headerlink" title="时间类型数组：NumPy的datetime64类型"></a>时间类型数组：NumPy的datetime64类型</h3><p>Python原生日期格式的性能弱点促使 NumPy团队为 NumPy增加了自己的时间序列类型。 datetime64类型将日期编码为64位整数,这样可以让日期数组非常紧凑(节省内存)。datetime64需要在设置日期时确定具体的输入类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.53.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>只要有了这个日期格式，就可以快速的向量化运算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.00.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然 datetime64弥补了 Python原生的datetime类型的不足,但它缺少了许多 datetime(尤其是dateutil)原本具备的便捷方法与函数。</p><h3 id="Pandas的日期与时间工具：理想与现实的最佳解决方案"><a href="#Pandas的日期与时间工具：理想与现实的最佳解决方案" class="headerlink" title="Pandas的日期与时间工具：理想与现实的最佳解决方案"></a>Pandas的日期与时间工具：理想与现实的最佳解决方案</h3><p>Pandas所有关于日期与时间的处理方法全部都是通过 Timestamp对象实现的,它利用 numpy. datetime64的有效存储和向量化接口将 datetime和 dateutil的易用性有机结合起来。 Pandas通过一组 Timestamp对象就可以创建一个可以作为 Series或DataFrame索引的 Datetimelndex。</p><h2 id="Pandas时间序列：用时间作索引"><a href="#Pandas时间序列：用时间作索引" class="headerlink" title="Pandas时间序列：用时间作索引"></a>Pandas时间序列：用时间作索引</h2><p>Pandas时间序列工具非常适合用来处理带时间戳的索引数据。我们可以通过一个时间索引数据创建一个 Series对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.11.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了一个带时间索引的Series之后,就能用它来演示之前介绍过的Series取值方法,可以直接用日期进行切片取值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.12.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另外,还有一些仅在此类 Series上可用的取值操作,例如直接通过年份切片获取该年的数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.14.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Pandas时间序列数据结构"><a href="#Pandas时间序列数据结构" class="headerlink" title="Pandas时间序列数据结构"></a>Pandas时间序列数据结构</h2><ol><li>针对时间戳数据, Pandas提供了 Timestamp类型。与前面介绍的一样,它本质上是 Python的原生 datetime类型的替代品,但是在性能更好的 numpy.datetime64类型的基础上创建。对应的索引数据结构是Datetimeindex。</li><li>针对时间周期数据, Pandas提供了 Period类型。这是利用numpy. datetime64类型将固定频率的时间间隔进行编码。对应的索引数据结构是 Periodindex。</li><li>针对时间增量或持续时间, Pandas提供了 Timedelta类型。Timedelta是一种代替 Python原生 datetime, timedelta类型的高性能数据结构,同样是基于 numpy. timedelta64类型。对应的索引数据结构是 Timedeltaindex。</li></ol><p>最基础的日期/时间对象是 Timestamp和 Datetimeindex。这两种对象可以直接使用,最常用的方法是pd.to_datetime()函数,它可以解析许多日期与时间格式。对pd.to_datetime()传递一个日期会返回一个 Timestamp类型,传递一个时间序列会返回一个Datetimelndex类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.24.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.25.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>任何Datetimeindex类型都可以通过to_ period()方法和一个频率代码转换成 Periodindex类型。下面用‘D’将数据转换成单日的时间序列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.25.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当用一个日期减去另一个日期时,返回的结果是 Timedeltaindex类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.26.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有规律的时间序列：<strong>pd.date_range()</strong>。</p><p>为了能更简便地创建有规律的时间序列, Pandas提供了一些方法:pd.daterange()可以处理时间戳、pd. period range()可以处理周期、pd.timedelta range()可以处理时间间隔。我们已经介绍过, Python的 range()和NumPy的 np.arange()可以用起点、终点和步长(可选的)创建一个序列。pd.daterange()与之类似,通过开始日期、结束日期和频率代码(同样是可选的)创建一个有规律的日期序列,默认的频率是天。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.42.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此外,日期范围不一定非是开始时间与结束时间,也可以是开始时间与周期数periods。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.43.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>你可以通过freq参数改变时间间隔,默认值是D。例如,可以创建个按小时变化的时间戳。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.43.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要创建一个有规律的周期或时间间隔序列,有类似的函数pd.period_range()和pd. timedelta_range()。下面是一个以月为周期的示例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.46.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一个以小时递增的序列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.46.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="时间频率与偏移量"><a href="#时间频率与偏移量" class="headerlink" title="时间频率与偏移量"></a>时间频率与偏移量</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.48.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.48.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.49.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以在频率代码后面加三位月份缩写字母来改变季、年频率的开始时间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.52.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以将频率组合起来创建新的周期。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.53.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="重新取样、迁移和窗口"><a href="#重新取样、迁移和窗口" class="headerlink" title="重新取样、迁移和窗口"></a>重新取样、迁移和窗口</h2><h3 id="重新取样与频率转换"><a href="#重新取样与频率转换" class="headerlink" title="重新取样与频率转换"></a>重新取样与频率转换</h3><p>处理时间序列数据时,经常需要按照新的频率(更高频率、更低频率)对数据进行重新取样。你可以通过 resample()方法解决这个问题,或者用更简单的 asfreq()方法。这两个方法的主要差异在于, resample()方法是以数据累计( data aggregation)为基础,而 asfreq()方法是以数据选择( data selection)为基础。</p><h3 id="时间迁移"><a href="#时间迁移" class="headerlink" title="时间迁移"></a>时间迁移</h3><p>一种常用的时间序列操作时对数据按时间进行迁移。Pandas有两种解决这类问题的方法：shift()和tshift()。简单来说，shift（）就是迁移数据，而tshift（）就是迁移索引。两种方法都是按照频率代码进行迁移。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%887.38.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>shift（900）将数据向前推进了900天，而tshift(900)将时间索引向前推进了900天。</p><h3 id="移动时间窗口"><a href="#移动时间窗口" class="headerlink" title="移动时间窗口"></a>移动时间窗口</h3><h1 id="高性能-Pandas-eval-与-query"><a href="#高性能-Pandas-eval-与-query" class="headerlink" title="高性能 Pandas:eval()与 query()"></a>高性能 Pandas:eval()与 query()</h1><h2 id="query-与eval-的设计动机-复合代数式"><a href="#query-与eval-的设计动机-复合代数式" class="headerlink" title="query()与eval()的设计动机:复合代数式"></a>query()与eval()的设计动机:复合代数式</h2><p>NumPy与Pandas都支持快速的向量化运算。</p><h2 id="用pandas-eval-实现高性能运算"><a href="#用pandas-eval-实现高性能运算" class="headerlink" title="用pandas.eval()实现高性能运算"></a>用pandas.eval()实现高性能运算</h2><p>Pandas的eval()函数用字符串代数式实现了 DataFrame的高性能运算。eval()版本的代数式比普通方法快一倍（而且内存消耗更少），结果也是一样的。</p><h3 id="pd-eval-支持的运算"><a href="#pd-eval-支持的运算" class="headerlink" title="pd.eval()支持的运算"></a>pd.eval()支持的运算</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>pd.eval()支持所有的算术运算符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.06.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>pd.eval()支持所有的比较运算符,包括链式代数式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.06.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.06.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="对象属性与索引"><a href="#对象属性与索引" class="headerlink" title="对象属性与索引"></a>对象属性与索引</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.07.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h4><p>目前pd.eval()还不支持函数调用、条件语句、循环以及更复杂的运算。如果你想要进行这些运算,可以借助 Numexpr来实现。</p><h2 id="用-DataFrame-eval-实现列间运算"><a href="#用-DataFrame-eval-实现列间运算" class="headerlink" title="用 DataFrame.eval()实现列间运算"></a>用 DataFrame.eval()实现列间运算</h2><p>由于 pd. eval()是 Pandas的顶层函数,因此 Dataframe有一个eval()方法可以做类似的运算。使用eval()方法的好处是可以借助列名称进行运算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.13.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.14.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Dataframe.eval()方法可以通过列名称实现简洁的代数式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.15.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="用-DataFrame-eval-新增列"><a href="#用-DataFrame-eval-新增列" class="headerlink" title="用 DataFrame. eval()新增列"></a>用 DataFrame. eval()新增列</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.18.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.18.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Dataframe-eval-使用局部变量"><a href="#Dataframe-eval-使用局部变量" class="headerlink" title="Dataframe.eval()使用局部变量"></a>Dataframe.eval()使用局部变量</h3><p>Dataframe.eval()方法还支持通过@符号使用 Python的局部变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.20.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>@符号表示“这是一个变量名称而不是一个列名称”,从而让你灵活地用两个“命名空间”的资源(列名称的命名空间和 Python对象的命名空间)计算代数式。需要注意的是,@符号只能在Dataframe.eval()方法中使用,而不能在 pandas.eval()函数中使用,因为 pandas. eval()函数只能获取一个( Python)命名空间的内容。</p><h2 id="DataFrame-query-方法"><a href="#DataFrame-query-方法" class="headerlink" title="DataFrame.query()方法"></a>DataFrame.query()方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.44.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>除了计算性能更优以外，这种方法的语法也比掩码代数式语法更好理解。需要注意的是，query()方法也支持@符号引用局部变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.46.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="性能决定使用时机"><a href="#性能决定使用时机" class="headerlink" title="性能决定使用时机"></a>性能决定使用时机</h2><p>在考虑要不要用这两个函数时,需要思考两个方面:计算时间和内存消耗,而内存消耗是更重要的影响因素。就像前面介绍的那样,每个涉及NumPy数组或Pandas的 DataFrame的复合代数式都会产生临时数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.50.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果临时 DataFrame的内存需求比你的系统内存还大(通常是几吉字),那么最好还是使用eval()和 query()代数式。</p><p>在性能方面，即使没有使用最大的系统内存，eval（）的计算速度也比普通方法快。在实际工作中,我发现普通的计算方法与eval/ query计算方法在计算时间上的差异并非总是那么明显,普通方法在处理较小的数组时反而速度更快!eval/ query方法的优点主要是节省内存,有时语法也更加简洁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pandas是在NumPy基础上建立的新程序库,提供了一种高效的 DataFrame数据结构。 DataFrame本质上是一种带行标签和列标签、支持相同类型数据和缺失值的多维数组。 Pandas不仅为带各种标签的数据提供了便利的存储界面,还实现了许多强大的操作,这些操作对数
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer  面试的流程</title>
    <link href="https://github.com/zdkswd/2018/10/28/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/10/28/剑指offer  面试的流程/</id>
    <published>2018-10-28T08:16:12.000Z</published>
    <updated>2018-10-28T08:17:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试的三种形式"><a href="#面试的三种形式" class="headerlink" title="面试的三种形式"></a>面试的三种形式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%885.49.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="电话面试"><a href="#电话面试" class="headerlink" title="电话面试"></a>电话面试</h3><p>与现场面试最大的区别就是应聘者见不到面试官，双方的沟通只能依靠声音。很多外企在电话面试时都会加上英语面试的环节，甚至有些公司全部面试都会用英语进行。对应聘者的听力提出了更高的要求。如果在面试的时候没有听清楚或听懂面试官的问题，千万不要不懂装懂答非所问，这是面试的大忌。当不确定面试官的问题时，一定要大胆的多提问，直到弄清楚面试官的意图为止。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%885.55.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="共享桌面远程面试"><a href="#共享桌面远程面试" class="headerlink" title="共享桌面远程面试"></a>共享桌面远程面试</h3><p>目前只有为数不多的几家大公司会在邀请应聘者到公司参加现场面试前，先进行一两轮共享桌面的远程面试。面试最关心的是应聘者的编程习惯及调试能力。通常面试官认可的习惯：</p><ol><li>思考清楚再开始编程。</li><li>良好的代码命名和缩进对齐习惯。</li><li>更够<strong>单元测试</strong>。通常面试官出的题目都是要求写函数解决某一问题,如果应聘者能够在定义函数之后,立即对该函数进行全面的单元测试,那就相当于向面试官证明了自己有着专业的软件开发经验。如果应聘者是<strong>先写单元测试用例</strong>,再写解决问题的函数,我相信面试官定会对你刮目相看,因为能做到测试在前、开发在后的程序员实在是太稀缺了,他会毫不犹豫地抛出绿色的橄榄枝。</li></ol><p>通常我们在写代码的时候都会遇到问题。当应聘者运行代码发现结果不对之后的表现,也是面试官关注的重点,因为应聘者此时的反应、采取的措施都能体现出他的<strong>调试功底</strong>。如果应聘者能够熟练地<strong>设置断点</strong>、<strong>单步跟踪</strong>、<strong>查看内存</strong>、<strong>分析调用栈</strong>,能很快发现问题的根源并最终解决问题,那么面试官将会觉得他的开发经验很丰富。调试能力是在书本上学不到的只有通过大量的软件开发实践才能积累出调试技巧。当面试官发现一个应聘者的调试功底很扎实的时候,他在写面试报告的时候是不会吝啬赞美之词的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.04.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="现场面试"><a href="#现场面试" class="headerlink" title="现场面试"></a>现场面试</h3><p>在通过上述两个面试后，就会进行现场面试，应当做好以下准备：</p><ol><li>规划好路线并估算出行时间，不迟到。</li><li>准备好得体的衣服，没有必要穿正装。</li><li>注意面试邀请函的面试流程。如果面试有好几轮，时间也很长，在面试过程中可能会觉得疲劳并思维变得迟钝。比如微软对技术职位通常有五论面试，连续几个小时处在高压的面试中，人难免会变得精疲力尽，因此可以带一些提神的饮料或食品。</li><li>准备几个问题。每一轮面试的最后，面试官都会让应聘者问几个问题，应聘者可以提前准备好问题。</li></ol><p>现场面试时整个面试流程中的重头戏。由于是坐在面试官的对面，应聘者的一举一动都看在面试官的眼力。面试官通过应聘者的语言和行动，考查他的<strong>沟通能力</strong>、<strong>学习能力</strong>、<strong>编程能力</strong>等综合实力。</p><h2 id="现场面试的三个环节"><a href="#现场面试的三个环节" class="headerlink" title="现场面试的三个环节"></a>现场面试的三个环节</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.19.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="行为面试环节"><a href="#行为面试环节" class="headerlink" title="行为面试环节"></a>行为面试环节</h3><p>面试开始的5~10分钟通常是行为面试的时间。在行为面试这个环节里,面试官会注意应聘者的性格特点,深入地了解简历中列举的项目经历。由于这一环节一般不会问技术难题,因此也是一个暖场的过程,应聘者可以利用这几分钟时间调整自己的情绪,进入面试的状态。</p><p>不少面试官会让应聘者做一个简短的自我介绍。由于面试官手中拿着应聘者的简历,而那里有应聘者的详细信息,因此此时的自我介绍不用花很多时间,用30秒到1分钟的时间介绍自己的主要学习、工作经历就即可如果面试官对你的某一段经历或者参与的某一个项目很感兴趣,他会有针对性地提几个问题详细了解。</p><h4 id="简历中应聘者的项目经验"><a href="#简历中应聘者的项目经验" class="headerlink" title="简历中应聘者的项目经验"></a>简历中应聘者的项目经验</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.26.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li><strong>Situation:简短的项目背景</strong>，比如项目的规模，开发的软件的功能、目标用户等。</li><li><strong>Task：自己完成的任务</strong>。这个要写<strong>详细</strong>，要让面试官对自己的工作一目了然。在用词上要注意区分“参与”和“负责”:如果只是加入某一个开发团队写了几行代码就用“负责”,那就很危险。面试官看到简历上应聘者“负责”了某个项目,他可能就会问项目的总体框架设计、核心算法、团队合作等问题。这些问题对于只是简单参与”的人来说,是很难回答的,会让面试官认为你不诚实,印象分会减去很多。</li><li><strong>Action：为了完成任务自己做了哪些工作，是怎么做的。</strong>这里可以<strong>详细</strong>介绍。做系统设计的,可以介绍系统架构的特点;做软件开发的,可以写基于什么工具在哪个平台下应用了哪些技术;做软件测试的,可以写是手工测试还是自动化测试,是白盒测试还是黑盒测试等。</li><li><strong>Result：自己的贡献。</strong>这些方面信息可以写得具体些，最好能用数字加以说明。如果是参与功能开发,可以说按时完成了多少功能;如果做优化,可以说性能提高的百分比是多少;如果是维护,可以说修改了多少个Bug。</li></ol><p>举例：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.36.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.37.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.37.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="应聘者掌握的技能，了解，熟悉，精通"><a href="#应聘者掌握的技能，了解，熟悉，精通" class="headerlink" title="应聘者掌握的技能，了解，熟悉，精通"></a>应聘者掌握的技能，了解，熟悉，精通</h4><p><strong>了解</strong>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.41.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>熟悉：</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.43.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>精通：</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.43.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="回答“为什么跳槽”"><a href="#回答“为什么跳槽”" class="headerlink" title="回答“为什么跳槽”"></a>回答“为什么跳槽”</h4><p>面试官只是想通过这个问题来了解应聘者的性格，可以根据自己的真实想法来回答这个问题但也不能想说什么就说什么，回答这个问题时不要抱怨，也不要流露出负面的情绪。应当尽量避免以下4个原因：</p><ol><li><strong>老板太苛刻。</strong></li><li><strong>同事太难相处。</strong>面试官可能会觉得这个人本身就很难相处。</li><li><strong>加班太频繁。</strong>对于大部分IT企业来说，加班是家常便饭。这么说等于不想进这家公司。</li><li><strong>工资太低。</strong>不建议在面试的时候对面试官抱怨，等完成技术面试之后谈offer时，再和HR谈工资也不迟。通过面试后我们就掌握主动了，想怎么谈就怎么谈，如果工资真的开高了HR会和你很客气地商量的。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.04.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.04.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><h3 id="技术面试环节"><a href="#技术面试环节" class="headerlink" title="技术面试环节"></a>技术面试环节</h3><p>面试官在通过简历及行为面试大致了解应聘者的背景之后，接下来就要开始技术面试了。一轮1小时的面试，通常技术面试会占40-50分钟，这是面试的重头戏，对面试的结果起决定性作用。总体面试官会关注应聘者5种素质：<strong>扎实的基础知识、能写高质量的代码、分析问题思路清晰、能优化时间和空间效率，以及学习沟通等各方面的能力。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.08.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="扎实的基础知识"><a href="#扎实的基础知识" class="headerlink" title="扎实的基础知识"></a>扎实的基础知识</h4><p>基本功在编程面试环节体现在三个方面：编程语言、数据结构和算法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.11.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.11.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.12.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="高质量的代码"><a href="#高质量的代码" class="headerlink" title="高质量的代码"></a>高质量的代码</h4><p>只有注重质量的程序员,才能写出鲁棒稳定的大型软件。在面试过程中,面试官总会格外关注<strong>边界条件</strong>、<strong>特殊输入</strong>等看似细枝末节但实质至关重要的地方,以考查应聘者是否注重代码质量。很多时候,面试官发现应聘者写出来的代码只能完成最基本的功能,一旦输入特殊的边界条件参数就会错误百出甚至程序崩溃。</p><p>总有些应聘者很困惑:面试的时候觉得题目很简单,感觉自己都做出来了,可最后为什么被拒了呢?在技术面试过程中,技术面试的面试官一般都是程序员,他们只认一个理:题目做对、做完整了,就让你通过面试;否则失败。所以遇到简单题目却被拒的情况,应聘者应认真反思在思路或者代码中存在哪些漏洞。</p><p>通常越是简单的问题，面试官的期望值就会越高。如果题目很简单，面试官会期待应聘者能够很<strong>完整</strong>的解决问题。除了完成基本功能以外，还要考虑到边界条件、错误处理等各个方面。还要考虑程序是否足够鲁棒。</p><p>要想很好地解决前面的问题,最好的办法是在动手写代码之后想好<strong>测试用例</strong>。只有把各种可能的输入事先都想好了,才能在写代码的时候把各种情况都做相应的处理。写完代码之后,也不要立刻给面试官检查,而是先在心里默默地运行。当输入之前想好的所有测试用例都能得到合理的输出时,再把代码交给面试官。做到了这一步,offer就很简单了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.39.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="清晰的思路"><a href="#清晰的思路" class="headerlink" title="清晰的思路"></a>清晰的思路</h4><p>对于确实很复杂的问题，面试官甚至不期待应聘者能在面试不到一个小时的时间里给出完整的答案，更看重的可能还是应聘者是否有清晰的思路。面试官通常不喜欢应聘者在没有形成清晰思路之前就草率地开始写代码，这样写出来的代码容易逻辑混乱、错误百出。</p><p>应聘者可以用几个简单的方法帮助自己形成清晰的思路。<br>首先是举几个简单的具体例子让自己理解问题。当我们一眼看不出问题中隐藏的规律的时候,可以试着用一两个具体的例子模拟操作的过程,这样说不定就能通过具体的例子找到抽象的规律。<br>其次可以试着用图形表示抽象的数据结构。像分析与链表、二叉树相关的题目,我们都可以画出它们的结构来简化题目。<br>最后可以试着把复杂的问题分解成若干个简单的子问题,再解决。很多基于递归的思路,包括分治法和动态规划,都是把复杂的问题分解成一个或者多个简单的子问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.47.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="优化效率的能力"><a href="#优化效率的能力" class="headerlink" title="优化效率的能力"></a>优化效率的能力</h4><p>优秀的程序员对时间和内存的消耗锱铢必较,他们很有激情地不断优化自己的代码。当面试官出的题目有多种解法的时候,通常他会期待应聘者最终能够找到最优解。当面试官提示还有更好的解法的时候,应聘者不能放弃思考,而应该努力寻找在时间消耗或者空间消耗上可以优化的地方。</p><p>要想优化时间或者空间效率,首先要知道如何分析效率。即使是同一个算法,用不同方法实现的效率可能也会大不相同,我们要能够分析出算法及其代码实现的效率。</p><p>要想优化代码的效率,我们还要熟知各种数据结构的优缺点,并能选择合适的数据结构解决问题。</p><p>要想优化代码的效率,我们也要熟练掌握常用的算法。面试中最常用的算法是査找和排序。</p><h4 id="优秀的综合能力"><a href="#优秀的综合能力" class="headerlink" title="优秀的综合能力"></a>优秀的综合能力</h4><p>除了展示自己的编程能力和技术功底之外，还需要展示自己的软能力，诸如自己的<strong>沟通能力</strong>和<strong>学习能力</strong>。软件开发已经告别了单打独斗的年代，程序员与他人的沟通变得越来越重要。<strong>知识迁移</strong>能力是一种特殊的学习能力。如果我们能够把已经掌握的知识迁移到其他领域，那么学习新技术或者解决新问题就会变得容易。还有些面试官喜欢考察应聘者的抽象建模能力和发散思维能力。</p><h3 id="应聘者提问环节"><a href="#应聘者提问环节" class="headerlink" title="应聘者提问环节"></a>应聘者提问环节</h3><p>在结束面试前的5-10分钟，面试官会给应聘者机会提几个问题，应聘者的问题质量也会对面试的结果有一定的影响。面试官让应聘者问几个问题，主要是想了解他最关心的问题有哪些，因此应聘者至少要问一两个问题。问得问题合适，是加分项，问的问题不合适，那就是减分项。</p><p>有些问题是不适合在技术面试这个环节问的。首先，不要问和自己职位没有关系的问题。比如面试职位是一线的开发问公司五年的发展战略。其次是不要问薪水，技术面试不是谈薪水的时候，要谈工资要等通过面试后和HR谈。再次是不要立即打听面试结果，现在大部分公司面试都有好几轮，最终决定应聘者能不能通过面试，是要把面试官的评价综合起来的，问这个等于白问。还会让人觉得没有自我评价的能力。</p><p>推荐问的问题是与招聘的职位或者与项目相关的问题，如果这种类的问题问的很好，就加分。不过要问好这类的问题首先应聘者应对应聘的职位或项目的背景有一定的了解。可以从两方面去了解。一是面试前做足功课，到网上去搜集相关的信息，做到对公司成立时间、主要业务、职位要求都了解。二是在面试过程中留意面试官说过的话。有不少面试官在面试前会简单介绍与招聘职位相关的项目，其中会包含其他渠道无法获得的信息，比如项目的进展情况等，可以从中找出一两个点，然后向面试官提问。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%888.20.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试的三种形式&quot;&gt;&lt;a href=&quot;#面试的三种形式&quot; class=&quot;headerlink&quot; title=&quot;面试的三种形式&quot;&gt;&lt;/a&gt;面试的三种形式&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div cl
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="offer" scheme="https://github.com/zdkswd/tags/offer/"/>
    
  </entry>
  
  <entry>
    <title>Python数据科学手册 NumPy入门</title>
    <link href="https://github.com/zdkswd/2018/10/28/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/"/>
    <id>https://github.com/zdkswd/2018/10/28/Python数据科学手册/</id>
    <published>2018-10-28T07:00:56.000Z</published>
    <updated>2018-10-28T07:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python数据科学手册-NumPy入门"><a href="#Python数据科学手册-NumPy入门" class="headerlink" title="Python数据科学手册 NumPy入门"></a>Python数据科学手册 NumPy入门</h1><p>数据集的来源与格式都十分丰富，比如文档集合、图像集合、声音片段集合、数值数据集合，等等。这些数据虽然存在明显的异构性，但是将所有数据简单地看作数字数组非常有助于我们理解和处理数据。</p><p>例如，可以将图像（尤其是数字图像）简单地看作二维数字数组，这些数字数组代表各区域的像素值；声音片段可以看做时间和强度的一维数组；文本也可以通过各种方式转化为数值表示，一种可能的转换时用二进制数表示特定单词或单词对出现的频率。不管数据是何种形式，第一步都是将这些数据转化为数值叔祖形式的可分析数据。</p><p>正因如此，有效地存储和操作数值数组是数据科学中绝对的基础过程。NumPy(Numerical Python的简称)提供了高效3存储和操作密集数据缓存的接口。</p><h1 id="理解Python中的数据类型"><a href="#理解Python中的数据类型" class="headerlink" title="理解Python中的数据类型"></a>理解Python中的数据类型</h1><p>Python的类型灵活性指出了一个事实：Python变量不仅是它们的值，还包括了关于值得类型的一些额外信息。</p><h2 id="Python整型不仅仅是一个整型"><a href="#Python整型不仅仅是一个整型" class="headerlink" title="Python整型不仅仅是一个整型"></a>Python整型不仅仅是一个整型</h2><p>标准的Python实现是用C语言编写的。这意味着每一个Python对象都是一聪明的伪C语言结构体，该结构体不仅包含其值，还有其他信息。例如当我们在Python中定义一个整型，x=10000时，x并不是一个‘原生’整型，而是一个指针，指向一个C语言的复合结构体，结构体里包含了一些值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%882.47.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%882.48.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这意味着与C语言这样的编译语言的整型相比，在python中存储一个整型会有一些开销。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%882.51.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里PyObject_HEAD是结构体中包含引用计数、类型编码和其他之前提到的内容的部分。</p><p>两者的差异在于，C语言整型本质上是对应某个内存位置的标签，里面存储的字节会编码成整型。而Python的整型其实是一个指针，指向包含这个Python对象所有信息的某个内存位置，其中包括可以转换成整型的字节。由于Python的整型结构体中还包含了大量额外的信息，所以Python可以自由、动态地编码，但是Python类型中的这些额外信息也会成为负担，在多个对象组合的结构体中尤其明显。</p><h2 id="Python列表不仅仅是一个列表"><a href="#Python列表不仅仅是一个列表" class="headerlink" title="Python列表不仅仅是一个列表"></a>Python列表不仅仅是一个列表</h2><p>python中的标准可变多元素容器是列表。为了获得这些灵活的类型，列表中每一项必须包含各自的类型信息、引用计数和其他信息。也就是每一项都是一个完整的Python对象。python的列表甚至可以是异构的，即每项的类型可以不同。如果列表中的所有变量都是同一类型的，那么很多信息会显得多余—将数据存储在固定类型的数组应该会更高效。动态类型的列表和固定类型（NumPy式）数组的区别。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.06.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在实现层面,数组基本上包含一个指向连续数据块的指针。另一方面,Python列表包含一个指向指针块的指针,这其中的每一个指针对应一个完整的 Python对象(如前面看到的 Python整型)。另外,列表的优势是灵活,因为每个列表元素是一个包含数据和类型信息的完整结构体,而且列表可以用任意类型的数据填充。固定类型的 NumPy式数组缺乏这种灵活性,但是能更有效地存储和操作数据。</p><h2 id="Python中固定类型数组"><a href="#Python中固定类型数组" class="headerlink" title="Python中固定类型数组"></a>Python中固定类型数组</h2><p>Python提供了几种将数据存储在有效的、固定类型的数据缓存中的选项。内置的数组( array)模块(在 Python3.3之后可用)可以用于创建统一类型的密集数组:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.15.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.16.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="从Python列表创建数组"><a href="#从Python列表创建数组" class="headerlink" title="从Python列表创建数组"></a>从Python列表创建数组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.17.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最后，不同于Python列表，NumPy数组可以被指定为多维的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.19.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="从头创建数组"><a href="#从头创建数组" class="headerlink" title="从头创建数组"></a>从头创建数组</h2><p>面对大型数组的时候，用NumPy内置的方法从头创建数组是一种更高效的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.26.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.31.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="NumPy标准数据类型"><a href="#NumPy标准数据类型" class="headerlink" title="NumPy标准数据类型"></a>NumPy标准数据类型</h2><p>NumPy数组包含同一类型的值，因此详细了解这些数据类型及其限制是非常重要的。因为NumPy是在C语言的基础上开发的，所以c的用户会比较熟悉这些数据类型。</p><p>当构建一个数组时，你可以用一个字符串参数来指定数据类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.34.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.45.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.45.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以进行更高级的数据类型指定，例如指定高位字节数或低位字节数。</p><h1 id="NumPy数组基础"><a href="#NumPy数组基础" class="headerlink" title="NumPy数组基础"></a>NumPy数组基础</h1><p>python中的数据操作几乎等同于NumPy数组操作，甚至新出现的Pandas工具也是构建在NumPy数组基础上的。</p><h2 id="NumPy数组的属性"><a href="#NumPy数组的属性" class="headerlink" title="NumPy数组的属性"></a>NumPy数组的属性</h2><p>我们将用NumPy的随机数生成器设置一组种子值，以确保每次程序执行时都可以生成同样的随机数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%884.14.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>每个数组有nidm(维度)、shape(数组每个维度的大小)和size(数组的大小)属性：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%884.18.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一个有用的属性时dtype,它是数组的数据类型。其他的属性包括每个数组元素字节的大小itemsize,以及表示数组总字节大小的属性nbytes。可以认为nbytes跟itemsize和size的乘积大小相等。</p><h2 id="数组索引：获取单个元素"><a href="#数组索引：获取单个元素" class="headerlink" title="数组索引：获取单个元素"></a>数组索引：获取单个元素</h2><p>NumPy中可以通过中括号指定索引获取第i个值（从0开始计数），为了获取数组的末尾索引，可以用负值索引，在多维数组中，可以用逗号分隔的索引元组获取元素。也可以用以上索引方式修改元素值。注意：和Python列表不同，NumPy数组是固定类型的。这意味着当试图将一个浮点值插入一个整型数组时，浮点值会被截断成整型，并且是自动完成的。</p><h2 id="数组切片：获取子数组"><a href="#数组切片：获取子数组" class="headerlink" title="数组切片：获取子数组"></a>数组切片：获取子数组</h2><p>可以用切片（slice）符号获取子数组，切片符号用冒号（：）表示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%884.43.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.16.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.17.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多维子数组"><a href="#多维子数组" class="headerlink" title="多维子数组"></a>多维子数组</h2><p>多维切片也采用同样的方式处理，用冒号分隔。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.25.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>子数组维度也可以同时被逆序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.26.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="获取数组的行和列"><a href="#获取数组的行和列" class="headerlink" title="获取数组的行和列"></a>获取数组的行和列</h2><p>一种常见的需求是获取数组的单行和单列。你可以将索引与切片组合起来实现这个功能。用一个冒号（：）表示空切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.28.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在获取行时，出于语法的简介考虑，可以省略空的切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.30.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.30.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="非副本视图的子数组"><a href="#非副本视图的子数组" class="headerlink" title="非副本视图的子数组"></a>非副本视图的子数组</h2><p>关于数组切片有一点很重要也非常有用,那就是数组切片返回的是数组数据的视图,而不是数值数据的副本。这一点也是 NumPy数组切片和 Python列表切片的不同之处:在 Python列表中,切片是值的副本。这种默认的处理方式实际上非常有用：它意味着在处理非常大的数据集时，可以获取或处理这些数据集的片段，而不用复制底层的数据缓存。</p><h2 id="创建数组的副本"><a href="#创建数组的副本" class="headerlink" title="创建数组的副本"></a>创建数组的副本</h2><p>尽管数组视图有一些非常好的特性，但是在有些时候明确地复制数组里的数据或子数组也是非常有用的。可以简单地通过copy（）方法实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%889.36.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果修改这个子数组，原始的数值不会被改变。</p><h2 id="数组的变形"><a href="#数组的变形" class="headerlink" title="数组的变形"></a>数组的变形</h2><p>数组变形最灵活的实现方式是通过reshape()函数来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%889.39.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果希望该方法可行，那么原始数组的大小必须和变形后数组的大小一致。如果满足条件reshape方法将会用到原始数组的一个非副本视图。但实际是，在非连续的数据缓存下，返回非副本视图往往不可能实现。</p><p>一个常见的变形模式是将一个一位数组转变为二维的行或列的矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%889.53.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数组拼接和分裂"><a href="#数组拼接和分裂" class="headerlink" title="数组拼接和分裂"></a>数组拼接和分裂</h2><h3 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h3><p>拼接或连接NumPy中的两个数组主要由np.concatenate、np.vstack和np.hstack例程实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以一次拼接两个以上数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.00.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>np.concatentate也可以由于二维数组的拼接。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.02.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>沿着固定维度处理数组时，使用np.vstack(垂直栈)和np.hstack(水平栈)函数会更简洁。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.04.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与之类似，np.dstack将沿着第三个维度拼接数组。</p><h3 id="数组的分裂"><a href="#数组的分裂" class="headerlink" title="数组的分裂"></a>数组的分裂</h3><p>分裂可以通过np.split、np.hsplit和np.vsplit函数来实现。可以转递一个索引列表作为参数，索引列表记录的是分裂点位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.09.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>n分裂点会得到n+1个子数组。np.hsplit和np.vsplit的用法也类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.11.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样，np.dspliy将数组沿着第三个维度分裂。</p><h1 id="NumPy数组的计算：通用函数"><a href="#NumPy数组的计算：通用函数" class="headerlink" title="NumPy数组的计算：通用函数"></a>NumPy数组的计算：通用函数</h1><h2 id="缓慢的循环"><a href="#缓慢的循环" class="headerlink" title="缓慢的循环"></a>缓慢的循环</h2><p>Python的默认实现(被称作 CPython)处理起某些操作时非常慢,一部分原因是该语言的动态性和解释性—数据类型灵活的特性决定了序列操作不能像C语言和 Fortran语言一样被编译成有效的机器码。目前,有一些项目试图解决 Python这一弱点,比较知名的包括:PyPy项目一个实时的 Python编译实现; Cython项目,将 Python代码转换成可编译的C代码;Nuba项目,将 Python代码的片段转换成快速的LLⅴM字节码。以上这些项目都各有其优势和劣势,但是比较保守地说,这些方法中还没有一种能达到或超过标准 CPython引擎的受欢迎程度。</p><p>Python的相对缓慢通常出现在很多小操作需要不断重复的时候,比如对数组的每个元素做循环操作时。处理结果所花费的时间是不合时宜的慢，处理瓶颈并不是运算本身，而是CPython在每次循环时必须做数据类型的检查和函数调度。在进行循环中每一轮的运算时，Python首先检查对象的类型，并且动态查找可以使用该数据类型的正确函数。如果我们在编译代码时进行这样的操作，那么就能在代码执行之前知晓类型的声明，结果的计算也会更加有效率。</p><h2 id="通用函数介绍"><a href="#通用函数介绍" class="headerlink" title="通用函数介绍"></a>通用函数介绍</h2><p>NumPy为很多类型的操作提供了非常方便的、静态类型的、可编译程序的接口,也被称作向量操作。你可以通过简单地对数组执行操作来实现,这里对数组的操作将会被用于数组中的每一个元素。这种向量方法被用于将循环推送至 NumPy之下的编译层,这样会取得更快的执行效率。如果计算一个较大数组的运行时间，可以看到它的时间比Python循环花费的时间更短。</p><h2 id="探索NumPy的通用函数"><a href="#探索NumPy的通用函数" class="headerlink" title="探索NumPy的通用函数"></a>探索NumPy的通用函数</h2><p>通用函数有两种存在形式:一元通用函数( unary func)对单个输入操作,二元通用函数( binary ufunc)对两个输入操作。</p><h3 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h3><p>NumPy通用函数的使用方式非常自然,因为它用到了 Python原生的算术运算符,标准的加、减、乘、除都可以使用，还有逻辑非，指数运算符和模运算符的一元通用函数。可以任意将这些算术运算符组合使用，当然得考虑这些运算符的优先级。所有这些算术运算符都是NumPy内置函数的简单封装器，例如+运算符就是一个add函数的封装器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.35.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h3><p>正如 NumPy能理解 Python内置的运算操作, NumPy也可以理解Python内置的绝对值函数。对应的 NumPy通用函数是 np. absolute,该函数也可以用别名np. abs来访问。</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>NumPy提供了大量好用的通用函数,其中对于数据科学家最有用的就是三角函数。<br>np.sin() np.cos() np.tan()<br>逆三角函数同样可以使用。<br>np.arcsin() np.arccos() np.arctan()</p><h3 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h3><p>np.log np.exp</p><h3 id="专用的通用函数"><a href="#专用的通用函数" class="headerlink" title="专用的通用函数"></a>专用的通用函数</h3><p>除了以上介绍到的, NumPy还提供了很多通用函数,包括双曲三角函数、比特位运算、比较运算符、弧度转化为角度的运算、取整和求余运算,等等。浏览 NumPy的文档将会揭示很多有趣的功能。还有一个更加专用,也更加晦涩的通用函数优异来源是子模块scipy. special。如果你希望对你的数据进行一些更晦涩的数学计算, scipy. special可能包含了你需要的计算函数。</p><p>NumPy和 scIpy. specia1中提供了大量的通用函数,这些包的文档在网上就可以查到,搜索“ gamma function python”即可。</p><h2 id="高级的通用函数特性"><a href="#高级的通用函数特性" class="headerlink" title="高级的通用函数特性"></a>高级的通用函数特性</h2><h3 id="指定输出"><a href="#指定输出" class="headerlink" title="指定输出"></a>指定输出</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.53.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于较大的数组，通过慎重使用out参数能有效节约内存。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>二元通用函数有些非常有趣的聚合功能,这些聚合可以直接在对象上计算。例如,如果我们希望用一个特定的运算 reduce一个数组,那么可以用任何通用函数的 reduce方法。一个 reduce方法会对给定的元素和操作重复执行,直至得到单个的结果。如果需要存储每次计算的中间结果，可以使用accumulate。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%883.00.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.59.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>请注意,在一些特殊情况中, NumPy提供了专用的函数(np.sum、np.prod、np. cumsum、np. cumprod),它们也可以实现以上 reduce的功能。</p><h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>最后,任何通用函数都可以用 outer方法获得两个不同输入数组所有元素对的函数运算结果。这意味着你可以用一行代码实现一个乘法表。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%883.03.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="通用函数：更多的信息"><a href="#通用函数：更多的信息" class="headerlink" title="通用函数：更多的信息"></a>通用函数：更多的信息</h2><p>有关通用函数的更多信息(包括可用的通用函数的完整列表)可以在NumPy和SciPy文档的网站找到。</p><h1 id="聚合：最小值、最大值和其他值"><a href="#聚合：最小值、最大值和其他值" class="headerlink" title="聚合：最小值、最大值和其他值"></a>聚合：最小值、最大值和其他值</h1><p>当面对大量的数据时，第一个步骤通常都是计算相关数据的概括统计值。最常用的概括统计值可能是均值和标准差，这两个值能让你分别概括出数据集中的“经典”值，但是其他一些形式的聚合也是非常有用的（如求和、乘积、中位数、最小值和最大值、分位数，等等）。</p><h2 id="数组值求和"><a href="#数组值求和" class="headerlink" title="数组值求和"></a>数组值求和</h2><p>Sum函数和np.sum函数并不等同,这有时会导致混淆。尤其是它们各自的可选参数都有不同的含义,np.sum函数是知道数组的维度的。sum是python求和，当然np.sum更快。</p><h2 id="最小值和最大值"><a href="#最小值和最大值" class="headerlink" title="最小值和最大值"></a>最小值和最大值</h2><p>Python也有内置的min函数和max函数,分别被用于获取给定数组的最小值和最大值，NumPy对应的函数也有类似的语法,并且也执行得更快。</p><h3 id="多维度聚合"><a href="#多维度聚合" class="headerlink" title="多维度聚合"></a>多维度聚合</h3><p>一种常用的聚合操作时沿着一行或一列聚合。默认情况下，每一个NumPy聚合函数将会返回对整个数组的聚合结果，聚合函数还有一个参数，用于指定沿着哪个轴的方向进行聚合。axis关键字指定的是数组将会被折叠的维度，而不是将要返回的维度。因此指定axis=0意味着第一个轴将要被折叠。对于二维数组，这意味着每一列的值都将被聚合。</p><h3 id="其他聚合函数"><a href="#其他聚合函数" class="headerlink" title="其他聚合函数"></a>其他聚合函数</h3><p>大多数的聚合都有对NaN值的安全处理策略，即计算时忽略所有的缺失值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%883.51.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="数组的计算：广播"><a href="#数组的计算：广播" class="headerlink" title="数组的计算：广播"></a>数组的计算：广播</h1><p>另外一种向量化操作的方法是利用 NumPy的广播功能。广播可以简单理解为用于不同大小数组的二进制通用函数(加、减、乘等)的一组规则。</p><h2 id="广播的介绍"><a href="#广播的介绍" class="headerlink" title="广播的介绍"></a>广播的介绍</h2><p>对于同样大小的数组，二进制操作是对相应元素逐个计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.14.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>广播允许这些二进制操作可以用于不同大小的数组，例如可以将一个标量和一个数组相加。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.15.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们也可以将这个原理扩展到更高维度，将一个一位数组和一个二维数组相加。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.17.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.25.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>浅色的盒子表示广播的值。需要注意的是,这个额外的内存并没有在实际操作中进行分配,但是这样的想象方式更方便我们从概念上理解。</p><h2 id="广播的规则"><a href="#广播的规则" class="headerlink" title="广播的规则"></a>广播的规则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.27.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="比较、掩码和布尔逻辑"><a href="#比较、掩码和布尔逻辑" class="headerlink" title="比较、掩码和布尔逻辑"></a>比较、掩码和布尔逻辑</h1><p>这一节将会介绍如何用布尔掩码来查看和操作 NumPy数组中的值。当你想基于某些准则来抽取、修改、计数或对一个数组中的值进行其他操作时,掩码就可以派上用场了。例如你可能希望统计数组中有多少值大于某一个给定值,或者删除所有超出某些门限值的异常点。在NumPy中,布尔掩码通常是完成这类任务的最高效方式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.52.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="操作布尔数组"><a href="#操作布尔数组" class="headerlink" title="操作布尔数组"></a>操作布尔数组</h2><h3 id="统计记录的个数"><a href="#统计记录的个数" class="headerlink" title="统计记录的个数"></a>统计记录的个数</h3><p>如果需要统计布尔数组中True记录的个数,可以使用np. count_nonzero函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.07.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如要快速检查任意或者所有的值是否为True，可以用np.any()或np.all()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.09.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="布尔运算值"><a href="#布尔运算值" class="headerlink" title="布尔运算值"></a>布尔运算值</h3><p>同标准的算术运算符一样，NumPy用通用函数重载了这些逻辑运算符，这样可以实现数组的逐位运算（通常是布尔运算）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.12.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.12.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="将布尔数组作为掩码"><a href="#将布尔数组作为掩码" class="headerlink" title="将布尔数组作为掩码"></a>将布尔数组作为掩码</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.18.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="花哨的索引"><a href="#花哨的索引" class="headerlink" title="花哨的索引"></a>花哨的索引</h1><p>花哨的索引和前面那些简单的索引非常类似，但是传递的是索引数组，而不是单个标量。花哨的索引让我们能够快速获得并修改复杂得数组值的字数据集。</p><h2 id="探索花哨的索引"><a href="#探索花哨的索引" class="headerlink" title="探索花哨的索引"></a>探索花哨的索引</h2><p>花哨的索引在概念上非常简单,它意味着传递一个索引数组来一次性获得多个数组元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.23.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.24.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>花哨的索引也对多个维度适用。</p><h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>花哨的索引可以和其他索引方案结合起来形成更强大的索引操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.44.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>更可以将花哨的索引和掩码组合使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.48.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h1><h2 id="NumPy中的快速排序：np-sort和np-argsort"><a href="#NumPy中的快速排序：np-sort和np-argsort" class="headerlink" title="NumPy中的快速排序：np.sort和np.argsort"></a>NumPy中的快速排序：np.sort和np.argsort</h2><p>尽管Python有内置的sort和sorted函数可以对列表进行排序，但是效率并不高，NumPy的np.sort函数实际上效率更高。默认情况下，np.sort的排序算法是快速排序，其算法复杂度O[NlogN]，另外也可以选择归并排序和堆排序。对于大多数应用场景，默认的快速排序已经足够高效了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.58.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.59.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>NumPy排序算法的一个有用功能是通过axis参数，沿着多维数组的行或列进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.01.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种处理方式是将行或列当做独立的数组，任何行或列的值之间的关系将会丢失。</p><h2 id="部分排序：分隔"><a href="#部分排序：分隔" class="headerlink" title="部分排序：分隔"></a>部分排序：分隔</h2><p>有时候我们不希望对整个数组进行排序，仅仅希望找到数组中第K小的值，NumPy的np.partition函数提供了该功能，最左边是第K小的值，往右是任意顺序的其他值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.07.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与排序类似，也可以沿着多维数组任意的轴进行分割。<br>正如np.argsort函数计算的是排序的索引值，也有一个np.argpartition函数计算的是分隔的索引值。</p><h1 id="结构化数据：NumPy的结构化数组"><a href="#结构化数据：NumPy的结构化数组" class="headerlink" title="结构化数据：NumPy的结构化数组"></a>结构化数据：NumPy的结构化数组</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.18.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里U1表示“长度不超过10的 Unicode字符串”,i4表示“4字节(即32比特)整型”,f8表示“8字节(即64比特)浮点型”。</p><p>现在生成了一个空的数组容器，可以将列表数据放入数组中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.21.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>正如我们希望的，所有的数据被安排在一个内存块中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.37.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.36.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.34.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="更高级的复合类型"><a href="#更高级的复合类型" class="headerlink" title="更高级的复合类型"></a>更高级的复合类型</h2><p>NumPy中也可以定义更高级的复合数据类型。例如,你可以创建一种类型,其中每个元素都包含一个数组或矩阵。我们会创建一个数据类型,该数据类型用mat组件包含一个3×3的浮点矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.49.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在X数组的每个元素都包含一个id和一个3×3的矩阵。为什么我们宁愿用这种方法存储数据,也不用简单的多维数组,或者 Python字典呢?原因是 NumPy的 dtype直接映射到C结构的定义,因此包含数组内容的缓存可以直接在C程序中使用。如果你想写一个 Python接口与一个遗留的C语言或 Fortran库交互,从而操作结构化数据,你将会发现结构化数组非常有用!</p><h2 id="记录数组：结构化数组的扭转"><a href="#记录数组：结构化数组的扭转" class="headerlink" title="记录数组：结构化数组的扭转"></a>记录数组：结构化数组的扭转</h2><p>NumPy还提供了np.recarray类。它和前面介绍的结构化数组几乎相同，但是它有一个独特的特征：域可以像属性一样获取，而不是像字典的键那样获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python数据科学手册-NumPy入门&quot;&gt;&lt;a href=&quot;#Python数据科学手册-NumPy入门&quot; class=&quot;headerlink&quot; title=&quot;Python数据科学手册 NumPy入门&quot;&gt;&lt;/a&gt;Python数据科学手册 NumPy入门&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础下</title>
    <link href="https://github.com/zdkswd/2018/10/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/"/>
    <id>https://github.com/zdkswd/2018/10/23/机器学习数学基础下/</id>
    <published>2018-10-23T13:28:47.000Z</published>
    <updated>2018-10-23T13:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性代数进阶"><a href="#线性代数进阶" class="headerlink" title="线性代数进阶"></a>线性代数进阶</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.26.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="矩阵的标准型：相似变换（把矩阵看做线性映射）"><a href="#矩阵的标准型：相似变换（把矩阵看做线性映射）" class="headerlink" title="矩阵的标准型：相似变换（把矩阵看做线性映射）"></a>矩阵的标准型：相似变换（把矩阵看做线性映射）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.30.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.15.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.16.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="矩阵的标准型：相合变换（二次型）"><a href="#矩阵的标准型：相合变换（二次型）" class="headerlink" title="矩阵的标准型：相合变换（二次型）"></a>矩阵的标准型：相合变换（二次型）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.34.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.35.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.36.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.36.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h3><p>PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</p><p>选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/e01296f282109b59e18086843866f81a_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如图中如果想要将二维转化为一维，若想少丢失信息，则应将投影尽可能的分散。而这种分散程度，可以用数学上的方差来表述。</p><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</p><p>考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。数学上可以用两个字段的协方差表示其相关性。</p><p>至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。</p><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.07.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.16.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.17.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.18.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.19.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.19.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>最后需要说明的是，PCA是一种无参数技术，也就是说面对同样的数据，如果不考虑清洗，谁来做结果都一样，没有主观参数的介入，所以PCA便于通用实现，但是本身无法个性化的优化。</p><h3 id="（奇异值分解）SVD"><a href="#（奇异值分解）SVD" class="headerlink" title="（奇异值分解）SVD"></a>（奇异值分解）SVD</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.48.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.54.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.55.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="SVD与PCA"><a href="#SVD与PCA" class="headerlink" title="SVD与PCA"></a>SVD与PCA</h3><p>我们讲到要用PCA降维，需要找到样本协方差矩阵的最大的k个特征向量，然后用这最大的k个特征向量张成的矩阵来做低维投影降维。 SVD也可以得到协方差矩阵最大的k个特征向量张成的矩阵。 就是说，PCA算法可以不用做特征分解，而是做SVD来完成。</p><h1 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.06.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.08.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.14.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.08.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最小二乘法是经常使用的优化算法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.38.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/v2-079ffd6e8865d3644fd2cfa1e7521e79_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于目标函数，我们限定是凸函数；对于优化变量的可行域（注意，还要包括目标函数定义域的约束），我们限定它是凸集。同时满足这两个限制条件的最优化问题称为凸优化问题，这类问题有一个非常好性质，那就是局部最优解一定是全局最优解。</p><p><strong>凸集</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.00.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.19.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.42.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%887.47.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%887.50.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%888.22.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%889.34.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%888.24.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.09.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.21.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="优化问题举例：EM算法简介与混合高斯模型"><a href="#优化问题举例：EM算法简介与混合高斯模型" class="headerlink" title="优化问题举例：EM算法简介与混合高斯模型"></a>优化问题举例：EM算法简介与混合高斯模型</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.38.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.39.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.44.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.46.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.49.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.51.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.51.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>第一步（E）:如果这个混合模型中，每一次的输出我们知道它是从哪一个模型里边出来的就好了</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>第二步（M）：最大化似然函数</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.53.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%8812.47.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>逐次逼近最优解。</p><h1 id="凸优化进阶"><a href="#凸优化进阶" class="headerlink" title="凸优化进阶"></a>凸优化进阶</h1><h2 id="机器学习与优化"><a href="#机器学习与优化" class="headerlink" title="机器学习与优化"></a>机器学习与优化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.57.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="共轭函数与对偶方法"><a href="#共轭函数与对偶方法" class="headerlink" title="共轭函数与对偶方法"></a>共轭函数与对偶方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.05.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>给定一个优化问题，如果比较复杂，可以转化为优化问题的对偶问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.10.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.29.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>勒让德（Legendre）变化的理解：函数上境图的支撑超平面的截距。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.09.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对偶（共轭）函数抓住了原来函数的一些性质，没有抓住全部性质，抓住了原来函数凸闭包的性质。非凸函数的凸闭包函数是最接近其性质的凸函数，所以可以拿来做近似。第一个结论告诉我勒让德变换抓的是凸包的性质，第二个性质告诉我们，如果是凸函数了。变成共轭函数了没有丢失信息，再做一次变换还能变回来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.48.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第三点说明对于一般的函数，共轭变换是丢失了一部分信息的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.50.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>第二点说的就是几何性质。</p><h2 id="对偶问题：拉格朗日对偶问题"><a href="#对偶问题：拉格朗日对偶问题" class="headerlink" title="对偶问题：拉格朗日对偶问题"></a>对偶问题：拉格朗日对偶问题</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.38.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于没有约束条件的问题，可以使用牛顿法。对于有约束条件的问题，最优解可能不在可行域里，这时就不太好解了。</p><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.35.31.png" alt=""><br>当对一群线性函数取逐点极小值的时候，得到的是一个凹函数。所以g函数是一个凹函数。其中x属于全部定义域，是没有约束条件的，这样再做就比较简单。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们将一个待求函数比较简单但约束条件比较复杂得问题转换为了一个待求函数比较复杂但约束条件比较简单的问题。把问题的复杂性转化到了函数里面去。待求函数不管凸的凹的可以用牛顿法去做逼近。</p><p>那转化后的问题与原问题有什么关系呢？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.25.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.28.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用g的上界提供了原问题的下界。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.52.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>d是g的最大值，p是f的最小值。</p><h2 id="强对偶性条件"><a href="#强对偶性条件" class="headerlink" title="强对偶性条件"></a>强对偶性条件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.50.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>凸优化问题比较容易去求解，但是为什么还需要求对偶变化呢，是因为约束条件比较复杂。需要简化。</p><p>当你是对偶问题时，在凸性上一定是变好的，但是不一定能抓住原来问题的所有性质。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.43.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.43.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.45.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.19.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.20.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.22.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.52.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>琴生不等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.54.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.47.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.48.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上确界（Supremum）：一个集合的最小上界， 数学符号sups<br>下确界（greatest lower boundinf）：一个集合的最大下界,数学符号inf<br>上确界与最大值：上确界类似于最大值，但是和最大值不同的是，最大值有时候会遇到无法取到的情况。比如x∈R,x&lt;2这样的情况下就不存在一个确定的最大值。但是可以确定上确界为2。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.50.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.53.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.21.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>a,x都是向量，b是常数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.24.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.26.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.26.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>简单来说仿射变换就是线性变换加平移。线性变化中原点还在原点，但仿射变换后，原点就移动了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%889.18.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如何通俗地讲解「<em>仿射变换</em>」这个概念？ - 马同学的回答 - 知乎<br><a href="https://www.zhihu.com/question/20666664/answer/157400568" target="_blank" rel="noopener">https://www.zhihu.com/question/20666664/answer/157400568</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.28.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将前z维每一项都除以最后一维t,将最后一项t舍弃。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.29.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.30.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.32.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.33.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.34.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.35.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.41.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.47.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.51.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>分割使用的是n-1维的超平面。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.53.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.56.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.00.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>等式条件定义了一个球面，球面不是一个凸集合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.20.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时把支持向量机问题转化为了一个凸优化问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.32.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.36.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.40.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.44.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.48.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.56.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>允许c和d有一部分交叉。<br>或者使用核方法，将维度增加，再进行划分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.58.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.01.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.03.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>C抜D抜离得最近的两个点的垂直平分线。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.06.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.08.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="压缩感知与图像处理"><a href="#压缩感知与图像处理" class="headerlink" title="压缩感知与图像处理"></a>压缩感知与图像处理</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.13.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.20.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.22.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.24.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.24.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.25.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.25.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="算法和理论与数学知识点"><a href="#算法和理论与数学知识点" class="headerlink" title="算法和理论与数学知识点"></a>算法和理论与数学知识点</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.52.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性代数进阶&quot;&gt;&lt;a href=&quot;#线性代数进阶&quot; class=&quot;headerlink&quot; title=&quot;线性代数进阶&quot;&gt;&lt;/a&gt;线性代数进阶&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常见的几种最优化方法</title>
    <link href="https://github.com/zdkswd/2018/10/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/zdkswd/2018/10/22/常见的几种最优化方法/</id>
    <published>2018-10-22T13:32:51.000Z</published>
    <updated>2018-11-06T05:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/maybe2030/p/4751804.html" target="_blank" rel="noopener">Math 常见的几种最优化方法 - Poll的笔记 - 博客园</a><br>最优化方法与凸优化，我们研究凸优化，是因为凸优化比较好研究，其实正确的叫法应当叫最优化方法。</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>梯度下降法是最早最简单，也是最为常用的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。<strong>梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/350px-Gradient_descent.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>梯度下降的缺点：</p><ol><li>靠近极小值时收敛速度减慢，如下图所示</li><li>直线搜索时可能会产生一些问题</li><li>可能会“之字形”地下降。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/Banana-SteepDesc.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><p>为什么计算函数极值用梯度下降算法而不直接令导数为0求解<br>并不是所有的函数都可以根据导数求出取得0值的点的, 现实的情况可能是:<br>1、可以求出导数在每个点的值, 但是直接解方程解不出来,<br>2、计算机更加适合用循环迭代的方法来求极值。</p><h2 id="批量梯度下降法（BGD）"><a href="#批量梯度下降法（BGD）" class="headerlink" title="批量梯度下降法（BGD）"></a>批量梯度下降法（BGD）</h2><p>最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</p><h2 id="随机梯度下降法（SGD）"><a href="#随机梯度下降法（SGD）" class="headerlink" title="随机梯度下降法（SGD）"></a>随机梯度下降法（SGD）</h2><p>最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。</p><p><strong>两者的关系可以这样理解：随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</strong></p><h1 id="牛顿法和拟牛顿法"><a href="#牛顿法和拟牛顿法" class="headerlink" title="牛顿法和拟牛顿法"></a>牛顿法和拟牛顿法</h1><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p><a href="https://matongxue.com/madocs/205.html" target="_blank" rel="noopener">如何通俗易懂地讲解牛顿迭代法？</a><br>五次及以上多项式方程没有根式解（就是没有像二次方程那样的万能公式）。没有根式解不意味着方程解不出来，数学家也提供了很多方法，牛顿迭代法就是其中一种。</p><h3 id="代数解法"><a href="#代数解法" class="headerlink" title="代数解法"></a>代数解法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-18%20%E4%B8%8A%E5%8D%8810.30.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="不总是收敛（不总是能求得足够近似的根）"><a href="#不总是收敛（不总是能求得足够近似的根）" class="headerlink" title="不总是收敛（不总是能求得足够近似的根）"></a>不总是收敛（不总是能求得足够近似的根）</h3><p>充分条件：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-18%20%E4%B8%8A%E5%8D%8810.28.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也就是说有很多情况下选择牛顿法，根不收敛。</p><p>而且不能完整求出所有的根，只能求到起始点附近的根。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>应用牛顿法最好：</p><ol><li>函数在整个定义域内最好是二阶可导的</li><li>起始点对求根计算影响重大，可以增加一些别的手段进行试错。</li></ol><h3 id="求解最值问题"><a href="#求解最值问题" class="headerlink" title="求解最值问题"></a>求解最值问题</h3><p>牛顿法也被用于求函数的最值。由于函数取最值的点处的导数值为零，故可用牛顿法求导函数的零点，其迭代式为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/b812c8fcc3cec3fddbb30b10dd88d43f869427c1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="高维情况的牛顿迭代式"><a href="#高维情况的牛顿迭代式" class="headerlink" title="高维情况的牛顿迭代式"></a>高维情况的牛顿迭代式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/0_1307264790QzWk.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>高维情况依然可以用牛顿迭代求解，但是问题是Hessian矩阵引入的复杂性，使得牛顿迭代求解的难度大大增加，但是已经有了解决这个问题的办法就是Quasi-Newton methond，不再直接计算hessian矩阵，而是每一步的时候使用梯度向量更新hessian矩阵的近似。</p><h3 id="关于牛顿法与梯度下降法效率的对比"><a href="#关于牛顿法与梯度下降法效率的对比" class="headerlink" title="关于牛顿法与梯度下降法效率的对比"></a>关于牛顿法与梯度下降法效率的对比</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/697b070fjw1dvpdvu65zij.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</p><p>根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：二阶收敛，收敛速度快；<br>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</p><h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2><p><strong>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。</strong>拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p><p>针对牛顿法中海塞矩阵的计算问题，拟牛顿法主要是使用一个海塞矩阵的近似矩阵来代替原来的还塞矩阵，通过这种方式来减少运算的复杂度。其主要过程是先推导出海塞矩阵需要满足的条件，即拟牛顿条件（也可以称为拟牛顿方程）。然后我们构造一个满足拟牛顿条件的近似矩阵来代替原来的海塞矩阵。</p><p>外，在满足拟牛顿条件的基础上如何构造近似的海塞矩阵，这有很多种方法，比如：DFP算法，BFGS算法，L-BFGS算法以及Broyden类算法等。常用前两种。</p><p>在牛顿法推导中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090055594094281.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后对f(x)求偏导：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090056311435787.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令x=xk得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090057071597116.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>g等于f的一阶导。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090057354245982.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>简化：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090058041599302.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>于是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090100178627788.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在满足此条件的基础上如何构造近似海塞矩阵呢？下面介绍两个方法：DFP算法和BFGS算法。</p><h3 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a>DFP算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324000528609.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324000539484.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="BFGS算法"><a href="#BFGS算法" class="headerlink" title="BFGS算法"></a>BFGS算法</h3><p>　　BFGS算法是用直接逼近海塞矩阵的方式来构造近似海塞矩阵，同样，我们使用迭代的方式来逐步逼近。我们使用B来表示海塞矩阵的近似矩阵，而在DFP算法中我们是直接使用D来构造近似海塞矩阵的逆矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324001108453.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324001126671.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h1><p><strong>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。</strong> 在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/220px-Conjugate_gradient_illustration.svg.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注：绿色为梯度下降法，红色代表共轭梯度法</strong></p><h1 id="启发式优化方法"><a href="#启发式优化方法" class="headerlink" title="启发式优化方法"></a>启发式优化方法</h1><p>启发式方法指人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。启发式优化方法种类繁多，包括经典的模拟退火方法、遗传算法、蚁群算法以及粒子群算法等等。</p><p>　　还有一种特殊的优化算法被称之多目标优化算法，它主要针对同时优化多个目标（两个及两个以上）的优化问题，这方面比较经典的算法有NSGAII算法、MOEA/D算法以及人工免疫算法等。</p><h1 id="解决约束优化问题—拉格朗日乘数法"><a href="#解决约束优化问题—拉格朗日乘数法" class="headerlink" title="解决约束优化问题—拉格朗日乘数法"></a>解决约束优化问题—拉格朗日乘数法</h1><h2 id="拉格朗日乘数法的基本思想"><a href="#拉格朗日乘数法的基本思想" class="headerlink" title="拉格朗日乘数法的基本思想"></a>拉格朗日乘数法的基本思想</h2><p>　<strong>作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数</strong></p><p>　　<strong>如何将一个含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题？拉格朗日乘数法从数学意义入手，通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解。</strong></p><h2 id="拉格朗日乘数法的基本形态"><a href="#拉格朗日乘数法的基本形态" class="headerlink" title="拉格朗日乘数法的基本形态"></a>拉格朗日乘数法的基本形态</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-22%20%E4%B8%8B%E5%8D%888.56.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="拉格朗日乘数法与KKT条件"><a href="#拉格朗日乘数法与KKT条件" class="headerlink" title="拉格朗日乘数法与KKT条件"></a>拉格朗日乘数法与KKT条件</h2><p>我们上述讨论的问题均为等式约束优化问题，但等式约束并不足以描述人们面临的问题，不等式约束比等式约束更为常见，大部分实际问题的约束都是不超过多少时间，不超过多少人力，不超过多少成本等等。所以有几个科学家拓展了拉格朗日乘数法，增加了KKT条件之后便可以用拉格朗日乘数法来求解不等式约束的优化问题了。</p><p>　<strong>KKT条件是指在满足一些有规则的条件下, 一个非线性规划(Nonlinear Programming)问题能有最优化解法的一个必要和充分条件.</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-22%20%E4%B8%8B%E5%8D%889.07.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/maybe2030/p/4751804.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Math 常见的几种最优化方法 - Poll的笔记 - 博客园&lt;/a&gt;&lt;br&gt;最优化方法与凸优化
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM 事件模型</title>
    <link href="https://github.com/zdkswd/2018/10/21/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/zdkswd/2018/10/21/JavaScript标准参考教程 DOM 事件模型/</id>
    <published>2018-10-21T06:53:56.000Z</published>
    <updated>2018-10-21T06:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件。</p><h1 id="EventTarget接口"><a href="#EventTarget接口" class="headerlink" title="EventTarget接口"></a>EventTarget接口</h1><p>DOM 的事件操作（监听和触发），都定义在<strong>EventTarget</strong>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<strong>XMLHttpRequest</strong>、<strong>AudioNode</strong>、<strong>AudioContext</strong>）也部署了这个接口。</p><p>该接口主要提供三个实例方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.51.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h2><p>EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.52.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>该方法接受三个参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.54.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>例子：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.56.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>关于参数：</p><ol><li>第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.58.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.03.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><p>addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除。</p><p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.06.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>监听函数内部的this，指向当前事件所在的那个对象。</p><h2 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h2><p>EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.08.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p><p>注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.11.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h2><p>EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.15.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>dispatchEvent方法的参数是一个Event对象的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.28.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果dispatchEvent方法的参数为空，或者不是一个有效的事件对象，将报错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.32.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h1><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p><p>JavaScript有三种方法，可以为事件绑定监听函数。</p><h2 id="HTML的on-属性"><a href="#HTML的on-属性" class="headerlink" title="HTML的on-属性"></a>HTML的on-属性</h2><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.34.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，这些属性的值是将会执行的代码，而不是一个函数。一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p><p>使用这个方法指定的监听代码，只会在冒泡阶段触发。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.38.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，&lt; button&gt;是&lt; div&gt;的子元素。&lt; button&gt;的click事件，也会触发&lt; div&gt;的click事件。由于on-属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出1，再输出2，即事件从子元素开始冒泡到父元素。</p><p>直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.38.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h2><p>元素节点对象的事件属性，同样可以指定监听函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.42.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p><p>注意，这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。</p><h2 id="EventTarget-addEventListener-1"><a href="#EventTarget-addEventListener-1" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h2><p>所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.43.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</li><li>“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。</li><li>EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.50.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1>监听函数内部的this指向触发事件的那个元素节点。<h1 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h1>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.54.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.58.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.59.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h1>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8811.00.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>上面代码中，click事件的监听函数定义在&lt; ul&gt;节点，但是实际上，它处理的是子节点&lt; li&gt;的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个&lt; li&gt;节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</li></ol><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。</p><p>但是，stopPropagation方法只会阻止事件的传播，不会阻止该事件触发&lt; p&gt;节点的其他click事件的监听函数。也就是说，不是彻底取消click事件。</p><p>如果想要彻底阻止这个事件的传播，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.31.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Event对象概述"><a href="#Event对象概述" class="headerlink" title="Event对象概述"></a>Event对象概述</h1><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。</p><p>Event对象本身就是一个构造函数，可以用来生成新的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.35.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.36.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.38.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码新建一个look事件实例，然后使用dispatchEvent方法触发该事件。</p><p>注意，如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数。</p><h1 id="Event对象的实例属性"><a href="#Event对象的实例属性" class="headerlink" title="Event对象的实例属性"></a>Event对象的实例属性</h1><h2 id="Event-bubbles，Event-eventPhase"><a href="#Event-bubbles，Event-eventPhase" class="headerlink" title="Event.bubbles，Event.eventPhase"></a>Event.bubbles，Event.eventPhase</h2><p>Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，Event构造函数生成的事件，默认是不冒泡的。</p><p>Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.51.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Event.eventPhase的返回值有四种可能。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.51.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Event-cancelable，Event-cancelBubble，event-defaultPrevented"><a href="#Event-cancelable，Event-cancelBubble，event-defaultPrevented" class="headerlink" title="Event.cancelable，Event.cancelBubble，event.defaultPrevented"></a>Event.cancelable，Event.cancelBubble，event.defaultPrevented</h2><p>Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p><p>大多数浏览器的原生事件是可以取消的。比如，取消click事件，点击链接将无效。但是除非显式声明，Event构造函数生成的事件，默认是不可以取消的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.54.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。</p><p>如果事件不能取消，调用Event.preventDefault()会没有任何效果。所以使用这个方法之前，最好用Event.cancelable属性判断一下是否可以取消。</p><p>Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。</p><h2 id="Event-currentTarget，Event-target"><a href="#Event-currentTarget，Event-target" class="headerlink" title="Event.currentTarget，Event.target"></a>Event.currentTarget，Event.target</h2><p>Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</p><p>Event.target属性返回原始触发事件的那个节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.07.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也就是currentTarget—&gt;p节点。&lt; em&gt;子节点上面点击，则e.target指向&lt; em&gt;子节点，导致&lt; em&gt;子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个para都将不可见。</p><h2 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h2><p>Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.09.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Event-timeStamp"><a href="#Event-timeStamp" class="headerlink" title="Event.timeStamp"></a>Event.timeStamp</h2><p>Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.10.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p><h2 id="Event-isTrusted"><a href="#Event-isTrusted" class="headerlink" title="Event.isTrusted"></a>Event.isTrusted</h2><p>Event.isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个click事件，该事件是用户产生的；Event构造函数生成的事件，则是脚本产生的。</p><h2 id="Event-detail"><a href="#Event-detail" class="headerlink" title="Event.detail"></a>Event.detail</h2><p>Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于click和dbclick事件，Event.detail是鼠标按下的次数（1表示单击，2表示双击，3表示三击）；对于鼠标滚轮事件，Event.detail是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p><h1 id="Event-对象的实例方法"><a href="#Event-对象的实例方法" class="headerlink" title="Event 对象的实例方法"></a>Event 对象的实例方法</h1><h2 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h2><p>Event.preventDefault方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的cancelable属性为true，如果为false，调用该方法没有任何效果。</p><p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用stopPropagation()或stopImmediatePropagation()方法。</p><h2 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h2><p>stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p><h2 id="Event-stopImmediatePropagation"><a href="#Event-stopImmediatePropagation" class="headerlink" title="Event.stopImmediatePropagation()"></a>Event.stopImmediatePropagation()</h2><p>Event.stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比Event.stopPropagation()更彻底。</p><h2 id="Event-composedPath"><a href="#Event-composedPath" class="headerlink" title="Event.composedPath()"></a>Event.composedPath()</h2><p>Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p><h1 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h1><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.32.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>CustomEvent()构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。CustomEvent的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.34.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.35.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有detail属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件。&lt;/p&gt;
&lt;h1 id=&quot;EventTarget接口&quot;&gt;&lt;a href=&quot;#EventTarget接口&quot; class=&quot;headerlink&quot; title=&quot;EventTarge
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown线性代数</title>
    <link href="https://github.com/zdkswd/2018/10/15/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/10/15/3Blue1Brown线性代数/</id>
    <published>2018-10-15T10:05:32.000Z</published>
    <updated>2018-10-15T10:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量究竟是什么"><a href="#向量究竟是什么" class="headerlink" title="向量究竟是什么"></a>向量究竟是什么</h1><p>在数学中向量以原点为起点，在空间中是一个有向的箭头，每一个位置上的数值代表在对应轴上的数值。为了与点区分，所以向量竖着写。</p><p>向量的加法<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.07.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>向量的乘法<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.11.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.14.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>线性代数围绕两种基本运算：向量加法与向量数乘。</strong></p><h1 id="线性组合、张成的空间与基"><a href="#线性组合、张成的空间与基" class="headerlink" title="线性组合、张成的空间与基"></a>线性组合、张成的空间与基</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.17.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基向量。</p><p><strong>当我们用数字描述向量时，都依赖于我们所选择的基。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.20.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在二维空间中，如果<strong>v</strong>,<strong>w</strong>不共线且不为零向量，那么理论上a<strong>v</strong>+b<strong>w</strong>就可以表示二维空间中所有的向量。 </p><p>为什么叫线性组合，如果固定其中一个向量那么只能表示部分向量，这些向量的末端构成一条直线。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.28.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.30.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么。</strong></p><p><strong>向量VS点</strong>：<br><strong>可以用点来代替一个起点为原点，终点在该点上的一个向量。</strong></p><p>三维向量：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.36.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>三个向量的线性组合的张成空间同理。 </p><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.46.04.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.46.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>线性相关：一个向量在其他向量线性组合的张成空间中，即这个向量没有提高所有向量组成的张成空间的维度。</p><p>线性无关：每一个向量都起到了提高张成空间维度的作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.49.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="矩阵与线性变换"><a href="#矩阵与线性变换" class="headerlink" title="矩阵与线性变换"></a>矩阵与线性变换</h1><p>变换只不过是函数的一种花哨说法，它接收输入内容，并输出对应结果。在线性代数中考虑的是向量输入，输出一个向量。那为什么不用函数这个词呢？变换这个词在暗示用<strong>运动</strong>去思考。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.55.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果一个变换有以下两条性质，我们就称它是线性的：一是直线在变换后仍然保持为直线，不能有所弯曲。二是原点保持固定。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.30.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如上不是线性变换。 </p><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.30.34.png" alt=""><br>如上为线性变换</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.31.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.31.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>变换后的坐标。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.34.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于线性变换后对于基向量的线性组合的值不变，所以只需要知道基向量的变换就可以算出变换后的任意向量的坐标。<br> 变换后的<strong>i</strong>,<strong>j</strong>。一个在<strong>标准网格</strong>的坐标系中的一个向量(x,y)<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.36.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标（<strong>标准网格下的坐标</strong>）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.39.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 矩阵在这里只是一个记号，它含有描述一个线性变换的信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.44.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="矩阵乘法与线性变换复合"><a href="#矩阵乘法与线性变换复合" class="headerlink" title="矩阵乘法与线性变换复合"></a>矩阵乘法与线性变换复合</h1><p>两个独立变换可以进行复合变换<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.50.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>先旋转再剪切。</p><p>两个矩阵相乘有着几何意义，也就是两个线性变换相继作用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.52.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>之所以能这么做是因为它们都在同一个坐标系下，即标准网格坐标系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.03.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>三维空间中的线性变换同理。</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.14.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>描述一个线性变换是让面积（对二维来说是面积，三维就是体积）拉伸还是挤压了。</p><p>也就是说如果一个行列式为0，那就是变换后成了一条线（对二维俩说）。推广就是计算一个矩阵的行列式，我们就能了解这个矩阵代表的变换是否将空间压缩到更小的维度上。</p><p>当空间定向改变的情况发生时，原本j在i的左侧，现在j在i的右侧了，行列式为负。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.28.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="逆矩阵、列空间与零空间"><a href="#逆矩阵、列空间与零空间" class="headerlink" title="逆矩阵、列空间与零空间"></a>逆矩阵、列空间与零空间</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.39.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.39.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>逆矩阵就是逆变换。只要变换不讲空间压缩到更低维度，就有逆变换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.21.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>即使压缩到更低的维度，解依然有可能存在，当<strong>x</strong>恰好在直线上时，解就存在。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.48.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.53.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>列空间就是矩阵的列所张成的空间。秩的更精确的定义是列空间的维数。满秩是指输入空间的维度等于矩阵的秩。对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身。对于非满秩的变换，将维度压缩到更低的维度，也就是说会有一系列的向量会压缩到原点。在变换后落在原点的向量集合，被称为所选矩阵的<strong>零空间</strong>或<strong>核</strong>。</p><h1 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.40.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.50.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>几何意义是将二维空间映射到三维空间上。矩阵有两列表明输入空间有两个基向量，三维是表明变换到了三维空间坐标系中，张成空间为三维空间的一个过原点的二维平面，矩阵依然是满秩的，因为列空间的维数与输入空间的维数相等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.46.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.47.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="点积与对偶性"><a href="#点积与对偶性" class="headerlink" title="点积与对偶性"></a>点积与对偶性</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.52.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.53.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里可以看做是二维空间压缩到一维的数轴上，由于变换是线性的，所以可以用一个1*2的矩阵来表示变换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8811.07.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.19.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="叉乘的标准介绍"><a href="#叉乘的标准介绍" class="headerlink" title="叉乘的标准介绍"></a>叉乘的标准介绍</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.08.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>顺序不同，正负不同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这里才是真正的叉乘：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.13.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>方向右手定则。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.15.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="以线性变换的眼光看叉乘"><a href="#以线性变换的眼光看叉乘" class="headerlink" title="以线性变换的眼光看叉乘"></a>以线性变换的眼光看叉乘</h1><p>为什么上述的式子中要用到ijk?下面就来解释。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.22.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>真正的三维向量的叉乘接收两个向量并输出一个向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.37.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.31.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个函数的几何意义在于，对于任一输入的向量（x,y,z),你都考虑它和v,w确定的平行六面体得到它的体积，然后根据取向确定符号。<strong>这个函数是线性的</strong>。</p><p>一旦知道它是线性的，就可以知道可以通过矩阵乘法来描述这个函数。具体地说，因为这个函数从三维空间到一维空间，就会存在一个1*3矩阵来代表这个变换。根据对偶性，从多维空间到一维空间的变换的特别之处在于可以将整个变换看做与这个特定向量的点积。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.42.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.45.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们要找的就是<strong>P</strong>，使得p与其他任意向量（x,y,z）的点积等于一个3* 3矩阵的行列式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.51.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从算数角度上来说<strong>p</strong>就是 （。。。。）i+（。。。。）j+（。。。。）k<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.56.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从几何的角度：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.33.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>左边式子，向量p与其他向量的点积的几何解释，是将其他向量投影到p上。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.59.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>右面式子是(x,y,z)的垂直分量*底部面积。和垂直于v,w且长度等于平行四边形面积的向量与（x,y,z）点乘一样。所以p垂直v,w且长度为平行四边形的面积。</p><p>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.33.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h1><p>线性变换中一个坐标系中的所有向量都跟着动，变换后的向量仍旧是相同的线性组合，不过使用的是新的基向量。基变换中，一个向量是不动的，动的是坐标系。</p><p>詹的坐标系：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.52.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>一个我们坐标系中的向量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.53.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>詹系中对它的描述：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.54.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>詹的基在我们系中的向量坐标：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.55.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>詹的基自己的坐标：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.56.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>不同的坐标系（基）对于空间内同一个向量的描述是不同的，也就是描述的语言不同。</p><p>不同的基的坐标原点是重合的。如何在不同的坐标系之间进行转化：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.00.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.02.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>式1</p><p>就是将（-1，2）进行线性变换后，可以变为黄色的向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.10.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以把这个式子看作是我们把我们对詹的误解（詹的坐标系下的数值直接拿到标准网格坐标系里）转化为真实的詹的所指，都是在标准网格坐标系下。</p><p>同理，如果取逆。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.14.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这时可以求在标准网格坐标系中的某点，在詹坐标系下的值。可在式一两侧左边同时乘以逆来很好的推出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.43.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果想要旋转90度，詹的基该如何表示？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.24.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>开始是一个詹下的向量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.24.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们转为我们的语言，在标准网格下的一个向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.25.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>此时再进行旋转操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.27.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>最后左乘一个逆矩阵，将其转换为詹的语言。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.28.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这就是詹的语言下旋转的操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.29.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h1><p>在线性变换中，有的向量并不改变方向，只是拉伸或者缩小。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.36.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.36.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.37.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>、<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.37.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这些向量就叫特征向量，每个特征向量都有一个所属的值，拉伸倍数叫做特征值。</p><p>如果在三维变化中找到这个特征向量，那它就是旋转轴</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.44.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="抽象空间本质"><a href="#抽象空间本质" class="headerlink" title="抽象空间本质"></a>抽象空间本质</h1><p>向量是什么？</p><p>从某种意义上来说函数也是向量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%884.55.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%884.56.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>x,y,z是三个点的纵坐标。</p><p>同时也存在另一个函数转换为另一个函数的操作（对应线性变化），例如求导。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.03.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可见函数是线性的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.13.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.13.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>抽象性带来的好处是我们能得到一般性的结论。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.16.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.16.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.17.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.19.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.21.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所以，什么是向量？数学中有许多类似向量的事物，只要你处理的对象集具有合理的数乘和相加概念，线性代数中所有关于向量、线性变换和其他等产生的概念都应该适用于它。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.23.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这些类似向量的事物，比如箭头、一组数、函数等，它们构成的集合被称为“向量空间”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.24.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.26.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.28.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足八条公理。这些公理是一个接口，一边连着应用线代的人，另一边是数学家。</p><p>只要满足八条公理，就可以将线代应用到你的研究对象上，而数学家则是根据这些公理证明了你的结论。</p><p>向量可以是任何东西，只要它满足公理。回答向量是什么，就像回答3是什么一样。</p><p><strong>普适的代价是抽象。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向量究竟是什么&quot;&gt;&lt;a href=&quot;#向量究竟是什么&quot; class=&quot;headerlink&quot; title=&quot;向量究竟是什么&quot;&gt;&lt;/a&gt;向量究竟是什么&lt;/h1&gt;&lt;p&gt;在数学中向量以原点为起点，在空间中是一个有向的箭头，每一个位置上的数值代表在对应轴上的数值。为了与点
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础上</title>
    <link href="https://github.com/zdkswd/2018/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/"/>
    <id>https://github.com/zdkswd/2018/10/13/机器学习数学基础上/</id>
    <published>2018-10-13T11:08:47.000Z</published>
    <updated>2018-11-06T05:38:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><p>见李宏毅第0课。</p><h2 id="得分函数"><a href="#得分函数" class="headerlink" title="得分函数"></a>得分函数</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>权重需要训练得到。</p><h2 id="损失函数最优化"><a href="#损失函数最优化" class="headerlink" title="损失函数最优化"></a>损失函数最优化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.13.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>左边是非凸函数，右边是凸函数。通过优化损失函数来调整权值。</p><h2 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h2><p>琴生不等式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.45.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="微积分基础"><a href="#微积分基础" class="headerlink" title="微积分基础"></a>微积分基础</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.19.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>梯度是一个点上升最快的方向。<br>梯度下降法。</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>通俗语言适合于说给对方听，数学记号适合于写给对方看，精确描述比较啰嗦但是非常精确不会造成误解，主要用于证明。不会出错。</p><p>无穷小的阶数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.17.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.18.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="微分学"><a href="#微分学" class="headerlink" title="微分学"></a>微分学</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.28.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.30.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.30.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.35.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.38.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>求导用链式法则。</p><h2 id="积分学"><a href="#积分学" class="headerlink" title="积分学"></a>积分学</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.19.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.20.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="泰勒级数。"><a href="#泰勒级数。" class="headerlink" title="泰勒级数。"></a>泰勒级数。</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.51.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.56.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="牛顿法与梯度下降法"><a href="#牛顿法与梯度下降法" class="headerlink" title="牛顿法与梯度下降法"></a>牛顿法与梯度下降法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.29.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.32.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.38.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为什么不用牛顿法：<br>原因一：牛顿法需要用到梯度和Hessian矩阵，这两个都难以求解。因为很难写出深度神经网络拟合函数的表达式，遑论直接得到其梯度表达式，更不要说得到基于梯度的Hessian矩阵了。<br>原因二：即使可以得到梯度和Hessian矩阵，当输入向量的维度NNN较大时，Hessian矩阵的大小是N×NN×NN\times N，所需要的内存非常大。<br>原因三：在高维非凸优化问题中，鞍点相对于局部最小值的数量非常多，而且鞍点处的损失值相对于局部最小值处也比较大。而二阶优化算法是寻找梯度为0的点，所以很容易陷入鞍点。</p><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.40.10.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.50.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="为什么研究凸函数，凸优化？"><a href="#为什么研究凸函数，凸优化？" class="headerlink" title="为什么研究凸函数，凸优化？"></a>为什么研究凸函数，凸优化？</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.52.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%889.21.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="概率与统计基础"><a href="#概率与统计基础" class="headerlink" title="概率与统计基础"></a>概率与统计基础</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.48.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.49.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>统计问题是概率问题的逆向工程。<br>概率问题是已知总体的情况，求一次的概率。统计问题则是根据样本的情况反推总体的情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.55.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.57.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="概率统计与机器学习的关系"><a href="#概率统计与机器学习的关系" class="headerlink" title="概率统计与机器学习的关系"></a>概率统计与机器学习的关系</h2><p><strong>概率统计与机器学习天然相关</strong>，训练的过程可以看做是统计过程，预测过程可以看做是概率过程。预测分类就是选择一个概率最大的分类。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%885.02.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以观察各个特征的分布以及标签的分布，筛选出相关性强的特征。</p><ul><li>可基于各个分布的特性来评估模型和样本。</li><li>统计估计的是分布，机器学习训练出来的是模型，模型可能包含了很多的分布。</li><li>训练与预测过程的一个核心评价指标就是模型的误差</li><li>误差本身就可以使概率形式，与概率紧密相关。</li><li>对误差的不同定义方式就演化成了不同损失函数的定义方式。</li><li>机器学习是概率与统计的进阶版本。（不严谨的说法）</li></ul><p>方差<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.40.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>协方差<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.19.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可评估两个分布之间的关系。定义公式几何意义：协方差可以理解成特征进行预处理之后（去均值化，机器学习里比较重要的一个数据预处理的方法）对应的向量的几何的<strong>内积</strong>。协方差是评价两个变量的线性关系。如果是非线性关系，评价不出来。</p><p>相关系数是研究变量之间线性相关程度地量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.30.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>var是方差。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.34.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.22.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.23.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.26.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.28.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.32.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.34.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>先验——根据若干年的统计（经验）或者气候（常识），某地方下雨（因）的概率；</p><p>似然/类条件概率——在下雨（因）的情况下，观测到了乌云（果）的概率，即原因已知时，结果出现的概率；</p><p>后验——根据天上有乌云（果），得到的下雨（因）的概率，即给定结果估计原因的概率；</p><p>x:观察得到的结果。</p><p>θ：决定数据分布的原因。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.01.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>矩</strong>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%888.54.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>其中t是一个实数，i是虚数单位，E表示期望值。此乃原点矩。E(（X-0）^n)中心矩就是-μ。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.29.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.29.29%202.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.06.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>即大部分都分布在均值周围。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.30.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.03.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.05.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%888.55.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.00.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.13.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.16.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.20.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>没法研究随机变量就研究其特征函数。</p><p>当一个分布不是常见的分布时，根据大数定理，反复做实验就可以得到其期望和方差。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.42.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>大数定理是告诉我们趋近一个数，中心极限定理是告诉我们以何种方式趋近一个数。一个正态分布。</p><h1 id="参数估计（统计学）"><a href="#参数估计（统计学）" class="headerlink" title="参数估计（统计学）"></a>参数估计（统计学）</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.47.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h2><p>利用样本来估计总体分布，总体分布的参数很多情况下是未知的。如均值μ、方差\sigma ^{2} 、泊松分布的λ、二项分布的比例π，其它分布还会有更多的未知参数，需要通过样本进行相应的估计，这种估计值就是点估计。</p><h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.56.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.58.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.03.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.10.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.13.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.16.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.17.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以把概率密度看作是θ和x的联合概率密度，把x固定，那么概率密度最大的地方就是θ最可能的地方。</p><p>不是概率是因为相加起来和不等于1，类似于概率是因为数值大小是有意义的，代表了可能性的大小。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.30.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如何通俗地理解概率论中的「极大似然估计法」? - 马同学的回答 - 知乎<br><a href="https://www.zhihu.com/question/24124998/answer/242682386" target="_blank" rel="noopener">https://www.zhihu.com/question/24124998/answer/242682386</a></p><p>简单来说，极大似然函数就是通过样本来求使得概率（似然）为最大的那个θ值。似然越大，就越有可能是这个θ。所以目的就是让似然函数最大就完事了，然后可以通过对θ的梯度下降法，使得似然函数求最大，也就是损失函数为负的似然函数求最小。</p><h3 id="点估计的评判准则"><a href="#点估计的评判准则" class="headerlink" title="点估计的评判准则"></a>点估计的评判准则</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.03.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><p>对于未知参数，点估计值只是一个近似值，会存在或大或小误差，这时给一个范围可能是更合适，也是更可信的。比如从北京到张家界旅游5天，你恐怕不能准确说出要花多少钱，但你可以给出一个范围，比如10000—13000，你会觉得比较可信。如果给的范围太大，比如10000—30000，虽然可信度更高一些，但这么大的范围参考意义不大；如果给的范围很小，如10000——10500，则准确性提高了，但可信度就似乎不会很高。找到一个合适的估值范围，这是<strong>置信区间</strong>要解决的问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.13.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="线性代数基础"></a>线性代数基础</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.52.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.53.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.55.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%8812.05.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>（1）保持加法（2）保持乘法。<br>线性映射是最简单的研究对象，用线性映射去逼近别的东西。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%8812.11.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>线性变换与矩阵的关系，对任何向量x进行线性变换T的结果向量，是一个对基向量组进行线性变换T之后的新向量组的一个线性组合，<strong>系数</strong>没变。</p><p>只需要知道两个基向量i向量和j向量转换之后的的结果，而不用知道转换本身，我们就能推导出二维空间中所有向量转换之后的结果。</p><h2 id="Ax的几何意义"><a href="#Ax的几何意义" class="headerlink" title="Ax的几何意义"></a>Ax的几何意义</h2><p>矩阵乘向量，列向量的线性组合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.45.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="svd的几何意义。"><a href="#svd的几何意义。" class="headerlink" title="svd的几何意义。"></a>svd的几何意义。</h2><p>一个很重要的降维算法。</p><h2 id="矩阵乘法在计算中的优势"><a href="#矩阵乘法在计算中的优势" class="headerlink" title="矩阵乘法在计算中的优势"></a>矩阵乘法在计算中的优势</h2><ul><li>将很多for循环写成矩阵或者向量乘法的方式。</li><li>矩阵计算模块在底层有优化。</li><li>numpy进行矩阵运算很快。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习基础&quot;&gt;&lt;a href=&quot;#机器学习基础&quot; class=&quot;headerlink&quot; title=&quot;机器学习基础&quot;&gt;&lt;/a&gt;机器学习基础&lt;/h1&gt;&lt;p&gt;见李宏毅第0课。&lt;/p&gt;
&lt;h2 id=&quot;得分函数&quot;&gt;&lt;a href=&quot;#得分函数&quot; class=&quot;head
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment</title>
    <link href="https://github.com/zdkswd/2018/10/12/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/"/>
    <id>https://github.com/zdkswd/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/</id>
    <published>2018-10-12T13:13:56.000Z</published>
    <updated>2018-10-12T13:13:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h1><p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p><p>属性本身是一个对象（Attr对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（HTMlElement对象）来操作属性。本章介绍如何操作这些属性。</p><h2 id="Element-attributes属性"><a href="#Element-attributes属性" class="headerlink" title="Element.attributes属性"></a>Element.attributes属性</h2><p>元素对象有一个attributes属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有attributes属性，但返回的都是null，因此可以把这个属性视为元素对象独有的。</p><p>单个属性可以通过序号引用，也可以通过属性名引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.41.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>返回的都是属性节点对象，而不是属性值。属性节点对象有name和value属性，对应该属性的属性名和属性值，等同于nodeName属性和nodeValue属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.43.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="元素的标准属性"><a href="#元素的标准属性" class="headerlink" title="元素的标准属性"></a>元素的标准属性</h2><p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.46.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这些属性都是可写的。这种修改属性的方法，常常用于添加表单的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.47.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码为表单添加提交网址和提交方法。</p><p>注意，这种用法虽然可以读写属性，但是无法删除属性，delete运算符在这里不会生效。</p><p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如onClick。</p><p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改<br>名。主要是以下两个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.48.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="headerlink" title="属性操作的标准方法"></a>属性操作的标准方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>元素节点提供四个方法，用来操作属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.49.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ol><li>适用性   这四个方法对所有的属性（包括用户自定义的属性）都适用。</li><li>返回值    getAttribute()只返回字符串，不会返回其他类型的值。</li><li>属性名     这些方法只接受属性的标准名称，不用改写保留字，比如for和class都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</li></ol><h3 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h3><p>lement.getAttribute方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。</p><h3 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h3><p>Element.setAttribute方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。</p><h3 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h3><p>Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p><h3 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h3><p>Element.removeAttribute方法用于从当前元素节点移除属性。</p><h2 id="dataset-属性"><a href="#dataset-属性" class="headerlink" title="dataset 属性"></a>dataset 属性</h2><p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。使用标准提供的data-*属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.54.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后，使用元素节点对象的dataset属性，它指向一个对象，可以用来操作 HTML 元素标签的data-*属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.55.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过dataset.foo读写data-foo属性。删除一个data-*属性，可以直接使用delete命令。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.57.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>除了dataset属性，也可以用getAttribute(‘data-foo’)、removeAttribute(‘data-foo’)、setAttribute(‘data-foo’)、hasAttribute(‘data-foo’)等方法操作data-*属性。</p><h1 id="Text节点和DocumentFragment节点"><a href="#Text节点和DocumentFragment节点" class="headerlink" title="Text节点和DocumentFragment节点"></a>Text节点和DocumentFragment节点</h1><h2 id="Text节点的概念"><a href="#Text节点的概念" class="headerlink" title="Text节点的概念"></a>Text节点的概念</h2><p>文本节点（Text）代表元素节点（Element）和属性节点（Attribute）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p><p>通常我们使用父节点的firstChild、nextSibling等属性获取文本节点，或者使用Document节点的createTextNode方法创造一个文本节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.29.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>浏览器原生提供一个Text构造函数。它返回一个文本节点实例。它的参数就是<br>该文本节点的文本内容。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>文本节点继承了Node接口，所以属性和方法都和Node一样。</p><h2 id="Text节点的属性"><a href="#Text节点的属性" class="headerlink" title="Text节点的属性"></a>Text节点的属性</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data属性等同于nodeValue属性，用来设置或读取文本节点的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.33.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="wholeText"><a href="#wholeText" class="headerlink" title="wholeText"></a>wholeText</h3><p>wholeText属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，wholeText属性的返回值，与data属性和textContent属性相同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.36.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>length属性返回当前文本节点的文本长度。</p><h3 id="nextElementSibling，previousElementSibling"><a href="#nextElementSibling，previousElementSibling" class="headerlink" title="nextElementSibling，previousElementSibling"></a>nextElementSibling，previousElementSibling</h3><p>nextElementSibling属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回null。</p><p>previousElementSibling属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回null：。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.38.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Text节点的方法"><a href="#Text节点的方法" class="headerlink" title="Text节点的方法"></a>Text节点的方法</h2><h3 id="appendData-，deleteData-，insertData-，replaceData-，subStringData"><a href="#appendData-，deleteData-，insertData-，replaceData-，subStringData" class="headerlink" title="appendData()，deleteData()，insertData()，replaceData()，subStringData()"></a>appendData()，deleteData()，insertData()，replaceData()，subStringData()</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>remove方法用于移除当前Text节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.53.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="splitText"><a href="#splitText" class="headerlink" title="splitText()"></a>splitText()</h3><p>splitText方法将Text节点一分为二，变成两个毗邻的Text节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p><p>分割后，该方法返回分割位置后方的字符串，而原Text节点变成只包含分割位置前方的字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.55.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>父元素的normalize方法可以实现逆操作，将它们合并。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.56.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="DocumentFragment节点"><a href="#DocumentFragment节点" class="headerlink" title="DocumentFragment节点"></a>DocumentFragment节点</h2><p>DocumentFragment节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，parentNode返回null，但是可以插入任意数量的子节点。它不属于当前文档，操作DocumentFragment节点，要比直接操作 DOM 树快得多。</p><p>它一般用于构建一个 DOM 结构，然后插入当前文档。document.createDocumentFragment方法，以及浏览器原生的DocumentFragment构造函数，可以创建一个空的DocumentFragment节点。然后再使用其他 DOM 方法，向其添加子节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.58.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码创建了一个DocumentFragment节点，然后将一个li节点添加在它里面，最后将DocumentFragment节点移动到原文档。</p><p><strong>注意</strong>，DocumentFragment节点本身不能被插入当前文档。当它作为appendChild()、insertBefore()、replaceChild()等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦DocumentFragment节点被添加进当前文档，它自身就变成了空节点（textContent属性为空字符串），可以被再次使用。如果想要保存DocumentFragment节点的内容，可以使用cloneNode方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%889.03.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面这样添加DocumentFragment节点进入当前文档，不会清空DocumentFragment节点。</p><p>DocumentFragment节点对象没有自己的属性和方法，全部继承自Node节点和ParentNode接口。也就是说，DocumentFragment节点比Node节点多出以下四个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%889.04.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;属性的操作&quot;&gt;&lt;a href=&quot;#属性的操作&quot; class=&quot;headerlink&quot; title=&quot;属性的操作&quot;&gt;&lt;/a&gt;属性的操作&lt;/h1&gt;&lt;p&gt;HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。&lt;/p&gt;
&lt;p&gt;属性本身是一
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于JavaScript的对象的理解</title>
    <link href="https://github.com/zdkswd/2018/10/11/%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://github.com/zdkswd/2018/10/11/关于JavaScript的对象的理解/</id>
    <published>2018-10-11T11:26:32.000Z</published>
    <updated>2018-10-11T11:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于JavaScript的对象的理解"><a href="#关于JavaScript的对象的理解" class="headerlink" title="关于JavaScript的对象的理解"></a>关于JavaScript的对象的理解</h1><p>JavaScript的对象可以分为狭义的和广义的对象。广义的对象由数组，狭义的对象和函数组成。</p><p>狭义的对象就是{}，里面是键值对。广义的对象其实本质也是键值对。只不过声明的方式多了一些。比如new Object()。Object就是一个构造函数，既然是函数，本身也就是一个对象，可以对Object中添加方法，和狭义对象的方法一样。比如Object.test=Function (){};这时候在外部可以调用Object.test()方法，即Object对象的静态方法。</p><p>这里Object是构造函数名，但是函数也是对象啊，我估计函数本质上也是一个键值对，函数可以是构造函数Function.prototype的实例对象。所以称为Object对象。</p><p>既然是构造函数，里面是有语句的，执行完语句得到一个键值对，这又是一个对象，称为Object.prototype。这时就是一个纯粹的键值对。就是原型对象。Object.prototype也有很多方法可以调用。至于原型链，就是对象与对象之间的一条链。对象都是构造函数.prototype。继承是通过构造函数的继承来实现的，一般就是在子类中要实现父类的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于JavaScript的对象的理解&quot;&gt;&lt;a href=&quot;#关于JavaScript的对象的理解&quot; class=&quot;headerlink&quot; title=&quot;关于JavaScript的对象的理解&quot;&gt;&lt;/a&gt;关于JavaScript的对象的理解&lt;/h1&gt;&lt;p&gt;JavaSc
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM模型 实际使用DOM Element节点</title>
    <link href="https://github.com/zdkswd/2018/10/09/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%E6%A8%A1%E5%9E%8B%20%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8DOM%20Element%E8%8A%82%E7%82%B9/"/>
    <id>https://github.com/zdkswd/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/</id>
    <published>2018-10-09T11:42:56.000Z</published>
    <updated>2018-10-09T13:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实战中的使用DOM"><a href="#实战中的使用DOM" class="headerlink" title="实战中的使用DOM"></a>实战中的使用DOM</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8A%E5%8D%8811.44.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8A%E5%8D%8811.50.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8B%E5%8D%883.07.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8B%E5%8D%883.26.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果加了括号就会直接执行了。</p><h1 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h1><p>Element对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。</p><p>元素节点的nodeType属性都是1。</p><p>Element对象继承了Node接口，因此Node的属性和方法在Element对象都存在。此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如&lt; a&gt;元素的节点对象由HTMLAnchorElement构造函数生成，&lt; button&gt;元素的节点对象由HTMLButtonElement构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承Element的属性和方法，还有各自构造函数的属性和方法。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="headerlink" title="元素特性的相关属性"></a>元素特性的相关属性</h3><h4 id="Element-id"><a href="#Element-id" class="headerlink" title="Element.id"></a>Element.id</h4><p>Element.id属性返回指定元素的id属性，该属性可读写。</p><p>id属性的值是大小写敏感。</p><h4 id="Element-tagName"><a href="#Element-tagName" class="headerlink" title="Element.tagName"></a>Element.tagName</h4><p>Element.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。</p><h4 id="Element-dir"><a href="#Element-dir" class="headerlink" title="Element.dir"></a>Element.dir</h4><p>Element.dir属性用于读写当前元素的文字方向，可能是从左到右（”ltr”），也可能是从右到左（”rtl”）。</p><h4 id="Element-accessKey"><a href="#Element-accessKey" class="headerlink" title="Element.accessKey"></a>Element.accessKey</h4><p>Element.accessKey属性用于读写分配给当前元素的快捷键。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.46.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面代码中，btn元素的快捷键是h，按下Alt + h就能将焦点转移到它上面。</p><h4 id="Element-draggable"><a href="#Element-draggable" class="headerlink" title="Element.draggable"></a>Element.draggable</h4><p>Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p><h4 id="Element-lang"><a href="#Element-lang" class="headerlink" title="Element.lang"></a>Element.lang</h4><p>Element.lang属性返回当前元素的语言设置。该属性可读写。</p><h4 id="Element-tabIndex"><a href="#Element-tabIndex" class="headerlink" title="Element.tabIndex"></a>Element.tabIndex</h4><p>Element.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p><p>abIndex属性值如果是负值（通常是-1），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的tabIndex属性的正整数值相同，则按照出现的顺序遍历。遍历完所有tabIndex为正整数的元素以后，再遍历所有tabIndex等于0、或者属性值是非法值、或者没有tabIndex属性的元素，顺序为它们在网页中出现的顺序。</p><h4 id="Element-title"><a href="#Element-title" class="headerlink" title="Element.title"></a>Element.title</h4><p>Element.title属性用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p><h3 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="headerlink" title="元素状态的相关属性"></a>元素状态的相关属性</h3><h4 id="Element-hidden"><a href="#Element-hidden" class="headerlink" title="Element.hidden"></a>Element.hidden</h4><p>Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。</p><p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，Element.hidden并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p><p>CSS 的设置高于Element.hidden。如果 CSS 指定了该元素不可见（display: none）或可见（display: hidden），那么Element.hidden并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p><h4 id="Element-contentEditable，Element-isContentEditable"><a href="#Element-contentEditable，Element-isContentEditable" class="headerlink" title="Element.contentEditable，Element.isContentEditable"></a>Element.contentEditable，Element.isContentEditable</h4><p>HTML 元素可以设置contentEditable属性，使得元素的内容可以编辑。</p><p>Element.contentEditable属性返回一个字符串，表示是否设置了contenteditable属性，有三种可能的值。该属性可写。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.49.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Element.isContentEditable属性返回一个布尔值，同样表示是否设置了contenteditable属性。该属性只读。</p><h3 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h3><p>Element.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。</p><h4 id="Element-className，Element-classList"><a href="#Element-className，Element-classList" class="headerlink" title="Element.className，Element.classList"></a>Element.className，Element.classList</h4><p>className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割</p><p>classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。</p><p>classList对象有下列方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.52.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>toggle方法可以接受一个布尔值，作为第二个参数。如果为true，则添加该属性；如果为false，则去除该属性。</p><h3 id="Element-dataset"><a href="#Element-dataset" class="headerlink" title="Element.dataset"></a>Element.dataset</h3><p>网页元素可以自定义data-属性，用来添加数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.53.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Element.dataset属性返回一个对象，可以从这个对象读写data-属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.54.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，dataset上面的各个属性返回都是字符串。</p><p>HTML 代码中，data-属性的属性名，只能包含英文字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_）。它们转成 JavaScript 对应的dataset属性名，规则如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.54.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>因此，data-abc-def对应dataset.abcDef，data-abc-1对应dataset[“abc-1”]。</p><p>除了使用dataset读写data-属性，也可以使用Element.getAttribute()和Element.setAttribute()，通过完整的属性名读写这些属性。</p><h3 id="Element-innerHTML"><a href="#Element-innerHTML" class="headerlink" title="Element.innerHTML"></a>Element.innerHTML</h3><p>Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<html>和<body>元素。</body></html></p><p>如果将innerHTML属性设为空，等于删除所有它包含的所有节点。</p><p>注意，读取属性值的时候，如果文本节点包含 \&amp;、小于号（ &lt;）和大于号（ &gt;），innerHTML属性会将它们转为实体形式 \&amp; amp;、\&amp; lt;、\&amp; gt;。如果想得到原文，建议使用element.textContent属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%883.53.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，如果文本之中含有&lt; script&gt;标签，虽然可以生成script节点，但是插入的代码不会执行。</p><p>为了安全考虑，如果插入的是文本，最好用textContent属性代替innerHTML。</p><h3 id="Element-outerHTML"><a href="#Element-outerHTML" class="headerlink" title="Element.outerHTML"></a>Element.outerHTML</h3><p>Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%883.57.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>outerHTML属性是可读写的，对它进行赋值，等于替换掉当前元素。</p><p>注意，如果一个节点没有父节点，设置outerHTML属性会报错。</p><h3 id="Element-clientHeight，Element-clientWidth"><a href="#Element-clientHeight，Element-clientWidth" class="headerlink" title="Element.clientHeight，Element.clientWidth"></a>Element.clientHeight，Element.clientWidth</h3><p>Element.clientHeight属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度。</p><p>除了元素本身的高度，它还包括padding部分，但是不包括border、margin。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p><p>Element.clientWidth属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p><p>document.documentElement的clientHeight属性，返回当前视口的高度（即浏览器窗口的高度），等同于window.innerHeight属性减去水平滚动条的高度（如果有的话）。document.body的高度则是网页的实际高度。一般来说，document.body.clientHeight大于document.documentElement.clientHeight。</p><h3 id="Element-clientLeft，Element-clientTop"><a href="#Element-clientLeft，Element-clientTop" class="headerlink" title="Element.clientLeft，Element.clientTop"></a>Element.clientLeft，Element.clientTop</h3><p>Element.clientLeft属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的padding和margin。如果没有设置左边框，或者是行内元素（display: inline），该属性返回0。该属性总是返回整数值，如果是小数，会四舍五入。</p><p>Element.clientTop属性等于网页元素顶部边框的宽度（单位像素），其他特点都与clientTop相同。</p><h3 id="Element-scrollHeight，Element-scrollWidth"><a href="#Element-scrollHeight，Element-scrollWidth" class="headerlink" title="Element.scrollHeight，Element.scrollWidth"></a>Element.scrollHeight，Element.scrollWidth</h3><p>Element.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。</p><p>Element.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读。</p><p>整张网页的总高度可以从document.documentElement或document.body上读取。</p><p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，scrollHeight属性仍然返回元素的总高度。</p><h3 id="Element-scrollLeft，Element-scrollTop"><a href="#Element-scrollLeft，Element-scrollTop" class="headerlink" title="Element.scrollLeft，Element.scrollTop"></a>Element.scrollLeft，Element.scrollTop</h3><p>Element.scrollLeft属性表示当前元素的水平滚动条向右侧滚动的像素数量，Element.scrollTop属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p><p>如果要查看整张网页的水平的和垂直的滚动距离，要从document.documentElement元素上读取。</p><p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p><h3 id="Element-offsetParent"><a href="#Element-offsetParent" class="headerlink" title="Element.offsetParent"></a>Element.offsetParent</h3><p>Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。</p><p>该属性主要用于确定子元素位置偏移的计算基准，Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。</p><p>如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），则offsetParent属性返回null。</p><p>如果某个元素的所有上层节点的position属性都是static，则Element.offsetParent属性指向<body>元素。</body></p><h3 id="Element-offsetHeight，Element-offsetWidth"><a href="#Element-offsetHeight，Element-offsetWidth" class="headerlink" title="Element.offsetHeight，Element.offsetWidth"></a>Element.offsetHeight，Element.offsetWidth</h3><p>Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。</p><p>Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。</p><p>这两个属性都是<strong>只读</strong>属性，只比Element.clientHeight和Element.clientWidth多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如display: none;），则返回0。</p><h3 id="Element-offsetLeft，Element-offsetTop"><a href="#Element-offsetLeft，Element-offsetTop" class="headerlink" title="Element.offsetLeft，Element.offsetTop"></a>Element.offsetLeft，Element.offsetTop</h3><p>Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移</p><h3 id="Element-style"><a href="#Element-style" class="headerlink" title="Element.style"></a>Element.style</h3><p>每个元素节点都有style用来读写该元素的行内样式信息。</p><h3 id="Element-children，Element-childElementCount"><a href="#Element-children，Element-childElementCount" class="headerlink" title="Element.children，Element.childElementCount"></a>Element.children，Element.childElementCount</h3><p>Element.children属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p><p>这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p><p>Element.childElementCount属性返回当前元素节点包含的子元素节点的个数，与Element.children.length的值相同。</p><h3 id="Element-firstElementChild，Element-lastElementChild"><a href="#Element-firstElementChild，Element-lastElementChild" class="headerlink" title="Element.firstElementChild，Element.lastElementChild"></a>Element.firstElementChild，Element.lastElementChild</h3><p>Element.firstElementChild属性返回当前元素的第一个元素子节点，Element.lastElementChild返回最后一个元素子节点。</p><p>如果没有元素子节点，这两个属性返回null。</p><h3 id="Element-nextElementSibling，Element-previousElementSibling"><a href="#Element-nextElementSibling，Element-previousElementSibling" class="headerlink" title="Element.nextElementSibling，Element.previousElementSibling"></a>Element.nextElementSibling，Element.previousElementSibling</h3><p>Element.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回null。</p><p>Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回null。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="属性相关方法"><a href="#属性相关方法" class="headerlink" title="属性相关方法"></a>属性相关方法</h3><h4 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h4><p>Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。</p><h4 id="Element-getAttributeNames"><a href="#Element-getAttributeNames" class="headerlink" title="Element.getAttributeNames()"></a>Element.getAttributeNames()</h4><p>Element.getAttributeNames()返回一个<strong>数组</strong>，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用Element.attributes属性，也可以拿到同样的结果，唯一的区别是它返回的是<strong>类似数组</strong>的对象。</p><h4 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h4><p>Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。</p><p>属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值true就会变成字符串true。</p><h4 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h4><p>Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否有指定的属性。</p><h4 id="Element-hasAttributes"><a href="#Element-hasAttributes" class="headerlink" title="Element.hasAttributes()"></a>Element.hasAttributes()</h4><p>Element.hasAttributes方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回false，否则返回true。</p><h4 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h4><p>Element.removeAttribute方法移除指定属性。该方法没有返回值。</p><h3 id="Element-querySelector"><a href="#Element-querySelector" class="headerlink" title="Element.querySelector()"></a>Element.querySelector()</h3><p>Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回null。</p><p>注意，这个方法无法选中伪元素。</p><p>它可以接受多个选择器，它们之间使用逗号分隔。</p><h3 id="Element-querySelectorAll"><a href="#Element-querySelectorAll" class="headerlink" title="Element.querySelectorAll()"></a>Element.querySelectorAll()</h3><p>Element.querySelectorAll方法接受 CSS 选择器作为参数，返回一个NodeList实例，包含所有匹配的子元素。</p><p>该方法的执行机制与querySelector方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p><p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的NodeList实例。</p><h3 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h3><p>Element.getElementsByClassName方法返回一个HTMLCollection实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p><p>注意，该方法的参数大小写敏感。</p><p>由于HTMLCollection实例是一个活的集合，document对象的任何变化会立刻反应到实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%884.59.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面代码中，matches集合的第一个成员，一旦被拿掉 class 里面的foo，就会立刻从matches里面消失，导致出现上面的结果。</p><h3 id="Element-getElementsByTagName"><a href="#Element-getElementsByTagName" class="headerlink" title="Element.getElementsByTagName()"></a>Element.getElementsByTagName()</h3><p>Element.getElementsByTagName方法返回一个HTMLCollection实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p><p><strong>注意</strong>，该方法的参数是大小写不敏感的。</p><h3 id="Element-closest"><a href="#Element-closest" class="headerlink" title="Element.closest()"></a>Element.closest()</h3><p>Element.closest方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回null。</p><h3 id="Element-matches"><a href="#Element-matches" class="headerlink" title="Element.matches()"></a>Element.matches()</h3><p>Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p><h3 id="事件相关方法"><a href="#事件相关方法" class="headerlink" title="事件相关方法"></a>事件相关方法</h3><p>以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="Element.scrollIntoView()"></a>Element.scrollIntoView()</h3><p>Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。</p><p>该方法可以接受一个布尔值作为参数。如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为true。</p><h3 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h3><p>Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p><p>只读。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.54.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意，getBoundingClientRect方法的所有属性，都把边框（border属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，width和height包括了元素本身 + padding + border。</p><h3 id="Element-getClientRects"><a href="#Element-getClientRects" class="headerlink" title="Element.getClientRects()"></a>Element.getClientRects()</h3><p>Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的Rect用的是复数）。每个矩形都有bottom、height、left、right、top和width六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p><p>对于盒状元素（比如&lt; div&gt;和&lt; p&gt;），该方法返回的对象中只有该元素一个成员。对于行内元素（比如&lt; span&gt;、&lt; a&gt;、&lt; em&gt;），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和Element.getBoundingClientRect()方法的主要区别，后者对于行内元素总是返回一个矩形。</p><h3 id="Element-insertAdjacentElement"><a href="#Element-insertAdjacentElement" class="headerlink" title="Element.insertAdjacentElement()"></a>Element.insertAdjacentElement()</h3><p>Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回null。</p><p>Element.insertAdjacentElement方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p><p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%886.12.22.png" alt=""></p><p>注意，beforebegin和afterend这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p><h3 id="Element-insertAdjacentHTML-，Element-insertAdjacentText"><a href="#Element-insertAdjacentHTML-，Element-insertAdjacentText" class="headerlink" title="Element.insertAdjacentHTML()，Element.insertAdjacentText()"></a>Element.insertAdjacentHTML()，Element.insertAdjacentText()</h3><p>Element.insertAdjacentHTML方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p><p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%886.22.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比innerHTML方法快得多。</p><p>注意，该方法会使 HTML 字符串显示为网页结构，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p><h3 id="Element-focus-，Element-blur"><a href="#Element-focus-，Element-blur" class="headerlink" title="Element.focus()，Element.blur()"></a>Element.focus()，Element.blur()</h3><p>Element.focus方法用于将当前页面的焦点，转移到指定元素上。</p><p>该方法可以接受一个对象作为参数。参数对象的preventScroll属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p><p>Element.blur方法用于将焦点从当前元素移除。</p><h3 id="Element-click"><a href="#Element-click" class="headerlink" title="Element.click()"></a>Element.click()</h3><p>Element.click方法用于在当前元素上模拟一次鼠标点击，相当于触发了click事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实战中的使用DOM&quot;&gt;&lt;a href=&quot;#实战中的使用DOM&quot; class=&quot;headerlink&quot; title=&quot;实战中的使用DOM&quot;&gt;&lt;/a&gt;实战中的使用DOM&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
               
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>html+css</title>
    <link href="https://github.com/zdkswd/2018/10/06/html+css/"/>
    <id>https://github.com/zdkswd/2018/10/06/html+css/</id>
    <published>2018-10-06T13:31:32.000Z</published>
    <updated>2018-10-11T07:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html-css"><a href="#html-css" class="headerlink" title="html+css"></a>html+css</h1><p>chrome市场份额多。</p><h1 id="常见浏览器内核介绍："><a href="#常见浏览器内核介绍：" class="headerlink" title="常见浏览器内核介绍："></a>常见浏览器内核介绍：</h1><p>浏览器内核又可以分成两个部分：渲染引擎（layout engineer或者Rendering Engine）和JS引擎。</p><p><strong>渲染引擎</strong>它负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入Css等),以及计算网页的显示方式,然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同,所以渲染的效果也不相同。</p><p><strong>JS引擎</strong>则是解析Javascript语言,执行 Javascript语言来实现网页的动态效果。</p><p>最开始渲染引擎和J5引擎并没有区分的很明确,后来]S引擎越来越独立,内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了个ACID来测试引擎的兼容性和性能。内核的种类很多,如加上没什么人使用的非商业的免费内核,可能会有10多种,但是常见的浏览器内核可以分这四种: Trident、 Gecko、 Blink、 Webkit。 </p><p>(1) Trident(IE内核)<br>国内很多的双核浏览器的其中一核便是 Trident,美其名曰”兼容模式”。<br>代表:、傲游、世界之窗浏览器、 Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。<br>Window10发布后,正将其内置浏览器命名为Edge,Edge最显著的特点就是新内核 EdgeHTML。</p><p>(2)Gecko(firefox)<br>Gecko( Firefox内核): Mozilla fire fox(火狐浏览器)采用该内核, Gecko的特点是代码完全公开,因此,其可开发程度很高,全世界的程序员都可以为其编写代码,增加功能。可惜这几年已经没落了,比如打开速度慢、升级频繁、猪一样的队友flash、神一样的对手 chrome。</p><p>(3) webkit(Safari)<br>Safari是苹果公司开发的浏览器,所用浏览器内核的名称是大名鼎鼎的 Webkit.<br>现在很多人错误地把 webkit叫做 chrome内核(即使 chrome内核已经是 blink了),苹果感觉像被别人抢了媳妇,都哭晕再厕所里面了。代表浏览器:傲游浏览器3、 Apple Safari(Win/ Mac_iPhone_iPad)、 Symbian手机浏览器、 Android默认浏览器。</p><p>(4) Chromium/Blink(chrome)<br>在 Chromium项目中研发 Blink渲染引擎(即浏览器核心),内置于 Chrome浏览器之中。 Blink其实是 Webkit的分支。<br>大部分国产浏览器最新版都采用Bink内核。</p><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p><p>Android手机而言,使用率最高的就是 Webkit内核,大部分国产浏览器宣称的自己的内核,基本上也是属于 webkit二次开发。</p><p>IOS以及WP7平台上,由于系统原因,系统大部分自带浏览器内核,一般是 Safari或者IE内核 Trident的。</p><h1 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h1><p>通过Web标准不同的浏览器内核展示统一内容。</p><h2 id="Web标准构成"><a href="#Web标准构成" class="headerlink" title="Web标准构成"></a>Web标准构成</h2><p>主要包括：结构（HTML）（<strong>最重要</strong>），表现（CSS），和行为（JS）。</p><h1 id="HTMl初识"><a href="#HTMl初识" class="headerlink" title="HTMl初识"></a>HTMl初识</h1><p>超（除了文字之外还有其他的，还可以链接），文本，标签，语言（有规范）。</p><p>语法骨架，一万年不变：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.08.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>h4之前标签是不分大小写的，h5之后最好小写。</p><p>头部是指标签栏位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.15.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>页面内容基本在body中。</p><h2 id="HTML标签分类"><a href="#HTML标签分类" class="headerlink" title="HTML标签分类"></a>HTML标签分类</h2><h3 id="双标签"><a href="#双标签" class="headerlink" title="双标签"></a>双标签</h3><p>一对尖括号。</p><p><head></head></p><h3 id="单标签"><a href="#单标签" class="headerlink" title="单标签"></a>单标签</h3><p><br><br>单标签数量非常少，用脚趾能数过来。<br>其中都有’/ ‘,’/‘表示关闭符。</p><h2 id="HTML标签关系"><a href="#HTML标签关系" class="headerlink" title="HTML标签关系"></a>HTML标签关系</h2><h3 id="嵌套关系"><a href="#嵌套关系" class="headerlink" title="嵌套关系"></a>嵌套关系</h3><p>父子关系</p><h3 id="并列关系"><a href="#并列关系" class="headerlink" title="并列关系"></a>并列关系</h3><p> <strong>倡议</strong>：如果两个标签之间的关系是嵌套关系，子元素最好缩进一个Tab的身位。如果是并列关系，最好上下对齐。</p><h2 id="HTML开发"><a href="#HTML开发" class="headerlink" title="HTML开发"></a>HTML开发</h2><p>使用sublime，输入html:5或者！后按下tab键自动生成骨骼框架。</p><p>右键在浏览器中打开，快捷键f12。</p><h3 id="文档类型-lt-DOCTYPE-gt"><a href="#文档类型-lt-DOCTYPE-gt" class="headerlink" title="文档类型&lt;!DOCTYPE&gt;"></a>文档类型&lt;!DOCTYPE&gt;</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.44.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>图中就是h5版本。</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%887.55.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>UTF-16固定用2个字节来存储。<br>UTF-8（国际通用）,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个..反正是根据字符对应的数字大小来确定。</p><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p>核心：在合适的地方给个合适的标签。</p><h2 id="HTMl常用标签"><a href="#HTMl常用标签" class="headerlink" title="HTMl常用标签"></a>HTMl常用标签</h2><h3 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h3><h4 id="（内容）标题标签（熟记）"><a href="#（内容）标题标签（熟记）" class="headerlink" title="（内容）标题标签（熟记）"></a>（内容）标题标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.05.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="段落标签（熟记）"><a href="#段落标签（熟记）" class="headerlink" title="段落标签（熟记）"></a>段落标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.28.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="水平线标签（认识）"><a href="#水平线标签（认识）" class="headerlink" title="水平线标签（认识）"></a>水平线标签（认识）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.34.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="语义化后的效果："><a href="#语义化后的效果：" class="headerlink" title="语义化后的效果："></a>语义化后的效果：</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.37.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="换行标签（熟记）"><a href="#换行标签（熟记）" class="headerlink" title="换行标签（熟记）"></a>换行标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.44.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="div-span标签（重点）"><a href="#div-span标签（重点）" class="headerlink" title="div span标签（重点）"></a>div span标签（重点）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.47.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常css+div<br>div独占一行，span一行可以放多个。</p><h4 id="文本格式化标签（熟记）"><a href="#文本格式化标签（熟记）" class="headerlink" title="文本格式化标签（熟记）"></a>文本格式化标签（熟记）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.51.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.54.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="图像标签img-重点"><a href="#图像标签img-重点" class="headerlink" title="图像标签img(重点)"></a>图像标签img(重点)</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%888.59.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.00.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.02.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>单独给宽高会等比缩放。</p><h4 id="链接标签（重点）"><a href="#链接标签（重点）" class="headerlink" title="链接标签（重点）"></a>链接标签（重点）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.22.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="锚点定位（难点）"><a href="#锚点定位（难点）" class="headerlink" title="锚点定位（难点）"></a>锚点定位（难点）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%889.40.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h4><p>base可以设置整体链接的打开状态。<br>在head中使用，单标签。</p><h4 id="特殊字符标签"><a href="#特殊字符标签" class="headerlink" title="特殊字符标签"></a>特殊字符标签</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8A%E5%8D%8811.52.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8A%E5%8D%8811.58.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="路径（重点难点）"><a href="#路径（重点难点）" class="headerlink" title="路径（重点难点）"></a>路径（重点难点）</h2><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.00.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.02.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>整齐有序。</p><h3 id="无序列表ul（重点）"><a href="#无序列表ul（重点）" class="headerlink" title="无序列表ul（重点）"></a>无序列表ul（重点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>先到先得，先到先显示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.09.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="有序列表ol-了解"><a href="#有序列表ol-了解" class="headerlink" title="有序列表ol(了解)"></a>有序列表ol(了解)</h3><p>注意事项和ul类似，使用也类似。</p><h3 id="自定义列表（理解）"><a href="#自定义列表（理解）" class="headerlink" title="自定义列表（理解）"></a>自定义列表（理解）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.17.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由三个标签组成。</p><p>效果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.19.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.20.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="表格table（会使用）"><a href="#表格table（会使用）" class="headerlink" title="表格table（会使用）"></a>表格table（会使用）</h2><p>表格不是用来布局的，常见处理，显示表格式数据。</p><h3 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%8812.55.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.02.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.02.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.04.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>三参为0 border  cellpadding cellspacing 为0</p><h3 id="表头标签"><a href="#表头标签" class="headerlink" title="表头标签"></a>表头标签</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.11.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 一般第一行或第一列使用。居中且加粗。</p><h3 id="表格标题"><a href="#表格标题" class="headerlink" title="表格标题"></a>表格标题</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.14.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="表格结构（了解）"><a href="#表格结构（了解）" class="headerlink" title="表格结构（了解）"></a>表格结构（了解）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.21.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%881.23.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="合并单元格（难点）"><a href="#合并单元格（难点）" class="headerlink" title="合并单元格（难点）"></a>合并单元格（难点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%882.34.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 在td属性中使用。</p><h2 id="表单标签（掌握）"><a href="#表单标签（掌握）" class="headerlink" title="表单标签（掌握）"></a>表单标签（掌握）</h2><p>收集用户信息。<br>一个完整的表单通常由三部分组成：<br>表单控件（也称为表单元素）、提示信息和表单域。</p><h3 id="input控件（重点）"><a href="#input控件（重点）" class="headerlink" title="input控件（重点）"></a>input控件（重点）</h3><p>单标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.00.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> 用name来控制单选组，多选组。</p><h3 id="label标签（理解）"><a href="#label标签（理解）" class="headerlink" title="label标签（理解）"></a>label标签（理解）</h3><p>label标签为input元素定义标注（标签）。<br>作用：用于绑定一个表单元素，当点击label标签时，被绑定的表单元素就会获得输入焦点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.23.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="textarea控件（文本域）"><a href="#textarea控件（文本域）" class="headerlink" title="textarea控件（文本域）"></a>textarea控件（文本域）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.27.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.17.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.19.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>层叠样式表。</p><h2 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h2><h3 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.48.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式，其中属性和值的书写规范与CSS样式规范相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。注意是冒号。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.56.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。</p><p>type=“text/CSS”在H5中可以省略，写上也比较符合规范，所以这个地方可以写也可以省略。</p><h3 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.50.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在外部样式中，不用style标签，直接写就完事了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.14.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.22.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="选择器（重点）"><a href="#选择器（重点）" class="headerlink" title="选择器（重点）"></a>选择器（重点）</h2><h3 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h3><h4 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.24.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.31.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%885.20.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.27.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.29.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>id选择器和类选择器最大的不同在于使用次数。<br>id选择器id只能使用一次。<br> 使用‘#’ 定义，使用 id= 调用</p><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.39.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>几乎不用。</p><h2 id="CSS字体样式属性"><a href="#CSS字体样式属性" class="headerlink" title="CSS字体样式属性"></a>CSS字体样式属性</h2><h3 id="font-size：字号大小"><a href="#font-size：字号大小" class="headerlink" title="font-size：字号大小"></a>font-size：字号大小</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.44.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>统一用px</p><h3 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family:字体"></a>font-family:字体</h3><p>font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.49.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果字体都没有，就使用系统默认的字体。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.57.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了照顾浏览器的兼容性，可以使用Unicode编码。</p><h3 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight:字体粗细"></a>font-weight:字体粗细</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>bold字体加粗。使用normal也可以让标题不加粗。</p><h3 id="font-style：字体风格"><a href="#font-style：字体风格" class="headerlink" title="font-style：字体风格"></a>font-style：字体风格</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.05.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="综合设置字体样式（重点）"><a href="#综合设置字体样式（重点）" class="headerlink" title="综合设置字体样式（重点）"></a>综合设置字体样式（重点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.12.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="CSS外观属性"><a href="#CSS外观属性" class="headerlink" title="CSS外观属性"></a>CSS外观属性</h2><h3 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color:文本颜色"></a>color:文本颜色</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>十六进制时 # ff0000由于数值一样，可以简写为 # f00。</p><h3 id="line-height-行间距"><a href="#line-height-行间距" class="headerlink" title="line-height:行间距"></a>line-height:行间距</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.25.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="text-align-水平对齐方式"><a href="#text-align-水平对齐方式" class="headerlink" title="text-align:水平对齐方式"></a>text-align:水平对齐方式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.27.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>css中没有垂直对齐的方式。</p><p>是让盒子里面的内容居中，而不是让盒子居中。</p><h3 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent:首行缩进"></a>text-indent:首行缩进</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%8812.45.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="text-decoration文本的装饰"><a href="#text-decoration文本的装饰" class="headerlink" title="text-decoration文本的装饰"></a>text-decoration文本的装饰</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%8812.52.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%881.47.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>用空格隔开。</p><p>是选择所有的后代。</p><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><p>只选亲儿子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%881.55.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="并集选择器（重点）"><a href="#并集选择器（重点）" class="headerlink" title="并集选择器（重点）"></a>并集选择器（重点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，比如可以选择第一个，第n个元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.27.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.27.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>active是按下鼠标还没弹起的状态。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.35.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.24.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.25.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="标签的显示（display）"><a href="#标签的显示（display）" class="headerlink" title="标签的显示（display）"></a>标签的显示（display）</h2><h3 id="块级元素（block-level）"><a href="#块级元素（block-level）" class="headerlink" title="块级元素（block-level）"></a>块级元素（block-level）</h3><p>每个块元素通常都会<strong>独自占据一整行或者多整行</strong>，<strong>可以对其设置宽度、高度、对齐等属性</strong>，常用于网页布局和网页结构的搭建。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.33.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.35.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="行内元素（inline-level）"><a href="#行内元素（inline-level）" class="headerlink" title="行内元素（inline-level）"></a>行内元素（inline-level）</h3><p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.36.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.37.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>a里面可以放块级元素。</strong></p><p><strong>注意</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.38.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.41.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="显示模式转换"><a href="#显示模式转换" class="headerlink" title="显示模式转换"></a>显示模式转换</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.47.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每一个标签都是一个小盒子。</p><p><strong>如果是行内元素，行内块元素，我们可以看做文本，可以在块级使用text-align:center进行居中对齐。</strong></p><p><strong>使行高等于盒子的高度，可以让单行文本垂直居中。</strong></p><h2 id="行高的测量"><a href="#行高的测量" class="headerlink" title="行高的测量"></a>行高的测量</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.18.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.19.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.20.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a>CSS层叠性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.40.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.43.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.49.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.54.36.png" alt=""></p><h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><p>CSS可以添加背景颜色和背景图片，以及来进行图片设置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.06.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="背景颜色与背景图片"><a href="#背景颜色与背景图片" class="headerlink" title="背景颜色与背景图片"></a>背景颜色与背景图片</h3><p>同时设置的话背景图片会在背景颜色之上。</p><h3 id="backgroud-repeat"><a href="#backgroud-repeat" class="headerlink" title="backgroud-repeat"></a>backgroud-repeat</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.33.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="backgroud-position"><a href="#backgroud-position" class="headerlink" title="backgroud-position"></a>backgroud-position</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.34.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="backgroud-attachment"><a href="#backgroud-attachment" class="headerlink" title="backgroud-attachment"></a>backgroud-attachment</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.35.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.28.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="背景透明（CSS3）"><a href="#背景透明（CSS3）" class="headerlink" title="背景透明（CSS3）"></a>背景透明（CSS3）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.49.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="盒子边框"><a href="#盒子边框" class="headerlink" title="盒子边框"></a>盒子边框</h3><p>盒子边框即border,有border-width,border-style,border-color.<br>可简写为 border: 1px solid red;<br>其中border-style常用值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.12.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>border亦可单边进行设置。border-top;border-bottom;border-left;border-right。</p><h4 id="合并相邻边框"><a href="#合并相邻边框" class="headerlink" title="合并相邻边框"></a>合并相邻边框</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.13.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h3><p>默认贴在左上角。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.16.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.17.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>padding和border会<strong>撑开</strong>带有width和height的盒子。对于没有给定的就是盒子大小不变，内容进行了移动。</p><h3 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.54.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>margin值的个数表达的意思和padding类似。</p><p>使盒子水平居中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.20.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上下是0，左右是auto。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.23.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.24.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使块中的内容居中：text-align=center。</p><h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.33.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以比较大的为准。</p><p>解决方法：避免</p><h3 id="垂直外边距嵌套元素合并"><a href="#垂直外边距嵌套元素合并" class="headerlink" title="垂直外边距嵌套元素合并"></a>垂直外边距嵌套元素合并</h3><p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.40.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>只有垂直会发生这种情况。</p><p>解决方案：</p><ol><li>可以为父元素定义1像素的上外边框或上内边距。</li><li>可以为父元素添加overflow:hidden.</li></ol><h3 id="盒子布局的稳定性"><a href="#盒子布局的稳定性" class="headerlink" title="盒子布局的稳定性"></a>盒子布局的稳定性</h3><p>按照优先使用顺序：width&gt;padding&gt;margin<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.52.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="插入图片与背景图片"><a href="#插入图片与背景图片" class="headerlink" title="插入图片与背景图片"></a>插入图片与背景图片</h3><p> 插入图片 最多比如产品展示类；背景图片我们一般用于小图标背景或者超大背景图片。</p><h3 id="圆角边框（CSS3）"><a href="#圆角边框（CSS3）" class="headerlink" title="圆角边框（CSS3）"></a>圆角边框（CSS3）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.54.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也可以是px。值越大越圆。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%887.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第一个左上，顺时针。</p><h3 id="盒子阴影（CSS3）"><a href="#盒子阴影（CSS3）" class="headerlink" title="盒子阴影（CSS3）"></a>盒子阴影（CSS3）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.03.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.09.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="浮动（float）"><a href="#浮动（float）" class="headerlink" title="浮动（float）"></a>浮动（float）</h2><h3 id="普通流（normal-flow）"><a href="#普通流（normal-flow）" class="headerlink" title="普通流（normal flow）"></a>普通流（normal flow）</h3><p>也称为标准流，CSS的定位机制有三种：普通流、浮动和定位。</p><p>普通流实际就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思。比如块级元素会独占一行，行内元素会按顺序依次前后排列。</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>浮动让盒子浮起来，盒子的位置就由其他盒子占据。</p><p>浮动有个很有意思的事情：就是让任何盒子可以一行排列，我们就慢慢地利用浮动的特性来布局了。</p><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.19.38.png" alt=""></p><p>为什么不用inline-block?是有的时候需要右对齐，这时就不好知道具体的位置。需要量出来，不同的屏幕显示的效果不一样。而且块之间有缝隙。这时使用浮动就效果比较好。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.23.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>只有<strong>左右</strong>。浮动的和浮动的又符合标准流。</p><p>浮动的盒子跨越不了padding值。</p><p>一个盒子浮动，会影响后面的位置，影响不了前面的位置，也就是说不会往上面的元素上浮。</p><p>浮动有一个隐藏的模式转换，浮动可以让元素默认转换为<strong>行内块元素</strong>，宽度取决于元素的大小。</p><p>如果已经给行内元素添加了浮动，此时不需要转换该元素也可以有宽高。</p><h2 id="版心和布局流程"><a href="#版心和布局流程" class="headerlink" title="版心和布局流程"></a>版心和布局流程</h2><p>为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下：</p><ol><li>确定页面的版心（可视区）。</li><li>分析页面中的行模块，以及每个行模块中的列模块。</li><li>制作HTML结构。</li><li>CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;html-css&quot;&gt;&lt;a href=&quot;#html-css&quot; class=&quot;headerlink&quot; title=&quot;html+css&quot;&gt;&lt;/a&gt;html+css&lt;/h1&gt;&lt;p&gt;chrome市场份额多。&lt;/p&gt;
&lt;h1 id=&quot;常见浏览器内核介绍：&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="https://github.com/zdkswd/tags/CSS/"/>
    
      <category term="HTML" scheme="https://github.com/zdkswd/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第四章 谈谈中文分词</title>
    <link href="https://github.com/zdkswd/2018/09/26/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B0%88%E8%B0%88%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    <id>https://github.com/zdkswd/2018/09/26/数学之美 第四章 谈谈中文分词/</id>
    <published>2018-09-26T10:16:32.000Z</published>
    <updated>2018-09-26T10:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中文分词方法的演变"><a href="#中文分词方法的演变" class="headerlink" title="中文分词方法的演变"></a>中文分词方法的演变</h1><p>对于西方拼音语言来说，词之间有明显的分界符，统计和使用语言模型非常直接。而对于中日韩泰等语言，词之间没有明确的分界符。</p><p>最容易想到的分词方法,也是最简单的办法,就是查字典。“查字典”的办法,其实就是把一个句子从左向右扫描一遍,遇到字典里有的词就标识出来,遇到复合词(比如“上海大学”)就找最长的词匹配,遇到不认识的字串就分割成单字词,于是简单的分词就完成了。</p><p>这个最简单的方法可以解决七八成以上的分词问题,遇到稍微复杂一点的问题就无能为力了。这种方法的一个明显不足时当遇到有二义性的分割时无能为力，另外并非所有的最长匹配都是一定正确的。</p><p>利用统计语言模型分词的方法,可以用几个数学公式简单概括如下:假定一个句子S可以有几种分词方法,为了简单起见,假定有以下三种:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B0%88%E8%B0%88%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%885.52.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中,A1,A2…B1,B2…,C1,C2…等等都是汉语的词,那么最好的一种分词方法应该保证分完词后这个句子出现的概率最大。</p><p>当然,这里面有一个实现的技巧。如果穷举所有可能的分词方法并计算出每种可能性下句子的概率,那么计算量是相当大的。因此,可以把它看成是一个动态规划( Dynamic Programming)的问题,并利用维特比( Viterbi)算法快速地找到最佳分词。(我们在后面的章节会介绍该算法。)</p><p>一般来讲,根据不同应用,汉语分词的颗粒度大小应该不同。</p><p>中文分词方法可以帮助判别英语单词的边界。因为手写英文字符时已经不能明显的区分边界了。</p><p>最后,需要指出的是任何方法都有它的局限性,虽然利用统计语言模型进行分词,可以取得比人工更好的结果,但是也不可能做到百分之百准确。因为统计语言模型很大程度上是依照“大众的想法”,或者“多数句子的用法”,而在特定情况下可能是错的。</p><h1 id="工程上的细节"><a href="#工程上的细节" class="headerlink" title="工程上的细节"></a>工程上的细节</h1><h2 id="分词的一致性"><a href="#分词的一致性" class="headerlink" title="分词的一致性"></a>分词的一致性</h2><p>如何衡量分词结果的对与错,好与坏看似容易,其实不是那么简单。说它看似容易,是因为只要对计算机分词的结果和人工分词的结果进行比较就可以了。说它不是那么简单,是因为不同的人对同一个句子可能有不同的分词方法。不同的人对词的切分看法上的差异性远比我们想象的要大得多。当统计语言模型被广泛应用后,不同的分词器产生的结果的差异要远远小于不同人之间看法的差异,这时简单依靠与人工分词的结果比较来衡量分词器的准确性就很难,甚至是毫无意义的了。中文分词现在是一个已经解决了的问题,提高的空间微乎其微了。只要采用统计语言模型,效果都差不到哪里去。</p><h2 id="词的颗粒度和层次"><a href="#词的颗粒度和层次" class="headerlink" title="词的颗粒度和层次"></a>词的颗粒度和层次</h2><p>人工分词产生不一致性的原因主要在于人们对词的颗粒度的认识问题。在这里不去强调谁的观点对,而是要指出在不同的应用中,会有一种颗粒度比另一种更好的情况。比如在机器翻译中,一般来讲,颗粒度大翻译效果好。比如“联想公司”作为一个整体,很容易找到它对应的英语翻译 Lenovo,如果分词时将它们分开,很有可能翻译失败。</p><p>虽然可以对不同的应用构造不同的分词器,但是这样做不仅非常浪费,而且也不必要。更好的方法是让一个分词器同时支持不同层次的词的切分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中文分词方法的演变&quot;&gt;&lt;a href=&quot;#中文分词方法的演变&quot; class=&quot;headerlink&quot; title=&quot;中文分词方法的演变&quot;&gt;&lt;/a&gt;中文分词方法的演变&lt;/h1&gt;&lt;p&gt;对于西方拼音语言来说，词之间有明显的分界符，统计和使用语言模型非常直接。而对于中日韩
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 常用内建库</title>
    <link href="https://github.com/zdkswd/2018/09/24/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97%20/"/>
    <id>https://github.com/zdkswd/2018/09/24/Python廖雪峰 常用内建模块 /</id>
    <published>2018-09-24T09:05:56.000Z</published>
    <updated>2018-09-24T09:07:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><p>datetime是Python处理日期和时间的标准库。</p><h2 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.11.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。</p><p>如果仅导入import datetime，则必须引用全名datetime.datetime。</p><p>datetime.now()返回当前日期和时间，其类型是datetime。</p><h2 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h2><p>直接用参数构造一个datetime。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.14.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h2><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</p><p>timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p><p>把一个datetime类型转换为timestamp只需要简单调用timestamp()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.17.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>注意</strong>Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。</p><p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p><h2 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h2><p>要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.22.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这个得到的时间就是当前操作系统设定的时区，timestamp也可以直接被转换到UTC标准时区的时间。datetime.utcfromtimestamp</p><h2 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h2><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.26.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h2><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.28.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h2><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.34.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="本地时间转换为UTC时间"><a href="#本地时间转换为UTC时间" class="headerlink" title="本地时间转换为UTC时间"></a>本地时间转换为UTC时间</h2><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p><h2 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h2><p>我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间。</p><p>datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p><h1 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h1><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.43.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。</p><p>作用是更直接，像类一样表明这个的用途，但又不是类，没那么重。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.05.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.10.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。</p><p>除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。</p><h2 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p><p>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序。</p><p>dict内是无序的。</p><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>Counter是一个简单的计数器，例如，统计字符出现的个数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.40.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Counter实际上也是dict的一个子类。</p><h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p><p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%。6bit表示一个字符在表中的位置。表中共有64个字符。</p><p>Python内置的base64可以直接进行base64的编解码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符+和/分别变成-和_<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.54.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。</p><p>尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p><h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p><p>摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p><p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p><p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p><p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p><p>这个函数是一个单向函数，可以通过对比结果的不同来判断原文是否发生过篡改。当然有可能发生两个不同的数据通过某个摘要算法得到了相同的摘要，这种情况叫做碰撞，非常非常罕见。</p><p>可以用来在数据库中存储使用md5加密过后的密码，用户登录时，经过计算再与数据库中的摘要作比较。</p><h1 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h1><p>Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p><p>Python自带的hmac模块实现了标准的Hmac算法。</p><p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%883.26.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。</p><p>Python内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。</p><h1 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h1><p>Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。</p><h2 id="chain"><a href="#chain" class="headerlink" title="chain()"></a>chain()</h2><p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器</p><h2 id="groupby"><a href="#groupby" class="headerlink" title="groupby()"></a>groupby()</h2><p>groupby()把迭代器中相邻的重复元素挑出来放在一起。</p><h1 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h1><p>实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句。实现上下文管理是通过<strong>enter</strong>和<strong>exit</strong>这两个方法实现的。 一个是with触发的时候，一个是退出的时候。编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法。</p><p>contextlib是个比with优美的东西，也是提供上下文机制的模块，它是通过Generator装饰器实现的。不再是采用<strong>enter</strong>和<strong>exit</strong>。contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制。</p><p>一个上下文管理器通过with声明激活, 而且API包含两个方法。__enter__()方法运行执行流进入到with代码块内。他返回一个对象共上下文使用。当执行流离开with块时，__exit__()方法上下文管理器清除任何资源被使用。</p><h2 id="closing"><a href="#closing" class="headerlink" title="@closing"></a>@closing</h2><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()。</p><p>closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%884.47.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p><h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><p>urllib提供了一系列用于操作URL的功能。</p><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应。</p><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p><h2 id="DOM-vs-SAX"><a href="#DOM-vs-SAX" class="headerlink" title="DOM vs SAX"></a>DOM vs SAX</h2><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p><p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p><p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%884.57.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。</p><h1 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h1><p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p><p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。</p><p>Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码。</p><p>利用HTMLParser，可以把网页中的文本、图像等解析出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;datetime&quot;&gt;&lt;a href=&quot;#datetime&quot; class=&quot;headerlink&quot; title=&quot;datetime&quot;&gt;&lt;/a&gt;datetime&lt;/h1&gt;&lt;p&gt;datetime是Python处理日期和时间的标准库。&lt;/p&gt;
&lt;h2 id=&quot;获取当前日期
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第三章 统计语言模型</title>
    <link href="https://github.com/zdkswd/2018/09/18/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/zdkswd/2018/09/18/数学之美 第三章 统计语言模型/</id>
    <published>2018-09-18T12:25:32.000Z</published>
    <updated>2018-09-18T12:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>自然语言从它产生开始,逐渐演变成一种上下文相关的信息表达和传递的方式,因此让计算机处理自然语言,一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型( Statistical Language Model),它是今天所有自然语言处理的基础,并且广泛应用于机器翻译、语音识别、印刷体或手写体识别、拼写纠错、汉字输入和文献查询。</p><h1 id="用数学的方法描述语言规律"><a href="#用数学的方法描述语言规律" class="headerlink" title="用数学的方法描述语言规律"></a>用数学的方法描述语言规律</h1><p>统计语言模型产生的初衷是为了解决语音识别问题。</p><p>相比较于传统的基于语法语义的分析。贾里尼克的出发点很简单:一个句子是否合理,就看看它的可能性大小如何。至于可能性就用概率来衡量。第一个句子出现的概率大致是十的负二十次方，第二个句子出现的概率是十的负二十五次方,第三个句子出现的概率是十的负七十次方。因此,第一个最有可能,它的可能是第二个句子的10万倍,是第三个句子的一百亿亿亿亿亿亿倍。这个方法更普通而严格的描述是:</p><p>假定S表示某一个有意义的句子，由一连串特定顺序排列的词w1,w2,…,wn组成，这里n是句子的长度。若是想知道S在文本中出现的可能性，即数学上所说的S的概率P（S）。当然可以把世界上所有出现过的话统计一下，便知道这句话出现的概率了。当然这是不可能做到的。因此，需要有个模型来估算它。S=w1,w2,…,wn,那么P(S)=P(w1,w2,…,wn)<br>利用条件概率公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.36.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>到了词wn，它的出现概率取决于它前面的所有词，到了最后一个词wn，条件概率P的可能性太多，无法估算。</p><p>俄罗斯数学家提出了一个偷懒且颇为有效的方法，即<strong>马尔科夫假设</strong>。假设任意一个词wi出现的概率只同它前面的词wi-1有关。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.46.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>公式对应的统计语言模型是二元模型。假设一个词由前面N-1个词决定，对应的模型稍微复杂些，被称为N元模型。</p><p><img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.55.16.png" alt=""></p><p>估计联合概率P(wi-1，wi)和边缘概率P(wi-1),现在变得很简单。因为有了大量机读文本,也就是专业人土讲的语料库,只要数一数wi-1,wi这对词在统计的文本中前后相邻出现了多少次#（w-1,w),以及W-1本身在同样的文本中出现了多少次#(wi-1),然后用两个数分别除以语料库的大小#,即可得到这些词或者二元组的相对频度:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.53.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>根据大数定理，只要统计量足够，相对频度就等于概率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.59.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="统计语言模型的工程诀窍"><a href="#统计语言模型的工程诀窍" class="headerlink" title="统计语言模型的工程诀窍"></a>统计语言模型的工程诀窍</h1><h2 id="高阶语言模型"><a href="#高阶语言模型" class="headerlink" title="高阶语言模型"></a>高阶语言模型</h2><p>显然一个词只跟前面一个词有关，似乎太简化，因此，更普遍的假设是某个词和前面若干个词有关。</p><p>假定文本中的每个词wi和前面N-1个词有关，而与更前面的词无关，这样当前词wi的概率只取决于前面N-1个词P。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%883.06.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这就是N-1阶马尔可夫假设，对应的语言模型称为N元模型。而实际应用中使用最多的是N=3的三元模型，更高阶的模型就很少使用了。</p><p>主要是因为N元模型的空间复杂度几乎是N的指数函数，即O（|V|^N），这里|V|是一种语言词典的词汇量，一般在几万到几十万个。同样时间复杂度也几乎是一个指数函数O（|V|^（N-1）），因此N不能很大。当N从1到2，再从2到3时，模型的效果上升显著。当模型从3到3时，效果的提升就不是很显著了，而资源的耗费增加却非常快，所以，除非是不惜资源为了做到极致，很少有人使用四元以上<br>的模型。Google的罗塞塔翻译系统和语言搜索系统,使用的是四元模型,该模型存储于500台以上的 Google服务器中。</p><h2 id="模型的训练、零概率问题和平滑方法"><a href="#模型的训练、零概率问题和平滑方法" class="headerlink" title="模型的训练、零概率问题和平滑方法"></a>模型的训练、零概率问题和平滑方法</h2><p>使用语言模型需要知道模型中所有的条件概率,我们称之为模型的参数。通过对语料的统计,得到这些参数的过程称作模型的训练。</p><p>在数理统计中,我们之所以敢于用对采样数据的观察结果来预测概率,是因为有大数定理( Law of Large Numbers)在背后做支持,它的要求是有足够的观测值。</p><p>一个直接的办法就是增加数据量,但是即使如此,依然会遇到零概率或者统计量不足的问题。假定要训练一个汉语的语言模型,汉语的词汇量大致是20万这个量级,训练一个三元模型就有8*10的15次方个不同的参数。假如从互联网上刨去垃圾数据,有100亿个有意义的中文网页,这已经是相当高估的数据,每个网页平均1000词。那么,即使将互联网上全部的中文内容都用作训练,依然只有10的13次方,因此,如果用<br>直接的比值计算概率,大部分条件概率依然是零,这种模型我们称之为不平滑。在实际应用中,统计语言模型的零概率问题是无法回避的。</p><p>古德-图灵估计可以解决这个问题。当一个词出现的频次过小时，统计可能不可靠，计算它们的概率时要使用一个更小一点的次数,是dr(而不直接使用r),古德-图灵估计按照下面的公式计算dr：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%884.16.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在语料库中出现r次的词有Nr个，语料库的大小为N。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%884.22.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>一般来说,出现一次的词的数量比出现两次的多,出现两次的比出现三次的多。这种规律称为zipf定律(zipf’s Law)。</p><p>r越大词的数量Nr越小。因此一般情况下dr&lt;r,而d0&gt;0。这样就给未出现的词赋予了一个很小的非零值，从而解决了零概率的问题。同时下调了出现频率很低的词的概率。当然,在实际的自然语言处理中,一般对出现次数超过某个阈值的词,频率不下调,只对出现次数低于这个阈值的词,频率才下调,下调得到的频率总和给未出现的词。</p><p>这样出现r次的词的概率估计为dr/N。于是,对于频率超过一定阈值的词,它们的概率估计就是它们在语料库中的相对频度,对于频率小于这个阈值的词,它们的概率估计就小于它们的相对频度,出现次数越少的,折扣越多。对于未看见的词,也给予了一个比较小的概率。这样所有词的概率估计都很平滑了。</p><p>例如对于三元模型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%888.15.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>函数fgt()表示经过古德-图灵估计后的相对频度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%888.16.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="语料的选取问题"><a href="#语料的选取问题" class="headerlink" title="语料的选取问题"></a>语料的选取问题</h1><p>训练数据应当相关，训练数据通常是越多越好。虽然介绍了相关的方法去解决缺数据的问题，但是在数据量最多的时候概率模型的参数可以估计得比较准确，高阶的模型因为参数多,需要的训练数据也相应会多很多。遗憾的是,并非所有的应用都能得到足够的训练数据,比如说机器翻译的双语语料就非常少,在这种情况下片面追求高阶的大模型就变得一点意义也没有了。</p><p>在训练数据和应用数据一致并且训练量足够大的情况下,训练语料的噪音高低也会对模型的效果产生一定的影响,因此,在训练以前有时需要对训练数据进行预处理。一般情况下,少量的(没有模式的)随机噪音清除起来成本非常髙,通常就不做处理了。但是对于能找到模式( Pattern)的、量比较大的噪音还是需要进行过滤的,而且它们也比较容易处理,比如网页文本中大量的制表符。因此,在成本不高的情况<br>下,过滤训练数据还是需要做的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自然语言从它产生开始,逐渐演变成一种上下文相关的信息表达和传递的方式,因此让计算机处理自然语言,一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型( Statistical Language Model),它是今
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
