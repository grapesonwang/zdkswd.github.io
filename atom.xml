<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-09-26T10:17:13.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学之美 第四章 谈谈中文分词</title>
    <link href="https://github.com/zdkswd/2018/09/26/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B0%88%E8%B0%88%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    <id>https://github.com/zdkswd/2018/09/26/数学之美 第四章 谈谈中文分词/</id>
    <published>2018-09-26T10:16:32.000Z</published>
    <updated>2018-09-26T10:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中文分词方法的演变"><a href="#中文分词方法的演变" class="headerlink" title="中文分词方法的演变"></a>中文分词方法的演变</h1><p>对于西方拼音语言来说，词之间有明显的分界符，统计和使用语言模型非常直接。而对于中日韩泰等语言，词之间没有明确的分界符。</p><p>最容易想到的分词方法,也是最简单的办法,就是查字典。“查字典”的办法,其实就是把一个句子从左向右扫描一遍,遇到字典里有的词就标识出来,遇到复合词(比如“上海大学”)就找最长的词匹配,遇到不认识的字串就分割成单字词,于是简单的分词就完成了。</p><p>这个最简单的方法可以解决七八成以上的分词问题,遇到稍微复杂一点的问题就无能为力了。这种方法的一个明显不足时当遇到有二义性的分割时无能为力，另外并非所有的最长匹配都是一定正确的。</p><p>利用统计语言模型分词的方法,可以用几个数学公式简单概括如下:假定一个句子S可以有几种分词方法,为了简单起见,假定有以下三种:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B0%88%E8%B0%88%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%885.52.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中,A1,A2…B1,B2…,C1,C2…等等都是汉语的词,那么最好的一种分词方法应该保证分完词后这个句子出现的概率最大。</p><p>当然,这里面有一个实现的技巧。如果穷举所有可能的分词方法并计算出每种可能性下句子的概率,那么计算量是相当大的。因此,可以把它看成是一个动态规划( Dynamic Programming)的问题,并利用维特比( Viterbi)算法快速地找到最佳分词。(我们在后面的章节会介绍该算法。)</p><p>一般来讲,根据不同应用,汉语分词的颗粒度大小应该不同。</p><p>中文分词方法可以帮助判别英语单词的边界。因为手写英文字符时已经不能明显的区分边界了。</p><p>最后,需要指出的是任何方法都有它的局限性,虽然利用统计语言模型进行分词,可以取得比人工更好的结果,但是也不可能做到百分之百准确。因为统计语言模型很大程度上是依照“大众的想法”,或者“多数句子的用法”,而在特定情况下可能是错的。</p><h1 id="工程上的细节"><a href="#工程上的细节" class="headerlink" title="工程上的细节"></a>工程上的细节</h1><h2 id="分词的一致性"><a href="#分词的一致性" class="headerlink" title="分词的一致性"></a>分词的一致性</h2><p>如何衡量分词结果的对与错,好与坏看似容易,其实不是那么简单。说它看似容易,是因为只要对计算机分词的结果和人工分词的结果进行比较就可以了。说它不是那么简单,是因为不同的人对同一个句子可能有不同的分词方法。不同的人对词的切分看法上的差异性远比我们想象的要大得多。当统计语言模型被广泛应用后,不同的分词器产生的结果的差异要远远小于不同人之间看法的差异,这时简单依靠与人工分词的结果比较来衡量分词器的准确性就很难,甚至是毫无意义的了。中文分词现在是一个已经解决了的问题,提高的空间微乎其微了。只要采用统计语言模型,效果都差不到哪里去。</p><h2 id="词的颗粒度和层次"><a href="#词的颗粒度和层次" class="headerlink" title="词的颗粒度和层次"></a>词的颗粒度和层次</h2><p>人工分词产生不一致性的原因主要在于人们对词的颗粒度的认识问题。在这里不去强调谁的观点对,而是要指出在不同的应用中,会有一种颗粒度比另一种更好的情况。比如在机器翻译中,一般来讲,颗粒度大翻译效果好。比如“联想公司”作为一个整体,很容易找到它对应的英语翻译 Lenovo,如果分词时将它们分开,很有可能翻译失败。</p><p>虽然可以对不同的应用构造不同的分词器,但是这样做不仅非常浪费,而且也不必要。更好的方法是让一个分词器同时支持不同层次的词的切分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中文分词方法的演变&quot;&gt;&lt;a href=&quot;#中文分词方法的演变&quot; class=&quot;headerlink&quot; title=&quot;中文分词方法的演变&quot;&gt;&lt;/a&gt;中文分词方法的演变&lt;/h1&gt;&lt;p&gt;对于西方拼音语言来说，词之间有明显的分界符，统计和使用语言模型非常直接。而对于中日韩
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 常用内建库</title>
    <link href="https://github.com/zdkswd/2018/09/24/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97%20/"/>
    <id>https://github.com/zdkswd/2018/09/24/Python廖雪峰 常用内建模块 /</id>
    <published>2018-09-24T09:05:56.000Z</published>
    <updated>2018-09-24T09:07:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><p>datetime是Python处理日期和时间的标准库。</p><h2 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.11.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。</p><p>如果仅导入import datetime，则必须引用全名datetime.datetime。</p><p>datetime.now()返回当前日期和时间，其类型是datetime。</p><h2 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h2><p>直接用参数构造一个datetime。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.14.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h2><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</p><p>timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p><p>把一个datetime类型转换为timestamp只需要简单调用timestamp()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.17.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>注意</strong>Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。</p><p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p><h2 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h2><p>要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.22.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这个得到的时间就是当前操作系统设定的时区，timestamp也可以直接被转换到UTC标准时区的时间。datetime.utcfromtimestamp</p><h2 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h2><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.26.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h2><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.28.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h2><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.34.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="本地时间转换为UTC时间"><a href="#本地时间转换为UTC时间" class="headerlink" title="本地时间转换为UTC时间"></a>本地时间转换为UTC时间</h2><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p><h2 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h2><p>我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间。</p><p>datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p><h1 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h1><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%881.43.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。</p><p>作用是更直接，像类一样表明这个的用途，但又不是类，没那么重。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.05.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.10.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。</p><p>除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。</p><h2 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p><p>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序。</p><p>dict内是无序的。</p><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>Counter是一个简单的计数器，例如，统计字符出现的个数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.40.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Counter实际上也是dict的一个子类。</p><h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p><p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%。6bit表示一个字符在表中的位置。表中共有64个字符。</p><p>Python内置的base64可以直接进行base64的编解码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符+和/分别变成-和_<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%882.54.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。</p><p>尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p><h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p><p>摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p><p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p><p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p><p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p><p>这个函数是一个单向函数，可以通过对比结果的不同来判断原文是否发生过篡改。当然有可能发生两个不同的数据通过某个摘要算法得到了相同的摘要，这种情况叫做碰撞，非常非常罕见。</p><p>可以用来在数据库中存储使用md5加密过后的密码，用户登录时，经过计算再与数据库中的摘要作比较。</p><h1 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h1><p>Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p><p>Python自带的hmac模块实现了标准的Hmac算法。</p><p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%883.26.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。</p><p>Python内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。</p><h1 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h1><p>Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。</p><h2 id="chain"><a href="#chain" class="headerlink" title="chain()"></a>chain()</h2><p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器</p><h2 id="groupby"><a href="#groupby" class="headerlink" title="groupby()"></a>groupby()</h2><p>groupby()把迭代器中相邻的重复元素挑出来放在一起。</p><h1 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h1><p>实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句。实现上下文管理是通过<strong>enter</strong>和<strong>exit</strong>这两个方法实现的。 一个是with触发的时候，一个是退出的时候。编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法。</p><p>contextlib是个比with优美的东西，也是提供上下文机制的模块，它是通过Generator装饰器实现的。不再是采用<strong>enter</strong>和<strong>exit</strong>。contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制。</p><p>一个上下文管理器通过with声明激活, 而且API包含两个方法。__enter__()方法运行执行流进入到with代码块内。他返回一个对象共上下文使用。当执行流离开with块时，__exit__()方法上下文管理器清除任何资源被使用。</p><h2 id="closing"><a href="#closing" class="headerlink" title="@closing"></a>@closing</h2><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()。</p><p>closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%884.47.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p><h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><p>urllib提供了一系列用于操作URL的功能。</p><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应。</p><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p><h2 id="DOM-vs-SAX"><a href="#DOM-vs-SAX" class="headerlink" title="DOM vs SAX"></a>DOM vs SAX</h2><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p><p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p><p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15377657274289/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8B%E5%8D%884.57.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。</p><h1 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h1><p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p><p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。</p><p>Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码。</p><p>利用HTMLParser，可以把网页中的文本、图像等解析出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;datetime&quot;&gt;&lt;a href=&quot;#datetime&quot; class=&quot;headerlink&quot; title=&quot;datetime&quot;&gt;&lt;/a&gt;datetime&lt;/h1&gt;&lt;p&gt;datetime是Python处理日期和时间的标准库。&lt;/p&gt;
&lt;h2 id=&quot;获取当前日期
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第三章 统计语言模型</title>
    <link href="https://github.com/zdkswd/2018/09/18/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/zdkswd/2018/09/18/数学之美 第三章 统计语言模型/</id>
    <published>2018-09-18T12:25:32.000Z</published>
    <updated>2018-09-18T12:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>自然语言从它产生开始,逐渐演变成一种上下文相关的信息表达和传递的方式,因此让计算机处理自然语言,一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型( Statistical Language Model),它是今天所有自然语言处理的基础,并且广泛应用于机器翻译、语音识别、印刷体或手写体识别、拼写纠错、汉字输入和文献查询。</p><h1 id="用数学的方法描述语言规律"><a href="#用数学的方法描述语言规律" class="headerlink" title="用数学的方法描述语言规律"></a>用数学的方法描述语言规律</h1><p>统计语言模型产生的初衷是为了解决语音识别问题。</p><p>相比较于传统的基于语法语义的分析。贾里尼克的出发点很简单:一个句子是否合理,就看看它的可能性大小如何。至于可能性就用概率来衡量。第一个句子出现的概率大致是十的负二十次方，第二个句子出现的概率是十的负二十五次方,第三个句子出现的概率是十的负七十次方。因此,第一个最有可能,它的可能是第二个句子的10万倍,是第三个句子的一百亿亿亿亿亿亿倍。这个方法更普通而严格的描述是:</p><p>假定S表示某一个有意义的句子，由一连串特定顺序排列的词w1,w2,…,wn组成，这里n是句子的长度。若是想知道S在文本中出现的可能性，即数学上所说的S的概率P（S）。当然可以把世界上所有出现过的话统计一下，便知道这句话出现的概率了。当然这是不可能做到的。因此，需要有个模型来估算它。S=w1,w2,…,wn,那么P(S)=P(w1,w2,…,wn)<br>利用条件概率公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.36.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>到了词wn，它的出现概率取决于它前面的所有词，到了最后一个词wn，条件概率P的可能性太多，无法估算。</p><p>俄罗斯数学家提出了一个偷懒且颇为有效的方法，即<strong>马尔科夫假设</strong>。假设任意一个词wi出现的概率只同它前面的词wi-1有关。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.46.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>公式对应的统计语言模型是二元模型。假设一个词由前面N-1个词决定，对应的模型稍微复杂些，被称为N元模型。</p><p><img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.55.16.png" alt=""></p><p>估计联合概率P(wi-1，wi)和边缘概率P(wi-1),现在变得很简单。因为有了大量机读文本,也就是专业人土讲的语料库,只要数一数wi-1,wi这对词在统计的文本中前后相邻出现了多少次#（w-1,w),以及W-1本身在同样的文本中出现了多少次#(wi-1),然后用两个数分别除以语料库的大小#,即可得到这些词或者二元组的相对频度:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.53.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>根据大数定理，只要统计量足够，相对频度就等于概率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%882.59.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="统计语言模型的工程诀窍"><a href="#统计语言模型的工程诀窍" class="headerlink" title="统计语言模型的工程诀窍"></a>统计语言模型的工程诀窍</h1><h2 id="高阶语言模型"><a href="#高阶语言模型" class="headerlink" title="高阶语言模型"></a>高阶语言模型</h2><p>显然一个词只跟前面一个词有关，似乎太简化，因此，更普遍的假设是某个词和前面若干个词有关。</p><p>假定文本中的每个词wi和前面N-1个词有关，而与更前面的词无关，这样当前词wi的概率只取决于前面N-1个词P。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%883.06.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这就是N-1阶马尔可夫假设，对应的语言模型称为N元模型。而实际应用中使用最多的是N=3的三元模型，更高阶的模型就很少使用了。</p><p>主要是因为N元模型的空间复杂度几乎是N的指数函数，即O（|V|^N），这里|V|是一种语言词典的词汇量，一般在几万到几十万个。同样时间复杂度也几乎是一个指数函数O（|V|^（N-1）），因此N不能很大。当N从1到2，再从2到3时，模型的效果上升显著。当模型从3到3时，效果的提升就不是很显著了，而资源的耗费增加却非常快，所以，除非是不惜资源为了做到极致，很少有人使用四元以上<br>的模型。Google的罗塞塔翻译系统和语言搜索系统,使用的是四元模型,该模型存储于500台以上的 Google服务器中。</p><h2 id="模型的训练、零概率问题和平滑方法"><a href="#模型的训练、零概率问题和平滑方法" class="headerlink" title="模型的训练、零概率问题和平滑方法"></a>模型的训练、零概率问题和平滑方法</h2><p>使用语言模型需要知道模型中所有的条件概率,我们称之为模型的参数。通过对语料的统计,得到这些参数的过程称作模型的训练。</p><p>在数理统计中,我们之所以敢于用对采样数据的观察结果来预测概率,是因为有大数定理( Law of Large Numbers)在背后做支持,它的要求是有足够的观测值。</p><p>一个直接的办法就是增加数据量,但是即使如此,依然会遇到零概率或者统计量不足的问题。假定要训练一个汉语的语言模型,汉语的词汇量大致是20万这个量级,训练一个三元模型就有8*10的15次方个不同的参数。假如从互联网上刨去垃圾数据,有100亿个有意义的中文网页,这已经是相当高估的数据,每个网页平均1000词。那么,即使将互联网上全部的中文内容都用作训练,依然只有10的13次方,因此,如果用<br>直接的比值计算概率,大部分条件概率依然是零,这种模型我们称之为不平滑。在实际应用中,统计语言模型的零概率问题是无法回避的。</p><p>古德-图灵估计可以解决这个问题。当一个词出现的频次过小时，统计可能不可靠，计算它们的概率时要使用一个更小一点的次数,是dr(而不直接使用r),古德-图灵估计按照下面的公式计算dr：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%884.16.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在语料库中出现r次的词有Nr个，语料库的大小为N。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%884.22.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>一般来说,出现一次的词的数量比出现两次的多,出现两次的比出现三次的多。这种规律称为zipf定律(zipf’s Law)。</p><p>r越大词的数量Nr越小。因此一般情况下dr&lt;r,而d0&gt;0。这样就给未出现的词赋予了一个很小的非零值，从而解决了零概率的问题。同时下调了出现频率很低的词的概率。当然,在实际的自然语言处理中,一般对出现次数超过某个阈值的词,频率不下调,只对出现次数低于这个阈值的词,频率才下调,下调得到的频率总和给未出现的词。</p><p>这样出现r次的词的概率估计为dr/N。于是,对于频率超过一定阈值的词,它们的概率估计就是它们在语料库中的相对频度,对于频率小于这个阈值的词,它们的概率估计就小于它们的相对频度,出现次数越少的,折扣越多。对于未看见的词,也给予了一个比较小的概率。这样所有词的概率估计都很平滑了。</p><p>例如对于三元模型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%888.15.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>函数fgt()表示经过古德-图灵估计后的相对频度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15372330494504/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-18%20%E4%B8%8B%E5%8D%888.16.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="语料的选取问题"><a href="#语料的选取问题" class="headerlink" title="语料的选取问题"></a>语料的选取问题</h1><p>训练数据应当相关，训练数据通常是越多越好。虽然介绍了相关的方法去解决缺数据的问题，但是在数据量最多的时候概率模型的参数可以估计得比较准确，高阶的模型因为参数多,需要的训练数据也相应会多很多。遗憾的是,并非所有的应用都能得到足够的训练数据,比如说机器翻译的双语语料就非常少,在这种情况下片面追求高阶的大模型就变得一点意义也没有了。</p><p>在训练数据和应用数据一致并且训练量足够大的情况下,训练语料的噪音高低也会对模型的效果产生一定的影响,因此,在训练以前有时需要对训练数据进行预处理。一般情况下,少量的(没有模式的)随机噪音清除起来成本非常髙,通常就不做处理了。但是对于能找到模式( Pattern)的、量比较大的噪音还是需要进行过滤的,而且它们也比较容易处理,比如网页文本中大量的制表符。因此,在成本不高的情况<br>下,过滤训练数据还是需要做的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自然语言从它产生开始,逐渐演变成一种上下文相关的信息表达和传递的方式,因此让计算机处理自然语言,一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型( Statistical Language Model),它是今
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第二章 自然语言处理--从规则到统计</title>
    <link href="https://github.com/zdkswd/2018/09/18/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86--%E4%BB%8E%E8%A7%84%E5%88%99%E5%88%B0%E7%BB%9F%E8%AE%A1/"/>
    <id>https://github.com/zdkswd/2018/09/18/数学之美 第二章 自然语言处理--从规则到统计/</id>
    <published>2018-09-18T01:07:32.000Z</published>
    <updated>2018-09-18T01:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何语言都是一种编码的方式，而语言的语法规则则是编解码的算法。</p><p>在上世纪70年代之前，计算机对自然语言的处理集中在分析语句和获取语义，基于规则的自然语言处理。主要是因为当时的学术界存在误区，即要让计算机完成翻译或者是语音识别这样只有人类能做到的事情，就必须先让计算机理解自然语言。因为从直觉上大家都会这么认为。但是相比于上下文无关文法，自然语言这种上下文有关的文法对于同样长度的句子复杂度是前者的万倍，因为上下文有关，所以需要更多额外的信息来表示现在的上下文，以及将自然语言变成及其复杂得树，在计算能力没法跟上的那个年代根本没有办法商用。</p><h1 id="从规则到统计"><a href="#从规则到统计" class="headerlink" title="从规则到统计"></a>从规则到统计</h1><p>随着保守的教授陆续的退休，慢慢地研究方向从基于规则逐渐转向了基于统计。</p><p>15年,对于一个学者来讲是一段非常长的时间,如果哪个人从做博士开始就选错了方向并且坚持错误,到15年后发现时,基本上这一辈子可能就一事无成了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>基于统计的自然语言处理方法，在数学模型和通信是相通的，甚至就是相同的。因此，在数学意义上自然语言处理又和语言的初衷–通信联系在一起了。但是，科学家们认识到这个联系却花了几十年的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;任何语言都是一种编码的方式，而语言的语法规则则是编解码的算法。&lt;/p&gt;
&lt;p&gt;在上世纪70年代之前，计算机对自然语言的处理集中在分析语句和获取语义，基于规则的自然语言处理。主要是因为当时的学术界存在误区，即要让计算机完成翻译或者是语音识别这样只有人类能做到的事情，就必须先让
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数学之美 第一章 文字和语言vs数字和信息</title>
    <link href="https://github.com/zdkswd/2018/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%96%87%E5%AD%97%E5%92%8C%E8%AF%AD%E8%A8%80vs%E6%95%B0%E5%AD%97%E5%92%8C%E4%BF%A1%E6%81%AF/"/>
    <id>https://github.com/zdkswd/2018/09/14/数学之美 第一章 文字和语言vs数字和信息/</id>
    <published>2018-09-14T12:41:32.000Z</published>
    <updated>2018-09-14T12:41:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15369247546524/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-14%20%E4%B8%8B%E5%8D%888.03.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="文字和数字"><a href="#文字和数字" class="headerlink" title="文字和数字"></a>文字和数字</h1><p>当语言和词汇多到一定程度时，人类仅靠大脑已经记不住所有的词汇了。高效记录信息的需求就产生了，这便是文字。</p><p>最早是象形文字，当文字的数量多到一定程度时便不再增加了，于是开始了对概念的概括与归类。比如中文的一字多意。对于概念的聚类在原理上与今天自然语言处理或机器学习的聚类有很大的相似性。</p><p>文字按照意思来聚类，最终会带来一些歧义性，解决这个问题的方法过去与现在并没有什么不同，都是依靠上下文。但是还是会有有歧义的情况发生。今天的情况也是这样，对上下文建立的概率模型再好也有失灵的时候。这些事语言从产生开始就固有的特点。</p><p>翻译之所以能够进行，仅仅是因为不同的文字系统在记录信息上的能力是等价的（这一点非常重要）。文字只是信息的载体，而非信息本身。即使不用文字使用如数字的载体也可以存储同样意义的信息。这便是现代通信的基础。</p><p>当然,不同的文明进行交流时,或许会用不同的文字记载同一件事情。这就有可能为我们破解无人能懂的语言提供一把钥匙。</p><p><strong>罗塞塔</strong>石碑使用了三种语言记录的同一件事情，罗塞塔石碑的破解有两点指导意义。首先，信息的冗余是信息安全的保障，其次，语言的数据，又称为语料尤其是双语或者多语对照语料对翻译至关重要。</p><p>既然文字是出现在远古“信息爆炸”导致人们的头脑装不下这些信息的时候,那么数字的出现则是在人们的财产多到需要数一数才搞清楚有多少的时候。</p><p>最开始是掰手指头来计数的，所以自然而然的就是十进制了。当然，也有连脚指头算上去的民族，所以他们是二十进制。当十进制不够用时，我们的祖先很聪明,他们发明了进位制,也就是我们今天说的逢十进一。这是人类在科学上的一大飞跃,因为我们的祖先懂得对数量开始编码了,不同的数字代表不同的量。比如二百，就是编过码的数字，解码的方法是乘法2*100。从编码的有效性来说，中国人的做法比罗马人高明。</p><p>阿拉伯人传播的古印度发明的数字123是革命性的，标志着数字和文字的分离。</p><h1 id="文字和语言背后的数学"><a href="#文字和语言背后的数学" class="headerlink" title="文字和语言背后的数学"></a>文字和语言背后的数学</h1><p>但是,任何事物的规律性是内在的,并不随它的载体而改变。自然语言的发展在冥冥之中,都受着信息科学规律的引导。</p><p>从象形文字到拼音文字是一个飞跃,因为人类在描述物体的方式上,从物体的外表到抽象的概念,同时不自觉地采用了对信息的编码。不仅如此,我们的祖先对文字的编码还非常合理。常用的较短，不常用的较长。这完全符合信息论中的最短编码原理。</p><p>在蔡伦发明纸张以前,书写文字不是一件容易的事情。就以中文为例在东汉以前要将文字刻在其他物件比如龟壳、石碑和竹简上。由于刻个字的时间相当长,因此要惜墨如金。这就使得我们的古文(书面文字)非常简洁,但是非常难懂,而同时期的口语却和今天的白话差别不大,语句较长但是易懂。(岭南客家话基本上保留了古代口语的原貌,写出来和我们清末民初的白话颇为相似。)这种现象非常符合今天信息科学(和工程)的一些基本原理,就是在通信时,如果信道较宽,信息不必压缩就可以直接传递;而如果信道很窄,信息在传递前需要尽可能地压缩,然后在接收端进行解压缩。</p><p>犹太人在抄写《圣经》时,抄写错误还是难以避免。于是犹<br>太人发明了一种类似于我们今天计算机和通信中<strong>校验码</strong>的方法。他们把每一个希伯来字母对应于一个数字,这样每行文字加起来便得到一个特殊的数字,这个数字便成为了这一行的校验码。同样,对于每一列也是这样处理。当犹太学者抄完一页《圣经》时,他们需要把每一行的文字加起来,看看新的校验码是否和原文的相同,然后对每一页进行同样的处理。如果这一页每一行和每一列的校验码和原文完全相同,说明这一页的抄写无误。如果某行的校验码和原文中的对应不上,则说明这行至少有一个抄写错误。当然,错误对应列的校验码也一定和原文对不上,这样可以很快找到出错的地方。</p><p>如果说从字母到词的构词法(Morphology)是词的编码规则,那么语法则是语言的编码和解码规则。不过,相比较而言,词可以被认为是有限而且封闭的集合,而语言则是无限和开放的集合。从数学上讲,对于前者可以有完备的编解码规则,而后者则不具备这个特性。因此,任何语言都有语法规则覆盖不到的地方,这些例外或者说不精确性,让我们的语言丰富多彩。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这些今天自然语言处理学者们研究的问题,我们的祖先在设计语言的时候其实已经遇到了,并且用类似今天的方法解决了,虽然他们的认识大多是自发的,而不是自觉的。他们过去遵循的法则和我们今天探求的研究方法背后有着共同的东西,这就是数学规律。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;

      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>浪潮之巅读书笔记</title>
    <link href="https://github.com/zdkswd/2018/09/14/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/zdkswd/2018/09/14/浪潮之巅读书笔记/</id>
    <published>2018-09-14T11:08:47.000Z</published>
    <updated>2018-09-14T11:09:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转载加修改，自用。"><a href="#转载加修改，自用。" class="headerlink" title="转载加修改，自用。"></a>转载加修改，自用。</h1><h1 id="对书名《浪潮之巅》中“浪潮”的理解"><a href="#对书名《浪潮之巅》中“浪潮”的理解" class="headerlink" title="对书名《浪潮之巅》中“浪潮”的理解"></a>对书名《浪潮之巅》中“浪潮”的理解</h1><p>书名为“浪潮之巅”。顾名思义，本书就是讲述那些曾经或正站在互联网浪潮的巅峰的企业。书中列举了好多我们耳熟能详的企业名称，例如苹果公司、微软、诺基亚等等，“之巅”大家都能理解，即”巅峰“的意思，这些公司无疑能让大家所知，无疑都是在各自领域中极有成就的，然而成就它们达到巅峰状态的，除了自身的内功之外，无一例外的，就是这些伟大的公司都赶上了IT产业的兴起、发展与升级。<br>因而“浪潮”可以这样理解：科技革命的浪潮，同时也可以专指信息技术革命的浪潮。</p><h1 id="那些曾经或正在浪潮之巅的弄潮儿们"><a href="#那些曾经或正在浪潮之巅的弄潮儿们" class="headerlink" title="那些曾经或正在浪潮之巅的弄潮儿们"></a>那些曾经或正在浪潮之巅的弄潮儿们</h1><h2 id="帝国黄昏之AT-amp-T公司"><a href="#帝国黄昏之AT-amp-T公司" class="headerlink" title="帝国黄昏之AT&amp;T公司"></a>帝国黄昏之AT&amp;T公司</h2><p>AT&amp;T公司创始人，说起来很有名，即使电话的发明人贝尔，后来AT&amp;T公司旗下有闻名于世的贝尔实验室，该实验室出过十一位诺贝尔奖得主。</p><p>AT&amp;T可谓老字号，于1877年成立，一百年来发展的顺风顺水，很长时期内垄断整个北美的通信业务。虽然有美国政府的反垄断调查，但是每次调查都会帮AT&amp;T公司剪除枝叶，让它更加茁壮。例如1913年美国司法部的调查，避免了AT&amp;T公司的大肆扩张，这反而让它顺利度过了大萧条时期。</p><p>时间到了1984年，AT&amp;T终于挺不过<strong>反垄断调查</strong>，公司进行了拆分，由一家分成7家，这次修剪让AT&amp;T公司从以通话业务为主转向了新兴的网络和移动通信方面。</p><p>1995年在华尔街<strong>逐利的资本驱动</strong>下，这一次公司高管自我拆分，而正是这个举动让AT&amp;T伤筋动骨。然而明白人大有人在，但是禁不住股票期权的诱惑，公司的未来在目前金钱的诱惑下一文不值。接下来的2000年公司又被拆分为四家，而此时AT&amp;T公司已经错过了互联网的浪潮。由于AT&amp;T主营业务是固定电话业务，互联网兴起后，人们可以直接用网络通话，再也不想用AT&amp;T那昂贵的通话业务了。<br>曾经最能代表行业发展的AT&amp;T，由于华尔街资本的贪婪和技术浪潮的波动，已经变成了明日黄花。</p><h2 id="科技界常青树之IBM"><a href="#科技界常青树之IBM" class="headerlink" title="科技界常青树之IBM"></a>科技界常青树之IBM</h2><p>IBM公司成立于1924年，由托马斯·华生创立。<br>IBM成立的时间正好是第二次工业革命的末期，它发明一种机器，能够帮助政府和大型企业组织进行统计数据的整理和简单分析，因而早期的IBM，<strong>其主要客户就是政府和大型组织。</strong></p><p>二战结束后，公司由托马斯·华生的儿子小华生接任，他是一位伟大的领导者，正是在他的带领下，IBM走向辉煌，并引领了第三次科技革命。</p><p>“电子计算机和IBM的名字是分不开的，就如同电话和AT&amp;T分不开一样”。吴军博士的这句话充分说明了IBM公司同电子计算机的相互促进作用。</p><p>在小华生的带领下，IBM投注计算机行业，在提高研究经费的同时也召来很多优秀工程师，并且参与了计算机行业标准的制定。正是这样的举动，IBM公司在小华生执掌期间，业绩年均增长30%，同时IBM公司很高的薪水也吸引了优秀的年轻人加入计算机行业。</p><p>从1950年代到1980年代这时期的IBM公司可以说是独孤求败。而这种垄断地位自然而然遭到了美国政府的反垄断调查。IBM公司不得不进行拆分，并想社会公布自己的一些专利和技术。</p><p>然而，由于IBM的业务重心一直在政府和大型企业这边，它就不可能把工作重点放在个人电脑业务上，此时一位天才人物比尔·盖茨看到了个人电脑的伟大前景，伴随着摩尔定律的作用，日渐强大的个人计算机不断蚕食IBM的主营业务，IBM就像一个走向坟墓的巨人。</p><p>1993年，郭士纳临危受命，拯救IBM。郭士纳果断出售不赚钱的硬件业务，把个人电脑业务卖给联想，从硬件制造商转型为服务政府和大型企业组织。这次转型是相当成功的，IBM公司成功从坟墓中爬了出来。</p><p>目前IBM公司是拥有专利最多的公司，在2001年起市值一度超过了微软。</p><h2 id="向死而生之苹果"><a href="#向死而生之苹果" class="headerlink" title="向死而生之苹果"></a>向死而生之苹果</h2><p>说起苹果公司，就一定要讲到史蒂夫·乔布斯。在吴军博士看来，他可谓是硅谷最具传奇色彩的人物。他是唯一一个大学没有超过一年就获得美国工程院院士的人，而他获选院士的理由是：在个人计算机领域的伟大贡献。</p><p>1976年苹果公司成立，当时乔布斯和他的小伙伴们的愿望是把昂贵的计算机商业化，让计算机走进千家万户。当时的计算机很昂贵，价值几万美元。而当苹果电脑一代出来时，只需花费数百美元。</p><p>虽然现在看起来苹果一代几乎做不了什么事，但这代表了计算机不再是大型组织的专属用品，它有可能走进千家万户。<br>与此同时，1980年代的IT产业巨人IBM也向个人计算机领域进军，一出售就占据了当时个人电脑市场的75%。针对于此，乔布斯致力于开发苹果二代，终于1984年研制出来，这是真正意义上有交互式图形界面并且有鼠标的个人电脑。而这个产品也广受市场欢迎，同时助推苹果股价攀上高峰<br>然而好景不长，此时的苹果公司邀请了原百事可乐总裁斯库利加盟，一年之后乔布斯出走。而苹果公司在斯库利的带领下，凭借乔布斯留下的财产，还能坚挺一阵子，然而苹果的摊子越铺越大，虽然开展了不少项目，但收效甚微。同时苹果电脑业务在微软的挤压下日薄西山。</p><p>1998年的苹果决定请回乔布斯，让他执掌苹果这艘破船，而乔布斯也不愿意看着自己所创立的公司倒闭，在他的带领下，苹果公司逐渐走出低谷，获得新生。</p><p>进入21世纪的苹果公司发展了两项业务：一个是iPod，一个是iPhone。</p><p>iPod的成功是因为乔布斯利用了音乐的数字化浪潮，而iPhone的成功同样借助3G时代的东风，如果这两件产品提前几年，估计不会有现在的成功，而乔布斯天才的地方在于他牢牢抓住了这两次浪潮，才成就了今天的苹果。</p><h2 id="前途未知的微软帝国"><a href="#前途未知的微软帝国" class="headerlink" title="前途未知的微软帝国"></a>前途未知的微软帝国</h2><p>吴军博士这样形容微软：“微软永远是所有公司最可怕的敌人。微软靠它在操作系统上的垄断地位和无比雄厚的财力，在计算机领域几乎是无往而不胜。</p><p>这句话放在《浪潮之巅》成书的那一年2008年——2009年还成立，但是现在由于谷歌和苹果的双重夹击，微软，这个被吴军博士称之为“IT业的罗马帝国”的人，前途还真的堪忧。</p><p>此话暂且不表，今日就来说说微软帝国如何成立的。<br>1980年代的微软，在乔布斯眼里还只是个小小的软件公司。然而微软有个天才，就是比尔·盖茨。虽然比尔·盖茨在其他领域可能不如乔布斯，但是他在商业经营上的天赋要高于乔布斯，通过两手抓的方式狙击了苹果。</p><p>一方面盖茨对苹果方面要求研发软件采用拖字诀；另一方面联合当时强大的IBM，开发新的、与苹果不同的操作系统。<br>没想到盖茨还有第三部，就是微软的操作系统便宜，他采用薄利多销的态度，因而吸引了大量计算机爱好者和软件研发者，他们在上面开发了各种各样的软件，这样用户就逐渐对微软的系统产生依赖。</p><p>就这样微软依靠自己相对廉价的操作系统，以及系统良好的兼容性，加上对手苹果公司存在的战略失误，帝国就这样建立起来。</p><p>1997年微软市场首次超过IBM，然而微软还不放心，它继续进行维护自己垄断地位的战争。这次它的手段是通过模仿比竞争对手更加廉价的产品，以及依靠自己的垄断地位来打击对手的。</p><p>然而没有永远的帝国，微软帝国在取得操作系统的绝对领先后，想进一步扩大优势，于是把眼光瞄向了互联网领域，这次迎接微软挑战的是新兴的雅虎，它比微软更绝，因为雅虎的服务是免费的。经过这次战役后，加上2000年的互联网泡沫，<strong>微软错过了进军互联网的最佳时机</strong>。</p><p>2015年下半年，微软将发布windows 10,它想实现所有操作平台的一体化，不知微软能否通过这一举动，实现王者归来？</p><h2 id="互联网中的福特——雅虎"><a href="#互联网中的福特——雅虎" class="headerlink" title="互联网中的福特——雅虎"></a>互联网中的福特——雅虎</h2><p>之所以称呼雅虎为互联网中的福特，是因为吴军博士认为雅虎对互联网的影响是可以同福特对汽车工业的影响相提并论的。</p><p>在汽车工业中，尽管汽车不是福特发明的，但是福特的生产模式，重新定义了汽车行业，并让普通工薪阶层买得起汽车。而雅虎对互联网行业的影响，在这一意义上，与福特对汽车产业的影响是相似的。</p><p>早期的互联网，其信息提供是面向用户收费的。不仅用户入网要收费，而且浏览信息也要收费，如果这样下去，互联网的发展将会和有线电视一样，几乎没有可能发展成现在的样子，而正是雅虎改变了这种状况，它把互联网办成了开放的、免费的，而且更重要的是，盈利的。</p><p>雅虎面向用户提供的服务是<strong>免费</strong>的，例如雅虎邮箱业务，而雅虎转而面向企业收取广告费，这样就形成了良性循环：免费模式吸引了更多的用户，而更多的用户意味着更多的流量，流量意味着广告商的投入更高效。</p><p>1996年雅虎上市，成为当时互联网的第一品牌，而其两位创始人——杨致远和大卫·肥罗——立刻成为了亿万富翁。</p><p>然而雅虎面对<strong>资本市场的疯狂追逐</strong>，它没有进行理性衡量，反而把自己的摊子越铺越大，因为雅虎要回应资本市场对它的期望，以支撑住它的股价。2000年，互联网泡沫崩溃，雅虎的股价下跌了90%。</p><p>从这之后，雅虎的股价再也没回到高峰，而更严重的是，雅虎并没有非常雄厚的技术积累，这个曾经的互联网巨头，按照吴军博士的话来说，已经进入了“红巨星”时代——恒星的最后一个阶段。</p><h2 id="消失的贵族——摩托罗拉"><a href="#消失的贵族——摩托罗拉" class="headerlink" title="消失的贵族——摩托罗拉"></a>消失的贵族——摩托罗拉</h2><p>曾经，没落罗拉就是无线通信的代名词，同时它还是品质和技术的保证。而现在它在浪潮的冲击下，从被谷歌收购，到现在转手联想，这其中的曲折让人叹息，然而我们不能忘记摩托罗拉曾经的荣耀，它也引领过浪潮。</p><p>摩托罗拉公司创立于1928年，原名加尔文制造公司，由创始人之一的保罗·加尔文的名字命名。最早生产汽车收音机，二战时该公司的一些工程师帮助政府研究无线通信工具，并获得军方的认可，由此开始，可以表现出该公司在无线通讯上的强悍技术。</p><p>二战后，由于摩托罗拉的品牌越来越响，加尔文公司干脆就改名为摩托罗拉。</p><p>从二战结束到20世纪90年代，可谓是摩托罗拉的黄金时代，摩托罗拉在模拟无线通信方面有任何公司都无法比拟的技术优势。</p><p>摩托罗拉最大的贡献是在20世纪80年代发明了“大哥大”，而且其品质受到人们的交口称赞。正是因为摩托罗拉的品质和技术优势，它很自然地垄断了第一代移动通信市场。当时的摩托罗拉手机占据了全球市场的70%。</p><p>然而时间进入到九十年代，以GSM为标准的第二代移动通信技术普及开来，由于这一技术标准是由欧洲制定，作为欧洲公司的诺基亚具有很大的地理优势和后发优势。另一方面摩托罗拉公司错误估计了信息技术的更新换代技术，而且<strong>摩托罗拉过度注重技术，忽视了消费者的需求</strong>，导致它的产品不如诺基亚和三星等亚洲公司的产品畅销。</p><p>尽管后来摩托罗拉推出过多款经典机型，例如著名的刀锋系列，但是已经回天乏术，2014年转手一次的摩托罗拉进入了联想。</p><h2 id="没落的雷神之锤——诺基亚"><a href="#没落的雷神之锤——诺基亚" class="headerlink" title="没落的雷神之锤——诺基亚"></a>没落的雷神之锤——诺基亚</h2><p>诺基亚是《浪潮之巅》中介绍的唯一一家欧洲公司，然而现在的命运也是堪称坎坷。从2007年的市占率40%到如今的黯然退出手机市场，诺基亚的名字貌似距离现在越来越远。</p><p>曾几何时诺基亚还是芬兰的一家木工厂，曾经它的业务也如摊大饼一般，不断寻找大的发展方向，其中一个尝试很重要，就是它在20世纪60年代为军方和商业用户提供对讲机，从这些业务中诺基亚积累了一定的技术。</p><p>1982年诺基亚研制出了一种可以移动的电话，然而此时的它还不能与当时的巨头摩托罗拉相比，直到20世纪80年代末因为项目太多，出现严重的亏损。</p><p>直到1992年通信业务才成为诺基亚的核心，这一转型使得诺基亚由一个普通的电子公司成为全球移动通信的领导者，除了正确的转型方向外，还有三点对诺基亚的成功很重要：第一，抓住了移动通信技术的转型浪潮；第二，芬兰政府的大力支持；第三，科技以换壳为本。</p><p>诺基亚在2G浪潮中比摩托罗拉更注重外观、用户的便捷程度，而且一直保持产品开发的快速和灵活性，又是换一个外壳就是一部新手机，因此有人戏称诺基亚——”科技以换壳为本“。</p><p>然而诺基亚在3G浪潮中没落，最终被迫与微软走到一起，出了几款Windows Phone手机，最近的新闻是诺基亚手机部门被微软收购，而变成了Lumia品牌，诺基亚这个曾经的”雷神之锤“黯然退出手机市场。</p><h2 id="奔腾的芯–英特尔"><a href="#奔腾的芯–英特尔" class="headerlink" title="奔腾的芯–英特尔"></a>奔腾的芯–英特尔</h2><h3 id="时势造英雄"><a href="#时势造英雄" class="headerlink" title="时势造英雄"></a>时势造英雄</h3><p>英特尔公司由戈登•摩尔(Gordon E. Moore)和罗伯特.诺伊斯(Robert Noyce)于 1968 年 创立于硅谷。此前，摩尔和诺伊斯在 1956 年还和另外六个人一起创办了仙童(Fairchild)半 导体公司。 </p><p>一开始英特尔生产的是性能低的微处理器，是用来补充大计算机公 司看不上的低端市场。在很长时间里，英特尔的产品被认为 是低性能、低价格。虽然它的性价比很高，但并不是尖端产品。 </p><p>1981 年，IBM 为了短平快地搞 出 PC，也懒得自己设计处理器，拿来英特尔的 8086 就直接用上了。这一下子，英特尔一举 成名。 </p><p>为了和 IBM PC 兼容，处理器都得是英特尔公司的。 </p><p>英特尔的崛起就成为历史的必然。这正是时势造英雄。 </p><p>八十年代，英特尔果断地停掉了它的内存业务，将这个 市场完全让给了日本人，从此专心做处理器。当时日本半导体公司在全市界挣了很多钱，日 本一片欢呼，认为它们打败了美国人。其实，这不过是英特尔等美国公司弃子求势的一招棋。 </p><p>到今天， 即使是最早生产工作站的太阳公司和世界上最大的计算机公司 IBM 以及以前从不使用英特 尔处理器的苹果公司，都开始在自己的计算机中使用英特尔的或者和英特尔兼容的处理器了。 现在，英特尔已经垄断了计算机处理器市场。 </p><h3 id="英特尔与摩托罗拉之战"><a href="#英特尔与摩托罗拉之战" class="headerlink" title="英特尔与摩托罗拉之战"></a>英特尔与摩托罗拉之战</h3><p>资金密集型的日本半导体公司终究不可能是技术密集型的英特尔公司的对手。英特尔公 司迄今唯一遇到的重量级对手只有八十年代的摩托罗拉。 </p><p>正如同罗马帝国的崛起是通过在布 匿战争中打败原有的霸主迦太基而完成的，英特尔的崛起是靠击败老牌半导体公司摩托罗拉 而实现的。 </p><p>英特尔公司从外部得到了强援。由于 IBM PC 兼容机的逐步普及，技术上相对落 后的英特尔反而占了更多的市场份额。 </p><p>要分析摩托罗拉之败，我们不妨来比较一下英特尔和摩托罗拉这两个公司。首先，这是 两个不同时代的公司。总部在美国中部伊利诺斯州的摩托罗拉虽然也是一个高技术公司，也 经历了八十年代的信息革命，但是它的作态完全还是五六十年代的传统的公司。虽然摩托罗 拉对雇员在工资和福利上待遇不错，但是公司和员工，基本上还是传统的雇佣关系，公司内 部管理层次较多，大部分员工基本上没有多少股票期权。因此，公司的业绩和员工的利益关 系不大。英特尔公司则是一的典型的硅谷公司。每个员工的工作强度比摩托罗拉要大很多， 但是每个人平均的股票期权也多很多。硅谷几个比较好的学区的房子，不少被英特尔公司的 早期员工买走了，而这些房子靠工资是一辈子也买不起的。 </p><p>几年前，美国历史频道(History Channel)在节目中评论了中日甲午战争。美国的历史学家认为，这是两个不同时代军队之间 的战争，虽然双方武器相差不多，战争的结果不会有任何悬念，因为一个在专制的农业时代 后期的军队很难打赢一个兴起的工业化国家的军队。英特尔和摩托罗拉之间的竞争也是如此。 </p><p>两个公司的统帅水平相去甚远。英特尔公司八九十年代的 CEO 格罗夫虽然是学 者出身，同时也是微机时代最优秀的领导者和管理者，他几次被评为世界上最好的 CEO。摩 托罗拉公司由加尔文(Galvin)兄弟创办，公司六十年代传到了儿子手里，八九十年代传到了 孙子手里，是个典型的家族公司。俗话说富不过三代，这话果然应验在加尔文家族上，三代 人可以说是一代不如一代。 </p><p>在业务上，半导体只是摩托罗拉的一个部门，而微机处理器又只是其半导体部门的一项 业务，可是它对于英特尔来讲却是全部。 </p><h3 id="指令集之争"><a href="#指令集之争" class="headerlink" title="指令集之争"></a>指令集之争</h3><p>英特尔在微软的帮助下，在商业上打赢了对摩托罗拉一战。在接下来的十年里，它在技术上又和全世界打了一战。如果转到精简指令的道路上，英特尔的市场优势会荡然无存;如果坚持 走复杂指令的道路，它就必须逆着全世界处理器发展潮流前进。 </p><p>英特尔为了兼容性，一直坚持使用CISC，但是并没有放弃RISC。应该讲英特尔在精简指令处理器的工作没有白花，它在奔腾及以后的处理器设计上吸取 了 RISC 的长处，使得处理器内部流水线的效率提高很多。英特尔通过高强度的投入，保证 了它处理器性能提升得比精简指令还要快。而在精简指令阵营，九十年代五大工作站厂家太 阳、SGI、IBM、DEC 和 HP 各自为战，每家都生产自己的精简指令处理器，加上摩托罗拉 为苹果生产的 PowerPC，六家瓜分一个市场，最后谁也做不大、做不好。 </p><p>英特尔经过十年努力终于打赢了对精简指令集的处理器之战。需要强调的是，英特尔不 是靠技术，而是靠市场打赢的此战。英特尔的表现在很多地方很值得圈点。首先，英特尔坚持自己系列产品的兼容性，即保证以往的软件程序肯定能在新的处理器上运行。这样时间一 长，用户便积累了很多在英特尔处理器上运行的软件。每次处理器升级，用户原来的软件都 能使，非常方便。因此大家就不愿意轻易更换其它厂家的处理器，即使那些处理器更快。而 其它处理器生产厂家这点做的都没有英特尔好，它们常常每过几年就重起炉灶，害得用户以 前很多软件不能用了，必须花钱买新的。时间一长，用户就换烦了。第二，英特尔利用规模 经济的优势，大强度投入研发，让业界普遍看衰的复杂指令集处理器一代代更新。在九十年 代初，英特尔的 x86 系列和精简指令集的处理器相比在实数运算上要略逊一筹。但是，英特 尔十几年来坚持不懈地努力，后来居上，而其它厂商因为各自市场不够大，每一个单独的处 理器芯片的投入远远不如英特尔，因此反倒落在了后面。 </p><p>英特尔并没有拒绝新技术，它也曾经研制出两个不错的精简 指令的处理器，只是看到它们前途不好时，立即停掉了它们。 </p><p>英特尔运气很好，在精简指令处理器阵营中，群龙无首。 </p><h3 id="英特尔和AMD的关系"><a href="#英特尔和AMD的关系" class="headerlink" title="英特尔和AMD的关系"></a>英特尔和AMD的关系</h3><p>英特尔和 AMD 的关系基 本上是既联合又斗争。如果不是反垄 断法的约束，英特尔很可能已经把 AMD 击垮或者收购了。另外，英特尔和 AMD 的关系基 本上是既联合又斗争。 </p><p>英特尔并没有想彻底把 AMD 打死。因为留着 AMD 对它利大于弊。 首先，它避免了反垄断的很多麻烦。今天 AMD 的股值只有英特尔的 5%，后者靠手中的现 金就足以买下前者。但是，英特尔不能这么做，否则会有反垄断的大麻烦。其次，留着 AMD 这个对手对英特尔自身的技术进步有好处。 </p><p>AMD 不同于英特尔以往的对手，它从来没有另起炉灶做一种和英特尔不同的芯片，而是 不断推出和英特尔兼容的、更便宜的替代品。 </p><h3 id="填补艰难"><a href="#填补艰难" class="headerlink" title="填补艰难"></a>填补艰难</h3><p>当一个公司的市场份额超过 50% 以后，就不用再想去将市场份额翻番了。 </p><p>英特尔虽然雄霸个人电脑处理器市场，但随着个人微机市场的饱和，它远景不容乐观。 从某种程度上讲，它是反摩尔定理最大的受害者，因为处理器的价格在不断下降。同时，它 在新市场的开拓上举步艰难，很难摆脱“诺威格效应”的阴影。好在英特尔同时也是安迪-比尔 定理的直接受益者，在可以预见的将来，它的发展很大程度上必须依赖于微软等公司软件的 更新。 </p><h2 id="互联网的金门大桥（思科）"><a href="#互联网的金门大桥（思科）" class="headerlink" title="互联网的金门大桥（思科）"></a>互联网的金门大桥（思科）</h2><h3 id="好风凭借力"><a href="#好风凭借力" class="headerlink" title="好风凭借力"></a>好风凭借力</h3><p>思科公司的图标正是旧金山的金门大桥，创始人的意思是要建起连接不同网络的桥梁。 </p><p>由斯坦福大学的一对夫妇创办，这对夫妇恐怕开始也没有想到以后思科能变成世界上最大的设备制造商。 </p><p>思科早期成功的关键在于它的两个创始人在最合适的时机创办了一个世界上最需要的公司。假如 思科早创立两年，它可能在市场还没有起来时就烧完了它的投资而关门了，反过来也一样， 如果它迟了两年，就可能被别的公司占了先机。在思科还是一个小公司时，各大计算机公司 各自有自己很大的市场，它们首先想的是在网络市场上打败对手们而不是研制包容各公司网 络产品的路由器，因此，没有公司和思科争夺多协议路由器的市场。而等到互联网兴起时， 思科已经占据了路由器市场的领先地位。 </p><p>思科的幸运正好和以朗讯为代表的传统电信公司的不幸互补，互联网的兴起，使得世界上数据传输量急剧增加，而语音通话量下降。 </p><p>思科的办法很像在大航海时代西班牙和葡萄牙国王对待探险者的做法。那时，包括哥伦 布和麦哲伦在内的很多航海家都得到了王室的资助。 </p><p>思科具体的做法是，如果公司里有人愿意自己创业，公司又觉 得他们做的东西是好东西，就让他们留在公司内部创业而不要到外面去折腾，而思科会作为 投资者而不再是管理者来对待这些创业的人。一旦这些小公司成功了，思科有优先权把它们 买回来，思科的地盘就得到扩大。而这些独立的小公司的创办者和员工，又可以得到很高的 回报。这样本来想离开思科出去创业的人也就不用麻烦了，接着上自己的班，只是名以上换 了一家公司。当然，如果这些小公司没办好关门了，那么思科除了赔上一些风险投资的钱， 没有额外的负担。这种做法不仅调动了各种员工尤其是早期员工的积极性，也避免这些员工 将来成为自己的对手或者加入对手的阵营。 </p><p>思科通过这种做法，基本上垄断了互联网路由器和其它重要设备的技术。因为一旦有更 新更好的技术出现，思科总是能有钱买回来。如果说微软是赤裸裸地直接垄断市场，那么思 科则是通过技术间接垄断了互联网设备的市场。 </p><p>既然思科这种办法证明有效，为什么别的公司学不来。当然这一方面因 为并非所有公司的领袖都有思科 CEO 钱伯斯(John Chambers)的胸怀和远见卓识，更重要 的是思科的基因使然。思科自己的创建就是用到了两个创始人的职务发明。 </p><p>另外，思科员工的发明，一般很难单独成为一种产品，而必须应用到现有 网络通信系统或设备中，因此它们最好的出路就是卖给思科。所以，思科倒是不怕这些小公 司将来反了天。 </p><h3 id="竞争者"><a href="#竞争者" class="headerlink" title="竞争者"></a>竞争者</h3><p>思科真正的竞争对只有一假一真两个。让我们先来看看假的—Juniper Networks。这个公 司基本上是思科的影子公司，相当于 AMD 对英特尔的地位。Juniper 的产品定位在高端，而 不像思科从小到 IP 电话机，大到高端路由器都做。 </p><p>思科真正的对手是中国的小弟弟华为。 </p><p>中国制造”的效应。它基本的影响是，当一个原本只能在美欧生产的产品，经过一段时间则可以过渡到日本和韩国，进而落脚于中国。 美欧公司能赚钱的时间只有从美国到中国这段时间差，以前这段时间可以长达数十年，现在 只有几年。一旦一项产品可以由中国制造，那么它的利润空间就会薄到让美欧公司退出市场。 </p><h3 id="诺威格定理的宿命"><a href="#诺威格定理的宿命" class="headerlink" title="诺威格定理的宿命"></a>诺威格定理的宿命</h3><p>谷歌研究院院长彼得.诺威格博士说，当一个公司的市场占有率超过50%以后，就不要再指望在市场占有率上翻番了。 </p><h2 id="硅谷的见证人（惠普公司）"><a href="#硅谷的见证人（惠普公司）" class="headerlink" title="硅谷的见证人（惠普公司）"></a>硅谷的见证人（惠普公司）</h2><h3 id="昔日的硅谷之星"><a href="#昔日的硅谷之星" class="headerlink" title="昔日的硅谷之星"></a>昔日的硅谷之星</h3><p>由两个斯坦福的毕业生创办。</p><p>斯坦福工业园(Stanford Industrial Park)，惠普公司成为进驻工业园的第一批公司。惠普公司的从这里起步，生意得到 了长足的发展，很多公司也随着进驻斯坦福工业园。到了计算机时代，由于这些公司大多从 事和半导体有关的技术，从此这里便被称为硅谷。而斯坦福大学，不但度过了难关，而且从六十年代起，一跃成为世界顶尖名校。惠普则成为硅谷神话的典型代表。 </p><p>几十年来，惠普和斯坦福互相提携，堪称厂校合作的典范。惠普从斯坦福获得了无数优秀毕业生，同时在财政上给予斯坦福极大的支持。就是在很长时间里，惠普是斯坦福最大的 捐助者，包括帕克特捐给斯坦福电子工程系的系馆。 </p><p>如果在九十年代 初问一问硅谷最有名的公司是哪一家，十个人中有十个会回答惠普。当时，惠普是很多斯坦 福学生首选的工作公司。 </p><p>九十年代后期，惠普经历了不很成功的转型，这个曾经辉煌的硅谷巨星渐渐黯淡下来了。 </p><h3 id="有争议的生死抉择"><a href="#有争议的生死抉择" class="headerlink" title="有争议的生死抉择"></a>有争议的生死抉择</h3><p>惠普衰落的原因大致有两个，领导者的错误和“日本/中国制造”的冲击。 </p><p>一般来讲，公司会卖出利润率低的、对自己没有用的，前景不好的部门并买进对公司长 远发展有帮助的公司，比如郭士纳领导下的 IBM 就是这样。但是，惠普接下来的发展史上最 大的两次拆分和并购，却是反其道而行之，因此科技界和华尔街至今很有争议。 </p><p>应该讲，1999 年的惠普虽然大，但是并不强。这有点像中国战国时候的楚国。惠普的董 事会当然希望把惠普搞得强大。它必须决定分出去哪个部门，保留哪个部门。医疗仪器部门 虽然利润率高，但是在 GE 的打压下发展有限，经过长期酝酿，才决定将科学仪器和医疗仪器 部门都分出去，成立一个新的公司安捷伦，然后新的惠普好集中精力于计算机行业。这么大 的公司重组当然要有个有经验的人来执行，惠普公司董事会看中了菲奥莉娜拆分和并购公司 的经验，破例选择了她出任硅谷最老的惠普公司的 CEO ，来实施安捷伦上市的事宜。 </p><h3 id="亚洲制造的冲击"><a href="#亚洲制造的冲击" class="headerlink" title="亚洲制造的冲击"></a>亚洲制造的冲击</h3><p>从 2003 、2004 年起，整个硅谷开始复苏，很多公司回到并超过 2000 年的水平。但是， 惠普一点没有好转的迹象。华尔街不断看空惠普的股票，忍无可忍的股东们终于决定赶走毫 无建树的菲奥莉娜。根据美国公司的惯例，惠普提供给她一笔丰厚的退休金，然后由她自己 提出辞职，这样大家面子上都好看。菲奥莉娜临走还从惠普投资者手中拿走了上亿美元的现 金和股票。但是，股东们宁可花钱请她走。菲奥莉娜离职的当天，惠普的股票大涨了 10% 。 这是一次惨痛的教训，它说明如果一个公司不能挑选好掌舵人，以后替换掉他成本也是很高 的。 </p><p>惠普虽然是一个大公司，但是它从来没有领导过哪次技术浪潮。因此，它开创出一个新 行业的可能性不大。(它不同于苹果，后者从来就有创新的基因，因此可以完成从微机到 iPod 再到 iPhone 的过渡。前者则很难转型。)它是当年以半导体和计算机硬件为核心时代的硅谷 的代表，而今天的硅谷，半导体已经变得越来越不重要了。惠普已经不能代表今天硅谷的潮 流了，这也是我在开始时讲惠普是黯淡了的巨星的原因。 </p><h2 id="下一个帝国——谷歌公司"><a href="#下一个帝国——谷歌公司" class="headerlink" title="下一个帝国——谷歌公司"></a>下一个帝国——谷歌公司</h2><p>长期以来，硅谷的公司在对决微软时都会处于下风，不仅在市场上被挤占，而且在人才争夺战中也会被微软挤压。从苹果到网景公司，他们都被微软后来居上，然而最终有一个公司从小发展，直至虎口拔牙，终于这家公司有资本正面对决微软了，那就是谷歌公司。</p><p>谷歌公司的成立也离不开20世纪末的互联网泡沫，当时还在学校读博士的拉里·佩奇和谢尔盖·布林面对时代的浪潮，他们觉得自己应该做点什么，他们瞄准了新兴的搜索引擎业务，于是谷歌成立。</p><p>谷歌英文名Google，原意为一个非常大的数字Googol，即10的一百次方，“实际上宇宙中都没有任何事物能有这么大，甚至宇宙中全部的基本粒子数目也没有这么多，佩奇和布林用这个数字的用意为，他们的搜索引擎很大。</p><p>1997年9月，佩奇和布林注册了google.com的域名，然而此时二人只能靠刷信用卡度日，于是他们去寻找投资人，找到了同为<strong>斯坦福大学的校友</strong>、<strong>太阳公司创始人</strong>安迪·贝托谢姆。</p><p>贝托谢姆看到二人展示的搜索技术，果断决定给他们10万美元的支票。虽然这笔钱看起来不多，然而这在无形中给新兴的谷歌公司做了一次成功的<strong>广告</strong>。</p><p>同时<strong>斯坦福大学</strong>也向佩奇和布林伸出了援手，为其提供了专利，同时成为谷歌的股东。而为了更好发展，佩奇和布林休学，去进行光荣的创业之旅了。</p><p>他们在进行创业之旅的时候”顺走“了另一个技术大牛——克雷格·希尔福斯坦，”他几乎一个人写出了谷歌的第一个商业版本……而早期佩奇和布林忙于商业筹资，技术上只剩下了这个技术大牛。</p><p>随着业务发展，谷歌开始招人了，佩奇等人认为谷歌要坚持宁缺毋滥，每招一个人必须所有人同意才行，而且进去谷歌的人必须以一挡百，正是这一个个精英，谷歌才能成为今天的谷歌。谷歌前工程副总裁毫不讳言：“我们只需要天才。”</p><p>另外谷歌坚持精英战略， “杀鸡就是要用牛刀。”因此谷歌称为全世界单位办公面积博士最集中的地方。”谷歌不仅喜欢招博士，而且特别喜欢大学成绩优异的，这表明这个人自制力强，有责任心，而且一般而言学习好的学生更聪明。</p><p>另一方面谷歌在“品质”的坚持上类似于日本公司，它认为为了保持搜索品质，就一定要用更优秀的才人，因为即使一项工作本科生能完成，然而用硕士生效率和质量会更高，这样反而能节省更多的时间。</p><p>这样子的谷歌朝气蓬勃，同时也坚持自己“不作恶”的态度，赢得了其他公司的善意。</p><p>而当互联网从桌面上向移动端转移的时候，谷歌比微软响应的速度要快，它推出了安卓操作系统，同时在微软擅长的操作系统领域推出了Chrome。</p><p>谷歌正在进行新的布局，它已然成为一个帝国。</p><h1 id="推动浪潮的三大定律"><a href="#推动浪潮的三大定律" class="headerlink" title="推动浪潮的三大定律"></a>推动浪潮的三大定律</h1><p>有三大定律主宰IT行业尤其是计算机产业的发展，分别是摩尔定律（Moore’s Law），安迪-比尔定律（Andy and Bill‘s Law）以及反摩尔定律（Reverse Mooore’s Law）。</p><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p>所谓摩尔定律，就是每过18个月，IT产品的性能会翻一番，或者说相同性能的电子产品，每过18个月价格会下降一半。</p><p>这一定律是由英特尔公司创始人戈登·摩尔（Gordon Moore）于1965年提出的。而自从摩尔定律提出以来，计算机行业始终按照摩尔定律的速度向前发展。<br>然而摩尔定律为什么会实现呢？这要归功于IT行业的特殊性。</p><p>IT行业与其他行业不太一样的一点在于，它的成本大部分都是研发成本，而在硬件制造上的成本相对来说比例不是很高，它的硬件制造成本主要集中在制造设备上。</p><p>可以说摩尔定律主导计算机行业的发展：<br>首先，摩尔定律要实现，硬件制造厂商不得不加快研究速度，在上一代商品出来之后就立马着手下一代产品的研发，而这需要大量的研发资金，因而从某种意义上来说，进入计算机行业有一定的资金壁垒。<br>其次，摩尔定律促使计算机性能得以快速提升，而这为软件的升级提供了硬件上的支持，希望未来计算机行业继续发展，嘻嘻，我想体验更高的网速。</p><h2 id="安迪-比尔定律"><a href="#安迪-比尔定律" class="headerlink" title="安迪-比尔定律"></a>安迪-比尔定律</h2><p>这条定律，顾名思义，安迪——英特尔公司CEO安迪·格鲁夫（Andy Grove）；比尔——微软公司创始人比尔·盖茨，（PS，这一条定律就是赤裸裸的暗示微软-英特尔联盟啊！）<br>这一条定律的产生与摩尔定律有关，如果按照摩尔定律的说法，如果消费者暂时不想花或者不能花很多的钱，他可以等18个月之后花一半的钱去买相同的产品。<br>那这样的话厂商怎么挣钱？<br>这个时候安迪-比尔定律就出现了。<br>按照摩尔定律，过去几十年计算机的硬件性能得到了飞速提升，然而似乎以微软为代表的软件性能貌似提升并不如硬件性能那样多，然而软件占据的空间越来越大，这就逼迫消费者在使用一台计算机之后，由于软件性能的限制，不得不重新购买升级。<br>这听起来一个阴谋，本来电子产品，就像白色家电一样，是耐用消费品，而安迪-比尔定律硬生生的让计算机和手机变成了快消品。<br>然而事实并不是那么简单。<br>几十年前，软件开发人员在编写程序时非常注意程序的大小，他们要充分利用计算机的空间，而现在的软件开发人员，似乎越来越浪费了。</p><p>这似乎不能怪罪软件开发人员，因为他们也要人性化，以前的编程的客观要求软件开发人员极低，而现在由于摩尔定律生效，软件工程师可以比较自由地利用硬件资源做自己喜欢的工作。而另一方面<strong>由于人力成本的提高</strong>，<strong>为了编程人员的最大利用化和缩短编程时间，因此编程语言越来越易懂、好用，而编程语言越来越臃肿。</strong></p><h2 id="反摩尔定律"><a href="#反摩尔定律" class="headerlink" title="反摩尔定律"></a>反摩尔定律</h2><p>这一定律是由谷歌前CEO埃里克·施密特提出的，“如果你反过来看摩尔定律，一个IT公司如果今天和十八个月前卖掉同样多的、同样的产品，它的营业额就要下降一半”（吴军）。</p><p>这样子下去的话IT公司就很惨了，因为他们花了同样的劳动，却只得到十八个月之前营业额的一半。而反摩尔定律就是硬逼着硬件公司跟上摩尔定律的速度。</p><p>反摩尔定律也有积极作用，就是促进IT行业不断寻找<strong>质变</strong>，而非像传统行业更多的是量变，而且反摩尔定律对新兴的小公司也是有极大好处的，因为在<strong>新的浪潮</strong>到来之时，新兴小公司和大公司站在同一起跑线。</p><p>读后感：看过吴军博士对计算机行业三大定律的介绍，解答了以前的一个疑惑：例如为什么计算机和电脑越用越卡，是不是他们的阴谋？这个问题就是第二条定律能解答的。</p><h1 id="行业兴衰的推手——资本"><a href="#行业兴衰的推手——资本" class="headerlink" title="行业兴衰的推手——资本"></a>行业兴衰的推手——资本</h1><h2 id="幕后英雄——风险投资"><a href="#幕后英雄——风险投资" class="headerlink" title="幕后英雄——风险投资"></a>幕后英雄——风险投资</h2><p>传统上创业时的资金来源为自己财产积累或借贷。然而年轻人一般没有什么钱，此时资金的不足就成了创业的瓶颈。<br>而敢于冒险的美国人发明了一种非常规多投资方式——风险投资，这种投资不需要抵押，也不需要偿还，如果投资成功，资本家将获得几倍、乃至几十倍上百倍多利润，而不成功，就当交学费了。而这对年轻人太具有了吸引力了，他不用因为创业失败而背上债务，这样年轻人就敢于创业，因此风险资本促使美国成为创业的国度。</p><h2 id="科技公司兴衰背后的重要角色——投资银行"><a href="#科技公司兴衰背后的重要角色——投资银行" class="headerlink" title="科技公司兴衰背后的重要角色——投资银行"></a>科技公司兴衰背后的重要角色——投资银行</h2><p>2008年的那场金融危机，深刻表露出华尔街的贪婪所造成的恶果，同时他们也对科技公司施加着影响：一方面，科技公司上市时的吹捧者，是他们；另一方面，打压科技公司的也是他们。</p><p>华尔街——美国的金融中心，这里坐落着诸多金融公司，而这些公司大致分为以下几类：商业银行（类似于我国的工商银行）、投资银行（替别人买卖任何有价值的商品，是股市的主力军）、共同基金公司（掌管美国所有的退休账户和世界上的很多财富）以及对冲基金（著名的有金融大鳄索罗斯的量子基金）。</p><p>而其中对科技公司影响最大的乃是投资银行。著名的投资公司有高盛公司（投资银行的NO.1)、摩根斯坦利（美国大银行家摩根创立）等。</p><p>风投公司要收回投资，科技公司的从业人员要获得回报，只有两条路可选：第一是<strong>被收购</strong>；第二是<strong>上市</strong>。而<strong>上市就需要高盛等公司当承包商</strong>，承包商以<strong>上市价格</strong>从被承包的公司收购一定数量的股票，并且以同样的价格分配给它们的客户。而承包商从中获得两笔收入：佣金（包销股票总金额）、以后用上市价购买科技公司一定股份的权利（这笔钱只有当科技公司股票上涨时才有意义）。<br>而当投资银行认为一家科技公司有前途时，其股票会上涨，反之则会下降。股票价格下降对科技公司的影响有时是灾难性的。诚可谓“成也萧何，败也萧何。”</p><h2 id="硅谷的摇篮——斯坦福大学"><a href="#硅谷的摇篮——斯坦福大学" class="headerlink" title="硅谷的摇篮——斯坦福大学"></a>硅谷的摇篮——斯坦福大学</h2><p>硅谷的传奇与斯坦福大学多方位的支持是分不开关系的。很多当今时尚著名的科技公司都是由斯坦福大学的教授和学生创立的。它们包括惠普公司、思科公司、太阳公司、雅虎、谷歌以及英特尔。斯坦福在科技业的这种契机是任何大学都无法比拟的。</p><p>首先，按照斯坦福人自己的说法，一个斯坦福等于一个哈佛加麻省理工。这句话粗看略显自大，但实际是有道理的。斯坦福大学在专业设置上人文理工兼修，同时比东岸名校更重视实践。</p><p>斯坦福的学生，在这里能够体现更加丰富的多样性，在这里培养了他们创业时需要的沟通能力和团队协作能力。<br>其次，斯坦福大学给予新兴的科技公司以专利和土地。斯坦福大学，其面积的相当大部分都租给了企业，这些企业绝大部分都是高科技企业，同时斯坦福大学也给予自己学校的毕业生和在读生创业上的优惠。</p><p>斯坦福大学的这一举动无疑是双赢。这些斯坦福的毕业生们成功之后就会投桃报李，他们会给母校丰厚的捐赠。</p><h2 id="怎样做到基业长青——硅谷成功的商业模式-印钞机"><a href="#怎样做到基业长青——硅谷成功的商业模式-印钞机" class="headerlink" title="怎样做到基业长青——硅谷成功的商业模式 印钞机"></a>怎样做到基业长青——硅谷成功的商业模式 印钞机</h2><p>日本经营之神——松下幸之助有句名言:一个企业必须要盈利，否则就是对全人类的犯罪。因为无法盈利的企业是浪费资源，还不如把这些人力物力用在更需要的地方。因此很多大公司的兴起，不是靠技术的革新，还是靠商业模式的转变，这里吴军博士介绍了硅谷那些成功的商业模式。<br><strong>什么是好的商业模式</strong><br>通常，好的商业模式都<strong>非常简单</strong>，<strong>即使是外行人也能看得清楚</strong>。AT&amp;T从事固定电话业务时（19世纪末），就懂得只收服务费而不是高的吓人的安装费，这点中国电信到2000年都不明白，而英特尔开发出比IBM以及惠普更便宜的处理器，分别卖给这些公司，这也是双赢。</p><p>相反，如果一种商业模式好几个小时都说不清楚，在巴菲特看来要么是骗人、要不根本不存在。而最理想的商业模式就是如同印钞机一样自动挣钱的模式，这里吴军介绍了三种印钞机模式——谷歌的广告系统、eBay的电子商务系统以及戴尔的微机直销系统。</p><h3 id="Google的广告系统"><a href="#Google的广告系统" class="headerlink" title="Google的广告系统"></a>Google的广告系统</h3><p>谷歌的广告系统大大降低了全国性广告乃至全球广告的门槛，深受中小企业欢迎，另一方面谷歌的技术实力强悍，机器会自动学习，强化个性化广告推荐，这样广告效果更好，广告上自然更加喜欢。</p><h3 id="ebay和亚马逊的在线市场"><a href="#ebay和亚马逊的在线市场" class="headerlink" title="ebay和亚马逊的在线市场"></a>ebay和亚马逊的在线市场</h3><p>而eBay的模式类似于阿里巴巴，坐收卖家和卖家之间的佣金和中介费，只要网上有交易，它就永远会有收入，但有个问题没有解决:就是信用问题和付款问题。付款问题靠PalPal（国外的支付宝）解决，但是信用问题是让eBay头疼的。</p><h3 id="戴尔的虚拟工厂"><a href="#戴尔的虚拟工厂" class="headerlink" title="戴尔的虚拟工厂"></a>戴尔的虚拟工厂</h3><p>第三个是戴尔的虚拟工厂。戴尔自己没有工厂，只有一个商标，它的创始人精简了从设计到零售的环节，精简了不少费用，一度戴尔电脑的市占率为美国第一。</p><h2 id="下一个浪潮"><a href="#下一个浪潮" class="headerlink" title="下一个浪潮"></a>下一个浪潮</h2><p>没有不消亡的帝国，同样也没有永不衰退的企业，浪潮不断推动企业兴衰更替，而从投资银行到求职者，都希望找到下一个浪潮，能站在下一个浪潮之巅的必将是下一个谷歌一般的企业。</p><p>吴军博士断言：云计算很可能成为下一个科技浪潮，因为它将使用户摆脱桌面，通过浏览器，借助高速网络和云端服务器，随时随地享受上网的乐趣。（画外音：话说这不是谷歌的笔记本Chromebook吗？到底吴军博士是谷歌的人啊！）<br>”科技产业让人振奋的是，有新一代技术的革命同时拌嘴这新一代公司的诞生，这个时间可能会很长，但终究会来到。而代表新的技术公司有时是新生的，有时却是以前的公司进化而来，不论是哪一种都足以让人振奋。寻找下一个这样的机会，永远是和所有现代生活相关的人追求或谈论的主题。</p><h1 id="涨姿势"><a href="#涨姿势" class="headerlink" title="涨姿势"></a>涨姿势</h1><h2 id="有关罗斯柴尔德家族的阴谋论到底是不是真的？"><a href="#有关罗斯柴尔德家族的阴谋论到底是不是真的？" class="headerlink" title="有关罗斯柴尔德家族的阴谋论到底是不是真的？"></a>有关罗斯柴尔德家族的阴谋论到底是不是真的？</h2><p>吴军博士的回答：罗斯柴尔德家族早已是过眼云烟，在华尔街眼里，这个家族就是二三流的水平，而美国，这个家族被人认知，还是因为葡萄酒。</p><p>按照一些中国作家的观点，一两百年前这个家族的财富作为原始资本，以每年6%的速度递增，现在该家族有几万亿美元，至于为何没有人看到，是因为这个家族的财务不向外界公开。</p><p>几万亿美元，相当于整个中国的经济规模，然而金钱只有流动才有可能增值，这么一大笔钱在世界上不可能藏得住。另外这些作者的假设也是错误的。这里可以举个反例：春秋时代的陶朱公，留给后人1两银子，现在应该变成10的60次方两银子，这远比现今世界上所有财富的加总还要多。这显然不可能，既然陶朱公不可能，凭什么罗斯柴尔德家族就可能呢？</p><p>罗斯柴尔德家族衰落与几个大事件有关：第一个，错失19世纪末飞速发展的美国；第二，纳粹德国的抢掠。<br>在华尔街看来，罗斯柴尔德家族的投资公司顶多算三流的投资公司。</p><h1 id="硅谷的另一面"><a href="#硅谷的另一面" class="headerlink" title="硅谷的另一面"></a>硅谷的另一面</h1><h2 id="成王败寇"><a href="#成王败寇" class="headerlink" title="成王败寇"></a>成王败寇</h2><p>在硅谷创业成功的几率比中六合彩大奖的概率大不了多少，就如同好莱坞的明星带给了无数少男少 女的明星梦一样。这正是风险投资资本家和华尔街所希望的。只有越来越多的人加入这种创 业的游戏，投资者才能有好的项目投资。 </p><p>毕竟，硅谷的 竞争太残酷了，成功的机会太低了。我有时会开玩笑地说“如果你不相信这辈子会被汽车撞死， 为什么相信能中硅谷大奖?后者的可能性更小。”他们会开玩笑地说:“也许是利令智昏吧。” </p><p>小公司想要成功，有很多因素必须同时具备。</p><ol><li>创始人很重要，所有的成功者都是实干家。成功的创业者必须有一个小而精的好团队，里面每个 人都得不计较个人得失，同甘共苦，否则成则争功，败则互相推诿。在技术上，他们必须有 自己的金刚钻，他们的技术必须是不容易被别人学会和模仿的。</li><li>但是光有好的团体和技术又远远不够，他们有商业头脑而且必须找到一个能盈利的商业 模型(Business Model)。</li><li>再接下来是判断力和执行力。</li><li>外部环境。</li><li>运气。</li></ol><p>硅谷汇集了美国三、四成的风险投资，每天硅谷都有成百上千的公司成立，但同时又有 成百上千的公司关门。对于那些失败的公司，大家并不关心，甚至无人知道它们的存在。即 使很多曾经辉煌过的公司，像网景公司、SGI 公司，人们很快也就忘却了它们。在这些成千 上万家硅谷的公司中，最终创造出了一些像思科、谷歌那样的传奇故事。仿佛间在硅谷办一 个公司就能成一个。岂不知，一将功成万骨枯，无数失败的公司在为少数几个成功者做分母。 </p><h2 id="嗜血的地方"><a href="#嗜血的地方" class="headerlink" title="嗜血的地方"></a>嗜血的地方</h2><p>在硅谷，加班很正常，与国内有过之而无不及。但是薪水却不是线性的增长，所以单位时间的薪水反而少了。</p><p>硅谷就是这样一个“嗜血”的地方。坦率地讲，硅谷的生活质量达不到美国的平均水平。 </p><h2 id="机会均等"><a href="#机会均等" class="headerlink" title="机会均等"></a>机会均等</h2><p>硅谷能成为科技之都，而且长盛不衰，必有它高明之处。其中最关键的一条是保证机会 均等。任何人、任何国家和制度都无法保证我们的社会绝对公平，(事实上也没有必要追求绝 对公平。)但是，一个好的制度要保证每个人有均等的机会。 </p><p>硅谷是一个到处可见权威却从不相信权威的地方。 </p><p>任何人要想在这里获得成功，都得真刀真枪地拿出真本事 干出个样子。在美国很多地方，尤其是传统产业中，普遍看中甚至过于看重个人的经历 (Resume)而不是做事情的本领。 </p><p>在硅谷谋职，简历固然重要， 但是个人的本事(包括和人打交道的软本领)才是各个公司真正看中的。由于每个公司产品 的压力很大，同行业公司之间的淘汰率很高，硅谷的公司需要的不是指手画脚的权威而是实 实在在干事情的人。 </p><p>对创业者来讲，资历固然有用，但就重要性而言远排不进前几位。名气大、职位高的创 业者经验丰富、交际广，容易找到钱和市场，但是闯劲远不如初出茅庐的牛犊那么足。在风 险投资家看来，一个人的能力，包括处理人际关系的“软”能力(Soft Skills)是决定创业成败 的关键。一个人的职位只代表过去，而财富和地位有时反而成为创业的负担。这也是为什么 硅谷很多著名的公司如思科、苹果、Yahoo 和谷歌，包括中国人创办的 Netscreen 和 Webex 都 是原来默默无名的年轻人办成的，但是却很少听说那个成功公司是一位原某公司老总办的 。</p><p>自古英雄出少年，这是风险投资家们普遍承认的事实。红杉风投的投资家们和我谈过他 们选择投资对象的原则，其中一条就是创业者一定要有饥渴感(Hungry)。很难想象一个腰缠 万贯的富翁能比一个急于脱离贫困现状的缀学生更有把公司办好的可能。因为前者办公司不 过是为了锦上添花而后者则是要置于死地而后生。这就是乔布斯勉励年轻人要保持饥渴感 (Keep Hungry)的原因。关于风险投资家如何选择投资对象我以后还会详述。因此资深创业 者和毫无经验的年轻人各有优势，但是机会均等。硅谷各个层次的成功者几乎无一例外是靠 自己的双手从零干起，获得成功的。 </p><p>由于有一些淘到金子的“冒险家”—科技新贵，就产生了替他们打理财务的需求，今天旧金 山和硅谷就成为投资银行最集中的地区之一。 </p><p>硅谷相对于美国其它地方是机会最多也是最均等的。因此虽然这里工作压力大，竞争激 烈，还是不断有人愿意来。全世界很多国家想学习硅谷建立自己的科技园，但是至今没有一 个能像硅谷这么成功的。我想这些科技园的管理者们，也许首先应该问问自己是否为创业者 提供了同等的机会，还是将人按照财富、经历、名气预先分为了三六九等。(我对一些科技园 按照学历、职称引进人才和投资额招商很不以为然。) 自古英雄不问出处，今天落魄的学子可能就是明天业界的领袖。 </p><h2 id="硅含量不断降低"><a href="#硅含量不断降低" class="headerlink" title="硅含量不断降低"></a>硅含量不断降低</h2><p>今天知道仙童公司的人已经不多了，但它在半导体历史上占据着独一无二的地位。 </p><p>硅谷没有了硅，那么留下了什么呢?</p><h2 id="亘古而常青"><a href="#亘古而常青" class="headerlink" title="亘古而常青"></a>亘古而常青</h2><p>半导体并不是硅谷真正的本质。硅谷的灵魂是创新。硅没有了，创新的灵魂留下了，它保证了硅谷的繁荣和发展。 </p><p>在硅谷的人，不论是投资者还是创业者，已经习惯了这种快速的产业变迁，人们不断在 寻找着下一个思科、下一个 Google 。其实，硅谷的创新并不局限于 IT 领域。生物科技无疑 是硅谷另一个亮点。今天的硅谷，也是世界上新兴生物公司最集中的地方。 </p><p>创新必须依靠技术实力。和 Google 一样，基因科技也是世界上单位办公面积博士密度最 高的公司。就连它的七名董事中都有五名博士，九名执行官中也有六名博士。基因科技里的 科学家在同行中是佼佼者，在公司内部地位也很高。 </p><p>美国的专利保护机制，一个药物只有一段时间的专利保护期，这一段时间用于回收成本，过了一段时间就不保护。对于药厂来说，必须不断的推出新药，而不能躺在功劳簿上吃一辈子。</p><h1 id="与机会失之交臂的公司"><a href="#与机会失之交臂的公司" class="headerlink" title="与机会失之交臂的公司"></a>与机会失之交臂的公司</h1><h2 id="太阳公司"><a href="#太阳公司" class="headerlink" title="太阳公司"></a>太阳公司</h2><p>太阳公司不乏能人，它不仅为 Google 培养了 CEO 埃里克.施密特和首任工程部副总裁韦恩.罗森(Wayne Rosen)，并且在一定程度上奠定了今天 Google 工程部门的基础。 </p><p>太阳公司从 1982 年成立到 2000 年达到顶峰用了近二十年时间，而走下坡路只用了一年，足以令经营者为戒。 </p><p>太阳公司名称的由来很多人不知道，它其实是斯坦福大学校园网(Stanford University Network)的首字母缩写。 </p><p>太阳公司，它的操作系统 Solaris 在技术上比 Windows NT 有明显的优势。 包括 Solaris 在内的 各种 Unix 操作系统比 Windows NT 能更好地利用计算机资源，尤其是当计算机系统庞大、 用户数量巨大增加时。对太阳来讲，取胜的关键在于是否能将它在 Unix 上的技术优势转换为市场优势。 </p><p>马可尼里等人的“思维”锁定在卖硬件上了。虽然太阳公司的工作站当年每台要上万美元、服务器要十万美元，但是比 DEC 的小型机和 IBM 的大型机便宜多了。在九十年代末由于互联网的兴起，太阳公司的服务器和工作站销路太好了、太挣钱了。虽然太阳公司的中小企业市场份额不断 被微软/英特尔联盟侵蚀，但是它也在不断占领原来 DEC 和 HP 小型机的市场并有足够的处女地可以开发。这很像十六世纪的西班牙王国，虽然它 的无敌舰队已经被英国人打败了，并失去了海上霸主的地位，但是由于世界上可殖民的处女地仍然很多，支撑着这个海上老二繁荣了两个世纪，直到十九世纪全世界再无殖民地可开拓 时，西班牙早期埋下的危机才表现出来。当然，衰落要比繁荣来得快。</p><h2 id="Novell公司"><a href="#Novell公司" class="headerlink" title="Novell公司"></a>Novell公司</h2><p>虽然 Novell 采用的是 DRDOS， 但是用户使用起来和微软的 MSDOS 一模一样，对程序开发者来讲也是一样。Novell 无疑是 在帮助微软和 UNIX 争夺企业级的市场。当时，微软在网络操作系统上毫无可圈点之处，它 甚至临时性地选择了 IBM 的 OS/2 LAN Server 来抵消 Novell 在网络上的优势，但是 OS/2 LAN Server 从来就没有成为过一种主流的网络操作系统。 </p><p>从 1995 年起，微软和 Novell 之争起了质的变化。微软一年前推出的 Windows NT 对 Novell 的影响开始显现出来了。用户已经从 DOS 转向了 Windows，Novell 的操作系统对微 软的 Windows NT 几乎没有优势可言。很难想象一个局域网在其网络服务器上安装 Novell 的操作系统，同时在联网的微机上使用 Windows 。显然从服务器到微机一律采用微软的 Windows 是更好的办法，这时胜利的天平开始向微软倾斜，并成为不可逆转的趋势。 </p><h2 id="网景公司"><a href="#网景公司" class="headerlink" title="网景公司"></a>网景公司</h2><p>其网络浏览器被微软公司通过捆绑ie浏览器给打败了。</p><h2 id="real-networks"><a href="#real-networks" class="headerlink" title="real networks"></a>real networks</h2><p>播放器同理。</p><h1 id="成功的转基因"><a href="#成功的转基因" class="headerlink" title="成功的转基因"></a>成功的转基因</h1><h2 id="道琼斯的常青树（3M）"><a href="#道琼斯的常青树（3M）" class="headerlink" title="道琼斯的常青树（3M）"></a>道琼斯的常青树（3M）</h2><p>3M 公司至今发明了六万种大大小小的产品，全世界有一半的人每天直接或者间接地接触 3M 的产品。该公司营业额中有三分之一来自于近五年的发明，其中相当大的一部分是员工利 于工作时间从事非工作的研究搞出来的。3M 允许员工用 15% 的时间干任何自己喜欢做的 事，后来这个做法被 Google 学去了，变成了 Google 的“百分之二十项目”。在最具有创新力 的公司里，3M 的排名更在 Google 和苹果这些以创新而闻名的公司前面。 </p><h2 id="世界最大的联合体（GE）"><a href="#世界最大的联合体（GE）" class="headerlink" title="世界最大的联合体（GE）"></a>世界最大的联合体（GE）</h2><p>今 天的 GE 是全球最大的联合体，到 2007 年底，它包括六大部门，每个部门如果独立，在各自的领域都是佼佼者。 </p><h1 id="信息产业的规律性"><a href="#信息产业的规律性" class="headerlink" title="信息产业的规律性"></a>信息产业的规律性</h1><h2 id="70-20-10律"><a href="#70-20-10律" class="headerlink" title="70 20 10律"></a>70 20 10律</h2><p>一般在全球容不下三个以上的主要竞争者。这个行业一定有一 个老大，斯库利把它比喻成一个猴王，它是这个行业的主导者。毫无疑问，它虽然想顺顺当 当地统领好整个行业，就像猴王想让猴子们永远臣服一样，但是，它一定会遇到一两个主要 的挑战者，也就是老二(也许还有一个老三)。剩下来的是一大群小商家，就像一大群猴子。 老大是这个领域的主导者，不仅占据着超过一半，通常是百分之六七十的市场，并且制定了 这个领域的游戏规则。老二有自己稳定的百分之二三十的市场份额，有时也会挑战老大并给 老大一些颜色看看，但是总的来讲是受老大欺负的时间多。剩下的一群小猴子数量虽然多， 但是却只能占到百分之十甚至更少的市场，它们基本上唯老大马首是瞻。老大总是密切注视 着老二，并时不时地打压它，防止它做大。老大和老二通常都不会太在意剩下的小企业，这 样就让这一群小的企业能有挣一些小钱的地方。这里面的百分比数字 70、20 和 10 是我加 的，因为信息产业大公司之间的市场份额大抵如此。 </p><h2 id="诺维格定理"><a href="#诺维格定理" class="headerlink" title="诺维格定理"></a>诺维格定理</h2><p>当一个公司的市场占有率超过 50% 后，就无法再使市场占有率翻番了。 </p><h2 id="基因决定定理"><a href="#基因决定定理" class="headerlink" title="基因决定定理"></a>基因决定定理</h2><p>一个公司可以不相信基因的决定性，但是最终无法摆脱它的影响。 </p><h1 id="估值与创始人"><a href="#估值与创始人" class="headerlink" title="估值与创始人"></a>估值与创始人</h1><p>公司上市估值过高与过低都不好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转载加修改，自用。&quot;&gt;&lt;a href=&quot;#转载加修改，自用。&quot; class=&quot;headerlink&quot; title=&quot;转载加修改，自用。&quot;&gt;&lt;/a&gt;转载加修改，自用。&lt;/h1&gt;&lt;h1 id=&quot;对书名《浪潮之巅》中“浪潮”的理解&quot;&gt;&lt;a href=&quot;#对书名《浪潮之巅
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="商业" scheme="https://github.com/zdkswd/tags/%E5%95%86%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>petri网理论及其应用 0 形式化表示</title>
    <link href="https://github.com/zdkswd/2018/09/13/petri%E7%BD%91%E7%90%86%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%200%20%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%A1%A8%E7%A4%BA/"/>
    <id>https://github.com/zdkswd/2018/09/13/petri网理论及其应用 0 形式化表示/</id>
    <published>2018-09-13T11:09:56.000Z</published>
    <updated>2018-09-13T11:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="petri网理论及其应用-0-形式化表示"><a href="#petri网理论及其应用-0-形式化表示" class="headerlink" title="petri网理论及其应用 0 形式化表示"></a>petri网理论及其应用 0 形式化表示</h1><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>热点必须要了解，结合趋势。</p><h2 id="为什么要形式化方法"><a href="#为什么要形式化方法" class="headerlink" title="为什么要形式化方法"></a>为什么要形式化方法</h2><p>形式化方法的研究高潮始于 20世纪60年代后期，针对当时所谓“软件危机”,人们提出种种解决方法,归纳起来有两类：一是采用工程方法来组织、管理软件的开发过程；二是深入探讨程 序和程序开发过程的规律，建立严密的理论，以其用来指导软件开发实践。前者导致“软件工程”的出现和发展，后者则推动了形式化方法的深入研究。</p><p>形式化方法的基本含义是借助数学的方法来研究CS中的有关问题。目的是为开发过程提供一些技术和工具，用于发现并指出软件实现中潜在的缺陷问题。数学是完美的，无二义性的，可以用在航空航天工程中，当然工业界也在慢慢的从软件测试逐步变为形式化方法。</p><h2 id="什么是形式化方法"><a href="#什么是形式化方法" class="headerlink" title="什么是形式化方法"></a>什么是形式化方法</h2><p>根据表达能力，形式化方法可以分为五类：</p><ol><li>基于模型的方法：通过明确定义状态和操作来建立一个系统模型（使系统从一个状态转换到另一个状态）。用这种方法虽可以表示非功能性需求（诸如时间需求），但不能很好地表示并发性。如：Z语言，VDM，B方法等。</li><li>基于逻辑的方法：用逻辑描述系统预期的性能，包括底层规约、时序和可能性行为。采用与所选逻辑相关的公理系统证明系统具有预期的性能。用具体的编程构 造扩充逻辑从而得到一种广谱形式化方法，通过保持正确性的细化步骤集来开发系统。如：ITL（区间时序逻辑），区段演算（DC），hoare 逻辑，WP演算，模态逻辑，时序逻辑，TAM（时序代理模型），RTTL（实时时序逻辑）等。</li><li>代数方法：通过将未定义状态下不同的操作行为相联系，给出操作的显式定义。与基于模型的方法相同的是，没有给出并发的显式表示。如：OBJ， Larch族代数规约语言等；</li><li>进程代数方法：通过限制所有容许的可观察的过程间通信来表示系统行为。此类方法允许并发过程的显式表示。如：通信顺序过程（CSP），通信系统演算 （CCS），通信过程代数（ACP），时序排序规约语言（LOTOS），计时CSP(TCSP），通信系统计时可能性演算（TPCCS）等。</li><li>基于网络的方法：由于图形化表示法易于理解，而且非专业人员能够使用，因此是一种通用的系统确定表示法。该方法采用具有形式语义的图形语言，为系统开发和再工程带来特殊的好处。如 <strong>Petri图</strong>，计时Petri图，状态图等。</li></ol><h3 id="形式化语言与自动机"><a href="#形式化语言与自动机" class="headerlink" title="形式化语言与自动机"></a>形式化语言与自动机</h3><p>以四类形式语言（短语结构语言、上下文有关语言、上下文无关语言、正则语言）</p><p>四种自动机（有穷自动机、下推自动机、图灵机、线性有界自动机）</p><h3 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h3><p>自动机是有限状态机(FSM)的数学模型。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15368328512934/15368361353633.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在编译当中有所应用。自动机描述的是顺序的，线性的。</p><p>有限自动机是指有限个状态，在语法，词法分析中有用到。编译解决的主要是上下文无关文法，日常生活中所用的语言是上下文有关的文法。科大讯飞在解决日常语言识别时使用到了大数据。</p><h3 id="λ-演算与图灵机"><a href="#λ-演算与图灵机" class="headerlink" title="λ-演算与图灵机"></a>λ-演算与图灵机</h3><p>这两者是等价的，都是回答了计算机可计算的边界这一问题。</p><p>不同的是，λ-演算使用的是数学的演算，而图灵机则是具有了一个物理的模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;petri网理论及其应用-0-形式化表示&quot;&gt;&lt;a href=&quot;#petri网理论及其应用-0-形式化表示&quot; class=&quot;headerlink&quot; title=&quot;petri网理论及其应用 0 形式化表示&quot;&gt;&lt;/a&gt;petri网理论及其应用 0 形式化表示&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="课堂笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="petri网" scheme="https://github.com/zdkswd/tags/petri%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>人工智能第一课</title>
    <link href="https://github.com/zdkswd/2018/09/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
    <id>https://github.com/zdkswd/2018/09/13/人工智能第一课/</id>
    <published>2018-09-13T08:49:32.000Z</published>
    <updated>2018-09-13T08:54:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="考核方式"><a href="#考核方式" class="headerlink" title="考核方式"></a>考核方式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/4.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="学术组织，会议"><a href="#学术组织，会议" class="headerlink" title="学术组织，会议"></a>学术组织，会议</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="刊物"><a href="#刊物" class="headerlink" title="刊物"></a>刊物</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/2/3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;考核方式&quot;&gt;&lt;a href=&quot;#考核方式&quot; class=&quot;headerlink&quot; title=&quot;考核方式&quot;&gt;&lt;/a&gt;考核方式&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="课堂笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人工智能" scheme="https://github.com/zdkswd/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 IO编程 进程和线程 正则表达式</title>
    <link href="https://github.com/zdkswd/2018/09/13/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20IO%E7%BC%96%E7%A8%8B%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/09/13/Python廖雪峰 IO编程 进程和线程 正则表达式/</id>
    <published>2018-09-13T08:46:56.000Z</published>
    <updated>2018-09-13T08:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p><p>比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p><p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p><p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p><p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p><p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p><p>注意，本章的IO编程都是同步模式，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。</p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p><p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;/Users/michael/test.txt&apos;, &apos;r&apos;)</span><br></pre></td></tr></table></figure><p>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p><p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在。</p><p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示。</p><p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure><p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p><p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p><p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便。</p><h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p><p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节</span><br></pre></td></tr></table></figure><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">'测试'</span><br></pre></td></tr></table></figure></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p><p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure></p><p>要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</p><p>以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入’a’以追加（append）模式写入。</p><h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p><p>StringIO顾名思义就是在内存中读写str。</p><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></p><p>getvalue()方法用于获得写入后的str。</p><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!\nHi!\nGoodbye!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>    s = f.readline()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure><p>StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。</p><h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</p><p>打开Python交互式命令行，我们来看看如何使用os模块的基本功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.name <span class="comment"># 操作系统类型</span></span><br><span class="line"><span class="string">'posix'</span></span><br></pre></td></tr></table></figure><p>要获取详细的系统信息，可以调用uname()函数。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看。</p><p>要获取某个环境变量的值，可以调用os.environ.get(‘key’)。</p><h3 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)</span><br></pre></td></tr></table></figure></p><p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。</p><p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。</p><p>os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便。</p><p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p><p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br></pre></td></tr></table></figure><p>但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，读写文件就可以完成文件复制。</p><p>shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p><p>我们要列出当前目录下的所有目录，只需要一行代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; [x for x in os.listdir(<span class="string">'.'</span>) if os.path.isdir(x)]</span><br><span class="line">[<span class="string">'.lein'</span>, <span class="string">'.local'</span>, <span class="string">'.m2'</span>, <span class="string">'.npm'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'.vim'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, ...]</span><br></pre></td></tr></table></figure></p><p>要列出所有的.py文件，也只需一行代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; [x for x in os.listdir(<span class="string">'.'</span>) if os.path.isfile(x) and os.path.splitext(x)[<span class="number">1</span>]==<span class="string">'.py'</span>]</span><br><span class="line">[<span class="string">'apis.py'</span>, <span class="string">'config.py'</span>, <span class="string">'models.py'</span>, <span class="string">'pymonitor.py'</span>, <span class="string">'test_db.py'</span>, <span class="string">'urls.py'</span>, <span class="string">'wsgiapp.py'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p><p>Python提供了pickle模块来实现序列化。</p><p>把一个对象序列化并写入文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b'\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'</span><br></pre></td></tr></table></figure></p><p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p><p>看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure><p>当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p><p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。</p><h3 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h3><p>Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化，但是Student对象不是一个可序列化为JSON的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2dict</span><span class="params">(std)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'name'</span>: std.name,</span><br><span class="line">        <span class="string">'age'</span>: std.age,</span><br><span class="line">        <span class="string">'score'</span>: std.score</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;<span class="string">"age"</span>: <span class="number">20</span>, <span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"score"</span>: <span class="number">88</span>&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以偷个懒，把任意class的实例变为dict：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</span><br></pre></td></tr></table></figure></p><p>因为通常class的实例都有一个<strong>dict</strong>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<strong>slots</strong>的class。</p><p>同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict2student</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Student(d[<span class="string">'name'</span>], d[<span class="string">'age'</span>], d[<span class="string">'score'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x10cd3c190</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p><p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p><p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于Windows没有fork调用，上面的代码在Windows上无法运行。由于Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的，推荐大家用Mac学Python！</p><p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p><h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>针对Windows没有fork，由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。</p><p>multiprocessing模块提供了一个Process类来代表一个进程对象。</p><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。</p><p>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。</p><p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。</p><p>Pool的默认大小是CPU的核数。</p><h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</p><p>在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p><p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p><p>Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2……</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>创建一个锁就是通过threading.Lock()来实现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h3 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h3><p>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p><p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p><p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p><p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦。</p><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p><h2 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h2><p>要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p><p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p><p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p><p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p><p>多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p><p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的<strong>缺点</strong>就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p><p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去。</p><p>切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p><h3 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h3><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p><p>对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</p><h2 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h2><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p><p>Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p><p>举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p><p>原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。</p><p>服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务。</p><p>请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。</p><p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。</p><p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p><p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>规则和javascript一样，实现形式通过re模块来实现。</p><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>由于Python的字符串本身也用\转义，所以要特别注意。</p><p>因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了。</p><p>match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p>用正则表达式切分字符串比用固定的字符更灵活。<br>在split（）函数中可以使用正则表达式。</p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。</p><p>如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。</p><p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。</p><p>和javascript一样，加个?就可以让\d+采用非贪婪匹配。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p><ol><li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li><li>用编译后的正则表达式去匹配字符串。</li></ol><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/1/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO编程&quot;&gt;&lt;a href=&quot;#IO编程&quot; class=&quot;headerlink&quot; title=&quot;IO编程&quot;&gt;&lt;/a&gt;IO编程&lt;/h1&gt;&lt;p&gt;IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 面向对象 异常处理</title>
    <link href="https://github.com/zdkswd/2018/09/02/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/09/02/Python廖雪峰 面向对象 异常处理/</id>
    <published>2018-09-02T07:00:56.000Z</published>
    <updated>2018-09-24T06:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>在Python中，定义类是通过class关键字。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.05.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p><p>创建实例是通过类名+()实现的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.05.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.06.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<strong>init</strong>方法，在创建实例的时候，就把name，score等属性绑上去。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.31.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身。</p><p>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</p><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.49.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入。</p><p>封装的另一个好处是可以给Student类增加新的方法。</p><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p><p>从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性。</p><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p><p>已经无法从外部访问实例变量.__name和实例变量.__score了</p><p>需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。</p><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%883.55.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>对私有数据操作用getter以及setter啦。</p><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。</p><p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：<strong>多态</strong>。</p><p>多态真正的威力：调用方只管调用，不管细节。</p><p>当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则。对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p><h3 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h3><p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">维基百科</span><br><span class="line">在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。</span><br></pre></td></tr></table></figure><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><p>判断对象类型，使用type()函数。<br>基本类型都可以用type()判断，如果一个变量指向函数或者类，也可以用type()判断。返回对应的Class类型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.18.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>判断一个对象是否是函数怎么办？可以使用types模块中定义的常量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.18.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p><p>isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p><p>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</p><h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.28.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>类似<strong>xxx</strong>的属性和方法在Python中都是有特殊用途的，比如<strong>len</strong>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.27.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.28.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.30.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.30.39.png" alt="屏幕快照 2018-08-31 下午4.30.39" title="">                </div>                <div class="image-caption">屏幕快照 2018-08-31 下午4.30.39</div>            </figure></p><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p><p>给实例绑定属性的方法是通过实例变量，或者通过self变量。</p><p>可以直接在class中定义属性，这种属性是类属性，归Student类所有。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%884.32.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。</p><h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><h2 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h2><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p><p>为了给所有实例都绑定方法，可以给class绑定方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.01.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p><p>Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.02.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.03.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p><h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改。</p><p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数。</p><p>调用方法又略显复杂，没有直接用属性这么直接简单。</p><p>对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法（图中为getter方法）变成属性调用的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.13.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.13.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.23.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h3><p><img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.30.44.png" alt=""></p><p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p><p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.27.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这样一来，<strong>我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</strong></p><p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p><p>只允许单一继承的语言（如Java）不能使用MixIn的设计。</p><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><p>定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.34.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这是因为直接显示变量调用的不是<strong>str__()，而是</strong>repr__()，两者的区别是<strong>str__()返回用户看到的字符串，而</strong>repr__()返回程序开发者看到的字符串，也就是说，<strong>repr</strong>()是为调试服务的。</p><p>解决办法是再定义一个<strong>repr__()。但是通常</strong>str__()和<strong>repr</strong>()代码都是一样的，所以，有个偷懒的写法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.39.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h3><p> 如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的</strong>next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.45.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a>__getitem__</h3><p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.48.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>但是如果想要正确实现一个<strong>getitem</strong>()还是要有很多工作要做的。</p><p>此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。</p><p>与之对应的是<strong>setitem、__()方法，把对象视作list或dict来对集合赋值。最后，还有一个</strong>delitem__()方法，用于删除某个元素。</p><p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p><h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。</p><p>要避免这个错误，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%889.55.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当调用不存在的属性时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值。</p><p>返回函数也是完全可以的。</p><p>注意，只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性，比如name，不会在<strong>getattr</strong>中查找。</p><p>此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的<strong>getattr</strong>默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误。          </p><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。</p><p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%8810.26.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%8810.27.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p><p>更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8B%E5%8D%8810.35.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</p><h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><p>Python提供了Enum类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.31.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.33.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h2><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。</p><p>type()函数既可以返回一个对象的类型，又可以创建出新的类型。</p><p>要创建一个class对象，type()函数依次传入3个参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.37.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p><p>正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p><h3 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h3><p>除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p><p>metaclass，直译为元类，简单的解释就是，当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p><p>先定义metaclass，就可以创建类，最后创建实例。metaclass允许你创建类或者修改类，可以把类看成是metaclass创建出来的“实例”。</p><p>按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8A%E5%8D%8811.43.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。</p><p>编写ORM会用到。</p><h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%881.40.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</p><p>可以有多个except来捕获不同类型的错误。</p><p>可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%881.41.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</p><p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p><h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>Python内置的logging模块可以非常容易地记录错误信息。</p><p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出。</p><p>通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p><p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.47.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</p><p>raise语句如果不带参数，就会把当前错误原样抛出。</p><p>捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看</p><p>用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>凡是用print()来辅助查看的地方，都可以用断言（assert）来替代。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.53.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p><p>如果断言失败，assert语句本身就会抛出AssertionError。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.55.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.55.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>关闭后，你可以把所有的assert语句当成pass来看。</p><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件。</p><p>这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p>logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p><h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。</p><p>以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt; s = ‘0’。输入命令l来查看代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.57.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>输入命令n可以单步执行代码。</p><p>任何时候都可以输入命令p 变量名来查看变量。</p><p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</p><h3 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h3><p>这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.58.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-01%20%E4%B8%8B%E5%8D%882.59.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有，Visual Studio Code，需要安装Python插件。PyCharm。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p><p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的</p><p>为了编写单元测试，我们需要引入Python自带的unittest模块。</p><p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.54.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</p><p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.50.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.53.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15356990280423/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-02%20%E4%B8%8A%E5%8D%889.56.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。</p><p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程&quot;&gt;&lt;/a&gt;面向对象编程&lt;/h1&gt;&lt;h2 id=&quot;类和实例&quot;&gt;&lt;a href=&quot;#类和实例&quot; class=&quot;headerlink&quot; title=&quot;类
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 高级特性 函数式编程 模块</title>
    <link href="https://github.com/zdkswd/2018/08/31/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%20%E6%A8%A1%E5%9D%97/"/>
    <id>https://github.com/zdkswd/2018/08/31/Python廖雪峰 高级特性 函数式编程 模块/</id>
    <published>2018-08-31T07:00:56.000Z</published>
    <updated>2018-09-24T08:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取数组前3个元素，用一行代码就可以完成切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.21.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从索引0开始取，直到索引3为止，但不包括索引3。</p><p>如果第一个索引是0，还可以省略。</p><p>Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片。</p><p>后10个数，L[-10:]。前10个数，每两个取一个，L[:10:2]。甚至什么都不写，只写[:]就可以原样复制一个list。</p><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。</p><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串。</p><p>Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</p><p>通过collections模块的Iterable类型判断一个对象是可迭代对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.34.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.35.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环里，同时引用了两个变量，在Python里是很常见的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.36.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))。</p><p>列表生成式则可以用一行语句代替循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.38.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环后面还可以加上if判断。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以使用两层循环，还可以使用两层循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.45.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.46.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>如果列表元素可以按照某种算法推算出来，可以在循环的过程中不断推算出后续的元素，就不必创建完整的list。Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>把一个列表生成式的[]改成()，就创建了一个generator。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.50.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>通过next()函数获得generator的下一个返回值。</p><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%889.57.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果一个函数定义中包含<strong>yield</strong>关键字，那么这个函数就不再是一个普通函数，而是一个<strong>generator</strong>。</p><p>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.20.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.22.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.32.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以直接作用于for循环的对象统称为可迭代对象：<strong>Iterable</strong>。如集合数据类型，如list、tuple、dict、set、str等，generator，包括生成器和带yield的generator function。</p><p>可以使用isinstance()判断一个对象是否是Iterable对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.35.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：<strong>Iterator</strong>。</p><p>可以使用isinstance()判断一个对象是否是Iterator对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.36.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</strong></p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.37.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。所以list、dict、str等数据类型不是Iterator。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>Python内建了map()和reduce()函数。</p><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.41.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p><p>所以，map()作为高阶函数，事实上它把运算规则抽象了，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list。</p><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.45.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.47.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的filter()函数用于过滤序列。</p><p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.48.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>Python内置的sorted()函数就可以对list进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.50.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.51.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.18.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>返回的函数并没有立刻执行，而是直到调用了f()才执行。</p><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数lambda x: x * x实际上就是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.35.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.37.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>同样，也可以把匿名函数作为返回值返回，比如。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.38.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><p>函数对象有一个<strong>name</strong>属性，可以拿到函数的名字。</p><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。</p><p>我们要定义一个能打印日志的decorator，可以定义如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.42.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们要借助Python的@语法，把decorator置于函数的定义处。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.42.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>把@log放到now()函数的定义处，相当于执行了语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.43.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>将原函数now传入log函数之中，返回wrapper函数，包含了原本的now功能以及加上了新的功能。将值赋予now。这样就完成了装饰。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.45.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p><p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.51.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。</p><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p><p>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<strong>author</strong>，<strong>name</strong>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<strong>doc</strong>访问，我们自己的变量一般不要用这种变量名；</p><p>类似_xxx和<strong>xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，</strong>abc等；</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public，这也是一种非常有用的代码封装和抽象的方法。</p><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。</p><p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.57.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="安装常用模块"><a href="#安装常用模块" class="headerlink" title="安装常用模块"></a>安装常用模块</h3><p>我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。</p><p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</p><p>如果我们要添加自己的搜索目录，有两种方法<br>一是直接修改sys.path，添加要搜索的目录。<br>第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高级特性&quot;&gt;&lt;a href=&quot;#高级特性&quot; class=&quot;headerlink&quot; title=&quot;高级特性&quot;&gt;&lt;/a&gt;高级特性&lt;/h1&gt;&lt;h2 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 简介，解释器，基础，函数</title>
    <link href="https://github.com/zdkswd/2018/08/27/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E7%AE%80%E4%BB%8B%EF%BC%8C%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%8C%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/08/27/Python廖雪峰 简介，解释器，基础，函数/</id>
    <published>2018-08-27T11:33:56.000Z</published>
    <updated>2018-09-13T04:46:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h1><p>Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。</p><p>除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。</p><h2 id="那Python适合开发哪些类型的应用呢？"><a href="#那Python适合开发哪些类型的应用呢？" class="headerlink" title="那Python适合开发哪些类型的应用呢？"></a>那Python适合开发哪些类型的应用呢？</h2><p>首选是网络应用，包括网站、后台服务等等；</p><p>其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</p><p>另外就是把其他语言开发的程序再包装起来，方便使用。</p><h2 id="Python的缺点"><a href="#Python的缺点" class="headerlink" title="Python的缺点"></a>Python的缺点</h2><p>第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</p><p>第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。</p><h1 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h1><p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p><h2 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h2><p>官方版本的解释器：CPython。这个解释器是用C语言开发的。CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p><h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p><h2 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h2><p>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。<br>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。</p><h2 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h2><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p><h2 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h2><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在Python中，能够直接处理的数据类型有以下几种：</p><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p><p>如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识。</p><p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义。</p><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容。用在命令行中，py文件中直接换行也可输出换行后的内容。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>一个布尔值只有True、False两种值，要么是True，要么是False。</p><p>布尔值可以用and、or和not运算。</p><p><strong>空值</strong><br>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头。</p><p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8A%E5%8D%8810.53.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可以看到赋值前不需要声明变量。</p><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>。</p><p><strong>变量在计算机内存中的表示</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8A%E5%8D%8811.07.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python解释器干了两件事情：<br>在内存中创建了一个’ABC’的字符串；<br>在内存中创建了一个名为a的变量，并把它指向’ABC’。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量。</p><p>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变。用全部大写的变量名表示常量只是一个习惯上的用法。</p><p>/ 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数。</p><h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。</p><p>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><h3 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h3><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。</p><p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p><p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的str通过encode()方法可以编码为指定的bytes。</p><p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法。</p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数。</p><p>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.00.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.00.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。Python当然也支持其他编码方式，比如把Unicode编码成GB2312。但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。</p><p>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用%实现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.07.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>常见的占位符有：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.04.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。</p><p>转义，用%%来表示一个%。</p><h4 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h4><p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.07.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一种有序的集合，可以随时添加和删除其中的元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.10.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>len()函数可以获得list元素的个数。</p><p>用索引来访问list中每一个位置的元素，记得索引是从0开始的。</p><p>-1做索引，直接获取最后一个元素。</p><p>append()可以往list中追加元素到末尾<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.12.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>insert()也可以把元素插入到指定的位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.14.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>pop()方法，删除list末尾的元素。要删除指定位置的元素，用pop(i)方法。</p><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置。</p><p>list里面的元素的数据类型也可以不同。list元素也可以是另一个list。</p><p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0。</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.37.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</p><p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><p>tuple的陷阱：只有1个元素的tuple定义时必须加一个逗号“  ,   ”，来消除歧义。</p><p>Python在显示只有1个元素的tuple时，也会加一个逗号“ , ”，以免你误解成数学计算意义上的括号。</p><p>tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><p>创建一个内容也不变的tuple那就必须保证tuple的每一个元素本身也不能变。</p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if语句elif是else if的缩写。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.43.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>input()读取用户的输入，这样可以自己输入。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.48.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p><p>range()函数，可以生成一个整数序列，range(5)生成的序列是从0开始小于5（没有5）的整数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.53.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>0-100。</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.53.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break语句可以提前退出循环。</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue语句，跳过当前的这次循环，直接开始下一次循环。</p><h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%884.01.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入。</p><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。</p><p>如果key不存在，dict就会报错，要避免key不存在的错误，有两种办法，一是通过in判断key是否存在，二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value。注意：返回None的时候Python的交互环境不显示结果。</p><p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%884.11.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p><p>和list比较，dict有以下几个特点<br>查找和插入的速度极快，不会随着key的增加而变慢<br>需要占用大量的内存，内存浪费多<br>而list相反</p><p>dict是用空间来换取时间的一种方法。</p><p>正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%882.58.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>重复元素在set中自动被过滤。</p><p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果。</p><p>通过remove(key)方法可以删除元素。</p><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.26.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象。</p><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。</p><p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误。如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息。</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.37.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.39.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.40.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）。</p><h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果想定义一个什么事也不做的空函数，可以用pass语句。</p><p>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p><p>缺少了pass，代码运行就会有语法错误。</p><h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError。但是如果参数类型不对，Python解释器就无法帮我们检查。</p><p>对参数的限制需要我们手动完成，数据类型检查可以用内置函数isinstance()实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.51.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.52.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但其实这只是一种假象，Python函数返回的仍然是单一值。</p><p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>函数体内部可以用return随时返回函数结果；<br>函数执行完毕也没有return语句时，自动return None。</p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>对于power(x)函数，参数x就是一个位置参数。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p> power(x, n=2)</p><p>当我们调用power(5)时，相当于调用power(5, 2)</p><p>设置默认参数时，有几点要注意<br>一是必选参数在前，默认参数在后，否则Python的解释器会报错。<br>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><p>默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.01.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll(‘Bob’, ‘M’, 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</p><p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(‘Adam’, ‘M’, city=’Tianjin’)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</p><p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑。<strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p><p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.49.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。</p><p>Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.50.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.54.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.55.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.56.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p><h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.00.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。</p><p>调用方式如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.09.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.10.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.10.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>命名关键字参数可以有缺省值，从而简化调用。</p><h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。</p><p><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></p><p>对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。</p><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p><p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python简介&quot;&gt;&lt;a href=&quot;#Python简介&quot; class=&quot;headerlink&quot; title=&quot;Python简介&quot;&gt;&lt;/a&gt;Python简介&lt;/h1&gt;&lt;p&gt;Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM模型 一</title>
    <link href="https://github.com/zdkswd/2018/08/22/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%E6%A8%A1%E5%9E%8B%20%E4%B8%80/"/>
    <id>https://github.com/zdkswd/2018/08/22/JavaScript标准参考教程 DOM模型 一/</id>
    <published>2018-08-22T10:33:56.000Z</published>
    <updated>2018-08-26T02:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM模型概述"><a href="#DOM模型概述" class="headerlink" title="DOM模型概述"></a>DOM模型概述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p><p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p><p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p><p>节点的类型有七种<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%889.50.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。</p><h3 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h3><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</p><p>浏览器原生提供document节点，代表整个文档。</p><p>文档的第一层只有一个节点，就是 HTML 网页的第一个标签&lt; html&gt;，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p><p>除了根节点，其他节点都有三种层级关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.05.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括firstChild（第一个子节点）和lastChild（最后一个子节点）等属性，同级节点接口包括nextSibling（紧邻在后的那个同级节点）和previousSibling（紧邻在前的那个同级节点）属性。</p><h2 id="Node-接口的属性"><a href="#Node-接口的属性" class="headerlink" title="Node 接口的属性"></a>Node 接口的属性</h2><p>所有 DOM 节点都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p><h3 id="Node-nodeType"><a href="#Node-nodeType" class="headerlink" title="Node.nodeType"></a>Node.nodeType</h3><p>nodeType属性返回一个整数值，表示节点的类型。</p><p>Node 对象定义了几个常量，对应这些类型值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.07.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>确定节点类型时，使用nodeType属性是常用方法。</p><h3 id="Node-nodeName"><a href="#Node-nodeName" class="headerlink" title="Node.nodeName"></a>Node.nodeName</h3><p>nodeName属性返回节点的名称。</p><p>不同节点的nodeName属性值如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.10.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Node-nodeValue"><a href="#Node-nodeValue" class="headerlink" title="Node.nodeValue"></a>Node.nodeValue</h3><p>nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p><p>只有文本节点（text）和注释节点（comment）有文本值，因此这两类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这两类节点可以设置nodeValue属性的值，其他类型的节点设置无效。</p><h3 id="Node-textContent"><a href="#Node-textContent" class="headerlink" title="Node.textContent"></a>Node.textContent</h3><p>textContent属性返回当前节点和它的所有后代节点的文本内容。</p><p>textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p><p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p><p>对于文本节点（text）和注释节点（comment），textContent属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括注释节点。如果一个节点没有子节点，则返回空字符串。</p><p>文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。</p><h3 id="Node-baseURI"><a href="#Node-baseURI" class="headerlink" title="Node.baseURI"></a>Node.baseURI</h3><p>baseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p><p>如果无法读到网页的 URL，baseURI属性返回null。</p><p>该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的&lt; base&gt;标签，改变该属性的值。</p><p>设置了以后，baseURI属性就返回<base>标签设置的值。</p><h3 id="Node-ownerDocument"><a href="#Node-ownerDocument" class="headerlink" title="Node.ownerDocument"></a>Node.ownerDocument</h3><p>Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。</p><p>document对象本身的ownerDocument属性，返回null。</p><h3 id="Node-nextSibling"><a href="#Node-nextSibling" class="headerlink" title="Node.nextSibling"></a>Node.nextSibling</h3><p>Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</p><p>注意，该属性还包括文本节点和注释节点（<!-- comment -->）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p><p>nextSibling属性可以用来遍历所有子节点。</p><h3 id="Node-previousSibling"><a href="#Node-previousSibling" class="headerlink" title="Node.previousSibling"></a>Node.previousSibling</h3><p>previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。</p><p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p><h3 id="Node-parentNode"><a href="#Node-parentNode" class="headerlink" title="Node.parentNode"></a>Node.parentNode</h3><p>parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p><p>文档节点（document）和文档片段节点（documentfragment）的父节点都是null。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是null。</p><h3 id="Node-parentElement"><a href="#Node-parentElement" class="headerlink" title="Node.parentElement"></a>Node.parentElement</h3><p>parentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。</p><p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。parentElement属性相当于把后两种父节点都排除了。</p><h3 id="Node-firstChild，Node-lastChild"><a href="#Node-firstChild，Node-lastChild" class="headerlink" title="Node.firstChild，Node.lastChild"></a>Node.firstChild，Node.lastChild</h3><p>firstChild属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。</p><p>注意，firstChild返回的除了元素节点，还可能是文本节点或注释节点。</p><p>lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。用法与firstChild属性相同。</p><h3 id="Node-childNodes"><a href="#Node-childNodes" class="headerlink" title="Node.childNodes"></a>Node.childNodes</h3><p>childNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。</p><p>使用该属性，可以遍历某个节点的所有子节点。</p><p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p><h3 id="Node-isConnected"><a href="#Node-isConnected" class="headerlink" title="Node.isConnected"></a>Node.isConnected</h3><p>isConnected属性返回一个布尔值，表示当前节点是否在文档之中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.56.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Node-接口的方法"><a href="#Node-接口的方法" class="headerlink" title="Node 接口的方法"></a>Node 接口的方法</h2><h3 id="Node-appendChild"><a href="#Node-appendChild" class="headerlink" title="Node.appendChild()"></a>Node.appendChild()</h3><p>appendChild方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.00.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果参数节点是 DOM 已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置。</p><p>如果appendChild方法的参数是DocumentFragment节点，那么插入的是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值是一个空的DocumentFragment节点。</p><h3 id="Node-hasChildNodes"><a href="#Node-hasChildNodes" class="headerlink" title="Node.hasChildNodes()"></a>Node.hasChildNodes()</h3><p>hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。</p><p>注意，子节点包括所有节点，哪怕节点只包含一个空格，hasChildNodes方法也会返回true。</p><p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.05.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Node-cloneNode"><a href="#Node-cloneNode" class="headerlink" title="Node.cloneNode()"></a>Node.cloneNode()</h3><p>cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p><p>该方法有一些使用注意点。</p><ol><li>克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即node.onclick = fn），添加在这个节点上的事件回调函数。</li><li>该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如Node.appendChild这样的方法添加到文档之中。</li><li>克隆一个节点之后，DOM 有可能出现两个有相同id属性（即id=”xxx”）的网页元素，这时应该修改其中一个元素的id属性。如果原节点有name属性，可能也需要修改。</li></ol><h3 id="Node-insertBefore"><a href="#Node-insertBefore" class="headerlink" title="Node.insertBefore()"></a>Node.insertBefore()</h3><p>insertBefore方法用于将某个节点插入父节点内部的指定位置。</p><p>insertBefore方法接受两个参数，第一个参数是所要插入的节点newNode，第二个参数是父节点parentNode内部的一个子节点referenceNode。newNode将插在referenceNode这个子节点的前面。返回值是插入的新节点newNode。</p><p>如果insertBefore方法的第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p><p><strong>注意</strong>，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p><p>由于不存在insertAfter方法，如果新节点要插在父节点的某个子节点后面，可以用insertBefore方法结合nextSibling属性模拟。</p><p>如果要插入的节点是DocumentFragment类型，那么插入的将是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值将是一个空的DocumentFragment节点。</p><h3 id="Node-removeChild"><a href="#Node-removeChild" class="headerlink" title="Node.removeChild()"></a>Node.removeChild()</h3><p>removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p><p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p><p>如果参数节点不是当前节点的子节点，removeChild方法将报错。</p><h3 id="Node-replaceChild"><a href="#Node-replaceChild" class="headerlink" title="Node.replaceChild()"></a>Node.replaceChild()</h3><p>replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。</p><p>replaceChild方法接受两个参数，第一个参数newChild是用来替换的新节点，第二个参数oldChild是将要替换走的子节点。返回值是替换走的那个节点oldChild。</p><h3 id="Node-contains"><a href="#Node-contains" class="headerlink" title="Node.contains()"></a>Node.contains()</h3><p>contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.21.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Node-compareDocumentPosition"><a href="#Node-compareDocumentPosition" class="headerlink" title="Node.compareDocumentPosition()"></a>Node.compareDocumentPosition()</h3><p>compareDocumentPosition方法的用法，与contains方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.22.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于compareDocumentPosition返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p><p>进行与运算（&amp;）。</p><h3 id="Node-isEqualNode-，Node-isSameNode"><a href="#Node-isEqualNode-，Node-isSameNode" class="headerlink" title="Node.isEqualNode()，Node.isSameNode()"></a>Node.isEqualNode()，Node.isSameNode()</h3><p>isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p><p>isSameNode方法返回一个布尔值，表示两个节点是否为同一个节点。</p><h3 id="Node-normalize"><a href="#Node-normalize" class="headerlink" title="Node.normalize()"></a>Node.normalize()</h3><p>normailize方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p><p>该方法是Text.splitText的逆方法。</p><h3 id="Node-getRootNode"><a href="#Node-getRootNode" class="headerlink" title="Node.getRootNode()"></a>Node.getRootNode()</h3><p>getRootNode方法返回当前节点所在文档的根节点。</p><h2 id="NodeList-接口"><a href="#NodeList-接口" class="headerlink" title="NodeList 接口"></a>NodeList 接口</h2><p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：NodeList和HTMLCollection。</p><p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是NodeList实例或HTMLCollection实例。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%883.58.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。</p><p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。</p><h3 id="NodeList-prototype-length"><a href="#NodeList-prototype-length" class="headerlink" title="NodeList.prototype.length"></a>NodeList.prototype.length</h3><p>length属性返回 NodeList 实例包含的节点数量。</p><p>document.getElementsByTagName返回一个 NodeList 集合。对于那些不存在的 HTML 标签，length属性返回0。</p><h3 id="NodeList-prototype-forEach"><a href="#NodeList-prototype-forEach" class="headerlink" title="NodeList.prototype.forEach()"></a>NodeList.prototype.forEach()</h3><p>forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。</p><p>forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。</p><h3 id="NodeList-prototype-item"><a href="#NodeList-prototype-item" class="headerlink" title="NodeList.prototype.item()"></a>NodeList.prototype.item()</h3><p>item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p><p>如果参数值大于实际长度，或者索引不合法（比如负数），item方法返回null。如果省略参数，item方法会报错。</p><p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用item方法。</p><h3 id="NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries"><a href="#NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries" class="headerlink" title="NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()"></a>NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h3><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过for…of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。</p><h2 id="HTMLCollection-接口"><a href="#HTMLCollection-接口" class="headerlink" title="HTMLCollection 接口"></a>HTMLCollection 接口</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历。</p><p>HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中。</p><p>如果元素节点有id或name属性，那么HTMLCollection实例上面，可以使用id属性或name属性引用该节点元素。如果没有对应的节点，则返回null。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%884.25.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="HTMLCollection-prototype-length"><a href="#HTMLCollection-prototype-length" class="headerlink" title="HTMLCollection.prototype.length"></a>HTMLCollection.prototype.length</h3><p>length属性返回HTMLCollection实例包含的成员数量。</p><h3 id="HTMLCollection-prototype-item"><a href="#HTMLCollection-prototype-item" class="headerlink" title="HTMLCollection.prototype.item()"></a>HTMLCollection.prototype.item()</h3><p>item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p><p>如果参数值超出成员数量或者不合法（比如小于0），那么item方法返回null。</p><h3 id="HTMLCollection-prototype-namedItem"><a href="#HTMLCollection-prototype-namedItem" class="headerlink" title="HTMLCollection.prototype.namedItem()"></a>HTMLCollection.prototype.namedItem()</h3><p>namedItem方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%884.28.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="ParentNode-接口"><a href="#ParentNode-接口" class="headerlink" title="ParentNode 接口"></a>ParentNode 接口</h2><p>节点对象除了继承 Node 接口以外，还会继承其他接口。ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。ChildNode接口表示当前节点是一个子节点，提供一些相关方法。</p><p>如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口。</p><h3 id="ParentNode-children"><a href="#ParentNode-children" class="headerlink" title="ParentNode.children"></a>ParentNode.children</h3><p>children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。</p><p>children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。</p><p>HTMLCollection是动态集合，会实时反映 DOM 的任何变化。</p><h3 id="ParentNode-firstElementChild"><a href="#ParentNode-firstElementChild" class="headerlink" title="ParentNode.firstElementChild"></a>ParentNode.firstElementChild</h3><p>firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。</p><h3 id="ParentNode-lastElementChild"><a href="#ParentNode-lastElementChild" class="headerlink" title="ParentNode.lastElementChild"></a>ParentNode.lastElementChild</h3><p>lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。</p><h3 id="ParentNode-childElementCount"><a href="#ParentNode-childElementCount" class="headerlink" title="ParentNode.childElementCount"></a>ParentNode.childElementCount</h3><p>childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。</p><h3 id="ParentNode-append-，ParentNode-prepend"><a href="#ParentNode-append-，ParentNode-prepend" class="headerlink" title="ParentNode.append()，ParentNode.prepend()"></a>ParentNode.append()，ParentNode.prepend()</h3><p>append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p><p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p><p>注意，该方法没有返回值。</p><p>prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。</p><h2 id="ChildNode-接口"><a href="#ChildNode-接口" class="headerlink" title="ChildNode 接口"></a>ChildNode 接口</h2><p>如果一个节点有父节点，那么该节点就继承了ChildNode接口。</p><h3 id="ChildNode-remove"><a href="#ChildNode-remove" class="headerlink" title="ChildNode.remove()"></a>ChildNode.remove()</h3><p>remove方法用于从父节点移除当前节点。</p><h3 id="ChildNode-before-，ChildNode-after"><a href="#ChildNode-before-，ChildNode-after" class="headerlink" title="ChildNode.before()，ChildNode.after()"></a>ChildNode.before()，ChildNode.after()</h3><p>before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p><p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p><p>after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。</p><h3 id="ChildNode-replaceWith"><a href="#ChildNode-replaceWith" class="headerlink" title="ChildNode.replaceWith()"></a>ChildNode.replaceWith()</h3><p>replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p><h1 id="document-对象"><a href="#document-对象" class="headerlink" title="document 对象"></a>document 对象</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>document对象是文档的根节点，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p><p>document对象有不同的办法可以获取。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%885.01.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>document对象继承了EventTarget接口、Node接口、ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="快捷方式属性"><a href="#快捷方式属性" class="headerlink" title="快捷方式属性"></a>快捷方式属性</h3><p>以下属性是指向文档内部的某个节点的快捷方式。</p><h4 id="document-defaultView"><a href="#document-defaultView" class="headerlink" title="document.defaultView"></a>document.defaultView</h4><p>document.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。</p><h4 id="document-doctype"><a href="#document-doctype" class="headerlink" title="document.doctype"></a>document.doctype</h4><p>对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt; DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt; !DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。</p><p>document.firstChild通常就返回这个节点。</p><h4 id="document-documentElement"><a href="#document-documentElement" class="headerlink" title="document.documentElement"></a>document.documentElement</h4><p>document.documentElement属性返回当前文档的根节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是<html>节点。</html></p><h4 id="document-body，document-head"><a href="#document-body，document-head" class="headerlink" title="document.body，document.head"></a>document.body，document.head</h4><p>document.body属性指向&lt; body&gt;节点，document.head属性指向&lt; head&gt;节点。</p><p>这两个属性总是存在的，如果网页源码里面省略了&lt; head&gt;或&lt; body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p><h4 id="document-scrollingElement"><a href="#document-scrollingElement" class="headerlink" title="document.scrollingElement"></a>document.scrollingElement</h4><p>document.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p><p>标准模式下，这个属性返回的文档的根元素document.documentElement（即<html>）。兼容（quirk）模式下，返回的是<body>元素，如果该元素不存在，返回null。</body></html></p><h4 id="document-activeElement"><a href="#document-activeElement" class="headerlink" title="document.activeElement"></a>document.activeElement</h4><p>document.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt; input&gt;、&lt; textarea&gt;、&lt; select&gt;等表单元素，如果当前没有焦点元素，返回&lt; body&gt;元素或null。</p><h4 id="document-fullscreenElement"><a href="#document-fullscreenElement" class="headerlink" title="document.fullscreenElement"></a>document.fullscreenElement</h4><p>document.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。</p><h2 id="节点集合属性"><a href="#节点集合属性" class="headerlink" title="节点集合属性"></a>节点集合属性</h2><p>以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p><h3 id="document-links"><a href="#document-links" class="headerlink" title="document.links"></a>document.links</h3><p>document.links属性返回当前文档所有设定了href属性的&lt; a&gt;及&lt; area&gt;节点。</p><h3 id="document-forms"><a href="#document-forms" class="headerlink" title="document.forms"></a>document.forms</h3><p>document.forms属性返回所有&lt; form&gt;表单节点。</p><h3 id="document-images"><a href="#document-images" class="headerlink" title="document.images"></a>document.images</h3><p>document.images属性返回页面所有&lt; img&gt;图片节点。</p><h3 id="document-embeds，document-plugins"><a href="#document-embeds，document-plugins" class="headerlink" title="document.embeds，document.plugins"></a>document.embeds，document.plugins</h3><p>document.embeds属性和document.plugins属性，都返回所有&lt; embed&gt;节点。</p><h3 id="document-scripts"><a href="#document-scripts" class="headerlink" title="document.scripts"></a>document.scripts</h3><p>document.scripts属性返回所有&lt; script&gt;节点。</p><h3 id="document-styleSheets"><a href="#document-styleSheets" class="headerlink" title="document.styleSheets"></a>document.styleSheets</h3><p>document.styleSheets属性返回文档内嵌或引入的样式表集合。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。</p><p>HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%886.03.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文档静态信息属性"><a href="#文档静态信息属性" class="headerlink" title="文档静态信息属性"></a>文档静态信息属性</h2><p>以下属性返回文档信息。</p><h3 id="document-documentURI，document-URL"><a href="#document-documentURI，document-URL" class="headerlink" title="document.documentURI，document.URL"></a>document.documentURI，document.URL</h3><p>document.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。</p><p>如果文档的锚点（#anchor）变化，这两个属性都会跟着变化。</p><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>document.domain属性返回当前文档的域名，不包含协议和接口。</p><p>比如，网页的网址是<a href="http://www.example.com:80/hello.html，" target="_blank" rel="noopener">http://www.example.com:80/hello.html，</a> 那么domain属性就等于<a href="http://www.example.com。如果无法获取域名，该属性返回null。" target="_blank" rel="noopener">www.example.com。如果无法获取域名，该属性返回null。</a></p><p>document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p><p>另外，设置document.domain会导致端口被改成null。因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同</p><h3 id="document-location"><a href="#document-location" class="headerlink" title="document.location"></a>document.location</h3><p>Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。</p><h3 id="document-lastModified"><a href="#document-lastModified" class="headerlink" title="document.lastModified"></a>document.lastModified</h3><p>document.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</p><p>注意，document.lastModified属性的值是字符串，所以不能直接用来比较。Date.parse方法将其转为Date实例，才能比较两个网页。</p><h3 id="document-title"><a href="#document-title" class="headerlink" title="document.title"></a>document.title</h3><p>document.title属性返回当前文档的标题。默认情况下，返回<title>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</title></p><h3 id="document-characterSet"><a href="#document-characterSet" class="headerlink" title="document.characterSet"></a>document.characterSet</h3><p>document.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。</p><h3 id="document-referrer"><a href="#document-referrer" class="headerlink" title="document.referrer"></a>document.referrer</h3><p>document.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。</p><h3 id="document-dir"><a href="#document-dir" class="headerlink" title="document.dir"></a>document.dir</h3><p>document.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p><h3 id="document-compatMode"><a href="#document-compatMode" class="headerlink" title="document.compatMode"></a>document.compatMode</h3><p>compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。</p><p>一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat。</p><h2 id="文档状态属性"><a href="#文档状态属性" class="headerlink" title="文档状态属性"></a>文档状态属性</h2><h3 id="document-hidden"><a href="#document-hidden" class="headerlink" title="document.hidden"></a>document.hidden</h3><p>document.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。</p><h3 id="document-visibilityState"><a href="#document-visibilityState" class="headerlink" title="document.visibilityState"></a>document.visibilityState</h3><p>document.visibilityState返回文档的可见状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%886.34.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</p><h3 id="document-readyState"><a href="#document-readyState" class="headerlink" title="document.readyState"></a>document.readyState</h3><p>document.readyState属性返回当前文档的状态，共有三种可能的值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%886.35.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个属性变化的过程如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.19.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次状态变化都会触发一个readystatechange事件。</p><h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p>document.cookie属性用来操作浏览器 Cookie。</p><h3 id="document-designMode"><a href="#document-designMode" class="headerlink" title="document.designMode"></a>document.designMode</h3><p>document.designMode属性控制当前文档是否可编辑，通常用在所见即所得编辑器。该属性只有两个值on和off，默认值为off。</p><h3 id="document-implementation"><a href="#document-implementation" class="headerlink" title="document.implementation"></a>document.implementation</h3><p>document.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.24.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="document-open-，document-close"><a href="#document-open-，document-close" class="headerlink" title="document.open()，document.close()"></a>document.open()，document.close()</h3><p>document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。</p><p>document.close方法用来关闭document.open()打开的文档。</p><h3 id="document-write-，document-writeln"><a href="#document-write-，document-writeln" class="headerlink" title="document.write()，document.writeln()"></a>document.write()，document.writeln()</h3><p>document.write方法用于向当前文档写入内容。</p><p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。</p><p>注意，document.write会当作 HTML 代码解析，不会转义。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.27.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。</p><p>如果在页面渲染过程中调用write方法，并不会自动调用open方法。（可以理解成，open方法已调用，但close方法还未调用。）</p><p>document.write是JavaScript语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对innerHTML属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。</p><p>document.writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。</p><p>注意，writeln方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<br>。</p><h3 id="document-querySelector-，document-querySelectorAll"><a href="#document-querySelector-，document-querySelectorAll" class="headerlink" title="document.querySelector()，document.querySelectorAll()"></a>document.querySelector()，document.querySelectorAll()</h3><p>document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.53.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。</p><p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p><p>这两个方法都支持复杂的 CSS 选择器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.55.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是，它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。</p><p>如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。</p><p>最后，这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。</p><h3 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName()"></a>document.getElementsByTagName()</h3><p>document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p><p>HTML 标签名是大小写不敏感的，因此getElementsByTagName方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p><p>注意，元素节点本身也定义了getElementsByTagName方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。</p><h3 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName()"></a>document.getElementsByClassName()</h3><p>document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p><p>由于class是保留字，所以 JavaScript 一律使用className表示 CSS 的class。</p><p>参数可以是多个class，它们之间使用空格分隔。</p><p>注意，正常模式下，CSS 的class是大小写敏感的。（quirks mode下，大小写不敏感。）</p><p>与getElementsByTagName方法一样，getElementsByClassName方法不仅可以在document对象上调用，也可以在任何元素节点上调用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%8812.08.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName()"></a>document.getElementsByName()</h3><p>document.getElementsByName方法用于选择拥有name属性的 HTML 元素,返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。</p><h3 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById()"></a>document.getElementById()</h3><p>document.getElementById方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。</p><p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的id属性是main，那么document.getElementById(‘Main’)将返回null。</p><p>document.getElementById方法与document.querySelector方法都能获取元素节点，不同之处是document.querySelector方法的参数使用 CSS 选择器语法，document.getElementById方法的参数是元素的id属性。document.getElementById()比document.querySelector()效率高得多。</p><p>另外，这个方法只能在document对象上使用，不能在其他元素节点上使用。</p><h3 id="document-elementFromPoint-，document-elementsFromPoint"><a href="#document-elementFromPoint-，document-elementsFromPoint" class="headerlink" title="document.elementFromPoint()，document.elementsFromPoint()"></a>document.elementFromPoint()，document.elementsFromPoint()</h3><p>document.elementFromPoint方法返回位于页面指定位置最上层的元素节点。</p><p>elementFromPoint方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回null。</p><p>document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p><h3 id="document-caretPositionFromPoint"><a href="#document-caretPositionFromPoint" class="headerlink" title="document.caretPositionFromPoint()"></a>document.caretPositionFromPoint()</h3><p>document.caretPositionFromPoint()返回一个 CaretPosition 对象，包含了指定坐标点在节点对象内部的位置信息。CaretPosition 对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。</p><p>CaretPosition 对象。该对象有两个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.04.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h3><p>document.createElement方法用来生成元素节点，并返回该节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.05.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感，即参数为div或DIV返回的是同一种节点。如果参数里面包含尖括号（即&lt;和&gt;）会报错。</p><p>注意，document.createElement的参数可以是自定义的标签名。</p><h3 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h3><p>document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.07.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</p><h3 id="document-createAttribute"><a href="#document-createAttribute" class="headerlink" title="document.createAttribute()"></a>document.createAttribute()</h3><p>document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。</p><p>document.createAttribute方法的参数name，是属性的名称。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.09.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="document-createComment"><a href="#document-createComment" class="headerlink" title="document.createComment()"></a>document.createComment()</h3><p>document.createComment方法生成一个新的注释节点，并返回该节点。</p><p>document.createComment方法的参数是一个字符串，会成为注释节点的内容。</p><h3 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h3><p>document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。</p><p>DocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.12.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="document-createEvent"><a href="#document-createEvent" class="headerlink" title="document.createEvent()"></a>document.createEvent()</h3><p>document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。</p><p>document.createEvent方法的参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents。</p><h3 id="document-addEventListener-，document-removeEventListener-，document-dispatchEvent"><a href="#document-addEventListener-，document-removeEventListener-，document-dispatchEvent" class="headerlink" title="document.addEventListener()，document.removeEventListener()，document.dispatchEvent()"></a>document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h3><p>这三个方法用于处理document节点的事件。它们都继承自EventTarget接口。</p><h3 id="document-hasFocus"><a href="#document-hasFocus" class="headerlink" title="document.hasFocus()"></a>document.hasFocus()</h3><p>document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p><p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p><h3 id="document-adoptNode-，document-importNode"><a href="#document-adoptNode-，document-importNode" class="headerlink" title="document.adoptNode()，document.importNode()"></a>document.adoptNode()，document.importNode()</h3><p>document.adoptNode方法将某个节点及其子节点，从原来所在的文档或DocumentFragment里面移除，归属当前document对象，返回插入后的新节点。插入的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。</p><p>注意，document.adoptNode方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用appendChild方法或insertBefore方法，将新节点插入当前文档树。</p><p>document.importNode方法则是从原来所在的文档或DocumentFragment里面，拷贝某个节点及其子节点，让它们归属当前document对象。拷贝的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。</p><p>document.importNode方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为true。</p><p>注意，document.importNode方法只是拷贝外部节点，这时该节点的父节点是null。下一步还必须将这个节点插入当前文档树。</p><h3 id="document-createNodeIterator"><a href="#document-createNodeIterator" class="headerlink" title="document.createNodeIterator()"></a>document.createNodeIterator()</h3><p>document.createNodeIterator方法返回一个子节点遍历器。</p><p>document.createNodeIterator方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（NodeFilter.SHOW_ELEMENT）。几种主要的节点类型写法如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.35.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>document.createNodeIterator方法返回一个“遍历器”对象（NodeFilter实例）。该实例的nextNode()方法和previousNode()方法，可以用来遍历所有子节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.40.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>currentNode和previousNode都指向同一个的节点。</p><p>注意，遍历器返回的第一个节点，总是根节点。</p><h3 id="document-createTreeWalker"><a href="#document-createTreeWalker" class="headerlink" title="document.createTreeWalker()"></a>document.createTreeWalker()</h3><p>document.createTreeWalker方法返回一个 DOM 的子树遍历器。它与document.createNodeIterator方法基本是类似的，区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。另外，它的第一个节点不是根节点。</p><p>document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与document.createNodeIterator方法的第二个参数相同）。</p><h3 id="document-getSelection"><a href="#document-getSelection" class="headerlink" title="document.getSelection()"></a>document.getSelection()</h3><p>这个方法指向window.getSelection()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DOM模型概述&quot;&gt;&lt;a href=&quot;#DOM模型概述&quot; class=&quot;headerlink&quot; title=&quot;DOM模型概述&quot;&gt;&lt;/a&gt;DOM模型概述&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>健身</title>
    <link href="https://github.com/zdkswd/2018/08/21/%E5%81%A5%E8%BA%AB/"/>
    <id>https://github.com/zdkswd/2018/08/21/健身/</id>
    <published>2018-08-21T01:49:12.000Z</published>
    <updated>2018-08-21T01:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><p>关注引领性指标</p><p>3900大卡差值消耗一斤脂肪。</p><p>计算每日消耗总热量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348093471499.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>计算摄入量<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348095297404.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果差值过大，会导致肌肉减少和基础代谢率降低，很容易反弹，难以持续。</p><p>随着体重降低，也要不断的调整。</p><p>把摄入热量除以3得到每餐要吃的热量。</p><p>三餐热量不同也可以，只要一天内摄入不超过即可。</p><p>每餐一个拳头的蛋白质，一个拳头的碳水化合物，蔬菜随便吃。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348099519577.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>蛋白质的主要来源 精瘦的鸡肉，猪肉，牛肉，海鲜，鱼，鸡蛋，牛奶，豆类。</p><p>碳水化合物尽量选择粗粮，比如说玉米，红薯，土豆，糙米，米粉，面条，面包。</p><p>追踪自己的减脂进展。</p><h2 id="超实用技巧"><a href="#超实用技巧" class="headerlink" title="超实用技巧"></a>超实用技巧</h2><p>餐前吃半根香蕉或者一粒糖。</p><p>第二个，每餐前吃六到七粒坚果。增加饱腹感。英国有研究表明每天吃20粒坚果能降低癌症和心脏病的风险。</p><p>第三个，用南瓜代替主食。</p><p>第四点，少油盐，外食要过水，油的热量远远大于菜的热量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348110037373.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>图中的食物可以随便吃。无限量吃。</p><p>第六个，嚼无糖口香糖，咀嚼感。</p><h2 id="瘦了后保持体形"><a href="#瘦了后保持体形" class="headerlink" title="瘦了后保持体形"></a>瘦了后保持体形</h2><p>保持期可以放宽，不需要赤字了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348113398115.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>早睡11点</li><li>吃早饭</li><li>冥想拉伸</li><li>少盐多蛋白质</li><li>跳绳</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;健身&quot;&gt;&lt;a href=&quot;#健身&quot; class=&quot;headerlink&quot; title=&quot;健身&quot;&gt;&lt;/a&gt;健身&lt;/h1&gt;&lt;p&gt;关注引领性指标&lt;/p&gt;
&lt;p&gt;3900大卡差值消耗一斤脂肪。&lt;/p&gt;
&lt;p&gt;计算每日消耗总热量。&lt;br&gt;&lt;figure class=&quot;ima
      
    
    </summary>
    
      <category term="知乎Live" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E4%B9%8ELive/"/>
    
    
      <category term="健身" scheme="https://github.com/zdkswd/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 语法专题</title>
    <link href="https://github.com/zdkswd/2018/08/20/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <id>https://github.com/zdkswd/2018/08/20/JavaScript标准参考教程 语法专题/</id>
    <published>2018-08-20T11:14:56.000Z</published>
    <updated>2018-08-20T11:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步操作概述"><a href="#异步操作概述" class="headerlink" title="异步操作概述"></a>异步操作概述</h1><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p><p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p><p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p><p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h2 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h2><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件。</p><h2 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h2><p>下面总结一下异步操作的几种模式。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是异步操作最基本的方法。</p><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><p>首先，为f1绑定一个事件（这里采用的 jQuery 的写法）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.52.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.53.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。</p><p>这个模式有多种实现，下面采用的是 Ben Alman 的 Tiny Pub/Sub，这是 jQuery 的一个插件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.56.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.56.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>f2完成执行后，可以取消订阅（unsubscribe）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.57.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><h2 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h2><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p><h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。</p><p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p><h3 id="并行与串行的结合"><a href="#并行与串行的结合" class="headerlink" title="并行与串行的结合"></a>并行与串行的结合</h3><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。</p><p>上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。</p><p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节limit变量，达到效率和资源的最佳平衡。</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p>setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p><p>setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。</p><p>除了前两个参数，setTimeout还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p><p>还有一个需要注意的地方，如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。</p><p>为了防止出现这个问题，一种解决方法是将obj.y放入一个函数。obj.y放在一个匿名函数之中，这使得obj.y在obj的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p><p>另一种解决方法是，使用bind方法，将obj.y这个方法绑定在obj上面。</p><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p>setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p><p>与setTimeout一样，除了前两个参数，setInterval方法还可以接受更多的参数，它们会传入回调函数。</p><h2 id="clearTimeout-，clearInterval"><a href="#clearTimeout-，clearInterval" class="headerlink" title="clearTimeout()，clearInterval()"></a>clearTimeout()，clearInterval()</h2><p>setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。</p><p>连续调用三次setTimeout，返回值都比上一次大了1。</p><p>利用这一点，可以写一个函数，取消当前所有的setTimeout定时器。</p><h2 id="实例：debounce-函数"><a href="#实例：debounce-函数" class="headerlink" title="实例：debounce 函数"></a>实例：debounce 函数</h2><p>有时，我们不希望回调函数被频繁调用。如果用户连续击键，就会连续触发keydown事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的keydown事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，再将数据发送出去。</p><p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%884.50.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p><p>这意味着，setTimeout和setInterval指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。</p><h2 id="setTimeout-f-0"><a href="#setTimeout-f-0" class="headerlink" title="setTimeout(f, 0)"></a>setTimeout(f, 0)</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f, 0)，那么会立刻执行吗？</p><p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行setTimeout指定的回调函数f。也就是说，setTimeout(f, 0)会在下一轮事件循环一开始就执行。</p><p>setTimeout(f, 0)这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f。</p><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p><p>首先，Promise 是一个对象，也是一个构造函数。</p><p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.02.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p><p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p><h2 id="Promise-对象的状态"><a href="#Promise-对象的状态" class="headerlink" title="Promise 对象的状态"></a>Promise 对象的状态</h2><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.04.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。</p><p>这三种的状态的变化途径只有两种。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.04.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p><p>因此，Promise 的最终结果只有两种。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.05.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h2><p>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.20.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例的then方法，用来添加回调函数。</p><p>then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p><p>then方法可以链式使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.26.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。</p><p>最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。</p><h2 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then() 用法辨析"></a>then() 用法辨析</h2><p>Promise 的用法，简单说就是一句话：使用then方法添加回调函数。</p><h2 id="Promise-的实例"><a href="#Promise-的实例" class="headerlink" title="Promise 的实例"></a>Promise 的实例</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.33.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Ajax-操作"><a href="#Ajax-操作" class="headerlink" title="Ajax 操作"></a>Ajax 操作</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p><p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的</p><p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p><p>是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p><p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%886.42.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p><h2 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h2><p>进入严格模式的标志，是一行字符串use strict。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%886.43.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p><p>严格模式可以用于整个脚本，也可以只用于单个函数。</p><h3 id="整个脚本文件"><a href="#整个脚本文件" class="headerlink" title="整个脚本文件"></a>整个脚本文件</h3><p>use strict放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。</p><h3 id="单个函数"><a href="#单个函数" class="headerlink" title="单个函数"></a>单个函数</h3><p>use strict放在函数体的第一行，则整个函数以严格模式运行。</p><p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p><h2 id="显式报错"><a href="#显式报错" class="headerlink" title="显式报错"></a>显式报错</h2><p>严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。</p><h3 id="只读属性不可写"><a href="#只读属性不可写" class="headerlink" title="只读属性不可写"></a>只读属性不可写</h3><p>严格模式下，设置字符串的length属性，会报错。正常模式下，改变length属性是无效的，但不会报错。</p><p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p><h3 id="只设置了取值器的属性不可写"><a href="#只设置了取值器的属性不可写" class="headerlink" title="只设置了取值器的属性不可写"></a>只设置了取值器的属性不可写</h3><p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p><h3 id="禁止扩展的对象不可扩展"><a href="#禁止扩展的对象不可扩展" class="headerlink" title="禁止扩展的对象不可扩展"></a>禁止扩展的对象不可扩展</h3><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p><h3 id="eval、arguments-不可用作标识名"><a href="#eval、arguments-不可用作标识名" class="headerlink" title="eval、arguments 不可用作标识名"></a>eval、arguments 不可用作标识名</h3><p>严格模式下，使用eval或者arguments作为标识名，将会报错。下面的语句都会报错。</p><h3 id="函数不能有重名的参数"><a href="#函数不能有重名的参数" class="headerlink" title="函数不能有重名的参数"></a>函数不能有重名的参数</h3><p>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。</p><h3 id="禁止八进制的前缀0表示法"><a href="#禁止八进制的前缀0表示法" class="headerlink" title="禁止八进制的前缀0表示法"></a>禁止八进制的前缀0表示法</h3><p>正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。</p><h2 id="增强的安全措施"><a href="#增强的安全措施" class="headerlink" title="增强的安全措施"></a>增强的安全措施</h2><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。</p><h3 id="全局变量显式声明"><a href="#全局变量显式声明" class="headerlink" title="全局变量显式声明"></a>全局变量显式声明</h3><p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p><p>因此，严格模式下，变量都必须先声明，然后再使用。</p><h3 id="禁止-this-关键字指向全局对象"><a href="#禁止-this-关键字指向全局对象" class="headerlink" title="禁止 this 关键字指向全局对象"></a>禁止 this 关键字指向全局对象</h3><p>正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p><p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加new，这时this不再指向全局对象，而是报错。</p><h3 id="禁止使用-fn-callee、fn-caller"><a href="#禁止使用-fn-callee、fn-caller" class="headerlink" title="禁止使用 fn.callee、fn.caller"></a>禁止使用 fn.callee、fn.caller</h3><p>函数内部不得使用fn.caller、fn.arguments，否则会报错。这意味着不能在函数内部得到调用栈了。</p><h3 id="禁止使用-arguments-callee、arguments-caller"><a href="#禁止使用-arguments-callee、arguments-caller" class="headerlink" title="禁止使用 arguments.callee、arguments.caller"></a>禁止使用 arguments.callee、arguments.caller</h3><p>arguments.callee和arguments.caller是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用arguments.callee、arguments.caller将会报错。</p><h3 id="禁止删除变量"><a href="#禁止删除变量" class="headerlink" title="禁止删除变量"></a>禁止删除变量</h3><p>严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。</p><h2 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h2><p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p><p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p><h3 id="禁止使用-with-语句"><a href="#禁止使用-with-语句" class="headerlink" title="禁止使用 with 语句"></a>禁止使用 with 语句</h3><p>严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p><h3 id="创设-eval-作用域"><a href="#创设-eval-作用域" class="headerlink" title="创设 eval 作用域"></a>创设 eval 作用域</h3><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。</p><p>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。</p><h3 id="arguments-不再追踪参数的变化"><a href="#arguments-不再追踪参数的变化" class="headerlink" title="arguments 不再追踪参数的变化"></a>arguments 不再追踪参数的变化</h3><p>变量arguments代表函数的参数。严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系。</p><h2 id="向下一个版本的-JavaScript-过渡"><a href="#向下一个版本的-JavaScript-过渡" class="headerlink" title="向下一个版本的 JavaScript 过渡"></a>向下一个版本的 JavaScript 过渡</h2><p>JavaScript语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p><h3 id="非函数代码块不得声明函数"><a href="#非函数代码块不得声明函数" class="headerlink" title="非函数代码块不得声明函数"></a>非函数代码块不得声明函数</h3><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。</p><p>ES6 允许在代码块之中声明函数。</p><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异步操作概述&quot;&gt;&lt;a href=&quot;#异步操作概述&quot; class=&quot;headerlink&quot; title=&quot;异步操作概述&quot;&gt;&lt;/a&gt;异步操作概述&lt;/h1&gt;&lt;h2 id=&quot;单线程模型&quot;&gt;&lt;a href=&quot;#单线程模型&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title> JavaScript标准参考教程 面向对象编程</title>
    <link href="https://github.com/zdkswd/2018/08/19/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/08/19/JavaScript标准参考教程 面向对象编程/</id>
    <published>2018-08-19T15:33:56.000Z</published>
    <updated>2018-08-19T15:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数与-new-命令"><a href="#构造函数与-new-命令" class="headerlink" title="构造函数与 new 命令"></a>构造函数与 new 命令</h1><p>JavaScript 语言具有很强的面向对象编程能力。</p><h2 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h2><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p><p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p><p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p><p>为了与普通函数区别，构造函数名字的第一个字母通常大写。</p><p>构造函数的特点有两个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.13.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>new命令的作用，就是执行构造函数，返回一个实例对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.14.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用new命令时，根据需要，构造函数也可以接受参数。</p><p>new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p><p>如果忘了使用new命令，构造函数就变成了普通函数，并不会生成实例对象。this这时代表全局对象，将造成一些意想不到的结果。</p><p>因此，应该非常小心，避免不使用new命令、直接调用构造函数。</p><p>为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.18.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。</p><p>不管加不加new命令，都会得到同样的结果。</p><h3 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h3><p>使用new命令时，它后面的函数依次执行下面的步骤。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.19.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。</p><p>如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。这一点需要特别引起<strong>注意</strong>。</p><p>另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。</p><p>使用这个属性，可以判断函数调用的时候，是否使用new命令。</p><h2 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h2><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。</p><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><h2 id="涵义"><a href="#涵义" class="headerlink" title="涵义"></a>涵义</h2><p>this都有一个共同点：它总是返回一个对象。</p><p>简单说，this就是属性或方法“当前”所在的对象。</p><p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。</p><p>总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。</p><h2 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h2><h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>全局环境使用this，它指的就是顶层对象window。</p><p>不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。</p><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数中的this，指的是实例对象。</p><h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</p><p>如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.20.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b。</p><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><h3 id="避免多层-this"><a href="#避免多层-this" class="headerlink" title="避免多层 this"></a>避免多层 this</h3><p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。内层的this直接指向顶层对象<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.10.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>因为实际执行的是下面的代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.34.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.09.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。</p><h3 id="避免数组处理方法中的-this"><a href="#避免数组处理方法中的-this" class="headerlink" title="避免数组处理方法中的 this"></a>避免数组处理方法中的 this</h3><p>数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.37.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最主要的问题就是函数表达式的出现，此时变成了全局环境。</span><br></pre></td></tr></table></figure><p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。</p><p>另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</p><h3 id="避免回调函数中的-this"><a href="#避免回调函数中的-this" class="headerlink" title="避免回调函数中的 this"></a>避免回调函数中的 this</h3><p>回调函数中的this往往会改变指向，最好避免使用。</p><h2 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定this的方法</h2><p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p><h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.23.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.24.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。</p><p>call方法还可以接受多个参数。</p><p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p><p><strong>call方法的一个应用是调用对象的原生方法。</strong></p><p>继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.29.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p><p>apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.31.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>利用这一点，可以做一些有趣的应用。</p><h4 id="找出数组最大元素"><a href="#找出数组最大元素" class="headerlink" title="找出数组最大元素"></a>找出数组最大元素</h4><p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p><h4 id="将数组的空元素变为undefined"><a href="#将数组的空元素变为undefined" class="headerlink" title="将数组的空元素变为undefined"></a>将数组的空元素变为undefined</h4><p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p><p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。</p><h4 id="转换类似数组的对象"><a href="#转换类似数组的对象" class="headerlink" title="转换类似数组的对象"></a>转换类似数组的对象</h4><p>另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p><h4 id="绑定回调函数的对象"><a href="#绑定回调函数的对象" class="headerlink" title="绑定回调函数的对象"></a>绑定回调函数的对象</h4><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</p><p>bind还可以接受更多的参数，将这些参数绑定原函数的参数。</p><p>bind还可以接受更多的参数，将这些参数绑定原函数的参数。</p><p>bind方法有一些使用注意点。</p><h4 id="每一次返回一个新函数"><a href="#每一次返回一个新函数" class="headerlink" title="每一次返回一个新函数"></a>每一次返回一个新函数</h4><p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。</p><h4 id="结合回调函数使用"><a href="#结合回调函数使用" class="headerlink" title="结合回调函数使用"></a>结合回调函数使用</h4><p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。</p><h4 id="结合call方法使用"><a href="#结合call方法使用" class="headerlink" title="结合call方法使用"></a>结合call方法使用</h4><h1 id="prototype-对象"><a href="#prototype-对象" class="headerlink" title="prototype 对象"></a>prototype 对象</h1><p>面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。</p><p>大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。JavaScript 语言的继承则是通过“原型对象”（prototype）。</p><h2 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h2><h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8812.28.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。</p><p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p><h3 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h3><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p><p>JavaScript 规定，每个<strong>函数</strong>都有一个prototype属性，指向一个对象。</p><p>对于普通函数来说，该属性基本无用。但是，对于<strong>构造函数</strong>来说，生成实例的时候，<strong>该属性会自动成为类类。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类类是自创的概念，类似于类的东西，即指不管实例对象是否存在，它都客观存在的实例对象的原型。</span><br></pre></td></tr></table></figure></p><p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</p><p>当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p><p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p><p>原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。</p><p>那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。</p><p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p><p><strong>注意</strong>，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。</p><p>由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。</p><p>constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p><p>constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%881.12.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>构造函数Person的原型对象改掉了，但是没有修改constructor属性，导致这个属性不再指向Person。由于Person的新原型是一个普通对象，而普通对象的contructor属性指向Object构造函数，导致Person.prototype.constructor变成了Object。</p><p>修改原型对象时，一般要同时修改constructor属性的指向。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%881.12.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法。</p><p>如果不能确定constructor属性是什么函数，还有一个办法：通过name属性，从实例得到构造函数的名称。</p><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p><p>instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。</p><p>只要一个对象的原型不是null，instanceof运算符的判断就不会失真。</p><p>instanceof运算符的一个用处，是判断值的类型。</p><p><strong>注意</strong>，instanceof运算符只能用于对象，不适用原始类型的值。</p><p>对于undefined和null，instanceOf运算符总是返回false。</p><p>利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%882.49.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h1><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.59.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.07.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><p>Object.setPrototypeOf方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p><p>new命令可以使用Object.setPrototypeOf方法模拟。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.15.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>new命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的prototype属性（上例是F.prototype）；第二步，将构造函数内部的this绑定这个空对象，然后执行构造函数，使得定义在this上面的方法和属性（上例是this.foo），都转移到这个空对象上。</p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>JavaScript 提供了Object.create方法，该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p><p>下面三种方式生成的新对象是等价的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.29.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。</p><p>使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p><p>Object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p><p>除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Object.create方法生成的对象，继承了它的原型对象的构造函数。</p><h2 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h2><p>实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。</p><p>只要实例对象处在参数对象的原型链上，isPrototypeOf方法都返回true。</p><h2 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.proto"></a>Object.prototype.<strong>proto</strong></h2><p>实例对象的<strong>proto</strong>属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p><p>根据语言标准，<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()和Object.setPrototypeOf()，进行原型对象的读写操作。</p><h2 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h2><p>获取实例对象obj的原型对象，有三种方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.48.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>前两种都不是很可靠。<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。</p><p>推荐使用第三种Object.getPrototypeOf方法，获取原型对象。</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>Object.getOwnPropertyNames方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p><p>Object.getOwnPropertyNames方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用Object.keys方法。</p><h2 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h2><p>对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p><p><strong>注意</strong>，hasOwnProperty方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p><h2 id="in-运算符和-for…in-循环"><a href="#in-运算符和-for…in-循环" class="headerlink" title="in 运算符和 for…in 循环"></a>in 运算符和 for…in 循环</h2><p>in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</p><p>in运算符常用于检查一个属性是否存在。</p><p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for…in循环。</p><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>如果要拷贝一个对象，需要做到下面两件事情。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%884.08.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="面向对象编程的模式"><a href="#面向对象编程的模式" class="headerlink" title="面向对象编程的模式"></a>面向对象编程的模式</h1><h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>让一个构造函数继承另一个构造函数，是非常常见的需求。</p><p>这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.41.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> JavaScript 中对象的赋值是默认引用赋值的，如果你想要复制赋值，则必须要重新分配对象</span><br></pre></td></tr></table></figure><p>另外一种写法是Sub.prototype等于一个父类实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.50.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p><p>有时只需要单个方法的继承，这时可以采用下面的写法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.51.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面代码中，子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.52.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种模式又称为 Mixin（混入）。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>JavaScript不是一种模块化编程语言，ES5不支持”类”（class），更遑论”模块”（module）了。ES6正式支持”类”和”模块”，但还没有成为主流。</p><h3 id="基本的实现方法"><a href="#基本的实现方法" class="headerlink" title="基本的实现方法"></a>基本的实现方法</h3><p>模块是实现特定功能的一组属性和方法的封装。</p><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p><p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p><p>上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。</p><p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p><h3 id="封装私有变量：构造函数的写法"><a href="#封装私有变量：构造函数的写法" class="headerlink" title="封装私有变量：构造函数的写法"></a>封装私有变量：构造函数的写法</h3><p>我们可以利用构造函数，封装私有变量。</p><p>这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。</p><h3 id="封装私有变量：立即执行函数的写法"><a href="#封装私有变量：立即执行函数的写法" class="headerlink" title="封装私有变量：立即执行函数的写法"></a>封装私有变量：立即执行函数的写法</h3><p>使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.03.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面的module1就是JavaScript模块的基本写法。下面，再对这种写法进行加工。</p><h3 id="模块的放大模式"><a href="#模块的放大模式" class="headerlink" title="模块的放大模式"></a>模块的放大模式</h3><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.28.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.29.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p><h3 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h3><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.30.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数与-new-命令&quot;&gt;&lt;a href=&quot;#构造函数与-new-命令&quot; class=&quot;headerlink&quot; title=&quot;构造函数与 new 命令&quot;&gt;&lt;/a&gt;构造函数与 new 命令&lt;/h1&gt;&lt;p&gt;JavaScript 语言具有很强的面向对象编程能力。&lt;/p
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 标准参考教程 标准库 下</title>
    <link href="https://github.com/zdkswd/2018/08/17/JavaScript%20%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E6%A0%87%E5%87%86%E5%BA%93%20%E4%B8%8B/"/>
    <id>https://github.com/zdkswd/2018/08/17/JavaScript 标准参考教程 标准库 下/</id>
    <published>2018-08-17T04:03:56.000Z</published>
    <updated>2018-09-01T03:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p><p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.52.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>另一种是使用RegExp构造函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.52.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p><p>RegExp构造函数还可以接受第二个参数，表示修饰符。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>正则对象的实例属性分成两类。</p><p>一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.14.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>三个属性都是只读的。</p><p>另一类是与修饰符无关的属性，主要是下面两个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.15.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h3><p>正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p><p>如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。</p><p>带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。</p><p>lastIndex属性只对同一个正则表达式有效。</p><p>如果正则模式是一个空字符串，则匹配所有字符串。</p><h3 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h3><p>正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。</p><p>exec方法的返回数组还包含以下两个属性：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.26.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p><p>正则实例对象的lastIndex属性不仅可读，还可写。设置了g修饰符的时候，只要手动设置了lastIndex的值，就会从指定位置开始匹配。</p><h2 id="字符串的实例方法"><a href="#字符串的实例方法" class="headerlink" title="字符串的实例方法"></a>字符串的实例方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.28.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p>字符串实例对象的match方法对字符串进行正则匹配，返回匹配结果。</p><p>字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。</p><p>如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。</p><p>设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。</p><p>设置正则对象的lastIndex属性是无效的。</p><h3 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h3><p>字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。</p><h3 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h3><p>字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p><p>正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p><p>replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.34.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p><h3 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p>字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p><p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p><p>正则默认是贪婪匹配。</p><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><h3 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h3><p>如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。</p><p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p><h4 id="点字符（-）"><a href="#点字符（-）" class="headerlink" title="点字符（.）"></a>点字符（.）</h4><p>点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。注意，对于码点大于0xFFFF的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。</p><h4 id="位置字符"><a href="#位置字符" class="headerlink" title="位置字符"></a>位置字符</h4><p>位置字符用来提示字符所处的位置，主要有两个字符。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.40.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="选择符（-）"><a href="#选择符（-）" class="headerlink" title="选择符（|）"></a>选择符（|）</h4><p>竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。</p><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成\ +。</p><p>正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.43.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</p><h4 id="脱字符（-）"><a href="#脱字符（-）" class="headerlink" title="脱字符（ ^ ）"></a>脱字符（ ^ ）</h4><p>如果方括号内的第一个字符是[^ ]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^ xyz]表示除了x、y、z之外都可以匹配。</p><p>如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</p><p><strong>注意</strong>，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p><h4 id="连字符（-）"><a href="#连字符（-）" class="headerlink" title="连字符（-）"></a>连字符（-）</h4><p>某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。</p><p>[1-31]，不代表1到31，只代表1到3。</p><p>连字符还可以用来指定 Unicode 字符的范围。</p><h3 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.51.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h3><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p><h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><p>量词符用来设定某个模式出现的次数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.53.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p><p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p><p>模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p><p>修饰符可以单个使用，也可以多个一起使用。</p><h4 id="g-修饰符"><a href="#g-修饰符" class="headerlink" title="g 修饰符"></a>g 修饰符</h4><p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p><h4 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h4><p>默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。</p><p>m修饰符表示多行模式（multiline），会修改\^和\$的行为。默认情况下（即不加m修饰符时），\^<br>和\$匹配字符串的开始处和结尾处，加上m修饰符以后，\^和\$还会匹配行首和行尾，即\^和\$会识别换行符（\n）。</p><h3 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p><p>注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。</p><p>这时必须使用正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获。</p><p>正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。</p><h4 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h4><p>(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8811.51.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h4><p>x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。</p><h4 id="先行否定断言"><a href="#先行否定断言" class="headerlink" title="先行否定断言"></a>先行否定断言</h4><p>x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。</p><h1 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h1><h2 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h2><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式。</p><p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p><p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。</p><p>JSON 对值的类型和格式有严格的规定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.02.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</p><p><strong>注意</strong>，对于原始类型的字符串，转换结果会带双引号。</p><p>如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。</p><p>如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。</p><p>正则对象会被转成空对象。</p><p>JSON.stringify方法会忽略对象的不可遍历属性。</p><h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p>JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</p><p>这个类似白名单的数组，只对对象的属性有效，对数组无效。</p><p>第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。</p><p>f函数，接受两个参数，分别是被转换的对象的键名和键值。</p><p>这个处理函数是递归处理所有的键。</p><h3 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h3><p>JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</p><h3 id="参数对象的-toJSON-方法"><a href="#参数对象的-toJSON-方法" class="headerlink" title="参数对象的 toJSON 方法"></a>参数对象的 toJSON 方法</h3><p>如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p><h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>JSON.parse方法用于将 JSON 字符串转换成对应的值。</p><p>如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。</p><p>单引号字符串不符合 JSON 格式，会报错。</p><p>为了处理解析错误，可以将JSON.parse方法放在try…catch代码块中。</p><p>JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。</p><h1 id="console对象"><a href="#console对象" class="headerlink" title="console对象"></a>console对象</h1><p>console对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p><p>console的常见用途有两个。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.24.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="浏览器实现"><a href="#浏览器实现" class="headerlink" title="浏览器实现"></a>浏览器实现</h2><p>可以使用下面三种方法的打开它。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.27.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>面板。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.29.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Console面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。</p><h2 id="console-对象的静态方法"><a href="#console-对象的静态方法" class="headerlink" title="console 对象的静态方法"></a>console 对象的静态方法</h2><p>console对象提供的各种静态方法，用来与控制台窗口互动。</p><h3 id="console-log-，console-info-，console-debug"><a href="#console-log-，console-info-，console-debug" class="headerlink" title="console.log()，console.info()，console.debug()"></a>console.log()，console.info()，console.debug()</h3><p>console.log方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p><p>console.log方法会自动在每次输出的结尾，添加换行符。</p><p>如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</p><p>不同类型的数据必须使用对应的占位符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.30.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>console.info是console.log方法的别名，用法完全一样。只不过console.info方法会在输出信息的前面，加上一个蓝色图标。</p><p>console.debug方法与console.log方法类似，会在控制台输出调试信息。但是，默认情况下，console.debug输出的信息不会显示，只有在打开显示级别在verbose的情况下，才会显示。</p><p>console对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。</p><h3 id="console-warn-，console-error"><a href="#console-warn-，console-error" class="headerlink" title="console.warn()，console.error()"></a>console.warn()，console.error()</h3><p>warn方法和error方法也是在控制台输出信息，它们与log方法的不同之处在于，warn方法输出信息时，在最前面加一个黄色三角，表示警告；error方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>对于某些复合类型的数据，console.table方法可以将其转为表格显示。</p><h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p>count方法用于计数，输出它被调用了多少次。</p><p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p><h3 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h3><p>dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p><p>dir方法的输出结果，比log方法更易读，信息也更丰富。</p><p>对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p><p>Node 环境之中，还可以指定以代码高亮的形式输出。</p><p>dirxml方法主要用于以目录树的形式，显示 DOM 节点。</p><p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。</p><h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><p>console.assert方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p><p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p><h3 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p><p>time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p><h3 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p>console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p><p>console.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p><h3 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h3><p>console.trace方法显示当前执行的代码在堆栈中的调用路径。</p><p>console.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，console.clear方法将不起作用。</p><h2 id="命令行API"><a href="#命令行API" class="headerlink" title="命令行API"></a>命令行API</h2><p>浏览器控制台中，除了使用console对象，还可以使用一些控制台自带的命令行方法。</p><h3 id=""><a href="#" class="headerlink" title="$_"></a>$_</h3><p>$_属性返回上一个表达式的值。</p><h3 id="0-4"><a href="#0-4" class="headerlink" title="\$0 - \$4"></a>\$0 - \$4</h3><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，\$0代表倒数第一个（最近一个），\$1代表倒数第二个，以此类推直到\$4。</p><h3 id="selector"><a href="#selector" class="headerlink" title="$(selector)"></a>$(selector)</h3><p>\$(selector)返回第一个匹配的元素，等同于document.querySelector()。注意，如果页面脚本对\$有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行\$(selector)就会采用 jQuery 的实现，返回一个数组。</p><h3 id="selector-1"><a href="#selector-1" class="headerlink" title="$$(selector)"></a>$$(selector)</h3><p>$$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。</p><h3 id="x-path"><a href="#x-path" class="headerlink" title="$x(path)"></a>$x(path)</h3><p>$x(path)方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p><h3 id="inspect-object"><a href="#inspect-object" class="headerlink" title="inspect(object)"></a>inspect(object)</h3><p>inspect(object)方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在Elements面板中显示，比如inspect(document)会在 Elements 面板显示document元素。JavaScript 对象在控制台面板Profiles面板中显示，比如inspect(window)。</p><h3 id="getEventListeners-object"><a href="#getEventListeners-object" class="headerlink" title="getEventListeners(object)"></a>getEventListeners(object)</h3><p>getEventListeners(object)方法返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。</p><h3 id="keys-object-，values-object"><a href="#keys-object-，values-object" class="headerlink" title="keys(object)，values(object)"></a>keys(object)，values(object)</h3><p>keys(object)方法返回一个数组，包含object的所有键名。<br>values(object)方法返回一个数组，包含object的所有键值。</p><h3 id="monitorEvents-object-events-，unmonitorEvents-object-events"><a href="#monitorEvents-object-events-，unmonitorEvents-object-events" class="headerlink" title="monitorEvents(object[, events]) ，unmonitorEvents(object[, events])"></a>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</h3><p>monitorEvents(object[, events])方法监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息。unmonitorEvents方法用于停止监听。</p><p>monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%884.52.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>命令行 API 还提供以下方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%884.53.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h2><p>debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p><p>Chrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%884.54.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p><p>属性描述对象提供6个元属性。</p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>value是该属性的属性值，默认为undefined。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。</p><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for…in循环、Object.keys()，JSON.stringify方法）跳过该属性。</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get是一个函数，表示该属性的取值函数（getter），默认为undefined。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set是一个函数，表示该属性的存值函数（setter），默认为undefined。</p><h2 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h2><p>Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。</p><p><strong>注意</strong>，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p><p>这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。</p><h2 id="Object-defineProperty-，Object-defineProperties"><a href="#Object-defineProperty-，Object-defineProperties" class="headerlink" title="Object.defineProperty()，Object.defineProperties()"></a>Object.defineProperty()，Object.defineProperties()</h2><p>Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%889.34.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Object.defineProperty方法接受三个参数，依次如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%889.34.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%889.37.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。</p><p>Object.defineProperty()和Object.defineProperties()的第三个参数，是一个属性对象。它的writable、configurable、enumerable这三个属性的默认值都为false。</p><h2 id="Object-prototype-propertyIsEnumerable"><a href="#Object-prototype-propertyIsEnumerable" class="headerlink" title="Object.prototype.propertyIsEnumerable()"></a>Object.prototype.propertyIsEnumerable()</h2><p>实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。</p><h2 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h2><p>属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。</p><h3 id="value-1"><a href="#value-1" class="headerlink" title="value"></a>value</h3><p>value属性是目标属性的值。</p><h3 id="writable-1"><a href="#writable-1" class="headerlink" title="writable"></a>writable</h3><h3 id="enumerable-1"><a href="#enumerable-1" class="headerlink" title="enumerable"></a>enumerable</h3><h3 id="configurable-1"><a href="#configurable-1" class="headerlink" title="configurable"></a>configurable</h3><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。</p><p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。</p><p>存取器往往用于，属性的值依赖对象内部数据的场合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.20.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>next属性的存值函数和取值函数，都依赖于内部属性$n。</p><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象。</p><p>可以通过Object.defineProperty方法来拷贝属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.23.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>hasOwnProperty那一行用来过滤掉继承的属性，否则会报错，因为Object.getOwnPropertyDescriptor读不到继承属性的属性描述对象。</p><h2 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h2><p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。</p><h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><p>Object.preventExtensions方法可以使得一个对象无法再添加新的属性。</p><h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h3><p>Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。</p><h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><p>Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。</p><p>Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。</p><p>Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.29.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed()"></a>Object.isSealed()</h3><p>Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。</p><p>这时，Object.isExtensible方法也返回false。</p><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p>Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p><p>这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。</p><h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h3><p>Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。</p><p>使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。</p><p>一种解决方案是，把obj的原型也冻结住。</p><p>另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p><p>obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RegExp对象&quot;&gt;&lt;a href=&quot;#RegExp对象&quot; class=&quot;headerlink&quot; title=&quot;RegExp对象&quot;&gt;&lt;/a&gt;RegExp对象&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 标准参考教程 标准库 上</title>
    <link href="https://github.com/zdkswd/2018/08/17/JavaScript%20%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E6%A0%87%E5%87%86%E5%BA%93%20%E4%B8%8A/"/>
    <id>https://github.com/zdkswd/2018/08/17/JavaScript 标准参考教程 标准库 上/</id>
    <published>2018-08-17T04:02:56.000Z</published>
    <updated>2018-09-01T03:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 原生提供Object对象（注意起首的O是大写）。</p><p>JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。</p><p>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。</p><h3 id="Object对象本身的方法"><a href="#Object对象本身的方法" class="headerlink" title="Object对象本身的方法"></a>Object对象本身的方法</h3><h3 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h3><h2 id="Object（）"><a href="#Object（）" class="headerlink" title="Object（）"></a>Object（）</h2><p>Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p><p>如果参数为空（或者为undefined和null），Object()返回一个空对象。</p><p>instanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例。</p><p>如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例。</p><p>如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。</p><p>利用这一点，可以写一个判断变量是否为对象的函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.50.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Object构造函数"><a href="#Object构造函数" class="headerlink" title="Object构造函数"></a>Object构造函数</h2><p>Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。</p><p>Object构造函数的首要用途，是直接通过它来生成新对象。</p><p>注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。或者说，后者只是前者的一种简便写法。</p><h2 id="Object的静态方法"><a href="#Object的静态方法" class="headerlink" title="Object的静态方法"></a>Object的静态方法</h2><p>所谓“静态方法”，是指部署在Object对象自身的方法。</p><h3 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h3><p>Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。</p><p>Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。</p><p>对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。</p><p>由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="对象属性模型的相关方法"><a href="#对象属性模型的相关方法" class="headerlink" title="对象属性模型的相关方法"></a>对象属性模型的相关方法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.54.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="控制对象状态的方法"><a href="#控制对象状态的方法" class="headerlink" title="控制对象状态的方法"></a>控制对象状态的方法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.56.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="原型链相关方法"><a href="#原型链相关方法" class="headerlink" title="原型链相关方法"></a>原型链相关方法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.56.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Object的实例方法-1"><a href="#Object的实例方法-1" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h2><p>除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。</p><p>Object实例对象的方法，主要有以下六个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.02.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p>valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p><p>valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.05.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p>toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</p><p>通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p><p>数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。覆盖原始方法。</p><h3 id="toString-的应用：判断数据类型"><a href="#toString-的应用：判断数据类型" class="headerlink" title="toString() 的应用：判断数据类型"></a>toString() 的应用：判断数据类型</h3><p>Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p><p>由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.12.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不同数据类型的Object.prototype.toString方法返回值如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.13.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。</p><h3 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h3><p>Object.prototype.toLocaleString方法与toString的返回结果相同，也是返回一个值的字符串形式。</p><p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.21.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>举例来说，日期的实例对象的toString和toLocaleString返回值就不一样，而且toLocaleString的返回值跟用户设定的所在地域相关。</p><h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。而不显示继承而来的属性。</p><h1 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p><p>Array构造函数的参数2，表示生成一个两个成员的数组，每个位置都是空值。</p><p>如果没有使用new，运行结果也是一样的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%8810.41.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%8810.42.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%8810.44.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p>Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。</p><p>typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h3><p>valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。</p><p>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p><h3 id="push-，pop"><a href="#push-，pop" class="headerlink" title="push()，pop()"></a>push()，pop()</h3><p>push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p><p>pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</p><p>对空数组使用pop方法，不会报错，而是返回undefined。</p><h3 id="shift-，unshift"><a href="#shift-，unshift" class="headerlink" title="shift()，unshift()"></a>shift()，unshift()</h3><p>shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p><p>shift方法可以遍历并清空一个数组。</p><p>push和shift结合使用，就构成了“先进先出”的队列结构（queue）。</p><p>unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p><p>unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。</p><h3 id="join（）"><a href="#join（）" class="headerlink" title="join（）"></a>join（）</h3><p>join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p><p>如果数组成员是undefined或null或空位，会被转成空字符串。</p><p>通过call方法，这个方法也可以用于字符串或类似数组的对象。</p><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p><p>除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。</p><p>如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</p><p>它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p><p>如果slice方法的参数是负数，则表示倒数计算的位置。</p><p>slice没有参数，实际上等于返回一个原数组的拷贝。</p><p>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。</p><p>slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%882.32.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>起始位置如果是负数，就表示从倒数位置开始删除。</p><p>如果只是单纯地插入元素，splice方法的第二个参数可以设为0。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p><p>sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。</p><p>如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%882.36.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个<strong>新数组</strong>返回。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%882.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。</p><p>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量。</p><p>如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。</p><p>map方法不会跳过undefined和null，但是会跳过空位。</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法<strong>不返回值，只用来操作数据</strong>。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。</p><p>forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</p><p>forEach方法也可以接受第二个参数，绑定参数函数的this变量。</p><p>forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。</p><p>forEach方法也会跳过数组的空位。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p><p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法<strong>不会改变原数组</strong>。</p><p>filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</p><p>filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</p><h3 id="some-，every"><a href="#some-，every" class="headerlink" title="some()，every()"></a>some()，every()</h3><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p><p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p><p>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</p><p>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</p><p>注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。</p><p>some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</p><h3 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h3><p>reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p><p>reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.03.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p><p>如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。</p><p>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。</p><h3 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h3><p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p><p>indexOf方法还可以接受第二个参数，表示搜索的开始位置。</p><p>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p><p><strong>注意</strong>，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。</p><p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</p><h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p><p>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.25.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。</p><p><strong>Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。</strong></p><p>即，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</p><h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><p>包装对象的实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。</p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p>valueOf方法返回包装对象实例对应的原始类型的值。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>toString方法返回对应的字符串形式。</p><h2 id="原始类型与实例对象的自动转换"><a href="#原始类型与实例对象的自动转换" class="headerlink" title="原始类型与实例对象的自动转换"></a>原始类型与实例对象的自动转换</h2><p>原始类型的值，可以自动当作包装对象调用，即调用各种包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。</p><p>比如，字符串可以调用length属性，返回字符串的长度。</p><p>abc是一个字符串，本身不是对象，不能调用length属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p><p>自动转换生成的包装对象是<strong>只读</strong>的，无法修改。所以，字符串无法添加新属性。</p><p>调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。</p><h2 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>三种包装对象除了提供很多原生的实例方法，还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。</p><p>这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。</p><h2 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。</p><h3 id="Boolean-函数的类型转换作用"><a href="#Boolean-函数的类型转换作用" class="headerlink" title="Boolean 函数的类型转换作用"></a>Boolean 函数的类型转换作用</h3><p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。</p><h1 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p><p>作为构造函数时，它用于生成值为数值的对象。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.44.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实例方法-2"><a href="#实例方法-2" class="headerlink" title="实例方法"></a>实例方法</h2><p>Number对象有4个实例方法，都跟将数值转换成指定格式有关。</p><h3 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h3><p>Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。</p><p>toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.46.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。</p><p>除了为10加上括号，还可以在10后面加两个点，JavaScript 会把第一个点理解成小数点（即10.0），把第二个点理解成调用对象属性，从而得到正确结果。</p><p>意味着，可以直接对一个小数使用toString方法。</p><p>通过方括号运算符也可以调用toString方法。</p><p>toString方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用parseInt方法。</p><h3 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h3><p>toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p><h3 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h3><p>toExponential方法用于将一个数转为科学计数法形式。</p><p>toExponential方法的参数是小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个 RangeError 错误。</p><h3 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h3><p>toPrecision方法用于将一个数转为指定位数的有效数字。</p><p>toPrecision方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出 RangeError 错误。</p><p>toPrecision方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p><h2 id="自定义方法-1"><a href="#自定义方法-1" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。 </p><p>注意，数值的自定义方法，只能定义在它的原型对象Number.prototype上面，数值本身是无法自定义属性的。</p><h1 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p><p>字符串对象是一个类似数组的对象（很像数组，但不是数组）。</p><p>String对象还可以当作工具方法使用，将任意类型的值转为字符串。</p><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h3><p>该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p><p>String.fromCharCode方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。</p><p><strong>注意</strong>，该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）。</p><p>String.fromCharCode发现参数值大于0xFFFF，就会忽略多出的位（即忽略0x20BB7里面的2）。</p><p>码点大于0xFFFF的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把0x20BB7拆成两个字符表示。</p><p>码点大于0xFFFF的字符的四字节表示法，由 UTF-16 编码方法决定。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="String-prototype-length"><a href="#String-prototype-length" class="headerlink" title="String.prototype.length"></a>String.prototype.length</h3><p>字符串实例的length属性返回字符串的长度。</p><h2 id="实例方法-3"><a href="#实例方法-3" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="String-prototype-charAt"><a href="#String-prototype-charAt" class="headerlink" title="String.prototype.charAt()"></a>String.prototype.charAt()</h3><p>charAt方法返回指定位置的字符，参数是从0开始编号的位置。</p><p>如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。</p><h3 id="String-prototype-charCodeAt"><a href="#String-prototype-charCodeAt" class="headerlink" title="String.prototype.charCodeAt()"></a>String.prototype.charCodeAt()</h3><p>charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。</p><p>如果没有任何参数，charCodeAt返回首字符的 Unicode 码点。</p><p>如果参数为负数，或大于等于字符串的长度，charCodeAt返回NaN。</p><p>charCodeAt方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必需连续使用两次charCodeAt，不仅读入charCodeAt(i)，还要读入charCodeAt(i+1)，将两个值放在一起，才能得到准确的字符。</p><h3 id="String-prototype-concat"><a href="#String-prototype-concat" class="headerlink" title="String.prototype.concat()"></a>String.prototype.concat()</h3><p>concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p><p>如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%884.26.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h3><p>slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p><p>如果省略第二个参数，则表示子字符串一直到原字符串结束。</p><p>如果参数是负值，表示从结尾开始倒数计算的位置。</p><p>如果第一个参数大于第二个参数，slice方法返回一个空字符串。</p><h3 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h3><p>substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</p><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p><p>如果第一个参数大于第二个参数，substring方法会自动更换两个参数的位置。</p><p>如果参数是负数，substring方法会自动将负数转为0。</p><p>由于这些规则违反直觉，因此不建议使用substring方法，应该优先使用slice。</p><h3 id="String-prototype-substr"><a href="#String-prototype-substr" class="headerlink" title="String.prototype.substr()"></a>String.prototype.substr()</h3><p>substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。</p><p>substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。</p><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p><p>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</p><h3 id="String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>String.prototype.indexOf()，String.prototype.lastIndexOf()</h3><p>indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p><p>indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。</p><p>lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。</p><p>lastIndexOf的第二个参数表示从该位置起向前匹配。</p><h3 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h3><p>trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p><p>该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。</p><h3 id="String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>String.prototype.toLowerCase()，String.prototype.toUpperCase()</h3><p>toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p><h3 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p>match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</p><p>match方法还可以使用正则表达式作为参数。</p><h3 id="String-prototype-search-，String-prototype-replace"><a href="#String-prototype-search-，String-prototype-replace" class="headerlink" title="String.prototype.search()，String.prototype.replace()"></a>String.prototype.search()，String.prototype.replace()</h3><p>search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</p><p>search方法还可以使用正则表达式作为参数。</p><p>replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配。</p><p>replace方法还可以使用正则表达式作为参数。</p><h3 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p>split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p><p>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</p><p>如果省略参数，则返回数组的唯一成员就是原字符串。</p><p>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。</p><p>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。</p><p>split方法还可以接受第二个参数，限定返回数组的最大成员数。</p><p>split方法还可以使用正则表达式作为参数。</p><h3 id="String-prototype-localeCompare"><a href="#String-prototype-localeCompare" class="headerlink" title="String.prototype.localeCompare()"></a>String.prototype.localeCompare()</h3><p>localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</p><p>该方法的最大特点，就是会<strong>考虑自然语言的顺序</strong>。举例来说，正常情况下，大写的英文字母小于小写字母。</p><p>JavaScript 采用的是 Unicode 码点比较但是，localeCompare方法会考虑自然语言的排序情况，大写字母比小写字母大。</p><p>localeCompare还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</p><h1 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h1><p>Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，<strong>不能生成实例</strong>，所有的属性和方法都必须在Math对象上调用。</p><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.10.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这些属性都是只读的，不能修改。</p><h2 id="静态方法-2"><a href="#静态方法-2" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.11.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。</p><p>Math.floor方法返回小于参数值的最大整数（地板值）。</p><p>Math.ceil方法返回大于参数值的最小整数（天花板值）。</p><p>Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。</p><p>Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。</p><p>如果要计算以10为底的对数，可以先用Math.log求出自然对数，然后除以Math.LN10；求以2为底的对数，可以除以Math.LN2。</p><p>Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p><h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.16.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h1><p>Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p><h2 id="普通函数的用法"><a href="#普通函数的用法" class="headerlink" title="普通函数的用法"></a>普通函数的用法</h2><p>Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</p><p>即使带有参数，Date作为普通函数使用时，返回的还是当前时间。</p><p>无论有没有参数，直接调用Date总是返回当前时间。</p><h2 id="构造函数的用法"><a href="#构造函数的用法" class="headerlink" title="构造函数的用法"></a>构造函数的用法</h2><p>Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。</p><p>Date实例有一个独特的地方。其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。</p><p>作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.48.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>关于Date构造函数的参数，</p><p>第一点，参数可以是负整数，代表1970年元旦之前的时间。</p><p>第二点，只要是能被Date.parse()方法解析的字符串，都可以当作参数。</p><p>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。</p><p>各个参数的取值范围如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.49.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。</p><p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。</p><p>日期设为0，就代表上个月的最后一天。</p><p>参数还可以使用负数，表示扣去的时间。</p><h2 id="日期的运算"><a href="#日期的运算" class="headerlink" title="日期的运算"></a>日期的运算</h2><p>类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。</p><h2 id="静态方法-3"><a href="#静态方法-3" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h3><p>Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p><h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h3><p>Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。</p><p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.55.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果解析失败，返回NaN。</p><h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><p>Date.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</p><p>该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。</p><h2 id="实例方法-4"><a href="#实例方法-4" class="headerlink" title="实例方法"></a>实例方法</h2><p>Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%8810.12.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf()"></a>Date.prototype.valueOf()</h3><p>valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。</p><h3 id="to-类方法"><a href="#to-类方法" class="headerlink" title="to 类方法"></a>to 类方法</h3><h4 id="Date-prototype-toString"><a href="#Date-prototype-toString" class="headerlink" title="Date.prototype.toString()"></a>Date.prototype.toString()</h4><p>toString方法返回一个完整的日期字符串。</p><h4 id="Date-prototype-toUTCString"><a href="#Date-prototype-toUTCString" class="headerlink" title="Date.prototype.toUTCString()"></a>Date.prototype.toUTCString()</h4><p>toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。</p><h4 id="Date-prototype-toISOString"><a href="#Date-prototype-toISOString" class="headerlink" title="Date.prototype.toISOString()"></a>Date.prototype.toISOString()</h4><p>toISOString方法返回对应时间的 ISO8601 写法。</p><p>toISOString方法返回的总是 UTC 时区的时间。</p><h4 id="Date-prototype-toJSON"><a href="#Date-prototype-toJSON" class="headerlink" title="Date.prototype.toJSON()"></a>Date.prototype.toJSON()</h4><p>toJSON方法返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同。</p><h4 id="Date-prototype-toDateString"><a href="#Date-prototype-toDateString" class="headerlink" title="Date.prototype.toDateString()"></a>Date.prototype.toDateString()</h4><p>toDateString方法返回日期字符串（不含小时、分和秒）。</p><h4 id="Date-prototype-toTimeString"><a href="#Date-prototype-toTimeString" class="headerlink" title="Date.prototype.toTimeString()"></a>Date.prototype.toTimeString()</h4><p>toTimeString方法返回时间字符串（不含年月日）。</p><h4 id="Date-prototype-toLocaleDateString"><a href="#Date-prototype-toLocaleDateString" class="headerlink" title="Date.prototype.toLocaleDateString()"></a>Date.prototype.toLocaleDateString()</h4><p>toLocaleDateString方法返回一个字符串，代表日期的当地写法（不含小时、分和秒）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.32.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="get类方法"><a href="#get类方法" class="headerlink" title="get类方法"></a>get类方法</h3><p>Date对象提供了一系列get*方法，用来获取实例对象某个方面的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.39.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所有这些get*方法返回的都是整数，不同方法返回值的范围不一样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.40.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.42.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="set-类方法"><a href="#set-类方法" class="headerlink" title="set 类方法"></a>set 类方法</h3><p>Date对象提供了一系列set*方法，用来设置实例对象的各个方面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.44.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>set*方法的参数都会自动折算。以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p><p>set*系列方法除了setTime()和setYear()，都有对应的 UTC 版本，即设置 UTC 时区的时间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.49.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object对象&quot;&gt;&lt;a href=&quot;#Object对象&quot; class=&quot;headerlink&quot; title=&quot;Object对象&quot;&gt;&lt;/a&gt;Object对象&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 语法 二</title>
    <link href="https://github.com/zdkswd/2018/08/14/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E8%AF%AD%E6%B3%95%20%E4%BA%8C/"/>
    <id>https://github.com/zdkswd/2018/08/14/JavaScript标准参考教程 语法 二/</id>
    <published>2018-08-14T02:36:56.000Z</published>
    <updated>2018-09-01T05:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 有三种声明函数的方法。</p><h3 id="function-命令"><a href="#function-命令" class="headerlink" title="function 命令"></a>function 命令</h3><p>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.15.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>除了用function命令声明函数，还可以采用变量赋值的写法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.16.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这种写法将一个匿名函数赋值给变量。</p><p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体<strong>外部无效</strong>。</p><p>这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。</p><p><strong>注意</strong>，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。</p><h3 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function 构造函数"></a>Function 构造函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.22.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p><p>这种声明函数的方式非常不直观，<strong>几乎无人使用</strong>。</p><h2 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h2><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p><h2 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h2><h2 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h2><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p><p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p><h2 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h2><p>JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.32.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用<strong>赋值语句</strong>定义函数，JavaScript 就会<strong>报错</strong>。</p><h2 id="不能在条件语句中声明函数"><a href="#不能在条件语句中声明函数" class="headerlink" title="不能在条件语句中声明函数"></a>不能在条件语句中声明函数</h2><p>根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。</p><p>但是，实际情况是各家浏览器往往并不报错，能够运行。</p><p>但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。</p><p>要达到在条件语句中定义函数的目的，只有使用函数表达式。</p><h2 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h2><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>函数的name属性返回函数的名字。</p><p>如果是通过变量赋值定义的函数，那么name属性返回变量名。</p><p>只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。</p><p>name属性的一个用处，就是获取参数函数的名字。</p><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p><p>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>函数的toString方法返回一个字符串，内容是函数的源码。</p><p>函数内部的注释也可以返回。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p><p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。</p><p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p><h3 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h3><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p><h3 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h3><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%883.44.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p><h3 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h3><p>函数参数不是必需的，Javascript 允许省略参数。</p><p>运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。</p><p><strong>注意</strong>，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p><h2 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h2><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p><p>如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p><p><strong>注意</strong>，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p><p>重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。</p><h2 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h2><p>如果有同名的参数，则取最后出现的那个值。</p><h2 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h2><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p><p>rguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p><p>正常模式下，arguments对象可以在运行时修改。</p><p>严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。</p><p>通过arguments对象的length属性，可以判断函数调用时到底带几个参数。</p><h3 id="与数组的关系"><a href="#与数组的关系" class="headerlink" title="与数组的关系"></a>与数组的关系</h3><p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</p><h3 id="callee属性"><a href="#callee属性" class="headerlink" title="callee属性"></a>callee属性</h3><p>arguments对象带有一个callee属性，返回它所对应的原函数。</p><p>可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p><h2 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p><p>出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%884.45.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p><p>闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%884.49.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p><p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p><p><strong>注意</strong>，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><h2 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%884.55.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p><h2 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h2><p>eval命令的作用是，将字符串当作语句执行。</p><p>eval的命令字符串不会得到 JavaScript 引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h2><p>JavaScript 允许非数值的相加。如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。</p><p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%885.49.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h2><p>如果运算子是对象，必须先转成原始类型的值，然后再相加。</p><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%885.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>余数运算符运算结果的正负号由第一个运算子的正负号决定。</p><p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%885.56.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p><h3 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h3><p>字符串按照字典顺序进行比较。</p><p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</p><h3 id="非字符串的比较"><a href="#非字符串的比较" class="headerlink" title="非字符串的比较"></a>非字符串的比较</h3><p>两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。</p><p>字符串和布尔值都会先转成数值，再进行比较。</p><p>特殊情况，即任何值（包括NaN本身）与NaN比较，返回的都是false。</p><p><strong>对象</strong></p><h3 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h3><p>JavaScript 提供两种相等运算符：==和===。</p><p>简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p><p>需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。</p><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。使用===</p><p>空对象、空数组、空函数的值，都存放在不同的内存地址。</p><p><strong>注意</strong>，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</p><p><strong>undefined和null</strong><br>undefined和null与自身严格相等。</p><p>由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。</p><h3 id="严格不相等运算符"><a href="#严格不相等运算符" class="headerlink" title="严格不相等运算符"></a>严格不相等运算符</h3><p>严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。</p><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</p><p>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%886.58.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p><p>因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。</p><h3 id="不相等运算符"><a href="#不相等运算符" class="headerlink" title="不相等运算符"></a>不相等运算符</h3><p>相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。</p><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.01.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="！"><a href="#！" class="headerlink" title="！"></a>！</h3><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.02.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><h3 id=""><a href="#" class="headerlink" title="||"></a>||</h3><h3 id="（-）"><a href="#（-）" class="headerlink" title="（?:）"></a>（?:）</h3><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.05.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p><p>左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方（最高位即符号位不参与移动）。</p><p>右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）。</p><p>带符号位的右移运算符（&gt;&gt;&gt;）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。</p><h3 id="开关作用"><a href="#开关作用" class="headerlink" title="开关作用"></a>开关作用</h3><p>掩码</p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="void运算符"><a href="#void运算符" class="headerlink" title="void运算符"></a>void运算符</h3><p>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</p><p>这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.11.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p><h2 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。</p><p>记住所有运算符的优先级，是非常难的，也是没有必要的。</p><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。</p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>使用Number函数，可以将任意类型的值转化成数值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.20.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。</p><p>parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。</p><p>Number方法的参数是对象时，将返回NaN，<strong>除非是包含单个数值的数组</strong>。</p><p>第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。<br>第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。<br>第三步，如果toString方法返回的是对象，就报错。</p><h2 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h2><p>String函数可以将任意类型的值转化成字符串，转换规则如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.29.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p><p>String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.30.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h2><p>Boolean函数可以将任意类型的值转为布尔值。</p><p>它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.33.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。</p><h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>自动转换是以强制转换为基础的。</p><p>以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p><p>第一种情况，不同类型的数据互相运算。</p><p>第二种情况，对非布尔值类型的数据求布尔值。</p><p>第三种情况，对非数值类型的值使用一元运算符（即+和-）。</p><p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。</p><p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</p><h2 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h2><h2 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h2><p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p><p>这种自动转换很容易出错。期望求导个整数值结果得到个字符串。</p><h2 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h2><p>除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p><p><strong>注意</strong>：null转为数值时为0，而undefined转为数值时为NaN。</p><p>一元运算符也会把运算子转成数值。</p><h1 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h1><h2 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8811.11.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h2><p>Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。</p><h3 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h3><p>SyntaxError对象是解析代码时发生的语法错误。</p><h3 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h3><p>ReferenceError对象是引用一个不存在的变量时发生的错误。</p><p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</p><h3 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h3><p>RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p><h3 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h3><p>TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</p><h3 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h3><p>URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p><h3 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h3><p>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p><h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><h2 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h2><p>throw语句的作用是手动中断程序执行，抛出一个错误。</p><p>实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p><p>对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p><h2 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h2><p>一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。</p><p>如果你不确定某些代码是否会报错，就可以把它们放在try…catch代码块之中，便于进一步对错误进行处理。</p><p>catch代码块之中，还可以再抛出错误，甚至使用嵌套的try…catch结构。</p><p>为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8811.23.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><p>try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。</p><p>return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。</p><p><img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8811.31.52.png" alt=""></p><p>由于没有catch语句块，所以错误没有捕获。执行finally代码块以后，程序就中断在错误抛出的地方。</p><p>try…catch…finally这三者之间的执行顺序。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.11.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生</p><p>finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略</p><p>所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。</p><h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。</p><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。</p><p>Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。</p><p>建议总是使用大括号表示区块。</p><p>JavaScript 要使用起首的大括号跟在关键字的后面，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。</p><p><strong>因此，表示区块起首的大括号，不要另起一行。</strong></p><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。</p><p>建议可以用空格，区分这两种不同的括号。</p><h2 id="行尾的分号"><a href="#行尾的分号" class="headerlink" title="行尾的分号"></a>行尾的分号</h2><h3 id="不使用分号的情况"><a href="#不使用分号的情况" class="headerlink" title="不使用分号的情况"></a>不使用分号的情况</h3><h4 id="for和while循环"><a href="#for和while循环" class="headerlink" title="for和while循环"></a>for和while循环</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.22.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，do…while循环是有分号的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.23.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="分支语句：if，switch，try"><a href="#分支语句：if，switch，try" class="headerlink" title="分支语句：if，switch，try"></a>分支语句：if，switch，try</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.23.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="函数的声明语句"><a href="#函数的声明语句" class="headerlink" title="函数的声明语句"></a>函数的声明语句</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.24.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，函数表达式仍然要使用分号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.25.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。</p><h3 id="分号的自动添加"><a href="#分号的自动添加" class="headerlink" title="分号的自动添加"></a>分号的自动添加</h3><p>所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。</p><p>麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。</p><p>如果continue、break、return和throw这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果return语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。</p><p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。</p><p>不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。</p><p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。</p><p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p><p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如UPPER_CASE。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>JavaScript 会自动将变量声明”提升“（hoist）到代码块（block）的头部。</p><p>为了避免可能出现的问题，最好把变量声明都放在代码块的头部。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.31.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</p><h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p>with可以减少代码的书写，但是会造成混淆。</p><p>因此，不要使用with语句。</p><h2 id="相等和严格相等"><a href="#相等和严格相等" class="headerlink" title="相等和严格相等"></a>相等和严格相等</h2><p>相等运算符会自动转换变量类型，造成很多意想不到的情况。</p><p>建议不要使用相等运算符（==），只使用严格相等运算符（===）。</p><h2 id="语句的合并"><a href="#语句的合并" class="headerlink" title="语句的合并"></a>语句的合并</h2><p>建议不要将不同目的的语句，合并成一行。</p><h2 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h2><p>自增（++）和自减（–）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的++运算符都可以用+= 1代替。</p><p>建议自增（++）和自减（–）运算符尽量使用+=和-=代替。</p><h2 id="switch…case结构"><a href="#switch…case结构" class="headerlink" title="switch…case结构"></a>switch…case结构</h2><p>switch…case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。这样不仅容易忘记，还会造成代码的冗长。</p><p>建议switch…case结构可以用对象结构代替。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Jav
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 语法 一</title>
    <link href="https://github.com/zdkswd/2018/08/14/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E8%AF%AD%E6%B3%95%20%E4%B8%80/"/>
    <id>https://github.com/zdkswd/2018/08/14/JavaScript标准参考教程 语法 一/</id>
    <published>2018-08-14T02:36:56.000Z</published>
    <updated>2018-09-01T05:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><blockquote><p>var a=1+3;</p></blockquote><p>分号语句结束。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><blockquote><p>var a = 1;<br>a = ‘hello’;</p></blockquote><p><strong>变量提升</strong><br>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的<strong>变量</strong>，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>中文是合法的标识符，可以用作变量名。<br>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>//单行<br>/*多行*/<br>由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<!--和-->也被视为合法的单行注释。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“<strong>区块</strong>”（block）。<br>对于var命令来说，JavaScript 的区块不构成单独的<strong>作用域</strong>（scope）。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>if和switch 还有三元运算符<br>if switch与c一样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%885.19.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while \for\ do..while<br>while for do..while语法与c一样。<br>break退出循环，continue退出本轮循环。</p><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置。与汇编语言类似。<br><strong>标签</strong>:标签通常与break语句和continue语句配合使用，跳出特定的循环.</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%885.35.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>JavaScript中的值分为2大类：基本类型和引用类型。<br>基本类型：<br>数字类型：Number；字符串类型：String；布尔类型：Boolean(true和false)；Undefined；Null。</p><p>引用类型：<br>对象。</p><p>对象是最复杂的数据类型，又可以分成三个子类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.03.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p><p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。</p><p>对基本类型，是按值访问的，即通过<strong>值复制</strong>的方式来赋值和传递。<br>对引用类型，是按引用访问的，即通过<strong>引用复制</strong>的方式赋值和传递。</p><p>当一个变量进行赋值操作时，就是在重新将变量进行指向。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.08.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>typeof可以用来检查一个没有声明的变量，而不报错。</p><p>instanceof运算符可以区分数组和对象。</p><p>typeof null的类型是object，这是由于历史原因造成的。</p><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。</p><p>在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。</p><p>区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.23.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.24.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>空数组（[]）和空对象（{}）对应的布尔值，都是true。</p><h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h2><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.40.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有效数字的第一位默认总是1。</p><h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.42.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p><h2 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h2><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。<br>数值也可以采用科学计数法表示。</p><p>科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.48.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。<br>（1）小数点前的数字多于21位。<br>（2）小数点后的零多于5个。</p><h2 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h2><p>JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.51.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。</p><p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p><p>有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.52.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><p><strong>正零和负零</strong><br>JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的。<br><strong>NaN</strong><br>NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p><p>0除以0也会得到NaN。</p><p>NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。</p><p>NaN不等于任何值，包括它本身。</p><p>数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。</p><p>NaN在布尔运算时被当作false。</p><p>NaN与任何数（包括它自己）的运算，得到的都是NaN。<br><strong>Infinity</strong><br>Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。</p><p>Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。</p><p>由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。</p><p>Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。</p><p>Infinity与NaN比较，总是返回false。</p><p>Infinity的四则运算，符合无穷的数学计算规则。</p><p>0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。</p><p>Infinity减去或除以Infinity，得到NaN。</p><p>Infinity与null计算时，null会转成0，等同于与0的计算。</p><p>Infinity与undefined计算，返回的都是NaN。</p><h2 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h2><p>parseInt方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。如果parseInt的参数不是字符串，则会先转为字符串再转换。</p><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</p><p>所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。</p><p>如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。</p><p>如果字符串以0开头，将其按照10进制解析。</p><p>对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p><p><strong>进制转换</strong><br>parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。</p><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。</p><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。</p><p>前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h2 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h2><p>parseFloat方法用于将一个字符串转为浮点数。</p><p>如果字符串符合科学计数法，则会进行相应的转换。</p><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><p>parseFloat方法会自动过滤字符串前导的空格。</p><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。</p><p>上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。这些特点使得parseFloat的转换结果不同于Number函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%888.04.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>isNaN</strong><br>isNaN方法可以用来判断一个值是否为NaN。</p><p>但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%888.05.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>出于同样的原因，对于对象和数组，isNaN也返回true。</p><p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。</p><p>上面代码之所以返回false，原因是这些数组能被Number函数转成数值。</p><p><strong>因此，使用isNaN之前，最好判断一下数据类型。</strong></p><p>判断NaN更可靠的方法是，<strong>利用NaN为唯一不等于自身的值的这个特点，进行判断。</strong></p><p><strong>isFinite（）</strong><br>isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p><p>除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p><p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p><p>字符串默认只能写在一行内，分成多行将会报错。</p><p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p><p>连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.15.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>反斜杠还有三种特殊用法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.17.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p><h2 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h2><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p><p>字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p><h2 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h2><p>length属性返回字符串的长度，该属性也是无法改变的。但是不会报错。</p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p><p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。</p><p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p><p>每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即<strong>2个字节</strong>。</p><p>但是，UTF-16 有两种长度。对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。</p><p>JavaScript 对 UTF-16 的支持是<strong>不完整</strong>的，由于历史原因，只支持两字节的字符，不支持四字节的字符。</p><p>总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是<strong>不正确</strong>的。</p><h2 id="Base64-转码"><a href="#Base64-转码" class="headerlink" title="Base64 转码"></a>Base64 转码</h2><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p><p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p><p>JavaScript 原生提供两个 Base64 相关的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.38.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两个方法不适合非 ASCII 码的字符，会报错。</p><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.41.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>键名</strong><br>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。</p><p>如果键名是数值，会被自动转为字符串。</p><p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.45.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果属性的值还是一个对象，就形成了链式引用。</p><p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p><p>属性可以动态创建，不必在对象声明时就指定。</p><h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向<strong>同一个内存地址</strong>。修改其中一个变量，会影响到其他所有变量。</p><p>其中任何一个变量添加属性，另一个变量都可以读写该属性。</p><p>如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><p>这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p><h2 id="表达式还是语句"><a href="#表达式还是语句" class="headerlink" title="表达式还是语句"></a>表达式还是语句</h2><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p><p>V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好还是在大括号前加上圆括号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.54.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h2><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.55.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>注意</strong>，如果使用方括号运算符，键名必须放在<strong>引号</strong>里面，否则会被当作变量处理。</p><p>数字键可以不加引号，因为会自动转成字符串。</p><p><strong>注意</strong>，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p><h2 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h2><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p><p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p><h2 id="查看所有属性"><a href="#查看所有属性" class="headerlink" title="查看所有属性"></a>查看所有属性</h2><p>查看一个对象本身的所有属性，可以使用Object.keys方法。</p><h2 id="delete-命令"><a href="#delete-命令" class="headerlink" title="delete 命令"></a>delete 命令</h2><p>delete命令用于删除对象的属性，删除成功后返回true。delete A[属性名]；。</p><p><strong>注意</strong>，删除一个不存在的属性，delete不报错，而且返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。</p><p>只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。</p><p><strong>注意</strong>，delete命令只能删除对象本身的属性，无法删除继承的属性。即为即使delete返回true，该属性依然可能读取到值。</p><h2 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h2><p>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。</p><p>in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。</p><h2 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h2><p>for…in循环有两个使用注意点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8810.57.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果继承的属性是可遍历的，那么就会被for…in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for…in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p><h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.07.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.07.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。</p><p>因此，建议不要使用with语句，可以考虑用一个临时变量代替with。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组用方括号表示。任何类型的数据，都可以放入数组。</p><h2 id="数组本质"><a href="#数组本质" class="headerlink" title="数组本质"></a>数组本质</h2><p>本质上，数组属于一种特殊的对象。数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。<br>JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p><h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>清空数组的一个有效方法，就是将length属性设为0。<br>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p><h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h2><p>检查某个键名是否存在的运算符in，适用于对象，也适用于数组。</p><h2 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h2><p>for…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p><p>但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。所以，不推荐使用for…in遍历数组。<br>数组的遍历可以考虑使用for循环或while循环。</p><p>数组的forEach方法，也可以用来遍历数组。</p><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。<br>数组的空位不影响length属性。数组最后一个成员后面有一个逗号，这不影响length属性的值。<br>数组的空位是可以读取的，返回undefined。<br>使用delete命令删除一个数组成员，会形成空位，并且<strong>不会影响length属性</strong>。</p><h2 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h2><p>如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p><p>“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。</p><p>“类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。</p><p>典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。</p><p>数组的slice方法可以将“类似数组的对象”变成真正的数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%885.14.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。</p><p>字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。</p><p><strong>注意</strong>，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h1&gt;&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
</feed>
