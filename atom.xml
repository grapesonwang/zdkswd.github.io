<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-07-04T10:36:06.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>松本行弘的程序世界0 说在前面</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C0%20%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>https://github.com/zdkswd/2018/07/04/松本行弘的程序世界0 说在前面/</id>
    <published>2018-07-04T10:35:32.000Z</published>
    <updated>2018-07-04T10:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界0-说在前面"><a href="#松本行弘的程序世界0-说在前面" class="headerlink" title="松本行弘的程序世界0 说在前面"></a>松本行弘的程序世界0 说在前面</h1><h2 id="vczh如何设计一门语言（一）"><a href="#vczh如何设计一门语言（一）" class="headerlink" title="vczh如何设计一门语言（一）"></a>vczh如何设计一门语言（一）</h2><p>好的语言，除了库写起来又容易又好用以外，还有两个重要的特点：容易学，容易分析。关于容易学这一点，其实不是说，你随便看一看就能学会，而是说，只要你掌握了门道，很多未知的特性你都可以猜中。这就有一个语法的<strong>一致性问题</strong>在里面了。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ruby code for fun<br>这本书是松本行弘从一个编程语言设计者的角度去看待各种各样的流行编程语言，分析它们有哪些特点以及ruby编程语言如何进行取舍。ruby本身大量参考了一个更古老而著名的面向对象编程方法的开山鼻祖smalltalk以及偷师函数式编程语言鼻祖LISP。程序员社区有种说法：任何现代编程语言都脱胎于smalltalk于LISP。看看Ruby设计师是怎么设计Ruby语言的，则可以高屋建瓴的理解一些主流的编程语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界0-说在前面&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界0-说在前面&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界0 说在前面&quot;&gt;&lt;/a&gt;松本行弘的程序世界0 说在前面&lt;/h1&gt;&lt;h2 id=&quot;vczh如何设计一门语言（
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界1 我为什么开发Ruby</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C1%20%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91Ruby/"/>
    <id>https://github.com/zdkswd/2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/</id>
    <published>2018-07-04T10:35:32.000Z</published>
    <updated>2018-07-04T10:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界1-我为什么开发Ruby"><a href="#松本行弘的程序世界1-我为什么开发Ruby" class="headerlink" title="松本行弘的程序世界1 我为什么开发Ruby"></a>松本行弘的程序世界1 我为什么开发Ruby</h1><h2 id="编程语言的重要性"><a href="#编程语言的重要性" class="headerlink" title="编程语言的重要性"></a>编程语言的重要性</h2><p>程序员由于使用的编程语言不同，思考方法和编写出的代码都会受到很大的影响。</p><h2 id="Ruby的原则"><a href="#Ruby的原则" class="headerlink" title="Ruby的原则"></a>Ruby的原则</h2><ol><li>简洁性</li><li>扩展性</li><li>稳定性<h2 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h2>随着编程语言的演进，程序员已经可以更简单、更抽象地编程了。面向对象的方法没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序运行开销。现在由于计算机性能大大提高，只要可以提高软件的开发效率，浪费一些计算机资源也无所谓了。<br>ruby的目标是成为开发效率高、能直接运行的伪码式编程语言。省去了不必要的声明。<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2>Ruby看重的不是明哲保身，而是如何最大限度的发挥程序员自身的能力。<br>编程的历史就是因为想当然而失败的历史，ruby对整数范围不做任何限定，尽最大努力排除“想当然”。<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2>虽然ruby非常重视扩展性，但明知道LISP风格的宏能带来巨大的扩展性，仍没有使用。<h2 id="一切皆因兴趣"><a href="#一切皆因兴趣" class="headerlink" title="一切皆因兴趣"></a>一切皆因兴趣</h2></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界1-我为什么开发Ruby&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界1-我为什么开发Ruby&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界1 我为什么开发Ruby&quot;&gt;&lt;/a&gt;松本行弘的程序世界1 我为什么开发Ruby&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>growth全栈</title>
    <link href="https://github.com/zdkswd/2018/07/03/growth%E5%85%A8%E6%A0%88/"/>
    <id>https://github.com/zdkswd/2018/07/03/growth全栈/</id>
    <published>2018-07-03T01:12:25.000Z</published>
    <updated>2018-07-03T03:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识篇"><a href="#基础知识篇" class="headerlink" title="基础知识篇"></a>基础知识篇</h1><p>环境是生产率的一部分。高效的程序员与低效的程序员间十倍的差距，至少有三倍是因为环境差异。<br>语言和开发软件都是工具，都有相对更合适的情况。</p><h2 id="提高效率的工具："><a href="#提高效率的工具：" class="headerlink" title="提高效率的工具："></a>提高效率的工具：</h2><h3 id="快速启动软件"><a href="#快速启动软件" class="headerlink" title="快速启动软件"></a>快速启动软件</h3><p>windows-&gt; launcy</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><h3 id="DEBUG工具"><a href="#DEBUG工具" class="headerlink" title="DEBUG工具"></a>DEBUG工具</h3><h3 id="终端或命令提示符"><a href="#终端或命令提示符" class="headerlink" title="终端或命令提示符"></a>终端或命令提示符</h3><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="OSX"><a href="#OSX" class="headerlink" title="OSX"></a>OSX</h3><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><p>包管理工具，官方称之为 The missing package manager for OS X。 </p><h4 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a>Homebrew Cask</h4><p>brew-cask 允许你使用命令行安装 OS X 应用。 </p><h4 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h4><p>iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。 </p><h4 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h4><p>Zsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:<br>• 更高效<br>• 更好的自动补全• 更好的文件名展开(通配符展开) • 更好的数组处理• 可定制性高 </p><h4 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h4><p>Oh My Zsh 同时提供一套插件和工具，可以简化命令行操作。  </p><h4 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a>MacDown</h4><p>MacDown 是 Markdown 编辑器。 </p><h4 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h4><p>CheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按 。 </p><h4 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h4><p>SourceTree 是 Atlassian 公司出品的一款优秀的 Git 图形化客户端。 </p><h4 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h4><p>Mac 用户不用鼠标键盘的必备神器，配合大量 Workflows，习惯之后可以大 大减少操作时间。<br>上手简单，调教成本在后期自定义 Workflows，不过有大量雷锋使用者提供的现成 扩展，访问这里挑选喜欢的，并可以极其简单地根据自己的需要修改。 </p><h4 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a>Vimium</h4><p>Vimium 是一个 Google Chrome 扩展，让你可以纯键盘操作 Chrome。 </p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h4><p>Chocolatey 是一个软件包管理工具，类似于 Ubuntu 下面的 apt-get, 不过是 运行在 Windows 环境下面。 </p><h4 id="Wox"><a href="#Wox" class="headerlink" title="Wox"></a>Wox</h4><p>Wox 是一个高效的快速启动器工具，通过快捷键呼出，然后输入关键字来搜 索程序进行快速启动，或者搜索本地硬盘的文件，打开百度、Google 进行搜 索，甚至是通过一些插件的功能实现单词翻译、关闭屏幕、查询剪贴板历史、 查询编程文档、查询天气等更多功能。它最大的特点是可以支持中文拼音的 模糊匹配。 </p><h4 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h4><p>Windows PowerShell 是微软公司为 Windows 环境所开发的壳程序(shell) 及脚本语言技术，采用的是命令行界面。这项全新的技术提供了丰富的控制 与自动化的系统管理能力。 </p><h4 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h4><p>cmder 把 conemu，msysgit 和 clink 打包在一起，让你无需配置就能使用一 个真正干净的 Linux 终端!她甚至还附带了漂亮的 monokai 配色主题。 </p><h4 id="Total-Commander"><a href="#Total-Commander" class="headerlink" title="Total Commander"></a>Total Commander</h4><p>Total Commander 是一款应用于 Windows 平台的文件管理器，它包含两个 并排的窗又，这种设计可以让用户方便地对不同位置的 “文件或文件夹” 进 行操作，例如复制、移动、删除、比较等，相对 Windows 资源管理器而言 方便很多，极大地提高了文件操作的效率，被广大软件爱好者亲切地简称为: TC 。 </p><h3 id="GNU-Linux"><a href="#GNU-Linux" class="headerlink" title="GNU/Linux"></a>GNU/Linux</h3><h4 id="Zsh-1"><a href="#Zsh-1" class="headerlink" title="Zsh"></a>Zsh</h4><p>Zsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:<br>• 更高效<br>• 更好的自动补全<br>• 更好的文件名展开(通配符展开)<br>• 更好的数组处理• 可定制性高 </p><h4 id="Oh-My-Zsh-1"><a href="#Oh-My-Zsh-1" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h4><p>Oh My Zsh 同时提供一套插件和工具，可以简化命令行操作。</p><h4 id="ReText"><a href="#ReText" class="headerlink" title="ReText"></a>ReText</h4><p>ReText 是一个使用 Markdown 语法和 reStructuredText (reST) 结构的文本 编辑器，编辑的内容支持导出到 PDF、ODT 和 HTML 以及纯文本，支持即 时预览、网页生成以及 HTML 语法高亮、全屏模式，可导出文件到 Google Docs 等。 </p><h4 id="Launchy"><a href="#Launchy" class="headerlink" title="Launchy"></a>Launchy</h4><p>Launchy 是一款免费开源的协助您摒弃 Windows “运行” 的 Dock 式替代工 具，既方便又实用，自带多款皮肤，作为美化工具也未尝不可。 </p><p>学习一门语言，输出是最好的输入，实践更是硬道理。 </p><h1 id="Web编程基础"><a href="#Web编程基础" class="headerlink" title="Web编程基础"></a>Web编程基础</h1><p>运用HTTP传递数据,浏览器第一步Parser HTML,Paser HTML 实质上就是将其 将解析为 DOM Tree。与此同时，CSS 解析器会解析 CSS 会产生 CSS 规则树。<br>随后会根据生成的 DOM 树和 CSS 规则树来构建 Render Tree，接着生成 Render Tree 的布局，最后就是绘制出 Render Tree。<br> <img src="/img/media/15290576482384/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-17%20%E4%B8%8B%E5%8D%884.12.56.png" alt="屏幕快照 2018-06-17 下午4.12.56"></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>超文本标记语言 </p><ol><li>浏览器解析器对中文支持不友好。 </li><li>浏览器解析器对英文支持友好。 <h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3>类选择器，id选择器<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2>HTML 中插入 JavaScript 的方法，就需要用到 HTML 中的 &lt; script&gt; 标签 完整的 JavaScript 应该由下列三个部分组成:<br>• 核心 (ECMAScript)——核心语言功能<br>• 文档对象模型 (DOM)——访问和操作网页内容的方法和接口<br>• 浏览器对象模型 (BOM)——与浏览器交互的方法和接口</li></ol><p>有了 DOM 我们就可以对页面进行操作，可以说我们看<br>到的绝大部分的页面效果都是通过 DOM 操作实现的。 </p><h2 id="前端与后端"><a href="#前端与后端" class="headerlink" title="前端与后端"></a>前端与后端</h2><h3 id="后台语言选择"><a href="#后台语言选择" class="headerlink" title="后台语言选择"></a>后台语言选择</h3><h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><p>只要是 Web 就会有前端,只要有前端就需要有 JavaScript。与此同时 Node.js在后台中的地位已经愈发重要了。<br>对于 JavaScript 来说，它可以做很多类型的应用。这些应用都是基于浏览器来运行 的，有:<br>• Electron + Node.js + JavaScript 做桌面应用<br>• Ionic + JavaScript 做移动应用<br>• Node.js + JavaScript 网站前后台<br>• JavaScript + Tessl 做硬件 </p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><strong>Model</strong><br>模型用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。<br><strong>View</strong> 层只是单纯的一个显示作用，这也是我们推荐的做法。业务逻辑应 该尽可能的放置于业务层。<br><strong>Controller</strong><br>控制器层起到不同层面间的组织作用，用于控制应用程序的流程。</p><h3 id="后台即服务"><a href="#后台即服务" class="headerlink" title="后台即服务"></a>后台即服务</h3><p>移动端应用程序</p><h3 id="前端框架选择"><a href="#前端框架选择" class="headerlink" title="前端框架选择"></a>前端框架选择</h3><h4 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h4><p>AngularJS 对于后端人员写前端代码来说，是一个非常不错的选择。Angular 框架 采用并扩展了传统 HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许 模型和视图之间的自动同步。 </p><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>React 只是我们在上面章节里说到的 View 层，而这个 View 层需要辅以其他框架才 能完成更多的工作。<br>并且 React 还有一个不错的杀手锏——React Native，虽然这个框架还在有条不紊地 挖坑中，但是这真的是太爽了。以后我们只需要一次开发就可以多处运行了，再也没有 比这更爽的事情发生了。 </p><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><p>Vue.js 是一个轻量级的前端框架。它是一个更加灵活开放的解决方案。它允许你以 希望的方式组织应用程序，你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。 </p><h4 id="jQuery系"><a href="#jQuery系" class="headerlink" title="jQuery系"></a>jQuery系</h4><p>jQuery 还是一个不错的选择，不仅仅对于学习来说，而且对于工作来说也是如此。 如果你们不是新起一个项目或者重构旧的项目，那么必然你是没有多少机会去超越 DOM。 </p><h3 id="前台与后台交互"><a href="#前台与后台交互" class="headerlink" title="前台与后台交互"></a>前台与后台交互</h3><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>AJAX 即 “Asynchronous JavaScript And XML”(异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。<br>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更 新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的 网页如果需要更新内容，必须重载整个网页页面。 </p><h4 id="JSON-WEB-Tokens"><a href="#JSON-WEB-Tokens" class="headerlink" title="JSON WEB Tokens"></a>JSON WEB Tokens</h4><p>JSON Web Token (JWT) 是一种基于 token 的认证方案。<br>在人们大规模地开始 Web 应用的时候，我们在授权的时候遇到了一些问题，而这些 问题不是 Cookie 所能解决的。<br>通过 JWT 我们可以更方便地写出适用于前端应用的认证方案，如登陆、注册这些功能。<br>在使用 JWT 的时候也需要注意安全问题，在允许的情况下应该使用 HTTPS 协议。 </p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>HTML5 推出了一种 在单个 TCP 连接上进行全双工通讯的协议 WebSocket。WebSocket 可以让客户端和服务器之间存在持久的连接，而且双方都可以随时开始 发送数据。 </p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="Web-应用的构建系统"><a href="#Web-应用的构建系统" class="headerlink" title="Web 应用的构建系统"></a>Web 应用的构建系统</h2><p>构建系统 (build system) 是用来从源代码生成用户可以使用的目标的自动化 工具。目标可以包括库、可执行文件、或者生成的脚本等等。 </p><p>常用的构建工具包括 GNU Make、GNU autotools、CMake、Apache Ant(主要用于 JAVA)。此外，所有的集成开发环境(IDE)比如 Qt Creator、Microsoft Visual Studio 和 Eclipse 都对他们支持的语言添加了自己的构建系统配置工具。通常 IDE 中的构建系 统只是基于控制台的构建系统(比如 Autotool 和 CMake )的前端。<br>对比于 Web 应用开发来说，构建系统应该还包括应用打包 (如 Java 中的 Jar 包，或 者用于部署的 RPM 包、源代码分析、测试覆盖率分析等等。 </p><h2 id="Web-应用的构建"><a href="#Web-应用的构建" class="headerlink" title="Web 应用的构建"></a>Web 应用的构建</h2><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><strong>Gulp.js</strong>是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你 可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务 的 Gulp 文件都是通过 JavaScript(或者 CoffeeScript )源码来实现的。 </p><h3 id="JSHint"><a href="#JSHint" class="headerlink" title="JSHint"></a>JSHint</h3><p>最初，lint这个工具用来扫描C源文件并对源程序中不可移植的代码提出警告。但是现在大多数lint实用程序已经变得更加严密，它不但可以检查出可移植性问题，而且可以检查出那些虽然可移植并且完全合乎语法但却很可能是错误的特性。<br>对应于不同的语言都会有不同的 lint 工具，在 JavaScript 中就有JSLint。JavaScript 是一门年轻、语法灵活多变且对格式要求相对松散的语言，因此这样的工具对于这门语 言来说比较重要。<br>• 可配置规则，每个团队可以自己定义自己想要的代码规范。<br>• 对社区非常友好，社区支持度高。<br>• 可定制的结果报表。 </p><h3 id="自动化测试工具"><a href="#自动化测试工具" class="headerlink" title="自动化测试工具"></a>自动化测试工具</h3><p>Mocha 是一个可以运行在 Node.js 和浏览器环境里的测试框架。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>对于静态型语言来说，编译是一个很重要的步骤。不过，对于动态语言来说也存在这样的工具。<br><strong>动态语言的编译</strong>:是以我们常见的 JavaScript 为代表。<br><strong>打包</strong>,1.    DEB 2.RPM 3.压缩文档 tar.gz </p><h3 id="如何编写测试TODO"><a href="#如何编写测试TODO" class="headerlink" title="如何编写测试TODO"></a>如何编写测试TODO</h3><p>测试金字塔 从上到下 ui测试 服务测试 单元测试<br>测试替身 Stub Mock</p><h3 id="代码重构TODO"><a href="#代码重构TODO" class="headerlink" title="代码重构TODO"></a>代码重构TODO</h3><p>重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。 </p><h1 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h1><h2 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h2><p>目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。 </p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广 泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器 端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译 到服务器中。 </p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件(IMAP/ POP3)代理服务器，并在一个 BSD-like 协议下发行。由俄罗斯的程序设计师 Igor Sysoev 所开发，供俄国大型的入又网站及搜索引擎 Rambler(俄文:Рамблер)使用。 其特点是占有内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务 器中表现较好，中国大陆使用 Nginx 网站用户有:百度、新浪、网易、腾讯等。 </p><h3 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h3><p>Internet Information Services(IIS，互联网信息服务)，是由微软公司提供的基 于运行 Microsoft Windows 的互联网基本服务。最初是 Windows NT 版本的可选包，随 后内置在 Windows 2000、Windows XP Professional 和 Windows Server 2003 一起发 行，但在 Windows XP Home 版本上并没有 IIS。 </p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器(Proxy Server)是一种重要的服务器安全功能，它的工作主要在 开放系统互联 (OSI) 模型的会话层，从而起到防火墙的作用。代理服务器大 多被用来连接 INTERNET(国际互联网)和 Local Area Network(局域网)。 </p><h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><p>• 数据库端缓存<br>• 应用层缓存<br>• 前端缓存<br>• 客户端缓存 </p><h2 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h2><p>当我们上线了我们的新功能的时候，这时候如果有个 Bug，那么我们是下线么?要 知道这个版本里面包含了很多的 Bug 修复。<br>Feature Toggle 它是一种允许控制线上功能开启或者关闭的方式 </p><h2 id="依赖与包仓库"><a href="#依赖与包仓库" class="headerlink" title="依赖与包仓库"></a>依赖与包仓库</h2><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="SEO-搜索引擎优化"><a href="#SEO-搜索引擎优化" class="headerlink" title="SEO 搜索引擎优化"></a>SEO 搜索引擎优化</h2><h2 id="分析工具-google-analytics"><a href="#分析工具-google-analytics" class="headerlink" title="分析工具 google analytics"></a>分析工具 google analytics</h2><h2 id="网站性能-Apdex联盟"><a href="#网站性能-Apdex联盟" class="headerlink" title="网站性能 Apdex联盟"></a>网站性能 Apdex联盟</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础知识篇&quot;&gt;&lt;a href=&quot;#基础知识篇&quot; class=&quot;headerlink&quot; title=&quot;基础知识篇&quot;&gt;&lt;/a&gt;基础知识篇&lt;/h1&gt;&lt;p&gt;环境是生产率的一部分。高效的程序员与低效的程序员间十倍的差距，至少有三倍是因为环境差异。&lt;br&gt;语言和开发软件都是工
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="全栈" scheme="https://github.com/zdkswd/tags/%E5%85%A8%E6%A0%88/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>[Linux内核设计与实现]中断与中断处理</title>
    <link href="https://github.com/zdkswd/2018/07/01/%E3%80%90Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%91%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/01/【Linux内核设计与实现】中断与中断处理/</id>
    <published>2018-07-01T11:37:32.000Z</published>
    <updated>2018-07-01T11:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Linux内核设计与实现】中断与中断处理"><a href="#【Linux内核设计与实现】中断与中断处理" class="headerlink" title="【Linux内核设计与实现】中断与中断处理"></a>【Linux内核设计与实现】中断与中断处理</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在Linux中，中断处理程序就是普普通通的C函数。</p><h2 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h2><p>把中断处理分为两部分。中断处理程序是上半部–接收到一个中断，就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部。</p><h2 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h2><p>中断处理程序是管理硬件的驱动程序的组成部分。每一设备都有相关的驱动程序，如果设备使用中断，则对应的驱动程序就注册一个中断处理程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【Linux内核设计与实现】中断与中断处理&quot;&gt;&lt;a href=&quot;#【Linux内核设计与实现】中断与中断处理&quot; class=&quot;headerlink&quot; title=&quot;【Linux内核设计与实现】中断与中断处理&quot;&gt;&lt;/a&gt;【Linux内核设计与实现】中断与中断处理&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="纸质书笔记" scheme="https://github.com/zdkswd/tags/%E7%BA%B8%E8%B4%A8%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters</title>
    <link href="https://github.com/zdkswd/2018/06/15/%E5%BC%95%E5%85%A5module%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98%20;%20AsyncTask%20;Make%20Clean%20Project;abiFilters/"/>
    <id>https://github.com/zdkswd/2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/</id>
    <published>2018-06-15T09:49:56.000Z</published>
    <updated>2018-06-15T03:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters"><a href="#引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters" class="headerlink" title="引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters"></a>引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters</h1><h2 id="import-module"><a href="#import-module" class="headerlink" title="import module"></a>import module</h2><p>在import module时，如果图标没有变化，不要忘了改setting.gradle</p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask,即异步任务,是Android给我们提供的一个处理异步任务的类.通过此类,可以实现UI线程和后台线程进行通讯,后台线程执行异步任务,并把结果返回给UI线程.</p><p><strong>AsyncTask</strong>&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个<strong>泛型参数</strong>:<br><strong>Params</strong>:启动任务时输入的参数类型.<br><strong>Progress</strong>:后台任务执行中返回进度值的类型.<br><strong>Result</strong>:后台任务执行完成后返回结果的类型.</p><p><strong>AsyncTask</strong>主要有如下几个<strong>方法</strong>:<br><strong>doInBackground</strong>:<strong>必须重写</strong>,异步执行后台线程要完成的任务,<strong>耗时操作将在此方法中完成</strong>.<br><strong>onPreExecute</strong>:执行后台耗时操作前被调用,通常用于进行初始化操作.<br><strong>onPostExecute</strong>:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.<br><strong>onProgressUpdate</strong>:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度.</p><h2 id="Make-Project-Clean-Project"><a href="#Make-Project-Clean-Project" class="headerlink" title="Make Project Clean Project"></a>Make Project Clean Project</h2><ol><li>Make Project：编译Project下所有Module，一般是自上次编译后Project下有更新的文件，不生成apk。</li><li>Make Selected Modules：编译指定的Module，一般是自上次编译后Module下有更新的文件，不生成apk。</li><li>Clean Project：删除之前编译后的编译文件，并重新编译整个Project，比较花费时间，不生成apk。</li><li>Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成apk，这里效果其实跟Clean Project是一致的，这个不知道Google搞什么鬼～～</li><li>Build APK：前面4个选项都是编译，没有生成apk文件，如果想生成apk，需要点击Build APK。</li><li>Generate Signed APK：生成有签名的apk。</li></ol><p>平时小的改动直接用Make Project就可以，可以看到只有它有快捷方式，表明这个功能要经常用。对于一些大的改动比如更新lib，大功能修改等，用Clean或Rebuild，毕竟这两个编译起来要费时间。<br>如果有的时候死活编译不过，多试试Clean吧，会有意想不到的效果！</p><h2 id="关于abiFilters的使用"><a href="#关于abiFilters的使用" class="headerlink" title="关于abiFilters的使用"></a>关于abiFilters的使用</h2><p>最近项目中遇到了要使用opencv的情况，涉及到了abi兼容的选择。因为如果全部都适配的话，包很大，这样兼容那些用户数极少的cpu就很不划算，所以我只适配了armeabi-v7a这一个。但是今天在x64-v8a的模拟器上看的时候，提示我的library.so文件找不到，我记得这个应该是向下兼容的，但是出现这种情况很奇怪，于是我就在网上找了找答案。<br>解决方法：abiFilters<br>在app的gradle的defaultConfig里面加上这么一句<br>ndk {<br>    abiFilters  “armeabi-v7a”  // 指定要ndk需要兼容的架构(这样其他依赖包里mips,x86,armeabi,arm-v8之类的so会被过滤掉)<br>}</p><p>这句话的意思就是指定ndk需要兼容的架构，把除了v7a以外的兼容包都过滤掉，只剩下一个v7a的文件夹。用了这个方法之后，确实解决了问题。这就是解决方法。<br>具体分析<br>其实这个方法我开始是很奇怪的，我明明没有指定其他的兼容框架，为什么会需要一个过滤。我打来了apk的包，找到了里面的lib目录，发现里面有很多的兼容目录，然后看到里面目录里面的是一个fresco的.so文件。也就是说，fresco做了各个平台的兼容，所以它创建了各个兼容平台的目录。因为只要出现了这个目录，系统就只会在这个目录里找.so文件而不会遍历其他的目录，所以就出现了之前找不到.so文件的情况（因为其他目录没有我的.so文件）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters&quot;&gt;&lt;a href=&quot;#引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="AndroidStudio" scheme="https://github.com/zdkswd/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>[Linux内核设计与实现]系统调用</title>
    <link href="https://github.com/zdkswd/2018/06/15/%5BLinux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://github.com/zdkswd/2018/06/15/[Linux内核设计与实现]系统调用/</id>
    <published>2018-06-15T03:53:32.000Z</published>
    <updated>2018-06-18T02:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核设计与实现-系统调用"><a href="#Linux内核设计与实现-系统调用" class="headerlink" title="[Linux内核设计与实现]系统调用"></a>[Linux内核设计与实现]系统调用</h1><p>内核提供接口让应用程序调用实现特定功能，避免应用程序肆意妄为。</p><h2 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h2><p>系统调用在用户空间进程和硬件设备间添加了一个中间层。</p><ol><li>提供硬件的抽象接口，即无需管磁盘类型，介质等问题。</li><li>保证系统的安全。</li><li>告知内核自己在使用硬件以实现多任务和虚拟内存。内核知道了才能更好的管理分配。<br><strong>系统调用是用户空间访问内核的唯一手段。</strong></li></ol><h2 id="API、POSIX、和C库"><a href="#API、POSIX、和C库" class="headerlink" title="API、POSIX、和C库"></a>API、POSIX、和C库</h2><p>用户程序在用户空间使用API进行编程。API可以实现零个，一个或多个系统调用。<br>UNIX世界中，最流行的应用程序接口是基于POSIX标准的。在大多数Unix上，根据POSIX定义的API函数和系统调用之间有着直接的关系。这个协议是对操作系统服务接口的标准化，从而保证了应用程序在源码层次的可移植性。<br>具体来说是应用程序调用API，API中包含有系统调用，调用内核。<br>程序员与API打交道，内核与系统调用打交道。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>要访问系统调用（在Linux中常称为syscall）,通常通过C库中定义的函数调用来进行。</p><h3 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h3><p>在Linux中，每个系统调用被赋予一个系统调用号。通过这个独一无二的号可以关联系统调用。<strong>系统调用号非常重要，</strong>一旦分配就不能变更，否则编译好的应用就会崩溃。Linux中的<strong>sys_ni_syscall()</strong>系统调用几乎不做任何操作，相当于白板儿，用来替代那些被删除的或不可用的系统调用。<br>内核用<strong>sys_call_table</strong>记录注册过的系统调用。</p><h3 id="系统调用的性能"><a href="#系统调用的性能" class="headerlink" title="系统调用的性能"></a>系统调用的性能</h3><p>Linux系统调用比其他操作系统执行的快。一是因为Linux有很短的上下文切换时间。二是系统调用处理程序和每个系统调用都很简洁。</p><h2 id="系统调用的处理程序"><a href="#系统调用的处理程序" class="headerlink" title="系统调用的处理程序"></a>系统调用的处理程序</h2><p>应用程序实际在API中调用的系统调用也并不是直接执行内核代码。应用程序以<strong>软中断</strong>的方式来通知系统执行一个系统的调用。通过引发异常来促使系统切换到内核态去执行异常处理程序。正是系统调用的处理程序。通过<strong>int$0x80</strong>指令触发中断。</p><h3 id="指定恰当的系统调用"><a href="#指定恰当的系统调用" class="headerlink" title="指定恰当的系统调用"></a>指定恰当的系统调用</h3><p><strong>系统调用号</strong>通过<strong>eax寄存器</strong>传递给内核。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>也可以通过寄存器进行参数的传递。</p><h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><h3 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h3><p>Unix格言<strong>提供机制而不是策略</strong>，当写一个系统调用时，要时刻注意可移植性和健壮性，还要为以后做打算。</p><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p>系统调用必须仔细检查参数是否合法有效最重要的检查是用户提供的指针知否有效。内核无论何时都不能轻率接受来自用户空间的指针。</p><h2 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h2><p>在Context中，内核可以休眠可以被抢占。</p><h3 id="绑定一个系统调用的最后步骤"><a href="#绑定一个系统调用的最后步骤" class="headerlink" title="绑定一个系统调用的最后步骤"></a>绑定一个系统调用的最后步骤</h3><h3 id="从用户空间访问系统调用"><a href="#从用户空间访问系统调用" class="headerlink" title="从用户空间访问系统调用"></a>从用户空间访问系统调用</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux内核设计与实现-系统调用&quot;&gt;&lt;a href=&quot;#Linux内核设计与实现-系统调用&quot; class=&quot;headerlink&quot; title=&quot;[Linux内核设计与实现]系统调用&quot;&gt;&lt;/a&gt;[Linux内核设计与实现]系统调用&lt;/h1&gt;&lt;p&gt;内核提供接口让应
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="纸质书笔记" scheme="https://github.com/zdkswd/tags/%E7%BA%B8%E8%B4%A8%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback</title>
    <link href="https://github.com/zdkswd/2018/05/31/Surface%E3%80%81SurfaceView%E3%80%81SurfaceHolder%E5%8F%8ASurfaceHolder.Callback/"/>
    <id>https://github.com/zdkswd/2018/05/31/Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback/</id>
    <published>2018-05-31T09:49:56.000Z</published>
    <updated>2018-05-31T09:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h2><p>Surface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原生缓冲器以及其它方面的内容。<br>原生缓冲器（rawbuffer）是用于保存当前窗口的像素数据的。<br>通常画图是在一个Canvas对象上面进行的。</p><h2 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h2><p>SurfaceView，顾名思义就是Surface的View，通过SurfaceView就可以看到Surface的部分或者全部的内容.<br>也就是说，Surface是用通过SurfaceView才能展示其中的内容。<br>SurfaceView是Android中View的子类。事实上，在Android中所有用于界面展示的类皆为View的子类，包括那些不可见的、各种各样的Layout。</p><p>在Android中Surface是从Object派生而来，且实现了Parcelable接口。看到Parcelable就让人能很自然地想到数据容器，SurfaceView就是用来展示Surface中的数据的。在这个层面上而言，Surface就是管理数据的地方，SurfaceView就是展示数据的地方。</p><p>这个类的目的之一，就是提供一个可以用另外一个线程（第二个线程）进行屏幕渲染的surface（译注：即UI线程和绘制线程可以分离）。如果你打算这样使用，那么应当注意一些线程方面的语义：</p><ul><li>所有SurfaceView和SurfaceHolder.Callback中声明的方法，必须在运行SurfaceView窗口中的线程中调用（典型地，就是应用的主线程。译注：即UI线程），因为它们需要正确地将同时被绘制线程访问的各种状态进行同步。</li><li>必须保证，只有在背后的Surface有效的时候 – 在SurfaceHolder.Callback.surfaceCreated()和 SurfaceHolder.Callback.surfaceDestroyed()这两个方法调用之间，访问它。</li></ul><p>Android中实现<strong>序列化</strong>有两个选择：一是实现<strong>Serializable</strong>接口（是JavaSE本身就支持的），一是实现<strong>Parcelable</strong>接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。</p><h2 id="SurfaceHolder"><a href="#SurfaceHolder" class="headerlink" title="SurfaceHolder"></a>SurfaceHolder</h2><p>SurfaceHolder是一个接口，其作用就像一个关于Surface的监听器。提供访问和控制SurfaceView背后的Surface 相关的方法.它通过三个回调方法，让我们可以感知到Surface的创建、销毁或者改变。在SurfaceView中有一个方法getHolder，可以很方便地获得SurfaceView所对应的Surface所对应的SurfaceHolder.<br>从设计模式的高度来看，Surface、SurfaceView和SurfaceHolder实质上就是广为人知的MVC，即Model-View-Controller。</p><h2 id="SurfaceHolder-Callback"><a href="#SurfaceHolder-Callback" class="headerlink" title="SurfaceHolder.Callback"></a>SurfaceHolder.Callback</h2><p>前面已经讲到SurfaceHolder是一个接口，它通过回到方法的方式，让我们可以感知到Surface的创建、销毁或者改变。其实这一点是通过其内部的静态子接口SurfaceHolder.Callback来实现的。SurfaceHolder.Callback中定义了三个接口方法：</p><ol><li>abstract void surfaceChanged(SurfaceHolderholder, int format, int width, int height)<br>当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。</li><li>abstract void surfaceCreated(SurfaceHolderholder)<br>当surface对象创建后，该方法就会被立即调用。</li><li>abstract void surfaceDestroyed(SurfaceHolderholder)<br>当surface对象在将要销毁前，该方法会被立即调用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Surface&quot;&gt;&lt;a href=&quot;#Surface&quot; class=&quot;headerlink&quot; title=&quot;Surface&quot;&gt;&lt;/a&gt;Surface&lt;/h2&gt;&lt;p&gt;Surface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原生缓冲器以及其它
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【安卓开发艺术探索】JNI和NDK编程</title>
    <link href="https://github.com/zdkswd/2018/05/31/%E3%80%90%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%91JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/05/31/【安卓开发艺术探索】JNI和NDK编程/</id>
    <published>2018-05-31T09:49:56.000Z</published>
    <updated>2018-05-31T12:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>NDK还提供了交叉编译器，开发人员只需要简单地修改mk文件就可以生成特定CPU平台的动态库。</p><h2 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h2><ol><li><strong>在java中声明native方法</strong><br>声明native方法，且在类头部有加载动态库的过程，库的真实名字为加载所用名字加前缀lib，这是加载so库的规范。  </li><li><strong>编译java源文件得到class文件，然后通过javah命令导出JNI的头文件</strong></li></ol><blockquote><p>javac com/ddd/example.java<br>javah com.ddd.example</p></blockquote><p>在当前目录会产生一个com_ddd_example.h的头文件，它是javah命令自动生成的。函数名的格式遵循java_包名_类名_方法名</p><ol start="3"><li><strong>实现JNI方法</strong>，JNI方法是指java中声明的native方法，在工程的主目录下创建一个子目录，名称随意，将上一步生成的头文件复制其中，接着创建.cpp文件，include它。实现其中的方法。</li><li><strong>编译so库并在java中调用</strong>so库这里采用gcc编译，切换到刚刚生成的子目录中，对于cpp编译指令如下：<blockquote><p>gcc -shared-I /本地jdk的安装路径/include -fPIC .cpp -o libexample.so</p></blockquote></li></ol><p>so库编译完成后，就可以在Java程序中调用so库了，切换至主目录，执行指令</p><blockquote><p>java -Djava.library.path=子目录名 com.ddd.example </p></blockquote><p>其中-Djava.library.path指明了so库的路径。</p><h2 id="NDK开发流程"><a href="#NDK开发流程" class="headerlink" title="NDK开发流程"></a>NDK开发流程</h2><ol><li><strong>下载并配置NDK</strong></li><li><strong>创建一个安卓项目，并声明所需的native方法</strong>如：</li></ol><blockquote><p>public static native String hello();</p></blockquote><p>3.<strong>实现安卓项目中声明的native方法</strong>,在外部创建一个名为jni的目录，然后在jni目录下创建3个文件，.cpp,Android.mk和Application.mk .h中：</p><blockquote><p>JNIEXPORT jstring JNICALL Java_com_aiseminar_EasyPR_PlateRecognizer_hello(JNIEnv *, jclass);</p></blockquote><p>.cpp中实现其.h中的函数。<br><strong>Android.mk</strong>中，<strong>LOCAL_MODULE</strong>表示模块的名称，<strong>LOCAL_SRC_FILES</strong>表示需要参与编译的源文件。<br><strong>Application.mk</strong>中常用的配置项是<strong>APP_ABI</strong>,它表示CPU架构平台的类型，默认NDK编译全平台的so库，但可以指定编译特定平台的so库。</p><ol start="4"><li><strong>切换到jni目录的父目录，然后通过ndk-build命令编译产生so库</strong><br>这时NDK会创建一个和jni平级的目录libs，存放so库的目录。需要注意ndk-build命令默认指定jni目录为本地源码目录。若不是则无法成功编译。<br>然后在app/src/main中创建一个名为jniLibs目录，将生成so库复制过去，通过AndroidStudio编译运行即可。<br>jniLibs目录是AndroidStudio默认目录，也可修改App build.gradle文件，jniLibs.srcDir选项指定了新的存放so库的目录。</li></ol><p>也可以通过AndroidStudio来<strong>自动编译</strong>来产生so库。首先需要在App的build.gradle的defaultConfig区域内添加NDK选项，其中moduleName制定了模块的名称，这个名称指定看打包后的so库文件名。<br>ndk{<br>    moduleName”example”<br>}<br>接着需要将JNI代码放在app/src/main/jni目录中，注意存JNI必须为jni，也可以通过如下方式指定JNI代码路径，其中jni.srcDirs指定JNI代码路径：<br>jni.srcDirs ‘src/main/lib_src’<br>经过上面的步骤，AndroidStudio就可以自动编译JNI代码了。</p><h2 id="JNI的数据类型和类型签名"><a href="#JNI的数据类型和类型签名" class="headerlink" title="JNI的数据类型和类型签名"></a>JNI的数据类型和类型签名</h2><h2 id="JNI调用Java方法"><a href="#JNI调用Java方法" class="headerlink" title="JNI调用Java方法"></a>JNI调用Java方法</h2><p>1 找到类名<br>2 找到方法id<br>3 调用方法<br>对于非静态方法要先生成类才行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NDK还提供了交叉编译器，开发人员只需要简单地修改mk文件就可以生成特定CPU平台的动态库。&lt;/p&gt;
&lt;h2 id=&quot;JNI开发流程&quot;&gt;&lt;a href=&quot;#JNI开发流程&quot; class=&quot;headerlink&quot; title=&quot;JNI开发流程&quot;&gt;&lt;/a&gt;JNI开发流程&lt;/h2
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>implementation 与 compile 的区别 .iml build文件夹 安卓视图</title>
    <link href="https://github.com/zdkswd/2018/05/31/implementation%20%E4%B8%8E%20compile%20%E7%9A%84%E5%8C%BA%E5%88%AB%20.iml%20build%E6%96%87%E4%BB%B6%E5%A4%B9%20%E5%AE%89%E5%8D%93%E8%A7%86%E5%9B%BE/"/>
    <id>https://github.com/zdkswd/2018/05/31/implementation 与 compile 的区别 .iml build文件夹 安卓视图/</id>
    <published>2018-05-31T09:49:56.000Z</published>
    <updated>2018-05-31T09:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>##implement<br>概念 : 将该依赖隐藏在内部，而不对外部公开。<br>理解 : 在 app mudule 中使用 implement 依赖的第三方库, 在其他 mudule 是无法调用的.<br>举例 : 此时项目中有一个 mudule 是 ImageLoader ,其内部用 implement 指令依赖了 glide 这个库, 那么此时我们在 app mudule 中无法调用 glide 库中的方法.</p><p>##compile<br>概念: android studio 3.0 版本后废弃该指令 改用 api 代替, api 完全等同于之前的 compile 指令, 也就是普通的依赖, 第三方库在 mudule 中依赖后其他 mudule 都可以使用该库.<br>官方推荐在不影响的前提下优先使用 implement 指令依赖.</p><h2 id="iml文件"><a href="#iml文件" class="headerlink" title=".iml文件"></a>.iml文件</h2><p>iml是 intellij idea的工程配置文件，里面是当前project的一些配置信息<br>可以配置不输出文件夹。</p><h2 id="build文件夹中的generated-intermediates"><a href="#build文件夹中的generated-intermediates" class="headerlink" title="build文件夹中的generated intermediates"></a>build文件夹中的generated intermediates</h2><p>成功build后会产生以下文件夹：<br><strong>generated</strong>：<br>The “<strong>generated</strong>“ folder contains java code generated by Android Studio for the module. The primary file here is “<strong>R.java</strong>“ which assigns symbolic names to each of the items in the “res” directory so they can be referenced in java source code.<br><strong>intermediates</strong>：<br>The “<strong>intermediates</strong>“ folder contains individual files that are created during the build process and which are eventually combined to produce the “apk” file.</p><h2 id="Android视图与Project视图"><a href="#Android视图与Project视图" class="headerlink" title="Android视图与Project视图"></a>Android视图与Project视图</h2><p><strong>Project视图</strong>：<br>Project视图是真实的文件结构，真实文件就是这么存放的。<br><strong>Android视图</strong>:<br>可以说是<strong>build成功</strong>后根据配置信息，生成的结构。结构与配置信息有关，与build文件夹有关。不是真实文件的存放方式。其项目树的名字也不一定是真实名字，与配置信息有关。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##implement&lt;br&gt;概念 : 将该依赖隐藏在内部，而不对外部公开。&lt;br&gt;理解 : 在 app mudule 中使用 implement 依赖的第三方库, 在其他 mudule 是无法调用的.&lt;br&gt;举例 : 此时项目中有一个 mudule 是 ImageLoad
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="AndroidStudio" scheme="https://github.com/zdkswd/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow模型持久化</title>
    <link href="https://github.com/zdkswd/2018/05/25/Tensorflow%E6%A8%A1%E5%9E%8B%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2018/05/25/Tensorflow模型持久化/</id>
    <published>2018-05-25T11:00:56.000Z</published>
    <updated>2018-05-25T11:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化代码实现"><a href="#持久化代码实现" class="headerlink" title="持久化代码实现"></a>持久化代码实现</h2><p>通过<strong>tf.train.Saver类</strong>来保存和还原一个神经网络，模型文件目录下会出现三个文件。这是因为Tensorflow会将计算图的结构和图上参数取值分开保存。</p><ol><li><strong>model.ckpt.meta</strong>,保存了计算图的结构。</li><li><strong>model.ckpt</strong>,保存程序中每一个变量的取值。</li><li><strong>checkpoint</strong>,保存了一个目录下所有的模型文件列表。</li></ol><p>加载已经保存的Tensorflow模型方法。1.使用和保存模型代码中一样的方法来声明变量。2.加载已经保存的模型。<strong>sever.restore(sess,”.ckpt”)</strong></p><p>加载模型的程序也是定义了Tensorflow计算图上的所有运算，并声明了一个tf.train.Saver类。区别在于加载模型的代码中没有运行变量的初始化过程而是将变量的值通过已经保存的模型加载了进来。也可以直接加载已经持久化的图<br><strong>saver=tf.train.import_meta_graph(…..meta)</strong></p><p>函数<strong>tf.get_default_graph().get_tensor_by_name(“add:0”)</strong>可以通过张量的名称获取张量。</p><p>也可以声明tf.train.Saver类时提供一个列表指定需要保存或者加载的变量。同样可以在保存和加载时使用字典给变量重命名。</p><p>使用Saver会保存运行程序所需的全部信息，然而有时不需要某些信息。在测试或者离线预测时，不需要某些辅助节点的信息。且多个文件存储时也并不方便。<strong>convert_variables_to_constants</strong>将计算图中的变量及其取值通过常亮保存。<br>导出当前计算图的GraphDef部分只需要这一部分就可以完成从输入层到输出层的计算过程。</p><blockquote><p>graph_def=tf.get_default_graph().as_graph_def()</p></blockquote><p>将图中的变量及其取值转化为常量，同时将图中不必要的节点去掉。一些如变量初始化操作的系统运算也会被转化为计算图的节点。可以通过【】指定需要保存的操作。</p><blockquote><p>output_graph_def=graph_util.convert_variables_to_constants(sess,graph_def,[‘add’])//add为节点名</p></blockquote><p>将导出模型存入文件：</p><blockquote><p>with tf.gfile.GFile(“…pb”,”wb”) as f:<br>　　f.write(output_graph_def.SerialzeToString())</p></blockquote><p>加载模型：</p><blockquote><p>with gflie.FastGFile(model_filename//.pb,’rb’) as f:<br>　　graph_def=tf.GraphDef()<br>　　graph_def.ParseFromString(f.read())<br>result=tf.import_graph_def(graph_def,return_elements=[“add:0”])//add:0为一个张量<br>sess.run(result)</p></blockquote><h2 id="Saver持久化原理及数据格式"><a href="#Saver持久化原理及数据格式" class="headerlink" title="Saver持久化原理及数据格式"></a>Saver持久化原理及数据格式</h2><p>Tensorflow通过元图（<strong>MetaGraph</strong>）来记录计算图中节点信息以及运行计算图中节点所需要的元数据。<br>由Protocol Buffer定义，记录了五类信息：</p><ol><li><strong>meta_info_def</strong>属性,记录计算图中的元数据以及所有使用到运算方法的信息。</li><li><strong>graph_def</strong>属性，记录计算图的节点信息。</li><li><strong>saver_def</strong>属性，记录了持久化模型时需要用到的一些参数。</li><li><strong>collection_def</strong>属性维护集合的底层实现是通过collection_def这个属性。<br>5 <strong>signature_def</strong>属性。</li></ol><p><strong>model.ckpt</strong>保存所有变量的取值，通过SSTable格式存储，大致为一个（key，value）列表。<br><strong>checkpoint</strong>是Saver类自动生成自动维护的。当某个保存的TensorFlow模型文件被删除时，这个模型对应的文件名也会从checkpoint文件中删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;持久化代码实现&quot;&gt;&lt;a href=&quot;#持久化代码实现&quot; class=&quot;headerlink&quot; title=&quot;持久化代码实现&quot;&gt;&lt;/a&gt;持久化代码实现&lt;/h2&gt;&lt;p&gt;通过&lt;strong&gt;tf.train.Saver类&lt;/strong&gt;来保存和还原一个神经网络，模型文
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="TensorFlow" scheme="https://github.com/zdkswd/tags/TensorFlow/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bazel 和Protocol Buffer</title>
    <link href="https://github.com/zdkswd/2018/05/25/Bazel%20%E5%92%8CProtocol%20Buffer/"/>
    <id>https://github.com/zdkswd/2018/05/25/Bazel 和Protocol Buffer/</id>
    <published>2018-05-25T11:00:56.000Z</published>
    <updated>2018-05-25T11:01:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h2><p>Bazel是一个类似于Make的编译工具，是Google为其内部软件开发的特点量身定制的工具，如今Google使用它来构建内部大多数的软件。Google认为直接用Makefile构建软件速度太慢，结果不可靠，所以构建了一个新的工具叫做Bazel，Bazel的规则层级更高。</p><h2 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h2><p>Protocol Buffer是谷歌开发的处理结构化数据的工具。解决结构数据在信息持久化或网络传输时需要进行序列化以及还原数据的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bazel&quot;&gt;&lt;a href=&quot;#Bazel&quot; class=&quot;headerlink&quot; title=&quot;Bazel&quot;&gt;&lt;/a&gt;Bazel&lt;/h2&gt;&lt;p&gt;Bazel是一个类似于Make的编译工具，是Google为其内部软件开发的特点量身定制的工具，如今Google使用它
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="TensorFlow" scheme="https://github.com/zdkswd/tags/TensorFlow/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Gradle</title>
    <link href="https://github.com/zdkswd/2018/05/20/Gradle/"/>
    <id>https://github.com/zdkswd/2018/05/20/Gradle/</id>
    <published>2018-05-20T09:28:56.000Z</published>
    <updated>2018-05-20T09:42:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="差异管理"><a href="#差异管理" class="headerlink" title="差异管理"></a>差异管理</h2><p>说到多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说国内某团购网站的Android App有100多个渠道.这里出现了什么?重复,反复的去打包而且这些包之前的差异很小(只是渠道号不同),和写代码一样我们应该复用,通过Gradle可以实现一个命令打出所有的渠道包,一个命令打出指定的渠道包.再复杂一点,你可能需要不同的渠道对应不同的签名文件,不同的icon,不同的服务器地址…这些都可以通过Gradle来方便的实现.</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理:"></a>依赖管理:</h2><p>做软件开发你可能需要依赖各种不同的jar,library.你当然可以通过将.jar/library工程下载到本地再copy到你的工程中,但不知你是否听说过国外有个叫中央仓库的东西,在这个仓库里你可以找到所有你能想到以及你从来没听说过的jar,aar…The Central Repository Search Engine 这里可以找到所有你需要的依赖,而你需要的只是指定一个坐标,如下:<br>compile’com.squareup.picasso:picasso:2.3.3<br>剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:<br>剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:</p><ol><li>依赖不会进入到你的版本控制仓库中(默认会缓存到~/.gradle/下)</li><li>方便卸载装载依赖(只是一条坐标依赖,不需要删除即可)</li><li>方便的版本管理,如上图中的2.3.3既是picasso的版本号,若改为+就表示从中央仓库中下载最新的版本</li><li>不同工程的相同依赖不会存在重复副本(只在~/.gradle下存在一份)<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2>这方面我没怎么接触过,但据我所知通过一些插件,可以实现自动将你的输出(.jar,.apk,.war…)上传到指定仓库,自动部署…</li></ol><h2 id="Gradle概念"><a href="#Gradle概念" class="headerlink" title="Gradle概念"></a>Gradle概念</h2><p>Gradle，这是一个基于 JVM 的富有突破性<strong>构建工具</strong>。<br>Gradle不单单是一个配置脚本，它的背后是三门语言。<br>    ◦    Groovy Language<br>    ◦    Gradle DSL<br>    ◦    Android DSL<br><strong>DSL</strong>的全称是Domain Specific Language，即领域特定语言。</p><h2 id="The-Gradle-wrapper"><a href="#The-Gradle-wrapper" class="headerlink" title="The Gradle wrapper"></a>The Gradle wrapper</h2><p>Gradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。</p><h2 id="Gradle构建基础"><a href="#Gradle构建基础" class="headerlink" title="Gradle构建基础"></a>Gradle构建基础</h2><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><p>一个项目中会有一个project build.gradle。与若干个module build.gradle.<br>你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本。</p><h3 id="project与task"><a href="#project与task" class="headerlink" title="project与task"></a>project与task</h3><p>Gradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等。插件本身就是包含了若干Task的。</p><h2 id="Gradle脚本的执行时序"><a href="#Gradle脚本的执行时序" class="headerlink" title="Gradle脚本的执行时序"></a>Gradle脚本的执行时序</h2><ol><li><p><strong>初始化</strong>，分析有哪些module将要被构建，为每个module创建对应的 project实例。这个时候settings.gradle文件会被解析。</p></li><li><p><strong>配置</strong>,处理所有的模块的 build 脚本，处理依赖，属性等。这个时候每个模块的build.gradle文件会被解析并配置，这个时候会构建整个task的链表（这里的链表仅仅指存在依赖关系的task的集合，不是数据结构的链表）。先是project build.gradle后是module build.gradle,且从依赖树的叶节点执行。<strong>配置完了以后，有一个重要的回调project.afterEvaluate，它表示所有的模块都已经配置完了，可以准备执行task了。</strong></p></li><li><p><strong>执行</strong>，根据task链表来执行某一个特定的task，这个task所依赖的其他task都将会被提前执行。</p></li></ol><h2 id="Groovy基础-原创：任玉刚"><a href="#Groovy基础-原创：任玉刚" class="headerlink" title="Groovy基础[原创：任玉刚]"></a>Groovy基础[原创：任玉刚]</h2><h3 id="Groovy和Java的关系"><a href="#Groovy和Java的关系" class="headerlink" title="Groovy和Java的关系"></a>Groovy和Java的关系</h3><p>Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。</p><h3 id="Groovy的变量和方法声明"><a href="#Groovy的变量和方法声明" class="headerlink" title="Groovy的变量和方法声明"></a>Groovy的变量和方法声明</h3><p>在Groovy中，通过 def 关键字来声明变量和方法。</p><blockquote><p>def a = 1<br>def b = “hello world”<br>def int c = 1</p></blockquote><blockquote><p>def hello() {<br>    println “hello world” // 方法调用省略括号<br>    1;                    // 方法返回值省略return<br>}<br>def hello(String msg) {<br>    println (msg)<br>}</p></blockquote><blockquote><p>// 方法省略参数类型<br>int hello(msg) {<br>    println (msg)<br>    return 1<br>}</p></blockquote><blockquote><p>// 方法省略参数类型<br>int hello(msg) {<br>    println msg<br>    return 1 // 这个return不能省略<br>    println “done”<br>}</p></blockquote><h3 id="Groovy的数据类型"><a href="#Groovy的数据类型" class="headerlink" title="Groovy的数据类型"></a>Groovy的数据类型</h3><ol><li><p><strong>String</strong>,用于字符串拼接。</p></li><li><p><strong>闭包</strong>，Groovy中有一种特殊的<strong>类型</strong>，叫做<strong>Closure</strong>，翻译过来就是闭包，这是一种类似于C语言中函数指针的东西。闭包用起来非常方便，在Groovy中，闭包作为一种特殊的数据类型而存在，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在。</p></li></ol><p>声明闭包</p><blockquote><p>{ parameters -&gt;<br>    code<br>}</p></blockquote><ol start="3"><li><p><strong>List和Map</strong>,Groovy加强了Java中的集合类，比如List、Map、Set等.List还有一种看起来很奇怪的操作符&lt;&lt;，表示向List中添加新元素的意思.</p></li><li><p><strong>加强的IO</strong>.</p></li></ol><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li>所有的Class类型，都可以省略.class</li><li>只要有属性就有Getter/Setter，反之亦然。</li><li>with操作符<blockquote><p>Book bk = new Book()<br>bk.id = 1<br>bk.name = “android art”<br>bk.press = “china press”</p></blockquote></li></ul><p>可以简写为：</p><blockquote><p>Book bk = new Book()<br>bk.with {<br>    id = 1<br>    name = “android art”<br>    press = “china press”<br>}</p></blockquote><p>等等<a href="http://www.jianshu.com/p/ba55dc163dfd" target="_blank" rel="noopener">http://www.jianshu.com/p/ba55dc163dfd</a></p><h2 id="定义Task"><a href="#定义Task" class="headerlink" title="定义Task"></a>定义Task</h2><blockquote><p>task myTask {<br>    println “config myTask”<br>}</p></blockquote><p>通过上述方式定义的task,括号内部的代码会在配置阶段执行。</p><p>要括号内的代码仅仅在执行我们的task的时候才执行，这个时候可以通过doFirst或者doLast来完成。<br>    •    doFirst：task执行时，最开始的操作<br>    •    doLast：task执行时，最后的操作</p><blockquote><p>myTask.doLast {<br>    println “after execute myTask”<br>}<br>myTask.doFirst {<br>    println “before execute myTask”<br>}</p></blockquote><p>doLast还有一个等价的操作leftShift，leftShift还可以缩写为&lt;&lt;</p><blockquote><p>myTask &lt;&lt; {<br>    println “after execute myTask”<br>}</p></blockquote><p>剩下的细节还是需要大家查看Gradle文档，其实学习Gradle就是一个查文档的过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;差异管理&quot;&gt;&lt;a href=&quot;#差异管理&quot; class=&quot;headerlink&quot; title=&quot;差异管理&quot;&gt;&lt;/a&gt;差异管理&lt;/h2&gt;&lt;p&gt;说到多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="软件构筑" scheme="https://github.com/zdkswd/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E7%AD%91/"/>
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>x86 ARM MIPS NDK JNI 交叉编译 ABI</title>
    <link href="https://github.com/zdkswd/2018/05/19/x86%20ARM%20MIPS%20NDK%20JNI%20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%20ABI/"/>
    <id>https://github.com/zdkswd/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/</id>
    <published>2018-05-19T13:46:56.000Z</published>
    <updated>2018-05-25T10:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="X86和ARM-MIPS架构"><a href="#X86和ARM-MIPS架构" class="headerlink" title="X86和ARM,MIPS架构"></a>X86和ARM,MIPS架构</h2><p>x86架构采用CISC，代表公司Intel。而ARM采用RISC，代表公司ARM。MIPS架构多用在网关、猫、机顶盒等设备。</p><p><strong>X86</strong>以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。x86为此还必须有复杂的分支预测机构，确保流水线的效率。再加上多级cache，支持超线程、虚拟化等等，x86的复杂度其实相当高<br><strong>ARM</strong>（Advanced RISC Machines）一个32位元精简指令集(RISC)处理器架构<br>可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。<br>但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。 </p><p><strong>扩展性</strong><br>X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，<br>x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。<br>ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行</p><p><strong>功耗</strong><br>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度，考虑其完成复杂操作的能力，功耗很大。<br>ARM则功耗很低。<br>ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场，<strong>ARM目前是移动处理器的老大</strong>；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 <strong>x86是PC端老大</strong>。</p><h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><p>Native Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C/C++的动态库，并能自动将so和java一起打包成apk。<strong>NDK就是帮助我们可以在Android应用中使用C/C++来完成特定功能的一套工具.</strong>NDK的作用有很多，我们简单的列举两个:<br>1.首先NDK可以帮助开发者“快速”开发C(或C++)的动态库。<br>2.其次，NDK集成了“<strong>交叉编译器</strong>”。使用NDK，我们可以将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。</p><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>Java Native Interface（JNI）标准是java平台的一部分，JNI是Java语言提供的Java和C/C++相互沟通的机制，其实JNI它就是一种<strong>协议</strong>,Java可以通过JNI调用C/C++代码，C/C++的代码也可以调用java代码。</p><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>编译器在将中间代码连接成当前计算机可执行的二进制程序时，连接程序会根据当前计算机的CPU、操作系统的类型来转换。<br><strong>交叉编译</strong>就是在一个平台下（比如：CPU架构为X86，操作系统为Windows）编译出在另一个平台上（比如：CPU架构为arm,操作系统为Linux）可以执行的二进制代码。Google提供的NDK就可以完成交叉编译的工作。【Android：基于Linux 内核arm架构的操作系统，装在arm上的linux是需要重新编译内核的 所以和x86上的linux内核是不一样的】</p><h2 id="Android-设备的CPU类型-通常称为”ABIs”"><a href="#Android-设备的CPU类型-通常称为”ABIs”" class="headerlink" title="Android 设备的CPU类型(通常称为”ABIs”)"></a>Android 设备的CPU类型(通常称为”ABIs”)</h2><ol><li>armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的部分Android设备都使用它.</li><li>arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。</li><li>armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。</li><li>x86: 平板、模拟器用得比较多。</li><li>x86_64: 64位的平板。  </li></ol><p>arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so，那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了，所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，所以要么你别加arm64-v8a,要么armeabi里面有的so库，arm64-v8a里面也必须有。</p><p><strong>对策</strong>：</p><ul><li>为了减小 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中.so数量一致   </li><li>对只提供 armeabi 版本的第三方 .so，原样复制一份到 armeabi-v7a 文件夹   </li></ul><p>应用程序二进制接口（<strong>A</strong>pplication <strong>B</strong>inary <strong>I</strong>nterface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。 </p><p>当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支持armeabi-v7a和armeabi）。<br>我们往往很容易对.so文件<strong>应该放在或者生成到哪里</strong>感到困惑，下面是一个总结：Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;X86和ARM-MIPS架构&quot;&gt;&lt;a href=&quot;#X86和ARM-MIPS架构&quot; class=&quot;headerlink&quot; title=&quot;X86和ARM,MIPS架构&quot;&gt;&lt;/a&gt;X86和ARM,MIPS架构&lt;/h2&gt;&lt;p&gt;x86架构采用CISC，代表公司Intel。
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="计算机科学" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
      <category term="c/c++" scheme="https://github.com/zdkswd/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>lib dll .h .hpp 预编译</title>
    <link href="https://github.com/zdkswd/2018/05/17/lib,dll,.h,.hpp,%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <id>https://github.com/zdkswd/2018/05/17/lib,dll,.h,.hpp,预编译/</id>
    <published>2018-05-17T13:46:56.000Z</published>
    <updated>2018-05-17T13:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静态库动态库"><a href="#静态库动态库" class="headerlink" title="静态库动态库"></a>静态库动态库</h2><p>静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15265538206394/15265538778964.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15265538206394/15265538810589.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>是动态链接有一个缺点就是可移植性太差，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>编译时，编译器通过头文件.h找到对应的函数库，预编译时将整个.h文件插入目标文件头部，项目中需要有其对应的.c文件进行编译生成中间文件进行连接。<br>.hpp，本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数</p><p>一个头文件被别的源文件重复包含是经常发生的，如何避免某个头文件被重复包含呢？利用条件编译轻松解决。在头文件的开始加入：</p><blockquote><p>#ifndef HEADER_NAME<br>#define HEADER_NAME </p></blockquote><p>在头文件的结尾加上：</p><blockquote><p>#endif</p></blockquote><h2 id="C-C-中的预编译指令"><a href="#C-C-中的预编译指令" class="headerlink" title="C/C++中的预编译指令"></a>C/C++中的预编译指令</h2><p>程序的编译过程可以分为预处理、编译、汇编三部分，其中预处理是首先执行的过程，预处理过程扫描程序源代码，对其进行初步的转换，产生新的源代码提供给编译器。</p><ol><li><strong>#include</strong>指令，#include预处理指令的作用是在指令处展开被包含的文件。<br>#include \&lt;xxx.h&gt;<br>#include “xxx.h”<br>第一种方法将待包含的头文件使用尖括号括起来，预处理程序会在系统默认目录或者括号内的路径查找，通常用于包含系统中自带的公共头文件。<br>第二种方法将待包含的头文件使用双引号引起来，预处理程序会在程序源文件所在目录查找，如果未找到则去系统默认目录查找，通常用于包含程序作者编写的私有头文件。  </li></ol><p>2.<strong>#define、#undef</strong>指令,#define指令定义了一个标识符及一个串，标识符称为宏名，源程序中宏名的每次出现都会用其定义的串进行替换，称为宏替换。<br>#undef指令取消一个已定义的宏。  </p><p>3.<strong>#if、#elif、#else、#endif</strong>指令，这几个指令称为条件编译指令，可对程序源代码的各部分有选择地进行编译。<br>跟一般的if、else if、else语句类似，如果一个条件上的值为真，则编译它对应的代码，否则提过这些代码，测试下一个条件上的值是否为真。注意，作为条件的表达式是在编译时求值的，它必须仅含常量及已定义过的标识符，不可使用变量，也不可以含有操作符sizeof（sizeof也是编译时求值）。<br>感觉这主要是用来设置一个宏选择性的编译一部分的代码。  </p><p>4.<strong>#ifdef、#ifndef、#endif</strong>指令，这几个也是条件编译指令，其检查后面指定的宏是否已经定义，然后根据检查结果选择是否要编译后面语句。其中#ifdef表示”如果有定义“，#ifndef表示”如果没有定义“。这个通常可以用于防止重复包含头文件的问题</p><blockquote><p>#ifndef MYHEAD_H<br>#define MYHEAD_H<br>#include “myHead.h”<br>#endif  </p></blockquote><p>5.<strong>#line</strong>指令,C语言中可以使用<strong>FILE</strong>表示本行语句所在源文件的文件名，使用<strong>LINE</strong>表示本行语句在源文件中的位置信息。#line指令可以重新设定这两个变量的值，其语法格式为<br>#line number[“filename”] </p><p>6.<strong>#error</strong>指令,#error指令在编译时输出编译错误信息，可以方便程序员检查出现的错误。</p><p>7.<strong>#pragma</strong>指令,该指令用来来设定编译器的状态或者是指示编译器完成一些特定的动作，它有许多不同的参数。<br>7.1. #pragma once<br>在头文件的最开始加入这条指令可以保证头文件只被编译一次。它可以实现上述使用#ifndef实现不重复包含头文件同样的功能，但可能会有部分编译系统不支持。</p><p>7.2.#pragma message<br>该指令能够让编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。</p><p>7.3.#pragma warning<br>…等等其他参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;静态库动态库&quot;&gt;&lt;a href=&quot;#静态库动态库&quot; class=&quot;headerlink&quot; title=&quot;静态库动态库&quot;&gt;&lt;/a&gt;静态库动态库&lt;/h2&gt;&lt;p&gt;静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机科学" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
      <category term="c/c++" scheme="https://github.com/zdkswd/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow可视化</title>
    <link href="https://github.com/zdkswd/2018/05/17/Tensorflow%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2018/05/17/Tensorflow可视化/</id>
    <published>2018-05-17T10:11:41.000Z</published>
    <updated>2018-05-25T11:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tensorflow计算模型–计算图"><a href="#Tensorflow计算模型–计算图" class="headerlink" title="Tensorflow计算模型–计算图"></a>Tensorflow计算模型–计算图</h2><h3 id="计算图的使用"><a href="#计算图的使用" class="headerlink" title="计算图的使用"></a>计算图的使用</h3><p>tensorflow程序可分为两个阶段，第一阶段定义图中所有的计算。第二阶段为执行阶段。<br>tensorflow中，系统会自动维护一个默认的计算图，通过<strong>tf.get_default_graph</strong>函数可以获取当前默认的计算图。<br>除了使用默认的计算图，Tensorflow支持通过<strong>tf.Graph</strong>函数来生成新的计算图。不同计算图上的张量和运算都不会共享。<br>计算图可以通过<strong>tf.Graph.device</strong>函数来指定运行计算的设备。<br>有效地整理TensorFlow程序的资源也是计算图的一个重要功能。在一个集合（collection）来管理不同类型的资源。</p><table><thead><tr><th>集合名称</th><th>集合内容</th><th>使用场景</th></tr></thead><tbody><tr><td>tf.GraphKeys.VARIABLES</td><td>所有变量</td><td>持久化Tensorflow模型</td></tr><tr><td>tf.GraphKeys.TRAINABLE_VARIABLES</td><td>可学习的变量（一般指神经网络中的参数）</td><td>模型训练、生成模型可视化内容</td></tr><tr><td>tf.GraphKeys.SUMMARIES</td><td>日志生成的相关的张量</td><td>TensorFlow计算可视化</td></tr><tr><td>tf.GraphKeys.QUEUE_RUNNERS</td><td>处理输入的QueueRunner</td><td>输入处理</td></tr><tr><td>tf.GraphKeys.MOVING_AVERAGE_VARIABLES</td><td>所有计算了滑动平均值的变量</td><td>计算变量的滑动平均值</td></tr></tbody></table><p>如通过<strong>tf.add_to_collection</strong>将资源加入一个或多个集合中。通过<strong>tf.get_collection</strong>获取一个集合里面的所有资源。</p><h2 id="TensorBoard可视化"><a href="#TensorBoard可视化" class="headerlink" title="TensorBoard可视化"></a>TensorBoard可视化</h2><h3 id="TensorBoard简介"><a href="#TensorBoard简介" class="headerlink" title="TensorBoard简介"></a>TensorBoard简介</h3><p>TensorBoard可以通过TensorFlow程序运行过程中输出的日志文件可视化TensorFlow程序的运行状态。两者跑在不同进程中，TensorBoard会自动读取TensorFlow最新的日志文件。</p><blockquote><p>#运行TensorBoard，将地址执行日志输出地址<br>tensorboard –logdir=/path/to/log</p></blockquote><p>命令启动服务默认端口号6006，localhost:6006可以看到界面。使用–port参数可以改变启动服务的端口。</p><h2 id="变量管理"><a href="#变量管理" class="headerlink" title="变量管理"></a>变量管理</h2><p>TensorFLow提供了通过变量名称来创建或者获取一个变量的机制。通过这个机制在不同的函数中可以直接通过变量的名称来使用变量，而不需要将变量通过参数的形式到处传递。TensorFLow中通过变量名称获取变量的机制主要是通过<strong>tf.get_variable</strong>和<strong>tf.variable_scope</strong>函数实现。</p><p>v.get_variable和tf.Variable定义等价。区别在于前者变量名称是个必填项，后者是个选填项。v.get_variable会根据这个名字去创建或者获取变量。首先会试图创建一个变量，如有同名则创建失败。如果需要通v.get_variable获取一个已经创建的变量，<strong>需要tf.variable_scope函数生成一个上下文管理器。将参数reuse设置为True</strong>(获取唯一途径)，v.get_variable将<strong>只能</strong>获取已经创建过的变量。否则将尝试创建变量。</p><blockquote><p>with v.variable_scope(“name”,reuse=”True”):<br>      v=v.get_variable(“var”,[1])</p></blockquote><p><strong>tf.variable_scope会创建一个命名空间。</strong>foo/v:0 “:0”表示这个变量是生成变量这个运算的第一个结果。</p><h2 id="TensorFlow计算图可视化"><a href="#TensorFlow计算图可视化" class="headerlink" title="TensorFlow计算图可视化"></a>TensorFlow计算图可视化</h2><h3 id="命名空间与TensorBoard图上节点"><a href="#命名空间与TensorBoard图上节点" class="headerlink" title="命名空间与TensorBoard图上节点"></a>命名空间与TensorBoard图上节点</h3><p>变量的初始化过程也会产生新的计算节点。为了更好的组织可视化效果图中的计算节点，TensorBoard支持通过TensorFlow命名空间来整理可视化效果图上的节点。在Tensorflow默认视图中同一命名空间计算图为一个节点，只有顶层命名空间的节点显示。<br>除了tf.Variable_scope函数，tf.name_scope函数也提供了命名空间管理的功能，两者大部分情况下等价。唯一的区别是tf.get_Variable不受tf.name_scope函数的影响。即在tf.name_scope域里tf.get_Variable生成变量也不是域内的变量。<br>节点之间有两种不同的边，一种是通过实线表示的，刻画了数据传输，箭头表示传输方向。另一种箭头是双向的，表示会修改，会互相影响。<br>TensorBoard边上标注了张量的维度信息。如100*784说明batch为100，输入节点个数为784，粗细代表维度的总大小。若张量数量大于1时。图上将只显示张量的个数。<br>虚线表示计算之间的依赖关系，如tf.control_dependencies函数指定操作同时进行。则存在虚线。<br>TensorBoard会自动将连接比较多的节点放在辅助图中，可以手动移入主图或移出主图。TensorBoard不会保存用户对计算图可视化结果的手工修改，页面刷新之后计算图可视化结果又会回到最初的样子。</p><h3 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h3><p>使用TensorBoard可以非常直观地展现所有Tensorflow计算节点在某一次运行时所消耗的时间和内存。</p><blockquote><p>run_options =tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)<br>// 运行时记录运行信息的proto。<br>run_metadata = tf.RunMetadata()<br>   m, loss_value, step = sess.run(<br>                    [train_op, loss, global_step], feed_dict={x: xs, y_: ys},<br>                    options=run_options, run_metadata=run_metadata)<br>                    //将节点在运行时的信息写入日志文件。          writer.add_run_metadata(run_metadata=run_metadata,tag=(“tag%d” % i),global_step=i)</p></blockquote><p>使用程序输出的日志启动TensorBoard,就可以了。进入GRAPHS栏，选择Session runs,Color会出现Compute time和Memory这两个选项。颜色越深消耗越大。Structure中如果有两个节点结构相同就会涂上相同的颜色。Device中可显示哪些使用了相同的设备（CPU/GPU）。<br>点击节点时弹出的信息卡片也会显示这个节点的各种信息。</p><h2 id="监控指标可视化"><a href="#监控指标可视化" class="headerlink" title="监控指标可视化"></a>监控指标可视化</h2><table><thead><tr><th>TensorFlow日志生成函数</th><th>TensorBoard界面栏</th><th>显示内容</th></tr></thead><tbody><tr><td>tf.scalar_summary</td><td>EVENTS</td><td>TensorFlow中标量（scalar）监控数据随着迭代进行的变化趋势。</td></tr><tr><td>tf.image_summary</td><td>IMAGES</td><td>TensorFlow中使用的图片数据，这一栏一般用于可视化当前使用的训练/测试图片。</td></tr><tr><td>tf.audio_summary</td><td>AUDIO</td><td>TensorFlow中使用的音频数据。</td></tr><tr><td>tf.histogram_summary</td><td>HISTOGRAMS</td><td>TensorFlow中张量分布监控数据随着迭代轮次的变化趋势。</td></tr></tbody></table><p>上述生成函数都不会立即执行，需要通过sess.run来明确调用这些函数。tf.merge_all_summaries()可将定义的所有日志文件执行一次。</p><h2 id="writer"><a href="#writer" class="headerlink" title="writer"></a>writer</h2><blockquote><p>writer=tf.train.SummaryWriter(path,tf.get_default_graph())<br>writer.close()　　</p></blockquote><p>或者</p><blockquote><p>with tf.Session() as sess:<br>　　writer=tf.train.SummaryWriter(path,sess.graph)</p></blockquote><p><strong>上述比较过时，若报错则改为writer = tf.summary.FileWriter(“output”, sess.graph)</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tensorflow计算模型–计算图&quot;&gt;&lt;a href=&quot;#Tensorflow计算模型–计算图&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow计算模型–计算图&quot;&gt;&lt;/a&gt;Tensorflow计算模型–计算图&lt;/h2&gt;&lt;h3 id=&quot;计
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="TensorFlow" scheme="https://github.com/zdkswd/tags/TensorFlow/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>[Linux内核设计与实现]进程调度</title>
    <link href="https://github.com/zdkswd/2018/05/15/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>https://github.com/zdkswd/2018/05/15/进程调度/</id>
    <published>2018-05-15T13:39:12.000Z</published>
    <updated>2018-05-16T11:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>现代Linux系统也许有100个进程在内存，但是只有一个处于可运行状态。<br>Linux是抢占式多任务模式。</p><h2 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h2><p>Linux2.5内核开始采用O（1）调度程序，对大服务器工作负载很理想但对于交互性桌面系统表现不佳。<br>2.6.23内核后使用RSDL增加了交互性，此时被称为CFS（完全公平调度算法）</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="I-O消耗型和处理器消耗型的进程"><a href="#I-O消耗型和处理器消耗型的进程" class="headerlink" title="I/O消耗型和处理器消耗型的进程"></a>I/O消耗型和处理器消耗型的进程</h3><p>GUI属于I/O消耗型，多数时间都在等待键鼠交互操作。<br>应当降低处理器消耗型的调度频率，以延长其运行时间。<br>Linux更倾向于IO消耗型进程，也并未忽略处理器消耗型进程。</p><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>Linux采用了两种不同范围的优先级范围。<br>1：使用nice值，范围【-20，19】，默认0，越大优先级越低。Linux nice代表时间片比例，mac os nice代表时间片的绝对值。<br>2：实时优先级，其值可配。范围【0，99】，越高优先级越大。任何实时进程优先级都高于普通进程。</p><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>Linux的CFS调度器并没有直接分配时间片到进程，将处理器的使用比划分给了进程。进程所获处理器的时间和负载密切相关。受nice值得影响。<br>Linux的CFS调度器抢占时机取决于进程的处理器使用比，若大于当前进程则抢占。</p><h3 id="调度策略的活动"><a href="#调度策略的活动" class="headerlink" title="调度策略的活动"></a>调度策略的活动</h3><p>对于一个文字编辑程序和一个视频处理程序，一般操作系统会分配文字编辑器更高的优先级和更多的时间片。Linux则是nice值相同，即平分50%时间，但是当文字编辑程序要使用处理器时，CFS发现其时间没到50%，会抢占视频处理程序执行。</p><h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>Linux调度器是模块方式，可以针对不同类型的进程选择合适的调度算法。<br>完全公平调度（CFS）是针对普通进程的调度类。</p><h3 id="Unix系统的进程调度"><a href="#Unix系统的进程调度" class="headerlink" title="Unix系统的进程调度"></a>Unix系统的进程调度</h3><p>CFS完全摒弃时间片而是分配进程一个处理器的使用比重，这样CFS确保了进程调度有恒定的公平性，将切换频率置于不断变动中。</p><h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p>CFS的最小粒度（最小时间片长度）为1ms，时间片分配时间根据目标延迟以及nice值决定的比例计算而得。所以说其实如果进程无限大的话，改法并不公平。但是能保证正常情况下是公平的。</p><h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h3><p> 所有的调度器都必须对进程运行时间做记账。</p><ol><li><strong>调度器实体结构</strong>,CFS不再有时间片的概念，但是它也必须维护每个进程运行时间记账，为了确保每个进程只在公平分配给它的处理器时间运行。CFS使用调度器实体结构struct sched_entity作为名为se的成员变量，嵌入进程描述符struct task_struct内。  </li><li><strong>虚拟实时</strong>，struct sched_entity结构中的vruntime变量存放进程的虚拟运行时间，虚拟时间是以ns为单位的，与定时器节拍不再相关。vruntime可以准确地测量给定进程的运行时间，而且可知道谁应该是下一个被运行的进程。</li></ol><h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h3><p>当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。<br>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小的vruntime值的进程。红黑树是一种以树节点形式存储的数据，这些数据都对应一个键值，可通过键值快速检索节点上的数据。</p><ol><li><strong>挑选下一个任务</strong>，CFS调度器选取待运行的下一个进程，是所有进程中vruntime最小的那一个，对应的便是树最左侧的叶子节点。   </li><li><strong>向树中加入进程</strong>，CFS如何将进程加入rbtree中，以及如何缓存最左叶子节点。这一切发生在进程变为可运行状态（被唤醒）或是通过fork()调用第一次创建进程时。enqueue_entity()函数实现了这一目的。改函数更新运行时间和其他一些统计数据，然后调用_enqueue_entity()进行繁重的插入操作，把数据项真正插入到红黑树中。</li><li><strong>从树中删除进程</strong>, 删除动作发生在进程堵塞或者终止时。<h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h3>进程调度的主要入口点是函数schedule()，它会找到一个最高优先级的调度类，其需要有自己的可运行队列。<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3>休眠（被阻塞）进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程刚好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。</li><li><strong>等待队列</strong>， 等待队列是由等待某些事件发生的进程组成的简单链表。</li><li><strong>唤醒</strong>， 唤醒指定等待队列上的所有进程。<h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2>上下文切换，就是从一个可执行进程切换到另一个可执行的进程。由函数context_switch()负责，每当新的进程被选出来准备投入运行时，schedule()就会调用该函数。内核提供了一个need_resched标志表明是否需要重新执行一次调度，内核也就知道什么时候调用schedule()。当某个进程应该被抢占或优先级高的进程进入可执行状态时或中断返回或系统调用返回用户空间，会设置标志位。<h3 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h3>内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。即用户抢占发生在</li></ol><ul><li>从系统调用返回用户空间时。     </li><li>从中断处理程序返回用户空间时。  </li></ul><h3 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h3><p>Linux完整地支持内核抢占，只要重新调度是安全的，内核就可以在任何时候抢占正在执行的内核任务。安全即没有持有锁，即preempy_count=0且need_resched被设置，中断返回内核空间时，就可调度。同样若内核阻塞或显式调用schedule()也会显式抢占。</p><h2 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h2><p>Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的非实时的调度策略是SCHED_NORMAL.这些策略被一个特殊的实时调度器管理。</p><ol><li><strong>SCHED_FIFO</strong>, 不基于时间片，可以一直执行下去，其比任何SCHED_NORMAL级的进程都先得到调度。更高优先级的SCHED_FIFO或SCHED_RR才能抢占。优先级一样的就轮流执行。</li><li><strong>SCHED_RR</strong>,带有时间片的SCHED_FIFO，耗尽时间片时，只能调度同一优先级的进程。<br>【 <strong>总结</strong>】：对于SCHED_FIFO进程，高优先级总是立即抢占低优先级进程，但低优先级决不能抢占SCHED__RR任务，即使它的时间片耗尽。<br>Linux提供的是软实时工作方式，SCHED_RR与SCHED_FIFO优先级范围【0，99】，而SCHED_NORMAL使用nice值。<h2 id="与调度相关的系统调度"><a href="#与调度相关的系统调度" class="headerlink" title="与调度相关的系统调度"></a>与调度相关的系统调度</h2>Linux提供了一个系统调用族，用于管理与调度程序的相关<strong>参数</strong>。这些系统调用可以用来操作和处理进程优先级、调度策略及处理器绑定，同时还提供了显式地将处理器交给其他进程的机制。<h3 id="与调度策略和优先级相关的系统调用"><a href="#与调度策略和优先级相关的系统调用" class="headerlink" title="与调度策略和优先级相关的系统调用"></a>与调度策略和优先级相关的系统调用</h3>sched_setscheduler()和sched_getscheduler()用于设置和获取进程的调度策略和实时优先级。sched_setparam()和sched_getparam()用于设置和获取进程的实时优先级。<h3 id="与处理器绑定有关的系统调用"><a href="#与处理器绑定有关的系统调用" class="headerlink" title="与处理器绑定有关的系统调用"></a>与处理器绑定有关的系统调用</h3>Linux调度程序提供强制的处理器绑定机制。<h3 id="放弃处理器时间"><a href="#放弃处理器时间" class="headerlink" title="放弃处理器时间"></a>放弃处理器时间</h3>Linux通过sched_yield()系统调用，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多任务&quot;&gt;&lt;a href=&quot;#多任务&quot; class=&quot;headerlink&quot; title=&quot;多任务&quot;&gt;&lt;/a&gt;多任务&lt;/h2&gt;&lt;p&gt;现代Linux系统也许有100个进程在内存，但是只有一个处于可运行状态。&lt;br&gt;Linux是抢占式多任务模式。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="纸质书笔记" scheme="https://github.com/zdkswd/tags/%E7%BA%B8%E8%B4%A8%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>初识makefile_make_cmake</title>
    <link href="https://github.com/zdkswd/2018/04/29/cmake/"/>
    <id>https://github.com/zdkswd/2018/04/29/cmake/</id>
    <published>2018-04-29T14:11:20.000Z</published>
    <updated>2018-05-16T11:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识makefile-make-cmake"><a href="#初识makefile-make-cmake" class="headerlink" title="初识makefile,make,cmake"></a>初识makefile,make,cmake</h1><h2 id="什么是makefile"><a href="#什么是makefile" class="headerlink" title="什么是makefile"></a>什么是makefile</h2><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去<strong>编译</strong>和<strong>链接</strong>程序。<br>makefile关系到了整个工程的编译规则。makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p><h2 id="什么是make"><a href="#什么是make" class="headerlink" title="什么是make"></a>什么是make</h2><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法（包括链接）。</p><h2 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="关于程序的编译和链接"></a>关于程序的编译和链接</h2><p>在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。Linux中的.so。<br>一个lib文件是obj文件的集合。<br>源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码</p><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p><strong>usr</strong>文件夹称为是Unix System Resource，即Unix系统资源的缩写。  </p><p><strong>bin文件夹</strong>是一个二进制程序文件夹<br>1.bin是binary的缩写，代表的意思是二进制，二进制数据是用0和1两个数码来表示的数。<br>2.bin这个文件夹里存放的是二进制可执行的文件，比如exe，msi，com等的都是二进制文件，双击就能运行。  </p><p>GUN下面绝大部分应用的编译系统都是用<strong>automake</strong>。<br>于是乎，你看到的很多很多应用都安装在了/usr/local/目录下<br>然后通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变<br>/usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件<br>安装好的lib文件存放在“/usr/local/lib”文件夹，h文件存放在“/usr/local/include”（Unix）</p><h2 id="什么是cmake"><a href="#什么是cmake" class="headerlink" title="什么是cmake"></a>什么是cmake</h2><p>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。<br>cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15249996372857/15250008307496.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h2><p>dll存在于windows中</p><h2 id="openCV安装过程"><a href="#openCV安装过程" class="headerlink" title="openCV安装过程"></a>openCV安装过程</h2><blockquote><p>mkdir release<br>cd release<br>cmake -D CMAKE_BUILD_TYPE=RELEASE -D 换行CMAKE_INSTALL_PREFIX=usr/local/opencv3.1.0  -G “Unix Makefiles” ..<br>make<br>sudo make install</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初识makefile-make-cmake&quot;&gt;&lt;a href=&quot;#初识makefile-make-cmake&quot; class=&quot;headerlink&quot; title=&quot;初识makefile,make,cmake&quot;&gt;&lt;/a&gt;初识makefile,make,cmake&lt;/
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="软件构筑" scheme="https://github.com/zdkswd/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E7%AD%91/"/>
    
      <category term="计算机科学" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅2017听课笔记1-Where does the error come from?</title>
    <link href="https://github.com/zdkswd/2018/04/25/%E6%9D%8E%E5%AE%8F%E6%AF%85error/"/>
    <id>https://github.com/zdkswd/2018/04/25/李宏毅error/</id>
    <published>2018-04-25T14:48:13.000Z</published>
    <updated>2018-05-16T11:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="李宏毅2017听课笔记1-Where-does-the-error-come-from"><a href="#李宏毅2017听课笔记1-Where-does-the-error-come-from" class="headerlink" title="李宏毅2017听课笔记1-Where does the error come from?"></a>李宏毅2017听课笔记1-Where does the error come from?</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245707424828/15245752316344.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245707424828/15245752454185.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245707424828/15245752497587.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245707424828/15245752535450.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>这么多线是多次试验，每次试验拟合出一条红线</strong> </p><p><img src="/img/media/15245707424828/15245752575393.jpg" alt=""><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245707424828/15245752784321.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>在这里直观的解释了为什么简单的模型偏差更大，因为最终是在函数集中选取最佳函数，因为函数简单的话，一开始划定的范围就较小。</strong></p><p><img src="/img/media/15245707424828/15245752825260.jpg" alt=""><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245707424828/15245753194288.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245707424828/15245753375273.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>正则化会伤害bias，因为只选择更平滑的曲线，相当于划了范围。（其实是让模型更简单了）</strong></p><p><img src="/img/media/15245707424828/15245772661756.jpg" alt=""></p><p><img src="/img/media/15245707424828/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-24%20%E4%B8%8B%E5%8D%889.47.53.png" alt="屏幕快照 2018-04-24 下午9.47.53"><br>分为训练集，验证集，测试集</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;李宏毅2017听课笔记1-Where-does-the-error-come-from&quot;&gt;&lt;a href=&quot;#李宏毅2017听课笔记1-Where-does-the-error-come-from&quot; class=&quot;headerlink&quot; title=&quot;李宏毅201
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="李宏毅" scheme="https://github.com/zdkswd/tags/%E6%9D%8E%E5%AE%8F%E6%AF%85/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅2017听课笔记0</title>
    <link href="https://github.com/zdkswd/2018/04/25/%E6%9D%8E%E5%AE%8F%E6%AF%852017%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B00/"/>
    <id>https://github.com/zdkswd/2018/04/25/李宏毅2017听课笔记0/</id>
    <published>2018-04-25T01:26:25.000Z</published>
    <updated>2018-07-03T02:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="李宏毅2017听课笔记0"><a href="#李宏毅2017听课笔记0" class="headerlink" title="李宏毅2017听课笔记0"></a>李宏毅2017听课笔记0</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前听了吴恩达2014大部分的课以及吴恩达最近在网易云上的CNN课程。<br>听闻李宏毅的课程不错，主要比较系统全面，来听一哈喽。<br><a href="https://blog.csdn.net/soulmeetliang/article/details/77461607" target="_blank" rel="noopener">不错的博客</a></p><h2 id="0-1Introduction"><a href="#0-1Introduction" class="headerlink" title="0-1Introduction"></a>0-1Introduction</h2><p><strong>找出function</strong>  </p><ul><li>准备一个function set  (model)</li><li>机器决定function们的好坏</li><li>找出最好的function</li></ul><p><strong>Deep Learning</strong>：<br>分类，非线性</p><p><strong>Learning Map</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245638704627/15245780453416.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>Reinforcement Learning</strong><br>在实际运用中，以上方法并不能解决全部问题，常常会遇到Beyond Classification的情况，比如语音识别，人脸识别，语言翻译等，那么就要通过增强学习来解决问题。<br>增强学习的一个非常知名的应用就是 google 阿法狗。</p><p><strong>Reinforcement Learning VS Supervised</strong><br>Supervised 就像给了机器一个点读机，他听到一句话时可以看到其含义，每一句话都有标签，就像有一个手把手教他的老师。<br>而Reinforcement Learning 就像跟女朋友对话，反复讲来回讲很多句话，直到女朋友觉得你无言以对愤然离去，机器唯一可以知道的就是他做的好还是不好，除此之外没有任何information。而这更像人类现实生活中的学习过程，必须自己像哪里做得好做得不够好，怎么修正。      </p><p><strong>Learning Map:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15245638704627/15245780740118.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>scenario</strong>:学习情景，不受自己控制。意思是你现在有什么类型的 training data。</p><table><thead><tr><th>machine learning</th><th>scenario</th></tr></thead><tbody><tr><td>Supervised Learning</td><td>有标签data</td></tr><tr><td>Semi-supervised Learning</td><td>部分有标签data</td></tr><tr><td>Unsupervised Learning</td><td>无标签data</td></tr><tr><td>Transfer Learning</td><td>一堆不相干data</td></tr><tr><td>Reinforcement Learning</td><td>只有来自外界的评价</td></tr></tbody></table><p><strong>task</strong>，意思是现在function的output是什么，只体现在supervised中，但其实可以插在以上五种Learning的每一种内。</p><table><thead><tr><th>machine learning</th><th>task(output)</th></tr></thead><tbody><tr><td>Regression</td><td>scalar</td></tr><tr><td>Classification</td><td>class1、class2…之一</td></tr><tr><td>Structured Learning</td><td>有结构的内容</td></tr></tbody></table><p><strong>Method</strong>方法模型，比如在Classification中有Linear模型 or Non-linear模型，我们可以将绿色部分插入任何红色部分中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;李宏毅2017听课笔记0&quot;&gt;&lt;a href=&quot;#李宏毅2017听课笔记0&quot; class=&quot;headerlink&quot; title=&quot;李宏毅2017听课笔记0&quot;&gt;&lt;/a&gt;李宏毅2017听课笔记0&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="李宏毅" scheme="https://github.com/zdkswd/tags/%E6%9D%8E%E5%AE%8F%E6%AF%85/"/>
    
  </entry>
  
  <entry>
    <title>[Linux内核设计与实现]进程管理</title>
    <link href="https://github.com/zdkswd/2018/04/16/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/04/16/进程管理/</id>
    <published>2018-04-16T10:50:51.000Z</published>
    <updated>2018-05-16T11:00:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。<br>进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。<br>父进程调用fork()复制现有进程创建一个全新的进程子进程。</p><p>每个线程都有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。<br>进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。<br>进程的另一个名字是<strong>task</strong>，Linux内核通常把进程也叫做任务。</p><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><p>内核把进程的列表存放在任务列表（task list）的双向循环列表中。链表的每一项都是类型为<strong>task_struct</strong>称为<strong>进程描述符</strong>的结构中，该结构相对较大，包含的数据能够完整的描述一个正在运行的程序：打开的文件，进程地址空间，挂起信号，进程状态及其他。</p><h3 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h3><p>Linux通过slab分配器分配task_struct结构,这样能够对象复用和缓存着色。<br>使用slab动态生成task_struct需要用到结构<strong>thread_info</strong>,其task域有指向实际进程描述符的指针。每个任务的thread_info在它的内核栈的尾端分配。</p><h3 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h3><p>内核通过唯一标识符PID（process indentification value）来标识每个进程，PID存放在进程描述符。为了兼容性设置其为short int型，故其最大值为32768.但是对于大型服务器需要更大值。可以不考虑兼容性修改/proc/sys/kernel/pid_max提高上限。 </p><p>内核访问任务需要获取指向task_struct的指针，故通过宏找到当前正在运行的进程描述符的速度就尤为重要。硬件的结构体系不同，宏的实现不同。例如有的体系结构有专用寄存器用于加快访问task_struct的速度，x86结构寄存器并不富余，就只能通过计算偏移间接查找task_struct。  </p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>task_struct的state域描述当前状态，必为五中之一   </p><ul><li>TASK_RUNNING(运行)在运行或在运行队列等待  </li><li>TASK_INTERRUPIBLE(可中断)被阻塞</li><li>TASK_UNINTERRUPTIBLE（不可中断）接到信号也不会唤醒</li><li>_TASK_TRACED被其他进程跟踪</li><li>_TASK_STOPPED停止执行</li></ul><h3 id="设置当前的进程状态"><a href="#设置当前的进程状态" class="headerlink" title="设置当前的进程状态"></a>设置当前的进程状态</h3><p>调整某个进程状态</p><blockquote><p>set_task_state(task,state);</p></blockquote><h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可执行代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行，一般在用户空间执行，执行系统调用或触发异常陷入内核空间。对内核的访问必须经过明确定义的接口。</p><h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>Linux和Unix一样所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程读取系统初始化脚本（initscript）并执行其他相关程序最终完成系统启动整个过程。init进程的进程描述符是作为init_task静态分配的。<br>对于当前task_struct，可以通过task_struct类型parent指针访问其父进程（必有一个），还包含一个children的子进程链表。 </p><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>许多其他操作系统：首先在新的地址空间创建进程，读入可执行文件，最后开始执行。<br>Unix：首先通过fork（）拷贝当前进程创建一个子进程，父子进程区别仅限于PID，PPID（子进程将其设为父进程PID值）和某些资源统计量。exec（）负责读取可执行文件并将其载入地址空间运行。</p><h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>Linux的fork（）采用写时拷贝，只有子进程在父进程进行写入时再进行拷贝，其他的时候是只读共享。所以fork（）的实际开销就是复制父进程页表以及创建PID。</p><h3 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h3><p>Linux通过clone（）系统调用实现fork（）<br>fork（）-调用-&gt;clone()-调用-&gt;do_fork()（完成创建的大部分工作）-调用-&gt;copy_process()<br>copy_process工作:</p><ol><li>调用dup_task_strucr()为新进程创建一个内核栈、thread_info和task_struct，此时，父子进程描述符完全一样。</li><li>检查并确保新创建这个进程后进程数目没有超出资源限制。</li><li>子进程着手于区别父进程。task_struct的许多成员被清零或设为初始值。</li><li>子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行。</li><li>copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERRIV标志被清0，表示进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。</li><li>调用alloc_pid()为新进程分配一个分配一个有效的PID。</li><li>根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信息处理函数、进程地址空间和命名空间等。一般，这些资源会所有线程共享，否则资源对每个进程是不同的，因此拷贝到这里。</li><li>最后，copy_process做扫尾工作并返回一个指向子进程的指针。 </li></ol><p>如果copy_process()成功返回do_fork()，新创进程被唤醒且内核有意让其首先执行。因为一般子进程都会马上调用exec()函数，可以避免父进程首先执行可能的写入造成的额外开销。</p><h3 id="vfork（）"><a href="#vfork（）" class="headerlink" title="vfork（）"></a>vfork（）</h3><p>除了不拷贝父进程的页表项以外，vfork()和fork()功能相同。基本没啥用。</p><h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>Linux中，线程具有task_struct,它看起来就是普通进程，只是和其他一些进程共享某些资源，如地址空间。对Linux来说，线程只是进程间共享资源的手段。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程创建于进程类似，只是在调用clone时需要传递一些参数标明需要共享的资源。创建Linux进程所花时间和其他操作系统创建线程要少。</p><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>独立运行在内核空间的标准进程，和普通进程区别在于没有独立地址空间。只在内核空间运行，和普通进程一样，可以被调度，也可以被强占。<br>新的任务是由kthread内核进程通过clone()系统调用而创建的。<br>内核线程启动后就一直运行到调用do_exit（）退出或其他部分调用kthread_stop()退出。</p><h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>终结时，释放资源并告诉父进程。<br>可以调用exit()主动终结,也可以异常被动终结,但大部分靠do_exit()来完成<br>do_exit():</p><ol><li>将task_struct标志设为PF_EXITING</li><li>调用del_time_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器在排队也没有定时器处理程序在运行。</li><li>如果BSD的记账功能是开启的，do_exit()调acct_update_integrals()来输入记账信息。</li><li>调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是说，这个进程空间没有被共享），就彻底释放它们。</li><li>调用sem_exit()函数，如果进程排队等候IPC信号，它则离开队列。</li><li>调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为0，那么久代表没有进程在使用相应的资源可以释放。</li><li>接着把存放在task_struct和exit_code成员中的任务退出代码置为由exit（）提供的退出代码，或者去完成任何其他由内核机制规定的退出动作，退出代码存放在这里供父进程随时检索。</li><li>调用exit_notufy()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或为init进程，并把进程状态（存放在task_struct中的exit_state中）设成EXIT_ZOMBIE。</li><li>do_exit()调用schedule（）切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。do_exit()永不返回。</li></ol><p>至此进程仅剩的内存就是内核栈，Thread_info 和task_struct结构。此时进程存在的唯一目的数向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关信息后，内存释放。</p><h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p>进程终结时的清理工作和进程描述符的删除被分开进行，这样做可以让系统有办法在子进程终结后仍能获得它的信息。过程如上段。</p><h3 id="孤儿进程造成的进退维谷"><a href="#孤儿进程造成的进退维谷" class="headerlink" title="孤儿进程造成的进退维谷"></a>孤儿进程造成的进退维谷</h3><p>如果父进程在子进程之前退出，必须有机制来保证子进程能够找到一个新的父亲。解决方法是给子进程在当前线程组内找一个线程做父亲，如果不行，就让init做父进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。&lt;br&gt;进程提供两种虚拟机制，虚拟处理器与虚
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="纸质书笔记" scheme="https://github.com/zdkswd/tags/%E7%BA%B8%E8%B4%A8%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
</feed>
