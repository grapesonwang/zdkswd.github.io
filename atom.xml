<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2019-06-11T01:33:18.640Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git</title>
    <link href="https://github.com/zdkswd/2019/06/11/Git/"/>
    <id>https://github.com/zdkswd/2019/06/11/Git/</id>
    <published>2019-06-11T01:32:55.000Z</published>
    <updated>2019-06-11T01:33:18.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h2><p>config的三个作用域  local(default,只对某个仓库有效)    global   system</p><blockquote><p>git config –list//查看现有配置信息</p></blockquote><p>add到的是git暂存区的作用，commit前的一个区域，比如可以用于暂存工作状态，然后再做修改，比较两次的修改，满意了第二次覆盖，不满意将第一次的提交。暂存区中不合适也可以回退。</p><p>因为需要查看暂存区的状态，使用的命令是：</p><blockquote><p>git status</p></blockquote><p>git重命名命令</p><blockquote><p>git mv src dest</p></blockquote><p>git log</p><blockquote><p>git log (–oneline一行显示) (–all所有分支) (-n4最近四个) (–graph绘制图形)</p></blockquote><p>.git目录</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560059022340.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>HEAD存储指向当前工作的分支</p><p>config中记录user的信息，如果设置local配置，则会在此存储local信息。</p><p>refs引用存储heads(分支)  tags(标签信息)</p><p>objects存储对象</p><p>commit,tree和blob对象之间的关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560059639501.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560060359602.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>分离头指针（detached HEAD）指的是HEAD指向一个commit而不是一个分支，很可能会被git当作垃圾清理掉。</p><p>HEAD与branch</p><p>HEAD不仅可以指向分支，最终是落脚于某个commit，还可以指向之前一次commit。所以HEAD指向commit。HEAD可以用于指代所指commit。</p><h2 id="常用场景-在本地维护自己的分支"><a href="#常用场景-在本地维护自己的分支" class="headerlink" title="常用场景(在本地维护自己的分支)"></a>常用场景(在本地维护自己的分支)</h2><p>清除不要分支</p><blockquote><p>git branch -D 分支名</p></blockquote><p> 最新commit描述不准确，进行修改</p><blockquote><p>git commit –amend//双单杠</p></blockquote><p>老旧commit描述不准确，进行修改</p><blockquote><p>git rebase -i 被修改的父类的id</p></blockquote><p>进入交互式界面用于指定对commit要进行的操作</p><p>r </p><p>wq！保存并退出进入交互式界面，来修改message信息。</p><p>wq！保存并退出</p><p>历史多个连续commit合并</p><p>和上面一样的操作选择父节点，不过是r变s。</p><p>历史不连续commit合并</p><p>选择父节点，然后将要和并的不在父节点下的commit显式pick id号,将父节点下要合并的子节点挨着放，s开头。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Git/1560068929555.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>比较暂存区与HEAD所含文件</p><blockquote><p>git diff –cached</p></blockquote><p>比较工作区和暂存区</p><blockquote><p>git diff</p></blockquote><p>将暂存区恢复成和HEAD一样</p><blockquote><p>git reset HEAD</p></blockquote><p>将工作区文件恢复成暂存区一样（add后又做了变更，然后不满意时）</p><blockquote><p>git checkout – 文件名</p></blockquote><p>取消暂存区部分文件变更</p><blockquote><p>git reset HEAD –文件名</p></blockquote><p>消除最近几次提交</p><blockquote><p>git reset –hard commit_id</p></blockquote><p>这样HEAD和暂存区都指向了commit_id所指的commit</p><p>比较不同提交的差异</p><blockquote><p>git diff commit_id1 commit_id2</p></blockquote><p>正确的删除一个文件</p><blockquote><p>git rm 文件名</p></blockquote><p>当开发时临时加了紧急任务时，将自己现在做的修改压入堆栈。</p><blockquote><p>git stash</p></blockquote><p>取回使用apply，取栈顶信息，不出栈。</p><blockquote><p>git stash apply</p></blockquote><p>取回使用pop，栈顶出栈</p><blockquote><p>git stash pop</p></blockquote><p>.gitignore用于指定不需要Git管理的文件，将文件名加在其中或者使用通配符来指定不需要git管理的文件。</p><p>git传输的协议分为哑协议和智能协议。在本地也存在git备份，类比于远端库有一个本地库。</p><h1 id="Github常用操作"><a href="#Github常用操作" class="headerlink" title="Github常用操作"></a>Github常用操作</h1><p>配置公私钥 ssh 本地生产公私钥，将公钥粘贴到github中。</p><p>git pull是分两步走，先是fetch然后是merge。</p><p>当远端有文件，本地没有，这时fetch不是fast-forward方式，要通过merge合并。</p><p>也可以用rebase方式。</p><p>不同人修改不同文件如何处理</p><p>远端新建分支，本地建分支与远端相关联</p><blockquote><p>git chechout -b(切换到新建分支)  本地分支命名  远端分支命名</p></blockquote><p>查看分支情况,本地以及远端</p><blockquote><p>git branch -av</p></blockquote><p>修改相同文件不同区域，同理，可以不用人介入的merge。</p><p>当多人修改同一区域的时候，pull(fetch and merge)会失败，自动merge会失败。文件中会显式标出冲突的地方。</p><p>此时有两个选择，一，终止merge git merge –abort</p><p>二，解决冲突的地方，然后commit  然后push到远端</p><p>同时变更了文件名和文件内容，git可以正常的合并。</p><p>禁止向集成分支执行push -f操作。</p><p>高效搜索github项目。in:readme stars:&gt;1000 advanced search</p><h1 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h1><p>保证代码质量 fork下来，pull request</p><p>organization</p><p>项目分支情况 insights-&gt;network</p><p>merge rebase合并分支</p><p>分支和master产生冲突时，master会合并到分支解决冲突，解决完然后再提交pull request，又回到master产生一个commit。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;一些命令&quot;&gt;&lt;a href=&quot;#一些命令&quot; class=&quot;headerlink&quot; title=&quot;一些命令&quot;&gt;&lt;/a&gt;一些命
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Git" scheme="https://github.com/zdkswd/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常处理</title>
    <link href="https://github.com/zdkswd/2019/06/07/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2019/06/07/Java 异常处理/</id>
    <published>2019-06-07T14:22:47.000Z</published>
    <updated>2019-06-07T14:22:50.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="码出高效"><a href="#码出高效" class="headerlink" title="码出高效"></a>码出高效</h1><h2 id="throw-throws"><a href="#throw-throws" class="headerlink" title="throw throws"></a>throw throws</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/WechatIMG122.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>throw</strong>是方法内部抛出具体异常类对象的关键字，<strong>throws</strong>则用在方法上，表示方法调用者可以通过此方法声明向上抛出异常对象。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>在Exception中，unchecked异常是运行时异常，它们都继承自<strong>RuntimeException</strong>，不需要程序进行显式的捕捉和处理。</p><h2 id="try代码块"><a href="#try代码块" class="headerlink" title="try代码块"></a>try代码块</h2><p><strong>（1）try代码块</strong>：监视代码执行过程，一旦发现异常直接跳转catch，没有catch。则直接跳转至finally。<br><strong>（2）catch代码块</strong>。<br><strong>（3）finally代码块</strong>：try存在时，可以只有catch代码块，也可以只有finally代码块。不管有没有异常发生，即使发生OutOfMemoryError也会执行，通常用于处理善后清理工作。</p><p><strong>finally是在return表达式运行后执行的，此时将要return的结果已经被暂存起来，待finally代码块执行结束后再将之暂存的结果返回。</strong></p><p><strong>finally</strong>代码块中使用<strong>return</strong>语句使返回值的判断变得复杂，所以避免返回值不可控，<strong>不要在finally代码块中使用return语句。</strong></p><p>Lock、ThreadLocal、InputStream等这些需要进行强制释放和清除的对象都得在finally代码块中进行显式的清理，避免产生内存泄露，或者资源消耗。</p><h1 id="java核心技术36讲"><a href="#java核心技术36讲" class="headerlink" title="java核心技术36讲"></a>java核心技术36讲</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/accba531a365e6ae39614ebfa3273900.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>业界有一种争论，甚至可以算是某种程度的共识，Java语言的Cheaked Exception也许是一个<strong>设计错误</strong>。<br>（1）Checked Exception的假设是捕获了异常然后恢复程序。但是实际上大多数情况下根本不可能恢复。Checked Exception的使用已经大大偏离了最初的设计目的。<br>（2）Checked Exception不兼容functional编程。</p><p>但是确实有意向异常，比如和环境相关的IO、网络等其实是存在可恢复性的。</p><p>从性能角度看Java异常处理机制，有两个比较昂贵的地方：<br>（1）try-catch代码段会产生额外的性能开销，它往往会<strong>影响JVM对代码进行优化</strong>，所以建议仅捕获必要的代码段，不要一个大的try包住整段代码；与此同时用异常控制代码流程远比通常意义上的条件语句要低效。<br>（2）Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的比较频繁，这个开销就不能忽略了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;码出高效&quot;&gt;&lt;a href=&quot;#码出高效&quot; class=&quot;headerlink&quot; title=&quot;码出高效&quot;&gt;&lt;/a&gt;码出高效&lt;/h1&gt;&lt;h2 id=&quot;throw-throws&quot;&gt;&lt;a href=&quot;#throw-throws&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java I/O</title>
    <link href="https://github.com/zdkswd/2019/06/05/java%20io/"/>
    <id>https://github.com/zdkswd/2019/06/05/java io/</id>
    <published>2019-06-05T12:56:47.000Z</published>
    <updated>2019-06-05T12:56:37.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-编程思想"><a href="#java-编程思想" class="headerlink" title="java 编程思想"></a>java 编程思想</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>file类名字具有一定的误导性，它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果指的是一个文件集，就可以对此集合调用list（）方法。返回一个字符数组，如果想要取得不同目录列表，只需再创建一个不同的File对象。</p><p>File类不仅仅只代表存在的文件或目录。也可以用File对象来<strong>创建</strong>新的目录或尚不存在的整个目录路径。我们还可以查看文件的特性（如：大小，最后修改日期，读/写）检查某个File对象代表的是一个文件还是一个目录，并可以删除文件。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>有时我们必须把来自于“字节”层次结构中的类和“字符”层次结构中的类结合起来使用。为了实现这个目的，要用到“适配器”（adapter）类：InputStreamReader可以把InputStream转换为Reader，而OutputStreamWriter可以把OutputStream转换为Writer。</p><p>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化。老的I/ O流继承层次结构仅支持8位字节流，并且不能很好地处理16位的Unicode字符。由于Unicode用于字符国际化（Java本身的char也是16位的Unicode），所以添加Reader和Writer继承层次结构就是为了在所有的I/O操作中都支持Unicode。另外，新类库的设计使得它的操作比旧类库更快。</p><h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><h2 id="缓冲（缓存）处理"><a href="#缓冲（缓存）处理" class="headerlink" title="缓冲（缓存）处理"></a>缓冲（缓存）处理</h2><p><strong>缓存处理是所有IO操作的基础，术语输入输出只对数据移入移出缓存有意义。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><blockquote><p>用户空间与内核空间对应内存中不同的位置划分。通常<strong>32位Linux内核</strong>地址空间划分0~3G为用户空间，3~4G为内核空间。用户空间与内核空间也可以进行内存共享，以避免大量的数据复制。</p></blockquote><p>进程执行操作系统的I/O请求包括数据从缓冲区排出（写操作）和数据填充缓冲区（读操作）。</p><p>例如一个磁盘，移动到进程的存储区域（例如RAM）中。首先，进程要求其缓冲通过read()系统调用填满。这个系统调用导致内核向磁盘控制硬件发出一条命令要从磁盘获取数据。磁盘控制器通过<strong>DMA</strong>直接将数据写入内核的内存缓冲区，不需要主CPU进一步帮助。当请求read()操作时，一旦磁盘控制器完成了缓存的填写，内核从内核空间的临时缓存拷贝数据到进程指定的缓存中。</p><blockquote><p>DMA技术的出现，使得外围设备可以通过DMA控制器直接访问内存，与此同时，CPU可以继续执行程序。DMA控制器获得总线控制权后，CPU即刻挂起或只执行内部操作，由DMA控制器输出读写命令，直接控制RAM与I/O接口进行DMA传输。</p></blockquote><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote><p>虚拟<a href="https://baike.baidu.com/item/内存" target="_blank" rel="noopener">内存</a>是<a href="https://baike.baidu.com/item/计算机系统/7210959" target="_blank" rel="noopener">计算机系统</a><a href="https://baike.baidu.com/item/内存管理/5633616" target="_blank" rel="noopener">内存管理</a>的一种技术。它使得<a href="https://baike.baidu.com/item/应用程序/5985445" target="_blank" rel="noopener">应用程序</a>认为它拥有连续的可用的<a href="https://baike.baidu.com/item/内存/103614" target="_blank" rel="noopener">内存</a>（一个连续完整的<a href="https://baike.baidu.com/item/地址空间/1423980" target="_blank" rel="noopener">地址空间</a>），而实际上，它通常是被分隔成多个<a href="https://baike.baidu.com/item/物理内存/2502263" target="_blank" rel="noopener">物理内存</a>碎片，还有部分暂时存储在外部<a href="https://baike.baidu.com/item/磁盘存储器/2386684" target="_blank" rel="noopener">磁盘存储器</a>上，在需要时进行<a href="https://baike.baidu.com/item/数据交换/1586256" target="_blank" rel="noopener">数据交换</a>。</p></blockquote><p>之所以要从内核空间拷贝到最终用户空间而不直接从磁盘到用户空间是由于虚拟内存的存在。</p><p>通过将内核空间地址映射到相同的物理地址作为一个用户空间的虚拟地址。这个缓存同时对内核和用户空间进程可见。</p><h1 id="close与flush"><a href="#close与flush" class="headerlink" title="close与flush"></a>close与flush</h1><p>A:close()关闭流对象，但是<strong>先刷新一次缓冲区</strong>，关闭之后，流对象不可以继续再使用了。close（）中会调用flush。<br>B:flush()仅仅是刷新缓冲区(一般写字符时要用,因为字符是先进入的缓冲区)，流对象还可以继续使用</p><p><strong>在io中，为了提高效率，通常是在缓存区满时进行一次读写，所以对于缓存区未满的情况下需要手动调用刷新将缓存区数据取出。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-编程思想&quot;&gt;&lt;a href=&quot;#java-编程思想&quot; class=&quot;headerlink&quot; title=&quot;java 编程思想&quot;&gt;&lt;/a&gt;java 编程思想&lt;/h1&gt;&lt;h2 id=&quot;File类&quot;&gt;&lt;a href=&quot;#File类&quot; class=&quot;header
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="https://github.com/zdkswd/2019/06/05/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://github.com/zdkswd/2019/06/05/散列表/</id>
    <published>2019-06-05T12:18:47.000Z</published>
    <updated>2019-06-05T12:19:51.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h2><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>将键（关键字）转化为数组下标的映射方法就叫做<strong>散列函数</strong>（Hash函数），散列函数计算得到的值就是<strong>散列值</strong>（Hash值）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/92c89a57e21f49d2f14f4424343a2773.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数构造的设计基本要求。</p><ol><li>散列函数计算得到的散列值是一个非负整数。</li><li>如果key1=key2，那么hash(key1)==hash(key2);</li><li>如果key1≠key2，那么hash(key1)≠hash(key2)。</li></ol><p>对于第三点，即便是业界著名的MD5，SHA，CRC等哈希算法，也无法完全避免<strong>散列冲突</strong>，数组的存储空间有限，也会加大散列冲突的概率。几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，需要通过其他途径来解决。</p><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>再好的散列函数也无法避免散列冲突，常用的散列冲突解决方法有两类，<strong>开放寻址法</strong>，<strong>链表法</strong>。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突,我们就重新探测一个空闲位置,将其插入。<br>其中一个简单的实现是<strong>线性探测法</strong>：插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>黄色代表空闲，橙色代表存储了数据<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在散列表中查找元素类似于插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则就是我们要找的元素，否则就顺序往后依次查找。如果遍历到数组中的空闲位置还没有找到，就说明要查找的元素并没有在散列表中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/9126b0d33476777e7371b96e676e90ff.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，不能单纯把要删除元素设为空。<br>可以将删除的元素特殊标记为deleted。当线性探测查找遇到标记为deleted的控件，不是停下来而是继续往下探测。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>线性探测法的主要问题在于，当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间越来越久，极端下需要探测整个散列表，最坏情况时间复杂度是O(n)。同理，在删除和查找时，也有可能线性探测整张散列表，才能找到查找或者删除数据。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外,还有另外两种比较经典的探测方法，<strong>二次探测</strong>(Quadratic probing)和<strong>双重散列</strong>(Double hashing)。</p><p>所谓<strong>二次探测</strong>，跟线性探测很像，线性探测每次探测的步长是1,那它探测的下标序列就是hash(key)+0, hash(key)+1, hash(key)+2…..二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是hash(key)+0, hash(key)+1^ 2, hash(key)+2^ 2…..</p><p>所谓<strong>双重散列</strong>，意思就是不仅要使用一个散列函数。 我们使用一组散列函数 hash1(key),hash2(key)，hash3(key)….. 先用第一个散列函数， 如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>(load factor)来表示空位的多少。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-03%20%E4%B8%8B%E5%8D%887.54.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当插入时，只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度是O(1)。当查找，删除一个元素时，同样通过散列函数计算出对应的槽，这两个操作的时间复杂度与链表的长度k成正比。</p><h2 id="word文档单词拼写检查"><a href="#word文档单词拼写检查" class="headerlink" title="word文档单词拼写检查"></a>word文档单词拼写检查</h2><p>常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确;如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p><h1 id="工业级水平的散列表"><a href="#工业级水平的散列表" class="headerlink" title="工业级水平的散列表"></a>工业级水平的散列表</h1><p>散列表的查询效率不能笼统地说成是O(1)，跟散列函数、装载因子、散列冲突都有关系，如果散列函数设计不好，或装载因子过高，都可能导致散列冲突发生概率升高，查询效率下降。极端情况下，一些恶意攻击者可能通过精心构造的数据使得所有数据经过散列函数之后都散列到同一个槽里，这时散列表就会退化为链表，查询时间复杂度从O(1)退化到O(n)。</p><p>如果散列表中有10万个数据，退化后的散列表查询的效率就下降了10 万倍。更直接点说，如果之前运行100次查询只需要0.1秒，那现在就需要1万秒。这样就有可能因为查询操作消耗大量CPU或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击(DoS) 的目的。这也就是<strong>散列表碰撞攻击</strong>的基本原理。</p><h2 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h2><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。</p><p>首先，<strong>散列函数的设计不能太复杂。</strong>过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响散列表的性能。</p><p>其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><p>还需要综合考虑各种因素，包括关键字的长度，特点，分布、还有散列表的大小等。</p><p>第一个例子就是学生运动会的例子,通过分析参赛编号的特征，把编号中的后两位作为散列值。还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，可以取手机号的后四位作为散列值。这种散列函数的设计方法，一般叫作“<strong>数据分析法</strong>”。</p><p>第二个例子是Word拼写检查功能，可以将单词中每个字母的ASCII码值进位相加，然后再跟散列表的大小求余，取模，作为散列值。</p><h2 id="装载因子过大怎么办"><a href="#装载因子过大怎么办" class="headerlink" title="装载因子过大怎么办"></a>装载因子过大怎么办</h2><p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。</p><p>针对散列表，当装载因子过大时，也可以进行动态扩容，重新申请一个更大的散列表， 将数据搬移到这个新散列表中。假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了0.4。针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/67d12e07a7d673a9c1d14354ad029443.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是O(1)。最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据,所以时间复杂度是O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是O(1)。</p><p>对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空间会越来越多。如果对空间消耗敏感，可以在装载因子小于某个值后，启动动态缩容，如果更加在意执行效率，能容忍多消耗一点内存空间，就不用费劲缩容。<br>装载因子阈值需要选择得当，如果太大，会导致冲突过多，如果太小，会导致内存浪费严重。</p><h2 id="如何避免低效地扩容？"><a href="#如何避免低效地扩容？" class="headerlink" title="如何避免低效地扩容？"></a>如何避免低效地扩容？</h2><p>在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>极端如当散列表大小为1GB，想要扩容为原来的两倍大小，就要对1GB的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，十分耗时，一次搬移就会造成用户等待过久。</p><p>为了解决一次性扩容耗时过久，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表。</p><p>当有新数据要插入时，将新数据插入到新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复操作。经过多次插入操作之后，老的散列表中的数据就一点一点搬移到新散列表中了。这样没有集中的一次性数据搬移，插入操作就都变得很快了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/6d6736f986ec4b75dabc5472965fb9cb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于查询操作，先从新散列表中查找，如果没有找到，再去老的散列表查找。</p><p>通过这样的均摊方法，将一次性扩容的代价，均摊到多次插入操作，避免了一次性扩容耗时过多。任何情况下，插入一个数据的时间复杂度都是O(1)。</p><h2 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h2><p>Java中LinkedHashMap采用链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突。</p><h3 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p><strong>优点</strong>：<br>开放寻址法不像链表法,需要拉很多链表。散列表中的数据都存储在数组中,可以有效地利用CPU缓存加快查询速度。而且,这种方法实现的散列表,序列化起来比较简单。链表法包含指针,序列化起来就没那么容易。</p><p><strong>缺点</strong>：用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中， 比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p><p><strong>总结</strong>：<strong>当数据量较小，装载因子小时，适合采用开放寻址法。</strong></p><h3 id="链表法-1"><a href="#链表法-1" class="headerlink" title="链表法"></a>链表法</h3><p>因为链表节点可以在需要时再创建，并不需要事先申请好，所以链表法对内存的利用率比开放寻址法要高。</p><p>链表法对比开放寻址法对大装载因子容忍度更高。开放寻址法只适用于装载因子小于1的情况。接近1时，就可能会有大量的散列冲突。对于链表法，也只是链表长度变长了，虽然查找效率有所下降，但是比顺序查找快很多。</p><p>由于链表中的节点时零散分布在内存中不是连续的，所以对CPU缓存是不友好的，对于执行效率有一定的影响。</p><p>对链表法稍加改造就可以实现一个更加高效的散列表。将链表改造成其他高效的动态数据结构，即便出现散列冲突，极端情况下，所有数据都散列到一个桶内，最终退化的散列表查找时间也不过是O(logn)。就有效避免了散列碰撞攻击。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/103b84d7173277c5565607b413c40129.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>总结</strong>：<strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p><h2 id="工业级散列表举例"><a href="#工业级散列表举例" class="headerlink" title="工业级散列表举例"></a>工业级散列表举例</h2><p>Java中的HashMap。</p><h3 id="初始大小"><a href="#初始大小" class="headerlink" title="初始大小"></a>初始大小</h3><p>HashMap默认的初始大小是16,当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高HashMap的性能。</p><h3 id="装载因子和动态扩容"><a href="#装载因子和动态扩容" class="headerlink" title="装载因子和动态扩容"></a>装载因子和动态扩容</h3><p>最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity (capacity 表示散列表的容量)的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><h3 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h3><p>HashMap底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，- -旦出现拉链过长,则会严重影响HashMap的性能。</p><p>在JDK1.8版本中，为了对HashMap做进一步优化， 引入了红黑树。而当链表长度太长(默认超过8)时，链表就转换为红黑树。可以利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于8个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h3 id="散列函数-1"><a href="#散列函数-1" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数设计的并不复杂，追求的是简单高效，分布均匀。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-04%20%E4%B8%8B%E5%8D%889.59.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="散列表与链表"><a href="#散列表与链表" class="headerlink" title="散列表与链表"></a>散列表与链表</h1><p>散列表与链表经常放在一起使用。</p><h2 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h2><p>缓存系统包括三个操作：添加（先要查找是否存在），删除，查找数据。都需要进行查找操作。只使用链表，时间复杂度是O(n)，散列表+链表，时间复杂度O(1)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>查找：</strong>散列表中查找数据的时间复杂度接近O(1)。通过散列表，可以很快地在缓存中找到一个数据，当找到后还需要将它移动到双向链表的尾部。</p><p><strong>删除：</strong>需要找到数据所在结点，将结点删除。借助散列表，可以在O(1)时间内找到要删除的节点。因为链表是双向链表，删除结点只需要O(1)时间复杂度。</p><p><strong>添加</strong>：添加到缓存稍微有点麻烦，需要先看是否在缓存中，如果已经在其中，需要将其移动到双向链表的尾部，如果不在，就要看缓存有没有满，如果满了，则将双向链表头部结点删除，然后再将数据放到链表尾部。如果没有满就直接将数据放到链表的尾部。</p><h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><p>Redis有序集合的操作就是下面这些：<br>1.添加一个成员对象。<br>2.按照键值来删除一个成员对象。<br>3.按照键值来查找一个成员对象。<br>4.按照分值区间查找数据，比如查找在[100,356]之间的成员对象。<br>5.按照分值从小到大排序成员变量。</p><p>如果只采用跳表，按key来删除，查询就会很慢。可以再按照键值构建一个散列表，这样按照key来删除，查找一个成员对象的时间复杂度就变成了O(1)。</p><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>Linked并不仅仅代表它是通过链表法解决散列冲突的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-05%20%E4%B8%8B%E5%8D%888.01.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这段代码的打印结果是1，2，3，5.<br>每次调用put函数添加数据时，都会将数据添加到尾部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/17ac41d9dac454e454dcb289100bf198.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>插入key=3时，已存在，将原来的删除，并将新的放在尾部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/fe313ed327bcf234c73ba738d975b18c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当访问key为5时，将被访问的数据移动到链表的尾部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%A3%E5%88%97%E8%A1%A8/b5e07bb34d532d46d127f4fcc4b78f11.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以发现与LRU缓存策略一模一样。<br><strong>LinkedHashMap是通过双向链表和散列表组合的，Linked实际是指双向链表。</strong></p><h1 id="散列表和链表"><a href="#散列表和链表" class="headerlink" title="散列表和链表"></a>散列表和链表</h1><p>为什么散列表和链表经常一块使用?</p><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表(或者跳表)结合在一起使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列表&lt;/h1&gt;&lt;h2 id=&quot;散列思想&quot;&gt;&lt;a href=&quot;#散列思想&quot; class=&quot;headerlink&quot; title=&quot;散列思想&quot;&gt;&lt;/a&gt;散列思
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳表</title>
    <link href="https://github.com/zdkswd/2019/05/31/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://github.com/zdkswd/2019/05/31/跳表/</id>
    <published>2019-05-31T12:56:47.000Z</published>
    <updated>2019-05-31T12:56:35.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>二分查找是依赖数组随机访问的特性。如果数据是存储在链表中，则要对链表进行改造，支持类似二分的查找算法。改造后的数据结构叫做<strong>跳表</strong>。</p><p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>。可以支持快速的插入删除查找，甚至可以替代红黑树。</p><p>Redis中的有序集合(Sorted Set)就是用跳表来实现的。</p><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>对于单链表查找数据只能从头到尾遍历，O(n)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/14753c824a5ee4a976ea799727adc78e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>加上一层索引之后，查找一个结点需要遍历的结点数减少了，也就是查找效率提高了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/492206afe5e2fef9f683c7cff83afa65.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当链表的长度比较大时，在构建索引之后，查找效率的提升就会非常明显。</p><p><strong>这种链表加多级索引的结构就是跳表。</strong></p><h2 id="用跳表查询到底有多快"><a href="#用跳表查询到底有多快" class="headerlink" title="用跳表查询到底有多快"></a>用跳表查询到底有多快</h2><p>O(logn)</p><h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>等比数列求和。空间复杂度还是O(n)。<br>在实际的软件开发中，原始链表存储的可能是很大的对象，索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引节点大很多时，索引占用的额外空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>插入操作时间复杂度也是O(logn)。先要查找要插入的位置，再插入结点。<br>删除操作是，如果这个结点在索引中也有出现，除了删除原始链表汇总的结点，还要删除索引中的。在查找要删除的结点的时候，一定要获取前驱结点。如果使用的是双向链表，就不用考虑这个问题。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/c863074c01c26538cf0134eaf8dc67c5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果不停插入数据而不更新索引，就有可能出现某两个索引节点之间数据非常多的情况，极端情况下，跳表会退化为单链表。</p><p>可以通过<strong>随机函数</strong>来维护平衡性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B7%B3%E8%A1%A8/a861445d0b53fc842f38919365b004a7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>随机函数生成了值K，那么久将这个结点添加到第一级到第K级这K级索引中。</p><p>Redis有序集合支持的核心操作包括：（1）插入（2）删除（3）查找（4）按照区间查找数据（5）迭代输出有序序列</p><p>其中,插入、删除、查找以及迭代输岀有序序列这几个操作,红黑树也可以完成,时间复杂度跟跳表是一样的。但是,按照区间来查找数据这个操作,红黑树的效率没有跳表高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跳表&quot;&gt;&lt;a href=&quot;#跳表&quot; class=&quot;headerlink&quot; title=&quot;跳表&quot;&gt;&lt;/a&gt;跳表&lt;/h1&gt;&lt;p&gt;二分查找是依赖数组随机访问的特性。如果数据是存储在链表中，则要对链表进行改造，支持类似二分的查找算法。改造后的数据结构叫做&lt;strong&gt;跳
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring实战  Spring核心</title>
    <link href="https://github.com/zdkswd/2019/05/30/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/"/>
    <id>https://github.com/zdkswd/2019/05/30/Spring实战  Spring核心/</id>
    <published>2019-05-30T12:07:47.000Z</published>
    <updated>2019-05-30T12:10:43.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简要概念"><a href="#简要概念" class="headerlink" title="简要概念"></a>简要概念</h1><p> <strong>依赖注入</strong><br>方式1：构造器注入。</p><p>创建应用组件之间协作行为通常称为<strong>装配(wiring)</strong>。<br>可以用xml或java实现。</p><p>Spring通过<strong>应用上下文(Application Context)</strong>装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p><p>对于XML使用CLassPathXMLApplication，对于Java配置，使用AnnotationConfigApplicationContext。</p><hr><p> <strong>应用切面</strong><br>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</p><p>可以把切面想象为覆盖在很多组件上的一个外壳。应用是由那些实现各自业务功能的模块组成的。</p><p>可以在xml中将某个bean声明为一个切面。</p><hr><p><strong>使用模板消除样板式代码</strong><br>比如jdbcTemplate。</p><hr><p><strong>容纳Bean</strong><br>在基于Spring的应用中，应用对象生存于Spring容器(container)中。Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡。</p><p>容器是 Spring框架的核心。 Spring容器使用DI管理构成应用的组件,它会创建<br>相互协作的组件之间的关联。毫无疑问,这些对象更简单干净,更易于理解,更易于重用并且更易于进行单元测试。</p><p>spring自带了多种容器实现，归为两种类型，bean工厂与应用上下文。bean工厂对于大多数应用来说往往太低级，因此，应用上下文要比bean工厂更受欢迎。</p><hr><p><strong>使用应用上下文</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%884.24.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>无论是从文件系统中装载应用上下文还是从类路径下装载应用上下文，将bean加载到bean工厂的过程都是相似的。区别在于前者在指定的文件系统路径下查找xml文件，后者是在所有的类路径(包括JAR文件)下查找xml文件。AnnotationConfigApplicationContext通过一个配置类加载bean。<br>应用上下文准备就绪之后，就可以调用上下文的getBean()方法从Spring容器中获取bean。</p><hr><p><strong>bean的生命周期</strong><br>在传统的Java应用中,bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%884.34.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%885.52.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>Spring核心容器</strong><br>容器是Spring框架最核心的部分，它管理着Spring 应用中bean的创建、配置和管理。在该模块中，包括了Spring bean 工厂，它为Spring提供了DI的功能。基于bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。所有的Spring模块都构建于核心容器之上，当配置应用时，其实隐式地使用了这些类。</p><p><strong>Spring的AOP模块</strong><br>在AOP模块中，Spring 对面向切面编程提供了丰富的支持。这个模块是Spring 应用系统中开发切面的基础。与DI一样, AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点(例如事务和安全)从它们所应用的对象中解耦出来。</p><h1 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h1><p>在Spring中，对象无需自己查找或创建与其所关联的其他对象。容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间协作关系的行为称为装配，也是依赖注入的本质。</p><h2 id="Spring配置的可选方案"><a href="#Spring配置的可选方案" class="headerlink" title="Spring配置的可选方案"></a>Spring配置的可选方案</h2><p>Spring提供三种主要的装配机制：</p><ol><li>在XML中进行显式配置；</li><li>在java中进行显式配置；</li><li>隐式地bean发现机制和自动装配。</li></ol><p>作者建议尽可能地使用自动配置机制，显式配置越少越好，当必须要显式配置bean时，推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有想使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。</p><h2 id="自动化装配bean"><a href="#自动化装配bean" class="headerlink" title="自动化装配bean"></a>自动化装配bean</h2><p>Spring从两个角度来实现自动化装配：</p><ol><li>组件扫描(component scanning):Spring会自动发现应用上下文中所创建的bean。</li><li>自动装配(autowiring):Spring自动满足bean之间的依赖。</li></ol><p>组件扫描和自动装配组合在一起就能发挥出强大的威力，能够将显式配置降低到最少。</p><h3 id="创建可被发现的bean"><a href="#创建可被发现的bean" class="headerlink" title="创建可被发现的bean"></a>创建可被发现的bean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%886.54.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>@Component</strong>注解表明该类会作为组件类，并告知Spring要为这个类创建bean。</p><p>不过组件扫描默认是不启用的，还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.19.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@ComponentScan</strong>注解可以在Spring中启用组件扫描。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包，Spring将会扫描这个包以及包下的所有子包，查找带有@Component注解的类并且在Spring中自动为其创建一个bean。</p><p>还可以使用XML来启动组件扫描。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.27.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还是基于Java的配置用的多，喜好问题。</p><p>一个实例：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.31.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@ContextConfiguration</strong>注解说明需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类中包括了<strong>@ComponentScan</strong>,所有带有@Component注解的类都会创建为bean。</p><h3 id="为组件扫描的bean命名"><a href="#为组件扫描的bean命名" class="headerlink" title="为组件扫描的bean命名"></a>为组件扫描的bean命名</h3><p>Spring应用上下文中所有的bean都会给定一个ID，就是将类名的第一个字母变为小写。也可以使用@Component为bean设置不同的ID。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.52.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="设置组件扫描的基础包"><a href="#设置组件扫描的基础包" class="headerlink" title="设置组件扫描的基础包"></a>设置组件扫描的基础包</h3><p>默认扫描的是配置类所在的包作为基础包(base package)来扫描组件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%887.59.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以指定多个包，扫描多个包。但是basePackages有一个问题是其是字符串，所以当包不存在时IDE也不会第一时间报错。可以设置basePackageClasses,设置数组中包含了类，这些类所在的包将会作为组件扫描的基础包。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%888.05.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="通过为bean添加注解实现自动装配"><a href="#通过为bean添加注解实现自动装配" class="headerlink" title="通过为bean添加注解实现自动装配"></a>通过为bean添加注解实现自动装配</h3><p>自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。可以借助<strong>@Autowired</strong>注解进行自动装配。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%888.58.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Autowired</strong>注解不仅能够用在构造器上，还能用在属性的Setter方法上。如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%889.01.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在Spring初始化bean之后，会尽可能去满足bean的依赖。不管是构造器，Setter还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖，假设有且只有一个bean匹配依赖的话，那么这个bean将会被装配进来，如果没有匹配的bean，那么在应用上下文创建时，Spring会抛出一个异常，也可以将@Autowired的required属性设置为false避免抛异常，当设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态，此时需要谨慎对待这个bean，如果代码没有进行null检查的话，这个处于未装配的属性有可能会出现NullPointerException。</p><p>如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。</p><p>@Autowired是Spring特有的注解。如果你不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，可以考虑将其替换为@Inject。<br>@Inject注解来源于Java依赖注入规范，该规范同时还定义了@Named注解。在自动装配中，Spring 同时支持@Inject和@Autowired. 尽管@Inject和@Autowired之间有着一些细微的差别, 但是在大多数场景下，它们都是可以互相替换的。</p><h2 id="通过Java代码装配bean"><a href="#通过Java代码装配bean" class="headerlink" title="通过Java代码装配bean"></a>通过Java代码装配bean</h2><p>尽管在很多场景下通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如说，想要将第三方库中的组件装配到应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。</p><p>此时就需要采用显示装配的方式，分为Java和XML。在进行显式配置时，JavaConfig是更好的方案，因为其更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。同时JavaConfig与其他的Java代码又有所区别，JavaConfig是配置代码，这意味着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码之中，通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开。</p><h3 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h3><p>创建JavaConfig类的关键在于为其添加<strong>@Configuration</strong>注解，<strong>@Configuration</strong>注解表明这个类是一个配置类, 该类应该包含在Spring应用上下文中如何创建bean的细节。对于显式配置，将@ConponentScan注解移除。此时那些bean不会被发现，配置类也没有作用了。</p><h3 id="声明简单的bean"><a href="#声明简单的bean" class="headerlink" title="声明简单的bean"></a>声明简单的bean</h3><p>要在JavaConfig中声明bean，需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%889.29.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Bean</strong>注解告诉Spring方法返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。</p><h3 id="借助JavaConfig实现注入"><a href="#借助JavaConfig实现注入" class="headerlink" title="借助JavaConfig实现注入"></a>借助JavaConfig实现注入</h3><p>在JavaConfig中装配bean的最简单方式就是引用创建bean的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%889.33.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过调用方法来引用bean令人困惑，还有一种理解起来更为简单的方式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%889.36.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里使用构造器实现了DI功能，但是完全可以使用其他风格的DI配置，比如可以通过Setter方法注入：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.04.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例。构造器和Setter方法只是@Bean方法的两个简单样例。</p><h2 id="通过XML装配bean"><a href="#通过XML装配bean" class="headerlink" title="通过XML装配bean"></a>通过XML装配bean</h2><p>在装配bean时还可以选择XML，现在已经不太合乎大家的心意了，但是在Spring中已经有很长的历史了。</p><h3 id="创建XML配置规范"><a href="#创建XML配置规范" class="headerlink" title="创建XML配置规范"></a>创建XML配置规范</h3><p>在XML配置中，意味着要创建一个XML文件。并且要以<beans>元素为根。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.10.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></beans></p><h3 id="声明一个简单的"><a href="#声明一个简单的" class="headerlink" title="声明一个简单的"></a>声明一个简单的<bean></bean></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.16.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="借助构造器注入初始化bean"><a href="#借助构造器注入初始化bean" class="headerlink" title="借助构造器注入初始化bean"></a>借助构造器注入初始化bean</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.18.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="导入和混合配置"><a href="#导入和混合配置" class="headerlink" title="导入和混合配置"></a>导入和混合配置</h2><p>关于混合配置，首先不要在意装配的bean来自哪里，自动装配会考虑到Spring容器中所有bean，不管是在JavaConfig或XML中声明还是组件扫描获得的。</p><h3 id="在JavaConfig中引用XML配置"><a href="#在JavaConfig中引用XML配置" class="headerlink" title="在JavaConfig中引用XML配置"></a>在JavaConfig中引用XML配置</h3><p>可以有一个更高级别的配置类，在类中使用<strong>@Import</strong>将两个配置类组合在一起：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.58.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8810.57.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>假如配置在了XML中，则Spring可以使用<strong>@ImportResource</strong>注解加载。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8A%E5%8D%8811.00.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两个bean，配置在JavaConfig中以及配置在XML中都会被加载到Spring容器中。</p><h3 id="在XML配置中引入JavaConfig"><a href="#在XML配置中引入JavaConfig" class="headerlink" title="在XML配置中引入JavaConfig"></a>在XML配置中引入JavaConfig</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%881.41.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不管使用JavaConfig还是使用XML进行装配，通常都会创建一个根配置(root configuration)，这个配置会将两个或更多的装配类和或XML文件组合起来。也会在根配置中启用组件扫描(通过<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>或@ComponentScan)。</p><h1 id="高级装配"><a href="#高级装配" class="headerlink" title="高级装配"></a>高级装配</h1><h2 id="环境与profile"><a href="#环境与profile" class="headerlink" title="环境与profile"></a>环境与profile</h2><h3 id="配置profile-bean"><a href="#配置profile-bean" class="headerlink" title="配置profile bean"></a>配置profile bean</h3><p>要使用profile，首先要讲所有不同的bean定义整理到一个或多个profile之中，将应用部署到每个环境时，要确保对应的profile处于激活(active)的状态。在Java配置中，可以使用<strong>@Profile</strong>注解指定某个bean属于哪个profile。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%881.54.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Profile</strong>注解应用在了类级别上，它会告诉Spring这个配置类中的bean只有在dev profile激活时才会被创建，如果没有激活的话，那么带有@Bean注解的方法都会被忽略掉。</p><h3 id="在XML中配置profile"><a href="#在XML中配置profile" class="headerlink" title="在XML中配置profile"></a>在XML中配置profile</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%882.01.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="激活profile"><a href="#激活profile" class="headerlink" title="激活profile"></a>激活profile</h3><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性:spring.profiles.active和spring.profiles.default. 如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile 是激活的。但如果没有设置spring .profiles.active属性的话，那Spring 将会查找spring.profiles.default的值。如果spring.profiles.active 和spring.profiles.default均没有设置的话，那就没有激活的profile,因此只会创建那些没有定义在profile中的bean。</p><p>有多种方式来设置这两个属性：<br>1.作为DispatcherServlet的初始化参数;<br>2.作为Web应用的上下文参数;<br>3.作为JNDI条目;<br>4.作为环境变量;<br>5.作为JVM的系统属性;<br>6.在集成测试类上，使用@ActiveProfiles注解设置。</p><h2 id="条件化的bean"><a href="#条件化的bean" class="headerlink" title="条件化的bean"></a>条件化的bean</h2><p><strong>@Conditional</strong>注解可以用到带有@Bean注解的方法上，如果给定的条件计算结果为true，就会创建这个bean，否则，这个bean会被忽略。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%882.12.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>设置给<strong>@Conditional</strong>的类可以是任意实现了Condition接口的类型。这个接口实现起来很简单直接，只需提供matches()方法实现即可。如果matches()方法返回true，就会创建带有<strong>@Conditional</strong>注解的bean，返回false则不会创建这些bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.10.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过ConditionContext，可以做到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.15.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>AnnotatedTypeMetadata则能够让我们检查带有@Bean注解的方法还有其他什么注解。借助isAnnotated()方法，我们能够判断带有@Bean注解的方法是不是还有其他特定的注解。借助其他的那些方法,我们能够检查@Bean注解的方法上其他注解的属性。</p><p>@Profile注解如下所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.40.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>@Profile本身也使用了@Conditional注解，并且在做出决策的过程中，考虑到了ConditionContext和AnnotatedTypeMetadata中的多个因素。</p><h2 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h2><p>仅有一个bean匹配所需的结果时，自动装配才是有效的，如果不仅有一个bean能匹配结果的话，这种歧义性会阻碍Spring自动装配属性，构造器参数或方法参数。可以将可选bean中的某一个设为首选(primary)的bean，或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。</p><h3 id="标示首选的bean"><a href="#标示首选的bean" class="headerlink" title="标示首选的bean"></a>标示首选的bean</h3><p>使用<strong>@Primary</strong>注解<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.52.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果是通过Java配置显式声明，应该如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%883.54.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用XML<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.12.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="限定自动装配的bean"><a href="#限定自动装配的bean" class="headerlink" title="限定自动装配的bean"></a>限定自动装配的bean</h3><p>Spring的限定符能够在所有可选的bean上进行缩小范围的操作,最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性,那么可以继续使用更多的限定符来缩小选择范围。</p><p>@Qualifier注解是使用限定符的主要方式，它可以与<strong>@Autowired</strong>和<strong>@Inject</strong>协同使用，在注入时指定想要注入进去的是哪个bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.42.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>@Qualifier注解所设置的参数就是想要注入的bean的ID。</p><h3 id="创建自定义的限定符"><a href="#创建自定义的限定符" class="headerlink" title="创建自定义的限定符"></a>创建自定义的限定符</h3><p>自己为bean设置自己的限定符。在bean声明上添加<strong>@Qualifier</strong>注解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.43.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在注入的地方，只要引用cold限定符就可以了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.46.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过Java配置显式定义bean时，@Qualifier也可以与@Bean注解一起使用：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%884.47.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用自定义的限定符注解"><a href="#使用自定义的限定符注解" class="headerlink" title="使用自定义的限定符注解"></a>使用自定义的限定符注解</h3><p>比如自定义<strong>@Cold</strong>注解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在注入点使用必要的限定符注解进行任意组合，从而将可选范围缩小到只有一个bean满足需求。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.07.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过声明自定义的限定符注解，可以同时使用多个限定符。</p><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><p>在默认情况下，Spring 应用上下文中所有bean都是作为以单例(singleton) 的形式创建的。也就是说，不管给定的一个bean被注人到其他bean多少次，每次所注入的都是同一个实例。</p><p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括：<br>1.单例( Singleton):在整个应用中，只创建bean的一个实例。<br>2.原型( Prototype):每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。<br>3.会话(Session): 在Web应用中，为每个会话创建一个bean实例。<br>4.请求(Rquest):在Web应用中，为每个请求创建一个bean实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.30.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里使用ConfigurableBeanFactory类的SCOPE_ PROTOTYPE 常量设置了原型作用城。当然也可以使用@Scope (“prototype”),但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。</p><p>java配置中声明为原型bean则使用：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.44.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>XML配置bean，使用<bean>元素的scope属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.46.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></bean></p><h3 id="使用会话和请求作用域"><a href="#使用会话和请求作用域" class="headerlink" title="使用会话和请求作用域"></a>使用会话和请求作用域</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%885.50.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>就购物车bean而言，会话作用域是最为合适的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.00.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>proxyMode</strong>属性的配置表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean。<br>如果ShoppingCart是接口而不是类的话，这是可以的(最为理想的代理模式)。但如果ShoppingCart是一个具体的类的话, Spring 就没有办法创建基于接口的代理了。此时，它必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体类的话,我们必须要将proxyMode属性设置为ScopedProxyMode .TARGET_ CLASS,以此来表明要以生成目标类扩展的方式创建代理。</p><h3 id="在XML中声明作用域代理"><a href="#在XML中声明作用域代理" class="headerlink" title="在XML中声明作用域代理"></a>在XML中声明作用域代理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.11.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><a href="aop:scoped-proxy" target="_blank" rel="noopener">aop:scoped-proxy</a>是与@Scope注解的proxyMode属性功能相同的SpringXML配置元素。它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLib创建目标类的代理。但是我们也可以将proxy-target-class 属性设置为false,进而要求它生成基于接口的代理。</p><h2 id="运行时值注入"><a href="#运行时值注入" class="headerlink" title="运行时值注入"></a>运行时值注入</h2><p>当讨论依赖注入的时候，我们通常所讨论的是将一个 bean引用注入到另一个bean的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象进行关联。</p><p>bean装配的另外一个方面指的是将一个值注入到bean的属性或者构造器参数中。Spring提供了两种在运行时求值的方式：<br>1.属性占位符<br>2.Spring表达式语言(SpEL)</p><h3 id="注入外部的值"><a href="#注入外部的值" class="headerlink" title="注入外部的值"></a>注入外部的值</h3><p>处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.55.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%886.55.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="解析属性占位符"><a href="#解析属性占位符" class="headerlink" title="解析属性占位符"></a>解析属性占位符</h3><p>Spring一直支持将属性定义到外部的属性的文件中，并使用占位符值将其插入到Spring bean中，占位符的形式为”${…}”<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-28%20%E4%B8%8B%E5%8D%887.02.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XML配置没有使用任何硬编码的值。</p><h3 id="使用Spring表达式语言进行装配"><a href="#使用Spring表达式语言进行装配" class="headerlink" title="使用Spring表达式语言进行装配"></a>使用Spring表达式语言进行装配</h3><h1 id="面向切面的Spring"><a href="#面向切面的Spring" class="headerlink" title="面向切面的Spring"></a>面向切面的Spring</h1><p>在软件开发中，散布于应用多处的功能被称为横切关注点。这些横切关注点从概念上是与应用的业务逻辑相分离的。把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。</p><h2 id="什么是面向切面编程"><a href="#什么是面向切面编程" class="headerlink" title="什么是面向切面编程"></a>什么是面向切面编程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8A%E5%8D%8810.14.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果要重用通用功能的话，最常见的面向对象技术是继承或委托。但是如果在应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系；使用委托可能需要对委托对象进行复杂得调用。切面提供了取代继承和委托的另一种可选方案，在很多场景下更清晰简洁，在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面。</p><p>这样做有两个好处:首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中;其次，服务模块更简洁，因为它们只包含主要关注点(或核心功能)的代码，而次要关注点的代码被转移到切面中了。</p><h3 id="定义AOP术语"><a href="#定义AOP术语" class="headerlink" title="定义AOP术语"></a>定义AOP术语</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8A%E5%8D%8810.27.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>通知(Advice)：</strong><br>在AOP术语中，切面的工作被称为通知。<br>Spring切面可以应用5种类型的通知：</p><ol><li>前置通知(Before):在目标方法被调用之前调用通知功能;</li><li>后置通知(After): 在目标方法完成之后调用通知，此时不会关心方法的输出是什么;</li><li>返回通知(After-returning):在目标方法成功执行之后调用通知;</li><li>异常通知( After-throwing):在目标方法抛出异常后调用通知;</li><li>环绕通知( Around):通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ol><p><strong>连接点(Join point):</strong><br>切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p><strong>切点(Poincut):</strong><br>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。</p><p><strong>切面(Aspect):</strong><br>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容一它是什么 ,在何时和何处完成其功能。</p><p><strong>引入(Introduction):</strong><br>引入允许我们向现有的类添加新方法或属性。</p><p><strong>织入(Weaving):</strong><br>织人是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入:</p><ol><li>编译期:切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期:切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入( load-time weaving, LTW )就支持以这种方式织入切面。</li><li>运行期:切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ol><h3 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h3><p>Spring 提供了4种类型的AOP支持:</p><ol><li>基于代理的经典Spring AOP;</li><li>纯POJO切面;</li><li>@AspectJ注解驱动的切面; </li><li>注入式AspectJ切面( 适用于Spring各版本)。</li></ol><hr><p><strong>Spring通知是Java编写的</strong><br>Spring所创建的通知都是用标准的Java类编写的。可以使用与普通Java开发一样的(IDE) 来开发切面。定义通知所应用的切点通常会使用注解或在Spring配置文件里采用XML来编写,这两种语法对于Java开发者来说都是相当熟悉的。</p><p>AspectJ与之相反。虽然AspectJ现在支持基于注解的切面,但AspectJ 最初是以Java语言扩展的方式实现的。这种方式有优点也有缺点。通过特有的AOP语言，可以获得更强大和细粒度的控制，以及更丰富的AOP工具集，但是需要额外学习新的工具和语法。</p><hr><p><strong>Spring在运行时通知对象</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%8812.42.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法前，会执行切面逻辑。</p><p>直到应用需要被代理的bean 时，Spring 才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring 才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织人Spring AOP的切面。</p><hr><p><strong>Spring只支持方法级别的连接点</strong><br>因为Spring基于动态代理，所以Spring只支持方法连接点。这与一些其他的AOP框架是不同的，例如AspectJ和JBoss，除了方法切点，还提供了字段和构造器接入点。Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，无法在bean创建时应用通知。</p><p>但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么我们可以利用Aspect来补充Spring AOP的功能。</p><h2 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h2><p>在SpringAOP中，要使用AspectJ的切点表达式语言来定义切点。</p><h3 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.13.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.13.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用execution ()指示器选择Performance的perform()方法。方法表达式以“*”号开始，表明不关心方法返回值的类型。然后指定了全限定类名和方法名。对于方法参数列表，使用两个点好(..)表明切点要选择任意的perform()方法，无论该方法的入参是什么。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.18.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="在切点中选择bean"><a href="#在切点中选择bean" class="headerlink" title="在切点中选择bean"></a>在切点中选择bean</h3><p>Spring引入一个新的bean()指示器，允许在切点表达式中使用bean的ID来标识bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.39.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h2><h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.44.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.45.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以使用<strong>@Pointcut</strong>注解设置一个切点表达式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%882.48.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>performance ()方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供@Pointcut注解依附。</p><p>接下来在JavaConfig的配置类级别上通过使用<strong>@EnableAspectJAutoProxy</strong>注解启动自动代理功能。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%883.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XML装配bean需要使用Spring aop。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%883.03.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h3><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.13.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Around</strong>注解表明方法作为切点的环绕通知。这个通知所达到的效果与之前的前置通知和后置通知是一样的。现在它们在同一个方法中，不像之前分散。</p><p>它接受ProceedingJoinPoint作为参数。这个对象是必须要有的，因为要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用ProceedingJoinPoint的proceed()方法。</p><p>别忘记调用proceed()方法，如果不调用这个方法，通知实际上会阻塞对被通知方法的调用。</p><h3 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.37.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.37.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h3><p>利用被称为引入的AOP概念，切面可以为Spring bean添加新方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%886.50.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.01.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@DeclareParents</strong>注解由三部分组成：<br>1.value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现Performance的类型。(标记符后面的加号表示是Performance的所有子类型，而不是Performance本身。)<br>2.defaultImpl属性指定了为引入功能提供实现的类。在这里，我们指定的是De faultEncoreable提供实现。<br>3.@DeclareParents注解所标注的静态属性指明了要引入了接口。在这里，我们所引入的是Encoreable接口。</p><h2 id="在XML中声明切面"><a href="#在XML中声明切面" class="headerlink" title="在XML中声明切面"></a>在XML中声明切面</h2><p>如果需要声明切面，但又不能Wie通知类添加注解时，就必须转向XML配置了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.37.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>定义命名切点<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.41.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.41.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在切点是在一个地方定义的，并且被多个通知元素所引用。</p><h3 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.48.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.48.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.51.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.51.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.52.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.54.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>delegate-ref属性引用了一个Spring bean作为引入的委托。这需要在Spring上下文中存在一个ID为encoreableDelegate的bean。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%E5%AE%9E%E6%88%98%20%20Spring%E6%A0%B8%E5%BF%83/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-30%20%E4%B8%8B%E5%8D%887.57.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用default-impl来直接标识委托和间接使用delegate-ref 的区别在于后者是Spring bean,它本身可以被注人、通知或使用其他的Spring配置。</p><h2 id="注入AspectJ切面"><a href="#注入AspectJ切面" class="headerlink" title="注入AspectJ切面"></a>注入AspectJ切面</h2><p>虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP是一个功能比较弱的AOP解决方案。AspectJ提供了Spring AOP所不能支持的许多类型的切点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>AOP是面向对象编程的一个强大补充。通过AspectJ,我们现在可以把之前分散在应用各处的行为放人可重用的模块中。我们显示地声明在何处如何应用该行为。这有效减少了代码冗余，并让我们的类关注自身的主要功能。</p><p>Spring提供了一个AOP框架，让我们把切面插人到方法执行的周围。现在我们已经学会如何把通知织人前置、后置和环绕方法的调用中，以及为处理异常增加自定义的行为。</p><p>关于在Spring应用中如何使用切面，我们可以有多种选择。通过使用@AspectJ注解和简化的配置命名空间，在Spring中装配通知和切点变得非常简单。</p><p>最后，当Spring AOP不能满足需求时，我们必须转向更为强大的AspectJ。对于这些场景，我们了解了如何使用Spring为AspectJ切面注入依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简要概念&quot;&gt;&lt;a href=&quot;#简要概念&quot; class=&quot;headerlink&quot; title=&quot;简要概念&quot;&gt;&lt;/a&gt;简要概念&lt;/h1&gt;&lt;p&gt; &lt;strong&gt;依赖注入&lt;/strong&gt;&lt;br&gt;方式1：构造器注入。&lt;/p&gt;
&lt;p&gt;创建应用组件之间协作行为通常称为&lt;s
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
      <category term="Spring" scheme="https://github.com/zdkswd/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Android梳理</title>
    <link href="https://github.com/zdkswd/2019/05/27/Android%E6%A2%B3%E7%90%86/"/>
    <id>https://github.com/zdkswd/2019/05/27/Android梳理/</id>
    <published>2019-05-27T07:28:47.000Z</published>
    <updated>2019-05-27T07:29:41.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h2><p>其核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。要使用多态，在声明对象时就应该遵循一条法则：声明的总是父类类型或接口类型，创建的是实际类型。</p><blockquote><p>List list =newArrayList(); ✔️<br>ArrayList list =newArrayList(); ❎  </p></blockquote><p>在定义方法参数时也通常总是应该优先使用父类类型或接口类型。</p><blockquote><p>publicvoid doSomething(List list);✅<br>publicvoid doSomething(ArrayList list);❎  </p></blockquote><p>这样声明最大的好处在于结构的灵活性：假如某一天我认为ArrayList的特性无法满足我的要求，我希望能够用LinkedList来代替它，那么只需要在对象创建的地方把new ArrayList()改为new LinkedList即可，其它代码一概不用改动。</p><p>虚拟机会在执行程序时动态调用实际类的方法，它会通过一种名为动态绑定（又称延迟绑定）的机制自动实现，这个过程对程序员来说是透明的。</p><h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/u=2881300128,2318356091&fm=173&app=25&f=JPEG.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Throwable 是所有异常类型的基类，Throwable 下一层分为两个分支，Error 和 Exception.</p><p>Error 描述了 JAVA 程序运行时系统的内部错误，通常比较严重，除了通知用户和尽力使应用程序安全地终止之外，无能为力，应用程序不应该尝试去捕获这种异常。通常为一些虚拟机异常，如 StackOverflowError 等。</p><p>Exception 类型下面又分为两个分支，一个分支派生自 RuntimeException，这种异常通常为程序错误导致的异常；另一个分支为非派生自 RuntimeException 的异常，这种异常通常是程序本身没有问题，由于像 I/O 错误等问题导致的异常，每个异常类用逗号隔开。</p><p>受查异常<br>受查异常会在编译时被检测。如果一个方法中的代码会抛出受查异常，则该方法必须包含异常处理，即 try-catch 代码块，或在方法签名中用 throws 关键字声明该方法可能会抛出的受查异常，否则编译无法通过。</p><blockquote><p>private static void readFile(String filePath) throws IOException {  </p></blockquote><p>非受查异常不会在编译时被检测。JAVA 中 Error 和 RuntimeException 类的子类属于非受查异常，除此之外继承自 Exception 的类型为受查异常。</p><p>处理RuntimeException的原则是：如果出现RuntimeException，那么一定是程序员的错误。受检查的异常（IOException等）：这类异常如果没有try……catch也没有throws抛出，编译是通不过的。这类异常一般是外部错误，例如文件找不到、试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。</p><h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><h3 id="8种基本数据类型（所占字节数）"><a href="#8种基本数据类型（所占字节数）" class="headerlink" title="8种基本数据类型（所占字节数）"></a>8种基本数据类型（所占字节数）</h3><p>byte(1) char(2) short(2) int(4) float(4) double(8) long(8) boolean(1)<br>boolean类型比较特别，多个boolean可能共同占用一个字节。 </p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String不是基本数据类型，是引用类型，底层用char数组实现的，因为String是final类，在java中被final修饰的类不能被继承，因此String不可以被继承。</p><h2 id="Java的IO"><a href="#Java的IO" class="headerlink" title="Java的IO"></a>Java的IO</h2><h3 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h3><p>首先明确“字节（Byte）”和“字符（Character）”的大小：<br>1 byte = 8 bit<br>1 char = 2 byte = 16 bit (Java默认UTF-16编码)</p><p>总而言之，一切都是字节流，其实没有字符流这个东西。字符只是根据编码集对字节流翻译之后的产物。面向字节流的InputStream和OutputStream<br>面向字符的Reader和Writer，即为字节流继承于InputStream和OutputStream，字符流继承于InputStreamReader和OutputStreamWriter。</p><h3 id="字节流转字符流"><a href="#字节流转字符流" class="headerlink" title="字节流转字符流"></a>字节流转字符流</h3><p>字节输入流转字符输入流通过InputStreamReader实现,该类的构造函数可以传入InputStream对象。字节输出流转字符输出流通过OutputStreamWriter实现,该类的构造函数可以传入OutputStream对象。</p><h3 id="将java对象序列化到文件"><a href="#将java对象序列化到文件" class="headerlink" title="将java对象序列化到文件"></a>将java对象序列化到文件</h3><p>在java中能够被序列化的类必须先实现Serializable接口，该接口没有任何抽象方法只是起到一个标记作用。当试图对一个对象进行序列化的时候，如果该对象没有实现 Serializable 接口，将抛出NotSerializableException<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%889.43.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%889.44.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>s​e​r​i​a​l​V​e​r​s​i​o​n​U​I​D​:​ ​字​面​意​思​上​是​序​列​化​的​版​本​号​，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量</p><p>显式地定义serialVersionUID有两种用途：<br>1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p><h2 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h2><p>容器Container，和Array的最大区别就是它们的长度都是自动变化的，根本无需你干预。<br>Container 从总体上来看分为两类，一类叫做集合Collection ，另一类则叫做映射Map。<br>区别很简单在Map中，对象必须是成对存放的，这个对就叫做key-value，而集合则不是。集合又分为集<strong>Set</strong>、序列<strong>List</strong>和队列<strong>Queue</strong>。向Map中添加元素的方法是put(K key, V value)，而向Collection中添加则是add(E e)。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>集Set、序列List和队列Queue 之所以说他们属于Collection，是因为他们都实现了Collection这个interface。并且他们也不是“实现类”，而是interface，他们并不能直接使用。</p><h3 id="对集合排序"><a href="#对集合排序" class="headerlink" title="对集合排序"></a>对集合排序</h3><p>凡是对集合的操作，应该保持一个原则就是能用JDK中的API就用JDK中的API，比如排序算法不应去用冒泡或者选择排序，而是首先想到用Collections集合工具类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/2C0DE4ED-7B71-4EF6-8D65-EE2586A71797.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Collection常用的方法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8A%E5%8D%889.15.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="集合的实现类"><a href="#集合的实现类" class="headerlink" title="集合的实现类"></a>集合的实现类</h3><p>List：ArrayList(数组实现) LinkedList（链表实现）</p><p>Set：HashSet TreeSet LinkedHashMap （三种与Map实现类相同）<br>Set的特点是元素不能重复，在元素添加过程中，最重要的一个步骤就是进行对比，将对象通过Hash后对比速度飞起。</p><p>Queue：ArrayDeque(双端队列) PriorityQueue(保证最小的在顶上，并不是全部排序)</p><h3 id="集合的安全性问题"><a href="#集合的安全性问题" class="headerlink" title="集合的安全性问题"></a>集合的安全性问题</h3><p>ArrayList,HashSet,HashMap不是没有加锁，显然都是线程不安全的。</p><p>在集合中 Vector和 HashTable倒是线程安全的。你打开源码会发现其实就是把各自核心方法添加上了<strong>synchronized</strong>关键字</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-1448f5b62001bb691d1577ab574d3d13_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>单看Key，不就是Set吗，Set就是用Map实现的，可以说Set是Map的一种特殊应用。Map中也有一个叫做KeySet()的方法，直接返回一个Set。</p><h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="创建的两种方式"><a href="#创建的两种方式" class="headerlink" title="创建的两种方式"></a>创建的两种方式</h3><p>java.lang.Thread类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行,由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread类或者直接实现Runnable接口来重写run()方法实现线程。</p><h3 id="sleep和wait"><a href="#sleep和wait" class="headerlink" title="sleep和wait"></a>sleep和wait</h3><p>最大的不同是在等待时wait会释放锁,而sleep 一直持有锁。wait通常被用于线程间交互, sleep通常被用于暂停执行。</p><h3 id="synchronized和volatile关键字"><a href="#synchronized和volatile关键字" class="headerlink" title="synchronized和volatile关键字"></a>synchronized和volatile关键字</h3><p>一旦一个共享变量(类的成员变量、类的静态成员变量)被<strong>volatile</strong>修饰之后,那么就具备了两层语义:<br>1 )保证了不同线程对这个变量进行操作时的可见性,即一个线程修改了某个变量的值,这新值对其他线程来说是立即可见的。<br>2 )禁止进行指令重排序。<br>volatile本质是在告诉jvm当前变量在寄存器(工作内存)中的值是不确定的,需要从主存中读取，精确地说就是，编译优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p><p><strong>synchronized</strong>则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住。</p><p>两者的区别：<br>1.voltile仅能使用在变量级别;synchronized 则可以使用在变量、方法、和类级别的。<br>2.volatile仅能实现变量的修改可见性,并不能保证原子性;synchronized 则可以保证变量的修改可见性和原子性。<br>3.volatile不会造成线程的阻塞;synchronized 可能会造成线程的阻塞。<br>4.volatile标记的变量不会被编译器优化;synchronized 标记的变量可以被编译器优化。</p><h3 id="一道线程安全的题"><a href="#一道线程安全的题" class="headerlink" title="一道线程安全的题"></a>一道线程安全的题</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8B%E5%8D%881.48.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述代码执行后输出的结果不等于1000。</p><p>在java的内存模型中每一个线程运行时都有一个线程栈,线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候,首先通过对象的引用找到对应在堆内存的变量的值,然后把堆内存变量的具体值load到线程本地内存中,建立-个变量副本 ,之后线程就不再和对象在堆内存变量值有任何关系,而是直接修改副本变量的值，在修改完之后的某一个时刻(线程退出之前) ,自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。</p><p>也就是说上面主函数中开启了1000 个子线程,每个线程都有一个变量副本,每个线程修改变量只是临时修改了自己的副本,当线程结束时再将修改的值写入在主内存中, 这样就出现了线程安全问题。因此结果就不可能等于1000了。一般都会小于1000。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8B%E5%8D%881.50.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="线程池与使用"><a href="#线程池与使用" class="headerlink" title="线程池与使用"></a>线程池与使用</h3><p>线程池就是事先将多个线程对象放到一个容器中,当使用的时候就不用new线程而是直接去池中拿线程即可,节省了开辟子线程的时间,提高的代码执行效率。</p><h1 id="Java-SE高级"><a href="#Java-SE高级" class="headerlink" title="Java SE高级"></a>Java SE高级</h1><h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java中的反射首先是能够获取到Java中要反射类的字节码.获取字节码有三种方法，1.Class.forName(className) 2.类名.class 3.this.getClass(). 然后将字节码中的方法,变量,构造函数等映射成相应的Method. Filed, Constructor 等类,这些类提供了丰富的方法可以被我们所使用。</p><h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p>创建对象的过程<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-9cd31ab516bd967e1b8e68736931f8ba_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-eddc430b991c58039dfc79dd6f3139cc_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建一个实例，最关键的就是得到对应的Class对象。</p><p>代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/v2-e302487f952bdf8e284afc0d8d6a770b_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>动态代理的使用场景：<br>(1)设计模式中有一个设计原则是开闭原则，是说对修改关闭对扩展开放，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑<br>，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行增强。</p><p>(2)我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。</p><p>(3)Spring的AOP机制就是采用动态代理的机制来实现切面编程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-24%20%E4%B8%8B%E5%8D%882.52.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Java中的设计模式"><a href="#Java中的设计模式" class="headerlink" title="Java中的设计模式"></a>Java中的设计模式</h1><p>设计模式供分为三大类：<br>1、创建型模式，共五种:<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>单例模式</strong>、<strong>建造者模式</strong>。原型模式。<br>2、结构型模式,共七种:<strong>适配器模式</strong>、装饰器模式、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。<br>3、行为型模式，共十一种:<strong>策略模式</strong>，模板方法模式、<strong>观察者模式</strong>，迭代子模式、责任链模式、命令模式、 备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h1><h2 id="如何避免ANR"><a href="#如何避免ANR" class="headerlink" title="如何避免ANR"></a>如何避免ANR</h2><p>ANR：Application Not Responding。不同组件发生ANR的时间不一样，主线程(Activity,Service)是5秒，BroadCastReceiver是10秒。</p><p>解决方案：将所有耗时操作,比如访问网络, Socket通信,查询大量SQL语句,复杂逻辑计算等都放在子线程中去,然后通过handler.sendMessage. runonUITread. AsyncTask等方式更新UI,无论如何都要确保用户界面操作的流畅度。如果耗时操作需要让用户等待,那么可以在界面上显示进度条。</p><h2 id="sim卡的EF文件"><a href="#sim卡的EF文件" class="headerlink" title="sim卡的EF文件"></a>sim卡的EF文件</h2><p>基本文件EF(Elementary File)是SIM卡文件系统的一部分。</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="什么是Activity"><a href="#什么是Activity" class="headerlink" title="什么是Activity"></a>什么是Activity</h3><p>四大组件之一，一般一个用户交互界面对应一个activity<br>activity是Context的子类，同时实现了window.callback和keyevent.callback,可以处理与窗体用户交互事件。</p><h3 id="activity生命周期"><a href="#activity生命周期" class="headerlink" title="activity生命周期"></a>activity生命周期</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Android%E6%A2%B3%E7%90%86/4aa93209cbaef5c2a9bbd2003d928641_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一般情况下<br>按下<strong>home</strong>键:前台Activity依次回调onPause, onStop；<br>按下<strong>back</strong>键:前台Activity依次回调onPause, onStop, onDestroy；<br>按下<strong>电源键</strong>：前台Activity依次onPause, onStop；<br>对于<strong>进程管理器</strong>，采用的force-stop的方式，也是直接强杀进程，并且连广播都会隔断。</p><p>横竖屏切换：在未做任何处理的情况，旋转后，Activity生命周期重新运行:onPause, onStop, onDestroy, onCreate, onStart, onRestoreInstanceState, onResume。<br> 常用Activity：FragmentActivity,ListActivity,TabActivity。</p><h3 id="如何保存Activity的状态？"><a href="#如何保存Activity的状态？" class="headerlink" title="如何保存Activity的状态？"></a>如何保存Activity的状态？</h3><p>覆写onSaveInstanceState()方法，该方法接受一个Bundle类型的参数，开发者可以将状态数据存储到这个Bundle对象中，这样即使Activity被系统摧毁，开发者也可以利用这些数据将Activity恢复到被摧毁前的状态。</p><h3 id="Activity跳转"><a href="#Activity跳转" class="headerlink" title="Activity跳转"></a>Activity跳转</h3><p>两个activityAB，A里面激活B时，A会调用onPause()方法，然后B调用onCreate(),onStart(),onResume()方法。B覆盖窗体，A会调用onStop()方法。如果B是个透明的，或者是对话框的样式，就不会调用A的onStop()方法。</p><h3 id="Context，Activity，Application的区别"><a href="#Context，Activity，Application的区别" class="headerlink" title="Context，Activity，Application的区别"></a>Context，Activity，Application的区别</h3><p>Context维护的是当前的Activity的生命周期，Application维护的是整个项目的生命周期。</p><h3 id="两个Activity之间传递数据，除了intent，广播接收者，Content-provider还有什么？"><a href="#两个Activity之间传递数据，除了intent，广播接收者，Content-provider还有什么？" class="headerlink" title="两个Activity之间传递数据，除了intent，广播接收者，Content provider还有什么？"></a>两个Activity之间传递数据，除了intent，广播接收者，Content provider还有什么？</h3><p>1、利用static静态数据，public static成员变量。<br>2、利用外部存储的传输，File文件存储，SharedPreferences，Sqlite数据库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;Java多态&quot;&gt;&lt;a href=&quot;#Java多态&quot; class=&quot;headerlink&quot; title=&quot;Java多
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot实战 入门</title>
    <link href="https://github.com/zdkswd/2019/05/27/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/zdkswd/2019/05/27/Spring Boot实战 入门/</id>
    <published>2019-05-27T07:00:47.000Z</published>
    <updated>2019-05-27T07:21:22.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h1><p><strong>初始化后的项目</strong><br>Application.java不仅是启动引导类，还是配置类。<br><strong>@SpringBootApplication</strong>开启组件扫描和自动配置。将三个有用的注解组合在了一起。<br>1.Spring的<strong>@Configuration</strong>:标明该类使用Spring基于Java的配置。<br>2.Spring的<strong>@ComponentScan</strong>:启用组件扫描，这样所写的Web控制器类和其他组件才能被自动发现并注册为Spring应用程序上下文中里的Bean。<br>3.Spring Boot的<strong>@EnableAutoConfiguration</strong>:这一行配置开启了Spring Boot自动配置的魔力，可以不再写成篇的配置了。</p><p><strong>application.properties</strong>可以很方便地细粒度调整Spring Boot的自动配置。完全不用告诉Spring Boot加载application.properties,只要存在就会被加载。</p><p> <strong>Spring Boot项目构建插件</strong><br>Spring Boot的构建插件对构建过程有所帮助，如Maven钟spring-boot-maven-plugin。构建插件的主要功能是把项目打包成一个可执行的超级JAR，包括把应用程序的所有依赖打入JAR文件中，并为JAR添加一个描述文件，其中的内容能用java -jar来运行应用程序。</p><p><strong>指定基于功能的依赖</strong><br>并不需要指定版本号，起步依赖本身的版本是由正在使用的Spring Boot的版本来决定的，而起步依赖则会决定它们引入的传递依赖版本。<br>Maven和gradle中使用构建工具来显示包含项目汇总每一个库以及它们的版本。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.13.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>![]<br>(/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.13.40.png)</p><p><strong>覆盖起步依赖引入的传递依赖</strong><br>gradle</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.15.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Maven<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.16.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要指定版本的依赖，则可以在pom.xml中覆盖传递依赖引入的另一个依赖。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.18.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>gradle则是倾向于使用更新的依赖，若要指定老版本的生效，则要先将较新版本的exclude。</p><p><strong>使用自动配置</strong><br>Spring Boot的自动配置是一个运行时的过程，考虑了众多的因素，才决定Spring配置应该用哪一个不该用哪一个。例如。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.22.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>专注于应用程序功能：1.定义领域模型如一个实体。2.定义仓库接口。3.创建Web界面。</p><p>1.<strong>@Entity</strong>注解表明对象是一个JPA实体。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.25.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>id属性加了<strong>@Id</strong>和<strong>@GeneratedValue</strong>注解，说明这个字段是实体的唯一标识，并且这个字段的值是自动生成的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.26.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>2.通过扩展JpaRepository,ReadingListRespository直接继承了18个执行常用持久化操作的方法。JpaRepository是个泛型接口，有两个参数：仓库操作的领域对象类型，及ID属性的类型。以及自己增加的方法findByReader()。只需定义仓库接口，在应用程序启动后，该接口在运行时会自动实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>3.使用SpringMVC为应用程序处理HTTP请求。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8A%E5%8D%888.37.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Controller</strong>注解，组件扫描会自动将其注册为Spring应用程序上下文的一个Bean。<br><strong>@RequestMapping</strong>注解，将其中所有的处理器方法都映射到了”/”这个URL路径上。</p><p>在向应用程序加入 Spring boot时,有个名为<strong>spring-boot-autoconfigurel.JAR</strong>文件,其中包含了很多配置类。每个配置类都在应用程序的Classpath里,都有机会为应用程序的配置添砖加瓦。这些配置类里有用于 Thymeleaf的配置,有用于 Spring data JPa的配置,有用于 Spiring mvc的配置<br>还有很多其他东西的配置,你可以自己选择是否在 Spring应用程序里使用它们。其中利用了Spring的条件化配置，条件化配置运行配置存在于应用程序中，但在满足某些特定条件之前都忽略这个配置。在Spring里可以很方便地编写自己的条件，要做的就是实现Condition接口，覆盖它的matches方法。</p><p>下面的简单条件类只有在Classpath里存在JdbcTemplate时才会生效。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%8812.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当用Java来声明Bean时，可以用自定义条件类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%8812.42.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在这个例子中，只有当JdbcTemplateCondition类的条件成立时才会创建MyService这个Bean。也就是说，MyService Bean创建条件是Classpath里有JdbcTemplate。否则，这个Bean的声明就会被忽略。</p><p><strong>Classpath</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/191992114-5b5c838544f7c_articlex.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>自动配置会做出以下配置决策，它们和之前的例子息息相关。<br>1.因为Classpath里有H2，所以会创建一个嵌入式H2数据库Bean，它的类型是javax.sql.DataSource,JPA实现( Hibernate )需要它来访问数据库。<br>2.因为Classpath里有Hibernate ( Spring Data JPA传递引入的)的实体管理器，所以自动配置会配置与Hibernate相关的Bean，包括Spring的LocalContainerEntityManagerFactory Bean和JpaVendorAdapter。<br>3.因为Classpath里有Spring Data JIPA，所以它会自动配置为根据仓库的接口创建仓库实现。<br>4.因为Classpath里有Thymeleaf,所以Thymeleaf会配置为Spring MVC的视图，包括一个Thymeleaf的模板解析器、模板引擎及视图解析器。视图解析器会解析相对于Classpath根目录的 / templates目录里的模板。<br>5.因为Classpath里有SpringMVC(归功于Web起步依赖)，所以会配置Spring的DispatcherServlet并启用Spring MVC。<br>6.因为这是一个Spring MVC Web应用程序,所以会注册一个资源处理器,把相对于Classpath根目录的 / static目录里的静态内容提供出来。(这个资源处理器还能处理 / public、/ resources和_META-INF_resources的静态内容。)<br>7.因为Classpath里有Tomcat(通过Web起步依赖传递引用),所以会启动一个嵌入式的Tomcat容器，监听8080端口。</p><h1 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h1><p><strong>覆盖Spring Boot自动配置</strong><br>正如上面所讲。</p><p><strong>@Configuration</strong>用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p><p><strong>通过属性文件外置配置。</strong><br>另一种方式是通过applocation.properties,yml也可以。</p><p>Spring Boot能从多种属性源获得属性，优先级从高到低是：<br>(1)命令行参数<br>(2) java: comp / env里的JNDI属性<br>(3)JVM系统属性<br>(4)操作系统环境变量<br>(5)随机生成的带random. * 前缀的属性<br>(6)应用程序以外的application. properties或者appliaction.yml文件<br>(7)打包在应用程序内的application.properties或者appliaction.yml文件<br>(8)通过@PropertySource标注的属性源<br>(9)默认属性</p><p>application. properties和application.yml文件能放在以下四个位置。优先级有高到低<br>(1)外置，在相对于应用程序运行目录的 / config子目录里。<br>(2)外置，在应用程序运行的目录里。<br>(3)内置，在config包内 。<br>(4)内置，在Classpath根目录。</p><p>同一优先级位置上，application.yml会覆盖application.properties的属性。</p><p>在application.yml / prop通常你都无需指定JDBC驱动，Spring Boot会根据数据库URL识别出需要的驱动，但如果识别出问题了，你还可以设置spring datasource.driver-class-name属性。在自动配置DataSourceBean的时候，SpringBoot会使用这里的连接数据。</p><p>DataSourceBean是一个连接池，如果Classpath里有Tomcat的连接池DataSource,那么就会使用这个连接池;否则，Spring Boot会在Classpath里查找以下连接池:HikariCP，Commons DBCP 2。还可以自己配置DataSource Bean,使用自己喜欢的各种连接池。</p><p><strong>应用程序Bean的配置外置</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%882.44.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@ConfigurationProperties</strong>注解说明该Bean的属性应该是（通过setter）从配置属性值注入的，更具体就是说明应该注入带amazon前缀的属性。</p><p>本例中ReadingListController只有一个setter方法，就是设置associateId属性用的setter方法。因此，设置Amazon Associate ID唯一要做的就是添加amazon.associateId属性，把它加入支持的任一属性源位置里即可。<br>例如在application.properties中设置：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%882.51.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>开启配置属性</strong>从技 术上来说，<strong>@ConfigurationProperties</strong>注解不会生效，除非先向Spring配置类添加<strong>@EnableConfigurationProperties</strong>注解。但通常无需这么做，因为Spring Boot自动配置后面的全部配置类都已经加上了<strong>@EnableConfigurationProperties</strong>注解。因此，除非你完全不使用自动配置，否则就无需显式地添加<strong>@EnableConfigurationProperties</strong>。</p><p>需要注意，Spring Boot的属性解析器非常智能，它会自动把驼峰规则的属性和使用连字符或下划线的同名属性关联起来。换句话说，amazon. associateId这个属性和amazon. associate_ id以及amazon.associate-id都是等价的。</p><p><strong>在一个类里收集属性</strong>，创建一个单独的Bean,为它加上<strong>@ConfigurationProperties</strong>注解，让这个Bean收集所有配置属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.08.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了加载amazon.associateld配置属性的AmazonProperties后，我们可以调整ReadingListController ,让它从注入的AmazonProperties中获取Amazon Associate ID。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.13.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>使用Profile进行配置</strong><br>Profile是一种条件化配置，基于运行时激活Profile，会使用或者忽略不同的Bean或配置类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.51.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>@Profile</strong>注解要求运行时激活production Profile,这样才能应用该配置。如果production Profile没有激活，就会忽略该配置。设置spring.profiles.active属性就能激活Profile，任意设置配置属性的方式都能用于设置这个值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-23%20%E4%B8%8B%E5%8D%883.57.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果正在使用application.properties，可以创建额外的属性文件，遵循application-{profile}.properties命名格式，就能提供特定于Profile的属性了。<br>比如说生产环境，就是application-production.properties。</p><p>使用YAML就可以把所有的Profile的配置属性都放在一个application.yml文件里，例如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Spring%20Boot%E5%AE%9E%E6%88%98%20%E5%85%A5%E9%97%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-27%20%E4%B8%8B%E5%8D%882.48.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动配置&quot;&gt;&lt;a href=&quot;#自动配置&quot; class=&quot;headerlink&quot; title=&quot;自动配置&quot;&gt;&lt;/a&gt;自动配置&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;初始化后的项目&lt;/strong&gt;&lt;br&gt;Application.java不仅是启动引导类，还是配置类。&lt;br
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://github.com/zdkswd/tags/Java/"/>
    
      <category term="Spring" scheme="https://github.com/zdkswd/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>百面 优化算法</title>
    <link href="https://github.com/zdkswd/2019/05/14/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/zdkswd/2019/05/14/百面 优化算法/</id>
    <published>2019-05-14T01:45:47.000Z</published>
    <updated>2019-05-14T01:47:09.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百面-优化算法"><a href="#百面-优化算法" class="headerlink" title="百面 优化算法"></a>百面 优化算法</h1><p>机器学习算法=模型表征+模型评估+优化算法<br>优化算法所做的事情就是在模型表征空间中找到模型评估指标最好的模型。<br>经典的支持向量机对应的模型表征和评估指标分别为线性分类模型和最大间隔，逻辑回归对应的模型表征和评估指标则分别为线性分类模型和交叉熵。</p><h1 id="有监督学习的损失函数"><a href="#有监督学习的损失函数" class="headerlink" title="有监督学习的损失函数"></a>有监督学习的损失函数</h1><p><strong>问：有监督学习涉及的损失函数有哪些？请列举并简述它们的特点。</strong></p><p>答：在有监督学习中，损失函数刻画了模型和训练样本的匹配程度。<br>对于二分类问题，最自然地损失函数是0-1损失。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.33.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中1p是指示函数，当且仅当p为真时取值为1，否则取值为0。该损失函数能够直观地刻画分类的错误率，但是由于其非凸非光滑的特点，使得算法很难直接对其进行优化。<br>0-1损失的一个代理损失函数是hinge损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.35.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>hinge损失函数是0-1损失函数相对紧的凸上界，且当fy&gt;=1时，该函数不对其做任何惩罚。hinge损失在fy=1处不可导，因此不能用梯度下降法进行优化，而是用<strong>次梯度下降法</strong>。<br>0-1损失的另一个代理损失函数是logistic损失函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.38.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>logistic损失函数也是0-1损失函数的凸上界，且该函数处处光滑，因此可以用梯度下降法进行优化。但是，该损失函数对所有样本点都有所惩罚，因此对异常值相对更敏感一些。<br>当预测值f属于[-1,1]时，另一个代理损失函数就是交叉熵损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.56.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>交叉熵损失函数也是0-1损失函数的光滑凸上界。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.57.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>对于回归问题，最常用的损失函数是平方损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%888.58.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>平方损失函数是光滑函数，能够用梯度下降法进行优化。当预测值距离真实值越远时，平方损失函数的惩罚力度越大，因为它对异常点比较敏感。可以采用绝对损失函数来解决这个问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.02.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>绝对损失对异常点更鲁棒一些，但是绝对损失函数在f=y处无法求导数。综合考虑可导性和对异常点的鲁棒性，可以采用huber损失函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.18.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> huber损失函数在|f-y|较小时为平方损失，在|f-y|较大时为线性损失，处处可导，且对异常点鲁棒。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.21.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="机器学习中的优化问题"><a href="#机器学习中的优化问题" class="headerlink" title="机器学习中的优化问题"></a>机器学习中的优化问题</h1><p><strong>问： 机器学习中优化问题，哪些是凸优化问题，哪些是非凸优化问题？</strong></p><p>答：凸函数，函数L是凸函数当且仅当对定义域中的任意两点x，y和任意实数λ∈[0,1]总有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.25.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>逻辑回归对应的就是凸优化问题，对于二分类问题，Y={1,-1},假设模型参数为θ，则逻辑回归的优化问题为。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.27.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以通过计算目标函数的二阶Hessian矩阵来验证凸性。令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.37.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对该函数求一阶导，得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.38.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>继续求导，得到函数的Hessian矩阵<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.39.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>该矩阵满足半正定的性质。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.40.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.41.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>函数L为凸函数。对于凸优化问题，所有的局部极小值都是全局极小值，因此这类问题一般认为是比较容易求解的问题。</p><p>主成分分析的优化问题为非凸优化问题。一般来说，非凸优化问题被认为是比较南求解的问题，但主成分分析是一个特例，我们可以借助SVD直接得到主成分分析的全局极小值。</p><p><strong>总结与扩展：</strong>其他凸优化的例子包括支持向量机，线性回归等线性模型，非凸优化问题的例子包括低秩模型(如矩阵分解),深度神经网络模型。</p><h1 id="经典优化算法"><a href="#经典优化算法" class="headerlink" title="经典优化算法"></a>经典优化算法</h1><p><strong>问题：无约束优化问题的优化方法有哪些？</strong>对于无约束优化问题：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%889.54.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中目标函数L是光滑的，求解该问题的优化算法有哪些，适用场景是什么。</p><p>答：优化算法分为<strong>直接法</strong>和<strong>迭代法</strong>。<br>直接法，就是能够直接给出优化问题的最优解。直接法不是万能的。直接法要求目标函数需要满足两个条件，第一个是，L是凸函数。二，若L是凸函数，那么θ是最优解的充分必要条件是L在θ处的梯度为0。<br>即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.00.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>经典的例子是岭回归，其最优解为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.04.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>直接法要满足的这两个条件限制了它的应用范围。因此，在很多实际问题中，会采用迭代法。迭代法就是迭代地修正对最优解得估计。迭代法又分为一阶法和二阶法两类。<br>一阶法的迭代公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.20.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中α称为学习率，一阶法也称为梯度下降法，梯度就是目标函数的一阶信息。<br>二阶法的迭代公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8810.22.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>二阶法也称为牛顿法，Hessian矩阵就是目标函数的二阶信息，二阶法的收敛速度一般要远快于一阶法，但是在高维情况下，Hessian矩阵求逆的计算复杂度很大，而且当目标函数非凸时，二阶法有可能会收敛到鞍点。</p><h1 id="梯度验证"><a href="#梯度验证" class="headerlink" title="梯度验证"></a>梯度验证</h1><p>在实际应用中，写出计算梯度的代码后，通常需要验证自己写的代码是否正确。<br><strong>问：如何验证求目标函数梯度功能的正确性？</strong></p><p>答：ei是单位向量，维度与θ相同，仅在第i个位置取值为1，其余位置取值为0。可以取h为一个比较小的数(例如10的-7次方)，则有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8811.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8811.03.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在实际应用中，随机初始化θ，取h为较小的数(例如10的-7次方)，并对i=1,2,…,n,依次验证<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-08%20%E4%B8%8A%E5%8D%8811.01.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>是否成立。如果对于某个下标i，该不等式不成立，则有以下两种可能。<br>1 该下标对应的M过大<br>2 该梯度分量计算不正确</p><p>此时可以固定θ，减小h为原来的十分之一，并再次计算下标i对应的近似误差，若近似误差越减小为原来的百分之一，则对应第一种可能，我们应该采用更小的h重新做一次梯度验证，否则对应第二种可能，应检查梯度的代码是否有错误。</p><h1 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h1><p><strong>问：当训练数据量特别大时，经典的梯度下降法存在什么问题，需要做如何改进？</strong></p><p>答：经典的梯度下降法在每次对模型参数进行更新时，需要遍历所有的训练数据。当M很大时，这需要很大的计算量，耗费很长的计算时间，在实际应用中基本不可行。为了解决该问题，随机梯度下降法(SGD)用单个训练样本的损失来近似平均损失，即随机梯度下降法用单个训练数据即可对模型参数进行一次更新，大大加快了收敛速率。该方法也非常适用于数据源源不断到来的在线更新场景。</p><p>为了降低随机梯度的方差，从而使得迭代算法更加稳定，也为了充分利用高度优化的矩阵运算操作，在实际应用中我们会同时处理若干训练数据，该方法被称为小批量梯度下降法(Mini-Batch Gradient Descent)<br>有三个需要注意的地方：<br>1.选取参数m，在不同的应用中，最优的m通常会不一样，需要通过调参选取。一般m取2的幂次能充分利用矩阵运算操作，所以可以在2的幂次中挑选出最优的取值，例如32，64，128，256等。<br>2.挑选m个训练数据，为了避免数据的特定顺序给算法收敛带来的影响，一般会在每次遍历训练数据之前，先对所有的数据进行随机排序，然后在每次迭代时按顺序挑选m个训练数据直至遍历完所有的数据。<br>3.选取学习速率α，为了加快收敛速率，同时提高求解精度，通常会采用衰减学习速率的方案:一开始算法采用较大的学习速率，当误差曲线进入平台期后，减小学习速率做更精细的调整。最优的学习速率方案也通常需要调参才能得到。</p><p>综上，通常采用小批量梯度下降法解决训练数据量过大的问题。每次更新模型参数时，只需要处理m个训练数据即可，其中m是一个远小于总数据量M的常数，这样能够大大加快训练过程。</p><h1 id="随机梯度下降法的加速"><a href="#随机梯度下降法的加速" class="headerlink" title="随机梯度下降法的加速"></a>随机梯度下降法的加速</h1><p>提到深度学习中的优化方法，人们通常会想到随机梯度下降法。但是，随机梯度下降法并不是万金油，有时候反而会成为一个坑。当设计出一个深度神经网络时，如果只知道用随机梯度下降法来训练模型，那么当得到一个比较差的训练结果时，可能会放弃在这个模型上继续投入精力。然而，造成训练效果差的真正原因，可能并不是模型的问题，而是随机梯度下降法在优化过程中失效了，这可能会导致你丧失一次新发现的机会。</p><p><strong>问：随机梯度下降法偶尔也会失效，无法给出满意的训练结果，这是为什么？</strong></p><p>答：随机梯度下降法放弃了对梯度准确性的追求，每步仅仅随机采样一个或少量样本来估计当前梯度，计算速度快，内存开销小。但由于每步接受的信息量有限，随机梯度下降法对梯度的估计常常出现偏差，造成目标函数曲线收敛得很不稳定，伴有剧烈波动，有时甚至出现不收敛的情况。</p><p>深度学习中的优化问题本身就很难，有太多局部最优点的陷阱。这些陷阱对随机梯度下降法和批量梯度下降法都是普遍存在的。但对随机梯度下降法来说，可怕的不是局部最优点，而是<strong>山谷</strong>和<strong>鞍点</strong>两类地形。</p><p>山谷顾名思义就是狭长的山间小道，左右两边是峭璧;鞍点的形状像是一个马鞍，一个方向上两头翘，另一个方向上两头垂，而中心区域是一片近乎水平的平地。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/f08834008016f4c23a67e931d2f5a281_b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>山谷地形</p><p>在山谷中，准确的梯度方向是沿山道向下，稍有偏离就会撞向山壁，而粗糙的梯度估计使得它在两山壁间来回反弹震荡，不能沿山道方向迅速下降，导致收敛不稳定和收敛速度慢。在鞍点处，随机梯度下降法会走入一片平坦之地，结果就停滞下来。</p><p><strong>问：解决之道—惯性保持和环境感知。</strong></p><p>答：1.动量(<strong>Momentum</strong>)方法。<br>随机梯度下降法更新公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%887.56.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>动量方法模型参数迭代公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%887.56.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>具体来说，前进步伐-v,由两部分组成。一是学习速率乘以当前估计的梯度g;二是带衰减的前一次步伐v。这里，惯性就体现在对前一次步伐信息的重利用上。类比中学物理知识，当前梯度就好比当前时刻受力产生的加速度，前一次步伐好比前一时刻的速度，当前步伐好比当前时刻的速度。为了计算当前时刻的速度，应当考虑前一时刻速度和当前加速度共同作用的结果，因此vt直接依赖于vt-1 和gt, 而不仅仅是gt。另外，衰减系数y扮演了阻力的作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/3e0e36c25cfc4dccb28e651aa7a47b01_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/a1a5fe431b8ab803d778337c8be2f275_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/20180515233015431.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>AdaGrad方法</strong><br>随机梯度下降法对环境的感知是指在参数空间中，根据不同参数的一些经验性判断，自适应地确定参数的学习速率，不同参数的更新步幅是不同的。例如，在文本处理中训练词嵌入模型的参数时，有的词或词组频繁出现，有的词或词组则极少出现。数据的稀疏性导致相应参数的梯度的稀疏性，不频繁出现的词或词组的参数的梯度在大多数情况下为零，从而这些参数被更新的频率很低。在应用中，我们希望更新频率低的参数可以拥有较大的更新步幅，而更新频率高的参数的步幅可以减小。<strong>AdaGrad方法采用“历史梯度平方和”来衡量不同参数的梯度的稀疏性，取值越小表明越稀疏</strong>，具体的更新公式表示为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.09.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>分母求和的形式实现了退火过程，这是很多优化技术中常见的策略，意味着随着时间推移，学习速率越来越小，从而保证了算法的最终收敛。</p><p><strong>Adam方法</strong><br>Adam方法将惯性保持和环境感知这两个优点集于一身。一方面，Adam记录梯度的一阶矩(first moment) ，即过往梯度与当前梯度的平均，这体现了惯性保持;另一方面，Adam还记录梯度的二阶矩(second moment)，即过往梯度平方与当前梯度平方的平均，这类似AdaGrad方法，体现了环境感知能力，为不同参数产生自适应的学习速率。</p><p>一阶矩和二阶矩采用类似于滑动窗口内求平均的思想进行融合，即当前梯度和近一段时间内梯度的平均值，时间久远的梯度对当前平均值的贡献呈指数衰减。具体来说，一阶矩和二阶矩采用指数衰退平均(exponentialdecay average)技术，计算公式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.16.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中β，β2为衰减系数，m是一阶矩，v是二阶矩。</p><p> 一阶矩相当于估计E[g]:由于当下梯度g,是随机采样得到的估计结果，因此更关注它在统计意义上的期望;二阶矩相当于估计E[g2]，这点与AdaGrad方法不同，不是g2从开始到现在的加和，而是它的期望。它们的物理意义是，当|m|大且v大时， 梯度大且稳定，这表明遇到一个明显的大坡，前进方向明确;当|m|趋于零 且v,大时，梯度不稳定，表明可能遇到一个峡谷，容易引起反弹震荡;当lm|大 且v,趋于零时，这种情况不可能出现;当|m|趋于零且v趋于零时，梯度趋于零，可能到达局部最低点，也可能走到一片坡度极缓的平地，此时要避免陷入平原(plateau) 。另外，Adam方法还考虑了m， v,在零初始值情况下的偏置矫正。具体来说，Adam的更新公式为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.23.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.24.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="L1正则化与稀疏性"><a href="#L1正则化与稀疏性" class="headerlink" title="L1正则化与稀疏性"></a>L1正则化与稀疏性</h1><p><strong>问：L1正则化使得模型参数具有稀疏性的原理是什么？</strong></p><p>角度1：解空间形状。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.27.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在二维的情况下，黄色的部分是L2和L1正则项约束后的解空间，绿色的等高线是凸优化问题中目标函数的等高线。由图可知，L2正则项约束后的解空间是圆形，而L1正则项约束的解空间是多边形。显然，多边形的解空间更容易在尖角处与等高线碰撞出稀疏解。</p><p>事实上，带正则项和带约束条件是等价的。为了约束w的可能取值空间从而防止过拟合，我们为该最优化问题加上一个约束，就是w的L2范数的平方不能大于m:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.54.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了求解带约束条件的凸优化问题，写出拉格朗日函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-13%20%E4%B8%8B%E5%8D%889.56.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若w <em>  和λ </em> 分别是原问题和对偶问题的最优解，根据KKT条件，它们应满足<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-14%20%E4%B8%8A%E5%8D%888.48.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>L2正则化相当于为参数定义了一个圆形的解空间(因为必须保证L2范数不能大于m),而L1正则化相当于为参数定义了个棱形的解空间。如果原问题目标函数的最优解不是恰好落在解空间内,那么约束条件下的最优解一定是在解空间的边界上,而L1“棱角分明”的解空间显然更容易与目标函数等高线在角点碰撞,从而产生稀疏解。</p><p>L2的切点只有一个点，L1的话，一个尖尖可以和无数个圆连着。</p><p><strong>角度2：函数叠加</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-14%20%E4%B8%8A%E5%8D%888.55.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>棕线是原始目标函数L(w)的曲线图，最小值点在蓝点处，且对应w * 值非0。</p><p>考虑加上L2正则化项，目标函数变成L(w)+Cw2,其函数曲线为黄色。此时，最小值点在黄点处，对应w * 的绝对值减小了，但仍然非0.</p><p>考虑加上L1正则化项，目标函数变成L(w)+C|w|,其函数曲线为绿色，最小值点在红色处，对应的w是0，产生了稀疏性。</p><p>原因很直观，加入L1正则化后，对带正则项的目标函数求导，正则项部分产生的导数在原点左边部分是-C，在原点右边部分是C，因此，只要原目标函数的导数绝对值小于C，那么带正则项的目标函数在原点左边部分始终是递减的，在原点右边部分始终是递增的，最小值点自然在原点处。相反，L2正则项在原点处的导数是0，只要原目标函数在原点处的导数不为0，那么最小值点就不会在原点，所以L2只有减小w绝对值的作用，对解空间的稀疏性没有贡献。</p><p>在一些在线梯度下降算法中，往往会采用截断梯度法来产生稀疏性，这同L1正则项产生稀疏性的原理是类似的。<br><strong>由上可以看出，L1产生稀疏性的概率比L2大很多，L2只有原目标函数导数为0这一种情况，L1则是原目标函数的导数绝对值小于C即可。</strong></p><p><strong>角度3：贝叶斯先验</strong><br>从贝叶斯的角度来理解L1正则化和L2正则化，简单的解释是，L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正 则化相当于引入了高斯先验，而拉普拉斯先验使参数为0的可能性更大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;百面-优化算法&quot;&gt;&lt;a href=&quot;#百面-优化算法&quot; class=&quot;headerlink&quot; title=&quot;百面 优化算法&quot;&gt;&lt;/a&gt;百面 优化算法&lt;/h1&gt;&lt;p&gt;机器学习算法=模型表征+模型评估+优化算法&lt;br&gt;优化算法所做的事情就是在模型表征空间中找到模型评估
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode分类练习</title>
    <link href="https://github.com/zdkswd/2019/05/07/leetcode%E5%88%86%E7%B1%BB%E7%BB%83%E4%B9%A0/"/>
    <id>https://github.com/zdkswd/2019/05/07/leetcode分类练习/</id>
    <published>2019-05-07T11:56:47.000Z</published>
    <updated>2019-05-07T11:56:40.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>15.3sum<br>169.majority element<br>41.first missing positive</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>141.linked list cycle<br>23.merge k sorted list</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>20.valid parenthess<br>32.longest valid parentheses<br>150.evaluate reverse polish notation</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>641.design circular deque<br>239.sliding window maxumum</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>70.climbing stairs</p><h1 id="排序与二分查找"><a href="#排序与二分查找" class="headerlink" title="排序与二分查找"></a>排序与二分查找</h1><p>69.sqrt(x)</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>344.reverse string<br>151.reverse words in a string<br>8.string to integer(atoi)</p><h1 id="二叉树和堆"><a href="#二叉树和堆" class="headerlink" title="二叉树和堆"></a>二叉树和堆</h1><p>226.invert binary tree<br>104.maximum depth of binary tree<br>98.validate binary search tree<br>112.path sum</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>200.number of islands<br>36.vaild sudoku</p><h1 id="回溯分治动态规划"><a href="#回溯分治动态规划" class="headerlink" title="回溯分治动态规划"></a>回溯分治动态规划</h1><p>10.regular expression matching<br>64.minimum path sum<br>322.coin change<br>121.best time to buy and sell stock<br>152.maximum product subarray<br>120.triangle</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;15.3sum&lt;br&gt;169.majority element&lt;br&gt;41.first missing positive&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://github.com/zdkswd/2019/05/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://github.com/zdkswd/2019/05/07/二分查找/</id>
    <published>2019-05-07T08:53:47.000Z</published>
    <updated>2019-05-07T08:54:04.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/9dadf04cdfa7b3724e0df91da7cacd9b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/8bce81259abf0e9a06f115e22586b829.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>二分查找针对的是一个有序的数据集合,查找思想有点类似分治思想。每次都通过跟区间的中间元素对比,将待查找的区间缩小为之前的一半,直到找到要查找的元素,或者区间被缩小为0。</p><p><strong>惊人的查找速度O(logn)。</strong>比如n等于2的32次方，大约是32亿，但是在42亿个数据中用二分查找一个数据，最多需要比较32次。常量级时间复杂度的算法有时候可能还没有O(logn)的算法执行效率高。</p><h1 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h1><p>对于最简单的情况，即不存在重复数据的情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%883.33.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>三个容易出错的地方：<br>1.循环退出条件<br>是low&lt;=high,而不是low&lt;high。<br>2.mid的取值<br>实际上,mid=(ow+high)/2这种写法是有问题的。因为如果low和high比较大的话,两者之和就有可能会溢出。改进的方法是将md的计算方式写成low+(high-low)/2。更进一步,如果要将性能优化到极致的话,我们可以将这里的除以2操作转化成位运算low+(high-low)&gt;&gt;1)。因为相比除法运算来说,计算机处理位运算要快得多。<br>3.low和hign的更新<br>low=md+1,high=mid-1。注意这里的+1和-1,如果直接写成low=mid或者high=mid,就可能会发生死循环。比如,当high=3,low=3时,如果a3]不等于value,就会导致一直循环不退出。</p><p>二分查找除了用循环来实现，还可以用递归来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%883.45.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><p><strong>首先，二分查找依赖的是顺序表结构，简单说就是数组。</strong><br><strong>其次，二分查找针对的是有序数据。</strong>如果数据没有序，我们需要先排序。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。<br><strong>再次，数据量太小不适合二分查找。</strong>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。只有数据量比较大时，二分查找的优势才会比较明显。如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。<br><strong>最后，数据量太大也不适合二分查找。</strong>二分查找的底层需要依赖数组，需要有大量的连续的内存空间，对于1gb的数据，需要有1gb<strong>连续</strong>内存空间。</p><p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决，但是不论是散列表还是二叉树都会需要比较多的额外的内存空间。二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式。</p><h1 id="二分查找简单情况的变形"><a href="#二分查找简单情况的变形" class="headerlink" title="二分查找简单情况的变形"></a>二分查找简单情况的变形</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/4221d02a2e88e9053085920f13f9ce36.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/503c572dd0f9d734b55f1bd12765c4f8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于之前简单情况的代码进行一些变形。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%884.30.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>查找的是任意一个值等于给定值的元素，当a[mid]等于要查找的值时，a[mid]就是我们要找的元素，此时需要确认是否是第一个值等于给定值的元素。经检查发现a[mid]前面一个元素a[mid-1]也等于value，那么说明此时的a[mid]肯定不是第一个值等于给定值的元素，就更新high=mid-1。</p><h2 id="变体二-查找最后一个值等于给定值的元素"><a href="#变体二-查找最后一个值等于给定值的元素" class="headerlink" title="变体二 查找最后一个值等于给定值的元素"></a>变体二 查找最后一个值等于给定值的元素</h2><p>同理可得</p><h2 id="变体三-查找第一个大于等于给定值的元素"><a href="#变体三-查找第一个大于等于给定值的元素" class="headerlink" title="变体三 查找第一个大于等于给定值的元素"></a>变体三 查找第一个大于等于给定值的元素</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-07%20%E4%B8%8B%E5%8D%884.40.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>思路类似</p><h2 id="变体四-查找最后一个小于等于给定值的元素"><a href="#变体四-查找最后一个小于等于给定值的元素" class="headerlink" title="变体四 查找最后一个小于等于给定值的元素"></a>变体四 查找最后一个小于等于给定值的元素</h2><p>类似</p><h1 id="快速定位出一个ip地址归属地"><a href="#快速定位出一个ip地址归属地" class="headerlink" title="快速定位出一个ip地址归属地"></a>快速定位出一个ip地址归属地</h1><p>首先将ip地址排序，将问题转化为在有序数组中，查找最后一个小于等于某个给定值的元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性排序 O(n)  排序优化</title>
    <link href="https://github.com/zdkswd/2019/05/07/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2019/05/07/线性排序 O(n)  排序优化/</id>
    <published>2019-05-07T06:32:32.000Z</published>
    <updated>2019-05-07T06:33:45.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性排序-O-n-排序优化"><a href="#线性排序-O-n-排序优化" class="headerlink" title="线性排序 O(n)  排序优化"></a>线性排序 O(n)  排序优化</h1><p>桶排序，计数排序，基数排序的时间复杂度是线性的，之所以能做到线性的时间复杂度主要是因为这些算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>核心思想是将要排序的数据分到几个有序的桶中，每个桶里的数据再单独进行排序。桶内排完序后，再将每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/987564607b864255f81686829503abae.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>时间复杂度分析：</strong>如果要排序的数据有n个，把它们均匀地划分到m个桶内，每个桶里就有k=n / m个元素。每个桶内部使用快速排序，时间复杂度为O(k <em> logk)。m个桶排序的时间复杂度就是O(m </em> k <em> logk),因为k=n / m,所以整个桶排序的时间复杂度就是O(n </em> log(n / m))。当桶的个数m接近数据个数n时，log(n / m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p><p>桶排序对要排序数据的要求是非常苛刻的：<strong>首先</strong>要排序的数据需要很容易能划分成m个桶，并且桶与桶之间有着天然的大小顺序。这样每个桶内数据都排序完之后，桶与桶之间的数据不需要进行排序。<strong>其次</strong>，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中。</strong></p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p><strong>计数排序其实是桶排序的一种特殊情况。</strong>当要排序的n个数据，所处的范围并不大时，比如最大值为k，就可以将数据划分为k个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>比如高考成绩排序，考生的满分是750，最小是0，就可以分为751个桶，根据考生成绩，将50万考生划分到751个桶中，桶内的数据都是分数相同的学生，所以并不需要再进行排序，只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序，因为只涉及扫描遍历操作，所以时间复杂度是O(n)。</p><p>计数排序的名字计数有何而来呢？比如8个考生分数在0-5之间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/adc75672ef33fa54b023a040834fcbc9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C[6]内存储的不是考生，而是对应的考生的个数。将C[6]数组顺序求和。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C[k]里存储小于等于分数k的考生个数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/1d730cb17249f8e92ef5cab53ae65784.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种利用另外一个数组来计数的实现方式非常巧妙，这也是为什么这种排序算法叫计数排序的原因。</p><p><strong>计数排序只能用在数据范围不大的场景中，</strong>如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要在其不改变相对大小的情况下，转化为非负整数。</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于每一位的排序的算法需要是稳定的。可以使用桶排序或者计数排序，其中桶排序中每个桶不能用快排而要用归并排序。</p><p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的‘位’来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。</strong></p><h1 id="选择合适的排序算法"><a href="#选择合适的排序算法" class="headerlink" title="选择合适的排序算法"></a>选择合适的排序算法</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%20O(n)%20%20%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中默认桶排序是不稳定的。</p><h1 id="排序优化，实现高性能的排序函数"><a href="#排序优化，实现高性能的排序函数" class="headerlink" title="排序优化，实现高性能的排序函数"></a>排序优化，实现高性能的排序函数</h1><p>线性排序算法的时间复杂度较低，但是适用场景比较特殊。所以如果要写一个通用的排序函数,不能选择线性排序算法。</p><p>如果对小规模数据进行排序,可以选择时间复杂度是o(n2)的算法;如果对大规模数据进行排序,时间复杂度是 o(nlogn)的算法更加高效。所以,为了兼顾任意规模数据的排序,一般都会首选时间复杂度是o( nlogn)的排序算法来实现排序函数。</p><p>然而归并排序使用的并不多，虽然其稳定O(nlogn)，但是由于其不是原地排序算法，空间复杂度是O(n)，所以并没有得到很多的使用。</p><h1 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h1><p>最坏的情况下快排的时间复杂度是O(n2),如果数据原来就是有序或者接近有序的，每次分区点都选择最后一个数据，那么快速排序算法就会变得非常糟糕，时间复杂度就会退化为O(n2)，出现的主要原因是我们分区点选的不够合理。理想的分区点是，<strong>被分区点分开的两个分区中，数据的数量差不多。</strong>为了提高排序算法的性能，要尽可能地让每次分区都比较平均。</p><h2 id="三数取中法"><a href="#三数取中法" class="headerlink" title="三数取中法"></a>三数取中法</h2><p>我们从区间的首、尾、中间,分别取出一个数,然后对比大小,取这3个数的中间值作为分区点。这样每间隔某个固定的长度,取数据岀来比较,将中间值作为分区点的分区算法,肯定要比单纯取某一个数据更好。但是,如果要排序的数组比较大,那“三数取中”可能就不够了,可能要“五数取中”或者“十数取中”。</p><h2 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h2><p>随机法就是每次从要排序的区间中,随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好,但是从概率的角度来看,也不大可能会出现每次分区点都选的很差的情况,所以平均情况下,这样选的分区点是比较好的。时间复杂度退化为最糟糕的O(n2)的情况,出现的可能性不大。</p><p>快速排序是用递归来实现的。我们在递归那一节讲过,递归要警惕堆栈溢出。为了避免快速排序里,递归过深而堆栈过小,导致堆栈溢岀,我们有两种解决办法:第一种是限制递归深度。一旦递归过深,超过了我们事先设定的阈值,就停止递归。第二种是通过在堆上模拟实现一个函数调用栈,手动模拟递归压栈、岀栈的过程,这样就没有了系统栈大小的限制。</p><h1 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h1><p>比如<strong>qsort()函数</strong>，会优先使用归并排序来处理小数据量的排序。使用空间来换时间，当数据量太大，就会改用快速排序算法来排序。选取分区点的方法便是三数取中法。对于递归太深导致堆栈溢出的问题，是通过自己实现一个堆上的栈，手动模拟递归来解决的。qsort()并不仅仅用到了归并排序和快速排序，还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于4时，qsort()就退化为插入排序，在小规模数据前，O(n2)时间复杂度的算法并不一定比O(nlogn)的算法执行时间长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性排序-O-n-排序优化&quot;&gt;&lt;a href=&quot;#线性排序-O-n-排序优化&quot; class=&quot;headerlink&quot; title=&quot;线性排序 O(n)  排序优化&quot;&gt;&lt;/a&gt;线性排序 O(n)  排序优化&lt;/h1&gt;&lt;p&gt;桶排序，计数排序，基数排序的时间复杂度是线性
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 排序算法O(n^2) O(nlogn)</title>
    <link href="https://github.com/zdkswd/2019/04/30/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/"/>
    <id>https://github.com/zdkswd/2019/04/30/极客时间 排序算法O(n^2) O(nlogn)/</id>
    <published>2019-04-30T12:05:47.000Z</published>
    <updated>2019-05-07T12:10:22.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="极客时间-排序算法O-n-2-O-nlogn"><a href="#极客时间-排序算法O-n-2-O-nlogn" class="headerlink" title="极客时间 排序算法O(n^2) O(nlogn)"></a>极客时间 排序算法O(n^2) O(nlogn)</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/WechatIMG92.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所谓的算法稳定性就是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/1381c1f3f7819ae61ab17455ed7f0b59.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>比如对于4，5，6，3，2，1<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/4038f64f47975ab9f519e4f739e464e9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/9246f12cca22e5d872cbfce302ef4d09.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>冒泡的过程可以优化，当某次操作没有数据交换时，说明已经到达完全有序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/a9783a3b13c11a5e064c5306c261e8e6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一，冒泡排序的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度为O(1)，是一个<strong>原地排序</strong>算法。<br>二，为保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换。所以冒泡排序是<strong>稳定</strong>的。<br>三，最好情况，要排序的数据已经是有序的，只需进行一次冒泡操作即可结束，<strong>最好</strong>时间复杂度是<strong>O(n)</strong>。最坏要排序的数据是倒序的，需要进行n次冒泡，<strong>最坏</strong>为<strong>O(n^2)</strong><br>在最坏情况下，进行n <em> (n-1) / 2次交换，最好情况下不需要进行交换，取中间值为n </em> (n-1) / 4来表示平均，所以<strong>平均</strong>复杂度为<strong>O(n^2)</strong></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/7b257e179787c633d2bd171a764171a6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/b60f61ec487358ac037bf2b6974d2de1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>插入排序包括元素的比较与元素的移动两种操作。<br>一，插入排序不需要额外的存储空间，所以空间复杂度是O(1)，所以是一个<strong>原地排序</strong>算法。<br>二，对于值相同的元素，通过选择后面出现的元素，就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定</strong>的排序算法。<br>三，<strong>最好</strong>情况是有序，即为从头到尾遍历一遍为<strong>O(n)</strong>。最坏为倒序，每次要插到第一个位置，并且需要大量的移动数据，<strong>最坏</strong>情况时间复杂度为<strong>O(n^2)</strong>。<br>在数组中插入一个数据的平均时间复杂度是O(n)，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环n次，所以平均时间复杂度为O(n^2)。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/32371475a0b08f0db9861d102474181d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>选择排序算法的实现思路有点类似插入排序，但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p>选择排序空间复杂度为O(1)，是一种原地排序算法，最好最坏和平均时间复杂度都是O(n^2)。选择排序每次都要找到剩余未排序元素中的最小值，并和前面的元素交换位置，破坏了稳定性，所以选择排序是一种不稳定的排序算法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/348604caaf0a1b1d7fee0512822f0e50.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/db7f892d3355ef74da9cd64aa926dc2b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>归并排序使用的就是<strong>分治思想</strong>。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧。</strong>分治算法一般都是用递归来实现的。<br>归并排序的递推公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-30%20%E4%B8%8B%E5%8D%885.00.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-30%20%E4%B8%8B%E5%8D%885.01.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>merge函数的具体操作。需要借助一个临时数组tmp<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/95897ade4f7ad5d10af057b1d144a22f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一，对于A[p…q]和A[q+1…r]之间值相同的元素，可以将A[p…q]中的元素放入tmp数组中，就保证了值相同的元素合并前后顺序不变，所以归并排序是个<strong>稳定</strong>的排序。<br>二，由图中可以看出过程不论是最好最坏还是平均情况，<strong>时间复杂度</strong>都是<strong>O(nlogn)</strong><br>三，显而易见，归并排序不是原地排序，递归代码的空间复杂度并不能像时间复杂度那样累加，所以<strong>空间复杂度</strong>是<strong>O(n)</strong>。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快排主要思想：如果要排序数组中下标为p到r之间的一组数据，选择p到r之间任意一个数据作为pivot(分区点)。遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间，至此，p到r就被分为了三部分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/4d892c3a2e08a17f16097d07ea088a81.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>根据分治、递归的处理思想，可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-30%20%E4%B8%8B%E5%8D%885.58.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-30%20%E4%B8%8B%E5%8D%886.00.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>partition()分区函数就是随机选择一个元素作为pivot(一般情况下，可以选择p到r区间的最后一个元素)，然后对A[p…r]分区，函数返回pivot的下标。我们希望快排是个<strong>原地排序</strong>算法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/640.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/aa03ae570dace416127c9ccf9db8ac05.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以发现归并排序的处理是<strong>由下向上</strong>的，快排是<strong>由上到下</strong>的。</p><p>性能分析：快排是一种<strong>原地</strong>、<strong>不稳定</strong>的排序算法。由图中可见，有交换的过程，所以是不稳定的，一般来说快排的时间复杂度是O(nlogn)，最差情况是数组中的数据原来已经是有序的，选择最后一个元素作为pivot，分区就是极度不均衡的，那么复杂度就从O(nlogn)退化到O(n^2)，最佳情况就是分区极度均衡，为O(nlogn)，平均来看在大部分时间里，时间复杂度可以做到O(nlohn)，只有在极端情况下，会退化到O(n^2)，但是也有很多方法将这个概率降到很低。</p><p>问题:O(n)时间复杂度内求无序数组的第K大元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95O(n%5E2)%20O(nlogn)/898d94fc32e0a795fd65897293b98791.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>选择A[0…n-1]的最后一个元素A[n-1]作为pivot,对数组原地分区，这样数组就分为了三部分,A[0…p-1],A[p],A[p+1…n-1]。</p><p>如果p+1=K，那么A[p]就是要求解的元素；如果K&gt;p+1,说明在右侧，然后同样思路在右边区间去找。</p><h1 id="O-n-时间找到一组数据第K大元素"><a href="#O-n-时间找到一组数据第K大元素" class="headerlink" title="O(n)时间找到一组数据第K大元素"></a>O(n)时间找到一组数据第K大元素</h1><p>解题思路:利用快排中分区的思想,选择数组区间A[0…n-1]的左右一个元素A[n-1]作为pivot,对数组A[0…n-1]原地分区,这样数组就分成了三部分,A[0…p-1],A[p],A[p+1…n-1],如果p+1=k那么A[p]就是要求解的元素,如果K&gt;p+1,则说明第K大的元素在A[p+1…n-1]这个区间,否则在A[0…p-1]这个区间,递归的查找第K大的元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;极客时间-排序算法O-n-2-O-nlogn&quot;&gt;&lt;a href=&quot;#极客时间-排序算法O-n-2-O-nlogn&quot; class=&quot;headerlink&quot; title=&quot;极客时间 排序算法O(n^2) O(nlogn)&quot;&gt;&lt;/a&gt;极客时间 排序算法O(n^2) O(
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LightGBM: A Highly Efficient Gradient Boosting Decision Tree </title>
    <link href="https://github.com/zdkswd/2019/04/29/LightGBM:%20A%20Highly%20Efficient%20Gradient%20Boosting%20Decision%20Tree/"/>
    <id>https://github.com/zdkswd/2019/04/29/LightGBM: A Highly Efficient Gradient Boosting Decision Tree/</id>
    <published>2019-04-29T04:31:32.000Z</published>
    <updated>2019-04-29T04:32:05.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>介绍了两种能让gbdt加速训练的方法。</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p> Conventional implementations of GBDT need to, for every feature, scan all the data instances to estimate the information gain of all the possible split points.<br>The efficiency and scalability of XGBoost are still unsatisfactory when the feature dimension is high and data size is large.<br>A major reason is that for each feature, they need to scan all the data instances to estimate the information gain of all possible split points, which is very time consuming. </p><p>LightGBM use <strong>Gradient-based One-Side Sampling(GOSS)</strong> and <strong>Exclusive Feature Bundling(EFB)</strong>  to solve this problem.</p><p><strong>GOSS:</strong>exclude a significant proportion of data instances with small gradients, and only use the rest to estimate the information gain. </p><p><strong>EFB:</strong>bundle mutually exclusive features .This is NP-hard,but a greedy algorithm can achieve quite good approximation ratio.</p><p>They call new GBDT implementation with GOSS and EFB <strong>LightGBM</strong>. </p><h1 id="About-GBDT"><a href="#About-GBDT" class="headerlink" title="About GBDT"></a>About GBDT</h1><p>In each iteration, GBDT learns the decision trees by fitting the negative gradients (also known as <strong>residual errors</strong>). </p><p>The main cost in GBDT lies in learning the decision trees, and the most time-consuming part in learning a decision tree is to find the best split points. </p><p>Another popular algorithm is the histogram-based algorithm.Instead of finding the split points on the sorted feature values, histogram-based algorithm buckets continuous feature values into discrete bins and uses these bins to construct feature histograms during training. </p><p>Since the histogram-based algorithm is more efficient in both memory consumption and training speed, they develop work on its basis.</p><h1 id="Gradient-based-One-Side-Sampling-GOSS"><a href="#Gradient-based-One-Side-Sampling-GOSS" class="headerlink" title="Gradient-based One-Side Sampling(GOSS)"></a>Gradient-based One-Side Sampling(GOSS)</h1><p>notice that data instances with different gradients play different roles in the computation of information gain. In particular, according to the definition of information gain, those instances with larger gradients(<strong>i.e., under-trained instances</strong>) will contribute more to the information gain. </p><p>Therefore, when down sampling the data instances, in order to retain the accuracy of information gain estimation, should better keep those instances with large gradients (e.g., larger than a pre-defined threshold, or among the top percentiles), and only randomly drop those instances with small gradients. </p><p>They prove that such a treatment can lead to a more accurate gain estimation than uniformly random sampling, with the same target sampling rate, especially when the value of information gain has a large range. </p><h2 id="Algorithm-Description"><a href="#Algorithm-Description" class="headerlink" title="Algorithm Description"></a>Algorithm Description</h2><p>In AdaBoost, the sample weight serves as a good indicator for the importance of data instances. gradient for each data instance in GBDT provides us with useful information for data sampling. That is, if an instance is associated with a small gradient, the training error for this instance is small and it is already well-trained. </p><p>A straightforward idea is to discard those data instances with small gradients. However, the data distribution will be changed by doing so, which will hurt the accuracy of the learned model. To avoid this problem, they propose a new method called Gradient-based One-Side Sampling (GOSS). </p><p>GOSS keeps all the instances with large gradients(large <strong>residual errors</strong>) and performs random sampling on the instances with small gradients. </p><p>GOSS firstly sorts the data instances according to the absolute value of their gradients and selects the (top a) × 100% instances. Then it randomly samples b × 100% instances from the rest of the data. After that, GOSS amplifies the sampled data with small gradients by a constant<br>(1−a / b) when calculating the information gain.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM:%20A%20Highly%20Efficient%20Gradient%20Boosting%20Decision%20Tree/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-29%20%E4%B8%8B%E5%8D%8812.25.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Exclusive-Feature-Bundling-EFB"><a href="#Exclusive-Feature-Bundling-EFB" class="headerlink" title="Exclusive Feature Bundling(EFB)"></a>Exclusive Feature Bundling(EFB)</h1><p>in a sparse feature space, many features are (almost) exclusive, i.e., they rarely take nonzero values simultaneously. Examples include the one-hot features.They can safely bundle such exclusive features.</p><p>To this end, They design an efficient algorithm by reducing the optimal bundling problem to a graph coloring problem (by taking features as vertices and adding edges for every two features if they are not mutually exclusive), and solving it by a greedy algorithm with a constant approximation ratio. </p><p>There are two issues to be addressed. The <strong>first</strong> one is to determine which features should be bundled together. The <strong>second</strong> is how to construct the bundle. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h1&gt;&lt;p&gt;介绍了两种能让gbdt加速训练的方法。&lt;/p&gt;
&lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;h
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 数据结构</title>
    <link href="https://github.com/zdkswd/2019/04/25/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E4%B8%80/"/>
    <id>https://github.com/zdkswd/2019/04/25/极客时间 算法与数据结构 一/</id>
    <published>2019-04-25T12:56:47.000Z</published>
    <updated>2019-05-07T12:05:18.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="极客时间-算法与数据结构-一"><a href="#极客时间-算法与数据结构-一" class="headerlink" title="极客时间 算法与数据结构 一"></a>极客时间 算法与数据结构 一</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E4%B8%80/861556196039_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E4%B8%80/901556196041_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E4%B8%80/911556196043_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E4%B8%80/871556196040_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E4%B8%80/881556196041_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E4%B8%80/891556196042_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;极客时间-算法与数据结构-一&quot;&gt;&lt;a href=&quot;#极客时间-算法与数据结构-一&quot; class=&quot;headerlink&quot; title=&quot;极客时间 算法与数据结构 一&quot;&gt;&lt;/a&gt;极客时间 算法与数据结构 一&lt;/h1&gt;&lt;figure class=&quot;image-bubb
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法" scheme="https://github.com/zdkswd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Keras.Embedding</title>
    <link href="https://github.com/zdkswd/2019/04/25/Keras.Embedding/"/>
    <id>https://github.com/zdkswd/2019/04/25/Keras.Embedding/</id>
    <published>2019-04-25T12:51:47.000Z</published>
    <updated>2019-04-25T12:51:41.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Keras-Embedding"><a href="#Keras-Embedding" class="headerlink" title="Keras.Embedding"></a>Keras.Embedding</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Keras.Embedding/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-25%20%E4%B8%8B%E5%8D%886.13.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Keras.Embedding/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-25%20%E4%B8%8B%E5%8D%886.13.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Keras.Embedding/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-25%20%E4%B8%8B%E5%8D%886.14.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Keras.Embedding/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-25%20%E4%B8%8B%E5%8D%886.14.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于一个类别变量的embedding层，input_length=1.input_dim为labelEncoder后的最大值。将label的一个值转化为out_dim的向量的多个值表示。实验如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Keras.Embedding/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-25%20%E4%B8%8B%E5%8D%888.14.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Keras.Embedding/WechatIMG85.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Keras-Embedding&quot;&gt;&lt;a href=&quot;#Keras-Embedding&quot; class=&quot;headerlink&quot; title=&quot;Keras.Embedding&quot;&gt;&lt;/a&gt;Keras.Embedding&lt;/h1&gt;&lt;figure class=&quot;image-
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RS Embedding Papers</title>
    <link href="https://github.com/zdkswd/2019/04/18/RS%20Embedding%20Papers/"/>
    <id>https://github.com/zdkswd/2019/04/18/RS Embedding Papers/</id>
    <published>2019-04-18T05:56:47.000Z</published>
    <updated>2019-04-18T07:55:06.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Item2Vec-Microsoft"><a href="#Item2Vec-Microsoft" class="headerlink" title="Item2Vec  Microsoft"></a>Item2Vec  Microsoft</h1><p><strong>ITEM2VEC: NEURAL ITEM EMBEDDING FOR COLLABORATIVE FILTERING</strong></p><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>The method is capable of inferring item-item relations even when user information is not available. </p><h2 id="INTRODUCTION-AND-RELATED-WORK"><a href="#INTRODUCTION-AND-RELATED-WORK" class="headerlink" title="INTRODUCTION AND RELATED WORK"></a>INTRODUCTION AND RELATED WORK</h2><p>many recommendation algorithms are focused on learning a low dimensional embedding of users and items simultaneously ,computing item similarities is an end in itself .</p><p>The single item recommendations are different than the more “traditional” user-to-item recommendations because they are usually shown in the context of an explicit user interest in a specific item and in the context of an explicit user intent to purchase. Therefore, single item recommendations based on item similarities often have higher Click-Through Rates (CTR) than user-to-item recommendations and consequently responsible for a larger share of sales or revenue. </p><p>item similarities are used in online stores for better exploration and discovery and improve the overall user experience. </p><h2 id="ITEM2VEC-–-SGNS-FOR-ITEM-SIMILARITY"><a href="#ITEM2VEC-–-SGNS-FOR-ITEM-SIMILARITY" class="headerlink" title="ITEM2VEC – SGNS FOR ITEM SIMILARITY"></a>ITEM2VEC – SGNS FOR ITEM SIMILARITY</h2><p>Since some scenarios could not provide information about multiple sets of items might belong to the same user .user-item CF may not work well.</p><p>By moving from sequences to sets, the spatial / time information is lost. We choose to discard this information, since in this paper, we assume a static environment where items that share the same set are considered similar, no matter in what order / time they were generated by the user. </p><p>Since we ignore the spatial information, we treat each pair of items that share the same set as a positive example. <strong>This implies a window size that is determined from the set size.</strong> 这里意思是在训练时，窗口不像w2v中是定长的，而是一个变长的窗口，根据一个订单中物品的大小来动态确定。Specifically, for a given set of items, the objective from Eq. (1) is modified as follows:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-18%20%E4%B8%8A%E5%8D%8810.09.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Another option is to keep the objective in w2v as is, and shuffle each set of items during runtime. In our experiments we observed that both options perform the same.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-18%20%E4%B8%8A%E5%8D%8810.10.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>In this work, we used u_i_ as the final representation for the i-th item and the affinity between a pair of items is computed by the cosine similarity. </p><h2 id="EXPERIMENTAL"><a href="#EXPERIMENTAL" class="headerlink" title="EXPERIMENTAL"></a>EXPERIMENTAL</h2><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p>The first dataset is user-artist data that is retrieved from the Microsoft Xbox Music service. This dataset consist of 9M events. Each event consists of a <strong>user-artist</strong> relation, which means the user played a song by the specific artist. The dataset contains 732K users and 49K distinct artists. </p><p>The second dataset contains orders of products from Microsoft Store. An order is given by a basket of items without any information about the user that made it. Therefore, the information in this dataset is weaker in the sense that we <strong>cannot bind between users and items</strong>. The dataset consist of 379K orders (that contains more than a single item) and 1706 distinct items. </p><h3 id="Systems-and-parameters"><a href="#Systems-and-parameters" class="headerlink" title="Systems and parameters"></a>Systems and parameters</h3><p>We applied item2vec to both datasets. The optimization is done by stochastic gradient decent. We ran the algorithm for 20 epochs. We set the negative sampling value to N=15 for both datasets. The dimension parameter m was set to 100 and 40 for the Music and Store datasets, respectively. We further applied subsampling with ρ values of 10−5 and 10−3 to the Music and Store datasets, respectively. The reason we set different parameter values is due to different sizes of the datasets. </p><h2 id="论文解读"><a href="#论文解读" class="headerlink" title="论文解读"></a>论文解读</h2><p>一个物品集合被视作自然语言中的一个段落，物品集合的基本元素－物品等价于段落中的单词。因此在论文中，一个音乐物品集合是用户对某歌手歌曲的播放行为，一个商品集合是一个订单中包含的所有商品。</p><p>从自然语言序列迁移到物品集合，丢失了空间／时间信息，还无法对用户行为程度建模（喜欢和购买是不同程度的强行为）。好处是可以忽略用户－物品关系，即便获得的订单不包含用户信息，也可以生成物品集合。而论文的结论证明，在一些场景下序列信息的丢失是可忍受的。</p><h2 id="知乎上的实践思路"><a href="#知乎上的实践思路" class="headerlink" title="知乎上的实践思路"></a>知乎上的实践思路</h2><p><a href="https://zhuanlan.zhihu.com/p/28491088" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28491088</a><br>爬取的训练数据是豆瓣网友的电影收藏夹（类比于网易云的歌单）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/v2-4a91dea97a4b64bc2a72a28765188754_b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从结果中可以观察出一些有意思的结论。战狼2是最近刚出的电影(此文作于2017/08)，包含战狼2的大多是“暑期国产电影合集”，“2017年不得不看的国产电影“这类豆列；美国往事属于经典老片，训练语料足够多，skipgram和cbow的推荐结果各有千秋；小时代在豆瓣中属于不受待见的一类电影，包含小时代的豆列较少，skipgram的推荐结果优于cbow。</p><h1 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h1><p><strong>Deep Neural Networks for YouTube Recommendations</strong></p><h2 id="ABSTRACT-1"><a href="#ABSTRACT-1" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>Three major changllenging :(1)Scale,(2)Freshness,(3)Noise.</p><h2 id="SYSTEM-OVERVIEW"><a href="#SYSTEM-OVERVIEW" class="headerlink" title="SYSTEM OVERVIEW"></a>SYSTEM OVERVIEW</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-18%20%E4%B8%8B%E5%8D%881.48.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="CANDIDATE-GENERATION"><a href="#CANDIDATE-GENERATION" class="headerlink" title="CANDIDATE GENERATION"></a>CANDIDATE GENERATION</h2><p>During candidate generation, the enormous YouTube corpus is winnowed down to hundreds of videos that may be relevant to the user .</p><h3 id="Recommendation-as-Classification"><a href="#Recommendation-as-Classification" class="headerlink" title="Recommendation as Classification"></a>Recommendation as Classification</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-18%20%E4%B8%8B%E5%8D%882.03.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>compared to w2v<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/v2-4557472f61cfec30352942afea2b829b_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>you can see Youtube have two embeddings.</p><p>Although explicit feedback mechanisms exist on YouTube (thumbs up/down, in-product surveys, etc.) <strong>They use the implicit feedback</strong>  of watches to train the model, where a user completing a video is a positive example. This choice is based on the orders of magnitude more implicit user history available, allowing They to produce recommendations deep in the tail where explicit feedback is extremely sparse. </p><h3 id="Efficient-Extreme-Multiclass"><a href="#Efficient-Extreme-Multiclass" class="headerlink" title="Efficient Extreme Multiclass"></a>Efficient Extreme Multiclass</h3><p>To efficiently train such a model with millions of classes, they rely on a technique to sample negative classes from the background distribution (“candidate sampling”) and then correct for this sampling via importance weighting ,For each example the cross-entropy loss is minimized for the true label and the sampled negative classes. </p><blockquote><p>negative sample?  </p></blockquote><p>In <strong>practice</strong> several thou- sand negatives are sampled, corresponding to more than <strong>100 times speedup</strong> over traditional softmax. </p><p>At serving time they need to compute the most likely N classes (videos) in order to choose the top N to present to the user. Scoring millions of items under a strict serving latency of tens of milliseconds requires an approximate scoring scheme sublinear in the number of classes. </p><p>The classifier described here uses a similar approach. the scoring problem reduces to <strong>a nearest neighbor search</strong> in the dot product space for which general purpose libraries can be used .</p><h3 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h3><p><strong>A user’s watch history</strong> is represented by a variable-length sequence of sparse <strong>video IDs</strong> which is mapped to a dense vector representation via the <strong>embeddings</strong>.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-18%20%E4%B8%8B%E5%8D%882.24.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Heterogeneous-Signals"><a href="#Heterogeneous-Signals" class="headerlink" title="Heterogeneous Signals"></a>Heterogeneous Signals</h3><p>Search history is treated similarly to watch history - each query is tokenized into unigrams and bigrams and each token is embedded. Once averaged, the user’s tokenized, em- bedded queries represent a summarized dense search history. </p><p>Demographic features are important for providing priors so that the recommendations behave reasonably for new users. </p><p>The user’s geographic region and device are embedded and concatenated. Simple binary and continuous features such as the user’s gender, logged-in state and age are input directly into the network as real values normalized to [0, 1]. </p><p><strong>“Example Age” Feature</strong><br>Many hours worth of videos are uploaded each second to YouTube. Recommending this recently uploaded (“fresh”) content is extremely important for YouTube as a product. We consistently observe that users prefer fresh content, though not at the expense of relevance. </p><p>Machine learning systems often exhibit an implicit bias towards the past because they are trained to predict future behavior from historical examples. To correct for this, we feed the age of the training example as a feature during training.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-18%20%E4%B8%8B%E5%8D%882.39.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Label-and-Context-Selection"><a href="#Label-and-Context-Selection" class="headerlink" title="Label and Context Selection"></a>Label and Context Selection</h3><h2 id="王喆知乎"><a href="#王喆知乎" class="headerlink" title="王喆知乎"></a>王喆知乎</h2><ul><li style="list-style: none"><input type="checkbox"> 除了文中的单独对embedding层进行训练，还可以加上一个embedding层后跟DNN一起训练。优劣？</li></ul><p>本文字字珠玑适合之后细读。</p><h1 id="Airbnb"><a href="#Airbnb" class="headerlink" title="Airbnb"></a>Airbnb</h1><p><strong>Real-time Personalization using Embeddings for Search Ranking at Airbnb</strong> </p><h2 id="ABSTRACT-2"><a href="#ABSTRACT-2" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>capture guest’s short-term and long-term interests, delivering effective home listing recommendations. </p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>Since guests typically conduct multiple searches before booking, i.e. click on more than one listing and contact more than one host during their search session, we can use these in-session signals, i.e. clicks, host contacts, etc. for Real-time Personalization where the aim is to show to the guest more of the listings similar to the ones we think they liked since staring the search session. </p><p>At the same time we can use the negative signal, e.g. skips of high ranked listings, to show to the guest less of the listings similar to the ones we think<br>they did not like .</p><p>use <strong>listing embeddings</strong>, low-dimensional vector representations learned from search sessions. </p><p>In addition to Real-time Personalization using immediate user actions, such as clicks, that can be used as proxy signal for <strong>short- term user interest,</strong> we introduce another type of embeddings trained on bookings to be able to capture user’s <strong>long-term interest</strong>. </p><p>Due to the nature of travel business, where users travel 1-2 times per year on average, bookings are a sparse signal, with a long tail of users with a single booking. To tackle this we propose to train embeddings at a level of user type, instead of a particular user id, where type is determined using many-to-one rule-based mapping that leverages known user attributes. </p><p>At the same time we learn listing type embeddings in the same vector space as user type embeddings. This enables us to calculate similarities between user type embedding of the user who is conducting a search and listing type embeddings of candidate listings that need to be ranked. </p><p>For short-term interest personalization they trained listing embeddings using more than 800 million search clicks sessions, resulting in high quality listing representations. </p><p>For long-term interest personalization we trained user type and listing type embeddings using sequences of booked listings by 50 million users. Both user and listing type embeddings were learned in the same vector space, such that we can calculate similarities between user type and listing types of listings that need to be ranked. </p><h2 id="王喆知乎-1"><a href="#王喆知乎-1" class="headerlink" title="王喆知乎"></a>王喆知乎</h2><p>具体到embedding上，文章通过两种方式生成了两种不同的embedding分别capture用户的short term和long term的兴趣。</p><ol><li>一是通过click session数据生成listing的embedding，生成这个embedding的目的是为了进行listing的相似推荐，以及对用户进行session内的实时个性化推荐。</li><li>二是通过booking session生成user-type和listing-type的embedding，目的是捕捉不同user-type的long term喜好。由于booking signal过于稀疏，Airbnb对同属性的user和listing进行了聚合，形成了user-type和listing-type这两个embedding的对象。</li></ol><p>第一个对listing进行embedding的方法：<br>Airbnb采用了click session数据对listing进行embedding，其中click session指的是一个用户在一次搜索过程中，点击的listing的序列，这个序列需要满足两个条件，一个是只有停留时间超过30s的listing page才被算作序列中的一个数据点，二是如果用户超过30分钟没有动作，那么这个序列会断掉，不再是一个序列。这么做的目的无可厚非，一是清洗噪声点和负反馈信号，二是避免非相关序列的产生。</p><p>有了由clicked listings组成的sequence，我们可以把这个sequence当作一个“句子”样本，开始embedding的过程。Airbnb不出意外的选择了word2vec的skip-gram model作为embedding方法的框架。通过修改word2vec的objective使其靠近Airbnb的业务目标。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/v2-98bd1b08041a3f247c184b1a2207c044_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>正样本很自然的取自click session sliding window里的两个listing，负样本则是在确定central listing后随机从语料库（这里就是listing的集合）中选取一个listing作为负样本。</p><p>因此，Airbnb初始的objective function几乎与word2vec的objective一模一样。</p><p>在原始word2vec embedding的基础上，针对其业务特点，Airbnb的工程师希望能够把booking的信息引入embedding。这样直观上可以使Airbnb的搜索列表和similar item列表中更倾向于推荐之前booking成功session中的listing。从这个motivation出发，Airbnb把click session分成两类，最终产生booking行为的叫booked session，没有的称做exploratory session。</p><p>文章多介绍了一下cold start的问题。简言之，如果有new listing缺失embedding vector，就找附近的3个同样类型、相似价格的listing embedding进行平均得到，不失为一个实用的工程经验。</p><p>embedding不仅encode了price，listing-type等信息，甚至连listing的风格信息都能抓住，说明即使我们不利用图片信息，也能从用户的click session中挖掘出相似风格的listing。</p><p>为了捕捉用户的长期偏好，airbnb在这里使用了booking session序列。比如用户j在过去1年依次book过5个listing。既然有了booking session的集合，我们是否可以像之前对待click session一样拿直接应用w2v的方法得到embedding呢？答案是否定的，因为我们会遇到非常棘手的数据稀疏问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/RS%20Embedding%20Papers/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-18%20%E4%B8%8B%E5%8D%883.32.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>具体来讲booking session的数据稀疏问题表现在下面三点上：</p><ol><li>book行为的总体数量本身就远远小于click的行为，所以booking session集合的大小是远远小于click session的</li><li>单一用户的book行为很少，大量用户在过去一年甚至只book过一个房源，这导致很多booking session sequence的长度为1</li><li>大部分listing被book的次数也少的可怜，大家知道w2v要训练出较稳定有意义的embedding，item最少需要出现5-10次，但大量listing的book次数少于5次，根本无法得到有效的embedding。</li></ol><p>Airbnb如何解决如此严重的数据稀疏问题，训练出有意义的user embedding和listing embedding呢？他们给出的答案是基于某些属性规则做相似user和相似listing的聚合。</p><p>可以之后再细读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Item2Vec-Microsoft&quot;&gt;&lt;a href=&quot;#Item2Vec-Microsoft&quot; class=&quot;headerlink&quot; title=&quot;Item2Vec  Microsoft&quot;&gt;&lt;/a&gt;Item2Vec  Microsoft&lt;/h1&gt;&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch get started</title>
    <link href="https://github.com/zdkswd/2019/04/17/PyTorch%20get%20started/"/>
    <id>https://github.com/zdkswd/2019/04/17/PyTorch get started/</id>
    <published>2019-04-17T12:04:47.000Z</published>
    <updated>2019-04-17T12:05:51.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h1><p>Tensors are similar to NumPy’s ndarrays, with the addition being that Tensors can also be used on a GPU to accelerate computing.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.04.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Construct a 5x3 matrix, uninitialized:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.04.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Construct a randomly initialized matrix:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.05.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Construct a matrix filled zeros and of dtype long:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.05.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Construct a tensor directly from data:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.06.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>or create a tensor based on an existing tensor. These methods will reuse properties of the input tensor, e.g. dtype, unless new values are provided by user<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.07.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Get its size:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.15.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>Note:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.32.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><p>Addition: syntax 1<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.33.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Addition: syntax 2<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.33.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Addition: providing an output tensor as argument<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.34.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Addition: in-place<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.35.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>Note:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.36.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>You can use standard NumPy-like indexing<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.36.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Resizing: If you want to resize/reshape tensor, you can use torch.view:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.39.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Out:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.40.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>If you have a one element tensor, use .item() to get the value as a Python number<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.40.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Numpy-Bridge"><a href="#Numpy-Bridge" class="headerlink" title="Numpy Bridge"></a>Numpy Bridge</h1><p>The Torch Tensor and NumPy array will share their underlying memory locations, and changing one will change the other.</p><h2 id="Converting-a-Torch-Tensor-to-a-NumPy-Array"><a href="#Converting-a-Torch-Tensor-to-a-NumPy-Array" class="headerlink" title="Converting a Torch Tensor to a NumPy Array"></a>Converting a Torch Tensor to a NumPy Array</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.42.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.42.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.42.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.43.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.43.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Out:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.43.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Converting-NumPy-Array-to-Torch-Tensor"><a href="#Converting-NumPy-Array-to-Torch-Tensor" class="headerlink" title="Converting NumPy Array to Torch Tensor"></a>Converting NumPy Array to Torch Tensor</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.44.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>out:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%886.44.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>All the Tensors on the CPU except a CharTensor support converting to NumPy and back.</p><h1 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h1><p>Tensors can be moved onto any device using the .to method.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%887.43.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>out:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%887.46.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%887.58.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%887.59.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="PyTorch-Custom-nn-Modules"><a href="#PyTorch-Custom-nn-Modules" class="headerlink" title="PyTorch: Custom nn Modules"></a>PyTorch: Custom nn Modules</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%888.01.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/PyTorch%20get%20started/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%888.01.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tensors&quot;&gt;&lt;a href=&quot;#Tensors&quot; class=&quot;headerlink&quot; title=&quot;Tensors&quot;&gt;&lt;/a&gt;Tensors&lt;/h1&gt;&lt;p&gt;Tensors are similar to NumPy’s ndarrays, with the 
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tx往届心得</title>
    <link href="https://github.com/zdkswd/2019/04/17/tx%E5%BE%80%E5%B1%8A%E5%BF%83%E5%BE%97/"/>
    <id>https://github.com/zdkswd/2019/04/17/tx往届心得/</id>
    <published>2019-04-17T08:49:47.000Z</published>
    <updated>2019-04-17T02:57:36.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stacking技术分享"><a href="#stacking技术分享" class="headerlink" title="stacking技术分享"></a>stacking技术分享</h1><p>stacking不能称为一种算法，而是一种对模型的集成策略。在给定数据集的情况下，数据内部的空间结构和数据之间的关系是非常复杂得。不同的模型，其实很重要的一点就是在不同的角度去观测数据集。stacking框架就是用来取长补短进行结合的。</p><p>假设是五折的stacking，我们有一个train数据集和一个test数据集，那么一个基本的stacking框架会进行如下几个操作：</p><ol><li>选择基模型。我们可以有xgboost，lightGBM，RandomForest，SVM，ANN，KNN，LR等等你能想到的各种基本算法模型。</li><li>把训练集分为不交叉的五份。我们标记为train1到train5。</li><li>从train1开始作为预测集，使用train2到train5建模，然后预测train1，并保留结果；然后，以train2作为预测集，使用train1，train3到train5建模，预测train2，并保留结果；如此进行下去，直到把train1到train5各预测一遍；</li><li>把预测的结果按照train1到trian5的位置对应填补上，得到对train整个数据集在第一个基模型的一个stacking转换。</li><li>在上述建立的五个模型过程中，每个模型分别对test数据集进行预测，并最终保留这五列结果，然后对这五列取平均，作为第一个基模型对test数据的一个stacking转换。</li><li>选择第二个基模型，重复以上2-5操作，再次得到train整个数据集在第二个基模型的一个stacking转换。</li><li>以此类推。有几个基模型，就会对整个train数据集生成几列新的特征表达。同样，也会对test有几列新的特征表达。</li><li>一般使用LR作为第二层的模型进行建模预测。</li></ol><p><img src="/img/media/tx%E5%BE%80%E5%B1%8A%E5%BF%83%E5%BE%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%20%E4%B8%8B%E5%8D%881.32.08.png" alt=""><br>上面这个框架说明的是：对训练数据进行无重复的五次划分之后，分别对其中每一部分进行一次预测，而预测的模型就是由其余四部分训练的；并且在预测了预测集之后，还需要对我们的test数据集也进行一次预测，这这样就会得到5个N/5行、1列的对train数据集的特征转换，和5个M行、1列的对test数据集的特征转换，由此进入下一个图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/tx%E5%BE%80%E5%B1%8A%E5%BF%83%E5%BE%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%20%E4%B8%8B%E5%8D%881.33.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.stacking的框架设计比较复杂，对于一个基模型要训练5次，如果你的一个xgb模型要训练2个小时，即使在进行stacking的时候每折减少了五分之一的数据量，你的计算时间仍然是很可观的，加起来应该还是8-9小时，所以耗费时间很长（想像一下一个stacking框架跑一个基模型要大半天，简直太可怕）。所以建议大家在使用的时候要计算时间的耗费，或者可以改为3折，4折等等；</p><p>2、我们前面讲过了，stacking框架是集成了不同的算法，充分利用不同算法从不同的数据空间角度和数据结构角度的对数据的不同观测，来取长补短，优化结果。所以，我们的基模型除了是不同参数的相同模型之外，比如不同参数的xgboost，或者不同K值的KNN等等；更重要的是要尽可能的多加一些不同种类的基模型进去，也就是说所谓的模型要“跨越空间”的概念。这样的话我们的集成结果会更加稳健，更加精确。（曾经有一个比赛集成了上百个基模型的stacking框架获奖）</p><h2 id="基本变种改进"><a href="#基本变种改进" class="headerlink" title="基本变种改进"></a>基本变种改进</h2><p>在变种改进方面，我们可以不仅对模型进行融合，还可以对特征级进行一些变化，比如选部分特征做stacking；或者对stacking的结果进行再次的stacking，上面介绍的是两层的stacking，可以有3层，或者更多。但是时间复杂度很高，效果并不一定明显。</p><h1 id="Kaggle数据挖掘比赛经验分享"><a href="#Kaggle数据挖掘比赛经验分享" class="headerlink" title="Kaggle数据挖掘比赛经验分享"></a>Kaggle数据挖掘比赛经验分享</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzgzOTUxNA==&amp;mid=2247483678&amp;idx=1&amp;sn=5f044dabfaa726e292686287a1dd5ca4&amp;chksm=e8fecfebdf8946fdabf71fd5c4c0e019144f105da993c12fa257c64f281ecfb3a7557f16b79e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【干货】Kaggle 数据挖掘比赛经验分享</a><br>一个完整的数据挖掘比赛基本流程如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/tx%E5%BE%80%E5%B1%8A%E5%BF%83%E5%BE%97/640.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>通过对数据进行探索性分析（甚至有些情况下需要肉眼观察样本），还可以有助于启发数据清洗和特征抽取，譬如缺失值和异常值的处理，文本数据是否需要进行拼写纠正等。</p><h3 id="分析特征变量的分布"><a href="#分析特征变量的分布" class="headerlink" title="分析特征变量的分布"></a>分析特征变量的分布</h3><ol><li><strong>特征变量</strong>为连续值：如果为长尾分布并且考虑使用线性模型，可以对变量进行幂变换或者对数变换。</li><li><strong>特征变量</strong>为离散值：观察每个离散值的频率分布，对于频次较低的特征，可以考虑统一编码为“其他”类别。</li></ol><h3 id="分析目标变量的分布"><a href="#分析目标变量的分布" class="headerlink" title="分析目标变量的分布"></a>分析目标变量的分布</h3><ol><li><strong>目标变量</strong>为连续值：查看其值域范围是否较大，如果较大，可以考虑对其进行对数变换，并以变换后的值作为新的目标变量进行建模（<strong>在这种情况下，需要对预测结果进行逆变换</strong>）。一般情况下，可以对连续变量进行<strong>Box-Cox</strong>变换。通过变换可以使得模型更好的优化，通常也会带来效果上的提升。</li><li><strong>目标变量</strong>为离散值：如果数据分布不平衡，考虑是否需要上采样/下采样；如果目标变量在某个ID上面分布不平衡，在划分本地训练集和验证集的时候，需要考虑<strong>分层采样（Stratified Sampling）</strong>。</li></ol><h3 id="分析变量之间两两的分布和相关度"><a href="#分析变量之间两两的分布和相关度" class="headerlink" title="分析变量之间两两的分布和相关度"></a>分析变量之间两两的分布和相关度</h3><ol><li>可以用于发现高相关和共线性的特征。</li></ol><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>数据清洗是指对提供的原始数据进行一定的加工，使得其方便后续的特征抽取。其与特征抽取的界限有时也没有那么明确。常用的数据清洗一般包括：</p><h3 id="数据的拼接"><a href="#数据的拼接" class="headerlink" title="数据的拼接"></a>数据的拼接</h3><ol><li>提供的数据散落在多个文件，需要根据相应的键值进行数据的拼接。</li></ol><h3 id="特征缺失值的处理"><a href="#特征缺失值的处理" class="headerlink" title="特征缺失值的处理"></a>特征缺失值的处理</h3><ol><li>特征值为连续值：按不同的分布类型对缺失值进行补全：<strong>偏正态分布</strong>，使用均值代替，可以保持数据的均值；<strong>偏长尾分布</strong>，使用中值代替，避免受 outlier 的影响；</li><li>特征值为离散值：使用众数代替。</li></ol><h3 id="文本数据的清洗"><a href="#文本数据的清洗" class="headerlink" title="文本数据的清洗"></a>文本数据的清洗</h3><ol><li>在比赛当中，如果数据包含文本，往往需要进行大量的数据清洗工作。如去除HTML 标签，分词，拼写纠正, 同义词替换，去除停词，抽词干，数字和单位格式统一等。</li></ol><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>有一种说法是，特征决定了效果的上限，而不同模型只是以不同的方式或不同的程度来逼近这个上限。这样来看，好的特征输入对于模型的效果至关重要，正所谓”Garbage in, garbage out”。要做好特征工程，往往跟领域知识和对问题的理解程度有很大的关系，也跟一个人的经验相关。特征工程的做法也是Case by Case，以下就一些点，谈谈自己的一些看法。</p><h3 id="特征变换"><a href="#特征变换" class="headerlink" title="特征变换"></a>特征变换</h3><p>主要针对一些长尾分布的特征，<strong>需要进行幂变换或者对数变换，使得模型（LR或者DNN）能更好的优化</strong>。需要注意的是，Random Forest 和 GBDT 等模型对单调的函数变换不敏感。其原因在于树模型在求解分裂点的时候，只考虑排序分位点。</p><h3 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h3><p>对于离散的类别特征，往往需要进行必要的特征转换/编码才能将其作为特征输入到模型中。常用的编码方式有 LabelEncoder，OneHotEncoder（sklearn里面的接口）。譬如对于”性别”这个特征（取值为男性和女性），使用这两种方式可以分别编码为{0,1}和{[1,0], [0,1]}。</p><p>对于取值较多（如几十万）的类别特征（ID特征），直接进行OneHotEncoder编码会导致特征矩阵非常巨大，影响模型效果。可以使用如下的方式进行处理：<br>◆ 统计每个取值在样本中出现的频率，取 Top N 的取值进行 One-hot 编码，剩下的类别分到“其他“类目下，其中 N 需要根据模型效果进行调优；<br>◆ 统计每个 ID 特征的一些统计量（譬如历史平均点击率，历史平均浏览率）等代替该 ID 取值作为特征，具体可以参考 Avazu 点击率预估比赛第二名的获奖方案；<br>◆ 参考 word2vec 的方式，将每个类别特征的取值映射到一个连续的向量，对这个向量进行初始化，跟模型一起训练。训练结束后，可以同时得到每个ID的Embedding。具体的使用方式，可以参考 Rossmann 销量预估竞赛第三名的获奖方案，<a href="https://github.com/entron/entity-embedding-rossmann。">https://github.com/entron/entity-embedding-rossmann。</a></p><p>对于 Random Forest 和 GBDT 等模型，如果类别特征存在较多的取值，可以直接使用 LabelEncoder 后的结果作为特征（这里应该只是将数字来代替类别，数字并不具有实际含义）。注意labelEncoder将文字变换为数字，是虚拟数据，不一定有意义，建模时要注意去除。</p><h2 id="模型训练和验证"><a href="#模型训练和验证" class="headerlink" title="模型训练和验证"></a>模型训练和验证</h2><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><p>在处理好特征后，我们可以进行模型的训练和验证。<br>◆ 对于稀疏型特征（如文本特征，One-hot的ID类特征），我们一般使用线性模型，譬如 Linear Regression 或者 Logistic Regression。Random Forest 和 GBDT 等树模型不太适用于稀疏的特征，但可以先对特征进行降维（如PCA，SVD/LSA等），再使用这些特征。稀疏特征直接输入 DNN 会导致网络 weight 较多，不利于优化，也可以考虑先降维，或者对 ID 类特征使用 Embedding 的方式；<br>◆ 对于稠密型特征，推荐使用 XGBoost 进行建模，简单易用效果好；<br>◆ 数据中既有稀疏特征，又有稠密特征，可以考虑使用线性模型对稀疏特征进行建模，将其输出与稠密特征一起再输入 XGBoost/DNN 建模，具体可以参考Stacking 部分。</p><h3 id="调参和模型验证"><a href="#调参和模型验证" class="headerlink" title="调参和模型验证"></a>调参和模型验证</h3><p>对于选定的特征和模型，我们往往还需要对模型进行超参数的调优，才能获得比较理想的效果。调参一般可以概括为以下三个步骤：</p><p>1.<strong>训练集和验证集的划分。</strong>根据比赛提供的训练集和测试集，模拟其划分方式对训练集进行划分为本地训练集和本地验证集。划分的方式视具体比赛和数据而定，常用的方式有：<br>a) 随机划分：譬如随机采样 70% 作为训练集，剩余的 30% 作为测试集。在这种情况下，本地可以采用 KFold 或者 Stratified KFold 的方法来构造训练集和验证集。<br>b) 按时间划分：一般对应于时序序列数据，譬如取前 7 天数据作为训练集，后 1 天数据作为测试集。这种情况下，划分本地训练集和验证集也需要按时间先后划分。常见的错误方式是随机划分，这种划分方式可能会导致模型效果被高估。<br>c) 按某些规则划分：在 HomeDepot 搜索相关性比赛中，训练集和测试集中的 Query 集合并非完全重合，两者只有部分交集。而在另外一个相似的比赛中（CrowdFlower 搜索相关性比赛），训练集和测试集具有完全一致的 Query 集合。对于 HomeDepot 这个比赛中，训练集和验证集数据的划分，需要考虑 Query 集合并非完全重合这个情况，其中的一种方法可以参考第三名的获奖方案，<a href="https://github.com/ChenglongChen/Kaggle_HomeDepot。">https://github.com/ChenglongChen/Kaggle_HomeDepot。</a></p><p>2.<strong>指定参数空间</strong>。在指定参数空间的时候，需要对模型参数以及其如何影响模型的效果有一定的了解，才能指定出合理的参数空间。譬如DNN或者XGBoost中学习率这个参数，一般就选 0.01 左右就 OK 了（太大可能会导致优化算法错过最优化点，太小导致优化收敛过慢）。再如 Random Forest，一般设定树的棵数范围为 100~200 就能有不错的效果，当然也有人固定数棵数为 500，然后只调整其他的超参数。</p><p>3.<strong>按照一定的方法进行参数搜索</strong>。常用的参数搜索方法有，Grid Search，Random Search以及一些自动化的方法（如 Hyperopt）。其中，Hyperopt 的方法，根据历史已经评估过的参数组合的效果，来推测本次评估使用哪个参数组合更有可能获得更好的效果。</p><h3 id="适当利用-Public-LB-的反馈"><a href="#适当利用-Public-LB-的反馈" class="headerlink" title="适当利用 Public LB 的反馈"></a>适当利用 Public LB 的反馈</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/tx%E5%BE%80%E5%B1%8A%E5%BF%83%E5%BE%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8A%E5%8D%8810.30.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h2><h3 id="Averaging-和-Voting"><a href="#Averaging-和-Voting" class="headerlink" title="Averaging 和 Voting"></a>Averaging 和 Voting</h3><p>直接对多个模型的预测结果求平均或者投票。对于目标变量为连续值的任务，使用平均；对于目标变量为离散值的任务，使用投票的方式。</p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/tx%E5%BE%80%E5%B1%8A%E5%BF%83%E5%BE%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8A%E5%8D%8810.32.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li><strong>数据集划分</strong>。将训练数据按照5-Fold进行划分（如果数据跟时间有关，需要按时间划分）</li><li><strong>基础模型训练 I</strong>。按照交叉验证（Cross Validation）的方法，在训练集（Training Fold）上面训练模型（如图灰色部分所示），并在验证集（Validation Fold）上面做预测，得到预测结果（如图黄色部分所示）。最后综合得到整个训练集上面的预测结果（如图第一个黄色部分的CV Prediction所示）。</li><li><strong>基础模型训练 II</strong>（如图5第二和三行左半部分所示）。在全量的训练集上训练模型（如图第二行灰色部分所示），并在测试集上面做预测，得到预测结果（如图第三行虚线后绿色部分所示）。</li><li><strong>Stage 1 模型集成训练 I</strong>（如图5第一行右半部分所示）。将步骤 2 中得到的 CV Prediction 当作新的训练集，按照步骤 2 可以得到 Stage 1模型集成的 CV Prediction。</li><li>Stage 1 模型集成训练 II（如图5第二和三行右半部分所示）。将步骤 2 中得到的 CV Prediction 当作新的训练集和步骤 3 中得到的 Prediction 当作新的测试集，按照步骤 3 可以得到 Stage 1 模型集成的测试集 Prediction。此为 Stage 1 的输出，可以提交至 Kaggle 验证其效果。</li></ol><p>在图5中，基础模型只展示了一个，而实际应用中，基础模型可以多种多样，如SVM，DNN，XGBoost 等。也可以相同的模型，不同的参数，或者不同的样本权重。重复4和5两个步骤，可以相继叠加 Stage 2, Stage 3 等模型。</p><h3 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h3><p>Blending 与 Stacking 类似，但单独留出一部分数据（如 20%）用于训练 Stage X 模型。</p><h3 id="Bagging-Ensemble-Selection"><a href="#Bagging-Ensemble-Selection" class="headerlink" title="Bagging Ensemble Selection"></a>Bagging Ensemble Selection</h3><p>Bagging Ensemble Selection [5] 是我在 CrowdFlower 搜索相关性比赛中使用的方法，其主要的优点在于可以以优化任意的指标来进行模型集成。这些指标可以是可导的（如 LogLoss 等）和不可导的（如正确率，AUC，Quadratic Weighted Kappa等）。它是一个前向贪婪算法，存在过拟合的可能性，作者在文献 [5] 中提出了一系列的方法（如 Bagging）来降低这种风险，稳定集成模型的性能。使用这个方法，需要有成百上千的基础模型。为此，在 CrowdFlower 的比赛中，我把在调参过程中所有的中间模型以及相应的预测结果保留下来，作为基础模型。这样做的好处是，不仅仅能够找到最优的单模型（Best Single Model），而且所有的中间模型还可以参与模型集成，进一步提升效果。</p><h2 id="自动化框架"><a href="#自动化框架" class="headerlink" title="自动化框架"></a>自动化框架</h2><p>这份代码开源在 Github 上面，目前是 Github 有关 Kaggle 竞赛解决方案的 Most Stars，地址：<a href="https://github.com/ChenglongChen/Kaggle_CrowdFlower。">https://github.com/ChenglongChen/Kaggle_CrowdFlower。</a></p><p>其主要包含以下部分：</p><p>1.模块化特征工程<br>a) 接口统一，只需写少量的代码就能够生成新的特征；<br>b) 自动将单独的特征拼接成特征矩阵。</p><p>2.自动化模型调参和验证<br>a) 自定义训练集和验证集的划分方法；<br>b) 使用 Grid Search / Hyperopt 等方法，对特定的模型在指定的参数空间进行调优，并记录最佳的模型参数以及相应的性能。</p><p>3.自动化模型集成<br>a) 对于指定的基础模型，按照一定的方法（如Averaging_Stacking_Blending 等）生成集成模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stacking技术分享&quot;&gt;&lt;a href=&quot;#stacking技术分享&quot; class=&quot;headerlink&quot; title=&quot;stacking技术分享&quot;&gt;&lt;/a&gt;stacking技术分享&lt;/h1&gt;&lt;p&gt;stacking不能称为一种算法，而是一种对模型的集成策略。
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LightGBM Python quick start</title>
    <link href="https://github.com/zdkswd/2019/04/17/LightGBM%20Python%20quick%20start/"/>
    <id>https://github.com/zdkswd/2019/04/17/LightGBM Python quick start/</id>
    <published>2019-04-17T06:00:32.000Z</published>
    <updated>2019-04-17T06:00:16.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LightGBM-Python-quick-start"><a href="#LightGBM-Python-quick-start" class="headerlink" title="LightGBM Python quick start"></a>LightGBM Python quick start</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.00.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Data-Interface"><a href="#Data-Interface" class="headerlink" title="Data Interface"></a>Data Interface</h1><p>The LightGBM Python module can load data from:</p><p>1.libsvm/ tsv / csv / txt format file<br>2.NumPy 2D array(s), pandas DataFrame, H2O DataTable’s Frame, SciPy sparse matrix<br>3.LightGBM binary file</p><p>The data is stored in a <strong>Dataset</strong> object.</p><p><strong>To load a libsvm text file or a LightGBM binary file into Dataset:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.02.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>To load a numpy array into Dataset:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.02.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>Saving Dataset into a LightGBM binary file will make loading faster:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.03.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>Create validation data:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.05.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>or<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.06.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>In LightGBM, the validation data should be aligned with training data.</p><p><strong>Specific feature names and categorical features:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.22.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>LightGBM can use categorical features as input directly. It doesn’t need to convert to one-hot coding, and is much faster than one-hot coding (about 8x speed-up).</p><p><strong>Note</strong>: You should convert your categorical features to <strong>int</strong> type before you construct <strong>Dataset</strong>.</p><p><strong>Weights can be set when needed:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.22.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>or<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.23.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>And you can use <strong>Dataset.set_init_score()</strong> to set initial score, and <strong>Dataset.set_group()</strong> to set group/query data for ranking tasks.</p><p><strong>Memory efficient usage:</strong><br>The <strong>Dataset</strong> object in LightGBM is very memory-efficient, it only needs to save discrete bins. However, Numpy / Array / Pandas object is memory expensive. If you are concerned about your memory consumption, you can save memory by:</p><ol><li>Set <strong>free_raw_data=True</strong> (default is <strong>True</strong>) when constructing the <strong>Dataset</strong></li><li>Explicitly set <strong>raw_data=None</strong> after the <strong>Dataset</strong> has been constructed</li><li>Call <strong>gc</strong></li></ol><h1 id="Setting-Parameters"><a href="#Setting-Parameters" class="headerlink" title="Setting Parameters"></a>Setting Parameters</h1><p>LightGBM can use either a list of pairs or a dictionary to set <strong>Parameters</strong>. For instance:<br><strong>Booster parameters</strong>:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.56.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.27.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>You can also specify multiple eval metrics:</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.28.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h1><p>Training a model requires a parameter list and data set:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.29.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>After training, the model can be saved:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.30.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>The trained model can also be dumped to JSON format:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.31.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>A saved model can be loaded:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.31.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h1><p>Training with 5-fold CV:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.33.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Early-Stopping"><a href="#Early-Stopping" class="headerlink" title="Early Stopping"></a>Early Stopping</h1><p>If you have a validation set, you can use early stopping to find the optimal number of boosting rounds. Early stopping requires at least one set in <strong>valid_sets</strong>. If there is more than one, it will use all of them except the training data:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.35.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>The model will train until the validation score stops improving. Validation score needs to improve at least every <strong>early_stopping_rounds</strong> to continue training.</p><p>The index of iteration that has the best performance will be saved in the <strong>best_iteration</strong> field if early stopping logic is enabled by setting <strong>early_stopping_rounds</strong>. Note that <strong>train()</strong> will return a model from the best iteration.</p><p>This works with both metrics to minimize (L2, log loss, etc.) and to maximize (NDCG, AUC, etc.). Note that if you specify more than one evaluation metric, all of them will be used for early stopping. However, you can change this behavior and make LightGBM check only the first metric for early stopping by creating <strong>early_stopping</strong> callback with <strong>first_metric_only=True</strong>.</p><h1 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h1><p>A model that has been trained or loaded can perform predictions on datasets:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.51.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>If early stopping is enabled during training, you can get predictions from the best iteration with <strong>bst.best_iteration</strong>:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/LightGBM%20Python%20quick%20start/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-17%20%E4%B8%8B%E5%8D%881.52.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LightGBM-Python-quick-start&quot;&gt;&lt;a href=&quot;#LightGBM-Python-quick-start&quot; class=&quot;headerlink&quot; title=&quot;LightGBM Python quick start&quot;&gt;&lt;/a&gt;Light
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
