<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-08-11T02:09:15.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序剖析 运行机制</title>
    <link href="https://github.com/zdkswd/2018/08/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%89%96%E6%9E%90-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/zdkswd/2018/08/11/微信小程序剖析-运行机制/</id>
    <published>2018-08-11T02:02:43.000Z</published>
    <updated>2018-08-11T02:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解压应用"><a href="#解压应用" class="headerlink" title="解压应用"></a>解压应用</h2><p>简单的说明一下：</p><ol><li>app 目录下放置了app的代码</li><li>modified_modules 即一些修改后的模块</li><li>node_modules 地球人都知道</li><li>package.json 配置了NW相关的内容</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解压应用&quot;&gt;&lt;a href=&quot;#解压应用&quot; class=&quot;headerlink&quot; title=&quot;解压应用&quot;&gt;&lt;/a&gt;解压应用&lt;/h2&gt;&lt;p&gt;简单的说明一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;app 目录下放置了app的代码&lt;/li&gt;
&lt;li&gt;modified_modul
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信应用号开发基础教程</title>
    <link href="https://github.com/zdkswd/2018/08/10/%E5%BE%AE%E4%BF%A1%E5%BA%94%E7%94%A8%E5%8F%B7%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/08/10/微信应用号开发基础教程/</id>
    <published>2018-08-10T03:14:13.000Z</published>
    <updated>2018-08-10T03:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="获取微信小程序的AppID"><a href="#获取微信小程序的AppID" class="headerlink" title="获取微信小程序的AppID"></a>获取微信小程序的AppID</h3><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p><p>app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API</p><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p><p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p><h3 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h3><p>微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p><p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。</p><p>index.wxml 是页面的结构文件。</p><p>index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p><p>index.wxss 是页面的样式表。页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p><p>index.json 是页面的配置文件。<br>页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p><h3 id="手机预览"><a href="#手机预览" class="headerlink" title="手机预览"></a>手机预览</h3><h2 id="第一章-准备工作"><a href="#第一章-准备工作" class="headerlink" title="第一章 准备工作"></a>第一章 准备工作</h2><h2 id="第二章-项目架构"><a href="#第二章-项目架构" class="headerlink" title="第二章 项目架构"></a>第二章 项目架构</h2><p>从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。</p><p><strong>生命周期</strong>：<br>顺序是 App Launch–&gt;App Show–&gt;onload–&gt;onShow–&gt;onReady。</p><p>首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。</p><p><strong>路由</strong>：<br>微信在路由方面经过很好的封装，也提供三个跳转方法。</p><ol><li>wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。</li><li>wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。</li><li>wx.navigateBack()：关闭当前页面，回退前一页面。</li></ol><p><strong>组件</strong>：<br>微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。</p><p><strong>其它</strong>：<br>任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的rem.js也是不支持的。</p><p>此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。</p><p>注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。</p><p>建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。</p><p>编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。</p><p>使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。</p><p>「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：</p><blockquote><p>@import “wxss/index.CSS“</p></blockquote><p>注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。</p><p>「Js」文件需要在「app.json」文件的「”page”」里预先配置好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;获取微信小程序的AppID&quot;&gt;&lt;a href=&quot;#获取微信小程序的AppID&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="微信小程序" scheme="https://github.com/zdkswd/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》4 数值计算</title>
    <link href="https://github.com/zdkswd/2018/08/03/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B4%20%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <id>https://github.com/zdkswd/2018/08/03/《深度学习》4 数值计算/</id>
    <published>2018-08-03T01:47:12.000Z</published>
    <updated>2018-08-10T03:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上溢和下溢"><a href="#上溢和下溢" class="headerlink" title="上溢和下溢"></a>上溢和下溢</h2><p>连续数学在数字计算机上的根本困难是,我们需要通过有限数量的位模式来表示无限多的实数。这意味着我们在计算机中表示实数时,几乎总会引入一些近似误差。</p><p>种极具毁灭性的舍人误差是<strong>下溢</strong>( underflow)。当接近零的数被四舍五入为零时发生下溢。</p><p>另一个极具破坏力的数值错误形式是<strong>上溢</strong>( overfow)。当大量级的数被近似为+∞或-∞时发生上溢。进一步的运算通常会导致这些无限值变为非数字。</p><p>必须对上溢和下溢进行数值稳定的一个例子是<strong>softmax函数</strong>。</p><h2 id="病态条件"><a href="#病态条件" class="headerlink" title="病态条件"></a>病态条件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8A%E5%8D%8811.29.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是最大和最小特征值的模之比1 。当该数很大时，矩阵求逆对输入的误差特别敏感。 </p><p>这种敏感性是矩阵本身的固有特性，而不是矩阵求逆期间舍入误差的结果。 </p><h2 id="基于梯度的优化方法"><a href="#基于梯度的优化方法" class="headerlink" title="基于梯度的优化方法"></a>基于梯度的优化方法</h2><p>大多数深度学习算法都涉及某种形式的优化。优化指的是改变 x 以最小化或最 大化某个函数 f(x) 的任务。我们通常以最小化 f(x) 指代大多数最优化问题。最大化可经由最小化算法最小化−f(x) 来实现。 </p><p>我们把要最小化或最大化的函数称为 <strong>目标函数</strong>(objective function)或 <strong>准则</strong> (criterion)。当我们对其进行最小化时，我们也把它称为 <strong>代价函数</strong>(cost function)、 <strong>损失函数</strong>(loss function)或 <strong>误差函数</strong>(error function)。 </p><p><img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8A%E5%8D%8811.34.48.png" alt=""></p><p>有些临界点既不是最小点也不是最大点。这些点被称为 <strong>鞍点</strong>(saddle point)。 </p><p><strong>最速下降法</strong>(method of steepest descent) 或 <strong>梯度下降</strong>(gradient descent)。 </p><p><img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8A%E5%8D%8811.39.22.png" alt=""></p><p>其中 ε 为 学习率(learning rate)。</p><h3 id="梯度之上-Jacobian-和-Hessian-矩阵"><a href="#梯度之上-Jacobian-和-Hessian-矩阵" class="headerlink" title="梯度之上:Jacobian 和 Hessian 矩阵"></a>梯度之上:Jacobian 和 Hessian 矩阵</h3><p>有时我们需要计算输入和输出都为向量的函数的所有偏导数。包含所有这样的偏导数的矩阵被称为 <strong>Jacobian</strong> 矩阵。 雅可比矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.13.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当我们的函数具有多维输入时，二阶导数也有很多。我们可以将这些导数合并 成一个矩阵，称为 <strong>Hessian</strong> 矩阵。 黑塞矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.22.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.27.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Hessian 等价于梯度的 Jacobian 矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.30.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.35.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当 Hessian 的条件数很差时，梯度下降法也会表现得很差。 </p><p>病态条件也导致很难选择合适的步长。步长必须足够小，以免冲过最小而向具有较强正曲率的方向上升。这通常意味着步长太小，以致于在其他较小曲率的方向上进展不明显。 </p><p><img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.47.21.png" alt=""><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%885.08.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>牛顿法，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-03%20%E4%B8%8A%E5%8D%889.06.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>仅使用梯度信息的优化算法被称为<strong>一阶优化算法</strong>(first-order optimization al- gorithms)，如梯度下降。使用 Hessian 矩阵的优化算法被称为<strong>二阶最优化算法</strong>(second-order optimization algorithms)(Nocedal and Wright, 2006)，如牛顿法。 </p><p>在深度学习的背景下，限制函数满足<strong>Lipschitz 连续</strong>(Lipschitz continuous)或 其导数Lipschitz连续可以获得一些保证。直觉上，利普希茨连续函数限制了函数改变的速度，符合利普希茨条件的函数的斜率，必小于一个称为利普希茨常数的实数（该常数依函数而定）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-03%20%E4%B8%8A%E5%8D%889.17.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>最成功的特定优化领域或许是 凸优化(Convex optimization)。凸优化通过更强 的限制提供更多的保证。凸优化算法只对凸函数适用，即 Hessian 处处半正定的函 数。因为这些函数没有鞍点而且其所有局部极小点必然是全局最小点，所以表现很 好。然而，深度学习中的大多数问题都难以表示成凸优化的形式。凸优化仅用作一 些深度学习算法的子程序。凸优化中的分析思路对证明深度学习算法的收敛性非常 有用，然而一般来说，深度学习背景下凸优化的重要性大大减少。 </p><h2 id="约束优化"><a href="#约束优化" class="headerlink" title="约束优化"></a>约束优化</h2><p>在 x 的某些集合 S 中找 f(x) 的最大值或最小值。这被称 为 约束优化(constrained optimization)。在约束优化术语中，集合 S 内的点 x 被称为可行(feasible)点。 </p><p>我们常常希望找到在某种意义上小的解。针对这种情况下的常见方法是强加一 个范数约束，如 ||x|| ≤ 1。 </p><p><strong>Karush–Kuhn–Tucker</strong>(KKT)方法是针对约束优化非常通用的解决方案。KKT 方法是 <strong>Lagrange 乘子法</strong>(只允许等式约束)的推广。</p><p>我们可以使用一组简单的性质来描述约束优化问题的最优点。这些性质称 为 Karush–Kuhn–Tucker(KKT)条件 (Karush, 1939; Kuhn and Tucker, 1951)。 这些是确定一个点是最优点的必要条件，但不一定是充分条件。这些条件是:</p><ul><li>广义 Lagrangian 的梯度为零。</li><li>所有关于 x 和 KKT 乘子的约束都满足。</li><li>不等式约束显示的 ‘‘互补松弛性’’. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;上溢和下溢&quot;&gt;&lt;a href=&quot;#上溢和下溢&quot; class=&quot;headerlink&quot; title=&quot;上溢和下溢&quot;&gt;&lt;/a&gt;上溢和下溢&lt;/h2&gt;&lt;p&gt;连续数学在数字计算机上的根本困难是,我们需要通过有限数量的位模式来表示无限多的实数。这意味着我们在计算机中表示实数时
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》3 概率与信息论</title>
    <link href="https://github.com/zdkswd/2018/08/01/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B3%20%E6%A6%82%E7%8E%87%E4%B8%8E%E4%BF%A1%E6%81%AF%E8%AE%BA/"/>
    <id>https://github.com/zdkswd/2018/08/01/《深度学习》3 概率与信息论/</id>
    <published>2018-08-01T09:20:12.000Z</published>
    <updated>2018-08-10T03:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用概率"><a href="#为什么要使用概率" class="headerlink" title="为什么要使用概率"></a>为什么要使用概率</h2><p>在医生诊断病人的例子中,我们用概率来表示一种信任度( degree of belief),其中1表示非常肯定病人患有流感,而0表示非常肯定病人没有流感。前面那种概率,直接与事件发生的频率相联系,被称为<strong>频率派概率</strong>( frequentist probability);而后者,涉及到确定性水平,被称为<strong>贝叶斯概率</strong>( Bayesian probability)。</p><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p><strong>随机变量</strong>( random variable)是可以随机地取不同值的变量。</p><p>随机变量可以是离散的或者连续的。离散随机变量拥有有限或者可数无限多的状态。注意这些状态不一定非要是整数;它们也可能只是一些被命名的状态而没有数值。连续随机变量伴随着实数值。</p><h2 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h2><h3 id="离散型变量和概率质量函数"><a href="#离散型变量和概率质量函数" class="headerlink" title="离散型变量和概率质量函数"></a>离散型变量和概率质量函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%887.20.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也有翻译成概率分布律的</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%887.22.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%887.23.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="连续型变量和概率密度函数"><a href="#连续型变量和概率密度函数" class="headerlink" title="连续型变量和概率密度函数"></a>连续型变量和概率密度函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8810.55.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8810.56.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="边缘概率"><a href="#边缘概率" class="headerlink" title="边缘概率"></a>边缘概率</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8810.58.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.00.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.00.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="条件概率的链式法则"><a href="#条件概率的链式法则" class="headerlink" title="条件概率的链式法则"></a>条件概率的链式法则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.02.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="独立性和条件独立性"><a href="#独立性和条件独立性" class="headerlink" title="独立性和条件独立性"></a>独立性和条件独立性</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.05.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果关于x和y的条件概率分布对于z的每一个值都可以写成乘积的形式那么这两个随机变量x和y在给定随机变量z时是条件独立的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.07.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="期望、方差和协方差"><a href="#期望、方差和协方差" class="headerlink" title="期望、方差和协方差"></a>期望、方差和协方差</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.10.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.13.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.18.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>协方差的绝对值如果很大则意味着变量值变化很大并且它们同时距离各自的均值很远。如果协方差是正的,那么两个变量都倾向于同时取得相对较大的值。如果协方差是负的,那么其中一个变量倾向于取得相对较大的值的同时,另一个变量倾向于取得相对较小的值,反之亦然。其他的衡量指标如<strong>相关系数</strong>( correlation)将每个变量的贡献归一化,为了只衡量变量的相关性而不受各个变量尺度大小的影响。</p><p>协方差和相关性是有联系的,但实际上是不同的概念。它们是有联系的,因为两个变量如果相互独立那么它们的协方差为零,如果两个变量的协方差不为零那么它们一定是相关的。然而,独立性又是和协方差完全不同的性质。两个变量如果协方差为零,它们之间一定没有线性关系。独立性比零协方差的要求更强,因为独立性还排除了非线性的关系。两个变量相互依赖但具有零协方差是可能的。</p><h2 id="常用概率分布"><a href="#常用概率分布" class="headerlink" title="常用概率分布"></a>常用概率分布</h2><h3 id="Bernoulli分布（01分布）"><a href="#Bernoulli分布（01分布）" class="headerlink" title="Bernoulli分布（01分布）"></a>Bernoulli分布（01分布）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.26.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Multinoulli分布"><a href="#Multinoulli分布" class="headerlink" title="Multinoulli分布"></a>Multinoulli分布</h3><p>就是多项分布。</p><h3 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h3><p>即为正态分布。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="指数分布和-Laplace分布"><a href="#指数分布和-Laplace分布" class="headerlink" title="指数分布和 Laplace分布"></a>指数分布和 Laplace分布</h3><h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331064341410.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331064440953.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.54.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="拉普拉斯分布"><a href="#拉普拉斯分布" class="headerlink" title="拉普拉斯分布"></a>拉普拉斯分布</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.56.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331065959408.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Dirac分布和经验分布"><a href="#Dirac分布和经验分布" class="headerlink" title="Dirac分布和经验分布"></a>Dirac分布和经验分布</h3><h4 id="Dirac分布"><a href="#Dirac分布" class="headerlink" title="Dirac分布"></a>Dirac分布</h4><p>狄拉克δ函数是一个广义函数，在物理学中常用其表示质点、点电荷等理想模型的密度分布，该函数在除了零以外的点取值都等于零，而其在整个定义域上的积分等于1。</p><p>狄拉克δ函数在概念上，它是这么一个“函数”：在除了零以外的点函数值都等于零，而其在整个定义域上的积分等于1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331067947005.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="经验分布"><a href="#经验分布" class="headerlink" title="经验分布"></a>经验分布</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.08.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="分布的混合"><a href="#分布的混合" class="headerlink" title="分布的混合"></a>分布的混合</h3><p>通过组合一些简单的概率分布来定义新的概率分布也是很常见的。一种通用的组合方法是构造<strong>混合分布</strong>( mixture distribution)。混合分布由一些组件( component)<br>分布构成。</p><p>混合模型是组合简单概率分布来生成更丰富的分布的一种简单策略。</p><p>混合模型使我们能够一瞥以后会用到的一个非常重要的概念—<strong>潜变量</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.15.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="常用函数的有用性质"><a href="#常用函数的有用性质" class="headerlink" title="常用函数的有用性质"></a>常用函数的有用性质</h2><h3 id="logistic-sigmoid函数"><a href="#logistic-sigmoid函数" class="headerlink" title="logistic sigmoid函数"></a>logistic sigmoid函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.18.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.18.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="softplus函数"><a href="#softplus函数" class="headerlink" title="softplus函数"></a>softplus函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.52.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.52.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.52.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.53.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.54.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="贝叶斯规则"><a href="#贝叶斯规则" class="headerlink" title="贝叶斯规则"></a>贝叶斯规则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.55.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="连续型变量的技术细节"><a href="#连续型变量的技术细节" class="headerlink" title="连续型变量的技术细节"></a>连续型变量的技术细节</h2><p>连续型随机变量和概率密度函数的深入理解需要用到数学分支<strong>测度论</strong>(Ineasure heory)的相关内容来扩展概率论。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.01.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.02.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.04.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.04.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h2><p>信息论是应用数学的一个分支,主要研究的是对一个信号包含信息的多少进行量化。在机器学习中,我们也可以把信息论应用于连续型变量。</p><p>信息论的基本想法是一个不太可能的事件居然发生了,要比一个非常可能的事件发生,能提供更多的信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.16.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.19.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.22.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也记作H(P)。换言之,一个分布的香农熵是指遵循这个分布的事件所产生的期望信息总量。当x是连续的,香农熵被称为<strong>微分熵</strong>( differential entropy)。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.33.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.49.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>又称为<strong>相对熵</strong>，是用来度量使用基于Q的编码来编码来自P的样本平均所需的额外的比特个数。典型情况下，P表示数据的真实分布，Q表示数据的理论分布，模型分布，或P的近似分布。</p><p>是描述两个概率分布P和Q差异的一种方法。它是非对称的，这意味着D(P||Q) ≠ D(Q||P)。特别的，在信息论中，D(P||Q)表示当用概率分布Q来拟合真实分布P时，产生的信息损耗，其中P表示真实分布，Q表示P的拟合分布。</p><p>有人将KL散度称为KL距离，但事实上，KL散度并不满足距离的概念，因为：(1)KL散度不是对称的；(2)KL散度不满足三角不等式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.55.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.59.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="结构化概率模型"><a href="#结构化概率模型" class="headerlink" title="结构化概率模型"></a>结构化概率模型</h2><p>机器学习的算法经常会涉及到在非常多的随机变量上的概率分布。通常，这些概率分布涉及到的直接相互作用都是介于非常少的变量之间的。使用单个函数来描述整个联合概率分布是非常低效的 (无论是计算上还是统计上)。 </p><p>我们可以把概率分布分解成许多因子的乘积形式，而不是使用单一的函数来表 示概率分布。例如，假设我们有三个随机变量 a, b 和 c，并且a影响b的取值，b影响c的取值，但是 a 和 c 在给定 b 时是条件独立的。我们可以把全部三个变量的概 率分布重新表示为两个变量的概率分布的连乘形式:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%885.09.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这种分解可以极大地减少用来描述一个分布的参数数量。每个因子使用的参数 数目是它的变量数目的指数倍。 </p><p>我们可以用图来描述这种分解。把它称为<strong>结构化概率模型</strong>(structured probabilistic model)或者<strong>图模型</strong>(graphical model)。 </p><p>有两种主要的结构化概率模型:有向的和无向的。两种图模型都使用图 G，其中 图的每个节点对应着一个随机变量，连接两个随机变量的边意味着概率分布可以表 示成这两个随机变量之间的直接作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%885.13.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%885.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要使用概率&quot;&gt;&lt;a href=&quot;#为什么要使用概率&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用概率&quot;&gt;&lt;/a&gt;为什么要使用概率&lt;/h2&gt;&lt;p&gt;在医生诊断病人的例子中,我们用概率来表示一种信任度( degree of belief),其
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》2 线性代数</title>
    <link href="https://github.com/zdkswd/2018/07/31/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B2%20%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/07/31/《深度学习》2 线性代数/</id>
    <published>2018-07-31T09:41:12.000Z</published>
    <updated>2018-08-10T03:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标量、向量、矩阵和张量"><a href="#标量、向量、矩阵和张量" class="headerlink" title="标量、向量、矩阵和张量"></a>标量、向量、矩阵和张量</h2><ul><li><strong>标量</strong>( scalar)一个标量就是一个单独的数,它不同于线性代数中研究的其他大部分对象(通常是多个数的数组)。我们用斜体表示标量。标量通常被赋予小写的变量名称。当我们介绍标量时,会明确它们是哪种类型的数。比如,在定义实数标量时,我们可能会说“令s∈R表示一条线的斜率”;在定义自然数标量时,我们可能会说“令n∈N表示元素的数目”。</li><li><strong>向量</strong>( vector):一个向量是一列数。这些数是有序排列的。通过次序中的索引,我们可以确定每个单独的数。通常我们赋予向量粗体的小写变量名称,比如<strong>x</strong>。向量中的元素可以通过带脚标的斜体表示。向量<strong>x</strong>的第一个元素是x1,第二个元素是x2,等等。我们也会注明存储在向量中的元素是什么类型的。如果每个元素都属于R,并且该向量有n个元素,那么该向量属于实数集R的n次笛卡尔乘积构成的集合,记为<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.20.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>。当需要明确表示向量中的元素时,我们会将元素排列成一个方括号包围的纵列:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.22.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们可以把向量看作空间中的点,每个元素是不同坐标轴上的坐标。有时我们需要索引向量中的一些元素。在这种情况下,我们定义一个包含这些元素索引的集合,然后将该集合写在脚标处。比如,指定x1,和,我们定义集合S={1,3,6},然后写作xs。我们用符号一表示集合的补集中的索引。比如<strong>x</strong>-1表示<strong>x</strong>中除x1外的所有元素,<strong>x-s</strong>表示<strong>x</strong>中除x1,x3,x6外所有元素构成的向量。</p><ul><li><strong>矩阵</strong>( matrix):矩阵是一个二维数组,其中的每一个元素被两个索引(而非一个)所确定。我们通常会赋予矩阵粗体的大写变量名称,比如<strong>A（斜体）</strong>。如果一个实数矩阵高度为m,宽度为n,那么我们说<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.37.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>。我们在表示矩阵中的元素时,通常以不加粗的斜体形式使用其名称,索引用逗号间隔。比如,A1，1表示A左上的元素,Am，n表示A右下的元素。我们通过用“：”表示水平坐标,以表示垂直坐标i中的所有元素。比如,Ai,:表示<strong>A</strong>中垂直坐标i上的一横排元素。这也被称为A的第i行(row)。同样地,A:,i表示A的第i列column)。当我们需要明确表示矩阵中的元素时,我们将它们写在用方括号括起来的数组中:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.40.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>有时我们需要矩阵值表达式的索引,而不是单个元素。在这种情况下,我们在表达式后面接下标,但不必将矩阵的变量名称小写化。比如<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.44.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>表示函数f作用在A上输出的矩阵的第i行第j列元素。</li><li><strong>张量</strong>( tensor):在某些情况下,我们会讨论坐标超过两维的数组。一般地个数组中的元素分布在若干维坐标的规则网格中,我们称之为张量。我们使用字体<strong>A（不是斜体）</strong>来表示张量“A”。张量A中坐标为(i,j,k)的元素记作Ai,j,k。</li><li><strong>转置</strong>( transpose)是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像这条从左上角到右下角的对角线被称为主对角线( main diagonal)。我们将矩阵A的转置表示为AT,定义如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.52.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>向量可以看作只有一列的矩阵。对应地,向量的转置可以看作是只有一行的矩阵。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.55.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>。标量可以看作是只有一个元素的矩阵。因此,标量的转置等于它本身,a=aT。<br>转置的运算性质<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【】只是记法</span><br></pre></td></tr></table></figure><p> <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.10.22.png" alt=""><br>在深度学习中,我们也使用一些不那么常规的符号。我们允许矩阵和向量相加,产生另一个矩阵:<strong>C</strong>=<strong>A</strong>+<strong>b</strong>,其中<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.13.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>。换言之,向量b和矩阵A的每一行相加。这个简写方法使我们无需在加法操作前定义一个将向量b复制到每一行而生成的矩阵。这种隐式地复制向量b到很多位置的方式,被称为<strong>广播</strong>( broadcasting )。</p><h2 id="矩阵和向量相乘"><a href="#矩阵和向量相乘" class="headerlink" title="矩阵和向量相乘"></a>矩阵和向量相乘</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.18.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.20.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="单位矩阵和逆矩阵"><a href="#单位矩阵和逆矩阵" class="headerlink" title="单位矩阵和逆矩阵"></a>单位矩阵和逆矩阵</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.23.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.24.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="线性相关和生成子空间"><a href="#线性相关和生成子空间" class="headerlink" title="线性相关和生成子空间"></a>线性相关和生成子空间</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.39.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.40.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还有一种看法是以列向量为新的参考系，看在参考系下要表示的向量的坐标。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.46.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不等式n≥m仅是方程对每一点都有解的必要条件。这不是一个充分条件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.31.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.39.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇异值行列式为0</span><br></pre></td></tr></table></figure></p><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>有时我们需要衡量一个向量的大小。在机器学习中,我们经常使用被称为<strong>范数</strong>（norm)的函数衡量向量大小。形式上,<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.41.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>范数定义如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.41.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>范数(包括<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.55.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>范数)是将向量映射到非负值的函数。直观上来说,向量<strong>x</strong>的范数衡量从原点到点<strong>x</strong>的距离。更严格地说,范数是满足下列性质的任意函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.44.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当p=2时,<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.51.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>范数被称为欧几里得范数( Euclidean norm)。它表示从原点出发到向量c确定的点的欧几里得距离。L2范数在机器学习中出现地十分频繁,经常简化表示为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.52.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>,略去了下标2。平方L2范数也经常用来衡量向量的大小,可以简单地通过点积<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.52.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.56.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.01.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>另外一个经常在机器学习中出现的范数是L∞范数,也被称为最大范数（max norm)这个范数表示向量中具有最大幅值的元素的绝对值:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.03.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">弗罗贝尼乌斯范数</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.05.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="特殊类型的矩阵和向量"><a href="#特殊类型的矩阵和向量" class="headerlink" title="特殊类型的矩阵和向量"></a>特殊类型的矩阵和向量</h2><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.07.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="对称"><a href="#对称" class="headerlink" title="对称"></a>对称</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.08.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.12.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%889.52.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h2><p><strong>特征分解</strong>( eigendecomposition)是使用最广的矩阵分解之一,即我们将矩阵分解成一组特征向量和特征值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.00.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.06.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.06.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.13.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.16.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">矩阵A乘以x表示，对向量x进行一次转换（旋转或拉伸)（是一种线性转换），而该转换的效果为常数c乘以向量x（即只进行拉伸）。</span><br></pre></td></tr></table></figure></p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>我们探讨了如何将矩阵分解成特征向量和特征值。还有另一种分解矩阵的方法,被称为<strong>奇异值分解</strong>( singular value decomposition,SVD),将矩阵分解为奇异向量( singular vector)和奇异值( singular value)。通过奇异值分解,我们会得到一些与特征分解相同类型的信息。然而,<strong>奇异值分解有更广泛的应用</strong>。<strong>每个实数矩阵都有一个奇异值分解,但不一定都有特征分解</strong>。例如,非方阵的矩阵没有特征分解,这时我们只能使用奇异值分解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.23.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.23.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Moore-Penrose伪逆"><a href="#Moore-Penrose伪逆" class="headerlink" title="Moore-Penrose伪逆"></a>Moore-Penrose伪逆</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.13.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.19.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="迹运算"><a href="#迹运算" class="headerlink" title="迹运算"></a>迹运算</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.21.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.26.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>另一个有用的事实是标量在迹运算后仍然是它自己:a=Tr(a)。</p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>行列式,记作det(A),是一个将方阵A映射到实数的函数。行列式等于矩阵特征值的乘积。行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或者缩了多少。如果行列式是0,那么空间至少沿着某一维完全收缩了,使其失去了所有的体积。如果行列式是1,那么这个转换保持空间体积不变。</p><h2 id="实例-主成分分析"><a href="#实例-主成分分析" class="headerlink" title="实例:主成分分析"></a>实例:主成分分析</h2><p><strong>主成分分析</strong>( principal components analysis,PCA)是一个简单的机器学习算法,可以通过基础的线性代数知识推导。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标量、向量、矩阵和张量&quot;&gt;&lt;a href=&quot;#标量、向量、矩阵和张量&quot; class=&quot;headerlink&quot; title=&quot;标量、向量、矩阵和张量&quot;&gt;&lt;/a&gt;标量、向量、矩阵和张量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标量&lt;/strong&gt;( scalar)
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》 1 引言</title>
    <link href="https://github.com/zdkswd/2018/07/29/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%201%20%E5%BC%95%E8%A8%80/"/>
    <id>https://github.com/zdkswd/2018/07/29/《深度学习》 1 引言/</id>
    <published>2018-07-29T10:55:12.000Z</published>
    <updated>2018-08-10T03:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>讽刺的是,抽象和形式化的任务对人类而言是最困难的脑力任务之一,但对计算机而言却属于最容易的。计算机早就能够打败人类最好的象棋选手,但直到最近计算机才在识别对象或语音任务中达到人类平均水平。一个人的日常生活需要关于世界的巨量知识。很多这方面的知识是主观的、直观的,因此很难通过形式化的方式表达清楚。计算机需要获取同样的知识才能表现出智能。人工智能的一个关键挑战就是如何将这些非形式化的知识传达给计算机。</p><p>些人工智能项目力求将关于世界的知识用形式化的语言进行硬编码(hard code)。计算机可以使用逻辑推理规则来自动地理解这些形式化语言中的声明。这就是众所周知的人工智能的知识库( knowledge base)方法。然而,这些项目最终都没有取得重大的成功。其中最著名的项目是 Cyc(Lenat and Guha,1989)Cyc包括一个推断引擎和一个使用CycL语言描述的声明数据库。这些声明是由人类监督者输入的。这是一个笨拙的过程。人们设法设计出足够复杂的形式化规则来精确地描述世界。例如,Cyc不能理解一个关于名为rred的人在早上剃须的故事( Linde,1992)。它的推理引擎检测到故事中的不一致性:它知道人体的构成不包含电气零件,但由于Fred正拿着一个电动剃须刀,它认为实体“正在剃须的Fred”(“ Fred While Shaving”)含有电气部件。因此它产生了这样的疑问—Fred在刮胡子的时候是否仍然是一个人。；）</p><p>依靠硬编码的知识体系面对的困难表明,<strong>AI系统需要具备自己获取知识的能力即从原始数据中提取模式的能力</strong>。这种能力被称为<strong>机器学习</strong>( machine learning)引入机器学习使计算机能够解决涉及现实世界知识的问题，并能作出看似主观的决策。比如,一个被称为<strong>逻辑回归</strong>( logistic regression)的简单机器学习算法可以决定是否建议剖腹产(Mor- Yosef et al,1990)。而同样是简单机器学习算法的<strong>朴素贝叶斯</strong>( naive Bayes)则可以区分垃圾电子邮件和合法电子邮件</p><p>这些简单的机器学习算法的性能在很大程度上依赖于给定数据的<strong>表示</strong>( repre-sentation)。</p><p>许多人工智能任务都可以通过以下方式解决:先提取一个合适的<strong>特征集</strong>,然后将这些特征提供给简单的机器学习算法。例如,对于通过声音鉴别说话者的任务来说,一个有用的特征是对其声道大小的估计。这个特征为判断说话者是男性、女性还是儿童提供了有力线索。</p><p>然而,对于许多任务来说,我们很难知道应该提取哪些特征。例如,假设我们想编写一个程序来检测照片中的车。我们知道,汽车有轮子,所以我们可能会想用车轮的存在与否作为特征。不幸的是,我们难以准确地根据像素值来描述车轮看上去像什么。虽然车轮具有简单的几何形状,但它的图像可能会因场景而异,如落在车轮上的阴影、太阳照亮的车轮的金属零件、汽车的挡泥板或者遮挡的车轮一部分的前景物体等等。</p><p>解决这个问题的途径之一是使用机器学习来发掘表示本身,而不仅仅把表示映射到输出。这种方法我们称之为<strong>表示学习</strong>( representation learning)。学习到的表<br>示往往比手动设计的表示表现得更好。并且它们只需最少的人工干预,就能让AI系统迅速适应新的任务。表示学习算法只需几分钟就可以为简单的任务发现一个很好的特征集,对于复杂任务则需要几小时到几个月。手动为一个复杂的任务设计特征需要耗费大量的人工时间和精力;甚至需要花费整个社群研究人员几十年的时间。</p><p>表示学习算法的典型例子是<strong>自编码器</strong>( autoencoder)。自编码器由一个<strong>编码器</strong>( encoder)函数和一个<strong>解码器</strong>( decoder)函数组合而成。编码器函数将输入数据转换为一种不同的表示,而解码器函数则将这个新的表示转换到原来的形式。我们期望当输人数据经过编码器和解码器之后尽可能多地保留信息,同时希望新的表示有各种好的特性,这也是自编码器的训练目标。为了实现不同的特性,我们可以设计不同形式的自编码器。</p><p>当设计特征或设计用于学习特征的算法时,我们的目标通常是分离出能解释观察数据的<strong>变差因素</strong>( factors of variation)。在此背景下,“因素”这个词仅指代影响的不同来源;因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反,它们可能是现实世界中观察不到的物体或者不可观测的力,但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因,它们还可能以概念的形式存在于人类的思维中。它们可以被看作数据的概念或者抽象,帮助我们了解这些数据的丰富多样性。当分析语音记录时,变差因素包括说话者的年龄、性别、他们的口音和他们正在说的词语。当分析汽车的图像时,变差因素包括汽车的位置、它的颜色、太阳的角度和亮度。</p><p>显然,从原始数据中提取如此高层次、抽象的特征是非常困难的。许多诸如说话口音这样的变差因素,只能通过对数据进行复杂的、接近人类水平的理解来辨识。这几乎与获得原问题的表示一样困难,因此,乍一看,表示学习似乎并不能帮助我们。</p><p><strong>深度学习</strong>( deep learning)通过其他较简单的表示来表达复杂表示,解决了表示学习中的核心问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%885.55.44.png" alt="屏幕快照 2018-07-29 下午5.55.44" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午5.55.44</div>            </figure></p><p>如何通过组合较简单的概念(例如转角和轮廓,它们转而由边线定义)来表示图像中人的概念。深度学习模型的典型例子是前馈深度网络或<strong>多层感知机</strong>( multilayer perceptron,MLP)。多层感知机仅仅是一个将一组输人值映射到输出值的数学函数该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</p><p>学习数据的正确表示的想法是解释深度学习的一个视角。<strong>另一个视角</strong>是深度促使计算机学习一个多步骤的计算机程序。每一层表示都可以被认为是并行执行另组指令之后计算机的存储器状态。更深的网络可以按顺序执行更多的指令。顺序指令提供了极大的能力,因为后面的指令可以参考早期指令的结果。从这个角度上看在某层激活函数里,并非所有信息都蕴涵着解释输入的变差因素。表示还存储着状态信息,用于帮助程序理解输人。这里的状态信息类似于传统计算机程序中的计数器或指针。它与具体的输人内容无关,但有助于模型组织其处理过程。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.03.19.png" alt="屏幕快照 2018-07-29 下午6.03.19" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.03.19</div>            </figure></p><p>由于不同的人选择不同的最小元素集来构建相应的图,因此就像计算机程序的长度不存在单一的正确值一样,架构的深度也不存在单一的正确值。另外,也不存在模型多么深才能被修饰为“深”的共识。但相比传统机器学习,深度学习研究的模型涉及更多学到功能或学到概念的组合,这点毋庸置疑。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.07.58.png" alt="屏幕快照 2018-07-29 下午6.07.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.07.58</div>            </figure></p><h2 id="本书面向的读者"><a href="#本书面向的读者" class="headerlink" title="本书面向的读者"></a>本书面向的读者</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.09.31.png" alt="屏幕快照 2018-07-29 下午6.09.31" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.09.31</div>            </figure><h2 id="深度学习的历史趋势"><a href="#深度学习的历史趋势" class="headerlink" title="深度学习的历史趋势"></a>深度学习的历史趋势</h2><h3 id="神经网络的众多名称和命运变迁"><a href="#神经网络的众多名称和命运变迁" class="headerlink" title="神经网络的众多名称和命运变迁"></a>神经网络的众多名称和命运变迁</h3><p>20世纪40年代到60年代深度学习的雏形出现在控制论( cybernetics)中。</p><p>尽管有些机器学习的神经网络有时被用来理解大脑功能( Hinton and shallice,1991),但它们一般都没有被设计成生物功能的真实模型。</p><p>现在,神经科学被视为深度学习研究的一个重要灵感来源,但它已不再是该领域的主要指导。</p><p>媒体报道经常强调深度学习与大脑的相似性。的确,深度学习研究者比其他器学习领域(如核方法或贝叶斯统计)的研究者更可能地引用大脑作为影响,但是大家不应该认为深度学习在尝试模拟大脑。</p><p>深度学习领域主要关注如何构建计算机系统,从而成功解决需要智能才能解决的任务,而计算神经科学领域主要关注构建大脑如何进行真实工作的比较精确的模型。</p><p>在20世纪80年代,神经网络研究的第二次浪潮在很大程度上是伴随一个被称为<strong>联结主义</strong>( connectionism)或并行分布处理( parallel distributed processing)潮流而出现的( Rumelhart et al,1986d; McClelland et al,1995)。</p><p><strong>联结主义</strong>的中心思想是,当网络将大量简单的计算单元连接在一起时可以实现智能行为。这种见解同样适用于生物神经系统中的神经元,因为它和计算模型中隐藏单元起着类似的作用。</p><p>其中一个概念是<strong>分布式表示</strong>( distributed representation)( Hinton et al,1986)其思想是:系统的每一个输入都应该由多个特征表示,并且每一个特征都应该参与到多个可能输人的表示。例如,假设我们有一个能够识别红色、绿色、或蓝色的汽车、卡车和鸟类的视觉系统,表示这些输人的其中一个方法是将九个可能的组合:红<br>卡车,红汽车,红鸟,绿卡车等等使用单独的神经元或隐藏单元激活。这需要九个不同的神经元,并且每个神经必须独立地学习颜色和对象身份的概念。改善这种情况的方法之一是使用<strong>分布式表示</strong>,即用三个神经元描述颜色,三个神经元描述对象身份。这仅仅需要6个神经元而不是9个,并且描述红色的神经元能够从汽车、卡车和鸟类的图像中学习红色,而不仅仅是从一个特定类别的图像中学习。分布式表示的概念是本书的<strong>核心</strong>。</p><p>联结主义潮流的另一个重要成就是<strong>反向传播</strong>在训练具有内部表示的深度神经网络中的成功使用以及反向传播算法的普及( Rumelhart et al,1986c; LeCun,1987)。这个算法虽然曾黯然失色不再流行,但截至写书之时,它仍是训练深度模型的主导方法。</p><p>在20世纪90年代,研究人员在使用神经网络进行序列建模的方面取得了重要进展。 Hochreiter(191b)和 Bengio et al.(1994a)指出了对长序列进行建模的些根本性数学难题, Hochreiter and schmidhuber(1997)引入<strong>长短期记忆</strong>( long short-term memory,LSTM)网络来解决这些难题。如今,LSTM在许多序列建模任务中广泛应用,包括 Google的许多自然语言处理任务。</p><p>神经网络研究的第三次浪潮始于2006年的突破。Geoffrey Hinton表明名为深度信念网络的神经网络可以使用一种称为贪婪逐层预训练的策略来有效地训练。</p><p>神经网络研究的这一次浪潮普及了“深度学习”这一术语的使用,强调研究者现在有能力训练以前不可能训练的比较深的神经网络,并着力于深度的理论重要。此时,深度神经网络已经优于与之竞争的基于其他机器学习技术以及手工设计功能的AI系统。</p><p>尽管深度学习的研究重点在这一段时间内发生了巨大变化。第三次浪潮已开始着眼于新的无监督学习技术和深度模型在小数据集的泛化能力,但目前更多的兴趣点仍是比较传统的监督学习算法和深度模型充分利用大型标注数据集的能力。</p><h3 id="与日俱增的数据量"><a href="#与日俱增的数据量" class="headerlink" title="与日俱增的数据量"></a>与日俱增的数据量</h3><p>“大数据”时代使机器学习更加容易。截至2016年,一个粗略的经验法则是,监督深度学习算法在每类给定约5000个标注样本情况下一般将达到可以接受的性能,当至少有1000万个标注样本的数据集用于训练时,它将达到或超过人类表现。此外,在更小的数据集上获得成功是一个重要的研究领域,为此我们应特别侧重于如何通过无监督或半监督学习充分利用大量的未标注样本。</p><h3 id="与日俱增的模型规模"><a href="#与日俱增的模型规模" class="headerlink" title="与日俱增的模型规模"></a>与日俱增的模型规模</h3><p>20世纪80年代,神经网络只能取得相对较小的成功,而现在神经网络非常成功的另一个重要原因是我们现在拥有的计算资源可以运行更大的模型。联结主义的主要见解之一是,当动物的许多神经元一起工作时会变得聪明。单独神经元或小集合的神经元不是特别有用。</p><p>就神经元的总数目而言,直到最近神经网络都是惊人的小。自从隐藏单元引人以来,人工神经网络的规模大约每2.4年扩大一倍。这种增长是由更大内存、更快的计算机和更大的可用数据集驱动的。更大的网络能够在更复杂的任务中实现更高的精度。这种趋势看起来将持续数十年。除非有能力迅速扩展的新技术,否则至少要到21世纪50年代,人工神经网络将才能具备与人脑相同数量级的神经元。生物神经元表示的功能可能比目前的人工神经元所表示的更复杂。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.47.54.png" alt="屏幕快照 2018-07-29 下午6.47.54" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.47.54</div>            </figure><br>现在看来,其神经元比一个水蛭还少的神经网络不能解决复杂的人工智能问题是不足为奇的。即使现在的网络,从计算系统角度来看它可能相当大的,但实际上它比相对原始的脊椎动物如青蛙的神经系统还要小。</p><p>由于更快的CPU、通用GPU的出现更快的网络连接和更好的分布式计算的软件基础设施,模型规模随着时间的推移不断增加是深度学习历史中最重要的趋势之一。人们普遍预计这种趋势将很好地持续到未来。</p><h3 id="与日俱增的精度、复杂度和对现实世界的冲击"><a href="#与日俱增的精度、复杂度和对现实世界的冲击" class="headerlink" title="与日俱增的精度、复杂度和对现实世界的冲击"></a>与日俱增的精度、复杂度和对现实世界的冲击</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.51.21.png" alt="屏幕快照 2018-07-29 下午6.51.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.51.21</div>            </figure><p>深度学习的另一个最大的成就是其在强化学习( reinforcement learning)领域的扩展。在强化学习中,一个自主的智能体必须在没有人类操作者指导的情况下,通过试错来学习执行任务。 DeepMind表明,基于深度学习的强化学习系统能够学会玩并在多种任务中可与人类匹敌Mnih et al.,2015)。深度学习也显著改善了机器人强化学习的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;讽刺的是,抽象和形式化的任务对人类而言是最困难的脑力任务之一,但对计算机而言却属于最容易的。计算机早就能够打败人类最好的象棋选手,但直到最近
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 14 函数式编程</title>
    <link href="https://github.com/zdkswd/2018/07/26/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2014%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/07/26/松本行弘的程序世界 14 函数式编程/</id>
    <published>2018-07-26T13:00:32.000Z</published>
    <updated>2018-07-27T03:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-14-函数式编程"><a href="#松本行弘的程序世界-14-函数式编程" class="headerlink" title="松本行弘的程序世界 14 函数式编程"></a>松本行弘的程序世界 14 函数式编程</h1><h2 id="新范型–函数式编程"><a href="#新范型–函数式编程" class="headerlink" title="新范型–函数式编程"></a>新范型–函数式编程</h2><p>函数式编程是全部使用函数来编写程序代码的编程方法。这是可以与一般的结构化编程及面向对象编程相提并论的编程方法。</p><p>以函数为中心的函数式编程具有特征：</p><ol><li>函数本身也作为数据来处理（第一级函数）</li><li>以函数为参数的高阶函数</li><li>参数相同即可保证结果相同的引用透明性。</li><li>为实现引用透明性，禁止产生副作用的处理。</li></ol><p>函数式编程的最大优点在于，程序可以按照数学的形式以及声明的形式来编写。</p><p>结构式编程是在改变变量值的同时进行计算，所以一直注意着，这个变量的值是什么，并据此来预想计算过程。</p><p>采用函数式编程方式并不改变变量的值。并不包含状态或者动作等信息，仅仅是对想要做什么加以描述，这样不容易出错。</p><p>这种不是描述动作而是描述性质的编程方式称为<strong>声明式编程</strong>。声明式描述是函数式编程的一大优点。</p><h3 id="具有多种函数式性质的Lisp"><a href="#具有多种函数式性质的Lisp" class="headerlink" title="具有多种函数式性质的Lisp"></a>具有多种函数式性质的Lisp</h3><p>之前，Lisp被认为是函数式编程的代表。Lisp具备函数式语言的很多性质。</p><p>Lisp最大的特征是S式记法。S式是括号很多的Lisp的记法。S式无与伦比的优点是它彻底的统一性。对Lisp而言，不管什么都可以同一成单一形式。</p><p>第二个重要之处在于链这种数据结构。Lisp语言本名是List Processor（链表处理器），从侧面说明了链的重要性。链是一种构成树结构数据的通用数据结构，构成数据结构的节点分别包含两个引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8A%E5%8D%8810.02.29.png" alt="屏幕快照 2018-07-25 上午10.02.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 上午10.02.29</div>            </figure></p><p>总之，Lisp具备了函数编程语言的基本特征。但是Lisp不直接支持多数纯粹的函数式编程语言所拥有的副作用如回避以及延迟计算等功能。对变量的赋值没有任何限制。且编程风格为很多很多括号。比较难适应。</p><p>近年来，由于像Haskell这样的彻底的函数式编程语言的兴起，Lisp作为函数式编程语言在人们心中的印象越来越淡薄。</p><h3 id="彻底的函数式编程语言Haskell"><a href="#彻底的函数式编程语言Haskell" class="headerlink" title="彻底的函数式编程语言Haskell"></a>彻底的函数式编程语言Haskell</h3><p>Haskell可以说是纯粹的函数式编程语言。<br>Haskell语言特征：</p><ol><li>没有副作用</li><li>高阶函数</li><li>函数部分应用</li><li>延迟计算(非正式)</li><li>静态多态类型系统</li><li>型推论</li><li>链内包表达式</li><li>用对齐来表示块</li></ol><h4 id="没有副作用"><a href="#没有副作用" class="headerlink" title="没有副作用"></a>没有副作用</h4><p>Haskell程序基本没有副作用，不但不能改变变量的值，就连链的元素也是不能改变的。因此，只要参数不变，函数的返回值也就总是一样的。相同输入总能返回相同结果，这种可重复性对测试程序非常有利。这种重复性也称为引用透明性。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>Haskell高阶函数把函数本身作为数据来处理。比如，Haskell中没有循环控制结构，循环都是用递归调用或者高阶函数来实现的。</p><h4 id="延迟计算：不必要的处理就不做"><a href="#延迟计算：不必要的处理就不做" class="headerlink" title="延迟计算：不必要的处理就不做"></a>延迟计算：不必要的处理就不做</h4><p>必要时才进行处理。</p><h3 id="灵活的“静态多态性”类型系统"><a href="#灵活的“静态多态性”类型系统" class="headerlink" title="灵活的“静态多态性”类型系统"></a>灵活的“静态多态性”类型系统</h3><p>与没有类型的Ruby不同，Haskell是在编译时确定所有变量类型的静态类型语言。但实际上Haskell程序基本上没有必要给出变量的类型。这是因为聪明的Haskell语言处理系统会推测变量的类型。</p><p>Haskell利用多态性的类型系统和系统推测，在维持着接近于duck typing灵活性的同时，也使编译时的完全类型检查成为可能。</p><h3 id="近代函数式语言之父OCaml"><a href="#近代函数式语言之父OCaml" class="headerlink" title="近代函数式语言之父OCaml"></a>近代函数式语言之父OCaml</h3><p>OCaml也是具有代表性的函数式编程语言之一。它比Haskell还古老，说它是近代函数式语言之父也毫不为过。</p><p>与Haskell相比，OCaml具有如下不同：</p><ol><li>没有副作用</li><li>没有延迟计算</li><li>具有强力的模块系统</li></ol><p>虽然不像Haskell那样自然地做到延迟计算，但换来的好处是，程序内容与实际处理关系接近，使人容易理解程序的执行过程。</p><h3 id="强于并行计算的Erlang"><a href="#强于并行计算的Erlang" class="headerlink" title="强于并行计算的Erlang"></a>强于并行计算的Erlang</h3><p>作为函数式编程语言，二郎的特点</p><ol><li>受Prolog影响</li><li>专用于并行计算</li></ol><h3 id="用Ruby进行函数式编程"><a href="#用Ruby进行函数式编程" class="headerlink" title="用Ruby进行函数式编程"></a>用Ruby进行函数式编程</h3><p>Ruby中有几个能进行函数式编程的工具</p><h4 id="Proc对象（lambda）"><a href="#Proc对象（lambda）" class="headerlink" title="Proc对象（lambda）"></a>Proc对象（lambda）</h4><p>Ruby中唯一与函数直接对应的是Proc对象。</p><h4 id="程序块"><a href="#程序块" class="headerlink" title="程序块"></a>程序块</h4><p>以程序块为参数的方法等价于函数型语言的高阶函数。灵活运用以程序块为参数的方法，就可以实现函数式编程的高阶函数的技巧。</p><h4 id="枚举器"><a href="#枚举器" class="headerlink" title="枚举器"></a>枚举器</h4><p>Ruby中没有延迟计算，但用枚举器对数组和列表进行循环，可以实现类似于延迟计算的处理。</p><h4 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h4><p>所谓避免副作用，就是对生成的对象，尽量少去改变其状态。</p><h3 id="用枚举器来实现延迟计算"><a href="#用枚举器来实现延迟计算" class="headerlink" title="用枚举器来实现延迟计算"></a>用枚举器来实现延迟计算</h3><p>从Ruby1.8.7开始，很多以块为参数的方法在参数不是块的时候，就会返回枚举器。</p><p>枚举器就是把循环用对象来表达的一种方法。</p><p>使用这样的枚举器可以实现与Haskell类似的延迟计算。</p><h2 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h2><h3 id="在商业中利用Ruby"><a href="#在商业中利用Ruby" class="headerlink" title="在商业中利用Ruby"></a>在商业中利用Ruby</h3><h3 id="使用Ruby自动生成代码"><a href="#使用Ruby自动生成代码" class="headerlink" title="使用Ruby自动生成代码"></a>使用Ruby自动生成代码</h3><p>编程中的代码重复是非常恶劣的。发现了代码重复，就应该考虑在合理的代价范围内避免代码重复的方法。</p><h3 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h3><p>为了在构建程序的时候，自动生成省略部分，我们只需要定义make的规则、在构建程序的过程中调用代码生成工具。</p><h3 id="代码生成的应用"><a href="#代码生成的应用" class="headerlink" title="代码生成的应用"></a>代码生成的应用</h3><h4 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h4><p>从数据结构定义自动生成数据库的访问例程（包括SQL）。</p><h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><p>大多数依赖于数据库的Web应用程序，常常需要对表的各项目进行增删改查操作。</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>代码生成对单元测试也很有效果。只要有数据和测试条件，就可以开始单元测试。</p><h4 id="客户界面"><a href="#客户界面" class="headerlink" title="客户界面"></a>客户界面</h4><h4 id="文档化"><a href="#文档化" class="headerlink" title="文档化"></a>文档化</h4><p>代码生成也适合与文档化。对于自动生成的类，由人工记入档案是纯粹的浪费。按照JavaDoc的形式，在生成代码的程序里写好相应的文档，应该是个聪明的办法。</p><h3 id="代码生成的效果"><a href="#代码生成的效果" class="headerlink" title="代码生成的效果"></a>代码生成的效果</h3><p>代码生成有如下好处：</p><ol><li>改进质量。</li><li>确保一致性</li><li>集中知识。</li><li>增加用于设计的时间。</li><li>独立于程序实现的设计判断</li></ol><h3 id="编写代码生成器"><a href="#编写代码生成器" class="headerlink" title="编写代码生成器"></a>编写代码生成器</h3><p>对代码生成最有帮助的工具要数eRuby。Ruby本身也拥有优越的文本处理功能。使用eRuby以比较自然地形式编写模板的同时，还可以灵活运用Ruby的处理能力。</p><h3 id="也可以使用XML"><a href="#也可以使用XML" class="headerlink" title="也可以使用XML"></a>也可以使用XML</h3><p>幸运的是，Ruby拥有解释XML的标准库REXML。REXML提供操作XML的功能。</p><h3 id="在EJB中使用代码生成"><a href="#在EJB中使用代码生成" class="headerlink" title="在EJB中使用代码生成"></a>在EJB中使用代码生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分</span><br></pre></td></tr></table></figure><h2 id="内存管理与垃圾收集"><a href="#内存管理与垃圾收集" class="headerlink" title="内存管理与垃圾收集"></a>内存管理与垃圾收集</h2><p>垃圾收集（GC）是一种管理程序使用的内存区域的方法。使用具有垃圾收集功能的编程语言或处理程序的话，程序中不需要编写内存管理的代码，即不用编写代码来释放使用过的内存区域。</p><h3 id="内存管理的困难"><a href="#内存管理的困难" class="headerlink" title="内存管理的困难"></a>内存管理的困难</h3><p>在垃圾收集普及之前，内存区域的取得和释放完全是程序员的责任。随着程序的执行，会使用一些内存区域作为作业区。为记忆对象、字符串和数组等个别信息，都需要使用内存区域。没有垃圾收集的语言一般都提供有API，利用这些API，可以再需要时向操作系统申请并取得内存，使用过之后再把内存区域返回给操作系统。</p><h4 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h4><p>如果把还在使用中的内存区域错误调用free予以释放的话，就会发生悬挂指针的现象。程序再去访问该区域时就可能会出错。在引用该区域内容时，多数场合会读取到被破坏的数据，或是在更新该领域数据的时候，会置换成预想之外的数据。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>另一方面，如果忘记了把申请的内存区域返还给操作系统的话，就会发生内存泄漏。这时候因为使用过的内存区域越来越多，程序占有的内存就会逐渐增加。特别是长时间启动，连续提供服务的常驻内存型程序，容易发生内存泄漏，导致系统停止等重大问题。</p><h4 id="二重释放"><a href="#二重释放" class="headerlink" title="二重释放"></a>二重释放</h4><p>对已经释放过的内存区域再次调用free的情况也时有发生。这称为二重释放。这会带来malloc和free内部使用的数据区域不一致的问题。</p><p>内存泄漏问题只有在内存占用量超过预想的时候才会显露，而悬挂指针问题不会发生在释放使用内存的时刻，而是要到访问释放过的内存区域才会出现。程序员往往会在看起来完全没有问题的地方突然遭遇意想不到的错误。</p><h3 id="垃圾收集亮相之前"><a href="#垃圾收集亮相之前" class="headerlink" title="垃圾收集亮相之前"></a>垃圾收集亮相之前</h3><p>应该管理的内存区域越来越多，内存释放时刻的管理也就越来越难，这是产生内存问题的原因。</p><p>关于垃圾收集，有以下这些先入为主的观念。</p><h4 id="垃圾收集慢"><a href="#垃圾收集慢" class="headerlink" title="垃圾收集慢"></a>垃圾收集慢</h4><p>有研究表明，在某些条件下，垃圾收集比手工管理内存还更快。</p><h4 id="垃圾收集可靠性低"><a href="#垃圾收集可靠性低" class="headerlink" title="垃圾收集可靠性低"></a>垃圾收集可靠性低</h4><p>在Java之后诞生的编程语言，不管是否受到Lisp的影响，几乎都毫无例外的拥有垃圾收集的功能。垃圾收集从诞生之日起，经历了40多年的发展，终于成为大家认可的一项特性了。</p><h3 id="评价垃圾收集的两个指标"><a href="#评价垃圾收集的两个指标" class="headerlink" title="评价垃圾收集的两个指标"></a>评价垃圾收集的两个指标</h3><p>假如存在无线内存的计算机的话，就没有必要进行垃圾收集。</p><p>垃圾收集的性能可以由两个指标来测定：</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量是垃圾收集处理在程序全部执行时间中所占的比例。比例越小越好，比例大的话，程序整体的性能就会低下。</p><h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>暂停时间是一次垃圾收集处理所中断的时间。暂停时间过长的话，处理的中断时间就会变得很显眼，程序反应就会变慢。</p><p>垃圾收集每次所花的时间会因垃圾收集执行时对象的总数而变化，暂停时间有两种，一是把垃圾收集时间求平均值得到平均暂停时间，二是程序执行中最长的垃圾收集时间所代表的最大暂停时间。</p><p>那些实时性要求高的程序，就很重视最大暂停时间。像批处理这样非对话的处理强调吞吐量要高，而重视反应速度的嵌入式或者GUI程序就强调暂停时间要短。</p><p>Java运行环境中实现由多种垃圾收集算法，可以根据程序的性质来切换合适的垃圾收集算法。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>基本上是以下4类，还有几种变形：</p><ol><li>引用计数方式</li><li>标记和扫除方式</li><li>标记和紧缩方式</li><li>复制方式</li></ol><h3 id="引用计数方式"><a href="#引用计数方式" class="headerlink" title="引用计数方式"></a>引用计数方式</h3><p>引用计数方式在垃圾收集算法中具有最简单最容易实现的特征。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.25.46.png" alt="屏幕快照 2018-07-25 下午5.25.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.25.46</div>            </figure><br>引用计数器最大的优点就是容易实现。这种方式得到广泛的使用。暂停时间短也是它的优点。</p><p>最大的缺点是不能释放有循环引用关系的对象群。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.28.21.png" alt="屏幕快照 2018-07-25 下午5.28.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.28.21</div>            </figure><br>与生俱来的缺点，因为在引用增减的时候有必要同时正确维护引用计数器的增减，忘了这一点就会带来悬挂指针或内存泄露问题。</p><p>最后一个缺点是，引用计数器的管理与并行处理不相容。如果多个进程同时增减一个引用计数器的话，就会发生引用计数器的值不一致的现象。为避免这一个问题，需要在操作引用计数器的时候进行排他处理，但在频繁发生引用操作的同时进行排他处理的话，会带来巨大的时间开销。</p><p>总之，这种原理简单实现也简单的引用计数器方式，缺点很多，最近已经不怎么用了。</p><p>采用引用计数器方式的主要语言处理系统有Perl和Python。为了回避循环引用的问题，它们都组合了其他垃圾收集方式。这些语言基本上以引用计数器方式来进行垃圾收集，只有在极个别的情况下，才通过别的垃圾收集算法来处理引用计数器不能回收的对象。</p><h3 id="标记和扫除方式"><a href="#标记和扫除方式" class="headerlink" title="标记和扫除方式"></a>标记和扫除方式</h3><p>标记和扫除方式也是古老的垃圾收集算法。<br>标记和扫除方式从有可能成为对象引用元的变数（根）开始，给被引用的对象加上标记，表明其“活着”。然后再给标记对象所引用的对象还有其再引用的对象，也都递归地加上引用标记。</p><p>这样从根开始不管是直接还是间接，只要把所有引用的对象都加上标记的话，那么没有标记的对象就是没有被引用的，也就是“已经死了”。然后在所有的对象中找出没有标记的对象，把它们作为垃圾扫除出去。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.50.20.png" alt="屏幕快照 2018-07-25 下午5.50.20" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.50.20</div>            </figure><br>此法虽然古老，但是非常优秀，现在也还被多种处理系统所采用。</p><p>但是当对象数目较多时，性能容易恶化。在标记的时候要访问生存的所有对象，在回收时按顺序访问所有的对象，找出”已经死了“的对象。在寻找垃圾和扫除过程中，基本不能进行其他处理，垃圾收集时间长的话，会影响到本来的处理工作。</p><h3 id="标记和紧缩方式"><a href="#标记和紧缩方式" class="headerlink" title="标记和紧缩方式"></a>标记和紧缩方式</h3><p>标记和紧缩方式是标记和扫除的变形。标记处理是一样的，后阶段有所不同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.01.29.png" alt="屏幕快照 2018-07-26 下午12.01.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.01.29</div>            </figure><br>标记和紧缩方式最大的特征也是他的优越之处，是把空间集中起来（紧缩）。紧缩的结果是把没有释放而活下来的对象都集中到一个地方。这样，内存访问就集中到一个局部区域，这可以提高缓存功能的效率。对象的分配也只是把指针移动一下就完成了，降低了对象分配的开销。</p><p>缺点是，把生存着的对象全部复制的紧缩开销，容易比标记和扫除方式中执行的开销还要大。因为对象被移动位置了。</p><p>一部分Lisp处理系统采用的是标记和紧缩方式，Java处理系统（作为多个垃圾收集算法中的一个）也有标记和紧缩方式。</p><h3 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h3><p>像标记和扫除方式、标记和紧缩方式这样“标记之后释放死了的对象”的算法，标记时间与活着的对象数成比例，扫除时间与总对象数成比例。所以在分配有很多的对象，其中几乎所有对象都要被释放的场合，扫除的开销会变高，在性能方面很不利。</p><p>复制方式与标记和扫除方式一样，从根开始扫描所有的对象，但他不仅仅是加标记，还执行复制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.11.58.png" alt="屏幕快照 2018-07-26 下午12.11.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.11.58</div>            </figure><br>复制方式把内存空间分成旧空间和新空间两大块，总是在旧空间中分配对象。旧空间爆满时，从根开始扫描对象，把对象复制到新空间。这时，复制后的引用也要随之更新。</p><p>递归的执行从旧空间到新空间的复制，结束时就会把所有活着的对象都移动到新空间。不再被引用的对象都遗留到旧空间，旧空间就可以整个弃之不用，就避免了扫除的开销，从此再把新空间作为旧空间再进行同样的处理。</p><p>最大的优点是，垃圾回收的开销只和活着的对象数成比例。对象分配的开销也低。还有“局部性”的优点。复制方式按顺序把引用的对象复制到新空间，关系近的对象会被分配到相近的内存空间，称为局部性。关系近的对象被访问的可能性也高。计算机因为有缓存，内存空间相接近的访问可能具有较好的性能，局部性高的程序具有提高性能的优势。</p><p>缺点：复制方式要复制所有活着的对象，几乎具有和标记和紧缩方式一样的缺点。</p><h3 id="多种多样的垃圾收集算法"><a href="#多种多样的垃圾收集算法" class="headerlink" title="多种多样的垃圾收集算法"></a>多种多样的垃圾收集算法</h3><p>把基本算法组合起来的技术，几个具有代表性的：</p><ol><li>分代垃圾收集</li><li>保守垃圾收集</li><li>增量垃圾收集</li><li>并行垃圾收集</li><li>位图标志</li></ol><p>这些技术的组合也是有可能的。</p><h3 id="分代垃圾收集"><a href="#分代垃圾收集" class="headerlink" title="分代垃圾收集"></a>分代垃圾收集</h3><p>分代垃圾收集的基本思想是利用程序和对象的性质。一般程序都有这样一个性质，几乎所有的对象都在比较短的时间里变成垃圾，存活时间超过一定程度的对象总是拥有更长的寿命。</p><p>因为这一性质，就可以重点对分配之后的年轻对象进行扫描，这样就不用扫描全部对象就可能高效率地回收垃圾。</p><p>分代垃圾收集把对象的内存空间分成两个，新代和旧代，也有分成3个的。</p><p>只扫描新代区域的回收称为轻垃圾收集，但没有检查旧代区域对新代的引用，被引用的对象可能误判死亡，就会带来内存问题。</p><p>解决这一问题的方法是，监视对象的更新。在旧代区域引用新代区域的同时，就把这一引用的记录例程以及对象的更新场所全都记录下来，这个检查例程叫做<strong>写屏障</strong>，记录旧代区域对新代区域的引用叫<strong>记录集</strong>。</p><p>以所有区域对象的垃圾收集称为全垃圾收集或重垃圾收集。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.33.58.png" alt="屏幕快照 2018-07-26 下午12.33.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.33.58</div>            </figure><br>分代垃圾收集减少了扫描对象的个数，有缩短平均暂停时间的效果。但是，因为要执行全垃圾收集，最大暂停时间不会得到明显的改善。</p><p>最近几乎所有的Java都实现有分代垃圾收集。另外，函数型语言OCaml也采用了分代垃圾收集。</p><h3 id="保守垃圾收集"><a href="#保守垃圾收集" class="headerlink" title="保守垃圾收集"></a>保守垃圾收集</h3><p>像C这种本来没有垃圾收集的语言，编译之后没有保留区别整数和指针的信息，因为CPU对两者不加区分，所以也就没这个必要。通常，垃圾收集的实现需要明确区分引用（指针），而C和C++没有这样的功能，在这样的环境下实现垃圾收集的技巧之一称为保守垃圾收集。</p><p>其基本思想就是如果碰巧有整数的值与引用相同的话，该对象就有可能被引用，就当它是活着的。保守就是倾向于安全的意思。与此相对，能够明确区别所用的环境下的垃圾收集称为精确垃圾收集。</p><p>因为倾向于安全一面，保守垃圾收集在C或者C++这样没有垃圾收集功能的语言中也可以得到实现，这是它的优点。但是，本来应该回收的对象却在意料之外保留下来不能回收，这是它的缺点。以及，它不能喝复制垃圾收集这样需要移动的垃圾收集算法组合使用。</p><p><strong>Ruby采用的是保守垃圾收集。</strong>局部变量可以按照通常语言的访问路径来处理，系统堆栈部分是当做指针数组来扫描的。Ruby大部分是用C编写的，因为有了保守垃圾收集，C库的实现变得非常简单。实际上，Python和Perl因为采用的是引用计数器，C例程内部的引用数管理非常复杂，偶然忘记增减就会发生内存问题。但是，用C编写Ruby扩展库时，基本上不用操心内存管理，好处十分明显。</p><p>Boehm GC为C和C++增加了垃圾收集功能。Boehm GC也同时实现了分代垃圾收集。Boehm GC不仅用于C和C++，在Scheme处理系统Gauche等多种语言处理系统中，也作为垃圾收集功能得到广泛的应用。</p><h3 id="增量垃圾收集"><a href="#增量垃圾收集" class="headerlink" title="增量垃圾收集"></a>增量垃圾收集</h3><p>在实时性要求高的程序中，垃圾收集带来的中断时间必须是可预测的。为保证实时性，不需要等垃圾收集完全执行结束，而是要把垃圾收集细分正许多细小的片段，每次执行一点，这叫增量垃圾收集。</p><p>增量垃圾收集在垃圾收集处理过程中程序也在同时执行，引用有可能会改变。结果是垃圾收集的一致性不能得到保证。增量垃圾收集为避免这样的问题，采用了与保守垃圾收集相同的写屏蔽操作。</p><p>嵌入式处理系统采用的是增量垃圾收集。有名的Io和Lua都实现了增量垃圾收集。</p><h3 id="并行垃圾收集"><a href="#并行垃圾收集" class="headerlink" title="并行垃圾收集"></a>并行垃圾收集</h3><p>在多核环境下，灵活运用线程可以最大限度地发挥多个CPU的能力。并行垃圾收集就是要最大限度利用多个CPU的能力。</p><p>并行垃圾收集基本原理与增量垃圾收集大致是一样的，都是利用写屏蔽来维护当前状态的信息。有的并行垃圾收集的实现生成垃圾收集专用线程，把垃圾收集设计成总是与普通处理并行执行。</p><h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><p>以Linux为首的UNIX系列操作系统在使用fork系统调用复制过程时，内存空间并不进行复制而是直接共享。通过写时复制来提高性能。</p><p>垃圾收集与这一功能兼容性不好，给引用对象那个设置标记的方式会因设置标记而复制包含该对象的内存页。复制方式也同样会产生大量写内存操作。</p><p>位图标记是在利用标记的垃圾收集中消减操作系统内存页复制的方法。它不在对象里设置被引用的标记，而是利用外部位图区域（管理用内存区域）来保存引用标记。</p><p>只有标记用的位图部分会发生内存页复制，从而避免了复制没有实际更新的对象所在的内存页。</p><p>Ruby的垃圾收集也有了实现位图标记的补丁。</p><h2 id="用C语言来扩展Ruby"><a href="#用C语言来扩展Ruby" class="headerlink" title="用C语言来扩展Ruby"></a>用C语言来扩展Ruby</h2><p><strong>Ruby是解释型语言，即Ruby程序是由Ruby解释器的程序来解释执行的。</strong></p><p>提起解释器，大家会觉得它是逐行读取程序并执行，实际上Ruby解释器是把要执行的程序全部读进来，首先变换成更有效率的内部表现形式。解释器对其内部表现加以分析来执行程序。</p><p>解释型语言的特点，马上可以执行，开发周期非常快。至于C、C++、Java这样的编译语言，首先要把程序变换成计算机可以直接执行的形式再从头执行。</p><p>在执行程序过程中，编译型语言不再需要对原来程序进行解释和变换，速度很快。但是开发周期较长。</p><h3 id="开发与执行速度的取舍"><a href="#开发与执行速度的取舍" class="headerlink" title="开发与执行速度的取舍"></a>开发与执行速度的取舍</h3><p>这两种类型的语言要做取舍。Ruby的设计方针是开发效率优于执行效率，选择解释型的实现也是必然。</p><p>Ruby解释器是由C语言开发的，采用C语言开发理由：</p><ol><li>C语言作者拿手</li><li>C语言运行系统调用，速度高</li><li>用面向对象语言来实现别的面向对象语言的话，容易混淆对象的概念。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%885.36.05.png" alt="屏幕快照 2018-07-26 下午5.36.05" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午5.36.05</div>            </figure><p><strong>引擎</strong>是解释内部表现，并实际上执行程序的部分。1.9版本的引擎解释的字节码，可以说是近似于虚拟计算机的机器语言。所以1.9版本的引擎也可以成为VM。</p><p><strong>引擎</strong>在解释内部表现是，需要其他组件的帮助。内存和对象的管理，变量访问和方法调用的实现等，都要依靠底层称为<strong>运行库</strong>的组件来完成。<strong>运行库</strong>提供底层强有力的支持，是程序执行时不可或缺的部分。</p><p>Ruby利用的各种类是<strong>类库</strong>提供的。Ruby的这一部分也是用C编写的。像Ruby这样的解释型语言，因为是经过C编写的引擎来间接执行程序，与一般的编译语言相比，执行速度明显慢得多（100 倍或者 1000 倍）。但是，实际上程序的执行时间大部分都花在 C 編写的类库方法内部，因此在执行速度上很少会产生那么巨大的差距。</p><h3 id="扩展库"><a href="#扩展库" class="headerlink" title="扩展库"></a>扩展库</h3><p>扩展库是指利用Ruby运行库的API,用C定义的类库。Ruby的API使用C几乎可以实现Ruby所有的功能。使用这些API可以很简单地实现如下的功能：</p><ol><li>定义类</li><li>定义方法</li><li>访问实例变量</li><li>调用方法</li><li>调用块</li></ol><p>特意花时间用C来实现扩展库的理由主要有以下两点。</p><ol><li>想要比Ruby执行速度快</li><li>想使用C可以利用的库。</li></ol><p>前面已经说过,Ruby是解释型语言,它的执行速度不如像C这样的编译型语言。如果是绝对需要改善速度的程序,用C扩展库来实现其中成为瓶颈的部分的话,有可能显著改善程序的<br>执行速度。</p><p>UNX系列操作系统的大多数功能都是通过C可以访问的库来提供的。Ruby要想利用这些功能的话,就需要有一种从Ruby调用C的API的方法,这最简单的方法就是利用扩展库。</p><h3 id="扩展库的编译"><a href="#扩展库的编译" class="headerlink" title="扩展库的编译"></a>扩展库的编译</h3><p>首先按照以上的顺序编写源代码。若C程序的文件名后<br>约定为c的话,后续步骤会自动识别出来C程序文件。</p><p>为生成编译所需要的文件,需要准备必要的<br>Ruby文件。这个文件通常命名为 extconf.rb<br>minitab的 extconf.rb的内容如图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%887.09.31.png" alt="屏幕快照 2018-07-26 下午7.09.31" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午7.09.31</div>            </figure></p><p>extons,xb是由以下几个部分构成的:</p><ol><li>调用 require’mkmf’;   </li><li>用have_1 ibrary和 hava header检<br>查必要的库和头文件是否存在；  </li><li>用 create makefile来生成必要的<br>Makefile. create makefile的参数<br>是库的名字。</li></ol><p>照图14-34执行 extconfrb,就可以生成<br>Makefi1e。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%887.13.48.png" alt="屏幕快照 2018-07-26 下午7.13.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午7.13.48</div>            </figure></p><p>用make命令来编译,尔后可以用 make insta11命令来安装编译后的库。</p><h3 id="扩展库之外的工具"><a href="#扩展库之外的工具" class="headerlink" title="扩展库之外的工具"></a>扩展库之外的工具</h3><h4 id="RubyInline"><a href="#RubyInline" class="headerlink" title="RubyInline"></a>RubyInline</h4><p>Rubylnline可以在Ruby的源代码中直接嵌入C的程序。不用每次准备 exton,rb文件,也不需要明确的编译步骤,非常便利,但它也有不少约束,比如在执行环境中需要有编译器,与外部库的链接也有些麻烦等。</p><h4 id="dl"><a href="#dl" class="headerlink" title="dl"></a>dl</h4><p>有了d1,仅用Ruby也能实现与 minitab同样动作的库。把图1435的程序保存成 inial,rb文件,没有扩展库也可以使用 minitab。al的优点是在没有安装编译器和头文件的环境下也可以运行。</p><h4 id="ffi"><a href="#ffi" class="headerlink" title="ffi"></a>ffi</h4><p>关于Ruby的扩展,ffi库受到关注。ffi是 foreign function interface的缩写,它也提供在Ruby水平上的与外部函数的直接接口,这个目的与d1几乎是一样的。ffi可以从 Ruby Gems得到。ffi的特征是使用lb更有效率地调用外部函数,Ruby、 Rubinius和 GRubby都可以使用<br>同样的API。</p><h2 id="为什么要开源"><a href="#为什么要开源" class="headerlink" title="为什么要开源"></a>为什么要开源</h2><h3 id="自由软件的思想"><a href="#自由软件的思想" class="headerlink" title="自由软件的思想"></a>自由软件的思想</h3><p>为保证执行的自由,必须能够将软件免费拿到手。出于学习和研究的目的,也必须能够自由地得到源代码。还有,为了修改程序错误,或者为适合自己的目的而进行改造,那就不单单<br>是阅读源代码,还要允许改变源代码。把自己认为好的软件推荐给别人,或者把自己进行的修改或改善与他人共享的话,就需要有再发布的自由。</p><h3 id="自由软件的历史"><a href="#自由软件的历史" class="headerlink" title="自由软件的历史"></a>自由软件的历史</h3><p>曾几何时,在计算机的黎明期,软件完全是硬件的附属物。买了计算机,附带操作系统等源代码,根本就不是什么稀罕的事。那时,或者在更早一些的时候,甚至有这样的情况,从生<br>产厂家买来的计算机连操作系统也没有,需要用户自己来开发各种软件。买了同样计算机的用户互相交换自己开发的软件,互助合作。虽然不够精致,但与如今开源软件的情况很有些相似之处。</p><h3 id="Emacs事件的发生"><a href="#Emacs事件的发生" class="headerlink" title="Emacs事件的发生"></a>Emacs事件的发生</h3><p>但是,戈斯林把 Gosmacs的专利卖给了 Unipress公司,斯托曼就不能够在 Gosmacs的基础上开发新的 Emacs了。结果,斯托曼从零开始开发了自己的UNIX版的Emacs。</p><p>他们的最终目标是，创造一个从上到下完全自由的操作系统环境。</p><h3 id="开源的诞生"><a href="#开源的诞生" class="headerlink" title="开源的诞生"></a>开源的诞生</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%888.52.32.png" alt="屏幕快照 2018-07-26 下午8.52.32" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午8.52.32</div>            </figure><h3 id="OSS许可证"><a href="#OSS许可证" class="headerlink" title="OSS许可证"></a>OSS许可证</h3><h4 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h4><p>GPL( GNU General Public license)应该可以说是自由软件许可证的鼻祖,它具有如下特征:</p><ol><li>没有保证;</li><li>表示版权;</li><li>保持同样的许可证</li></ol><p>GPL特征中最重要的是保持同样的许可证,也就是说,在对GPL许可证的软件进行修改或复制的情况下,必须保持其原来的GPL许可证。<br>这意味着再利用GPL软件的源代码而开发的软件的许可证也必须是GPL。批判GPL的人把这称为感染性。赞同GPL的人们称之为版权保留,因为这一性质意味着版权的保留。</p><h4 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h4><h4 id="BSD许可证"><a href="#BSD许可证" class="headerlink" title="BSD许可证"></a>BSD许可证</h4><h4 id="APL和CPL"><a href="#APL和CPL" class="headerlink" title="APL和CPL"></a>APL和CPL</h4><h3 id="开源的背景"><a href="#开源的背景" class="headerlink" title="开源的背景"></a>开源的背景</h3><p>在科学领域,共享知识和信息本来是非常普通的事情。即使不用看站在巨人的肩膀上的牛顿的例子,把知识作为论文(免费)公开,利用前人的成绩进行新的研究是再理所当然不过的。</p><p>软件,特别是商业软件,一旦作为商品来经营的话,就容易忘记这样一点,与论文的内容一样,软件也不过是信息的一种,也应该适用同样的原则。科学家致力于研究,大学或研究机构对科学家给予支持,这种体制对软件也有可能成立。实际上,大学或研究机构支援软件开发的例子相当多。</p><p>但是,谈到近年来开源的普及和发展,计算机的普及和因特网的发展则功不可没。过去如果要想开发髙质量软件的话,需要购买价格髙昂的计算机,召集大量的技术人员。现在一般家庭里的计算机都完全能够开发软件,通过网络进行合作开发的事情也屡见不鲜。个人出于兴趣而编程也已经能够达到相当高的水平了。</p><p>软件的复杂化和商品化也是开源的背景之一,不容忽视。软件所覆盖的领域越来越广,软件也越来越复杂。过去1万行左右的程序就实现了的操作系统,如今变成了超过600万行的巨大软件。</p><h3 id="企业关注开源的理由"><a href="#企业关注开源的理由" class="headerlink" title="企业关注开源的理由"></a>企业关注开源的理由</h3><p>从1998年以来,开始出现了盈利企业为自己的利益而开发开<br>源软件的事例。一旦认识到无法自己来开发所有软件之后,企业只自己开发最具竞争力的小部分核心软件,而让大家共同来开发其他软件,结果对大家都有好处,企业关注开源正是这种冷静的分析考量的结果。</p><p>参与开源的人们也各有各的想法。有因经营考虑而参加的企业,有为软件自由而参加的程序员,有因上级命令而参加的公司职员,各种各样,千差万别。但是,开源有可能为个人和全人类带来幸福,如果能继续下去形成良性循环的话,那真是再好不过了。</p><h3 id="Ruby与开源"><a href="#Ruby与开源" class="headerlink" title="Ruby与开源"></a>Ruby与开源</h3><p>Ruby从一开始就是开源软件。Ruby在1995年初次公开的时候,开源这个单词还没有诞生,也许应该称为自由软件。</p><h3 id="选择许可证的方法"><a href="#选择许可证的方法" class="headerlink" title="选择许可证的方法"></a>选择许可证的方法</h3><p>许可证与技术无关,而是有关法律和合同的工作,这不是技术人员的工作,而是属于律师的工作范围。对于软件开发人员来说,这决不是一件令人感兴趣的工作,有人甚至会想:“哪用得着这些东西呢?”</p><p>如果使用你的许可证的软件的所有代码都完全是由你自己写出来的话,这几乎不成为什么问题。只要发布新的许可证版本,问题就解决了但是,如果其中包含了其他人写的补丁的话,软件就不再是你一个人的了,在法律上写补丁的人是共同拥有版权的。</p><p>FSF作为软件自由的拥护者,强烈推行版权保留。另一方面,不怎么在乎版权保留的开发人员好像更多一些。如果你希望版权保留的话,几乎就只能选择GPL。</p><p>如果你的软件是作为库来使用的话,那么LGPL则是个不错的选择。如果对库适用GPL许可证的话,那事实上就只能为GPL软件所用,采用限制较为宽松的LGPL的话,有可能使你的软件得到更为广泛的使用。但是,LGPL有不方便、难于理解以及没有得到充分考察等缺点,在不太强烈希望版权保留的时候,最好不要选择它。</p><p>对于不太在乎版权保留的人来说,可以选择GPL以外的许可证。这里的要点是,该软件是否需要与其他软件进行链接。如果预想到将来可能以某种方式与GPL许可证的软件链接在一起的话,那么与GPL的互换性就变得很重要。拥有插件功能的软件或库特别要注意这一点。作为与GPL不相矛盾的许可证,有修正BSD许可证和MIT许可证等。</p><p>另一个应该考虑的要点是,与相关软件和许可证是否一致。比如 Eclipse插件就应该选择Eclipse许可证(即使不与GPL互换)。另外,PHP关联软件选择与PHP一致的许可证也是安全的。用Ruby编写的软件与Ruby本身的许可证本来是相互独立的,但好像也大都选择Rby许可证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-14-函数式编程&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-14-函数式编程&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 14 函数式编程&quot;&gt;&lt;/a&gt;松本行弘的程序世界 14 函数式编程&lt;/h1&gt;&lt;h2 id=&quot;新
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 13 关于数据的持久化</title>
    <link href="https://github.com/zdkswd/2018/07/24/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2013%20%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2018/07/24/松本行弘的程序世界 13 关于数据的持久化/</id>
    <published>2018-07-24T02:00:32.000Z</published>
    <updated>2018-08-10T16:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-13-关于数据的持久化"><a href="#松本行弘的程序世界-13-关于数据的持久化" class="headerlink" title="松本行弘的程序世界 13 关于数据的持久化"></a>松本行弘的程序世界 13 关于数据的持久化</h1><h2 id="持久化数据的方法"><a href="#持久化数据的方法" class="headerlink" title="持久化数据的方法"></a>持久化数据的方法</h2><h3 id="保存文本"><a href="#保存文本" class="headerlink" title="保存文本"></a>保存文本</h3><h3 id="变换成文本的Marshal"><a href="#变换成文本的Marshal" class="headerlink" title="变换成文本的Marshal"></a>变换成文本的Marshal</h3><p>将对象按一定的方式变换成文本，就可以保存到文件中去。这样的对象文本化就称为serialize(序列化)，或是marshal(封送处理)。</p><h3 id="使用Marshal模块"><a href="#使用Marshal模块" class="headerlink" title="使用Marshal模块"></a>使用Marshal模块</h3><p>标准Ruby中，嵌入了marshal功能，这就是Marshal模块。<br>Marshal模块中提供了几乎能将全部Ruby对象变为字节串的方法dump，以及将字节串恢复成原对象（的复制）的load方法。<br>对象可以简单地保存到文件里。</p><h3 id="复制有两种方式"><a href="#复制有两种方式" class="headerlink" title="复制有两种方式"></a>复制有两种方式</h3><p>使用Marshal可以完成对象的深复制。<br>复制对象的时候，通常使用clone方法。这种情况下，只复制直接对象，引用的对象不复制。称为浅复制。<br>深复制连同引用对象也一起进行递归复制。</p><h3 id="仔细看Marshal的格式"><a href="#仔细看Marshal的格式" class="headerlink" title="仔细看Marshal的格式"></a>仔细看Marshal的格式</h3><p>Marshal用二进制形式将对象文本化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15323139335047/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.07.00.png" alt="屏幕快照 2018-07-23 上午11.07.00" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-23 上午11.07.00</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15323139335047/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.09.40.png" alt="屏幕快照 2018-07-23 上午11.09.40" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-23 上午11.09.40</div>            </figure></p><h3 id="不能保存的3类对象"><a href="#不能保存的3类对象" class="headerlink" title="不能保存的3类对象"></a>不能保存的3类对象</h3><p>Marshal在实现上有限制。以下3类对象不能保存：</p><ol><li>定义了特异方法的对象。</li><li>输入、输出或是套接字等不能超越进程保存的对象。</li><li>在扩充库中定义，Ruby不知道保存方法的对象。 </li></ol><p>但是即使不能封送处理，若不是像输入输出那种从原理上不可能的情况，单纯是不知道封送处理方法的话，重新教一遍也就行了。</p><h3 id="制作面向对象数据库"><a href="#制作面向对象数据库" class="headerlink" title="制作面向对象数据库"></a>制作面向对象数据库</h3><p>使用Marshal保存对象，使对象具有了持久性。所以，Marshal也可应用于面向对象数据库。<br>PStore库是Marshal的一个用例。Marshal虽然只是将数据变换成字符串，PStore却利用了这一点，简单地实现了面向对象数据库。<br>PStore有三个特征：使用Marshal，可以原封不动地保存任意的Ruby对象；具有容易使用的接口；有事务处理（transaction）。<br>PStore也有缺点，它不适合一下子将数据全部读入内存的大规模数据库。但几百字节的小规模数据库，应该没问题。</p><h3 id="试用PStore"><a href="#试用PStore" class="headerlink" title="试用PStore"></a>试用PStore</h3><h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><h4 id="开始事务处理"><a href="#开始事务处理" class="headerlink" title="开始事务处理"></a>开始事务处理</h4><h4 id="对象的登录和取得"><a href="#对象的登录和取得" class="headerlink" title="对象的登录和取得"></a>对象的登录和取得</h4><h4 id="事务处理的终止"><a href="#事务处理的终止" class="headerlink" title="事务处理的终止"></a>事务处理的终止</h4><p>简单说明一下事务处理的步骤：</p><ol><li>用flock将数据文件加锁。</li><li>用Marshal从数据文件中读取数据</li><li>执行（事务处理）块</li><li>块的执行成功，Marshal将数据写入数据文件</li><li>块的执行失败，什么也不做。</li></ol><h3 id="变换为文本的YAML"><a href="#变换为文本的YAML" class="headerlink" title="变换为文本的YAML"></a>变换为文本的YAML</h3><p>Marshal的变换结果是二进制文件，内容不容易看懂。有些场合及时效率低一些，也需要能够以更容易看懂的形式输出。能够满足要求的是YAML。使用文本形式，不依赖平台的体系结构，是一种对人而言易读易编辑的序列化格式。</p><p>有以下几个特征：记述简洁；结果容易读懂；使用缩进的层次表现；数据表现是专用的，不必烦恼标签的名称问题。</p><p>YMAL可以活用在Ruby on Rails的配置文件等各种各样的领域。YMAL是在Perl中开发的，但正式的支持，Ruby是第一个。</p><h3 id="用YAML制作数据库"><a href="#用YAML制作数据库" class="headerlink" title="用YAML制作数据库"></a>用YAML制作数据库</h3><p>类似于PStore的东西，YAML：：Store，其与PStore的互换性非常高，只要把名字换一换，面向PStore的程序在YAML：：Store也能运行。</p><p>他俩的区别：</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>很显然，一个YAML，一个Marshal。</p><h4 id="数据量"><a href="#数据量" class="headerlink" title="数据量"></a>数据量</h4><p>Marshal比YAML紧凑的多，Marshal牺牲了易读性而实现了良好性能。</p><h4 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h4><p>性能优良不光是容量的问题。使用Marshal的PStore比YAML：：Store速度高，在这一点上，也是数据量越大，两者的差异就越显著。</p><h2 id="对象的保存"><a href="#对象的保存" class="headerlink" title="对象的保存"></a>对象的保存</h2><p>对象持久化库Madeleine，利用直接持久化对象的设计模式Object Prevalence。</p><p>Madeleine是Object Prevalence在Ruby中的实现，应称为PStore的发展形式。</p><p>PStore只是对象单纯由Marshal输出而来，Madeleine则与应用程序相协调，实现了高可靠性和高性能的持久化。</p><h3 id="高速的Object-Prevalence"><a href="#高速的Object-Prevalence" class="headerlink" title="高速的Object Prevalence"></a>高速的Object Prevalence</h3><p>所谓Prevalence，是一种实现应用程序持久化和进程间共享数据的设计模式。高性能的秘密在于直接访问内存中的数据。Object Prevalence将处理的数据保存在正在执行的应用程序的内存中，检索等操作不通过SQL而是直接进行，节省了与数据库副武器的通信成本，引用当然就会很高速。</p><p>但是，只有是同一进程，才能引用内存中的数据，进程一结束，数据马上消失。从持久化角度有必要解决这一问题。</p><p>Object Prevalence用日志记录（journaling）和快照（snapshot）来解决这一问题。Object Prevalence中，数据更新时不是直接更新对象，而是创建称为command的对象，采用的是一种非常间接的方法，在用command更新对象时，内存中的对象更新的同时，所有的更新内容也会写到称为日志（journal log）的外部文件中。</p><p>长此下去日志越来越大，所以要将现在数据状态写到称为快照的文件中。有了快照，老日志就不需要了，可在适当的时机删除。</p><p>有了最新的快照和最新的日志，可以完全恢复现在对象的状态。程序启动，按三步骤恢复内存的数据。及时有多个进程，只要写入日志的信息是完整的，就可以共享对象的状态。</p><ol><li>如果不存在快照，就初始化应用程序数据。</li><li>如果存在快照，就读入其中最新的一个。</li><li>如果还存在日志，也将其读入，并用其中最新的一个更新应用程序数据。</li></ol><h3 id="Object-Prevalence的问题点"><a href="#Object-Prevalence的问题点" class="headerlink" title="Object Prevalence的问题点"></a>Object Prevalence的问题点</h3><p><strong>Object Prevalence通过使用日志记录和快照实现了对象的持久化和进程间共享。</strong>Object Prevalence将所有数据都保存到内存中，随着数据量的增大，内存的消耗也在增大。</p><p>关系数据库中，不引用的数据放在文件中，必要的内存量就不用那么多了。</p><p>Object Prevalence有为了数据更新而具有的特殊结构，更新持久化数据时需要经由command对象。</p><h3 id="使用Madeleine"><a href="#使用Madeleine" class="headerlink" title="使用Madeleine"></a>使用Madeleine</h3><h3 id="访问时刻信息"><a href="#访问时刻信息" class="headerlink" title="访问时刻信息"></a>访问时刻信息</h3><h3 id="让Madeleine更容易使用"><a href="#让Madeleine更容易使用" class="headerlink" title="让Madeleine更容易使用"></a>让Madeleine更容易使用</h3><p>Madeleine既保持简洁性，又能让对象持久化，但是最大的缺点是在每次更新应用程序时必须生成command对象。</p><h3 id="Madeleine的实用例Instiki"><a href="#Madeleine的实用例Instiki" class="headerlink" title="Madeleine的实用例Instiki"></a>Madeleine的实用例Instiki</h3><p>Madeleine没有得到广泛应用，除了知道的人少，还因为数据全保存在内存中，就必须十分留意数据的大小。</p><p>Madeleine有一个很大的缺点，就是没有考虑多个进程同时更新数据的情况。</p><h2 id="关于XML的考察"><a href="#关于XML的考察" class="headerlink" title="关于XML的考察"></a>关于XML的考察</h2><h3 id="XML的祖先是SGML"><a href="#XML的祖先是SGML" class="headerlink" title="XML的祖先是SGML"></a>XML的祖先是SGML</h3><p>SGML是将文档电子化的一种格式。由三部分组成：表示数据本身的Instance，表示数据结构的DTD，以及SGML声明。</p><p>由于SGML太复杂，处理成本太高，为了表现网页，将SGML特化为HTML，随之诞生的是XML。</p><p>XML不像HTML那样是为了特定目的的标记语言，它一开始就是为了通用目的而设计的。为了让XML在没有DTD来定义语法或提供schema信息的情况下，也能够解析，人们对其语法进行了简化。</p><h3 id="XML是树结构的数据表现"><a href="#XML是树结构的数据表现" class="headerlink" title="XML是树结构的数据表现"></a>XML是树结构的数据表现</h3><p>XML基本上是纯文本，以类似于HTML的标签嵌套方式实现树结构。XML是继承了SGML的通用标记语言，其与SGML最大的区别是其基本语法固定，不依赖于DTD那样的外部信息也能解析。</p><p>即使没有标签的概要信息也能解析的语法称为良构的（well-formed）,这是XML的一大特征。</p><h3 id="优点在于纯文本"><a href="#优点在于纯文本" class="headerlink" title="优点在于纯文本"></a>优点在于纯文本</h3><p>最大的优点在于XML基本上是纯文本的，表示结构的信息附加在标签里。</p><p>第二个优点是不易发生字符编码的问题。XML规定，在没有明确指定的情况下，字符编码均使用Unicode。</p><p>第三个优点是得益于良构的性质，在没有数据结构的情况下也能解析XML数据。这样就可以不考虑目的，而用共同的工具来处理XML数据。</p><p>第四个优点在于，XML与其解析工具不依赖于特定的语言，比如Java生成的XML数据在Ruby中的解析也很简单。解析XML的API，像DOM和SAX都超越语言提供了几乎共通的性质，所以不同语言也可以进行同样的操作。</p><p>最后一个有点是，人们也很容易理解。</p><p>总之，XML作为各种数据交换格式的框架，具有优良的性质。作为格式的格式，也就是元格式，是很优秀的。</p><h3 id="缺点在于冗长"><a href="#缺点在于冗长" class="headerlink" title="缺点在于冗长"></a>缺点在于冗长</h3><p>最大的缺点是效率低下。XML是以纯文本出现的，标签信息反复出现，显得冗长。与表示相同信息的二进制数据相比，XML数据的容量要大得多，与其他文本表现方式相比（YAML，JSON）也显得冗长。</p><p>效率低下不光体现在数据大小上，解析XML的效率也不怎么高。与二进制文件相比，XML文件的解析因为含有大量字符串处理，而容易变得很慢。</p><p>作为文本的标记语言而诞生的XML，用其表现有一定结构的数据到底好不好还是个疑问。如果只是用于表现构造数据，比XML更有效率的格式还有很多。而且XML原则上只能表现树结构的数据。</p><p>总结，XML作为出于通用目的的数据格式，效率很低，所谓很多优点，如果场合不对，也没多大意义。适才适用，XML也要分情况适当使用。</p><h3 id="不适合重视效率的处理"><a href="#不适合重视效率的处理" class="headerlink" title="不适合重视效率的处理"></a>不适合重视效率的处理</h3><p>对于重视通信量和速度的情况都不适合，此时应使用专用的协议或是效率更高的格式。</p><p>像配置文件那样靠人直接编辑的数据也不推荐XML。配置文件中，需要用到XML的树结构数据地方很少，随着要素数增加，就会很难读，用YMAL和JSON才更合适。</p><p>XML适合的场合：</p><ol><li>人一般不直接接触</li><li>复杂性不成问题</li><li>效率不成为问题</li><li>跨平台</li></ol><h3 id="适合于信息交换的格式"><a href="#适合于信息交换的格式" class="headerlink" title="适合于信息交换的格式"></a>适合于信息交换的格式</h3><p>利用XML的元格式性质，以XML为基础的格式的例子。</p><ol><li>RSS。Web网站更新信息。</li><li>Atom。RSS的代替。</li><li>ebXML。电子商务数据交换。</li><li>SVG。向量-图像表示。</li><li>SMIL。 多媒体及内容控制。</li></ol><p>以上这些都具有XML的性质，可以用XML处理工具简单地解析。制作数据格式时，最麻烦的就是制作处理这种格式的软件。所以，XML与XML处理库的存在是很可贵的。</p><p>另外，XML数据库中，问题不在于数据是不是实际以纯文本XML来表现，而在于XML能够表现的树结构能够自由自在地操作。即，不是带标签的纯文本，而是由带属性、带内容的节点所构成的树结构本身才是最重要的。关系数据库的表只能表示间接数据，如果是树结构，可以直接操作直接表现的数据。</p><h3 id="XML的解析"><a href="#XML的解析" class="headerlink" title="XML的解析"></a>XML的解析</h3><p>XML的解析方法有好几种。</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>DOM是文档对象模型的缩写，是对读取了XML数据的树结构进行操作的库。</p><h4 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h4><p>Simple API for XML,与将数据全部读入内存的DOM不同，通常，SAX以数据流的形式读入XML，以事件驱动进行处理。SAX中，没必要将数据全部读入，这样往往处理效率更高，所以适合于将XML变换为其他形式的处理，反过来说，不适合于对树结构进行随机访问等用途。</p><h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>XPath是用于指定XML树的一部分的书写格式。使用XPath，可以用节点名、属性名或是属性值等来选择特定的节点（群）。</p><h3 id="XML处理库REXML"><a href="#XML处理库REXML" class="headerlink" title="XML处理库REXML"></a>XML处理库REXML</h3><p>REXML是Ruby标准附属的XML处理库。REXML是具有DOM、SAX、SAX2以及XML Pull Parser等多照片那个功能的库。全部用Ruby实现，所以速度表现不怎么优秀。在特别重视效率的情况下，有必要用libxml等别的XML处理库。</p><h3 id="XML的代替"><a href="#XML的代替" class="headerlink" title="XML的代替"></a>XML的代替</h3><h4 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h4><p>JSON是把JavaScript的对象记法作为表现格式来使用。</p><p>将JSON数据原封不动地作为JavaScript去执行，就可以得到数据表现所对应的对象。但是JSON数据从外部读取的情况较多，实际上作为JavaScript直接执行容易引起安全上的问题，即使效率稍稍低一些，也应当使用解析JSON的库。</p><p>Ruby支持JSON。</p><h4 id="YAML（YMAL-ain’t-Markup-Language）"><a href="#YAML（YMAL-ain’t-Markup-Language）" class="headerlink" title="YAML（YMAL ain’t Markup Language）"></a>YAML（YMAL ain’t Markup Language）</h4><p>YAML是作为XML的对立面而诞生的，具有以下特征。完全放弃标记性记述，专注于数据表现；以缩进为基础表现数据结构；不要标签；可以对应各种语言。文件后缀为.yml</p><p>在用作数据表现及配置文件时，具有易读和不易变复杂等优点。实际上，YAML在Ruby on Rails中广泛用于配置文件。</p><p>另一方面，YAML到底是数据表现语言，没有相当于schema的东西，不适合于带结构的文本表现及元数据格式。</p><p>活用记号和缩进的YMAL比JSON更简洁，正如其名，YMAL不是标记语言，需要使用标记语言时还是XML合适。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAML是JSON的超集，采用空格来作为结构，JSON则是括号，一般YAML解析速度高于JSON，但对于某些东西定义的复杂性高于JSON，速度差别不大时可考虑用JSON。</span><br></pre></td></tr></table></figure></p><h4 id="Binary-XML"><a href="#Binary-XML" class="headerlink" title="Binary XML"></a>Binary XML</h4><p>与通常的XML有等价意义，但效率更高，采用二进制表现的是Binary XML。但现在还没有Binary XML的标准规格。</p><h4 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h4><p>Protocol Buffer使用一种“数据描述语言”来定义数据结构，然后从这个定义生成一个库，将原始数据变为二进制表现（序列化）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">持久数据的重要性</span><br><span class="line">如果不是有了像纸和刻了文字的石头等经久不烂而且可以读出的媒介，将来人类文明说不定会遇到失去重要信息的危险。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-13-关于数据的持久化&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-13-关于数据的持久化&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 13 关于数据的持久化&quot;&gt;&lt;/a&gt;松本行弘的程序世界 13 关于数据的持久化&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 12 关于时间的处理</title>
    <link href="https://github.com/zdkswd/2018/07/23/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2012%20%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/23/松本行弘的程序世界 12 关于时间的处理/</id>
    <published>2018-07-23T13:53:32.000Z</published>
    <updated>2018-07-23T13:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-12-关于时间的处理"><a href="#松本行弘的程序世界-12-关于时间的处理" class="headerlink" title="松本行弘的程序世界 12 关于时间的处理"></a>松本行弘的程序世界 12 关于时间的处理</h1><h2 id="用程序处理时刻与时间"><a href="#用程序处理时刻与时间" class="headerlink" title="用程序处理时刻与时间"></a>用程序处理时刻与时间</h2><h3 id="时差与时区"><a href="#时差与时区" class="headerlink" title="时差与时区"></a>时差与时区</h3><h3 id="世界协调时间"><a href="#世界协调时间" class="headerlink" title="世界协调时间"></a>世界协调时间</h3><h3 id="夏令时"><a href="#夏令时" class="headerlink" title="夏令时"></a>夏令时</h3><p>一定时期内时钟拨快一小时。</p><h3 id="改历"><a href="#改历" class="headerlink" title="改历"></a>改历</h3><h3 id="日期与时间的类"><a href="#日期与时间的类" class="headerlink" title="日期与时间的类"></a>日期与时间的类</h3><h4 id="Time类"><a href="#Time类" class="headerlink" title="Time类"></a>Time类</h4><p>表示日常所用时间的类。</p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>表示不含时刻的日期的类。</p><h4 id="DateTime类"><a href="#DateTime类" class="headerlink" title="DateTime类"></a>DateTime类</h4><p>Date类附加上时间信息的类。能表示时间，而且没有范围限制，功能上最强。</p><h3 id="2038年问题"><a href="#2038年问题" class="headerlink" title="2038年问题"></a>2038年问题</h3><p>不仅限UNIX，很多操作系统都是以过去某个时点开始所经过的时间来表示时刻的。在UNIX中，过去某个时点指1970年1月1日零点。<br>问题是计算机能够处理的整数大小有限，界限是2038年1月19日3时14分7秒。</p><h3 id="DateTime类-1"><a href="#DateTime类-1" class="headerlink" title="DateTime类"></a>DateTime类</h3><p>相对于epoch（某个时点）开始的秒数来管理Time类，DateTime类是以日期为基础计算的Date类，附加上时刻信息而生成的。</p><h3 id="Time与DateTime的相互变换"><a href="#Time与DateTime的相互变换" class="headerlink" title="Time与DateTime的相互变换"></a>Time与DateTime的相互变换</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-12-关于时间的处理&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-12-关于时间的处理&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 12 关于时间的处理&quot;&gt;&lt;/a&gt;松本行弘的程序世界 12 关于时间的处理&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 11 程序安全性</title>
    <link href="https://github.com/zdkswd/2018/07/21/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2011%20%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>https://github.com/zdkswd/2018/07/21/松本行弘的程序世界 11 程序安全性/</id>
    <published>2018-07-21T13:28:32.000Z</published>
    <updated>2018-07-21T13:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-11-程序安全性"><a href="#松本行弘的程序世界-11-程序安全性" class="headerlink" title="松本行弘的程序世界 11 程序安全性"></a>松本行弘的程序世界 11 程序安全性</h1><h2 id="程序的漏洞与攻击方法"><a href="#程序的漏洞与攻击方法" class="headerlink" title="程序的漏洞与攻击方法"></a>程序的漏洞与攻击方法</h2><h3 id="四种软件漏洞"><a href="#四种软件漏洞" class="headerlink" title="四种软件漏洞"></a>四种软件漏洞</h3><ol><li>dos攻击</li><li>信息泄露</li><li>权限夺取</li><li>权限升格</li></ol><p>DOS攻击，即拒绝服务攻击，指妨碍软件正常运行（服务的执行）的网络攻击手段。能够引起软件异常终止的程序错误，全部都是引发DOS攻击的安全性程序错误。<br>分为软件漏洞与外部DOS攻击。<br>信息泄露指不愿公开的信息被公开了。</p><h3 id="因权限被窃取而成为重大问题"><a href="#因权限被窃取而成为重大问题" class="headerlink" title="因权限被窃取而成为重大问题"></a>因权限被窃取而成为重大问题</h3><h3 id="安全问题的根源"><a href="#安全问题的根源" class="headerlink" title="安全问题的根源"></a>安全问题的根源</h3><p>在于运行软件的人（权限所有者）和利用软件的人是不同的。<br>安全问题有三种</p><ol><li>恶意软件<br>指在程序本身植入了恶意代码。</li><li>setuid/setgid<br>指执行的程序以所有者权限进行动作。setuid的缺点已经变得比优点更突出，现在几乎不用了。</li><li>服务器</li></ol><h3 id="“守护神”引起的问题"><a href="#“守护神”引起的问题" class="headerlink" title="“守护神”引起的问题"></a>“守护神”引起的问题</h3><p>服务这里指的是为了提供服务而常驻型的软件，又为后台服务(daemon),即守护神的意思。<br>后台服务基本上都是受理经由socket而来的请求。执行它所提供的服务，将结果经socket返回。几乎所有的情况，发出请求者和执行权限者都是不同的。这种软件若有了漏洞，会引起DOS问题和权限夺取问题。</p><h3 id="多样化的攻击手段"><a href="#多样化的攻击手段" class="headerlink" title="多样化的攻击手段"></a>多样化的攻击手段</h3><p>代表性的有：</p><ol><li>缓冲区溢出</li><li>整数溢出</li><li>跨站点脚本攻击（XSS）</li><li>SQL注入</li><li>跨站点伪造请求（CSRF）</li></ol><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>指向固定的缓冲区输入了比假定长度要长很多的数据，使程序异常终止。或者是更改堆栈的跳转地址劫持程序。<br>使用C那种连数组长度都不检查的语言，可以说肯定会产生问题。幸亏，像Ruby这样的高级语言，语言处理系统自动分配内存，可以不使用固定长的缓冲区。使用更高级的语言，可以从缓冲区溢出问题中解放出来。但由于速度上的考虑，还会开发C语言的CGI及Daemon程序，应多加注意。</p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>整数溢出与缓冲区溢出相似，但它是更难被发现的问题。<br>c等很多语言，整数只能表示一定范围的数，超过范围，就会发生溢出，也不发出警告就将数值舍入。这个问题通过使用Ruby这样的高级语言可以解决，内存分配不是由用户直接进行，内部分配都要经过严格检查。所以，只要使用Ruby，与整数溢出就不沾边。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是对外部的输入检查不充分时所产生的典型问题。<br>从外部的输入不能原封不动填到SQL语句中去，因为填入的文字可能含有对SQL语句有某种意义的文字。</p><h3 id="Shell注入"><a href="#Shell注入" class="headerlink" title="Shell注入"></a>Shell注入</h3><p>Shell注入与SQL注入原理相同。<br>从外部的输入，如果不进行检查就不能传递给system等危险的函数。<br>为了从一定程度上检查出这类问题，Ruby和Perl中有“污染检查”功能。给外部输入的数据加上“污染记号”，禁止对字符串进行危险操作。</p><h3 id="跨站点脚本攻击"><a href="#跨站点脚本攻击" class="headerlink" title="跨站点脚本攻击"></a>跨站点脚本攻击</h3><p>跨站点脚本攻击与SQL注入和Shell注入一样，也是因为将输入值原封不动地放在输出值内而引起的问题。<br>如用户输入中含有HTML标签。而且HTML可能夹杂JavaScript。</p><h3 id="跨站点伪造请求"><a href="#跨站点伪造请求" class="headerlink" title="跨站点伪造请求"></a>跨站点伪造请求</h3><p>跨站点伪造请求（CSRF）是Web应用程序固有的攻击手段。<br>构成Web应用程序的每一页由两部分构成，一个来自网路浏览器的HTTP请求，一个是HTTP服务器的响应。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.11.22.png" alt="屏幕快照 2018-07-21 下午7.11.22" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.11.22</div>            </figure></p><h3 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h3><h2 id="用异常进行错误处理"><a href="#用异常进行错误处理" class="headerlink" title="用异常进行错误处理"></a>用异常进行错误处理</h2><h3 id="异常的历史"><a href="#异常的历史" class="headerlink" title="异常的历史"></a>异常的历史</h3><h3 id="Java的受控异常"><a href="#Java的受控异常" class="headerlink" title="Java的受控异常"></a>Java的受控异常</h3><p>采用受控异常的，Java是第一个。</p><h3 id="Icon的面向目标判断"><a href="#Icon的面向目标判断" class="headerlink" title="Icon的面向目标判断"></a>Icon的面向目标判断</h3><p>Ruby在设计之初，也曾认真考虑过采用像Icon式的真伪值判断，结果还是采用了nil和false以外的值全是真值的这种正统方式。</p><h3 id="Ruby的异常"><a href="#Ruby的异常" class="headerlink" title="Ruby的异常"></a>Ruby的异常</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.30.12.png" alt="屏幕快照 2018-07-21 下午7.30.12" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.30.12</div>            </figure><h3 id="异常发生"><a href="#异常发生" class="headerlink" title="异常发生"></a>异常发生</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.33.32.png" alt="屏幕快照 2018-07-21 下午7.33.32" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.33.32</div>            </figure><h3 id="异常处理的设计方针"><a href="#异常处理的设计方针" class="headerlink" title="异常处理的设计方针"></a>异常处理的设计方针</h3><p>方法的执行应当“异常安全”，即执行时及时发生了异常也不会发生异常情况：</p><ul><li>因为发生了异常，留下了不完全的数据结构</li><li>因为发生了异常，数据库里进了垃圾</li><li>因为发生了异常，程序异常终止</li></ul><h3 id="异常发生的设计原则"><a href="#异常发生的设计原则" class="headerlink" title="异常发生的设计原则"></a>异常发生的设计原则</h3><p>假设发生的情况与既有的异常类明显不同，需要制作一个新的异常。此时考虑：</p><ul><li>名称：应该给新的类起一个什么样的名字</li><li>父类：新的类应该属于哪一个异常类的子类</li><li>生成方法：应该如何初始化新的类实例</li></ul><p>产生异常的两个原则：1异步异常，基本原则是不要使用异步异常。2.文档化，有必要清楚详细的写成文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-11-程序安全性&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-11-程序安全性&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 11 程序安全性&quot;&gt;&lt;/a&gt;松本行弘的程序世界 11 程序安全性&lt;/h1&gt;&lt;h2 id=&quot;程
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 10 高速执行和并行处理</title>
    <link href="https://github.com/zdkswd/2018/07/20/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2010%20%E9%AB%98%E9%80%9F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/</id>
    <published>2018-07-20T09:58:32.000Z</published>
    <updated>2018-07-20T10:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-10-高速执行和并行处理"><a href="#松本行弘的程序世界-10-高速执行和并行处理" class="headerlink" title="松本行弘的程序世界 10 高速执行和并行处理"></a>松本行弘的程序世界 10 高速执行和并行处理</h1><h2 id="让程序高速执行（前篇）"><a href="#让程序高速执行（前篇）" class="headerlink" title="让程序高速执行（前篇）"></a>让程序高速执行（前篇）</h2><h3 id="是不是越快越好"><a href="#是不是越快越好" class="headerlink" title="是不是越快越好"></a>是不是越快越好</h3><p>并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。</p><h3 id="高速执行的乐趣与效率"><a href="#高速执行的乐趣与效率" class="headerlink" title="高速执行的乐趣与效率"></a>高速执行的乐趣与效率</h3><p>在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。</p><h3 id="以数据为基础做出判断"><a href="#以数据为基础做出判断" class="headerlink" title="以数据为基础做出判断"></a>以数据为基础做出判断</h3><h3 id="改善系统调用"><a href="#改善系统调用" class="headerlink" title="改善系统调用"></a>改善系统调用</h3><p>排序处理任务重时，典型的对策是使用施瓦茨变换。</p><h3 id="数据可靠吗"><a href="#数据可靠吗" class="headerlink" title="数据可靠吗"></a>数据可靠吗</h3><p>误差</p><h3 id="只需改善瓶颈"><a href="#只需改善瓶颈" class="headerlink" title="只需改善瓶颈"></a>只需改善瓶颈</h3><p>性能优化中，“因为是排序，所以就用施瓦茨变换”这种条件反射式的对策并非总管用。为了合理提高速度，确立恰当的策略是很必要的。<br>帕累托法则又称80/20法则，即80%的数值是由20%的构成要素产生的。由帕累托法则可知，有20%的努力可以达到巨大回报，而有80%的努力得不到多少回报。在得不到回报的地方，不管怎么努力都是徒劳的。<br>Donald Knuth也提到，通常一半以上的执行时间都耗费在程序中不到4%的部分。<br>这些耗费了大半以上执行时间的部分称为瓶颈。<br>判定瓶颈，可以用profiler这一工具。</p><h3 id="profiler本身成了累赘"><a href="#profiler本身成了累赘" class="headerlink" title="profiler本身成了累赘"></a>profiler本身成了累赘</h3><p>不确定性原理是指测定行为本身对被测对象产生了影响，从原理上可以说不可能正确知道对象的状态。但是知道实际状态的大体倾向。</p><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>选择合适的算法，这是性能改善的第一考虑因素，要记住这条铁则。</p><h3 id="理解O记法"><a href="#理解O记法" class="headerlink" title="理解O记法"></a>理解O记法</h3><p>如何从效率方面判定一个算法的好坏呢。一个方法就是O记法，表示某种算法对于变量（比如使用的元素个数）如何变化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8A%E5%8D%8811.05.39.png" alt="屏幕快照 2018-07-20 上午11.05.39" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 上午11.05.39</div>            </figure></p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><h3 id="调查算法的性能"><a href="#调查算法的性能" class="headerlink" title="调查算法的性能"></a>调查算法的性能</h3><p>Ruby提供进行算法性能比较时用的benchmark程序。</p><h3 id="高速执行的悲哀"><a href="#高速执行的悲哀" class="headerlink" title="高速执行的悲哀"></a>高速执行的悲哀</h3><h4 id="徒劳无益的努力"><a href="#徒劳无益的努力" class="headerlink" title="徒劳无益的努力"></a>徒劳无益的努力</h4><p>很容易在瓶颈无关的地方花费太多徒劳无益的努力。</p><h4 id="改良绊住了手脚"><a href="#改良绊住了手脚" class="headerlink" title="改良绊住了手脚"></a>改良绊住了手脚</h4><p>sort_by所依据的施瓦茨变换，是用时间和空间的交换来消减计算量的方法。sort_by方法与sort方法相比，占用了多达三倍以上的内存。所以，模块内的处理本来不是很重，如果一味地占用内存反而可能会变慢。<br>性能优化，光有理论还不行，如果不实际做的话就不知道到底什么是正确的。</p><h4 id="算法选择的圈套"><a href="#算法选择的圈套" class="headerlink" title="算法选择的圈套"></a>算法选择的圈套</h4><p>在进行性能优化时，不改变原来程序的执行时一个大原则。</p><h3 id="性能优化的格言"><a href="#性能优化的格言" class="headerlink" title="性能优化的格言"></a>性能优化的格言</h3><p><strong>过早的优化是万恶之源。</strong></p><p><strong>优化有两条准则。</strong><br><strong>1.别做优化</strong><br><strong>2.（仅适用于专家）先不要做优化</strong></p><hr><p><strong>过早的优化是万恶之源</strong><br>代码优化的好处多多，但是这并不意味着所有的代码都需要进行优化，有时过度的优化反而适得其反——费时、费力、不讨好。<br>“现代计算机科学的鼻祖”Donald Knuth曾说过“过早的优化是万恶之源”，因为：让正确的程序更快，要比让快速的程序正确容易得多。<br>在项目开发中，总是有程序员浪费宝贵的时间去改进那些不需要改进的代码，而没有通过所做的改进增加价值。在对项目进行优化时，究竟哪些地方应该优化，应该如何优化，哪些不应该优化呢？你需要先来了解一下本文所说的这7件事。<br>1.究竟要优化什么？<br>在优化工作开始的时候，你还尚未明确优化内容和目的，那么你很容易陷入误区。在一开始，你就应该清楚地了解你要达到的效果，以及其他优化相关的各种问题。这些目标需要明确指出（至少精通技术的项目经理可以理解和表达它），接下来，在整个优化过程中，你需要坚持这些目标。<br>在实际的项目开发中，经常会存在各种各样的变数。可能一开始时要优化这一方面，随后你可能会发现需要优化另一方面。这种情况下，你需要清晰地了解这些变化，并确保团队中的每个人都明白目标已经发生了变化。<br>2.选择一个正确的优化指标<br>选择正确的指标，是优化的一个重要组成部分，你需要按照这些指标来测量优化工作的进展情况。如果指标选择不恰当，或者完全错误，你所做的努力有可能白费了。<br>即使指标正确，也必须有一些辨别。在某些情况下，将最多的努力投入到运行消耗时间最多的那部分代码中，这是实用的策略。但也要记住，Unix/Linux内核的大部分时间花费在了空循环上。<br>需要注意的是，如果你轻易选择了一个很容易达到的指标，这作用不大，因为没有真正解决问题。你有必要选择一个更复杂的、更接近你的目标的指标。<br>3.优化在刀刃上<br>这是有效优化的关键。找到项目中与你的目标（性能、资源或其他）相背的地方，并将你的努力和时间用在那里。<br>举一个典型的例子，一个Web项目速度比较慢，开发者在优化时将大部分精力放在了数据库优化上，最终发现真正的问题是网络连接慢。<br>另外，不要分心于容易实现的问题。这些问题尽管很容易解决，但可能不是必要的，或与你的目标不相符。容易优化并不意味着值得你花费工夫。<br>4.优化层次越高越好<br>在一般情况下，优化的层次越高，就会越有效。根据这个标准，最好的优化是找到一个更有效的算法。<br>举个例子，在一个软件开发项目中，有一个重要的应用程序性能较差，于是开发团队开始着手优化，但性能并没有提升太多，之后，项目人员交替，新的开发人员在检查代码时发现，性能问题的核心是由于在表中使用了冒泡排序算法，导致成千上万项的增加。<br>尽管如此，高层次的优化也不是“银弹”。一些基本技术，如将所有东西移到循环语句外，也可以产生一些优化的效果。通常情况下，大量低层次的优化可以产生等同于一个高层次优化的效果。<br>还需要注意的是，高层次优化，会减少一些代码块，那么你之前对这些代码块所做的优化就没有任何意义了，因此，刚开始就应该考虑高层次的优化。<br>5.不要过早优化<br>在项目早期就进行优化，会导致你的代码难以阅读，或者会影响运行。另一方面，在项目后期，你可能会发现之前所做的优化没有起到任何作用，白白浪费了时间和精力。<br>正确的方式是，你应该将项目开发和优化当作两个独立的步骤来做。<br>6.依赖性能分析，而不是直觉<br>你往往会认为你已经知道哪里需要优化，这是不可取的，尤其是在复杂的软件系统中，性能分析数据应该是第一位的，最后才是直觉。<br>优化的一个有效的策略是，你要根据所做工作对优化效果的影响来进行排序。在开始工作之前找到影响最大的“路障”，然后再处理小的“路障”。<br>7.优化不是万金油<br>优化最重要的规则之一是，你无法优化一切，甚至无法同时优化两个问题。比如，优化了速度，可能会增加资源利用；优化了存储的利用率，可能会使其他地方放慢。你需要权衡一下，哪个更符合你的优化目标。</p><hr><h2 id="让程序高速执行（后篇）"><a href="#让程序高速执行（后篇）" class="headerlink" title="让程序高速执行（后篇）"></a>让程序高速执行（后篇）</h2><p>例题是曼德勃罗集合的计算程序，指复平面上满足以下条件的复素数的集合：经过某种反复迭代运算以后，其值不会发散到无限大。</p><h3 id="确认程序概要"><a href="#确认程序概要" class="headerlink" title="确认程序概要"></a>确认程序概要</h3><h3 id="发现瓶颈"><a href="#发现瓶颈" class="headerlink" title="发现瓶颈"></a>发现瓶颈</h3><p>使用profiler</p><h3 id="使用更好地profiler"><a href="#使用更好地profiler" class="headerlink" title="使用更好地profiler"></a>使用更好地profiler</h3><p>ruby-prof程序通过使用扩展库可以实现高速profile</p><h3 id="高速优化之一：消减对象"><a href="#高速优化之一：消减对象" class="headerlink" title="高速优化之一：消减对象"></a>高速优化之一：消减对象</h3><p>Ruby高速优化的规则。</p><h4 id="减少对象"><a href="#减少对象" class="headerlink" title="减少对象"></a>减少对象</h4><p>高级面向对象语言中对象的生成要花费一定的时间，减少对象，除了会降低生成成本外，还有别的好处。<br>Ruby中不在使用的对象，由被称作垃圾收集的处理自动进行回收。垃圾收集处理需要检查对象的引用关系，任何地方都不再引用的对象会被判定为已经不再使用了。当对象的数量很多时，判断成本就要增大。</p><h4 id="减少方法调用"><a href="#减少方法调用" class="headerlink" title="减少方法调用"></a>减少方法调用</h4><p>方法调用中，存在多态性这一面向对象的本质特征，先要评价参数，判定对象种类，然后选出一个合适的方法，再讲控制交给该方法，这是一个缓慢的处理过程。<br>为了避开方法调用，尽可能不用Ruby中实现的方法。Ruby中实现的方法，几乎所有的情况都是调用其他方法来实现的。也就是说，只要使用了一次Ruby中实现的方法，就会有多余的方法调用发生。</p><h3 id="高速优化之二：利用立即值"><a href="#高速优化之二：利用立即值" class="headerlink" title="高速优化之二：利用立即值"></a>高速优化之二：利用立即值</h3><p>Ruby中有几类对象并不实际分配内存，而是用引用本身来表示，这种值称为立即值。<br>现在的Ruby中，小的整数（±2    ^30以内）、真假值、nil和符号名等都是立即值。<br>立即值既然不生成对象，就不用担心对象的生成成本，而且也不用垃圾收集处理，所以它具有特别理想的特性。</p><h3 id="高速优化之三：利用C语言"><a href="#高速优化之三：利用C语言" class="headerlink" title="高速优化之三：利用C语言"></a>高速优化之三：利用C语言</h3><p>Ruby是解释性语言，单纯计算的循环不是很快。如果将处理交给编译器，就可以变得很快。</p><h3 id="高速优化之四：采用合适的数据结构"><a href="#高速优化之四：采用合适的数据结构" class="headerlink" title="高速优化之四：采用合适的数据结构"></a>高速优化之四：采用合适的数据结构</h3><h3 id="全部以C语言计算"><a href="#全部以C语言计算" class="headerlink" title="全部以C语言计算"></a>全部以C语言计算</h3><h3 id="还存在其他技巧"><a href="#还存在其他技巧" class="headerlink" title="还存在其他技巧"></a>还存在其他技巧</h3><p>还有以空间换时间。</p><h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><p>与进程不同，同一进程的线程可以共享内存空间，所以，不同的线程能够引用同一对象。不需要经过将数据变为字节流再进行通信这样麻烦的处理，就能交换信息。</p><h3 id="生成线程"><a href="#生成线程" class="headerlink" title="生成线程"></a>生成线程</h3><h3 id="线程的执行状态"><a href="#线程的执行状态" class="headerlink" title="线程的执行状态"></a>线程的执行状态</h3><p>Ruby的线程有四种状态。<br>run：执行中<br>stop：停止中<br>to_kill:终止处理中<br>killed:终止<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%881.55.11.png" alt="屏幕快照 2018-07-20 下午1.55.11" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午1.55.11</div>            </figure></p><h3 id="传递值给线程的方法"><a href="#传递值给线程的方法" class="headerlink" title="传递值给线程的方法"></a>传递值给线程的方法</h3><h3 id="信息共享所产生的问题"><a href="#信息共享所产生的问题" class="headerlink" title="信息共享所产生的问题"></a>信息共享所产生的问题</h3><ol><li>数据完整性丧失</li><li>死锁</li></ol><p><strong>与其说是线程的问题，不如说是并行处理本身的问题。</strong></p><h3 id="数据完整性的丧失"><a href="#数据完整性的丧失" class="headerlink" title="数据完整性的丧失"></a>数据完整性的丧失</h3><p>原子操作</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>哲学家进餐问题</p><h3 id="用锁来实现对资源的独占"><a href="#用锁来实现对资源的独占" class="headerlink" title="用锁来实现对资源的独占"></a>用锁来实现对资源的独占</h3><p>Ruby Mutex类，互斥锁。<br>Java中，方法定义声明为synchronize,该方法被调用时自动加锁。</p><h3 id="二级互斥"><a href="#二级互斥" class="headerlink" title="二级互斥"></a>二级互斥</h3><p>很遗憾，锁的问题并不全是Mutex所能覆盖的单纯事例。如数据库中，对数据的访问需要以下多种互斥控制。</p><ol><li>可以同时引用</li><li>禁止同时更新</li><li>禁止更新中引用</li><li>禁止引用中更新</li></ol><p>引用与更新这种两个层次的互斥（二级互斥），在文件读取时也经常会发生。</p><hr><p><strong>数据库锁总结</strong></p><p>数据库锁出现的原因是为了处理并发问题，因为数据库是一个多用户共享的资源，当出现并发的时候，就会导致出现各种各样奇怪的问题，就像程序代码一样，出现多线程并发的时候，如果不做特殊控制的话，就会出现意外的事情，比如“脏“数据、修改丢失等问题。所以数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制，所以数据库锁是跟并发控制和事务联系在一起的。</p><p>平时会经常看到或者听到数据库锁有“共享锁”，“排它锁”，“互斥锁”，“写锁”，“读锁”，“悲观锁”，“乐观锁”，“行级锁”，“表级锁”，“页级锁”等，同时我们还会常看到“丢失修改“，”不可重复读“，”读脏数据“这三个术语，他们究竟是什么关系以及怎么理解呢，下面就来介绍一下他们。</p><p>先说事务的特性，要想成为事务，必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；一致性指的是事务的执行结果必须是使数据库从一个一致性状态变大另一个一致性状态，一致性和原子性是密切相关的；隔离性指的是一个事务执行不能被其他事务干扰；持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。</p><p>先说悲观锁和乐观锁吧。并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。乐观锁就比较简单了，就是不做控制，这只是一部分人对于并发所持有的一种态度而已。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁和共享锁，其中排它锁又称为写锁，共享锁又称为读锁。</p><p>共享锁和排它锁是具体的锁，是数据库机制上的锁，存在以下关系：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%882.17.40.png" alt="屏幕快照 2018-07-20 下午2.17.40" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午2.17.40</div>            </figure></p><p>(x表示是排它锁(Exclusive)，s表示共享锁(Share)，Y表示yes，N表示no）</p><p>上图表示可以共存的锁，如，第二行表示，一个事务T1给某数据加了X锁，则事务T2就不能再给那数据加X锁了，同时也不能再加S锁了，只有到T1事务提交完成之后，才可以。默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁。<br>另外，并发操作会导致数据的不一致性，主要包括“丢失数据”，“不可重复读”，“读脏数据等。还有就是，并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防，预防的方法有：1一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；2顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。另外，系统如何判断出现死锁呢，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁，诊断和判断死锁有两种方法，一是超时法，二是等待图法。超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。</p><p>最后，说下行级锁和表级锁。锁包括行级锁和表级锁<br>行级锁是一种排他锁，防止其他事务修改此行。</p><hr><h3 id="用队列协调线程"><a href="#用队列协调线程" class="headerlink" title="用队列协调线程"></a>用队列协调线程</h3><p>使用锁对资源进行互斥控制，是线程间保证协调的一种机制。除了锁以外，为了保证协调，还有别的方法。<br>问题的根源在于多个进程访问同一资源，为了实现无共享，给每个资源准备一个管理用的线程，各线程间只能交换某些限定的信息。<br>线程间信息交换的方法有代表性的有信息存储，信道及队列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.05.36.png" alt="屏幕快照 2018-07-20 下午3.05.36" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.05.36</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的生产者消费者问题并不是典型的生成者消费者问题，而是做出了一定的限制，即生产速度小于消费速度。不锁buffer,仅做信息传递的通道来进行说明。</span><br></pre></td></tr></table></figure><p>队列也可以用于解决资源的竞争。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.08.13.png" alt="屏幕快照 2018-07-20 下午3.08.13" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.08.13</div>            </figure></p><h3 id="锁模型与队列模型的比较"><a href="#锁模型与队列模型的比较" class="headerlink" title="锁模型与队列模型的比较"></a>锁模型与队列模型的比较</h3><h4 id="锁模型"><a href="#锁模型" class="headerlink" title="锁模型"></a>锁模型</h4><p>如果竞争足够少，多数情况下能保持较高性能，对于资源的竞争，不能忘记加锁，要做到完美无缺较难。</p><h4 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h4><p>在竞争少的时候，其性能比不上锁模型，比锁模型更容易贯彻，会因线程增多而带来性能低下的恶果。</p><h2 id="前景可期的并行编程技术，Actor"><a href="#前景可期的并行编程技术，Actor" class="headerlink" title="前景可期的并行编程技术，Actor"></a>前景可期的并行编程技术，Actor</h2><p>并行编程，要求有更高的抽象度和对人类而言更简单的编程模型。Actor（参与者模式）或许就是答案。</p><h3 id="何谓Actor"><a href="#何谓Actor" class="headerlink" title="何谓Actor"></a>何谓Actor</h3><p>所谓Actor，是（仅）通过消息（message）进行通信的实体。<br>与面向对象语言中对象的区别。向对象发送消息（方法调用），调用开始后，会一直等到返回结果，是一种同步方式。面向Actor发送消息，仅仅是发送消息而不返回结果，是一种异步方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步(Synchronous)和异步(Asynchronous)</span><br><span class="line">1.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</span><br><span class="line">2.异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。</span><br></pre></td></tr></table></figure></p><p>Actor由于仅仅通过消息进行信息交换，所以不能直接共享同一个值，信息传达要多花些代价。<br>Actor由于没有消息以外的信息传递手段，所以不用担心Actor之间的资源竞争。发送给Actor的消息都配送到各个Actor所拥有的邮箱里。多个消息同时到达时竞争由内嵌到系统中的排除机制来处理。<br>Actor的一大优点是安全，更大的优点是易懂。Actor根据消息进行处理，必要的化会向其他Actor传递消息，或向Actor返回消息。<br>这与现实世界中人与人之间相处没有多大的差别。现实世界中，别人在想什么你不知道，想要求什么时，需要通过某种手段传递“消息”。<br>理论上要到达最高性能，一般认为线程更优秀。但如果不注意使用线程的话，会出现与时机相关的很麻烦的问题。在计算机性能日益提高的今天，与理论上最高性能的可能性相比，Actor的安全性和易懂性更引人注目。</p><h3 id="操作Actor的三种处理系统"><a href="#操作Actor的三种处理系统" class="headerlink" title="操作Actor的三种处理系统"></a>操作Actor的三种处理系统</h3><p>Actor Model的函数型语言Erlang。<br>Erlang是只允许单一赋值的函数型语言，即一旦赋值，变量的值就不再改变。</p><h3 id="Erlang的程序"><a href="#Erlang的程序" class="headerlink" title="Erlang的程序"></a>Erlang的程序</h3><h3 id="pingpong处理的开始"><a href="#pingpong处理的开始" class="headerlink" title="pingpong处理的开始"></a>pingpong处理的开始</h3><h3 id="启动pingpong程序"><a href="#启动pingpong程序" class="headerlink" title="启动pingpong程序"></a>启动pingpong程序</h3><h3 id="Erlang的错误处理"><a href="#Erlang的错误处理" class="headerlink" title="Erlang的错误处理"></a>Erlang的错误处理</h3><p>Erlang中通过发送消息来通知异常终止。收到消息的process（actor）料理死去的process后事。<br>有了这种机制，使得Erlang适合构造抗障碍性强的系统。</p><h3 id="Erlang的使用场所"><a href="#Erlang的使用场所" class="headerlink" title="Erlang的使用场所"></a>Erlang的使用场所</h3><p>Erlang在通常的文本处理汇总并不怎么快。Erlang的好处在于其扩展性。对于多个处理并列执行的情况，分割成合适的Erlang process，能够发挥多CPU的威力。<br>同样的多任务分割虽然用操作系统的进程或线程也能实现，但Erlang的process与操作系统的进程或线程相比，能够轻量实现（1个process最小只耗费300字节），即使有大量process也不必顾虑、更进一步说，Erlang设计思想不用process连基本处理都不能实现，process分割在某种意义上可以说是强制的。</p><p>适合现代服务器端程序。</p><h3 id="面向Ruby的库“Revactor”"><a href="#面向Ruby的库“Revactor”" class="headerlink" title="面向Ruby的库“Revactor”"></a>面向Ruby的库“Revactor”</h3><p>Revactor的目的是为Ruby提供Erlang式的编程。<br>其优点是可以同时体验Ruby和Erlang的好处。但是Revactor中Actor的实现不是靠线程而是靠Fiber。Erlang的目的在于最大限度地利用多核CPU，而Revactor并不适合这种目的。<br>Revactor的最大优点，是能够在等待文件输入输出时，将程序的停止控制在最小程度。</p><h3 id="另一个库Dramatis"><a href="#另一个库Dramatis" class="headerlink" title="另一个库Dramatis"></a>另一个库Dramatis</h3><p>Dramatis是Ruby中另一个Actor库。函数型语言Erlang不支持面向对象功能。用Ruby这样的面向对象语言来实现Actor的时候，即使用普通对象来实现Actor，也不可避免地会出现把方法调用和发送消息这两种类似概念混在一起的情况。Dramatis库就是解答这种“概念混淆”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-10-高速执行和并行处理&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-10-高速执行和并行处理&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 10 高速执行和并行处理&quot;&gt;&lt;/a&gt;松本行弘的程序世界 10 高速执行和并行
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 3 Android控件架构与自定义控件详解</title>
    <link href="https://github.com/zdkswd/2018/07/18/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%203%20Android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/zdkswd/2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/</id>
    <published>2018-07-18T07:27:32.000Z</published>
    <updated>2018-07-18T09:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-3-Android控件架构与自定义控件详解"><a href="#Android群英传-3-Android控件架构与自定义控件详解" class="headerlink" title="Android群英传 3 Android控件架构与自定义控件详解"></a>Android群英传 3 Android控件架构与自定义控件详解</h1><h2 id="Android控件架构"><a href="#Android控件架构" class="headerlink" title="Android控件架构"></a>Android控件架构</h2><p>控件大致被分为两类，即ViewGroup控件与View控件。<br>通过ViewGroup，整个界面的控件形成了一个树形结构控件树。上层控件负责下层子控件的测量与绘制，并传递交互事件。findViewById（）方法，就是在控件树以数<strong>深度优先</strong>来遍历查找对应的元素。<br>每颗控件树的顶部，都有一个ViewParent对象，为整棵树的控制核心，所有的交互管理事件都由它统一调度和分配，从而可以对整个视图进行整体控制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.31.03.png" alt="屏幕快照 2018-07-17 下午2.31.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.31.03</div>            </figure><br>通常，在Activity中使用setContentView（）方法来设置一个布局，在调用该方法后，布局内容才真正的显示出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.36.21.png" alt="屏幕快照 2018-07-17 下午2.36.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.36.21</div>            </figure><br>每个Activity都包含一个Window对象，由PhoneWindow来实现。PhoneWindow将一个DecorView设置为整个应用窗口的根View。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通用方法。DecorView将要显示的具体方法呈现在PhoneWindow上，这里面的所有View的监听事件通过<strong>WindowManageService</strong>来进行验收，并通过Activity对象来回调相应的onClickListener。<br>在显示上，它将屏幕分为两部分，TitleView和ContentView。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.45.14.png" alt="屏幕快照 2018-07-17 下午2.45.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.45.14</div>            </figure><br>其中ViewGroup会根据对应参数设置不同的布局，如最常用的布局。而如果用户通过设置requestWindowFeature(Window.FEATURE_NO_TITLE)来设置全屏显示，视图树中的布局就只有Content了，这就解释了为什么调用requestWindowFeature()方法一定要在调用setContentView()方法之前才能生效的原因。<br>在代码中，当程序在onCreate（）方法中调用setContentView（）方法后，ActivityManagerService会回调onResume（）方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。</p><h2 id="View的测量"><a href="#View的测量" class="headerlink" title="View的测量"></a>View的测量</h2><p>系统在绘制View前，必须对View进行测量，即告诉系统该画一个多大的View，在onMeasure（）方法中进行。<br>通过系统提供的设计精悍功能强大的类<strong>MeasureSpec</strong>类来测量View。MeasureSpec为32位int值，高2位位测量的模式，低30位为测量的大小，在计算中使用位运算是为了提高并优化效率。<br>测量模式为3种：</p><ol><li>EXACTLY<br>即精确值模式，当我们将控件的layout_width或layout_height属性指定为具体数值时，或指定为match_parent属性时（占据父View的大小），系统使用的是EXACTLY模式。</li><li>AT_MOST<br>即最大值模式，当控件的layout_width或layout_height属性指定为wrap_content时，控件大小一般岁总监的子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。</li><li>UNSPECIFID<br>不指定大小测量模式，View想多大就多大，通常情况下在绘制自定义View时才会使用。</li></ol><p>View类默认的onMeasure（）方法只支持EXACTLY模式，所以如果自定义控件时不重写onMeasure方法的话，就只能使用EXACTLY模式。控件可以响应你指定的具体宽高值或是match_parent属性。而如果要让自定义View支持<strong>wrap_content</strong>属性，那么就必须重写onMeasure（）方法来指定wrap_content时的大小，如果不重写，就不知道该使用默认多大的尺寸，因此，就会默认填充整个父布局，所以重写onMeasure（）方法的目的，就是为了能够给View一个wrap_content属性下的默认大小。</p><h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>测量好一个View后，我们就可以重写onDraw（）方法，在Canvas对象上来绘制所需要的图形。<br>当创建一个Canvas对象时，需要传进去一个bitmap对象。这个bitmap用来存储所有绘制在Canvas上的像素信息。调用所有的Canvas.drawXXX方法都发生在这个bitmap上。</p><p>##ViewGroup的测量<br>ViewGroup会去管理子View，就有负责子View的显示大小。当ViewGroup大小为wrap_content时，就需要对子View进行遍历，以获得所有子View的大小，从而决定自己的大小。其他模式则会通过具体的指定值来设置自身的大小。<br>ViewGroup在测量时通过遍历所有的子View，从而调用View的Measure方法来获得每一个子View的测量结果。<br>当子View测量完毕时，就需要将子View放到合适的位置，这个过程就是View的Layout过程。ViewGroup在执行Layout过程时，同样是使用遍历来调用子View的Layout方法，并制定其具体显示的位置从而来决定其布局位置。<br>在定义ViewGroup时，通常会重写onLayout方法来控制其子View显示位置的逻辑。同样，如果要支持wrap_content属性，必须重写onMeasure。</p><h2 id="ViewGroup的绘制"><a href="#ViewGroup的绘制" class="headerlink" title="ViewGroup的绘制"></a>ViewGroup的绘制</h2><p>ViewGroup通常不需要绘制，如果不是指定了ViewGroup的背景颜色，ViewGroup的onDraw方法都不会被调用，但是，ViewGroup会使用dispatchDraw()方法来绘制其子View，其过程同样是通过遍历所有的子View，并调用子View绘制方法来完成绘制。</p><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><p>在自定义View时，我们通常会去重写onDraw()来绘制View的显示内容，如果该View还需要使用wrap_content属性，那么还必须重写onMeasure()方法。另外，通过自定义attrs属性，还可以设置新的属性配置值。<br>在View中通常有以下一些比较重要的回调方法。</p><ul><li>onFinishInflate():从XML加载组件后回调。</li><li>onSizeChanged():组件大小改变时回调。</li><li>onMeasure():回调该方法来进行测量。</li><li>onLayout():回调该方法来确定显示的位置。</li><li>onTouchEvent():监听到触摸事件时回调。</li></ul><p>通常有以下方法来实现自定义的控件。</p><ul><li>对现有控件进行扩展。 </li><li>通过组合来实现新的控件。</li><li>重写View来实现全新的控件。 </li></ul><h3 id="对现有控件进行扩展"><a href="#对现有控件进行扩展" class="headerlink" title="对现有控件进行扩展"></a>对现有控件进行扩展</h3><p>可以再onDraw()方法中对原生控件行为进行扩展。<br>程序调用super.onDraw(canvas)方法来实现原生控件的功能。</p><h3 id="创建复合控件"><a href="#创建复合控件" class="headerlink" title="创建复合控件"></a>创建复合控件</h3><p>创建复合控件可以很好地创建出具有重用功能的控件集合。这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，再给它添加指定功能的控件，从而组合成新的复合控件。通过这种方式创建的控件，我们一般会给它指定一些可配置的属性，让它具有更强的扩展性。</p><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><p>为一个View提供可自定义的属性非常简单，只需要在res资源目录的values目录下创建一个attrs.xml的属性定义文件，并在该文件中通过代码定义相应的属性即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.04.48.png" alt="屏幕快照 2018-07-17 下午5.04.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.04.48</div>            </figure></p><p>在代码中通过&lt; declare-styleable&gt;标签声明了使用自定义属性，通过name属性来确定引用的名称。通过&lt; attr&gt;标签来声明具体的自定义属性。通过format属性来指定属性的类型。<br>在确定好属性后，就可以创建一个自定义控件，让它继承自ViewGroup，从而组合一些需要的控件。在构造方法中，通过TypedArray对象的getString()和getColor()等方法，就可以获取这些定义的属性值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.11.26.png" alt="屏幕快照 2018-07-17 下午5.11.26" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.11.26</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.12.42.png" alt="屏幕快照 2018-07-17 下午5.12.42" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.12.42</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.13.03.png" alt="屏幕快照 2018-07-17 下午5.13.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.13.03</div>            </figure><p>当获取完所有的属性值后，需要调用TypedArray的recyle方法来完成资源的回收。</p><h4 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h4><p>通过动态添加控件的方式，使用addView（）方法将控件加入到模板中，并给它们设置前面所获取到的具体的属性值，如文字颜色、大小等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.16.29.png" alt="屏幕快照 2018-07-17 下午5.16.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.16.29</div>            </figure></p><p>定义接口<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.21.03.png" alt="屏幕快照 2018-07-17 下午5.21.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.21.03</div>            </figure></p><p>暴露接口给调用者<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.25.21.png" alt="屏幕快照 2018-07-17 下午5.25.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.25.21</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.25.46.png" alt="屏幕快照 2018-07-17 下午5.25.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.25.46</div>            </figure><p>实现接口回调<br>在调用者的代码中，调用者需要实现这样一个接口，并完成接口中的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.28.58.png" alt="屏幕快照 2018-07-17 下午5.28.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.28.58</div>            </figure></p><p>除了通过接口回调的方式来动态的控制UI模板，同样可以使用公共方法来动态地修改UI模板中的UI。这样可以进一步提高模板的可定制性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.31.54.png" alt="屏幕快照 2018-07-17 下午5.31.54" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.31.54</div>            </figure></p><h4 id="引用UI模板"><a href="#引用UI模板" class="headerlink" title="引用UI模板"></a>引用UI模板</h4><p>在需要使用的地方引用UI模板，在引用前，需要指定第三方控件的命名空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.33.56.png" alt="屏幕快照 2018-07-17 下午5.33.56" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.33.56</div>            </figure><br>这行代码就是在指定引用的命名空间xmlns，即xml namespace。这里指定了名字空间为“android”，因此在接下来使用系统属性时，才可以使用“android:”来引用Android的系统属性。如果要使用自定义的属性，就需要创建自己的名字空间。在Android Studio中，第三方的控件都使用如下代码来引入名字空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.39.45.png" alt="屏幕快照 2018-07-17 下午5.39.45" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.39.45</div>            </figure><br>这里我们将引入的第三方控件的名字空间取名为custom，之后再xml文件中使用自定义的属性时，就可以通过这个名字空间来引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.41.56.png" alt="屏幕快照 2018-07-17 下午5.41.56" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.41.56</div>            </figure><br>使用自定义的View与系统原生的View的最大区别就是在申明控件时，需要指定完整的包名，而在引用自定义的属性时，需要使用自定义的xmls名字。<br>再更进一步，将这个UI模板写到一个布局文件中，在其他的布局文中，直接通过&lt; include&gt;标签来引用这个UI模板的View。</p><h3 id="重写View来实现全新的控件"><a href="#重写View来实现全新的控件" class="headerlink" title="重写View来实现全新的控件"></a>重写View来实现全新的控件</h3><p>当Android系统原生的控件无法满足我们的需求时，我们就可以完全创建一个新的自定义View来实现需要的功能。通常需要继承View类，重写onDraw，onMeasure来实现绘制逻辑，同时重写onTouchEvent等触控时间来实现交互逻辑。还可以像实现组合控件那样，通过引入自定义属性，丰富自定义View的可定制性。</p><h4 id="弧线展示图"><a href="#弧线展示图" class="headerlink" title="弧线展示图"></a>弧线展示图</h4><h4 id="音频条形图"><a href="#音频条形图" class="headerlink" title="音频条形图"></a>音频条形图</h4><h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><p>重写onMeasure来对子View进行测量，重写onLayout确定子View的位置，重写onTouchEvent增加响应事件。</p><h2 id="事件拦截机制分析"><a href="#事件拦截机制分析" class="headerlink" title="事件拦截机制分析"></a>事件拦截机制分析</h2><p>Android为触摸事件封装了一个类MotionEvent，里面封装了触摸点的坐标，点击事件的类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.08.26.png" alt="屏幕快照 2018-07-18 下午3.08.26" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.08.26</div>            </figure><br>对于ViewGroup重写了三个方法：<br><strong>dispatchTouchEvent</strong><br><strong>onInterceptTouchEvent</strong><br><strong>onTouchEvent</strong><br>对于View来说，重写了两个方法：<br><strong>onTouchEvent</strong><br><strong>dispatchTouchEvent</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.12.38.png" alt="屏幕快照 2018-07-18 下午3.12.38" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.12.38</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.12.47.png" alt="屏幕快照 2018-07-18 下午3.12.47" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.12.47</div>            </figure><br><strong>dispatchTouchEvent</strong>基本不用动。<br>事件拦截的核心方法是<strong>onInterceptTouchEvent</strong>返回值：True，拦截，不继续；False，不拦截，继续流程。<br>事件处理<strong>onTouchEvent</strong>返回值：True，处理了，不用给上级汇报了，上级不会继续处理了；False，给上级处理。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.20.48.png" alt="屏幕快照 2018-07-18 下午3.20.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.20.48</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-3-Android控件架构与自定义控件详解&quot;&gt;&lt;a href=&quot;#Android群英传-3-Android控件架构与自定义控件详解&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 3 Android控件架构与自定义
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 2 Android开发工具新接触</title>
    <link href="https://github.com/zdkswd/2018/07/14/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%202%20Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%96%B0%E6%8E%A5%E8%A7%A6/"/>
    <id>https://github.com/zdkswd/2018/07/14/Android群英传 2 Android开发工具新接触/</id>
    <published>2018-07-14T04:18:32.000Z</published>
    <updated>2018-07-14T04:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-2-Android开发工具新接触"><a href="#Android群英传-2-Android开发工具新接触" class="headerlink" title="Android群英传 2 Android开发工具新接触"></a>Android群英传 2 Android开发工具新接触</h1><h2 id="Android开发IDE介绍"><a href="#Android开发IDE介绍" class="headerlink" title="Android开发IDE介绍"></a>Android开发IDE介绍</h2><h2 id="ADB命令使用技巧"><a href="#ADB命令使用技巧" class="headerlink" title="ADB命令使用技巧"></a>ADB命令使用技巧</h2><p>ADB–Android Debug Bridge，借助此工具，我们可以用电脑来操作手机。</p><h3 id="ADB基础"><a href="#ADB基础" class="headerlink" title="ADB基础"></a>ADB基础</h3><p>ADB工具位于SDK的platform-tools目录下。<br>手机助手也是使用ADB来实现它的功能。<br>手机端需要开发者模式，USB Debug。</p><h4 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h4><p>可以使用Linux Shell命令。</p><h4 id="android-list-targets"><a href="#android-list-targets" class="headerlink" title="android list targets"></a>android list targets</h4><p>显示系统中全部Android平台</p><h4 id="adb-install-r-程序-apk"><a href="#adb-install-r-程序-apk" class="headerlink" title="adb install -r 程序.apk"></a>adb install -r 程序.apk</h4><p>安装apk程序之install</p><h4 id="abd-push-lt-local-gt-lt-remote-gt"><a href="#abd-push-lt-local-gt-lt-remote-gt" class="headerlink" title="abd push &lt; local&gt; &lt; remote&gt;"></a>abd push &lt; local&gt; &lt; remote&gt;</h4><p>安装apk程序之push<br>两者都可以安装上APK，但是install是安装到data/data目录中，作为普通的用户应用程序。push则不是安装命令，是将文件写入手机的存储系统，所以，只要拥有相应的权限，就可以把任何Apk放到任何目录中，甚至是System目录下成为一个系统应用程序。</p><h4 id="abd-push-lt-local-gt-lt-remote-gt-1"><a href="#abd-push-lt-local-gt-lt-remote-gt-1" class="headerlink" title="abd push &lt; local&gt; &lt; remote&gt;"></a>abd push &lt; local&gt; &lt; remote&gt;</h4><p>向手机写入文件</p><h4 id="abd-pull-lt-local-gt-lt-remote-gt"><a href="#abd-pull-lt-local-gt-lt-remote-gt" class="headerlink" title="abd pull &lt; local&gt; &lt; remote&gt;"></a>abd pull &lt; local&gt; &lt; remote&gt;</h4><p>从手机获取文件。<br>这些东西在Android Device Monitor工具都可以直接使用。</p><h4 id="通过Logcat来查看Log"><a href="#通过Logcat来查看Log" class="headerlink" title="通过Logcat来查看Log"></a>通过Logcat来查看Log</h4><h4 id="删除应用"><a href="#删除应用" class="headerlink" title="删除应用"></a>删除应用</h4><h4 id="查看系统盘符"><a href="#查看系统盘符" class="headerlink" title="查看系统盘符"></a>查看系统盘符</h4><h4 id="输出所有已经安装的应用"><a href="#输出所有已经安装的应用" class="headerlink" title="输出所有已经安装的应用"></a>输出所有已经安装的应用</h4><h4 id="模拟按键输入"><a href="#模拟按键输入" class="headerlink" title="模拟按键输入"></a>模拟按键输入</h4><h4 id="模拟滑动输入"><a href="#模拟滑动输入" class="headerlink" title="模拟滑动输入"></a>模拟滑动输入</h4><h4 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h4><h4 id="Package管理信息"><a href="#Package管理信息" class="headerlink" title="Package管理信息"></a>Package管理信息</h4><h4 id="AM管理信息"><a href="#AM管理信息" class="headerlink" title="AM管理信息"></a>AM管理信息</h4><h4 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h4><h4 id="重新启动"><a href="#重新启动" class="headerlink" title="重新启动"></a>重新启动</h4><h3 id="ADB命令来源"><a href="#ADB命令来源" class="headerlink" title="ADB命令来源"></a>ADB命令来源</h3><h2 id="模拟器使用与配置"><a href="#模拟器使用与配置" class="headerlink" title="模拟器使用与配置"></a>模拟器使用与配置</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-2-Android开发工具新接触&quot;&gt;&lt;a href=&quot;#Android群英传-2-Android开发工具新接触&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 2 Android开发工具新接触&quot;&gt;&lt;/a&gt;Andro
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 1 Android体系与系统架构</title>
    <link href="https://github.com/zdkswd/2018/07/14/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%201%20Android%E4%BD%93%E7%B3%BB%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>https://github.com/zdkswd/2018/07/14/Android群英传 1 Android体系与系统架构/</id>
    <published>2018-07-14T03:01:32.000Z</published>
    <updated>2018-07-14T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-1-Android体系与系统架构"><a href="#Android群英传-1-Android体系与系统架构" class="headerlink" title="Android群英传 1 Android体系与系统架构"></a>Android群英传 1 Android体系与系统架构</h1><h2 id="Google生态系统"><a href="#Google生态系统" class="headerlink" title="Google生态系统"></a>Google生态系统</h2><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15315306518029/2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d.jpg" alt="2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d" title="">                </div>                <div class="image-caption">2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d</div>            </figure><p>这些层次结构即是相互独立的，又是相互关联的。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux层(仅为Linux内核)，Android最底层最核心的部分。显示内核版本，就是显示所用的Linux<strong>内核</strong>的版本。Linux层包含了Android系统的核心服务，包括硬件驱动，进程管理，安全系统等等。</p><h3 id="Dalvik与ART"><a href="#Dalvik与ART" class="headerlink" title="Dalvik与ART"></a>Dalvik与ART</h3><p>Dalvik包含了一整套Android运行环境虚拟机，每个App都会分配Dalvik虚拟机来保证互相之间不受干扰，并保持独立，特点是在运行时编译。<br>在Android 5.x开始，ART模式已经取代了Dalvik，ART是安装时进行编译，在运行时就不用编译了。</p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>见上图</p><h3 id="Standard-libraries"><a href="#Standard-libraries" class="headerlink" title="Standard libraries"></a>Standard libraries</h3><p>见上图</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>不管是使用NDK开发还是Java开发的App，都有Android Manifest文件、Dalvik Classes、Resource Bundle这些东西。</p><h2 id="Android-App组件架构"><a href="#Android-App组件架构" class="headerlink" title="Android App组件架构"></a>Android App组件架构</h2><p>即四大组件：Activity、BroadCastReciever、ContentProvider和Service。它们是组成一个Android App的最基本元素。</p><h3 id="Android四大组件如何协同工作"><a href="#Android四大组件如何协同工作" class="headerlink" title="Android四大组件如何协同工作"></a>Android四大组件如何协同工作</h3><p>Activity作为人机交互的第一界面，负责向用户展示和处理结果，信息的来源可以是通过资源获取，也可以是通过Content Provider来获取其他应用的信息，或是Service从后台计算，下载，处理后的结果，也可以是通过BroadCast Reciever获取到广播信息。同时，Android系统还提供了一个信使Intent，作为信息传递的载体。组件与组件之间通过Intent来通信、传递信息、交换数据，正是通过这样一种方式，四大组件形成了各自独立而又紧密联系的关系。</p><h3 id="应用运行上下文对象"><a href="#应用运行上下文对象" class="headerlink" title="应用运行上下文对象"></a>应用运行上下文对象</h3><p>Android系统上下文对象即Context，Activity、Service、Application都是继承自Context。<br>Android应用程序会在几个时间点创建应用上下文Context。</p><ol><li>创建Application</li><li>创建Activity</li><li>创建Service</li></ol><p>创建Context的时机就是在创建Context的实现类时。</p><h2 id="Android系统源代码目录与系统目录"><a href="#Android系统源代码目录与系统目录" class="headerlink" title="Android系统源代码目录与系统目录"></a>Android系统源代码目录与系统目录</h2><p>Android系统源代码目录包含了Android系统所有的源代码，从底层驱动到上层应用，Android系统对所有文件都进行了详细管理。在手机中，Android系统的目录和源代码目录不是一一对应的，与源代码编译后，与打包生成的Image文件的结构相同。</p><h3 id="Android系统源代码目录"><a href="#Android系统源代码目录" class="headerlink" title="Android系统源代码目录"></a>Android系统源代码目录</h3><p>看完Android源代码，要懂C、懂脚本、懂Java。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15315306518029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-14%20%E4%B8%8A%E5%8D%8810.18.18.png" alt="屏幕快照 2018-07-14 上午10.18.18" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-14 上午10.18.18</div>            </figure><br>应注意，不是所有的源代码结构都是这样。只有AOSP的Android项目才是这样的结构，有些芯片厂家如MTK目录结构就不同。<br>Android源码采用Makefile编译。<br>像Android这样的大型项目，它的源代码不计其数，不同的功能，模块，按类型分别放置在不同的目录中，这些模块通常会有Makefile文件进行管理。它定义了一系列的规则来指定模块，哪些文件需要编译，以及这些文件该按照怎演的顺序去编译。甚至可以配置更复杂的功能操作，比如定义编译规则，打包规则，Makefile就像一个shell脚本，不仅可以使用自己的语法，也能调用操作系统的命令。<br>Android系统源代码目录每个目录中还会包含更多的目录，而它的每一个最小的功能单位的目录下，都会有一个Makefile文件，这样每一级向上，通过一个个Makefile文件，就把整个源代码有条不紊的联系在一起了。</p><h3 id="Android系统目录"><a href="#Android系统目录" class="headerlink" title="Android系统目录"></a>Android系统目录</h3><p>通过ADB连上手机，通过Linux的ls命令查看Android系统的根目录。其中/system和/data是开发者非常关心的两个目录。</p><h4 id="system-app"><a href="#system-app" class="headerlink" title="/system/app/"></a>/system/app/</h4><p>这里面放的是一些系统的App</p><h4 id="system-bin"><a href="#system-bin" class="headerlink" title="/system/bin/"></a>/system/bin/</h4><p>这里面主要放的是Linux自带的组件</p><h4 id="system-build-prop"><a href="#system-build-prop" class="headerlink" title="/system/build.prop"></a>/system/build.prop</h4><p>这里记录的是系统的属性信息。</p><h4 id="system-fonts"><a href="#system-fonts" class="headerlink" title="/system/fonts/"></a>/system/fonts/</h4><p>系统字体存放的目录root后可下载TTF格式字体替代原字体。</p><h4 id="system-framework"><a href="#system-framework" class="headerlink" title="/system/framework/"></a>/system/framework/</h4><p>系统的核心文件，架构层。</p><h4 id="system-lib"><a href="#system-lib" class="headerlink" title="/system/lib/"></a>/system/lib/</h4><p>存放几乎所有的共享库（.so）文件。</p><h4 id="system-media"><a href="#system-media" class="headerlink" title="/system/media/"></a>/system/media/</h4><p>该目录用来保存系统提示音、系统铃声。</p><h4 id="system-usr"><a href="#system-usr" class="headerlink" title="/system/usr/"></a>/system/usr/</h4><p>该目录用来保存用户的配置文件，如键盘布局、共享、时区文件等。</p><h4 id="data-app"><a href="#data-app" class="headerlink" title="/data/app/"></a>/data/app/</h4><p>data目录包含了用户大部分数据信息。app目录下包含了用户安装的App或者升级的App。</p><h4 id="data-data"><a href="#data-data" class="headerlink" title="/data/data/"></a>/data/data/</h4><p>这个目录应该是开发者访问最多的目录了，这里包含了App的数据信息，文件信息、数据库信息等，以包名的方式来区分各个应用。</p><h4 id="data-system"><a href="#data-system" class="headerlink" title="/data/system/"></a>/data/system/</h4><p>这个目录包含了手机的各项系统信息。</p><h4 id="data-misc"><a href="#data-misc" class="headerlink" title="/data/misc/"></a>/data/misc/</h4><p>这个目录保存了大部分的WiFi、VPN信息。</p><h3 id="Android-App文件目录"><a href="#Android-App文件目录" class="headerlink" title="Android App文件目录"></a>Android App文件目录</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-1-Android体系与系统架构&quot;&gt;&lt;a href=&quot;#Android群英传-1-Android体系与系统架构&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 1 Android体系与系统架构&quot;&gt;&lt;/a&gt;Andro
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 9 整数和浮点小数</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%209%20%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E5%B0%8F%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 9 整数和浮点小数/</id>
    <published>2018-07-12T09:41:32.000Z</published>
    <updated>2018-07-12T09:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-9-整数和浮点小数"><a href="#松本行弘的程序世界-9-整数和浮点小数" class="headerlink" title="松本行弘的程序世界 9 整数和浮点小数"></a>松本行弘的程序世界 9 整数和浮点小数</h1><h2 id="深奥的整数世界"><a href="#深奥的整数世界" class="headerlink" title="深奥的整数世界"></a>深奥的整数世界</h2><h3 id="整数是有范围的"><a href="#整数是有范围的" class="headerlink" title="整数是有范围的"></a>整数是有范围的</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%884.23.38.png" alt="屏幕快照 2018-07-12 下午4.23.38" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午4.23.38</div>            </figure><h3 id="尝试位运算"><a href="#尝试位运算" class="headerlink" title="尝试位运算"></a>尝试位运算</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%884.24.58.png" alt="屏幕快照 2018-07-12 下午4.24.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午4.24.58</div>            </figure><h3 id="操作特定的位"><a href="#操作特定的位" class="headerlink" title="操作特定的位"></a>操作特定的位</h3><p>位运算组合起来，可以对存储在计算机中的各位进行自由操作。<br>操作二进制位就等于操作计算机的数据。<br>基本的位处理操作有4种。</p><ol><li>取出特定位的状态</li><li>特定位置位（设为1）</li><li>特定位清零（设为0）</li><li>特定位反转</li></ol><p>将操作限制在特定位的数为掩码。</p><h3 id="表示负数的办法"><a href="#表示负数的办法" class="headerlink" title="表示负数的办法"></a>表示负数的办法</h3><ol><li>开头一位做符号位</li><li>将整数的各位反转（1的补数）</li></ol><h3 id="Ruby的整数"><a href="#Ruby的整数" class="headerlink" title="Ruby的整数"></a>Ruby的整数</h3><p>Ruby的整数有两种，一种是范围有限制的整数Fixnum（32位CPU是31位，64位CPU是63位），另一种是范围没有限制（超过内存容量除外）的整数Bignum，根据计算结果自动变换。</p><h3 id="挑战公开密钥方式"><a href="#挑战公开密钥方式" class="headerlink" title="挑战公开密钥方式"></a>挑战公开密钥方式</h3><p>RSA加密的强度（解读的困难程度），就归因于素因数分解的难度。</p><h2 id="扑朔迷离的浮点小数世界"><a href="#扑朔迷离的浮点小数世界" class="headerlink" title="扑朔迷离的浮点小数世界"></a>扑朔迷离的浮点小数世界</h2><h3 id="计算机对小数的处理"><a href="#计算机对小数的处理" class="headerlink" title="计算机对小数的处理"></a>计算机对小数的处理</h3><h3 id="固定小数点数不易使用"><a href="#固定小数点数不易使用" class="headerlink" title="固定小数点数不易使用"></a>固定小数点数不易使用</h3><p>浮点数，就是小数点的位置可以移动。</p><h3 id="科学计数法也有问题"><a href="#科学计数法也有问题" class="headerlink" title="科学计数法也有问题"></a>科学计数法也有问题</h3><p>计算机中广泛使用的小数表示方法是科学计数法。科学计数法是指将有效数字和指数组合起来表示小数（实数）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%885.01.23.png" alt="屏幕快照 2018-07-12 下午5.01.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午5.01.23</div>            </figure><p><strong>IEEE754规定，尾数部分的首位始终归一化为1，所以首位始终省略，实质有效数字为53位。</strong></p><h3 id="小数不能完全表示"><a href="#小数不能完全表示" class="headerlink" title="小数不能完全表示"></a>小数不能完全表示</h3><ol><li>计算机中的数的表示有长度（位数）限制。</li><li>计算机中数的表示是二进制。</li></ol><h4 id="浮点数是有限的"><a href="#浮点数是有限的" class="headerlink" title="浮点数是有限的"></a>浮点数是有限的</h4><h4 id="浮点数有误差"><a href="#浮点数有误差" class="headerlink" title="浮点数有误差"></a>浮点数有误差</h4><h4 id="对于浮点小数，结合法不成立"><a href="#对于浮点小数，结合法不成立" class="headerlink" title="对于浮点小数，结合法不成立"></a>对于浮点小数，结合法不成立</h4><h3 id="有不能比较的时候"><a href="#有不能比较的时候" class="headerlink" title="有不能比较的时候"></a>有不能比较的时候</h3><p>对于浮点数进行比较运算，只有两个数在内部表示是完全相同的情况下才判定为相等。作为铁则，两个浮点数不能用==进行比较运算。如果有进行比较的必要，判断条件中的两个数的差要足够小。根据操作系统的不同，对于浮点数，足够小的值e有不同的定义。</p><h3 id="误差积累"><a href="#误差积累" class="headerlink" title="误差积累"></a>误差积累</h3><p>减少运算次数。</p><h3 id="不是数的特别“数”"><a href="#不是数的特别“数”" class="headerlink" title="不是数的特别“数”"></a>不是数的特别“数”</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%885.13.14.png" alt="屏幕快照 2018-07-12 下午5.13.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午5.13.14</div>            </figure><p>无限大Inf，零0，非数NaN</p><h3 id="计算误差有多种"><a href="#计算误差有多种" class="headerlink" title="计算误差有多种"></a>计算误差有多种</h3><h4 id="舍入误差"><a href="#舍入误差" class="headerlink" title="舍入误差"></a>舍入误差</h4><h4 id="最大值溢出与最小值溢出"><a href="#最大值溢出与最小值溢出" class="headerlink" title="最大值溢出与最小值溢出"></a>最大值溢出与最小值溢出</h4><h4 id="信息丢失"><a href="#信息丢失" class="headerlink" title="信息丢失"></a>信息丢失</h4><h4 id="位数脱落"><a href="#位数脱落" class="headerlink" title="位数脱落"></a>位数脱落</h4><h4 id="截止误差"><a href="#截止误差" class="headerlink" title="截止误差"></a>截止误差</h4><h3 id="误差导致的严重问题"><a href="#误差导致的严重问题" class="headerlink" title="误差导致的严重问题"></a>误差导致的严重问题</h3><h3 id="BigDecimal是什么"><a href="#BigDecimal是什么" class="headerlink" title="BigDecimal是什么"></a>BigDecimal是什么</h3><p>浮点数运算的陷阱可以归结为：1. 能够表示的精度有限</p><ol start="2"><li>以二进制来表示</li></ol><p>Ruby提供了BigDecimal类，有以下3个特点：</p><ol><li>与Bignum一样，有效数字自动扩展</li><li>以十进制计算</li><li>以C语言记述，比内嵌的浮点数类（Float）要慢</li></ol><h3 id="能够表示分数的Rational类"><a href="#能够表示分数的Rational类" class="headerlink" title="能够表示分数的Rational类"></a>能够表示分数的Rational类</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-9-整数和浮点小数&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-9-整数和浮点小数&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 9 整数和浮点小数&quot;&gt;&lt;/a&gt;松本行弘的程序世界 9 整数和浮点小数&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 8 正则表达式</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%208%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 8 正则表达式/</id>
    <published>2018-07-12T04:41:32.000Z</published>
    <updated>2018-07-12T04:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-8-正则表达式"><a href="#松本行弘的程序世界-8-正则表达式" class="headerlink" title="松本行弘的程序世界 8 正则表达式"></a>松本行弘的程序世界 8 正则表达式</h1><h2 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h2><h3 id="检索“像那样的东西”"><a href="#检索“像那样的东西”" class="headerlink" title="检索“像那样的东西”"></a>检索“像那样的东西”</h3><h3 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h3><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>除了表中所示的元字符以外的普通字符，都与该字符自身相匹配。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.28.08.png" alt="屏幕快照 2018-07-12 上午10.28.08" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.28.08</div>            </figure></p><h4 id="字符集合"><a href="#字符集合" class="headerlink" title="字符集合"></a>字符集合</h4><p>用括号（【】）括起来的部分为字符集合。与括号内所含的每一个字符都匹配。比如，【abcde】能与小写字母abcde中的任何一个相匹配。<br>字符集合中，用中划线（-）来指定范围。所以，【abcde】可以用【a-e】来代替。<br>字符集合中，第一个字符是【\^】时，表示取反。就是说，不与括号（【】）中的字符相匹配。</p><h4 id="任意一个字符"><a href="#任意一个字符" class="headerlink" title="任意一个字符"></a>任意一个字符</h4><p>表示任意一个字符读得模式是“.”。除了匹配换行符。</p><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.42.59.png" alt="屏幕快照 2018-07-12 上午10.42.59" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.42.59</div>            </figure><h4 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h4><p>贪婪：寻找符合的最长的，遍历完再回溯，<br>懒惰：寻找第一个符合的。</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>将模式绑定起来的功能称为分组。（ma）+</p><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>|</p><h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>指定位置而不是字符来进行匹配。称为锚点（anchor）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.53.24.png" alt="屏幕快照 2018-07-12 上午10.53.24" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.53.24</div>            </figure></p><h3 id="三个陷阱"><a href="#三个陷阱" class="headerlink" title="三个陷阱"></a>三个陷阱</h3><h4 id="记号多、密度高的表达式"><a href="#记号多、密度高的表达式" class="headerlink" title="记号多、密度高的表达式"></a>记号多、密度高的表达式</h4><p>为应对这一问题，出现了扩展正则表达式。</p><h4 id="0次以上的重复"><a href="#0次以上的重复" class="headerlink" title="0次以上的重复"></a>0次以上的重复</h4><h4 id="贪婪型匹配"><a href="#贪婪型匹配" class="headerlink" title="贪婪型匹配"></a>贪婪型匹配</h4><h3 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h3><p>面向对象语言Ruby中，所有数据都是对象。正则表达式也是对象。<br><strong>Ruby程序中正则表达式对象写成/.*/的样子。</strong><br>正则表达式对象可以用正则表达式类方法生成。程序中由组合字符串生成正则表达式时，使用类方法更自然。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>Ruby正则表达式末尾斜杠的后面，可以为这个正则表达式添加选项。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.34.28.png" alt="屏幕快照 2018-07-12 上午11.34.28" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.34.28</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.35.23.png" alt="屏幕快照 2018-07-12 上午11.35.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.35.23</div>            </figure></p><h3 id="正则表达式匹配的方法"><a href="#正则表达式匹配的方法" class="headerlink" title="正则表达式匹配的方法"></a>正则表达式匹配的方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.37.23.png" alt="屏幕快照 2018-07-12 上午11.37.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.37.23</div>            </figure><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>Ruby中有源于Perl的特殊变量。以$开头的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.41.33.png" alt="屏幕快照 2018-07-12 上午11.41.33" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.41.33</div>            </figure></p><h3 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.43.29.png" alt="屏幕快照 2018-07-12 上午11.43.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.43.29</div>            </figure><h3 id="split的本质"><a href="#split的本质" class="headerlink" title="split的本质"></a>split的本质</h3><p>分割字符串的方法split,与正则表达式组合起来能实现很多功能。</p><h3 id="字符串的扫描"><a href="#字符串的扫描" class="headerlink" title="字符串的扫描"></a>字符串的扫描</h3><h3 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h3><p>想要置换与字符串模式匹配的部分，可以用置换方法。</p><h2 id="正则表达式的应用实例与“鬼车”"><a href="#正则表达式的应用实例与“鬼车”" class="headerlink" title="正则表达式的应用实例与“鬼车”"></a>正则表达式的应用实例与“鬼车”</h2><p>正则表达式是表达字符串模式的一种微型语言。正则表达式由字符本身、字符模式、锚点以及重复等组合而成。</p><h3 id="解析日志文件的方法"><a href="#解析日志文件的方法" class="headerlink" title="解析日志文件的方法"></a>解析日志文件的方法</h3><h3 id="避免使用-的方法"><a href="#避免使用-的方法" class="headerlink" title="避免使用$的方法"></a>避免使用$的方法</h3><p>记号$不美观。Ruby中，以match方法替代=~运算符，就可以在程序中不使用这些记号了。</p><h3 id="从邮件中取出日期的方法"><a href="#从邮件中取出日期的方法" class="headerlink" title="从邮件中取出日期的方法"></a>从邮件中取出日期的方法</h3><h3 id="典型拼写错误的检索方法"><a href="#典型拼写错误的检索方法" class="headerlink" title="典型拼写错误的检索方法"></a>典型拼写错误的检索方法</h3><h3 id="Ruby1-9的新功能“鬼车”"><a href="#Ruby1-9的新功能“鬼车”" class="headerlink" title="Ruby1.9的新功能“鬼车”"></a>Ruby1.9的新功能“鬼车”</h3><p>“鬼车”新正则表达式库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DSL</span><br><span class="line">Domain Specific Language,意为面向特定领域的编程语言。</span><br><span class="line">DSL分内部DSL和外部DSL。</span><br><span class="line">内部DSL，就是往既有的语言中加入特定领域的词汇，使之DSL化。如软件编译工具Rake中表达依存关系的内部DSL。</span><br><span class="line">make是一个同样目的的工具，它使用Makefile来表达依存关系。Rake可以利用Ruby的编程功能、方法定义、条件分歧和循环等，不管关系有多复杂，都可以编程对应。</span><br><span class="line">外部DSL，不是扩展现有的语言，而是面向特定目的，如SQL就是DSL的代表性例子。正则表达式也可以称作是以实现模式匹配为目的的外部DSL。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-8-正则表达式&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-8-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 8 正则表达式&quot;&gt;&lt;/a&gt;松本行弘的程序世界 8 正则表达式&lt;/h1&gt;&lt;h2 id=&quot;正则表达式
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 7 文字编码</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%207%20%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 7 文字编码/</id>
    <published>2018-07-12T02:00:32.000Z</published>
    <updated>2018-07-12T02:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-7-文字编码"><a href="#松本行弘的程序世界-7-文字编码" class="headerlink" title="松本行弘的程序世界 7 文字编码"></a>松本行弘的程序世界 7 文字编码</h1><h2 id="文字编码的种类"><a href="#文字编码的种类" class="headerlink" title="文字编码的种类"></a>文字编码的种类</h2><h3 id="早期的文字编码"><a href="#早期的文字编码" class="headerlink" title="早期的文字编码"></a>早期的文字编码</h3><h3 id="纸带与文字的表现"><a href="#纸带与文字的表现" class="headerlink" title="纸带与文字的表现"></a>纸带与文字的表现</h3><h3 id="文字是什么"><a href="#文字是什么" class="headerlink" title="文字是什么"></a>文字是什么</h3><h3 id="走向英语以外的语言（欧洲篇）"><a href="#走向英语以外的语言（欧洲篇）" class="headerlink" title="走向英语以外的语言（欧洲篇）"></a>走向英语以外的语言（欧洲篇）</h3><h3 id="英语以外得到语言（亚洲篇）"><a href="#英语以外得到语言（亚洲篇）" class="headerlink" title="英语以外得到语言（亚洲篇）"></a>英语以外得到语言（亚洲篇）</h3><h3 id="Unicode的问世"><a href="#Unicode的问世" class="headerlink" title="Unicode的问世"></a>Unicode的问世</h3><h3 id="统一编码成16位的汉字统合"><a href="#统一编码成16位的汉字统合" class="headerlink" title="统一编码成16位的汉字统合"></a>统一编码成16位的汉字统合</h3><h3 id="Unicode的两个问题"><a href="#Unicode的两个问题" class="headerlink" title="Unicode的两个问题"></a>Unicode的两个问题</h3><p>选择16位文字的Unicode有两大副作用。一是字节顺序的问题，一是NUL文字问题。<br>字节顺序就是低八位先放还是高八位先放的问题。<br>传统C语言处理的字符串，一般有一个终端文字NUL（‘\0’）。但是作为16位文字的字符串，中途会出现NUL文字。所以，C语言中处理字符串的传统函数不能用于16位文字的字符串。<br>像java那样的语言，一开始就是以16位文字为前提而设计的，所以没什么问题。但以C语言处理16位文字的时候，需要全新的api。</p><h3 id="Unicode的文字集"><a href="#Unicode的文字集" class="headerlink" title="Unicode的文字集"></a>Unicode的文字集</h3><p>现在，Unicode放弃了16位方式，而用21位来表示一个文字，现在Unicode能够表示4111个文字，肯定够用了。</p><h3 id="文字表示的不确定性"><a href="#文字表示的不确定性" class="headerlink" title="文字表示的不确定性"></a>文字表示的不确定性</h3><h3 id="Unicode的字符编码方式"><a href="#Unicode的字符编码方式" class="headerlink" title="Unicode的字符编码方式"></a>Unicode的字符编码方式</h3><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8以一定式样的字节组合来表示Unicode中的21位文字。对于内部程序处理字符串非常方便，另外没有字节顺序问题，在外部处理时也很有用。<br>缺点：消费过多内存，几乎所有的汉字都要占用3个字节。<br>构成文字的字节数是可变的，随机访问任意文字，代价与字符串长度成正比。<br>但是随着计算机内存的容量和性能提高，这些缺点也无所谓了。</p><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>Unicode中能以16位表示的空间就以16位表示，超过16位就以两个16位码组合来表示。到现在缺点已经很突出了，从今以后没必要采用这种字符编码方式了。</p><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>固定长，可以随机访问，但存在字节顺序的问题。<br>因为4字节，没什么人气。</p><h2 id="程序中的文字处理"><a href="#程序中的文字处理" class="headerlink" title="程序中的文字处理"></a>程序中的文字处理</h2><h3 id="文字编码有多个意思"><a href="#文字编码有多个意思" class="headerlink" title="文字编码有多个意思"></a>文字编码有多个意思</h3><h3 id="只能处理文字集中包含的文字"><a href="#只能处理文字集中包含的文字" class="headerlink" title="只能处理文字集中包含的文字"></a>只能处理文字集中包含的文字</h3><h3 id="纷繁复杂的文字编码方式"><a href="#纷繁复杂的文字编码方式" class="headerlink" title="纷繁复杂的文字编码方式"></a>纷繁复杂的文字编码方式</h3><h3 id="影响力渐微的Shift-JIS与EUC-JP"><a href="#影响力渐微的Shift-JIS与EUC-JP" class="headerlink" title="影响力渐微的Shift_JIS与EUC-JP"></a>影响力渐微的Shift_JIS与EUC-JP</h3><h3 id="Unicode有多种字符编码方式"><a href="#Unicode有多种字符编码方式" class="headerlink" title="Unicode有多种字符编码方式"></a>Unicode有多种字符编码方式</h3><h3 id="为什么会发生乱码"><a href="#为什么会发生乱码" class="headerlink" title="为什么会发生乱码"></a>为什么会发生乱码</h3><h3 id="字符编码方式错误"><a href="#字符编码方式错误" class="headerlink" title="字符编码方式错误"></a>字符编码方式错误</h3><h3 id="没有字体"><a href="#没有字体" class="headerlink" title="没有字体"></a>没有字体</h3><h3 id="变换为内部码时出错"><a href="#变换为内部码时出错" class="headerlink" title="变换为内部码时出错"></a>变换为内部码时出错</h3><h3 id="发生不完全变换"><a href="#发生不完全变换" class="headerlink" title="发生不完全变换"></a>发生不完全变换</h3><h3 id="文字集的不同"><a href="#文字集的不同" class="headerlink" title="文字集的不同"></a>文字集的不同</h3><h3 id="字节顺序错误"><a href="#字节顺序错误" class="headerlink" title="字节顺序错误"></a>字节顺序错误</h3><p>像UTF-16，UTF-32这种基本数据单位大于一个字节的编码方式，存放数据时字节该以什么顺序摆放，有两大流派，一个是big endian,一个是little endian。所以同样是UTF-16格式（UTF-32也一样）根据字节顺序不同就会有两种。<br>UTF-8就不会。</p><h3 id="从编程语言的角度处理文字"><a href="#从编程语言的角度处理文字" class="headerlink" title="从编程语言的角度处理文字"></a>从编程语言的角度处理文字</h3><p>编程语言处理文本数据的方法，有UCS方式和CSI方式两种。</p><h3 id="以变换为前提的UCS方式"><a href="#以变换为前提的UCS方式" class="headerlink" title="以变换为前提的UCS方式"></a>以变换为前提的UCS方式</h3><p>UCS（泛用字符集），是指程序中所处理的共同文字集（及字符编码方式）。输入输出时，编程语言将文本数据变成UCS，内部对文本数据进行统一处理。优点：</p><ol><li>原理简单，容易实现</li><li>除变换外，处理成本低</li><li>实际成果多</li></ol><p>缺点：</p><ol><li>发生不必要的变换</li><li>变换存在模糊部分</li><li>有外字及机种依存文字的问题</li><li>UCS中不包含的文字绝对不能处理</li></ol><h3 id="原封不动处理的CSI方式"><a href="#原封不动处理的CSI方式" class="headerlink" title="原封不动处理的CSI方式"></a>原封不动处理的CSI方式</h3><p>CSI（Character Set Independent，字符集独立），是指不对各种文字集（及编码方式）进行任何变换，原封不动地进行处理。相对于UCS的内部只有一种编码方式的处理方式，CSI中对各种编码方式原封不动地处理。<br>CSI是优点多，自由度高的方式。</p><ol><li>不发生不必要的变换</li><li>不发生变换所带来的问题</li><li>不易发生外字的问题。</li><li>理论上不存在不能处理的文字</li><li>根据需要，可以处理应用程序独立的文字集</li></ol><p>缺点：</p><ol><li>字符串的处理容易变得复杂化</li><li>预计处理性能会变低</li><li>实际成果少</li></ol><p>实际上，现在存在的多种编程语言中，采用CSI方式的几乎没有。</p><h3 id="使用UTF-16的Java"><a href="#使用UTF-16的Java" class="headerlink" title="使用UTF-16的Java"></a>使用UTF-16的Java</h3><p>Java采用UCS方式，内部字符编码选用UTF-16<br>制作Java时，Unicode仅限于16位。java没选择可变长的UTF-8，而选择UTF-16，因而产生了这样的悲剧。说是时机的恶作剧也罢，真是太可惜了。</p><h3 id="使用UTF-8的Perl"><a href="#使用UTF-8的Perl" class="headerlink" title="使用UTF-8的Perl"></a>使用UTF-8的Perl</h3><p>Perl也使用UCS方式，内部编码方式采用UTF-8。</p><h3 id="用UTF-16的Python"><a href="#用UTF-16的Python" class="headerlink" title="用UTF-16的Python"></a>用UTF-16的Python</h3><p>UCS，UTF-16</p><h3 id="采用CSI方式的Ruby1-8"><a href="#采用CSI方式的Ruby1-8" class="headerlink" title="采用CSI方式的Ruby1.8"></a>采用CSI方式的Ruby1.8</h3><h3 id="强化了功能的Ruby1-9"><a href="#强化了功能的Ruby1-9" class="headerlink" title="强化了功能的Ruby1.9"></a>强化了功能的Ruby1.9</h3><h3 id="是UCS还是CSI"><a href="#是UCS还是CSI" class="headerlink" title="是UCS还是CSI"></a>是UCS还是CSI</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-7-文字编码&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-7-文字编码&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 7 文字编码&quot;&gt;&lt;/a&gt;松本行弘的程序世界 7 文字编码&lt;/h1&gt;&lt;h2 id=&quot;文字编码的种类&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 6 Ruby On Rails</title>
    <link href="https://github.com/zdkswd/2018/07/11/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%206%20Ruby%20On%20Rails/"/>
    <id>https://github.com/zdkswd/2018/07/11/松本行弘的程序世界 6 Ruby On Rails/</id>
    <published>2018-07-11T04:00:32.000Z</published>
    <updated>2018-07-11T03:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-6-Ruby-On-Rails"><a href="#松本行弘的程序世界-6-Ruby-On-Rails" class="headerlink" title="松本行弘的程序世界 6 Ruby On Rails"></a>松本行弘的程序世界 6 Ruby On Rails</h1><h2 id="MVC和Ruby-On-Rails"><a href="#MVC和Ruby-On-Rails" class="headerlink" title="MVC和Ruby On Rails"></a>MVC和Ruby On Rails</h2><p>MVC是设计GUI程序的设计模式之一。大部分设计模式仅决定程序某一部分的构成，而MVC决定了应用程序的整体部分，有时候也被成为架构模式。</p><h3 id="模型、视图和控制的作用"><a href="#模型、视图和控制的作用" class="headerlink" title="模型、视图和控制的作用"></a>模型、视图和控制的作用</h3><p>模型：是表现窗口中表示内容（信息）的对象。模型代表的只是信息（名字、数值等抽象的信息），它不能包含如何来显示这些信息的信息。<br>视图：代表将模型中包含的信息在窗口中进行表示的对象。视图知道要表现的模型的信息，而模型一般不知道要表示自己的视图信息。<br>控制：是从用户端接受输入，对视图和模型进行操作的对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.26.46.png" alt="屏幕快照 2018-07-11 上午9.26.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.26.46</div>            </figure></p><h3 id="用秒表的例子来学习MVC模式"><a href="#用秒表的例子来学习MVC模式" class="headerlink" title="用秒表的例子来学习MVC模式"></a>用秒表的例子来学习MVC模式</h3><h3 id="生成视图和控制部分"><a href="#生成视图和控制部分" class="headerlink" title="生成视图和控制部分"></a>生成视图和控制部分</h3><h3 id="GUI工具箱与MVC"><a href="#GUI工具箱与MVC" class="headerlink" title="GUI工具箱与MVC"></a>GUI工具箱与MVC</h3><h3 id="同时使用工具箱和MVC"><a href="#同时使用工具箱和MVC" class="headerlink" title="同时使用工具箱和MVC"></a>同时使用工具箱和MVC</h3><h3 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h3><p>优点：</p><h4 id="可以更换界面"><a href="#可以更换界面" class="headerlink" title="可以更换界面"></a>可以更换界面</h4><h4 id="一个模型对应多个视图"><a href="#一个模型对应多个视图" class="headerlink" title="一个模型对应多个视图"></a>一个模型对应多个视图</h4><h4 id="多个视图可以同时响应"><a href="#多个视图可以同时响应" class="headerlink" title="多个视图可以同时响应"></a>多个视图可以同时响应</h4><h4 id="容易测试"><a href="#容易测试" class="headerlink" title="容易测试"></a>容易测试</h4><p>缺点：</p><h4 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h4><h4 id="强关联性"><a href="#强关联性" class="headerlink" title="强关联性"></a>强关联性</h4><p>对模型对象进行了功能追加这样的变更后，相应地也必须对视图和控制进行变更。</p><h3 id="Web应用中的MVC"><a href="#Web应用中的MVC" class="headerlink" title="Web应用中的MVC"></a>Web应用中的MVC</h3><p>Web应用基本是HTTP。HTTP的一次处理经过了一下过程：<br>（1）Web浏览器对应于用户的操作，向Web服务器发出HTTP请求。<br>（2）Web服务器根据请求，准备好发送到Web浏览器的数据。<br>（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。</p><p>利用MVC来描述：<br>（1）Web浏览器发送过来的HTTP请求通过Web服务器传给控制部分。Web应用框架的分配器把请求传递给合适的控制部分。<br>（2）控制部分操作的模型和请求的信息相对应，同时制定显示使用的视图。视图从模型启动，一边引用模型一边准备发送给Web浏览器的数据。<br>（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.54.09.png" alt="屏幕快照 2018-07-11 上午9.54.09" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.54.09</div>            </figure><p>Ruby on Rails上的MVC各部分功能稍有不同。Rails中的模型相当于数据库层，视图指显示用的模板，控制器指控制用的类（包含了应用逻辑）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.56.48.png" alt="屏幕快照 2018-07-11 上午9.56.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.56.48</div>            </figure></p><h2 id="开放类和猴子补丁"><a href="#开放类和猴子补丁" class="headerlink" title="开放类和猴子补丁"></a>开放类和猴子补丁</h2><p>猴子补丁，即在动态语言中，不改变源代码而对功能进行追加和变更。<br>现在灵活使用开放类，变更和追加方法全部称为猴子补丁。</p><h3 id="开放类"><a href="#开放类" class="headerlink" title="开放类"></a>开放类</h3><p>Ruby的类的特征是所谓的开放类，相对于其他语言，特别容易打猴子补丁。<br>Ruby中，可以把String类、Array类等基本的数据类型及所有的类都作为开放类处理，可以自由地追加功能。</p><h3 id="猴子补丁的目的"><a href="#猴子补丁的目的" class="headerlink" title="猴子补丁的目的"></a>猴子补丁的目的</h3><h4 id="功能追加"><a href="#功能追加" class="headerlink" title="功能追加"></a>功能追加</h4><p>利用开放类可以给已有的类追加功能。</p><h4 id="功能变更"><a href="#功能变更" class="headerlink" title="功能变更"></a>功能变更</h4><h4 id="修改程序错误"><a href="#修改程序错误" class="headerlink" title="修改程序错误"></a>修改程序错误</h4><p>因为重新定义了有程序错误或有副作用的方法，不用修改原来那部分的代码就可以解决问题。这也是本来的猴子补丁的目的。</p><h4 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h4><p>有时间想在每个方法调用的同时增加一些其他处理。这种伴随方法调用而进行的处理称为“钩子”（hook），钩子的追加也可以用猴子补丁来实现。</p><h4 id="缓存（cache）"><a href="#缓存（cache）" class="headerlink" title="缓存（cache）"></a>缓存（cache）</h4><h3 id="猴子补丁的技巧"><a href="#猴子补丁的技巧" class="headerlink" title="猴子补丁的技巧"></a>猴子补丁的技巧</h3><p>可以吧Ruby提供的对方法、类和模块进行操作的功能运用到打猴子补丁上。最基本的功能就是给已有的方法改名或取消。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%8810.58.20.png" alt="屏幕快照 2018-07-11 上午10.58.20" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午10.58.20</div>            </figure></p><h4 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h4><p>undef有把方法取消定义的功能。用undef不仅可以取消本类中的方法，也可以取消父类中定义的方法。</p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><h3 id="灵活使用开放类的库"><a href="#灵活使用开放类的库" class="headerlink" title="灵活使用开放类的库"></a>灵活使用开放类的库</h3><p>jcode库可以不使用正则表达式，利用开放类的功能，使得字符串的方法可以处理多字节文字。</p><h3 id="猴子补丁的几点问题"><a href="#猴子补丁的几点问题" class="headerlink" title="猴子补丁的几点问题"></a>猴子补丁的几点问题</h3><p>若要正确使用开放类，安全地打猴子补丁，需遵守：</p><ol><li>基本上只是追加功能<br>对类追加新方法不会让已有的程序无法执行。使用开放类时，主要做不容易导致问题的功能追加会更保险。做功能追加时，如果发生名称重复会造成麻烦，在选择追加的方法名时需要慎重。</li><li>进行功能变更时要慎重，尽可能小规模</li><li>小心相互作用</li></ol><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>猴子补丁能够不改变源代码进行动态修改，这种灵活性是显示动态语言柔软性和扩展性的好例子。实现猴子补丁的Ruby开放类有时功能过强，可能会引起问题。<br>其他语言中用更易控制的形式也能实现猴子补丁。</p><h3 id="Ruby-on-Rails和开放类"><a href="#Ruby-on-Rails和开放类" class="headerlink" title="Ruby on Rails和开放类"></a>Ruby on Rails和开放类</h3><p>Rails构成部分之一ActiveSupport库。ActiveSupport利用Ruby的开放类功能，对Ruby标准提供的类大胆地追加了功能。</p><h3 id="ActiveSupport带来的扩展"><a href="#ActiveSupport带来的扩展" class="headerlink" title="ActiveSupport带来的扩展"></a>ActiveSupport带来的扩展</h3><ol><li>时间</li><li>字节单位系列</li><li>复数形和序数</li></ol><h3 id="大规模开发和Ruby"><a href="#大规模开发和Ruby" class="headerlink" title="大规模开发和Ruby"></a>大规模开发和Ruby</h3><h4 id="编译时不作类型检查"><a href="#编译时不作类型检查" class="headerlink" title="编译时不作类型检查"></a>编译时不作类型检查</h4><p>Ruby在执行时作类型检查，大规模程序为了保证可靠性一定会有严格的测试程序，如果作了严格的测试，在编译时作类型检查的优点就不像所说的那么重要了。</p><h4 id="没有包"><a href="#没有包" class="headerlink" title="没有包"></a>没有包</h4><p>Java对于构成库的类和文件有独立的包，要想具备某种功能，必须明确地进行import操作。而Ruby是不具备这种功能的。所以，库定义的类和模块名是全局的，从任何地方都可以引用。因此，可以说名称重复的危险性很大。</p><h4 id="存在开放类"><a href="#存在开放类" class="headerlink" title="存在开放类"></a>存在开放类</h4><p>各自独立的库发生互相矛盾的变更时，问题不能简单解决。这也可能在大规模开发时引发问题。</p><h3 id="信赖性模型"><a href="#信赖性模型" class="headerlink" title="信赖性模型"></a>信赖性模型</h3><p>在某种类型的大规模开发中，Ruby的性质会造成问题，或者说造成问题时解决起来不像其他语言那么容易，这种现象是现实中可能存在的。如果认为这些是问题的话，可能不使用Ruby会更好。但是，到现在为止我们看到的情况表明，会发生那种问题的大规模开发本来就绝不是好的开发状况。首先要做的，是把项目的信赖关系改善到可以使用Ruby的程度。就算是最后也没有使用Ruby，这也是应该先做到的事情。</p><h3 id="猴子补丁的未来"><a href="#猴子补丁的未来" class="headerlink" title="猴子补丁的未来"></a>猴子补丁的未来</h3><p>猴子补丁虽然有一定的危险性，但有利有弊，它也提供了方便性、扩展性和灵活性。开放类和利用它的猴子补丁，将来也可能会被更安全的、由1特定目的而特制的功能群而替代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-6-Ruby-On-Rails&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-6-Ruby-On-Rails&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 6 Ruby On Rails&quot;&gt;&lt;/a&gt;松本行弘的程序世界 6
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 5 Ajax</title>
    <link href="https://github.com/zdkswd/2018/07/10/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%205%20Ajax/"/>
    <id>https://github.com/zdkswd/2018/07/10/松本行弘的程序世界 5 Ajax/</id>
    <published>2018-07-10T09:25:32.000Z</published>
    <updated>2018-07-10T09:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-5-Ajax"><a href="#松本行弘的程序世界-5-Ajax" class="headerlink" title="松本行弘的程序世界 5 Ajax"></a>松本行弘的程序世界 5 Ajax</h1><h2 id="Ajax和JavaScript（前篇）"><a href="#Ajax和JavaScript（前篇）" class="headerlink" title="Ajax和JavaScript（前篇）"></a>Ajax和JavaScript（前篇）</h2><p>Ajax（Asynchronous JavaScript and XML）,含义是异步JavaScript及XML。<br>Ajax不算是一个新技术，只是既有技术的组合。</p><h3 id="通信及异步页面更新"><a href="#通信及异步页面更新" class="headerlink" title="通信及异步页面更新"></a>通信及异步页面更新</h3><p>Ajax的最大特点是进行异步操作，异步意味着Web浏览器的通信和页面更新是互相独立的。<br>以前的Web应用程序，每按下一个按钮就开始显示下一个页面，在页面完整呈现之前，用户只能等待，无法进行其他操作，使用Ajax技术的页面是在后台和HTTP服务器进行通信，设计优良的Web应用程序，在客户和服务器通信的过程中也可以让用户进行操作，而不需要等待。Ajax的最大优点是改善了应用程序的操控性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8A%E5%8D%888.52.52.png" alt="屏幕快照 2018-07-10 上午8.52.52" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 上午8.52.52</div>            </figure><br>Ajax技术中，对于用户进行的操作，基本是由JavaScript在Web浏览器中进行响应。尽在数据必须从服务器获取的情况下，才在后台进行异步通信。在通信过程中，用户也可以继续对Web浏览器进行操作。和服务器通信得到的结果由DHTML对当前的页面进行部分更新而现实出来。</p><h3 id="技术要素之一：JavaScript"><a href="#技术要素之一：JavaScript" class="headerlink" title="技术要素之一：JavaScript"></a>技术要素之一：JavaScript</h3><p>支撑Ajax的三个主要技术：JavaScript、XML及DHTML。<br>JavaScript是几乎所有Web浏览器处理系统都支撑的一种编程语言。因此，它被称为世界上最普及的编程语言。<br>JavaScript可以简单的嵌入到表示网页的HTML中去，利用JavaScript可以做出<strong>完全不用和服务器进行通信</strong>的网页。</p><h3 id="技术要素之二：XML"><a href="#技术要素之二：XML" class="headerlink" title="技术要素之二：XML"></a>技术要素之二：XML</h3><p>XML（eXtensible Markup Language）,和SGML、HTML类似，使用标签（tag）对数据进行标识说明的一种语言。<br>XML已经成为了数据表示、配置各种文件及其他多种场合下广泛使用的一种格式。<br>Ajax的名字中部分包括了XML，是因为当初大部分使用Ajax技术的应用程序都使用了XML数据，以及用JavaScript进行异步通信的对象的名字是XMLHTTPRequest。当然不用XML的XMLHTTPRequest的通信也是存在的，使用Ajax技术的Web应用进行通信的数据格式也是多种多样的，比如有普通文本格式以及YAML，JSON。</p><h3 id="XML以外的数据表示形式"><a href="#XML以外的数据表示形式" class="headerlink" title="XML以外的数据表示形式"></a>XML以外的数据表示形式</h3><p>YAML（YAML Ain’t Markup Language）看出它不是标记语言。YAML只是表示数据的语言，目的仅仅是表示数据。特点有：</p><ol><li>记述简洁</li><li>容易理解</li><li>专注于表示数据，不用费心考虑给标签起名字。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8A%E5%8D%889.30.23.png" alt="屏幕快照 2018-07-10 上午9.30.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 上午9.30.23</div>            </figure></li></ol><p>和YMAL相提并论的是JSON（JavaScript Object Notation）意思是JavaScript对象表示法。是直接把JavaScript表示对象的程序拿来记述数据。JSON是合法的JavaScript程序，作为JavaScript实现可以生成对象。<br>JSON可以表现下面6种数据类型：数值（整数及浮点小数）、字符串、布尔值（真、假）、数组、对象（键和值的表）和null。<br>YAML通过扩展可以表示各种形式的数据。相比较，JSON就简单太多了，但也够用了。</p><h3 id="技术要素之三：DHTML"><a href="#技术要素之三：DHTML" class="headerlink" title="技术要素之三：DHTML"></a>技术要素之三：DHTML</h3><p>DHTML，动态HTML，顾名思义，可以动态地对HTML进行引用、修改和更新。更具体的说，是利用装载在网页中的JavaScript，使用DOM（文档对象模型）对网页数据进行操作。使用DOM可以进行下述处理：</p><ol><li>取得页面中特定标签中的数据；</li><li>修改标签的数据（文字、属性等）</li><li>在页面中添加标签；</li><li>设定事件处理程序<h3 id="JavaScript技术基础"><a href="#JavaScript技术基础" class="headerlink" title="JavaScript技术基础"></a>JavaScript技术基础</h3>JavaScript是以对象为基础的语言，所有的数据都可以作为“对象”进行统一处理。不过，它不具备“类”这样的所谓普通面向对象语言所提供的功能，即使去除JavaScript面向对象的编程功能，它也可以作为普通的结构化编程语言来使用。<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4>JavaScript的基本语法和C、Java类似。最大的不同是，JavaScript不指定变量类型。<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4>JavaScript的特点之一是把函数作为对象进行处理。C也是将函数作为对象处理，但JavaScript的不同之处在于函数对象有闭包（closure），可以使用函数外面的局部变量。<strong>闭包功能称为了JavaScript面向对象功能的基础。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闭包是Ruby中块变为对象后的结果。它的优点是，只要闭包还存在，就能访问闭包内的变量。</span><br></pre></td></tr></table></figure></li></ol><h3 id="原型模式的面向对象编程语言"><a href="#原型模式的面向对象编程语言" class="headerlink" title="原型模式的面向对象编程语言"></a>原型模式的面向对象编程语言</h3><p>如果具有原型模式的面向对象功能的话，就可以最大限度地消减语言本身的固有功能。这非常适合于JavaScript这样的语言。<br>以类为中心的传统面向对象编程，是以类为基础生成新对象。类和对象的关系可以类比成铸模和铸件的关系。而原型模式的面向对象编程语言没有类这样一个概念。<br>需要生成新的对象时，只要给对象追加属性。设置函数对象作为属性的话，就成为方法。当访问对象中不存在的属性时，JavaScript会去搜索该对象prototype属性所指向的对象。<br>JavaScript利用这个功能，使用“委派”而非“继承”来实现面向对象编程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">委派是指，把对于某个对象的调用传送到另一个对象上。</span><br></pre></td></tr></table></figure></p><p>JavaScript的方式过于简单反而使记述太过复杂。</p><h3 id="使用prototype-js库"><a href="#使用prototype-js库" class="headerlink" title="使用prototype.js库"></a>使用prototype.js库</h3><p>为了克服JavaScript记述过于繁杂的缺点，JavaScript提供了进行功能扩展的一些库。如prototype.js库<br>prototype.js受到了Ruby的影响，实际上Ruby on Rails中标准地附加了prototype.js库，使用得很广泛。</p><h3 id="prototype-js的功能"><a href="#prototype-js的功能" class="headerlink" title="prototype.js的功能"></a>prototype.js的功能</h3><h4 id="Ajax功能"><a href="#Ajax功能" class="headerlink" title="Ajax功能"></a>Ajax功能</h4><p>prototype.js支持XMLHttpRequest对象，可以对HTML进行异步更新。<br>实际上不同Web浏览器获取XMLHttpRequest对象的方法也是不同的。Ajax.Request帮我们屏蔽了与代码移植相关的问题。</p><h4 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h4><p>它是Ruby的Enumerable模块在JavaScript中的实现。</p><h4 id="其他扩展功能"><a href="#其他扩展功能" class="headerlink" title="其他扩展功能"></a>其他扩展功能</h4><p>如使用Object.extend()给对象追加功能。</p><h2 id="Ajax和JavaScript-后篇"><a href="#Ajax和JavaScript-后篇" class="headerlink" title="Ajax和JavaScript(后篇)"></a>Ajax和JavaScript(后篇)</h2><p>像Ajax有3个特点：</p><ol><li>没有Web页面跳转</li><li>通过异步通信实现快速反应</li><li>实现了动画和拖拽等单独使用HTML格式无法表现的用户界面<br>构成DHTML基础的JavaScript是一个速度不怎么快的语言。某种技术在开发出来之后经过相当长一段时间才得到普及，此类例子并不少见。<h3 id="巧妙使用DHTML"><a href="#巧妙使用DHTML" class="headerlink" title="巧妙使用DHTML"></a>巧妙使用DHTML</h3>DHTML被称为Ajax的本质技术。顾名思义，可以动态访问、更新HTML。具体就是利用嵌入网页的JavaScript，使用DOM操作页面数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM是操作HTML和XML的规范。特点是把HTML和XML作为树结构进行处理。</span><br></pre></td></tr></table></figure></li></ol><p>HTML被读取后，生成树结构。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8B%E5%8D%884.39.14.png" alt="屏幕快照 2018-07-10 下午4.39.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 下午4.39.14</div>            </figure><br>使用JavaScript对树结构进行操作就是DHTML的本质。因此JavaScript提供的W3C DOM API有如下功能：</p><ol><li>获取documnent节点</li><li>获取和更新标签数据（包括文字、类型以及属性等）</li><li>追加documnent节点</li><li>设定时间处理程序（event handler）</li></ol><h3 id="获取documnent节点"><a href="#获取documnent节点" class="headerlink" title="获取documnent节点"></a>获取documnent节点</h3><blockquote><p>getElementById(name)<br>getElementsByTagName(name)</p></blockquote><h3 id="获取和更新标签数据"><a href="#获取和更新标签数据" class="headerlink" title="获取和更新标签数据"></a>获取和更新标签数据</h3><p>获取节点对象后，通过调用对象的方法，读写对象的属性等就能够获取和更新标签数据。</p><h3 id="设定事件处理程序"><a href="#设定事件处理程序" class="headerlink" title="设定事件处理程序"></a>设定事件处理程序</h3><p>两种办法：</p><ol><li>指定标签属性。如设置为a标签的onclick属性值来指定事件处理程序。</li><li>把方法设为JavaScript对象的属性。如<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8B%E5%8D%884.49.48.png" alt="屏幕快照 2018-07-10 下午4.49.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 下午4.49.48</div>            </figure></li></ol><h3 id="追加标签节点"><a href="#追加标签节点" class="headerlink" title="追加标签节点"></a>追加标签节点</h3><p>用appendChild方法可以为节点对象追加节点，消除节点用removeChild方法。</p><h3 id="本地HTML应用"><a href="#本地HTML应用" class="headerlink" title="本地HTML应用"></a>本地HTML应用</h3><h3 id="和服务器间的通信"><a href="#和服务器间的通信" class="headerlink" title="和服务器间的通信"></a>和服务器间的通信</h3><p>使用DHTML之后，对于较简单的应用，在客户端就能够实现。但是，客户端无法保存数据，所以保存和获取数据时需要和服务器进行通信。<br>Ajax是利用XMLHTTPRequest对象来进行异步通信，不需要网页跳转，在后台就可以进行通信。</p><h3 id="使用Prototype-js的优点"><a href="#使用Prototype-js的优点" class="headerlink" title="使用Prototype.js的优点"></a>使用Prototype.js的优点</h3><p>不需要麻烦的记述。</p><h3 id="在服务器上保存数据"><a href="#在服务器上保存数据" class="headerlink" title="在服务器上保存数据"></a>在服务器上保存数据</h3><h3 id="Web应用的脆弱性"><a href="#Web应用的脆弱性" class="headerlink" title="Web应用的脆弱性"></a>Web应用的脆弱性</h3><p>如XSS（跨站点脚本问题）</p><h3 id="使用JavaScript的感觉"><a href="#使用JavaScript的感觉" class="headerlink" title="使用JavaScript的感觉"></a>使用JavaScript的感觉</h3><h4 id="作为动态语言名副其实"><a href="#作为动态语言名副其实" class="headerlink" title="作为动态语言名副其实"></a>作为动态语言名副其实</h4><h4 id="DHTML比想象的更有趣"><a href="#DHTML比想象的更有趣" class="headerlink" title="DHTML比想象的更有趣"></a>DHTML比想象的更有趣</h4><h4 id="Prototype-js也不错"><a href="#Prototype-js也不错" class="headerlink" title="Prototype.js也不错"></a>Prototype.js也不错</h4><h4 id="调试比较麻烦"><a href="#调试比较麻烦" class="headerlink" title="调试比较麻烦"></a>调试比较麻烦</h4><p>JavaScript理就算有程序错误，Web浏览器也不会显示任何信息。想要确认程序的状态，只能多次使用alert()。<br>Firefox提供了Firebug的扩展功能，对于JavaScript的调试非常有用。</p><h4 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h4><p>Ajax开发最难的一点就是Web浏览器间JavaScript的兼容性问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名字的重要性</span><br><span class="line">起了一个合适的名字本身意味着功能设计的正确。反过来，起了不好的名字说明设计者自己也没有完全理解应完成什么样的功能。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-5-Ajax&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-5-Ajax&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 5 Ajax&quot;&gt;&lt;/a&gt;松本行弘的程序世界 5 Ajax&lt;/h1&gt;&lt;h2 id=&quot;Ajax和Java
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 4 设计模式</title>
    <link href="https://github.com/zdkswd/2018/07/09/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%204%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 4 设计模式/</id>
    <published>2018-07-09T10:21:32.000Z</published>
    <updated>2018-07-20T11:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-4-设计模式"><a href="#松本行弘的程序世界-4-设计模式" class="headerlink" title="松本行弘的程序世界 4 设计模式"></a>松本行弘的程序世界 4 设计模式</h1><h2 id="设计模式（1）"><a href="#设计模式（1）" class="headerlink" title="设计模式（1）"></a>设计模式（1）</h2><h3 id="设计模式的价值和意义"><a href="#设计模式的价值和意义" class="headerlink" title="设计模式的价值和意义"></a>设计模式的价值和意义</h3><p>Gamma他们并没有发现新的模式，总结出来的23种设计模式也是软件开发中早就存在并反复使用的模式，因此并不能说是Gamma他们的首创。但即使是这样，设计模式有了名字，人们就可以认识到它的存在，并对之进行讨论。这种不能用语言表达的知识称为内隐知识。给这些在软件中经常反复出现的模式命名，使得这些本来只有经验丰富的程序员才能认识到的软件设计模式能被广泛认识和讨论。</p><h3 id="设计模式是程序抽象化的延伸"><a href="#设计模式是程序抽象化的延伸" class="headerlink" title="设计模式是程序抽象化的延伸"></a>设计模式是程序抽象化的延伸</h3><p>一旦有了设计模式，只要把过去优秀的人们考虑出来的模式拿来应用一下。</p><h3 id="Ruby中的设计模式"><a href="#Ruby中的设计模式" class="headerlink" title="Ruby中的设计模式"></a>Ruby中的设计模式</h3><h3 id="Singleton模式"><a href="#Singleton模式" class="headerlink" title="Singleton模式"></a>Singleton模式</h3><p>单件模式。用来保证某个类的实例只有一个。<br>Ruby实现Singleton模式的方法有几个</p><ol><li>使用singleton库的方法<br>Ruby以库的形式实现了Singleton模式。使用Singleton库，在任意类中include Singleton模块，那个类就变成Singleton模式的对象。</li><li>使用类或模块<br>C++和java是不能把类作为对象使用的，与之不同的是，smalltalk或Ruby能把类也作为对象来处理。因此，在类或模块中定义一个方法就可以实现Singleton模式。</li><li>把一般的对象作为Singleton来使用<br>为了把一个类的对象限制为只有一个，并不一定要对对象的一般生产方法进行限制。可以生成一个一般的对象，然后不要在生产更多个对象了。</li><li>使用对象和特异方法<br>Ruby可以在对象生成以后再增加新的方法。</li></ol><h3 id="Proxy模式"><a href="#Proxy模式" class="headerlink" title="Proxy模式"></a>Proxy模式</h3><p>Proxy（代理）模式是为某个对象提供代理对象的模式。<br>在不知道是否真正需要一个生成代价很大的对象时可能造成很大浪费，但不生成又什么都做不了。</p><h3 id="Iterator模式"><a href="#Iterator模式" class="headerlink" title="Iterator模式"></a>Iterator模式</h3><p>Iterator（迭代器）模式提供按顺序访问集合对象中各元素的方法。即使不知道对象的内部构造，也可以按顺序访问其中的每个元素。<br>Iterator模式是为集合对象另外准备用来控制循环处理的对象，就像C++或java一样，我们称这个循环控制对象为Iyerator，也称为游标。</p><h3 id="外部与内部，哪一个更好"><a href="#外部与内部，哪一个更好" class="headerlink" title="外部与内部，哪一个更好"></a>外部与内部，哪一个更好</h3><p>它们都有方便的一面，也都有不方便的另一面。</p><h3 id="内部迭代器的缺陷"><a href="#内部迭代器的缺陷" class="headerlink" title="内部迭代器的缺陷"></a>内部迭代器的缺陷</h3><p>内部迭代器不能同时进行多个循环，也就无法实现按顺序比较两个集合元素的处理。</p><h3 id="外部迭代器的缺陷"><a href="#外部迭代器的缺陷" class="headerlink" title="外部迭代器的缺陷"></a>外部迭代器的缺陷</h3><p>外部迭代器的缺陷在于迭代器对象需要引用集合对象的内部信息，为了按顺序访问集合对象的各个元素，迭代器需要访问集合的内部构造，破坏了隐藏集合内部构造的封装性原则。</p><h2 id="设计模式（2）"><a href="#设计模式（2）" class="headerlink" title="设计模式（2）"></a>设计模式（2）</h2><h3 id="模式与动态语言的关系"><a href="#模式与动态语言的关系" class="headerlink" title="模式与动态语言的关系"></a>模式与动态语言的关系</h3><p>《设计模式》一书中介绍了23个设计模式。这些设计模式可分为3大类：（1）有关生成的模式（5个），有关构造的模式（7个）以及有关行为的模式（11个）。Singleton为（1），Proxy为（2），Iterayor为（3）。</p><h3 id="重复使用既存对象的Protoype模式"><a href="#重复使用既存对象的Protoype模式" class="headerlink" title="重复使用既存对象的Protoype模式"></a>重复使用既存对象的Protoype模式</h3><p>Protoype（原型）模式明确一个实例作为要生成对象的种类原型，通过复制该实例来生成新的对象。<br>在需要新种类对象时，首先复制一个既存的对象，给复制的对象直接增加方法或实例变量等功能，生成最初的第一个新种类对象。最初一个也并不特别，只是偶尔被用来复制而已。<br>相对于类模式编程，原型模式的编程构成元素比较少，具有简单实现面向对象功能设计的倾向，JavaScript的面向对象就是原型模式。io语言也是。</p><h3 id="亲身体验IO语言"><a href="#亲身体验IO语言" class="headerlink" title="亲身体验IO语言"></a>亲身体验IO语言</h3><h3 id="Ruby中的原型"><a href="#Ruby中的原型" class="headerlink" title="Ruby中的原型"></a>Ruby中的原型</h3><p>基本上讲Ruby是类模式的语言，但也拥有支持原型模式编程功能。</p><ol><li>复制对象的clone方法</li><li>给个别对象增加方法的特意方法功能</li><li>给个别对象增加一组功能的extend方法</li></ol><p>静态语言中没有原型编程，因为不可能给复制的对象增加新方法。</p><h3 id="编写抽象算法的Template-Method模式"><a href="#编写抽象算法的Template-Method模式" class="headerlink" title="编写抽象算法的Template Method模式"></a>编写抽象算法的Template Method模式</h3><h3 id="用Ruby来尝试Template-Method"><a href="#用Ruby来尝试Template-Method" class="headerlink" title="用Ruby来尝试Template Method"></a>用Ruby来尝试Template Method</h3><p>Ruby的类库中最大限度灵活运用Template Method模式的部分，应该是Enumerable模块和Comparable模块了。</p><h3 id="动态语言与Template-Method模式"><a href="#动态语言与Template-Method模式" class="headerlink" title="动态语言与Template Method模式"></a>动态语言与Template Method模式</h3><p>Template Method模式的这种优秀性质与语言是不是静态没有关系。</p><h3 id="避免高度依赖性的Observer模式"><a href="#避免高度依赖性的Observer模式" class="headerlink" title="避免高度依赖性的Observer模式"></a>避免高度依赖性的Observer模式</h3><p>Observer（观察者）模式是当某个对象的状态发生变化时，依存于该状态的全部对象都自动得到通知，而且为了让它们都得到通知，定义了对象间一对多的依存关系。<br>这是控制类与类之间依存关系的一种模式。<br>高度依赖性会导致组成程序的零件过大，避免高度依赖性的Observer模式，构成观察者模式的有两个对象，一个称谓Observer（观察者）接受变更通知；另一个称为Subject（对象）或Observable（被观察者），发出变更通知。<br>被观察者让人得到被动的印象，在实际处理中，被观察者会发出通知“我已经变化了哦”。</p><h3 id="Observable模块"><a href="#Observable模块" class="headerlink" title="Observable模块"></a>Observable模块</h3><p>Ruby中为实现Observer模式提供了名为observer的库。observer库提供observer模块。</p><h3 id="Observer模式与动态语言"><a href="#Observer模式与动态语言" class="headerlink" title="Observer模式与动态语言"></a>Observer模式与动态语言</h3><p>由于Ruby的动态性质，Observer库具有以下几方面的灵活性。</p><ol><li>观察者类不必是特定类的子类。</li><li>观察者类不必实现特定的接口（本来在Ruby中也没有接口）</li><li>观察者类的更新方法名可以自由决定</li><li>观察者类更新方法的参数可以自由决定</li><li>被观察者类不必是特定类的子类</li><li>对被观察者类的要求，只是将Observable模块包括进来。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说到事件监听模式,很容易将它和观察者模式联系在一起。</span><br><span class="line">实质上这两者完成同类型的工作。依个人理解，事件监听模式更像是观察者模式的进阶。</span><br><span class="line">事件监听机制就是对观察者模式进行了进一步抽象，节省了代码量。</span><br></pre></td></tr></table></figure><h2 id="设计模式（3）"><a href="#设计模式（3）" class="headerlink" title="设计模式（3）"></a>设计模式（3）</h2><h3 id="软件开发的悲剧"><a href="#软件开发的悲剧" class="headerlink" title="软件开发的悲剧"></a>软件开发的悲剧</h3><ol><li>复杂性</li><li>变化性</li></ol><p>软件的规模越大，各个部分之间的牵连越复杂，更改也就越难。<br>在软件开发过程中，需求变更几乎是不可避免的。</p><h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p><strong>对模块扩展必须开放，对修改必须封闭。</strong><br>为了应对将来的需要，扩展必须是开放的，但是即使某一模块的内部结构改变了，对外接口也应当是不变的。简称OCP。</p><h3 id="面向对象的情况"><a href="#面向对象的情况" class="headerlink" title="面向对象的情况"></a>面向对象的情况</h3><p>既要开放，又要封闭，看似互相矛盾，但是<strong>面向对象编程语言能够很彻底地消除这个矛盾。</strong></p><h3 id="非面向对象的情况"><a href="#非面向对象的情况" class="headerlink" title="非面向对象的情况"></a>非面向对象的情况</h3><p>非面向对象则很难处理好。<br><strong>面向对象的精髓在于对OCP的实践。至于把对象看做物体理解起来比较容易，能够建立现实世界的模型等，不过是锦上添花。</strong></p><h3 id="OCP与Template-Method模式"><a href="#OCP与Template-Method模式" class="headerlink" title="OCP与Template Method模式"></a>OCP与Template Method模式</h3><p>虽说使用面向对象语言的功能，可以实现OCP，但是只是说有这种可能性，并不是说什么时候都能实现。当然，虽然使用了面向对象语言，却做成了一个糟糕的设计，这种情况也是屡见不鲜。<br>分类中很多设计模式之所以优秀是因为经得起OCP所要求的变化。<br>Template Method模式，是满足OCP的基本手段。其他的设计模式都是利用多个类的关联来实现的，而Template Method模式则仅仅使用了继承，基本上无非是实现了一个抽象类。</p><h3 id="Observer模式"><a href="#Observer模式" class="headerlink" title="Observer模式"></a>Observer模式</h3><p>Observer模式是满足OCP的。<br>DRY也好，OCP也好，都不过是原则，根据具体情况，要做适当的选择，如果代码没有再利用的打算，也没有扩展功能的打算，也就没有必要生搬硬套设计模式。使用前有必要先做判断。</p><h3 id="使用Strategy模式"><a href="#使用Strategy模式" class="headerlink" title="使用Strategy模式"></a>使用Strategy模式</h3><p>Strategy（策略）模式是定义算法的集合，将各算法封装，使它们能够交换。利用Strategy模式，算法和利用这些算法的客户程序可以分别独立进行修改而不互相影响。<br>Strategy模式就是将容易变化的处理归纳为独立的对象，然后使它们能够互相交换，使用方法与将容易变化的处理交给子类的Template Method模式相类似。两个模式最大的区别在于，Strategy模式是独立的对象，能够动态交换处理逻辑。</p><h3 id="Strategy模式与OCP"><a href="#Strategy模式与OCP" class="headerlink" title="Strategy模式与OCP"></a>Strategy模式与OCP</h3><p>Strategy模式完全满足OCP。<br>世上很多设计模式，为了能应对将来可能的修改，都是按照OCP的要求来设计的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-4-设计模式&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-4-设计模式&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 4 设计模式&quot;&gt;&lt;/a&gt;松本行弘的程序世界 4 设计模式&lt;/h1&gt;&lt;h2 id=&quot;设计模式（1）&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
