<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-07-20T10:17:28.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>松本行弘的程序世界 10 高速执行和并行处理</title>
    <link href="https://github.com/zdkswd/2018/07/20/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2010%20%E9%AB%98%E9%80%9F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/</id>
    <published>2018-07-20T09:58:32.000Z</published>
    <updated>2018-07-20T10:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-10-高速执行和并行处理"><a href="#松本行弘的程序世界-10-高速执行和并行处理" class="headerlink" title="松本行弘的程序世界 10 高速执行和并行处理"></a>松本行弘的程序世界 10 高速执行和并行处理</h1><h2 id="让程序高速执行（前篇）"><a href="#让程序高速执行（前篇）" class="headerlink" title="让程序高速执行（前篇）"></a>让程序高速执行（前篇）</h2><h3 id="是不是越快越好"><a href="#是不是越快越好" class="headerlink" title="是不是越快越好"></a>是不是越快越好</h3><p>并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。</p><h3 id="高速执行的乐趣与效率"><a href="#高速执行的乐趣与效率" class="headerlink" title="高速执行的乐趣与效率"></a>高速执行的乐趣与效率</h3><p>在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。</p><h3 id="以数据为基础做出判断"><a href="#以数据为基础做出判断" class="headerlink" title="以数据为基础做出判断"></a>以数据为基础做出判断</h3><h3 id="改善系统调用"><a href="#改善系统调用" class="headerlink" title="改善系统调用"></a>改善系统调用</h3><p>排序处理任务重时，典型的对策是使用施瓦茨变换。</p><h3 id="数据可靠吗"><a href="#数据可靠吗" class="headerlink" title="数据可靠吗"></a>数据可靠吗</h3><p>误差</p><h3 id="只需改善瓶颈"><a href="#只需改善瓶颈" class="headerlink" title="只需改善瓶颈"></a>只需改善瓶颈</h3><p>性能优化中，“因为是排序，所以就用施瓦茨变换”这种条件反射式的对策并非总管用。为了合理提高速度，确立恰当的策略是很必要的。<br>帕累托法则又称80/20法则，即80%的数值是由20%的构成要素产生的。由帕累托法则可知，有20%的努力可以达到巨大回报，而有80%的努力得不到多少回报。在得不到回报的地方，不管怎么努力都是徒劳的。<br>Donald Knuth也提到，通常一半以上的执行时间都耗费在程序中不到4%的部分。<br>这些耗费了大半以上执行时间的部分称为瓶颈。<br>判定瓶颈，可以用profiler这一工具。</p><h3 id="profiler本身成了累赘"><a href="#profiler本身成了累赘" class="headerlink" title="profiler本身成了累赘"></a>profiler本身成了累赘</h3><p>不确定性原理是指测定行为本身对被测对象产生了影响，从原理上可以说不可能正确知道对象的状态。但是知道实际状态的大体倾向。</p><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>选择合适的算法，这是性能改善的第一考虑因素，要记住这条铁则。</p><h3 id="理解O记法"><a href="#理解O记法" class="headerlink" title="理解O记法"></a>理解O记法</h3><p>如何从效率方面判定一个算法的好坏呢。一个方法就是O记法，表示某种算法对于变量（比如使用的元素个数）如何变化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8A%E5%8D%8811.05.39.png" alt="屏幕快照 2018-07-20 上午11.05.39" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 上午11.05.39</div>            </figure></p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><h3 id="调查算法的性能"><a href="#调查算法的性能" class="headerlink" title="调查算法的性能"></a>调查算法的性能</h3><p>Ruby提供进行算法性能比较时用的benchmark程序。</p><h3 id="高速执行的悲哀"><a href="#高速执行的悲哀" class="headerlink" title="高速执行的悲哀"></a>高速执行的悲哀</h3><h4 id="徒劳无益的努力"><a href="#徒劳无益的努力" class="headerlink" title="徒劳无益的努力"></a>徒劳无益的努力</h4><p>很容易在瓶颈无关的地方花费太多徒劳无益的努力。</p><h4 id="改良绊住了手脚"><a href="#改良绊住了手脚" class="headerlink" title="改良绊住了手脚"></a>改良绊住了手脚</h4><p>sort_by所依据的施瓦茨变换，是用时间和空间的交换来消减计算量的方法。sort_by方法与sort方法相比，占用了多达三倍以上的内存。所以，模块内的处理本来不是很重，如果一味地占用内存反而可能会变慢。<br>性能优化，光有理论还不行，如果不实际做的话就不知道到底什么是正确的。</p><h4 id="算法选择的圈套"><a href="#算法选择的圈套" class="headerlink" title="算法选择的圈套"></a>算法选择的圈套</h4><p>在进行性能优化时，不改变原来程序的执行时一个大原则。</p><h3 id="性能优化的格言"><a href="#性能优化的格言" class="headerlink" title="性能优化的格言"></a>性能优化的格言</h3><p><strong>过早的优化是万恶之源。</strong></p><p><strong>优化有两条准则。</strong><br><strong>1.别做优化</strong><br><strong>2.（仅适用于专家）先不要做优化</strong></p><hr><p><strong>过早的优化是万恶之源</strong><br>代码优化的好处多多，但是这并不意味着所有的代码都需要进行优化，有时过度的优化反而适得其反——费时、费力、不讨好。<br>“现代计算机科学的鼻祖”Donald Knuth曾说过“过早的优化是万恶之源”，因为：让正确的程序更快，要比让快速的程序正确容易得多。<br>在项目开发中，总是有程序员浪费宝贵的时间去改进那些不需要改进的代码，而没有通过所做的改进增加价值。在对项目进行优化时，究竟哪些地方应该优化，应该如何优化，哪些不应该优化呢？你需要先来了解一下本文所说的这7件事。<br>1.究竟要优化什么？<br>在优化工作开始的时候，你还尚未明确优化内容和目的，那么你很容易陷入误区。在一开始，你就应该清楚地了解你要达到的效果，以及其他优化相关的各种问题。这些目标需要明确指出（至少精通技术的项目经理可以理解和表达它），接下来，在整个优化过程中，你需要坚持这些目标。<br>在实际的项目开发中，经常会存在各种各样的变数。可能一开始时要优化这一方面，随后你可能会发现需要优化另一方面。这种情况下，你需要清晰地了解这些变化，并确保团队中的每个人都明白目标已经发生了变化。<br>2.选择一个正确的优化指标<br>选择正确的指标，是优化的一个重要组成部分，你需要按照这些指标来测量优化工作的进展情况。如果指标选择不恰当，或者完全错误，你所做的努力有可能白费了。<br>即使指标正确，也必须有一些辨别。在某些情况下，将最多的努力投入到运行消耗时间最多的那部分代码中，这是实用的策略。但也要记住，Unix/Linux内核的大部分时间花费在了空循环上。<br>需要注意的是，如果你轻易选择了一个很容易达到的指标，这作用不大，因为没有真正解决问题。你有必要选择一个更复杂的、更接近你的目标的指标。<br>3.优化在刀刃上<br>这是有效优化的关键。找到项目中与你的目标（性能、资源或其他）相背的地方，并将你的努力和时间用在那里。<br>举一个典型的例子，一个Web项目速度比较慢，开发者在优化时将大部分精力放在了数据库优化上，最终发现真正的问题是网络连接慢。<br>另外，不要分心于容易实现的问题。这些问题尽管很容易解决，但可能不是必要的，或与你的目标不相符。容易优化并不意味着值得你花费工夫。<br>4.优化层次越高越好<br>在一般情况下，优化的层次越高，就会越有效。根据这个标准，最好的优化是找到一个更有效的算法。<br>举个例子，在一个软件开发项目中，有一个重要的应用程序性能较差，于是开发团队开始着手优化，但性能并没有提升太多，之后，项目人员交替，新的开发人员在检查代码时发现，性能问题的核心是由于在表中使用了冒泡排序算法，导致成千上万项的增加。<br>尽管如此，高层次的优化也不是“银弹”。一些基本技术，如将所有东西移到循环语句外，也可以产生一些优化的效果。通常情况下，大量低层次的优化可以产生等同于一个高层次优化的效果。<br>还需要注意的是，高层次优化，会减少一些代码块，那么你之前对这些代码块所做的优化就没有任何意义了，因此，刚开始就应该考虑高层次的优化。<br>5.不要过早优化<br>在项目早期就进行优化，会导致你的代码难以阅读，或者会影响运行。另一方面，在项目后期，你可能会发现之前所做的优化没有起到任何作用，白白浪费了时间和精力。<br>正确的方式是，你应该将项目开发和优化当作两个独立的步骤来做。<br>6.依赖性能分析，而不是直觉<br>你往往会认为你已经知道哪里需要优化，这是不可取的，尤其是在复杂的软件系统中，性能分析数据应该是第一位的，最后才是直觉。<br>优化的一个有效的策略是，你要根据所做工作对优化效果的影响来进行排序。在开始工作之前找到影响最大的“路障”，然后再处理小的“路障”。<br>7.优化不是万金油<br>优化最重要的规则之一是，你无法优化一切，甚至无法同时优化两个问题。比如，优化了速度，可能会增加资源利用；优化了存储的利用率，可能会使其他地方放慢。你需要权衡一下，哪个更符合你的优化目标。</p><hr><h2 id="让程序高速执行（后篇）"><a href="#让程序高速执行（后篇）" class="headerlink" title="让程序高速执行（后篇）"></a>让程序高速执行（后篇）</h2><p>例题是曼德勃罗集合的计算程序，指复平面上满足以下条件的复素数的集合：经过某种反复迭代运算以后，其值不会发散到无限大。</p><h3 id="确认程序概要"><a href="#确认程序概要" class="headerlink" title="确认程序概要"></a>确认程序概要</h3><h3 id="发现瓶颈"><a href="#发现瓶颈" class="headerlink" title="发现瓶颈"></a>发现瓶颈</h3><p>使用profiler</p><h3 id="使用更好地profiler"><a href="#使用更好地profiler" class="headerlink" title="使用更好地profiler"></a>使用更好地profiler</h3><p>ruby-prof程序通过使用扩展库可以实现高速profile</p><h3 id="高速优化之一：消减对象"><a href="#高速优化之一：消减对象" class="headerlink" title="高速优化之一：消减对象"></a>高速优化之一：消减对象</h3><p>Ruby高速优化的规则。</p><h4 id="减少对象"><a href="#减少对象" class="headerlink" title="减少对象"></a>减少对象</h4><p>高级面向对象语言中对象的生成要花费一定的时间，减少对象，除了会降低生成成本外，还有别的好处。<br>Ruby中不在使用的对象，由被称作垃圾收集的处理自动进行回收。垃圾收集处理需要检查对象的引用关系，任何地方都不再引用的对象会被判定为已经不再使用了。当对象的数量很多时，判断成本就要增大。</p><h4 id="减少方法调用"><a href="#减少方法调用" class="headerlink" title="减少方法调用"></a>减少方法调用</h4><p>方法调用中，存在多态性这一面向对象的本质特征，先要评价参数，判定对象种类，然后选出一个合适的方法，再讲控制交给该方法，这是一个缓慢的处理过程。<br>为了避开方法调用，尽可能不用Ruby中实现的方法。Ruby中实现的方法，几乎所有的情况都是调用其他方法来实现的。也就是说，只要使用了一次Ruby中实现的方法，就会有多余的方法调用发生。</p><h3 id="高速优化之二：利用立即值"><a href="#高速优化之二：利用立即值" class="headerlink" title="高速优化之二：利用立即值"></a>高速优化之二：利用立即值</h3><p>Ruby中有几类对象并不实际分配内存，而是用引用本身来表示，这种值称为立即值。<br>现在的Ruby中，小的整数（±2    ^30以内）、真假值、nil和符号名等都是立即值。<br>立即值既然不生成对象，就不用担心对象的生成成本，而且也不用垃圾收集处理，所以它具有特别理想的特性。</p><h3 id="高速优化之三：利用C语言"><a href="#高速优化之三：利用C语言" class="headerlink" title="高速优化之三：利用C语言"></a>高速优化之三：利用C语言</h3><p>Ruby是解释性语言，单纯计算的循环不是很快。如果将处理交给编译器，就可以变得很快。</p><h3 id="高速优化之四：采用合适的数据结构"><a href="#高速优化之四：采用合适的数据结构" class="headerlink" title="高速优化之四：采用合适的数据结构"></a>高速优化之四：采用合适的数据结构</h3><h3 id="全部以C语言计算"><a href="#全部以C语言计算" class="headerlink" title="全部以C语言计算"></a>全部以C语言计算</h3><h3 id="还存在其他技巧"><a href="#还存在其他技巧" class="headerlink" title="还存在其他技巧"></a>还存在其他技巧</h3><p>还有以空间换时间。</p><h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><p>与进程不同，同一进程的线程可以共享内存空间，所以，不同的线程能够引用同一对象。不需要经过将数据变为字节流再进行通信这样麻烦的处理，就能交换信息。</p><h3 id="生成线程"><a href="#生成线程" class="headerlink" title="生成线程"></a>生成线程</h3><h3 id="线程的执行状态"><a href="#线程的执行状态" class="headerlink" title="线程的执行状态"></a>线程的执行状态</h3><p>Ruby的线程有四种状态。<br>run：执行中<br>stop：停止中<br>to_kill:终止处理中<br>killed:终止<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%881.55.11.png" alt="屏幕快照 2018-07-20 下午1.55.11" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午1.55.11</div>            </figure></p><h3 id="传递值给线程的方法"><a href="#传递值给线程的方法" class="headerlink" title="传递值给线程的方法"></a>传递值给线程的方法</h3><h3 id="信息共享所产生的问题"><a href="#信息共享所产生的问题" class="headerlink" title="信息共享所产生的问题"></a>信息共享所产生的问题</h3><ol><li>数据完整性丧失</li><li>死锁</li></ol><p><strong>与其说是线程的问题，不如说是并行处理本身的问题。</strong></p><h3 id="数据完整性的丧失"><a href="#数据完整性的丧失" class="headerlink" title="数据完整性的丧失"></a>数据完整性的丧失</h3><p>原子操作</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>哲学家进餐问题</p><h3 id="用锁来实现对资源的独占"><a href="#用锁来实现对资源的独占" class="headerlink" title="用锁来实现对资源的独占"></a>用锁来实现对资源的独占</h3><p>Ruby Mutex类，互斥锁。<br>Java中，方法定义声明为synchronize,该方法被调用时自动加锁。</p><h3 id="二级互斥"><a href="#二级互斥" class="headerlink" title="二级互斥"></a>二级互斥</h3><p>很遗憾，锁的问题并不全是Mutex所能覆盖的单纯事例。如数据库中，对数据的访问需要以下多种互斥控制。</p><ol><li>可以同时引用</li><li>禁止同时更新</li><li>禁止更新中引用</li><li>禁止引用中更新</li></ol><p>引用与更新这种两个层次的互斥（二级互斥），在文件读取时也经常会发生。</p><hr><p><strong>数据库锁总结</strong></p><p>数据库锁出现的原因是为了处理并发问题，因为数据库是一个多用户共享的资源，当出现并发的时候，就会导致出现各种各样奇怪的问题，就像程序代码一样，出现多线程并发的时候，如果不做特殊控制的话，就会出现意外的事情，比如“脏“数据、修改丢失等问题。所以数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制，所以数据库锁是跟并发控制和事务联系在一起的。</p><p>平时会经常看到或者听到数据库锁有“共享锁”，“排它锁”，“互斥锁”，“写锁”，“读锁”，“悲观锁”，“乐观锁”，“行级锁”，“表级锁”，“页级锁”等，同时我们还会常看到“丢失修改“，”不可重复读“，”读脏数据“这三个术语，他们究竟是什么关系以及怎么理解呢，下面就来介绍一下他们。</p><p>先说事务的特性，要想成为事务，必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；一致性指的是事务的执行结果必须是使数据库从一个一致性状态变大另一个一致性状态，一致性和原子性是密切相关的；隔离性指的是一个事务执行不能被其他事务干扰；持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。</p><p>先说悲观锁和乐观锁吧。并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。乐观锁就比较简单了，就是不做控制，这只是一部分人对于并发所持有的一种态度而已。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁和共享锁，其中排它锁又称为写锁，共享锁又称为读锁。</p><p>共享锁和排它锁是具体的锁，是数据库机制上的锁，存在以下关系：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%882.17.40.png" alt="屏幕快照 2018-07-20 下午2.17.40" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午2.17.40</div>            </figure></p><p>(x表示是排它锁(Exclusive)，s表示共享锁(Share)，Y表示yes，N表示no）</p><p>上图表示可以共存的锁，如，第二行表示，一个事务T1给某数据加了X锁，则事务T2就不能再给那数据加X锁了，同时也不能再加S锁了，只有到T1事务提交完成之后，才可以。默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁。<br>另外，并发操作会导致数据的不一致性，主要包括“丢失数据”，“不可重复读”，“读脏数据等。还有就是，并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防，预防的方法有：1一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；2顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。另外，系统如何判断出现死锁呢，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁，诊断和判断死锁有两种方法，一是超时法，二是等待图法。超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。</p><p>最后，说下行级锁和表级锁。锁包括行级锁和表级锁<br>行级锁是一种排他锁，防止其他事务修改此行。</p><hr><h3 id="用队列协调线程"><a href="#用队列协调线程" class="headerlink" title="用队列协调线程"></a>用队列协调线程</h3><p>使用锁对资源进行互斥控制，是线程间保证协调的一种机制。除了锁以外，为了保证协调，还有别的方法。<br>问题的根源在于多个进程访问同一资源，为了实现无共享，给每个资源准备一个管理用的线程，各线程间只能交换某些限定的信息。<br>线程间信息交换的方法有代表性的有信息存储，信道及队列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.05.36.png" alt="屏幕快照 2018-07-20 下午3.05.36" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.05.36</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的生产者消费者问题并不是典型的生成者消费者问题，而是做出了一定的限制，即生产速度小于消费速度。不锁buffer,仅做信息传递的通道来进行说明。</span><br></pre></td></tr></table></figure><p>队列也可以用于解决资源的竞争。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.08.13.png" alt="屏幕快照 2018-07-20 下午3.08.13" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.08.13</div>            </figure></p><h3 id="锁模型与队列模型的比较"><a href="#锁模型与队列模型的比较" class="headerlink" title="锁模型与队列模型的比较"></a>锁模型与队列模型的比较</h3><h4 id="锁模型"><a href="#锁模型" class="headerlink" title="锁模型"></a>锁模型</h4><p>如果竞争足够少，多数情况下能保持较高性能，对于资源的竞争，不能忘记加锁，要做到完美无缺较难。</p><h4 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h4><p>在竞争少的时候，其性能比不上锁模型，比锁模型更容易贯彻，会因线程增多而带来性能低下的恶果。</p><h2 id="前景可期的并行编程技术，Actor"><a href="#前景可期的并行编程技术，Actor" class="headerlink" title="前景可期的并行编程技术，Actor"></a>前景可期的并行编程技术，Actor</h2><p>并行编程，要求有更高的抽象度和对人类而言更简单的编程模型。Actor（参与者模式）或许就是答案。</p><h3 id="何谓Actor"><a href="#何谓Actor" class="headerlink" title="何谓Actor"></a>何谓Actor</h3><p>所谓Actor，是（仅）通过消息（message）进行通信的实体。<br>与面向对象语言中对象的区别。向对象发送消息（方法调用），调用开始后，会一直等到返回结果，是一种同步方式。面向Actor发送消息，仅仅是发送消息而不返回结果，是一种异步方式。<br>Actor由于仅仅通过消息进行信息交换，所以不能直接共享同一个值，信息传达要多花些代价。<br>Actor由于没有消息以外的信息传递手段，所以不用担心Actor之间的资源竞争。发送给Actor的消息都配送到各个Actor所拥有的邮箱里。多个消息同时到达时竞争由内嵌到系统中的排除机制来处理。<br>Actor的一大优点是安全，更大的优点是易懂。Actor根据消息进行处理，必要的化会向其他Actor传递消息，或向Actor返回消息。<br>这与现实世界中人与人之间相处没有多大的差别。现实世界中，别人在想什么你不知道，想要求什么时，需要通过某种手段传递“消息”。<br>理论上要到达最高性能，一般认为线程更优秀。但如果不注意使用线程的话，会出现与时机相关的很麻烦的问题。在计算机性能日益提高的今天，与理论上最高性能的可能性相比，Actor的安全性和易懂性更引人注目。</p><h3 id="操作Actor的三种处理系统"><a href="#操作Actor的三种处理系统" class="headerlink" title="操作Actor的三种处理系统"></a>操作Actor的三种处理系统</h3><p>Actor Model的函数型语言Erlang。<br>Erlang是只允许单一赋值的函数型语言，即一旦赋值，变量的值就不再改变。</p><h3 id="Erlang的程序"><a href="#Erlang的程序" class="headerlink" title="Erlang的程序"></a>Erlang的程序</h3><h3 id="pingpong处理的开始"><a href="#pingpong处理的开始" class="headerlink" title="pingpong处理的开始"></a>pingpong处理的开始</h3><h3 id="启动pingpong程序"><a href="#启动pingpong程序" class="headerlink" title="启动pingpong程序"></a>启动pingpong程序</h3><h3 id="Erlang的错误处理"><a href="#Erlang的错误处理" class="headerlink" title="Erlang的错误处理"></a>Erlang的错误处理</h3><p>Erlang中通过发送消息来通知异常终止。收到消息的process（actor）料理死去的process后事。<br>有了这种机制，使得Erlang适合构造抗障碍性强的系统。</p><h3 id="Erlang的使用场所"><a href="#Erlang的使用场所" class="headerlink" title="Erlang的使用场所"></a>Erlang的使用场所</h3><p>Erlang在通常的文本处理汇总并不怎么快。Erlang的好处在于其扩展性。对于多个处理并列执行的情况，分割成合适的Erlang process，能够发挥多CPU的威力。<br>同样的多任务分割虽然用操作系统的进程或线程也能实现，但Erlang的process与操作系统的进程或线程相比，能够轻量实现（1个process最小只耗费300字节），即使有大量process也不必顾虑、更进一步说，Erlang设计思想不用process连基本处理都不能实现，process分割在某种意义上可以说是强制的。</p><p>适合现代服务器端程序。</p><h3 id="面向Ruby的库“Revactor”"><a href="#面向Ruby的库“Revactor”" class="headerlink" title="面向Ruby的库“Revactor”"></a>面向Ruby的库“Revactor”</h3><p>Revactor的目的是为Ruby提供Erlang式的编程。<br>其优点是可以同时体验Ruby和Erlang的好处。但是Revactor中Actor的实现不是靠线程而是靠Fiber。Erlang的目的在于最大限度地利用多核CPU，而Revactor并不适合这种目的。<br>Revactor的最大优点，是能够在等待文件输入输出时，将程序的停止控制在最小程度。</p><h3 id="另一个库Dramatis"><a href="#另一个库Dramatis" class="headerlink" title="另一个库Dramatis"></a>另一个库Dramatis</h3><p>Dramatis是Ruby中另一个Actor库。函数型语言Erlang不支持面向对象功能。用Ruby这样的面向对象语言来实现Actor的时候，即使用普通对象来实现Actor，也不可避免地会出现把方法调用和发送消息这两种类似概念混在一起的情况。Dramatis库就是解答这种“概念混淆”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-10-高速执行和并行处理&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-10-高速执行和并行处理&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 10 高速执行和并行处理&quot;&gt;&lt;/a&gt;松本行弘的程序世界 10 高速执行和并行
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 3 Android控件架构与自定义控件详解</title>
    <link href="https://github.com/zdkswd/2018/07/18/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%203%20Android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/zdkswd/2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/</id>
    <published>2018-07-18T07:27:32.000Z</published>
    <updated>2018-07-18T09:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-3-Android控件架构与自定义控件详解"><a href="#Android群英传-3-Android控件架构与自定义控件详解" class="headerlink" title="Android群英传 3 Android控件架构与自定义控件详解"></a>Android群英传 3 Android控件架构与自定义控件详解</h1><h2 id="Android控件架构"><a href="#Android控件架构" class="headerlink" title="Android控件架构"></a>Android控件架构</h2><p>控件大致被分为两类，即ViewGroup控件与View控件。<br>通过ViewGroup，整个界面的控件形成了一个树形结构控件树。上层控件负责下层子控件的测量与绘制，并传递交互事件。findViewById（）方法，就是在控件树以数<strong>深度优先</strong>来遍历查找对应的元素。<br>每颗控件树的顶部，都有一个ViewParent对象，为整棵树的控制核心，所有的交互管理事件都由它统一调度和分配，从而可以对整个视图进行整体控制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.31.03.png" alt="屏幕快照 2018-07-17 下午2.31.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.31.03</div>            </figure><br>通常，在Activity中使用setContentView（）方法来设置一个布局，在调用该方法后，布局内容才真正的显示出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.36.21.png" alt="屏幕快照 2018-07-17 下午2.36.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.36.21</div>            </figure><br>每个Activity都包含一个Window对象，由PhoneWindow来实现。PhoneWindow将一个DecorView设置为整个应用窗口的根View。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通用方法。DecorView将要显示的具体方法呈现在PhoneWindow上，这里面的所有View的监听事件通过<strong>WindowManageService</strong>来进行验收，并通过Activity对象来回调相应的onClickListener。<br>在显示上，它将屏幕分为两部分，TitleView和ContentView。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.45.14.png" alt="屏幕快照 2018-07-17 下午2.45.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.45.14</div>            </figure><br>其中ViewGroup会根据对应参数设置不同的布局，如最常用的布局。而如果用户通过设置requestWindowFeature(Window.FEATURE_NO_TITLE)来设置全屏显示，视图树中的布局就只有Content了，这就解释了为什么调用requestWindowFeature()方法一定要在调用setContentView()方法之前才能生效的原因。<br>在代码中，当程序在onCreate（）方法中调用setContentView（）方法后，ActivityManagerService会回调onResume（）方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。</p><h2 id="View的测量"><a href="#View的测量" class="headerlink" title="View的测量"></a>View的测量</h2><p>系统在绘制View前，必须对View进行测量，即告诉系统该画一个多大的View，在onMeasure（）方法中进行。<br>通过系统提供的设计精悍功能强大的类<strong>MeasureSpec</strong>类来测量View。MeasureSpec为32位int值，高2位位测量的模式，低30位为测量的大小，在计算中使用位运算是为了提高并优化效率。<br>测量模式为3种：</p><ol><li>EXACTLY<br>即精确值模式，当我们将控件的layout_width或layout_height属性指定为具体数值时，或指定为match_parent属性时（占据父View的大小），系统使用的是EXACTLY模式。</li><li>AT_MOST<br>即最大值模式，当控件的layout_width或layout_height属性指定为wrap_content时，控件大小一般岁总监的子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。</li><li>UNSPECIFID<br>不指定大小测量模式，View想多大就多大，通常情况下在绘制自定义View时才会使用。</li></ol><p>View类默认的onMeasure（）方法只支持EXACTLY模式，所以如果自定义控件时不重写onMeasure方法的话，就只能使用EXACTLY模式。控件可以响应你指定的具体宽高值或是match_parent属性。而如果要让自定义View支持<strong>wrap_content</strong>属性，那么就必须重写onMeasure（）方法来指定wrap_content时的大小，如果不重写，就不知道该使用默认多大的尺寸，因此，就会默认填充整个父布局，所以重写onMeasure（）方法的目的，就是为了能够给View一个wrap_content属性下的默认大小。</p><h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>测量好一个View后，我们就可以重写onDraw（）方法，在Canvas对象上来绘制所需要的图形。<br>当创建一个Canvas对象时，需要传进去一个bitmap对象。这个bitmap用来存储所有绘制在Canvas上的像素信息。调用所有的Canvas.drawXXX方法都发生在这个bitmap上。</p><p>##ViewGroup的测量<br>ViewGroup会去管理子View，就有负责子View的显示大小。当ViewGroup大小为wrap_content时，就需要对子View进行遍历，以获得所有子View的大小，从而决定自己的大小。其他模式则会通过具体的指定值来设置自身的大小。<br>ViewGroup在测量时通过遍历所有的子View，从而调用View的Measure方法来获得每一个子View的测量结果。<br>当子View测量完毕时，就需要将子View放到合适的位置，这个过程就是View的Layout过程。ViewGroup在执行Layout过程时，同样是使用遍历来调用子View的Layout方法，并制定其具体显示的位置从而来决定其布局位置。<br>在定义ViewGroup时，通常会重写onLayout方法来控制其子View显示位置的逻辑。同样，如果要支持wrap_content属性，必须重写onMeasure。</p><h2 id="ViewGroup的绘制"><a href="#ViewGroup的绘制" class="headerlink" title="ViewGroup的绘制"></a>ViewGroup的绘制</h2><p>ViewGroup通常不需要绘制，如果不是指定了ViewGroup的背景颜色，ViewGroup的onDraw方法都不会被调用，但是，ViewGroup会使用dispatchDraw()方法来绘制其子View，其过程同样是通过遍历所有的子View，并调用子View绘制方法来完成绘制。</p><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><p>在自定义View时，我们通常会去重写onDraw()来绘制View的显示内容，如果该View还需要使用wrap_content属性，那么还必须重写onMeasure()方法。另外，通过自定义attrs属性，还可以设置新的属性配置值。<br>在View中通常有以下一些比较重要的回调方法。</p><ul><li>onFinishInflate():从XML加载组件后回调。</li><li>onSizeChanged():组件大小改变时回调。</li><li>onMeasure():回调该方法来进行测量。</li><li>onLayout():回调该方法来确定显示的位置。</li><li>onTouchEvent():监听到触摸事件时回调。</li></ul><p>通常有以下方法来实现自定义的控件。</p><ul><li>对现有控件进行扩展。 </li><li>通过组合来实现新的控件。</li><li>重写View来实现全新的控件。 </li></ul><h3 id="对现有控件进行扩展"><a href="#对现有控件进行扩展" class="headerlink" title="对现有控件进行扩展"></a>对现有控件进行扩展</h3><p>可以再onDraw()方法中对原生控件行为进行扩展。<br>程序调用super.onDraw(canvas)方法来实现原生控件的功能。</p><h3 id="创建复合控件"><a href="#创建复合控件" class="headerlink" title="创建复合控件"></a>创建复合控件</h3><p>创建复合控件可以很好地创建出具有重用功能的控件集合。这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，再给它添加指定功能的控件，从而组合成新的复合控件。通过这种方式创建的控件，我们一般会给它指定一些可配置的属性，让它具有更强的扩展性。</p><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><p>为一个View提供可自定义的属性非常简单，只需要在res资源目录的values目录下创建一个attrs.xml的属性定义文件，并在该文件中通过代码定义相应的属性即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.04.48.png" alt="屏幕快照 2018-07-17 下午5.04.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.04.48</div>            </figure></p><p>在代码中通过&lt; declare-styleable&gt;标签声明了使用自定义属性，通过name属性来确定引用的名称。通过&lt; attr&gt;标签来声明具体的自定义属性。通过format属性来指定属性的类型。<br>在确定好属性后，就可以创建一个自定义控件，让它继承自ViewGroup，从而组合一些需要的控件。在构造方法中，通过TypedArray对象的getString()和getColor()等方法，就可以获取这些定义的属性值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.11.26.png" alt="屏幕快照 2018-07-17 下午5.11.26" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.11.26</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.12.42.png" alt="屏幕快照 2018-07-17 下午5.12.42" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.12.42</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.13.03.png" alt="屏幕快照 2018-07-17 下午5.13.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.13.03</div>            </figure><p>当获取完所有的属性值后，需要调用TypedArray的recyle方法来完成资源的回收。</p><h4 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h4><p>通过动态添加控件的方式，使用addView（）方法将控件加入到模板中，并给它们设置前面所获取到的具体的属性值，如文字颜色、大小等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.16.29.png" alt="屏幕快照 2018-07-17 下午5.16.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.16.29</div>            </figure></p><p>定义接口<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.21.03.png" alt="屏幕快照 2018-07-17 下午5.21.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.21.03</div>            </figure></p><p>暴露接口给调用者<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.25.21.png" alt="屏幕快照 2018-07-17 下午5.25.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.25.21</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.25.46.png" alt="屏幕快照 2018-07-17 下午5.25.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.25.46</div>            </figure><p>实现接口回调<br>在调用者的代码中，调用者需要实现这样一个接口，并完成接口中的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.28.58.png" alt="屏幕快照 2018-07-17 下午5.28.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.28.58</div>            </figure></p><p>除了通过接口回调的方式来动态的控制UI模板，同样可以使用公共方法来动态地修改UI模板中的UI。这样可以进一步提高模板的可定制性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.31.54.png" alt="屏幕快照 2018-07-17 下午5.31.54" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.31.54</div>            </figure></p><h4 id="引用UI模板"><a href="#引用UI模板" class="headerlink" title="引用UI模板"></a>引用UI模板</h4><p>在需要使用的地方引用UI模板，在引用前，需要指定第三方控件的命名空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.33.56.png" alt="屏幕快照 2018-07-17 下午5.33.56" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.33.56</div>            </figure><br>这行代码就是在指定引用的命名空间xmlns，即xml namespace。这里指定了名字空间为“android”，因此在接下来使用系统属性时，才可以使用“android:”来引用Android的系统属性。如果要使用自定义的属性，就需要创建自己的名字空间。在Android Studio中，第三方的控件都使用如下代码来引入名字空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.39.45.png" alt="屏幕快照 2018-07-17 下午5.39.45" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.39.45</div>            </figure><br>这里我们将引入的第三方控件的名字空间取名为custom，之后再xml文件中使用自定义的属性时，就可以通过这个名字空间来引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.41.56.png" alt="屏幕快照 2018-07-17 下午5.41.56" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.41.56</div>            </figure><br>使用自定义的View与系统原生的View的最大区别就是在申明控件时，需要指定完整的包名，而在引用自定义的属性时，需要使用自定义的xmls名字。<br>再更进一步，将这个UI模板写到一个布局文件中，在其他的布局文中，直接通过&lt; include&gt;标签来引用这个UI模板的View。</p><h3 id="重写View来实现全新的控件"><a href="#重写View来实现全新的控件" class="headerlink" title="重写View来实现全新的控件"></a>重写View来实现全新的控件</h3><p>当Android系统原生的控件无法满足我们的需求时，我们就可以完全创建一个新的自定义View来实现需要的功能。通常需要继承View类，重写onDraw，onMeasure来实现绘制逻辑，同时重写onTouchEvent等触控时间来实现交互逻辑。还可以像实现组合控件那样，通过引入自定义属性，丰富自定义View的可定制性。</p><h4 id="弧线展示图"><a href="#弧线展示图" class="headerlink" title="弧线展示图"></a>弧线展示图</h4><h4 id="音频条形图"><a href="#音频条形图" class="headerlink" title="音频条形图"></a>音频条形图</h4><h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><p>重写onMeasure来对子View进行测量，重写onLayout确定子View的位置，重写onTouchEvent增加响应事件。</p><h2 id="事件拦截机制分析"><a href="#事件拦截机制分析" class="headerlink" title="事件拦截机制分析"></a>事件拦截机制分析</h2><p>Android为触摸事件封装了一个类MotionEvent，里面封装了触摸点的坐标，点击事件的类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.08.26.png" alt="屏幕快照 2018-07-18 下午3.08.26" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.08.26</div>            </figure><br>对于ViewGroup重写了三个方法：<br><strong>dispatchTouchEvent</strong><br><strong>onInterceptTouchEvent</strong><br><strong>onTouchEvent</strong><br>对于View来说，重写了两个方法：<br><strong>onTouchEvent</strong><br><strong>dispatchTouchEvent</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.12.38.png" alt="屏幕快照 2018-07-18 下午3.12.38" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.12.38</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.12.47.png" alt="屏幕快照 2018-07-18 下午3.12.47" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.12.47</div>            </figure><br><strong>dispatchTouchEvent</strong>基本不用动。<br>事件拦截的核心方法是<strong>onInterceptTouchEvent</strong>返回值：True，拦截，不继续；False，不拦截，继续流程。<br>事件处理<strong>onTouchEvent</strong>返回值：True，处理了，不用给上级汇报了，上级不会继续处理了；False，给上级处理。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.20.48.png" alt="屏幕快照 2018-07-18 下午3.20.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.20.48</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-3-Android控件架构与自定义控件详解&quot;&gt;&lt;a href=&quot;#Android群英传-3-Android控件架构与自定义控件详解&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 3 Android控件架构与自定义
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 2 Android开发工具新接触</title>
    <link href="https://github.com/zdkswd/2018/07/14/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%202%20Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%96%B0%E6%8E%A5%E8%A7%A6/"/>
    <id>https://github.com/zdkswd/2018/07/14/Android群英传 2 Android开发工具新接触/</id>
    <published>2018-07-14T04:18:32.000Z</published>
    <updated>2018-07-14T04:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-2-Android开发工具新接触"><a href="#Android群英传-2-Android开发工具新接触" class="headerlink" title="Android群英传 2 Android开发工具新接触"></a>Android群英传 2 Android开发工具新接触</h1><h2 id="Android开发IDE介绍"><a href="#Android开发IDE介绍" class="headerlink" title="Android开发IDE介绍"></a>Android开发IDE介绍</h2><h2 id="ADB命令使用技巧"><a href="#ADB命令使用技巧" class="headerlink" title="ADB命令使用技巧"></a>ADB命令使用技巧</h2><p>ADB–Android Debug Bridge，借助此工具，我们可以用电脑来操作手机。</p><h3 id="ADB基础"><a href="#ADB基础" class="headerlink" title="ADB基础"></a>ADB基础</h3><p>ADB工具位于SDK的platform-tools目录下。<br>手机助手也是使用ADB来实现它的功能。<br>手机端需要开发者模式，USB Debug。</p><h4 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h4><p>可以使用Linux Shell命令。</p><h4 id="android-list-targets"><a href="#android-list-targets" class="headerlink" title="android list targets"></a>android list targets</h4><p>显示系统中全部Android平台</p><h4 id="adb-install-r-程序-apk"><a href="#adb-install-r-程序-apk" class="headerlink" title="adb install -r 程序.apk"></a>adb install -r 程序.apk</h4><p>安装apk程序之install</p><h4 id="abd-push-lt-local-gt-lt-remote-gt"><a href="#abd-push-lt-local-gt-lt-remote-gt" class="headerlink" title="abd push &lt; local&gt; &lt; remote&gt;"></a>abd push &lt; local&gt; &lt; remote&gt;</h4><p>安装apk程序之push<br>两者都可以安装上APK，但是install是安装到data/data目录中，作为普通的用户应用程序。push则不是安装命令，是将文件写入手机的存储系统，所以，只要拥有相应的权限，就可以把任何Apk放到任何目录中，甚至是System目录下成为一个系统应用程序。</p><h4 id="abd-push-lt-local-gt-lt-remote-gt-1"><a href="#abd-push-lt-local-gt-lt-remote-gt-1" class="headerlink" title="abd push &lt; local&gt; &lt; remote&gt;"></a>abd push &lt; local&gt; &lt; remote&gt;</h4><p>向手机写入文件</p><h4 id="abd-pull-lt-local-gt-lt-remote-gt"><a href="#abd-pull-lt-local-gt-lt-remote-gt" class="headerlink" title="abd pull &lt; local&gt; &lt; remote&gt;"></a>abd pull &lt; local&gt; &lt; remote&gt;</h4><p>从手机获取文件。<br>这些东西在Android Device Monitor工具都可以直接使用。</p><h4 id="通过Logcat来查看Log"><a href="#通过Logcat来查看Log" class="headerlink" title="通过Logcat来查看Log"></a>通过Logcat来查看Log</h4><h4 id="删除应用"><a href="#删除应用" class="headerlink" title="删除应用"></a>删除应用</h4><h4 id="查看系统盘符"><a href="#查看系统盘符" class="headerlink" title="查看系统盘符"></a>查看系统盘符</h4><h4 id="输出所有已经安装的应用"><a href="#输出所有已经安装的应用" class="headerlink" title="输出所有已经安装的应用"></a>输出所有已经安装的应用</h4><h4 id="模拟按键输入"><a href="#模拟按键输入" class="headerlink" title="模拟按键输入"></a>模拟按键输入</h4><h4 id="模拟滑动输入"><a href="#模拟滑动输入" class="headerlink" title="模拟滑动输入"></a>模拟滑动输入</h4><h4 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h4><h4 id="Package管理信息"><a href="#Package管理信息" class="headerlink" title="Package管理信息"></a>Package管理信息</h4><h4 id="AM管理信息"><a href="#AM管理信息" class="headerlink" title="AM管理信息"></a>AM管理信息</h4><h4 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h4><h4 id="重新启动"><a href="#重新启动" class="headerlink" title="重新启动"></a>重新启动</h4><h3 id="ADB命令来源"><a href="#ADB命令来源" class="headerlink" title="ADB命令来源"></a>ADB命令来源</h3><h2 id="模拟器使用与配置"><a href="#模拟器使用与配置" class="headerlink" title="模拟器使用与配置"></a>模拟器使用与配置</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-2-Android开发工具新接触&quot;&gt;&lt;a href=&quot;#Android群英传-2-Android开发工具新接触&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 2 Android开发工具新接触&quot;&gt;&lt;/a&gt;Andro
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 1 Android体系与系统架构</title>
    <link href="https://github.com/zdkswd/2018/07/14/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%201%20Android%E4%BD%93%E7%B3%BB%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>https://github.com/zdkswd/2018/07/14/Android群英传 1 Android体系与系统架构/</id>
    <published>2018-07-14T03:01:32.000Z</published>
    <updated>2018-07-14T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-1-Android体系与系统架构"><a href="#Android群英传-1-Android体系与系统架构" class="headerlink" title="Android群英传 1 Android体系与系统架构"></a>Android群英传 1 Android体系与系统架构</h1><h2 id="Google生态系统"><a href="#Google生态系统" class="headerlink" title="Google生态系统"></a>Google生态系统</h2><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15315306518029/2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d.jpg" alt="2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d" title="">                </div>                <div class="image-caption">2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d</div>            </figure><p>这些层次结构即是相互独立的，又是相互关联的。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux层(仅为Linux内核)，Android最底层最核心的部分。显示内核版本，就是显示所用的Linux<strong>内核</strong>的版本。Linux层包含了Android系统的核心服务，包括硬件驱动，进程管理，安全系统等等。</p><h3 id="Dalvik与ART"><a href="#Dalvik与ART" class="headerlink" title="Dalvik与ART"></a>Dalvik与ART</h3><p>Dalvik包含了一整套Android运行环境虚拟机，每个App都会分配Dalvik虚拟机来保证互相之间不受干扰，并保持独立，特点是在运行时编译。<br>在Android 5.x开始，ART模式已经取代了Dalvik，ART是安装时进行编译，在运行时就不用编译了。</p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>见上图</p><h3 id="Standard-libraries"><a href="#Standard-libraries" class="headerlink" title="Standard libraries"></a>Standard libraries</h3><p>见上图</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>不管是使用NDK开发还是Java开发的App，都有Android Manifest文件、Dalvik Classes、Resource Bundle这些东西。</p><h2 id="Android-App组件架构"><a href="#Android-App组件架构" class="headerlink" title="Android App组件架构"></a>Android App组件架构</h2><p>即四大组件：Activity、BroadCastReciever、ContentProvider和Service。它们是组成一个Android App的最基本元素。</p><h3 id="Android四大组件如何协同工作"><a href="#Android四大组件如何协同工作" class="headerlink" title="Android四大组件如何协同工作"></a>Android四大组件如何协同工作</h3><p>Activity作为人机交互的第一界面，负责向用户展示和处理结果，信息的来源可以是通过资源获取，也可以是通过Content Provider来获取其他应用的信息，或是Service从后台计算，下载，处理后的结果，也可以是通过BroadCast Reciever获取到广播信息。同时，Android系统还提供了一个信使Intent，作为信息传递的载体。组件与组件之间通过Intent来通信、传递信息、交换数据，正是通过这样一种方式，四大组件形成了各自独立而又紧密联系的关系。</p><h3 id="应用运行上下文对象"><a href="#应用运行上下文对象" class="headerlink" title="应用运行上下文对象"></a>应用运行上下文对象</h3><p>Android系统上下文对象即Context，Activity、Service、Application都是继承自Context。<br>Android应用程序会在几个时间点创建应用上下文Context。</p><ol><li>创建Application</li><li>创建Activity</li><li>创建Service</li></ol><p>创建Context的时机就是在创建Context的实现类时。</p><h2 id="Android系统源代码目录与系统目录"><a href="#Android系统源代码目录与系统目录" class="headerlink" title="Android系统源代码目录与系统目录"></a>Android系统源代码目录与系统目录</h2><p>Android系统源代码目录包含了Android系统所有的源代码，从底层驱动到上层应用，Android系统对所有文件都进行了详细管理。在手机中，Android系统的目录和源代码目录不是一一对应的，与源代码编译后，与打包生成的Image文件的结构相同。</p><h3 id="Android系统源代码目录"><a href="#Android系统源代码目录" class="headerlink" title="Android系统源代码目录"></a>Android系统源代码目录</h3><p>看完Android源代码，要懂C、懂脚本、懂Java。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15315306518029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-14%20%E4%B8%8A%E5%8D%8810.18.18.png" alt="屏幕快照 2018-07-14 上午10.18.18" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-14 上午10.18.18</div>            </figure><br>应注意，不是所有的源代码结构都是这样。只有AOSP的Android项目才是这样的结构，有些芯片厂家如MTK目录结构就不同。<br>Android源码采用Makefile编译。<br>像Android这样的大型项目，它的源代码不计其数，不同的功能，模块，按类型分别放置在不同的目录中，这些模块通常会有Makefile文件进行管理。它定义了一系列的规则来指定模块，哪些文件需要编译，以及这些文件该按照怎演的顺序去编译。甚至可以配置更复杂的功能操作，比如定义编译规则，打包规则，Makefile就像一个shell脚本，不仅可以使用自己的语法，也能调用操作系统的命令。<br>Android系统源代码目录每个目录中还会包含更多的目录，而它的每一个最小的功能单位的目录下，都会有一个Makefile文件，这样每一级向上，通过一个个Makefile文件，就把整个源代码有条不紊的联系在一起了。</p><h3 id="Android系统目录"><a href="#Android系统目录" class="headerlink" title="Android系统目录"></a>Android系统目录</h3><p>通过ADB连上手机，通过Linux的ls命令查看Android系统的根目录。其中/system和/data是开发者非常关心的两个目录。</p><h4 id="system-app"><a href="#system-app" class="headerlink" title="/system/app/"></a>/system/app/</h4><p>这里面放的是一些系统的App</p><h4 id="system-bin"><a href="#system-bin" class="headerlink" title="/system/bin/"></a>/system/bin/</h4><p>这里面主要放的是Linux自带的组件</p><h4 id="system-build-prop"><a href="#system-build-prop" class="headerlink" title="/system/build.prop"></a>/system/build.prop</h4><p>这里记录的是系统的属性信息。</p><h4 id="system-fonts"><a href="#system-fonts" class="headerlink" title="/system/fonts/"></a>/system/fonts/</h4><p>系统字体存放的目录root后可下载TTF格式字体替代原字体。</p><h4 id="system-framework"><a href="#system-framework" class="headerlink" title="/system/framework/"></a>/system/framework/</h4><p>系统的核心文件，架构层。</p><h4 id="system-lib"><a href="#system-lib" class="headerlink" title="/system/lib/"></a>/system/lib/</h4><p>存放几乎所有的共享库（.so）文件。</p><h4 id="system-media"><a href="#system-media" class="headerlink" title="/system/media/"></a>/system/media/</h4><p>该目录用来保存系统提示音、系统铃声。</p><h4 id="system-usr"><a href="#system-usr" class="headerlink" title="/system/usr/"></a>/system/usr/</h4><p>该目录用来保存用户的配置文件，如键盘布局、共享、时区文件等。</p><h4 id="data-app"><a href="#data-app" class="headerlink" title="/data/app/"></a>/data/app/</h4><p>data目录包含了用户大部分数据信息。app目录下包含了用户安装的App或者升级的App。</p><h4 id="data-data"><a href="#data-data" class="headerlink" title="/data/data/"></a>/data/data/</h4><p>这个目录应该是开发者访问最多的目录了，这里包含了App的数据信息，文件信息、数据库信息等，以包名的方式来区分各个应用。</p><h4 id="data-system"><a href="#data-system" class="headerlink" title="/data/system/"></a>/data/system/</h4><p>这个目录包含了手机的各项系统信息。</p><h4 id="data-misc"><a href="#data-misc" class="headerlink" title="/data/misc/"></a>/data/misc/</h4><p>这个目录保存了大部分的WiFi、VPN信息。</p><h3 id="Android-App文件目录"><a href="#Android-App文件目录" class="headerlink" title="Android App文件目录"></a>Android App文件目录</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-1-Android体系与系统架构&quot;&gt;&lt;a href=&quot;#Android群英传-1-Android体系与系统架构&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 1 Android体系与系统架构&quot;&gt;&lt;/a&gt;Andro
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 9 整数和浮点小数</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%209%20%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E5%B0%8F%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 9 整数和浮点小数/</id>
    <published>2018-07-12T09:41:32.000Z</published>
    <updated>2018-07-12T09:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-9-整数和浮点小数"><a href="#松本行弘的程序世界-9-整数和浮点小数" class="headerlink" title="松本行弘的程序世界 9 整数和浮点小数"></a>松本行弘的程序世界 9 整数和浮点小数</h1><h2 id="深奥的整数世界"><a href="#深奥的整数世界" class="headerlink" title="深奥的整数世界"></a>深奥的整数世界</h2><h3 id="整数是有范围的"><a href="#整数是有范围的" class="headerlink" title="整数是有范围的"></a>整数是有范围的</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%884.23.38.png" alt="屏幕快照 2018-07-12 下午4.23.38" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午4.23.38</div>            </figure><h3 id="尝试位运算"><a href="#尝试位运算" class="headerlink" title="尝试位运算"></a>尝试位运算</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%884.24.58.png" alt="屏幕快照 2018-07-12 下午4.24.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午4.24.58</div>            </figure><h3 id="操作特定的位"><a href="#操作特定的位" class="headerlink" title="操作特定的位"></a>操作特定的位</h3><p>位运算组合起来，可以对存储在计算机中的各位进行自由操作。<br>操作二进制位就等于操作计算机的数据。<br>基本的位处理操作有4种。</p><ol><li>取出特定位的状态</li><li>特定位置位（设为1）</li><li>特定位清零（设为0）</li><li>特定位反转</li></ol><p>将操作限制在特定位的数为掩码。</p><h3 id="表示负数的办法"><a href="#表示负数的办法" class="headerlink" title="表示负数的办法"></a>表示负数的办法</h3><ol><li>开头一位做符号位</li><li>将整数的各位反转（1的补数）</li></ol><h3 id="Ruby的整数"><a href="#Ruby的整数" class="headerlink" title="Ruby的整数"></a>Ruby的整数</h3><p>Ruby的整数有两种，一种是范围有限制的整数Fixnum（32位CPU是31位，64位CPU是63位），另一种是范围没有限制（超过内存容量除外）的整数Bignum，根据计算结果自动变换。</p><h3 id="挑战公开密钥方式"><a href="#挑战公开密钥方式" class="headerlink" title="挑战公开密钥方式"></a>挑战公开密钥方式</h3><p>RSA加密的强度（解读的困难程度），就归因于素因数分解的难度。</p><h2 id="扑朔迷离的浮点小数世界"><a href="#扑朔迷离的浮点小数世界" class="headerlink" title="扑朔迷离的浮点小数世界"></a>扑朔迷离的浮点小数世界</h2><h3 id="计算机对小数的处理"><a href="#计算机对小数的处理" class="headerlink" title="计算机对小数的处理"></a>计算机对小数的处理</h3><h3 id="固定小数点数不易使用"><a href="#固定小数点数不易使用" class="headerlink" title="固定小数点数不易使用"></a>固定小数点数不易使用</h3><p>浮点数，就是小数点的位置可以移动。</p><h3 id="科学计数法也有问题"><a href="#科学计数法也有问题" class="headerlink" title="科学计数法也有问题"></a>科学计数法也有问题</h3><p>计算机中广泛使用的小数表示方法是科学计数法。科学计数法是指将有效数字和指数组合起来表示小数（实数）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%885.01.23.png" alt="屏幕快照 2018-07-12 下午5.01.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午5.01.23</div>            </figure><p><strong>IEEE754规定，尾数部分的首位始终归一化为1，所以首位始终省略，实质有效数字为53位。</strong></p><h3 id="小数不能完全表示"><a href="#小数不能完全表示" class="headerlink" title="小数不能完全表示"></a>小数不能完全表示</h3><ol><li>计算机中的数的表示有长度（位数）限制。</li><li>计算机中数的表示是二进制。</li></ol><h4 id="浮点数是有限的"><a href="#浮点数是有限的" class="headerlink" title="浮点数是有限的"></a>浮点数是有限的</h4><h4 id="浮点数有误差"><a href="#浮点数有误差" class="headerlink" title="浮点数有误差"></a>浮点数有误差</h4><h4 id="对于浮点小数，结合法不成立"><a href="#对于浮点小数，结合法不成立" class="headerlink" title="对于浮点小数，结合法不成立"></a>对于浮点小数，结合法不成立</h4><h3 id="有不能比较的时候"><a href="#有不能比较的时候" class="headerlink" title="有不能比较的时候"></a>有不能比较的时候</h3><p>对于浮点数进行比较运算，只有两个数在内部表示是完全相同的情况下才判定为相等。作为铁则，两个浮点数不能用==进行比较运算。如果有进行比较的必要，判断条件中的两个数的差要足够小。根据操作系统的不同，对于浮点数，足够小的值e有不同的定义。</p><h3 id="误差积累"><a href="#误差积累" class="headerlink" title="误差积累"></a>误差积累</h3><p>减少运算次数。</p><h3 id="不是数的特别“数”"><a href="#不是数的特别“数”" class="headerlink" title="不是数的特别“数”"></a>不是数的特别“数”</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%885.13.14.png" alt="屏幕快照 2018-07-12 下午5.13.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午5.13.14</div>            </figure><p>无限大Inf，零0，非数NaN</p><h3 id="计算误差有多种"><a href="#计算误差有多种" class="headerlink" title="计算误差有多种"></a>计算误差有多种</h3><h4 id="舍入误差"><a href="#舍入误差" class="headerlink" title="舍入误差"></a>舍入误差</h4><h4 id="最大值溢出与最小值溢出"><a href="#最大值溢出与最小值溢出" class="headerlink" title="最大值溢出与最小值溢出"></a>最大值溢出与最小值溢出</h4><h4 id="信息丢失"><a href="#信息丢失" class="headerlink" title="信息丢失"></a>信息丢失</h4><h4 id="位数脱落"><a href="#位数脱落" class="headerlink" title="位数脱落"></a>位数脱落</h4><h4 id="截止误差"><a href="#截止误差" class="headerlink" title="截止误差"></a>截止误差</h4><h3 id="误差导致的严重问题"><a href="#误差导致的严重问题" class="headerlink" title="误差导致的严重问题"></a>误差导致的严重问题</h3><h3 id="BigDecimal是什么"><a href="#BigDecimal是什么" class="headerlink" title="BigDecimal是什么"></a>BigDecimal是什么</h3><p>浮点数运算的陷阱可以归结为：1. 能够表示的精度有限</p><ol start="2"><li>以二进制来表示</li></ol><p>Ruby提供了BigDecimal类，有以下3个特点：</p><ol><li>与Bignum一样，有效数字自动扩展</li><li>以十进制计算</li><li>以C语言记述，比内嵌的浮点数类（Float）要慢</li></ol><h3 id="能够表示分数的Rational类"><a href="#能够表示分数的Rational类" class="headerlink" title="能够表示分数的Rational类"></a>能够表示分数的Rational类</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-9-整数和浮点小数&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-9-整数和浮点小数&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 9 整数和浮点小数&quot;&gt;&lt;/a&gt;松本行弘的程序世界 9 整数和浮点小数&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 8 正则表达式</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%208%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 8 正则表达式/</id>
    <published>2018-07-12T04:41:32.000Z</published>
    <updated>2018-07-12T04:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-8-正则表达式"><a href="#松本行弘的程序世界-8-正则表达式" class="headerlink" title="松本行弘的程序世界 8 正则表达式"></a>松本行弘的程序世界 8 正则表达式</h1><h2 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h2><h3 id="检索“像那样的东西”"><a href="#检索“像那样的东西”" class="headerlink" title="检索“像那样的东西”"></a>检索“像那样的东西”</h3><h3 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h3><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>除了表中所示的元字符以外的普通字符，都与该字符自身相匹配。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.28.08.png" alt="屏幕快照 2018-07-12 上午10.28.08" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.28.08</div>            </figure></p><h4 id="字符集合"><a href="#字符集合" class="headerlink" title="字符集合"></a>字符集合</h4><p>用括号（【】）括起来的部分为字符集合。与括号内所含的每一个字符都匹配。比如，【abcde】能与小写字母abcde中的任何一个相匹配。<br>字符集合中，用中划线（-）来指定范围。所以，【abcde】可以用【a-e】来代替。<br>字符集合中，第一个字符是【\^】时，表示取反。就是说，不与括号（【】）中的字符相匹配。</p><h4 id="任意一个字符"><a href="#任意一个字符" class="headerlink" title="任意一个字符"></a>任意一个字符</h4><p>表示任意一个字符读得模式是“.”。除了匹配换行符。</p><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.42.59.png" alt="屏幕快照 2018-07-12 上午10.42.59" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.42.59</div>            </figure><h4 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h4><p>贪婪：寻找符合的最长的，遍历完再回溯，<br>懒惰：寻找第一个符合的。</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>将模式绑定起来的功能称为分组。（ma）+</p><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>|</p><h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>指定位置而不是字符来进行匹配。称为锚点（anchor）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.53.24.png" alt="屏幕快照 2018-07-12 上午10.53.24" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.53.24</div>            </figure></p><h3 id="三个陷阱"><a href="#三个陷阱" class="headerlink" title="三个陷阱"></a>三个陷阱</h3><h4 id="记号多、密度高的表达式"><a href="#记号多、密度高的表达式" class="headerlink" title="记号多、密度高的表达式"></a>记号多、密度高的表达式</h4><p>为应对这一问题，出现了扩展正则表达式。</p><h4 id="0次以上的重复"><a href="#0次以上的重复" class="headerlink" title="0次以上的重复"></a>0次以上的重复</h4><h4 id="贪婪型匹配"><a href="#贪婪型匹配" class="headerlink" title="贪婪型匹配"></a>贪婪型匹配</h4><h3 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h3><p>面向对象语言Ruby中，所有数据都是对象。正则表达式也是对象。<br><strong>Ruby程序中正则表达式对象写成/.*/的样子。</strong><br>正则表达式对象可以用正则表达式类方法生成。程序中由组合字符串生成正则表达式时，使用类方法更自然。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>Ruby正则表达式末尾斜杠的后面，可以为这个正则表达式添加选项。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.34.28.png" alt="屏幕快照 2018-07-12 上午11.34.28" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.34.28</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.35.23.png" alt="屏幕快照 2018-07-12 上午11.35.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.35.23</div>            </figure></p><h3 id="正则表达式匹配的方法"><a href="#正则表达式匹配的方法" class="headerlink" title="正则表达式匹配的方法"></a>正则表达式匹配的方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.37.23.png" alt="屏幕快照 2018-07-12 上午11.37.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.37.23</div>            </figure><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>Ruby中有源于Perl的特殊变量。以$开头的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.41.33.png" alt="屏幕快照 2018-07-12 上午11.41.33" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.41.33</div>            </figure></p><h3 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.43.29.png" alt="屏幕快照 2018-07-12 上午11.43.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.43.29</div>            </figure><h3 id="split的本质"><a href="#split的本质" class="headerlink" title="split的本质"></a>split的本质</h3><p>分割字符串的方法split,与正则表达式组合起来能实现很多功能。</p><h3 id="字符串的扫描"><a href="#字符串的扫描" class="headerlink" title="字符串的扫描"></a>字符串的扫描</h3><h3 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h3><p>想要置换与字符串模式匹配的部分，可以用置换方法。</p><h2 id="正则表达式的应用实例与“鬼车”"><a href="#正则表达式的应用实例与“鬼车”" class="headerlink" title="正则表达式的应用实例与“鬼车”"></a>正则表达式的应用实例与“鬼车”</h2><p>正则表达式是表达字符串模式的一种微型语言。正则表达式由字符本身、字符模式、锚点以及重复等组合而成。</p><h3 id="解析日志文件的方法"><a href="#解析日志文件的方法" class="headerlink" title="解析日志文件的方法"></a>解析日志文件的方法</h3><h3 id="避免使用-的方法"><a href="#避免使用-的方法" class="headerlink" title="避免使用$的方法"></a>避免使用$的方法</h3><p>记号$不美观。Ruby中，以match方法替代=~运算符，就可以在程序中不使用这些记号了。</p><h3 id="从邮件中取出日期的方法"><a href="#从邮件中取出日期的方法" class="headerlink" title="从邮件中取出日期的方法"></a>从邮件中取出日期的方法</h3><h3 id="典型拼写错误的检索方法"><a href="#典型拼写错误的检索方法" class="headerlink" title="典型拼写错误的检索方法"></a>典型拼写错误的检索方法</h3><h3 id="Ruby1-9的新功能“鬼车”"><a href="#Ruby1-9的新功能“鬼车”" class="headerlink" title="Ruby1.9的新功能“鬼车”"></a>Ruby1.9的新功能“鬼车”</h3><p>“鬼车”新正则表达式库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DSL</span><br><span class="line">Domain Specific Language,意为面向特定领域的编程语言。</span><br><span class="line">DSL分内部DSL和外部DSL。</span><br><span class="line">内部DSL，就是往既有的语言中加入特定领域的词汇，使之DSL化。如软件编译工具Rake中表达依存关系的内部DSL。</span><br><span class="line">make是一个同样目的的工具，它使用Makefile来表达依存关系。Rake可以利用Ruby的编程功能、方法定义、条件分歧和循环等，不管关系有多复杂，都可以编程对应。</span><br><span class="line">外部DSL，不是扩展现有的语言，而是面向特定目的，如SQL就是DSL的代表性例子。正则表达式也可以称作是以实现模式匹配为目的的外部DSL。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-8-正则表达式&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-8-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 8 正则表达式&quot;&gt;&lt;/a&gt;松本行弘的程序世界 8 正则表达式&lt;/h1&gt;&lt;h2 id=&quot;正则表达式
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 7 文字编码</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%207%20%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 7 文字编码/</id>
    <published>2018-07-12T02:00:32.000Z</published>
    <updated>2018-07-12T02:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-7-文字编码"><a href="#松本行弘的程序世界-7-文字编码" class="headerlink" title="松本行弘的程序世界 7 文字编码"></a>松本行弘的程序世界 7 文字编码</h1><h2 id="文字编码的种类"><a href="#文字编码的种类" class="headerlink" title="文字编码的种类"></a>文字编码的种类</h2><h3 id="早期的文字编码"><a href="#早期的文字编码" class="headerlink" title="早期的文字编码"></a>早期的文字编码</h3><h3 id="纸带与文字的表现"><a href="#纸带与文字的表现" class="headerlink" title="纸带与文字的表现"></a>纸带与文字的表现</h3><h3 id="文字是什么"><a href="#文字是什么" class="headerlink" title="文字是什么"></a>文字是什么</h3><h3 id="走向英语以外的语言（欧洲篇）"><a href="#走向英语以外的语言（欧洲篇）" class="headerlink" title="走向英语以外的语言（欧洲篇）"></a>走向英语以外的语言（欧洲篇）</h3><h3 id="英语以外得到语言（亚洲篇）"><a href="#英语以外得到语言（亚洲篇）" class="headerlink" title="英语以外得到语言（亚洲篇）"></a>英语以外得到语言（亚洲篇）</h3><h3 id="Unicode的问世"><a href="#Unicode的问世" class="headerlink" title="Unicode的问世"></a>Unicode的问世</h3><h3 id="统一编码成16位的汉字统合"><a href="#统一编码成16位的汉字统合" class="headerlink" title="统一编码成16位的汉字统合"></a>统一编码成16位的汉字统合</h3><h3 id="Unicode的两个问题"><a href="#Unicode的两个问题" class="headerlink" title="Unicode的两个问题"></a>Unicode的两个问题</h3><p>选择16位文字的Unicode有两大副作用。一是字节顺序的问题，一是NUL文字问题。<br>字节顺序就是低八位先放还是高八位先放的问题。<br>传统C语言处理的字符串，一般有一个终端文字NUL（‘\0’）。但是作为16位文字的字符串，中途会出现NUL文字。所以，C语言中处理字符串的传统函数不能用于16位文字的字符串。<br>像java那样的语言，一开始就是以16位文字为前提而设计的，所以没什么问题。但以C语言处理16位文字的时候，需要全新的api。</p><h3 id="Unicode的文字集"><a href="#Unicode的文字集" class="headerlink" title="Unicode的文字集"></a>Unicode的文字集</h3><p>现在，Unicode放弃了16位方式，而用21位来表示一个文字，现在Unicode能够表示4111个文字，肯定够用了。</p><h3 id="文字表示的不确定性"><a href="#文字表示的不确定性" class="headerlink" title="文字表示的不确定性"></a>文字表示的不确定性</h3><h3 id="Unicode的字符编码方式"><a href="#Unicode的字符编码方式" class="headerlink" title="Unicode的字符编码方式"></a>Unicode的字符编码方式</h3><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8以一定式样的字节组合来表示Unicode中的21位文字。对于内部程序处理字符串非常方便，另外没有字节顺序问题，在外部处理时也很有用。<br>缺点：消费过多内存，几乎所有的汉字都要占用3个字节。<br>构成文字的字节数是可变的，随机访问任意文字，代价与字符串长度成正比。<br>但是随着计算机内存的容量和性能提高，这些缺点也无所谓了。</p><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>Unicode中能以16位表示的空间就以16位表示，超过16位就以两个16位码组合来表示。到现在缺点已经很突出了，从今以后没必要采用这种字符编码方式了。</p><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>固定长，可以随机访问，但存在字节顺序的问题。<br>因为4字节，没什么人气。</p><h2 id="程序中的文字处理"><a href="#程序中的文字处理" class="headerlink" title="程序中的文字处理"></a>程序中的文字处理</h2><h3 id="文字编码有多个意思"><a href="#文字编码有多个意思" class="headerlink" title="文字编码有多个意思"></a>文字编码有多个意思</h3><h3 id="只能处理文字集中包含的文字"><a href="#只能处理文字集中包含的文字" class="headerlink" title="只能处理文字集中包含的文字"></a>只能处理文字集中包含的文字</h3><h3 id="纷繁复杂的文字编码方式"><a href="#纷繁复杂的文字编码方式" class="headerlink" title="纷繁复杂的文字编码方式"></a>纷繁复杂的文字编码方式</h3><h3 id="影响力渐微的Shift-JIS与EUC-JP"><a href="#影响力渐微的Shift-JIS与EUC-JP" class="headerlink" title="影响力渐微的Shift_JIS与EUC-JP"></a>影响力渐微的Shift_JIS与EUC-JP</h3><h3 id="Unicode有多种字符编码方式"><a href="#Unicode有多种字符编码方式" class="headerlink" title="Unicode有多种字符编码方式"></a>Unicode有多种字符编码方式</h3><h3 id="为什么会发生乱码"><a href="#为什么会发生乱码" class="headerlink" title="为什么会发生乱码"></a>为什么会发生乱码</h3><h3 id="字符编码方式错误"><a href="#字符编码方式错误" class="headerlink" title="字符编码方式错误"></a>字符编码方式错误</h3><h3 id="没有字体"><a href="#没有字体" class="headerlink" title="没有字体"></a>没有字体</h3><h3 id="变换为内部码时出错"><a href="#变换为内部码时出错" class="headerlink" title="变换为内部码时出错"></a>变换为内部码时出错</h3><h3 id="发生不完全变换"><a href="#发生不完全变换" class="headerlink" title="发生不完全变换"></a>发生不完全变换</h3><h3 id="文字集的不同"><a href="#文字集的不同" class="headerlink" title="文字集的不同"></a>文字集的不同</h3><h3 id="字节顺序错误"><a href="#字节顺序错误" class="headerlink" title="字节顺序错误"></a>字节顺序错误</h3><p>像UTF-16，UTF-32这种基本数据单位大于一个字节的编码方式，存放数据时字节该以什么顺序摆放，有两大流派，一个是big endian,一个是little endian。所以同样是UTF-16格式（UTF-32也一样）根据字节顺序不同就会有两种。<br>UTF-8就不会。</p><h3 id="从编程语言的角度处理文字"><a href="#从编程语言的角度处理文字" class="headerlink" title="从编程语言的角度处理文字"></a>从编程语言的角度处理文字</h3><p>编程语言处理文本数据的方法，有UCS方式和CSI方式两种。</p><h3 id="以变换为前提的UCS方式"><a href="#以变换为前提的UCS方式" class="headerlink" title="以变换为前提的UCS方式"></a>以变换为前提的UCS方式</h3><p>UCS（泛用字符集），是指程序中所处理的共同文字集（及字符编码方式）。输入输出时，编程语言将文本数据变成UCS，内部对文本数据进行统一处理。优点：</p><ol><li>原理简单，容易实现</li><li>除变换外，处理成本低</li><li>实际成果多</li></ol><p>缺点：</p><ol><li>发生不必要的变换</li><li>变换存在模糊部分</li><li>有外字及机种依存文字的问题</li><li>UCS中不包含的文字绝对不能处理</li></ol><h3 id="原封不动处理的CSI方式"><a href="#原封不动处理的CSI方式" class="headerlink" title="原封不动处理的CSI方式"></a>原封不动处理的CSI方式</h3><p>CSI（Character Set Independent，字符集独立），是指不对各种文字集（及编码方式）进行任何变换，原封不动地进行处理。相对于UCS的内部只有一种编码方式的处理方式，CSI中对各种编码方式原封不动地处理。<br>CSI是优点多，自由度高的方式。</p><ol><li>不发生不必要的变换</li><li>不发生变换所带来的问题</li><li>不易发生外字的问题。</li><li>理论上不存在不能处理的文字</li><li>根据需要，可以处理应用程序独立的文字集</li></ol><p>缺点：</p><ol><li>字符串的处理容易变得复杂化</li><li>预计处理性能会变低</li><li>实际成果少</li></ol><p>实际上，现在存在的多种编程语言中，采用CSI方式的几乎没有。</p><h3 id="使用UTF-16的Java"><a href="#使用UTF-16的Java" class="headerlink" title="使用UTF-16的Java"></a>使用UTF-16的Java</h3><p>Java采用UCS方式，内部字符编码选用UTF-16<br>制作Java时，Unicode仅限于16位。java没选择可变长的UTF-8，而选择UTF-16，因而产生了这样的悲剧。说是时机的恶作剧也罢，真是太可惜了。</p><h3 id="使用UTF-8的Perl"><a href="#使用UTF-8的Perl" class="headerlink" title="使用UTF-8的Perl"></a>使用UTF-8的Perl</h3><p>Perl也使用UCS方式，内部编码方式采用UTF-8。</p><h3 id="用UTF-16的Python"><a href="#用UTF-16的Python" class="headerlink" title="用UTF-16的Python"></a>用UTF-16的Python</h3><p>UCS，UTF-16</p><h3 id="采用CSI方式的Ruby1-8"><a href="#采用CSI方式的Ruby1-8" class="headerlink" title="采用CSI方式的Ruby1.8"></a>采用CSI方式的Ruby1.8</h3><h3 id="强化了功能的Ruby1-9"><a href="#强化了功能的Ruby1-9" class="headerlink" title="强化了功能的Ruby1.9"></a>强化了功能的Ruby1.9</h3><h3 id="是UCS还是CSI"><a href="#是UCS还是CSI" class="headerlink" title="是UCS还是CSI"></a>是UCS还是CSI</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-7-文字编码&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-7-文字编码&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 7 文字编码&quot;&gt;&lt;/a&gt;松本行弘的程序世界 7 文字编码&lt;/h1&gt;&lt;h2 id=&quot;文字编码的种类&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 6 Ruby On Rails</title>
    <link href="https://github.com/zdkswd/2018/07/11/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%206%20Ruby%20On%20Rails/"/>
    <id>https://github.com/zdkswd/2018/07/11/松本行弘的程序世界 6 Ruby On Rails/</id>
    <published>2018-07-11T04:00:32.000Z</published>
    <updated>2018-07-11T03:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-6-Ruby-On-Rails"><a href="#松本行弘的程序世界-6-Ruby-On-Rails" class="headerlink" title="松本行弘的程序世界 6 Ruby On Rails"></a>松本行弘的程序世界 6 Ruby On Rails</h1><h2 id="MVC和Ruby-On-Rails"><a href="#MVC和Ruby-On-Rails" class="headerlink" title="MVC和Ruby On Rails"></a>MVC和Ruby On Rails</h2><p>MVC是设计GUI程序的设计模式之一。大部分设计模式仅决定程序某一部分的构成，而MVC决定了应用程序的整体部分，有时候也被成为架构模式。</p><h3 id="模型、视图和控制的作用"><a href="#模型、视图和控制的作用" class="headerlink" title="模型、视图和控制的作用"></a>模型、视图和控制的作用</h3><p>模型：是表现窗口中表示内容（信息）的对象。模型代表的只是信息（名字、数值等抽象的信息），它不能包含如何来显示这些信息的信息。<br>视图：代表将模型中包含的信息在窗口中进行表示的对象。视图知道要表现的模型的信息，而模型一般不知道要表示自己的视图信息。<br>控制：是从用户端接受输入，对视图和模型进行操作的对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.26.46.png" alt="屏幕快照 2018-07-11 上午9.26.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.26.46</div>            </figure></p><h3 id="用秒表的例子来学习MVC模式"><a href="#用秒表的例子来学习MVC模式" class="headerlink" title="用秒表的例子来学习MVC模式"></a>用秒表的例子来学习MVC模式</h3><h3 id="生成视图和控制部分"><a href="#生成视图和控制部分" class="headerlink" title="生成视图和控制部分"></a>生成视图和控制部分</h3><h3 id="GUI工具箱与MVC"><a href="#GUI工具箱与MVC" class="headerlink" title="GUI工具箱与MVC"></a>GUI工具箱与MVC</h3><h3 id="同时使用工具箱和MVC"><a href="#同时使用工具箱和MVC" class="headerlink" title="同时使用工具箱和MVC"></a>同时使用工具箱和MVC</h3><h3 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h3><p>优点：</p><h4 id="可以更换界面"><a href="#可以更换界面" class="headerlink" title="可以更换界面"></a>可以更换界面</h4><h4 id="一个模型对应多个视图"><a href="#一个模型对应多个视图" class="headerlink" title="一个模型对应多个视图"></a>一个模型对应多个视图</h4><h4 id="多个视图可以同时响应"><a href="#多个视图可以同时响应" class="headerlink" title="多个视图可以同时响应"></a>多个视图可以同时响应</h4><h4 id="容易测试"><a href="#容易测试" class="headerlink" title="容易测试"></a>容易测试</h4><p>缺点：</p><h4 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h4><h4 id="强关联性"><a href="#强关联性" class="headerlink" title="强关联性"></a>强关联性</h4><p>对模型对象进行了功能追加这样的变更后，相应地也必须对视图和控制进行变更。</p><h3 id="Web应用中的MVC"><a href="#Web应用中的MVC" class="headerlink" title="Web应用中的MVC"></a>Web应用中的MVC</h3><p>Web应用基本是HTTP。HTTP的一次处理经过了一下过程：<br>（1）Web浏览器对应于用户的操作，向Web服务器发出HTTP请求。<br>（2）Web服务器根据请求，准备好发送到Web浏览器的数据。<br>（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。</p><p>利用MVC来描述：<br>（1）Web浏览器发送过来的HTTP请求通过Web服务器传给控制部分。Web应用框架的分配器把请求传递给合适的控制部分。<br>（2）控制部分操作的模型和请求的信息相对应，同时制定显示使用的视图。视图从模型启动，一边引用模型一边准备发送给Web浏览器的数据。<br>（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.54.09.png" alt="屏幕快照 2018-07-11 上午9.54.09" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.54.09</div>            </figure><p>Ruby on Rails上的MVC各部分功能稍有不同。Rails中的模型相当于数据库层，视图指显示用的模板，控制器指控制用的类（包含了应用逻辑）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.56.48.png" alt="屏幕快照 2018-07-11 上午9.56.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.56.48</div>            </figure></p><h2 id="开放类和猴子补丁"><a href="#开放类和猴子补丁" class="headerlink" title="开放类和猴子补丁"></a>开放类和猴子补丁</h2><p>猴子补丁，即在动态语言中，不改变源代码而对功能进行追加和变更。<br>现在灵活使用开放类，变更和追加方法全部称为猴子补丁。</p><h3 id="开放类"><a href="#开放类" class="headerlink" title="开放类"></a>开放类</h3><p>Ruby的类的特征是所谓的开放类，相对于其他语言，特别容易打猴子补丁。<br>Ruby中，可以把String类、Array类等基本的数据类型及所有的类都作为开放类处理，可以自由地追加功能。</p><h3 id="猴子补丁的目的"><a href="#猴子补丁的目的" class="headerlink" title="猴子补丁的目的"></a>猴子补丁的目的</h3><h4 id="功能追加"><a href="#功能追加" class="headerlink" title="功能追加"></a>功能追加</h4><p>利用开放类可以给已有的类追加功能。</p><h4 id="功能变更"><a href="#功能变更" class="headerlink" title="功能变更"></a>功能变更</h4><h4 id="修改程序错误"><a href="#修改程序错误" class="headerlink" title="修改程序错误"></a>修改程序错误</h4><p>因为重新定义了有程序错误或有副作用的方法，不用修改原来那部分的代码就可以解决问题。这也是本来的猴子补丁的目的。</p><h4 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h4><p>有时间想在每个方法调用的同时增加一些其他处理。这种伴随方法调用而进行的处理称为“钩子”（hook），钩子的追加也可以用猴子补丁来实现。</p><h4 id="缓存（cache）"><a href="#缓存（cache）" class="headerlink" title="缓存（cache）"></a>缓存（cache）</h4><h3 id="猴子补丁的技巧"><a href="#猴子补丁的技巧" class="headerlink" title="猴子补丁的技巧"></a>猴子补丁的技巧</h3><p>可以吧Ruby提供的对方法、类和模块进行操作的功能运用到打猴子补丁上。最基本的功能就是给已有的方法改名或取消。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%8810.58.20.png" alt="屏幕快照 2018-07-11 上午10.58.20" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午10.58.20</div>            </figure></p><h4 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h4><p>undef有把方法取消定义的功能。用undef不仅可以取消本类中的方法，也可以取消父类中定义的方法。</p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><h3 id="灵活使用开放类的库"><a href="#灵活使用开放类的库" class="headerlink" title="灵活使用开放类的库"></a>灵活使用开放类的库</h3><p>jcode库可以不使用正则表达式，利用开放类的功能，使得字符串的方法可以处理多字节文字。</p><h3 id="猴子补丁的几点问题"><a href="#猴子补丁的几点问题" class="headerlink" title="猴子补丁的几点问题"></a>猴子补丁的几点问题</h3><p>若要正确使用开放类，安全地打猴子补丁，需遵守：</p><ol><li>基本上只是追加功能<br>对类追加新方法不会让已有的程序无法执行。使用开放类时，主要做不容易导致问题的功能追加会更保险。做功能追加时，如果发生名称重复会造成麻烦，在选择追加的方法名时需要慎重。</li><li>进行功能变更时要慎重，尽可能小规模</li><li>小心相互作用</li></ol><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>猴子补丁能够不改变源代码进行动态修改，这种灵活性是显示动态语言柔软性和扩展性的好例子。实现猴子补丁的Ruby开放类有时功能过强，可能会引起问题。<br>其他语言中用更易控制的形式也能实现猴子补丁。</p><h3 id="Ruby-on-Rails和开放类"><a href="#Ruby-on-Rails和开放类" class="headerlink" title="Ruby on Rails和开放类"></a>Ruby on Rails和开放类</h3><p>Rails构成部分之一ActiveSupport库。ActiveSupport利用Ruby的开放类功能，对Ruby标准提供的类大胆地追加了功能。</p><h3 id="ActiveSupport带来的扩展"><a href="#ActiveSupport带来的扩展" class="headerlink" title="ActiveSupport带来的扩展"></a>ActiveSupport带来的扩展</h3><ol><li>时间</li><li>字节单位系列</li><li>复数形和序数</li></ol><h3 id="大规模开发和Ruby"><a href="#大规模开发和Ruby" class="headerlink" title="大规模开发和Ruby"></a>大规模开发和Ruby</h3><h4 id="编译时不作类型检查"><a href="#编译时不作类型检查" class="headerlink" title="编译时不作类型检查"></a>编译时不作类型检查</h4><p>Ruby在执行时作类型检查，大规模程序为了保证可靠性一定会有严格的测试程序，如果作了严格的测试，在编译时作类型检查的优点就不像所说的那么重要了。</p><h4 id="没有包"><a href="#没有包" class="headerlink" title="没有包"></a>没有包</h4><p>Java对于构成库的类和文件有独立的包，要想具备某种功能，必须明确地进行import操作。而Ruby是不具备这种功能的。所以，库定义的类和模块名是全局的，从任何地方都可以引用。因此，可以说名称重复的危险性很大。</p><h4 id="存在开放类"><a href="#存在开放类" class="headerlink" title="存在开放类"></a>存在开放类</h4><p>各自独立的库发生互相矛盾的变更时，问题不能简单解决。这也可能在大规模开发时引发问题。</p><h3 id="信赖性模型"><a href="#信赖性模型" class="headerlink" title="信赖性模型"></a>信赖性模型</h3><p>在某种类型的大规模开发中，Ruby的性质会造成问题，或者说造成问题时解决起来不像其他语言那么容易，这种现象是现实中可能存在的。如果认为这些是问题的话，可能不使用Ruby会更好。但是，到现在为止我们看到的情况表明，会发生那种问题的大规模开发本来就绝不是好的开发状况。首先要做的，是把项目的信赖关系改善到可以使用Ruby的程度。就算是最后也没有使用Ruby，这也是应该先做到的事情。</p><h3 id="猴子补丁的未来"><a href="#猴子补丁的未来" class="headerlink" title="猴子补丁的未来"></a>猴子补丁的未来</h3><p>猴子补丁虽然有一定的危险性，但有利有弊，它也提供了方便性、扩展性和灵活性。开放类和利用它的猴子补丁，将来也可能会被更安全的、由1特定目的而特制的功能群而替代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-6-Ruby-On-Rails&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-6-Ruby-On-Rails&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 6 Ruby On Rails&quot;&gt;&lt;/a&gt;松本行弘的程序世界 6
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 5 Ajax</title>
    <link href="https://github.com/zdkswd/2018/07/10/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%205%20Ajax/"/>
    <id>https://github.com/zdkswd/2018/07/10/松本行弘的程序世界 5 Ajax/</id>
    <published>2018-07-10T09:25:32.000Z</published>
    <updated>2018-07-10T09:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-5-Ajax"><a href="#松本行弘的程序世界-5-Ajax" class="headerlink" title="松本行弘的程序世界 5 Ajax"></a>松本行弘的程序世界 5 Ajax</h1><h2 id="Ajax和JavaScript（前篇）"><a href="#Ajax和JavaScript（前篇）" class="headerlink" title="Ajax和JavaScript（前篇）"></a>Ajax和JavaScript（前篇）</h2><p>Ajax（Asynchronous JavaScript and XML）,含义是异步JavaScript及XML。<br>Ajax不算是一个新技术，只是既有技术的组合。</p><h3 id="通信及异步页面更新"><a href="#通信及异步页面更新" class="headerlink" title="通信及异步页面更新"></a>通信及异步页面更新</h3><p>Ajax的最大特点是进行异步操作，异步意味着Web浏览器的通信和页面更新是互相独立的。<br>以前的Web应用程序，每按下一个按钮就开始显示下一个页面，在页面完整呈现之前，用户只能等待，无法进行其他操作，使用Ajax技术的页面是在后台和HTTP服务器进行通信，设计优良的Web应用程序，在客户和服务器通信的过程中也可以让用户进行操作，而不需要等待。Ajax的最大优点是改善了应用程序的操控性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8A%E5%8D%888.52.52.png" alt="屏幕快照 2018-07-10 上午8.52.52" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 上午8.52.52</div>            </figure><br>Ajax技术中，对于用户进行的操作，基本是由JavaScript在Web浏览器中进行响应。尽在数据必须从服务器获取的情况下，才在后台进行异步通信。在通信过程中，用户也可以继续对Web浏览器进行操作。和服务器通信得到的结果由DHTML对当前的页面进行部分更新而现实出来。</p><h3 id="技术要素之一：JavaScript"><a href="#技术要素之一：JavaScript" class="headerlink" title="技术要素之一：JavaScript"></a>技术要素之一：JavaScript</h3><p>支撑Ajax的三个主要技术：JavaScript、XML及DHTML。<br>JavaScript是几乎所有Web浏览器处理系统都支撑的一种编程语言。因此，它被称为世界上最普及的编程语言。<br>JavaScript可以简单的嵌入到表示网页的HTML中去，利用JavaScript可以做出<strong>完全不用和服务器进行通信</strong>的网页。</p><h3 id="技术要素之二：XML"><a href="#技术要素之二：XML" class="headerlink" title="技术要素之二：XML"></a>技术要素之二：XML</h3><p>XML（eXtensible Markup Language）,和SGML、HTML类似，使用标签（tag）对数据进行标识说明的一种语言。<br>XML已经成为了数据表示、配置各种文件及其他多种场合下广泛使用的一种格式。<br>Ajax的名字中部分包括了XML，是因为当初大部分使用Ajax技术的应用程序都使用了XML数据，以及用JavaScript进行异步通信的对象的名字是XMLHTTPRequest。当然不用XML的XMLHTTPRequest的通信也是存在的，使用Ajax技术的Web应用进行通信的数据格式也是多种多样的，比如有普通文本格式以及YAML，JSON。</p><h3 id="XML以外的数据表示形式"><a href="#XML以外的数据表示形式" class="headerlink" title="XML以外的数据表示形式"></a>XML以外的数据表示形式</h3><p>YAML（YAML Ain’t Markup Language）看出它不是标记语言。YAML只是表示数据的语言，目的仅仅是表示数据。特点有：</p><ol><li>记述简洁</li><li>容易理解</li><li>专注于表示数据，不用费心考虑给标签起名字。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8A%E5%8D%889.30.23.png" alt="屏幕快照 2018-07-10 上午9.30.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 上午9.30.23</div>            </figure></li></ol><p>和YMAL相提并论的是JSON（JavaScript Object Notation）意思是JavaScript对象表示法。是直接把JavaScript表示对象的程序拿来记述数据。JSON是合法的JavaScript程序，作为JavaScript实现可以生成对象。<br>JSON可以表现下面6种数据类型：数值（整数及浮点小数）、字符串、布尔值（真、假）、数组、对象（键和值的表）和null。<br>YAML通过扩展可以表示各种形式的数据。相比较，JSON就简单太多了，但也够用了。</p><h3 id="技术要素之三：DHTML"><a href="#技术要素之三：DHTML" class="headerlink" title="技术要素之三：DHTML"></a>技术要素之三：DHTML</h3><p>DHTML，动态HTML，顾名思义，可以动态地对HTML进行引用、修改和更新。更具体的说，是利用装载在网页中的JavaScript，使用DOM（文档对象模型）对网页数据进行操作。使用DOM可以进行下述处理：</p><ol><li>取得页面中特定标签中的数据；</li><li>修改标签的数据（文字、属性等）</li><li>在页面中添加标签；</li><li>设定事件处理程序<h3 id="JavaScript技术基础"><a href="#JavaScript技术基础" class="headerlink" title="JavaScript技术基础"></a>JavaScript技术基础</h3>JavaScript是以对象为基础的语言，所有的数据都可以作为“对象”进行统一处理。不过，它不具备“类”这样的所谓普通面向对象语言所提供的功能，即使去除JavaScript面向对象的编程功能，它也可以作为普通的结构化编程语言来使用。<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4>JavaScript的基本语法和C、Java类似。最大的不同是，JavaScript不指定变量类型。<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4>JavaScript的特点之一是把函数作为对象进行处理。C也是将函数作为对象处理，但JavaScript的不同之处在于函数对象有闭包（closure），可以使用函数外面的局部变量。<strong>闭包功能称为了JavaScript面向对象功能的基础。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闭包是Ruby中块变为对象后的结果。它的优点是，只要闭包还存在，就能访问闭包内的变量。</span><br></pre></td></tr></table></figure></li></ol><h3 id="原型模式的面向对象编程语言"><a href="#原型模式的面向对象编程语言" class="headerlink" title="原型模式的面向对象编程语言"></a>原型模式的面向对象编程语言</h3><p>如果具有原型模式的面向对象功能的话，就可以最大限度地消减语言本身的固有功能。这非常适合于JavaScript这样的语言。<br>以类为中心的传统面向对象编程，是以类为基础生成新对象。类和对象的关系可以类比成铸模和铸件的关系。而原型模式的面向对象编程语言没有类这样一个概念。<br>需要生成新的对象时，只要给对象追加属性。设置函数对象作为属性的话，就成为方法。当访问对象中不存在的属性时，JavaScript会去搜索该对象prototype属性所指向的对象。<br>JavaScript利用这个功能，使用“委派”而非“继承”来实现面向对象编程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">委派是指，把对于某个对象的调用传送到另一个对象上。</span><br></pre></td></tr></table></figure></p><p>JavaScript的方式过于简单反而使记述太过复杂。</p><h3 id="使用prototype-js库"><a href="#使用prototype-js库" class="headerlink" title="使用prototype.js库"></a>使用prototype.js库</h3><p>为了克服JavaScript记述过于繁杂的缺点，JavaScript提供了进行功能扩展的一些库。如prototype.js库<br>prototype.js受到了Ruby的影响，实际上Ruby on Rails中标准地附加了prototype.js库，使用得很广泛。</p><h3 id="prototype-js的功能"><a href="#prototype-js的功能" class="headerlink" title="prototype.js的功能"></a>prototype.js的功能</h3><h4 id="Ajax功能"><a href="#Ajax功能" class="headerlink" title="Ajax功能"></a>Ajax功能</h4><p>prototype.js支持XMLHttpRequest对象，可以对HTML进行异步更新。<br>实际上不同Web浏览器获取XMLHttpRequest对象的方法也是不同的。Ajax.Request帮我们屏蔽了与代码移植相关的问题。</p><h4 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h4><p>它是Ruby的Enumerable模块在JavaScript中的实现。</p><h4 id="其他扩展功能"><a href="#其他扩展功能" class="headerlink" title="其他扩展功能"></a>其他扩展功能</h4><p>如使用Object.extend()给对象追加功能。</p><h2 id="Ajax和JavaScript-后篇"><a href="#Ajax和JavaScript-后篇" class="headerlink" title="Ajax和JavaScript(后篇)"></a>Ajax和JavaScript(后篇)</h2><p>像Ajax有3个特点：</p><ol><li>没有Web页面跳转</li><li>通过异步通信实现快速反应</li><li>实现了动画和拖拽等单独使用HTML格式无法表现的用户界面<br>构成DHTML基础的JavaScript是一个速度不怎么快的语言。某种技术在开发出来之后经过相当长一段时间才得到普及，此类例子并不少见。<h3 id="巧妙使用DHTML"><a href="#巧妙使用DHTML" class="headerlink" title="巧妙使用DHTML"></a>巧妙使用DHTML</h3>DHTML被称为Ajax的本质技术。顾名思义，可以动态访问、更新HTML。具体就是利用嵌入网页的JavaScript，使用DOM操作页面数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM是操作HTML和XML的规范。特点是把HTML和XML作为树结构进行处理。</span><br></pre></td></tr></table></figure></li></ol><p>HTML被读取后，生成树结构。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8B%E5%8D%884.39.14.png" alt="屏幕快照 2018-07-10 下午4.39.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 下午4.39.14</div>            </figure><br>使用JavaScript对树结构进行操作就是DHTML的本质。因此JavaScript提供的W3C DOM API有如下功能：</p><ol><li>获取documnent节点</li><li>获取和更新标签数据（包括文字、类型以及属性等）</li><li>追加documnent节点</li><li>设定时间处理程序（event handler）</li></ol><h3 id="获取documnent节点"><a href="#获取documnent节点" class="headerlink" title="获取documnent节点"></a>获取documnent节点</h3><blockquote><p>getElementById(name)<br>getElementsByTagName(name)</p></blockquote><h3 id="获取和更新标签数据"><a href="#获取和更新标签数据" class="headerlink" title="获取和更新标签数据"></a>获取和更新标签数据</h3><p>获取节点对象后，通过调用对象的方法，读写对象的属性等就能够获取和更新标签数据。</p><h3 id="设定事件处理程序"><a href="#设定事件处理程序" class="headerlink" title="设定事件处理程序"></a>设定事件处理程序</h3><p>两种办法：</p><ol><li>指定标签属性。如设置为a标签的onclick属性值来指定事件处理程序。</li><li>把方法设为JavaScript对象的属性。如<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8B%E5%8D%884.49.48.png" alt="屏幕快照 2018-07-10 下午4.49.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 下午4.49.48</div>            </figure></li></ol><h3 id="追加标签节点"><a href="#追加标签节点" class="headerlink" title="追加标签节点"></a>追加标签节点</h3><p>用appendChild方法可以为节点对象追加节点，消除节点用removeChild方法。</p><h3 id="本地HTML应用"><a href="#本地HTML应用" class="headerlink" title="本地HTML应用"></a>本地HTML应用</h3><h3 id="和服务器间的通信"><a href="#和服务器间的通信" class="headerlink" title="和服务器间的通信"></a>和服务器间的通信</h3><p>使用DHTML之后，对于较简单的应用，在客户端就能够实现。但是，客户端无法保存数据，所以保存和获取数据时需要和服务器进行通信。<br>Ajax是利用XMLHTTPRequest对象来进行异步通信，不需要网页跳转，在后台就可以进行通信。</p><h3 id="使用Prototype-js的优点"><a href="#使用Prototype-js的优点" class="headerlink" title="使用Prototype.js的优点"></a>使用Prototype.js的优点</h3><p>不需要麻烦的记述。</p><h3 id="在服务器上保存数据"><a href="#在服务器上保存数据" class="headerlink" title="在服务器上保存数据"></a>在服务器上保存数据</h3><h3 id="Web应用的脆弱性"><a href="#Web应用的脆弱性" class="headerlink" title="Web应用的脆弱性"></a>Web应用的脆弱性</h3><p>如XSS（跨站点脚本问题）</p><h3 id="使用JavaScript的感觉"><a href="#使用JavaScript的感觉" class="headerlink" title="使用JavaScript的感觉"></a>使用JavaScript的感觉</h3><h4 id="作为动态语言名副其实"><a href="#作为动态语言名副其实" class="headerlink" title="作为动态语言名副其实"></a>作为动态语言名副其实</h4><h4 id="DHTML比想象的更有趣"><a href="#DHTML比想象的更有趣" class="headerlink" title="DHTML比想象的更有趣"></a>DHTML比想象的更有趣</h4><h4 id="Prototype-js也不错"><a href="#Prototype-js也不错" class="headerlink" title="Prototype.js也不错"></a>Prototype.js也不错</h4><h4 id="调试比较麻烦"><a href="#调试比较麻烦" class="headerlink" title="调试比较麻烦"></a>调试比较麻烦</h4><p>JavaScript理就算有程序错误，Web浏览器也不会显示任何信息。想要确认程序的状态，只能多次使用alert()。<br>Firefox提供了Firebug的扩展功能，对于JavaScript的调试非常有用。</p><h4 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h4><p>Ajax开发最难的一点就是Web浏览器间JavaScript的兼容性问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名字的重要性</span><br><span class="line">起了一个合适的名字本身意味着功能设计的正确。反过来，起了不好的名字说明设计者自己也没有完全理解应完成什么样的功能。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-5-Ajax&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-5-Ajax&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 5 Ajax&quot;&gt;&lt;/a&gt;松本行弘的程序世界 5 Ajax&lt;/h1&gt;&lt;h2 id=&quot;Ajax和Java
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 4 设计模式</title>
    <link href="https://github.com/zdkswd/2018/07/09/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%204%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 4 设计模式/</id>
    <published>2018-07-09T10:21:32.000Z</published>
    <updated>2018-07-09T10:18:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-4-设计模式"><a href="#松本行弘的程序世界-4-设计模式" class="headerlink" title="松本行弘的程序世界 4 设计模式"></a>松本行弘的程序世界 4 设计模式</h1><h2 id="设计模式（1）"><a href="#设计模式（1）" class="headerlink" title="设计模式（1）"></a>设计模式（1）</h2><h3 id="设计模式的价值和意义"><a href="#设计模式的价值和意义" class="headerlink" title="设计模式的价值和意义"></a>设计模式的价值和意义</h3><p>Gamma他们并没有发现新的模式，总结出来的23种设计模式也是软件开发中早就存在并反复使用的模式，因此并不能说是Gamma他们的首创。但即使是这样，设计模式有了名字，人们就可以认识到它的存在，并对之进行讨论。这种不能用语言表达的知识称为内隐知识。给这些在软件中经常反复出现的模式命名，使得这些本来只有经验丰富的程序员才能认识到的软件设计模式能被广泛认识和讨论。</p><h3 id="设计模式是程序抽象化的延伸"><a href="#设计模式是程序抽象化的延伸" class="headerlink" title="设计模式是程序抽象化的延伸"></a>设计模式是程序抽象化的延伸</h3><p>一旦有了设计模式，只要把过去优秀的人们考虑出来的模式拿来应用一下。</p><h3 id="Ruby中的设计模式"><a href="#Ruby中的设计模式" class="headerlink" title="Ruby中的设计模式"></a>Ruby中的设计模式</h3><h3 id="Singleton模式"><a href="#Singleton模式" class="headerlink" title="Singleton模式"></a>Singleton模式</h3><p>单件模式。用来保证某个类的实例只有一个。<br>Ruby实现Singleton模式的方法有几个</p><ol><li>使用singleton库的方法<br>Ruby以库的形式实现了Singleton模式。使用Singleton库，在任意类中include Singleton模块，那个类就变成Singleton模式的对象。</li><li>使用类或模块<br>C++和java是不能把类作为对象使用的，与之不同的是，smalltalk或Ruby能把类也作为对象来处理。因此，在类或模块中定义一个方法就可以实现Singleton模式。</li><li>把一般的对象作为Singleton来使用<br>为了把一个类的对象限制为只有一个，并不一定要对对象的一般生产方法进行限制。可以生成一个一般的对象，然后不要在生产更多个对象了。</li><li>使用对象和特异方法<br>Ruby可以在对象生成以后再增加新的方法。<h3 id="Proxy模式"><a href="#Proxy模式" class="headerlink" title="Proxy模式"></a>Proxy模式</h3>Proxy（代理）模式是为某个对象提供代理对象的模式。<br>在不知道是否真正需要一个生成代价很大的对象时可能造成很大浪费，但不生成又什么都做不了。<h3 id="Iterator模式"><a href="#Iterator模式" class="headerlink" title="Iterator模式"></a>Iterator模式</h3>Iterator（迭代器）模式提供按顺序访问集合对象中各元素的方法。即使不知道对象的内部构造，也可以按顺序访问其中的每个元素。<br>Iterator模式是为集合对象另外准备用来控制循环处理的对象，就像C++或java一样，我们称这个循环控制对象为Iyerator，也称为游标。<h3 id="外部与内部，哪一个更好"><a href="#外部与内部，哪一个更好" class="headerlink" title="外部与内部，哪一个更好"></a>外部与内部，哪一个更好</h3>它们都有方便的一面，也都有不方便的另一面。<h3 id="内部迭代器的缺陷"><a href="#内部迭代器的缺陷" class="headerlink" title="内部迭代器的缺陷"></a>内部迭代器的缺陷</h3>内部迭代器不能同时进行多个循环，也就无法实现按顺序比较两个集合元素的处理。<h3 id="外部迭代器的缺陷"><a href="#外部迭代器的缺陷" class="headerlink" title="外部迭代器的缺陷"></a>外部迭代器的缺陷</h3>外部迭代器的缺陷在于迭代器对象需要引用集合对象的内部信息，为了按顺序访问集合对象的各个元素，迭代器需要访问集合的内部构造，破坏了隐藏集合内部构造的封装性原则。<h2 id="设计模式（2）"><a href="#设计模式（2）" class="headerlink" title="设计模式（2）"></a>设计模式（2）</h2><h3 id="模式与动态语言的关系"><a href="#模式与动态语言的关系" class="headerlink" title="模式与动态语言的关系"></a>模式与动态语言的关系</h3>《设计模式》一书中介绍了23个设计模式。这些设计模式可分为3大类：（1）有关生成的模式（5个），有关构造的模式（7个）以及有关行为的模式（11个）。Singleton为（1），Proxy为（2），Iterayor为（3）。<h3 id="重复使用既存对象的Protoype模式"><a href="#重复使用既存对象的Protoype模式" class="headerlink" title="重复使用既存对象的Protoype模式"></a>重复使用既存对象的Protoype模式</h3>Protoype（原型）模式明确一个实例作为要生成对象的种类原型，通过复制该实例来生成新的对象。<br>在需要新种类对象时，首先复制一个既存的对象，给复制的对象直接增加方法或实例变量等功能，生成最初的第一个新种类对象。最初一个也并不特别，只是偶尔被用来复制而已。<br>相对于类模式编程，原型模式的编程构成元素比较少，具有简单实现面向对象功能设计的倾向，JavaScript的面向对象就是原型模式。io语言也是。<h3 id="亲身体验IO语言"><a href="#亲身体验IO语言" class="headerlink" title="亲身体验IO语言"></a>亲身体验IO语言</h3><h3 id="Ruby中的原型"><a href="#Ruby中的原型" class="headerlink" title="Ruby中的原型"></a>Ruby中的原型</h3>基本上讲Ruby是类模式的语言，但也拥有支持原型模式编程功能。</li><li>复制对象的clone方法</li><li>给个别对象增加方法的特意方法功能</li><li>给个别对象增加一组功能的extend方法<br>静态语言中没有原型编程，因为不可能给复制的对象增加新方法。<h3 id="编写抽象算法的Template-Method模式"><a href="#编写抽象算法的Template-Method模式" class="headerlink" title="编写抽象算法的Template Method模式"></a>编写抽象算法的Template Method模式</h3><h3 id="用Ruby来尝试Template-Method"><a href="#用Ruby来尝试Template-Method" class="headerlink" title="用Ruby来尝试Template Method"></a>用Ruby来尝试Template Method</h3>Ruby的类库中最大限度灵活运用Template Method模式的部分，应该是Enumerable模块和Comparable模块了。<h3 id="动态语言与Template-Method模式"><a href="#动态语言与Template-Method模式" class="headerlink" title="动态语言与Template Method模式"></a>动态语言与Template Method模式</h3>Template Method模式的这种优秀性质与语言是不是静态没有关系。<h3 id="避免高度依赖性的Observer模式"><a href="#避免高度依赖性的Observer模式" class="headerlink" title="避免高度依赖性的Observer模式"></a>避免高度依赖性的Observer模式</h3>Observer（观察者）模式是当某个对象的状态发生变化时，依存于该状态的全部对象都自动得到通知，而且为了让它们都得到通知，定义了对象间一对多的依存关系。<br>这是控制类与类之间依存关系的一种模式。<br>高度依赖性会导致组成程序的零件过大，避免高度依赖性的Observer模式，构成观察者模式的有两个对象，一个称谓Observer（观察者）接受变更通知；另一个称为Subject（对象）或Observable（被观察者），发出变更通知。<br>被观察者让人得到被动的印象，在实际处理中，被观察者会发出通知“我已经变化了哦”。<h3 id="Observable模块"><a href="#Observable模块" class="headerlink" title="Observable模块"></a>Observable模块</h3>Ruby中为实现Observer模式提供了名为observer的库。observer库提供observer模块。<h3 id="Observer模式与动态语言"><a href="#Observer模式与动态语言" class="headerlink" title="Observer模式与动态语言"></a>Observer模式与动态语言</h3>由于Ruby的动态性质，Observer库具有以下几方面的灵活性。</li><li>观察者类不必是特定类的子类。</li><li>观察者类不必实现特定的接口（本来在Ruby中也没有接口）</li><li>观察者类的更新方法名可以自由决定</li><li>观察者类更新方法的参数可以自由决定</li><li>被观察者类不必是特定类的子类</li><li>对被观察者类的要求，只是将Observable模块包括进来。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说到事件监听模式,很容易将它和观察者模式联系在一起。</span><br><span class="line">实质上这两者完成同类型的工作。依个人理解，事件监听模式更像是观察者模式的进阶。</span><br><span class="line">事件监听机制就是对观察者模式进行了进一步抽象，节省了代码量。</span><br></pre></td></tr></table></figure></li></ol><h2 id="设计模式（3）"><a href="#设计模式（3）" class="headerlink" title="设计模式（3）"></a>设计模式（3）</h2><h3 id="软件开发的悲剧"><a href="#软件开发的悲剧" class="headerlink" title="软件开发的悲剧"></a>软件开发的悲剧</h3><ol><li>复杂性</li><li>变化性<br>软件的规模越大，各个部分之间的牵连越复杂，更改也就越难。<br>在软件开发过程中，需求变更几乎是不可避免的。<h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><strong>对模块扩展必须开放，对修改必须封闭。</strong><br>为了应对将来的需要，扩展必须是开放的，但是即使某一模块的内部结构改变了，对外接口也应当是不变的。简称OCP。</li></ol><h3 id="面向对象的情况"><a href="#面向对象的情况" class="headerlink" title="面向对象的情况"></a>面向对象的情况</h3><p>既要开放，又要封闭，看似互相矛盾，但是<strong>面向对象编程语言能够很彻底地消除这个矛盾。</strong></p><h3 id="非面向对象的情况"><a href="#非面向对象的情况" class="headerlink" title="非面向对象的情况"></a>非面向对象的情况</h3><p>非面向对象则很难处理好。<br><strong>面向对象的精髓在于对OCP的实践。至于把对象看做物体理解起来比较容易，能够建立现实世界的模型等，不过是锦上添花。</strong></p><h3 id="OCP与Template-Method模式"><a href="#OCP与Template-Method模式" class="headerlink" title="OCP与Template Method模式"></a>OCP与Template Method模式</h3><p>虽说使用面向对象语言的功能，可以实现OCP，但是只是说有这种可能性，并不是说什么时候都能实现。当然，虽然使用了面向对象语言，却做成了一个糟糕的设计，这种情况也是屡见不鲜。<br>分类中很多设计模式之所以优秀是因为经得起OCP所要求的变化。<br>Template Method模式，是满足OCP的基本手段。其他的设计模式都是利用多个类的关联来实现的，而Template Method模式则仅仅使用了继承，基本上无非是实现了一个抽象类。</p><h3 id="Observer模式"><a href="#Observer模式" class="headerlink" title="Observer模式"></a>Observer模式</h3><p>Observer模式是满足OCP的。<br>DRY也好，OCP也好，都不过是原则，根据具体情况，要做适当的选择，如果代码没有再利用的打算，也没有扩展功能的打算，也就没有必要生搬硬套设计模式。使用前有必要先做判断。</p><h3 id="使用Strategy模式"><a href="#使用Strategy模式" class="headerlink" title="使用Strategy模式"></a>使用Strategy模式</h3><p>Strategy（策略）模式是定义算法的集合，将各算法封装，使它们能够交换。利用Strategy模式，算法和利用这些算法的客户程序可以分别独立进行修改而不互相影响。<br>Strategy模式就是将容易变化的处理归纳为独立的对象，然后使它们能够互相交换，使用方法与将容易变化的处理交给子类的Template Method模式相类似。两个模式最大的区别在于，Strategy模式是独立的对象，能够动态交换处理逻辑。</p><h3 id="Strategy模式与OCP"><a href="#Strategy模式与OCP" class="headerlink" title="Strategy模式与OCP"></a>Strategy模式与OCP</h3><p>Strategy模式完全满足OCP。<br>世上很多设计模式，为了能应对将来可能的修改，都是按照OCP的要求来设计的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-4-设计模式&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-4-设计模式&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 4 设计模式&quot;&gt;&lt;/a&gt;松本行弘的程序世界 4 设计模式&lt;/h1&gt;&lt;h2 id=&quot;设计模式（1）&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 3 程序块</title>
    <link href="https://github.com/zdkswd/2018/07/09/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%203%20%E7%A8%8B%E5%BA%8F%E5%9D%97/"/>
    <id>https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 3 程序块/</id>
    <published>2018-07-09T02:21:32.000Z</published>
    <updated>2018-07-11T02:11:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-3-程序块"><a href="#松本行弘的程序世界-3-程序块" class="headerlink" title="松本行弘的程序世界 3 程序块"></a>松本行弘的程序世界 3 程序块</h1><h2 id="程序块的威力"><a href="#程序块的威力" class="headerlink" title="程序块的威力"></a>程序块的威力</h2><p>Ruby的特色功能之一——程序块。Ruby的程序块是指在方法调用时可以追加的代码块。</p><h3 id="把函数作为参数的高阶函数"><a href="#把函数作为参数的高阶函数" class="headerlink" title="把函数作为参数的高阶函数"></a>把函数作为参数的高阶函数</h3><p>高阶函数是指以函数作为参数的函数。<br>为了实现高阶函数，编程语言中必须把函数和方法作为数据来处理。</p><h3 id="C语言高阶函数的局限"><a href="#C语言高阶函数的局限" class="headerlink" title="C语言高阶函数的局限"></a>C语言高阶函数的局限</h3><p>在C语言中，实现函数间的信息传递只有两种方法：要么明确地传递参数，要么使用全局变量，没有其他方法。<br>如果使用全局变量来传递信息，就搞不清楚什么时候、谁在引用或者更新这一变量。除了全局变量之外，没有别的办法在函数间共享信息，这是C语言的局限。</p><h3 id="可以保存外部环境的闭包"><a href="#可以保存外部环境的闭包" class="headerlink" title="可以保存外部环境的闭包"></a>可以保存外部环境的闭包</h3><p>Ruby中，增加了引用函数外部变量的功能。<br>与C语言指针的例子比较，Ruby具有以下两个易于使用的优点：</p><ol><li>可以再使用时定义；</li><li>可以引用外部的局部变量。</li></ol><p>java的匿名类和C语言的函数指针也能实现同样的功能，但是没有那么简洁。<br>在块中可以引用外部局部变量的方法，这说明不只是简单的程序代码，而且把外部“环境”也包括进来，像这样的块叫做闭包。通常的局部变量在方法执行结束时就不存在了，但如果被包括进了闭包，闭包存在期间，局部变量也会一直存在。</p><h3 id="块的两种使用方法"><a href="#块的两种使用方法" class="headerlink" title="块的两种使用方法"></a>块的两种使用方法</h3><p>Ruby的块是可以追加给调用方法的代码块，块自身不是对象（对象化后的块是闭包）。参数传递的方法和普通函数不同。<br>在被调用的方法中有两种方式来使用传递过来的块。一种是用“块参数”的方式明确声明接受块作为参数，另一种是使用<strong>yield</strong>这个Ruby的保留词。<br>块作为参数具有三个优点：</p><ol><li>明确表示了块处理</li><li>块和对象一样被统一处理</li><li>检查参数是否为nil就可以判断出是否传递了块参数。</li></ol><p>另外，yield具有下面两个优点：</p><ol><li>没有用到闭包，执行速度少快</li><li>错误提示信息比较容易理解</li></ol><h3 id="最终来看，块到底是什么"><a href="#最终来看，块到底是什么" class="headerlink" title="最终来看，块到底是什么"></a>最终来看，块到底是什么</h3><p>Ruby的块具有以下三个特点：</p><ol><li>代码块可以作为参数传递给方法</li><li>在被调用的方法中可以执行传递过来的代码块，执行后程序的控制权返还给方法。</li><li>块中最后执行的算式的值是块的值，这个值可以返回给方法。</li></ol><p>块也可以被看做只是高阶函数的一种特殊形式的语法。虽然只是稍作改进，但Ruby中块的各种灵活应用的方法还是让人赞叹不已。</p><h3 id="块在循环处理中的应用"><a href="#块在循环处理中的应用" class="headerlink" title="块在循环处理中的应用"></a>块在循环处理中的应用</h3><p>最典型的用法是，在逐个处理集合对象的元素的方法中使用块。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-06%20%E4%B8%8A%E5%8D%8811.19.23.png" alt="屏幕快照 2018-07-06 上午11.19.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-06 上午11.19.23</div>            </figure></p><p>Ruby中几乎所有的容器类都有each这个方法。使用这个方法可以循环处理容器类中的所有元素。<br>也可以用for语句来实现each方法。<br>本来，Ruby就是为了要实现循环功能才导入了块。所以，在以前的文档中把具有块的方法称为迭代器（iterator）。iterate就是循环、迭代的意思。但是，如今块的应用范围比当初所能想到的要广泛的多，和循环没有关系的处理中也大量的用到块。所以现在仍把块称为迭代器就很不恰当了。</p><h3 id="内部迭代器和外部迭代器"><a href="#内部迭代器和外部迭代器" class="headerlink" title="内部迭代器和外部迭代器"></a>内部迭代器和外部迭代器</h3><p>像Ruby块这样，把对各个元素的处理逻辑传送给容器类的方法，然后在方法中对容器类中每个元素调用指定的处理逻辑，这种迭代方式称为内部迭代器的方式。<br>与之对应，C++和java中所谓的迭代器，是用别的类对象来循环处理容器中的元素，这种循环处理的方式称为外部迭代器方式。在外部迭代器方式中，把顺序取出容器中元素对象称为迭代器，也称为游标。<br>内部迭代器不用额外生成类，使用和实现都很简单，但是，对于不支持闭包的编程语言，想要拥有循环外部的信息就要费些功夫。外部迭代器可以简单地处理从多个容器中逐个取出数据进行并行处理。<br>从设计模式来看，内部迭代器是访问者模式，外部迭代器是迭代器模式。</p><h3 id="在排序和比较大小中的应用"><a href="#在排序和比较大小中的应用" class="headerlink" title="在排序和比较大小中的应用"></a>在排序和比较大小中的应用</h3><h3 id="用块保证程序的后处理"><a href="#用块保证程序的后处理" class="headerlink" title="用块保证程序的后处理"></a>用块保证程序的后处理</h3><h3 id="用块实现新的控制结构"><a href="#用块实现新的控制结构" class="headerlink" title="用块实现新的控制结构"></a>用块实现新的控制结构</h3><p>用块的话，不需要改变文法，就可以控制结构的定义。</p><h3 id="在回调中使用块"><a href="#在回调中使用块" class="headerlink" title="在回调中使用块"></a>在回调中使用块</h3><h3 id="块处理的特别理由"><a href="#块处理的特别理由" class="headerlink" title="块处理的特别理由"></a>块处理的特别理由</h3><p>ruby的块具有以下特点：</p><ol><li>在普通参数以外，另外被传送；</li><li>块不是对象（lambda方法可以作闭包对象化）。</li></ol><p>其他具有闭包功能的编程语言，比如Lisp和Smalltalk，它们没有这样的区别，总是把闭包作为对象来处理。Ruby作了改进，因为：</p><ol><li>减少对象的生成数。初期Ruby生成闭包对象的代价很高，所以尽量避免了闭包对象的生成。即使是真正必要的对象，也尽量延迟到必要的时候才生成。</li><li>外观上的理由。</li></ol><p>调用方法时只能用一个块，是Ruby中的一个限制，但实际情况中也几乎没有必要使用多个块。</p><h2 id="用块做循环"><a href="#用块做循环" class="headerlink" title="用块做循环"></a>用块做循环</h2><p>Ruby的块本来就是在循环的抽象化过程中诞生的。现在除了循环以外，在其他一些场合也得到广泛应用，但这并未有改变其实现循环的初衷。</p><h3 id="块是处理的集合"><a href="#块是处理的集合" class="headerlink" title="块是处理的集合"></a>块是处理的集合</h3><p>循环是程序的基本元素。从结构化编程的原理来说，所有算法都是有顺序、分支和循环的组合来实现的。可以说处理好了循环，也就处理好了程序。<br>Ruby也用while循环，但是循环还有其他更为深奥的表现形式。<br>Ruby中有until语句。<br>块是处理的集合。Ruby中，在方法调用的最后，可以附加上块。<br>Ruby的简洁性不只体现在程序简短，更重要的是体现在对本质问题的处理，使程序更为灵活。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%20%E4%B8%8A%E5%8D%889.00.34.png" alt="屏幕快照 2018-07-09 上午9.00.34" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-09 上午9.00.34</div>            </figure><br>第二行大括号中的部分是块，这行程序是作为参数来调用数组的each方法。<br>用Ruby实现这种循环非常简单，知识在块调用的地方用yield来指定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%20%E4%B8%8A%E5%8D%889.08.46.png" alt="屏幕快照 2018-07-09 上午9.08.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-09 上午9.08.46</div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个方法的定义，在方法内部有yield的出现；在方法的调用处会有程序块的出现。</span><br></pre></td></tr></table></figure></p><p>也可以用do-end来定义块。大括号和do-end基本是一样的。但是，在块是多行时。用do-end结构统一性更好一些。</p><ol><li>块是一行的时候用大括号，是多行的时候用do-end;</li><li>块作为表达式的一部分，给方法返回值时用大括号，块作为处理语句或程序流程控制时用do-end。<br>大括号的优先级更高。</li></ol><p><strong>在省略括号调用方法时，一定要注意块的结合优先顺序。</strong></p><h3 id="块应用范围的扩展"><a href="#块应用范围的扩展" class="headerlink" title="块应用范围的扩展"></a>块应用范围的扩展</h3><p>当时块主要使用在循环里。<br>在Ruby中不必特别的结构，在任意的方法中都可以使用块，所以不仅仅在循环中，块在各种各样的领域中都得到了应用。</p><h3 id="高阶函数和块本质一样"><a href="#高阶函数和块本质一样" class="headerlink" title="高阶函数和块本质一样"></a>高阶函数和块本质一样</h3><p>编程语言要实现高阶函数，就必须把函数或者方法作为数据来处理。反之，具有这样功能的编程语言就可以利用高阶函数。<br>可以把块看做高阶函数调用，只能有一个函数参数。<br>事实上，在高阶函数中94%都只有一个函数参数，有两个以上函数参数是极少的。Ruby以更易于使用的形式，把只有一个函数参数的情形在语法上加以特殊处理，导入了块功能。</p><h3 id="用Enumerable来利用块"><a href="#用Enumerable来利用块" class="headerlink" title="用Enumerable来利用块"></a>用Enumerable来利用块</h3><p>把块应用于循环抽象化的，最典型的应该是Enumerable模块。Enumerable模块以each方法为基础，定义了each方法的类提供了多种功能。如果继承（Mix-in）了这个模块，就可以很方便地利用它的各种功能。<br>Enumberable的意思是可数的。它是对数组等各种集合元素做循环处理的方法的集成。可大致分为：</p><ol><li>循环</li><li>指定条件</li><li>排序、比较大小</li></ol><h3 id="Enumerable的局限"><a href="#Enumerable的局限" class="headerlink" title="Enumerable的局限"></a>Enumerable的局限</h3><ol><li>循环都依赖each方法，而且不能并行执行。</li><li>Enumerable可以用each方法简单的实现循环，反过来也是一个局限。</li></ol><h2 id="精通集合的使用"><a href="#精通集合的使用" class="headerlink" title="精通集合的使用"></a>精通集合的使用</h2><h3 id="使用Ruby的数组"><a href="#使用Ruby的数组" class="headerlink" title="使用Ruby的数组"></a>使用Ruby的数组</h3><p>在动态语言ruby中，集合可以混合存在各种类型的对象，所以可以定义复杂得数组。</p><h3 id="修改指定范围的元素的内容"><a href="#修改指定范围的元素的内容" class="headerlink" title="修改指定范围的元素的内容"></a>修改指定范围的元素的内容</h3><p>和C语言、java语言相比，ruby的数组具有以下特点。</p><ol><li>Ruby的数组是对象，可以调用各种方法。</li><li>用【】访问数组实际上是方法调用。【】是方法名，里面的值是参数。</li><li>变更数组元素实际上也是方法调用。【】=是方法名，里面和右边的值是参数。</li></ol><h3 id="Ruby中的哈希处理"><a href="#Ruby中的哈希处理" class="headerlink" title="Ruby中的哈希处理"></a>Ruby中的哈希处理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%20%E4%B8%8A%E5%8D%889.55.21.png" alt="屏幕快照 2018-07-09 上午9.55.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-09 上午9.55.21</div>            </figure><h3 id="支持循环的Enumerable"><a href="#支持循环的Enumerable" class="headerlink" title="支持循环的Enumerable"></a>支持循环的Enumerable</h3><p>Ruby中提供的方法可以更好地发挥集合的作用。<br>Ruby中，集合的功能都定义在Enumerable这个Mix-in中了。从另一个角度来说，只要把Enumerable模块通过Mix-in继承进来，就可以使用集合对象的大量方法了。</p><h3 id="用于循环的each方法"><a href="#用于循环的each方法" class="headerlink" title="用于循环的each方法"></a>用于循环的each方法</h3><p>在Enumerable中没有定义each方法，反之，Enumerable中所有方法都是在内部调用each方法实现的。</p><h3 id="使用inject、zip和grep"><a href="#使用inject、zip和grep" class="headerlink" title="使用inject、zip和grep"></a>使用inject、zip和grep</h3><p>inject是用块吧各个元素结合起来。<br>zip是从多个集合并行取得元素的方法。<br>grep方法可以对集合中的元素进行模式匹配。</p><h3 id="用来指定条件的select方法"><a href="#用来指定条件的select方法" class="headerlink" title="用来指定条件的select方法"></a>用来指定条件的select方法</h3><p>对集合的各个元素进行块处理的是循环类型的方法。和它相对的，对各个元素进行块处理，用快处理的结果作为下个处理的判定条件的是条件指定型方法。<br>条件指定型方法中最常用的是select方法。select方法把快处理结果为真的元素存放在数组中返回。</p><h3 id="排序与比较大小"><a href="#排序与比较大小" class="headerlink" title="排序与比较大小"></a>排序与比较大小</h3><h3 id="在类中包括（include）Enumerable模块"><a href="#在类中包括（include）Enumerable模块" class="headerlink" title="在类中包括（include）Enumerable模块"></a>在类中包括（include）Enumerable模块</h3><h3 id="列表内包表达式和块的区别"><a href="#列表内包表达式和块的区别" class="headerlink" title="列表内包表达式和块的区别"></a>列表内包表达式和块的区别</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-3-程序块&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-3-程序块&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 3 程序块&quot;&gt;&lt;/a&gt;松本行弘的程序世界 3 程序块&lt;/h1&gt;&lt;h2 id=&quot;程序块的威力&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>艺术的力量 卡拉瓦乔</title>
    <link href="https://github.com/zdkswd/2018/07/06/%E8%89%BA%E6%9C%AF%E7%9A%84%E5%8A%9B%E9%87%8F%20%E5%8D%A1%E6%8B%89%E7%93%A6%E4%B9%94/"/>
    <id>https://github.com/zdkswd/2018/07/06/艺术的力量 卡拉瓦乔/</id>
    <published>2018-07-06T09:56:20.000Z</published>
    <updated>2018-07-06T09:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="艺术的力量-卡拉瓦乔"><a href="#艺术的力量-卡拉瓦乔" class="headerlink" title="艺术的力量 卡拉瓦乔"></a>艺术的力量 卡拉瓦乔</h1><p>这个天才，是个恶人<br>教堂寻寻觅觅及卡拉瓦乔生来注定要做的，就是在罪人的生命中找到超凡入圣之处。<br>卡拉瓦乔笔下的主角不是圣人，而是罪人。<br>这名画家，对穷苦信徒的处境感身受<br>他艺术的力量来自于真实的力量，其中包括了对自身真相的觉醒。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308705069360.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>青年音乐家 1595</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308687397847.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>自比酒神的自画像</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308699610387.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>赌博</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308687531515.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>圣母之死</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308701803968.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>圣母玛利亚</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308685944948.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>男孩与水果篮</p><p>有人说他是艺术天才，也有人说他是血性魔鬼，他的一生可以说就是一部历险记。<br>卡拉瓦乔出生在米兰，家庭状况还阔以，爸妈在当时有点名气和地位。在卡拉瓦乔5岁的时候发生了一场瘟疫，为了躲避瘟疫，他们全家搬离了米兰。<br>但不幸还是发生了，他的爸爸和爷爷都感染了这种瘟疫，并在同一天去世了，生活的重担就都落到他妈妈一个人身上，那时候的卡拉瓦乔才6岁。<br>等到他卡拉瓦乔13岁时候，妈妈也离开了这个世界，于是他就成了孤儿。<br>也就是在妈妈去世那一年，卡拉瓦乔开始跟着意大利画家西蒙·彼得扎诺学画画，一画就是四年，期间他也看了很多大师的作品，比如达芬奇的最后的晚餐啥的，增加了对艺术的了解。<br>画家靠自己是很难的，因为你要搞商业你就无心创作，毕竟一个人的精力有限，所以需要钱的帮助，就是一定资金上的支持…卡拉瓦乔的命就很好。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308703755249.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>多疑的thomas</p><p> <img src="/img/media/15308499185596/15308692736469.jpg" alt=""><br>召唤使徒马太</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308696988306.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>马太的殉难</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308698384972.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>手提歌利亚头的大卫</p><p>画中的男子手里提的，正是卡拉瓦乔的头。</p><p>意大利画家卡拉瓦乔，作为一个被通缉的画家，常年过着颠沛流离的逃亡生活。<br>罪行满满的卡拉瓦乔最终想回到那个让他登上巅峰的罗马，但是他在那里杀过人啊，所以他决定画一幅画讨掌权者的欢心…… </p><p><img src="/img/media/15308499185596/15308707756929.jpg" alt=""><br>被斩首的施洗约翰</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;艺术的力量-卡拉瓦乔&quot;&gt;&lt;a href=&quot;#艺术的力量-卡拉瓦乔&quot; class=&quot;headerlink&quot; title=&quot;艺术的力量 卡拉瓦乔&quot;&gt;&lt;/a&gt;艺术的力量 卡拉瓦乔&lt;/h1&gt;&lt;p&gt;这个天才，是个恶人&lt;br&gt;教堂寻寻觅觅及卡拉瓦乔生来注定要做的，就是在罪人的
      
    
    </summary>
    
      <category term="纪录片" scheme="https://github.com/zdkswd/categories/%E7%BA%AA%E5%BD%95%E7%89%87/"/>
    
    
      <category term="艺术" scheme="https://github.com/zdkswd/tags/%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 2 面向对象</title>
    <link href="https://github.com/zdkswd/2018/07/05/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%202%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/</id>
    <published>2018-07-05T14:14:32.000Z</published>
    <updated>2018-07-06T02:09:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-2-面向对象"><a href="#松本行弘的程序世界-2-面向对象" class="headerlink" title="松本行弘的程序世界 2 面向对象"></a>松本行弘的程序世界 2 面向对象</h1><h2 id="编程和面向对象的关系"><a href="#编程和面向对象的关系" class="headerlink" title="编程和面向对象的关系"></a>编程和面向对象的关系</h2><p>计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。</p><h3 id="颠倒的构造"><a href="#颠倒的构造" class="headerlink" title="颠倒的构造"></a>颠倒的构造</h3><p>程序员要夺得主动权。</p><h3 id="主宰计算机的武器"><a href="#主宰计算机的武器" class="headerlink" title="主宰计算机的武器"></a>主宰计算机的武器</h3><p>为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。</p><h3 id="怎样写程序"><a href="#怎样写程序" class="headerlink" title="怎样写程序"></a>怎样写程序</h3><p>编程风格 算法 数据结构 设计模式 开发方法</p><h3 id="面向对象的编程方法"><a href="#面向对象的编程方法" class="headerlink" title="面向对象的编程方法"></a>面向对象的编程方法</h3><p>smalltalk为面向对象编程语言之母。</p><h3 id="面向对象的难点"><a href="#面向对象的难点" class="headerlink" title="面向对象的难点"></a>面向对象的难点</h3><p>面向对象编程语言中最重要的技术是“多态性”。</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态就是可以把不同种类的东西当做相同的东西处理。<br>操作对象是三个箱子，分别是盖着盖子的箱子、加了锁的箱子、系着彩带的箱子。在编程中，“打开箱子”的命令，称之为消息；打开不同箱子的具体操作，称之为方法。</p><h3 id="具体的程序"><a href="#具体的程序" class="headerlink" title="具体的程序"></a>具体的程序</h3><p>调用box_open这个方法，根据参数（箱子的种类）的不同做相应的处理。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.11.02.png" alt="屏幕快照 2018-07-04 上午8.11.02" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-04 上午8.11.02</div>            </figure></p><p>但是如果增加种类代码就要重写，修改的地方越来越多，追加箱子的种类就会变得非常困难。<br>修改程序，实现真正的多态。“.”可以理解为“给前面的式子的值发送一个open消息”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.14.46.png" alt="屏幕快照 2018-07-04 上午8.14.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-04 上午8.14.46</div>            </figure></p><h3 id="多态性的优点"><a href="#多态性的优点" class="headerlink" title="多态性的优点"></a>多态性的优点</h3><p>首先，各种数据可以统一地处理。关注要处理什么，而不是怎么处理。<br>其次，根据对象选择方法，程序内部不会冲突。减轻程序员的负担。<br>再次，新数据简单的追加可以实现，不需要改动以前程序，具备了扩展性。</p><h2 id="数据抽象和继承"><a href="#数据抽象和继承" class="headerlink" title="数据抽象和继承"></a>数据抽象和继承</h2><p>面向对象编程的三原则：<strong>多态性</strong>，<strong>数据抽象</strong>，<strong>继承</strong>。别称：多态性：动态绑定，数据抽象：信息隐藏或封装。</p><h3 id="面向对象的历史"><a href="#面向对象的历史" class="headerlink" title="面向对象的历史"></a>面向对象的历史</h3><h4 id="simula的“发明”"><a href="#simula的“发明”" class="headerlink" title="simula的“发明”"></a>simula的“发明”</h4><p>面向对象编程思想起源于瑞典20世纪60年代后期发展起来的模拟编程语言Simula。以前，表示模拟对象的数据和实际的模拟方法是互相独立的，需要分别管理。</p><h4 id="Smalltalk的发展"><a href="#Smalltalk的发展" class="headerlink" title="Smalltalk的发展"></a>Smalltalk的发展</h4><p>smalltalke的开发宗旨是“让儿童也可以使用”，吸收了Simula的面向对象思想，且独居一格。不仅如此，还有一个很好的图形用户界面。使得世人开始了解面向对象编程的概念。</p><h4 id="Lisp的发展"><a href="#Lisp的发展" class="headerlink" title="Lisp的发展"></a>Lisp的发展</h4><p>许多重要的面向对象的概念都是从Lisp的面向对象功能中诞生的。</p><h4 id="和c语言的相遇"><a href="#和c语言的相遇" class="headerlink" title="和c语言的相遇"></a>和c语言的相遇</h4><p>C++是直接受到了simula语言的影响而没有受到smalltalk多大影响。</p><h4 id="Java的诞生"><a href="#Java的诞生" class="headerlink" title="Java的诞生"></a>Java的诞生</h4><p>java语言放弃了和C语言的兼容性，并增加了Lisp语言中一些好的功能。此外，通过Java虚拟机（JVM），java程序可以不用重新编译而在所有操作系统中运行。<br>Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p><h3 id="复杂性是面向对象的敌人"><a href="#复杂性是面向对象的敌人" class="headerlink" title="复杂性是面向对象的敌人"></a>复杂性是面向对象的敌人</h3><p>软件开发的最大敌人是复杂性。人类的大脑无法做台复杂得处理，记忆力和理解力也是有限的。<br>在计算机性能这么高的今天，人们为了找到迅速开发大规模复杂软件的方法，哪怕牺牲一些性能也在所不辞。</p><h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><p>如果不考虑黑盒内部的处理，系统复杂性就可以降低到人类的可控范围内。针对程序控制流的复杂问题，结构化编程采用看限制和抽象化的武器解决问题。</p><h3 id="数据抽象化"><a href="#数据抽象化" class="headerlink" title="数据抽象化"></a>数据抽象化</h3><p>数据抽象是数据和处理方法结合。对数据内容的处理和操作，必须通过实先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。<br>比如说栈。<br>有了数据抽象，程序处理的数据就不再是单纯的数值或者文字这些概念性的东西，而变成了人脑容易想象的具体事物。而代码的“抽象化”则是把想象的过程“具体化”了。</p><h3 id="雏形"><a href="#雏形" class="headerlink" title="雏形"></a>雏形</h3><p>同样的对象大量存在时，为避免重复，可以采用两种方法管理对象。</p><ol><li>原型。用原始对象的副本来作为新的相同的对象，JS用的原型。</li><li>模板，称为类。<br>跟原型不同，面向对象编程语言的类和对象有明显区别。对象又称作实例。<h3 id="找出相似的部分来继承"><a href="#找出相似的部分来继承" class="headerlink" title="找出相似的部分来继承"></a>找出相似的部分来继承</h3>类的增多会用到很多性质相似的类。这就违背了我们的DRY（Don’t Repeat Yourself）原则。把这些相似的部分汇总到一起就好了。<br>继承就是这种方法。子类继承父类所有方法，如有需要可以增加新的方法，也可以重写父类方法。<br>Ruby跟多数编程语言一样，一个子类只能有一个父类，即单一继承，C++、Lisp等编程语言中，一个子类可以有多个父类，这称为“多重继承”。<h2 id="多重继承的缺点"><a href="#多重继承的缺点" class="headerlink" title="多重继承的缺点"></a>多重继承的缺点</h2>继承的原本目的实际上是逐步细化。所以为解决抽出类中相似部分的问题并不完全准确。<h3 id="为什么需要多继承"><a href="#为什么需要多继承" class="headerlink" title="为什么需要多继承"></a>为什么需要多继承</h3>一个程序员也可能是一个作家。<h3 id="多重继承和单一继承不可分离"><a href="#多重继承和单一继承不可分离" class="headerlink" title="多重继承和单一继承不可分离"></a>多重继承和单一继承不可分离</h3>单一继承的特点：</li><li>继承关系单纯，有利有弊<br>多重继承的特点：</li><li>很自然的做到了单一继承的扩展。</li><li>可以继承多个类的功能。<br>单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系变得复杂。这是多重继承的一个缺点。<h3 id="goto语句和多重继承比较相似"><a href="#goto语句和多重继承比较相似" class="headerlink" title="goto语句和多重继承比较相似"></a>goto语句和多重继承比较相似</h3>多重继承导致的问题：</li><li>结构复杂化</li><li>优先顺序模糊</li><li>功能冲突<h3 id="解决多重继承的问题"><a href="#解决多重继承的问题" class="headerlink" title="解决多重继承的问题"></a>解决多重继承的问题</h3>继承作为抽象化的手段，是需要实现多重继承功能的，如果一个类只允许抽出一个功能，那么限制就太多了。<br>受限制的多重继承，这个解决或改善多重继承问题的方法出现了，它在Java中被称为接口（interface）,在Lisp或Ruby中是Mix-in。<h3 id="静态语言与动态语言的区别"><a href="#静态语言与动态语言的区别" class="headerlink" title="静态语言与动态语言的区别"></a>静态语言与动态语言的区别</h3>编程语言可以分为静态语言和动态语言两种。像Java这样规定变量和算式类型的语言称为静态语言。<br>在静态语言中，不能给变量赋不同类型的值，会导致编译错误，不通过执行就可以发现类型不匹配是静态语言的一个优点。<br>如果只能给一个变量赋值同类对象，就不可能根据对象的类自动选择合适的处理方式（多态性）。<h3 id="静态语言的特点"><a href="#静态语言的特点" class="headerlink" title="静态语言的特点"></a>静态语言的特点</h3>当给一个类变量赋值时，既可以用这个类的对象来赋值，也可以用这个类的子类对象来赋值。这样就可以实现多态性。<br>但是这时，如果定义了父类变量，赋值子类对象，变量不能调用子类特有的方法。<h3 id="动态语言的特点"><a href="#动态语言的特点" class="headerlink" title="动态语言的特点"></a>动态语言的特点</h3>动态语言允许调用没有继承关系的方法。静态语言中只能调用有继承关系的方法，数组、哈希表和字符串都能调用的方法，只能是在它们共同的父类（恐怕是Object）中定义。<br>在静态语言中，如果要调用类层次中平行类的方法，那么必须要有一个可以表现这些对象的类型。如果没有这个类型，可调用的方法是十分有限的。由此我们看到静态语言中某种形式的多重继承是不可少的。<h3 id="静态语言与动态语言的比较"><a href="#静态语言与动态语言的比较" class="headerlink" title="静态语言与动态语言的比较"></a>静态语言与动态语言的比较</h3>静态语言即使不通过执行也可以检查出类型是否匹配。但是逐个来定义算式和变量的类型又会使程序变得冗长。只有包含继承关系的类才会具有多态性。<br>对于动态语言来说，静态语言显得限制过多，灵活性差。程序中有没有错误只有执行了才会知道。程序中没有类型定义，这样程序会变得很简洁。只要方法名一样，这些对象可以以相同的方式去处理。这样生产效率会大大提高，这种宽松的编程机制称为Duck Typing（鸭子类型检测）<h3 id="继承的两种含义"><a href="#继承的两种含义" class="headerlink" title="继承的两种含义"></a>继承的两种含义</h3>继承包括两种含义，一种是“<strong>类都有哪些方法</strong>”，也就是说这个类都支持些什么操作，即规格的继承。<br>另一种是“<strong>类中都用了什么数据结构什么算法</strong>”，也就是实现的继承。<br>静态语言中这两者的区别很重要，动态语言中区别规格的继承和实现的继承意义不大。即使没有继承关系，方法也可以自由地调用。<br>java对两者有很明确的区分，实现的继承用extends来继承父类，规格的继承用implements来指定接口。<br>类是用来指定对象实现的，而接口只是指定对象的外观（都有哪些方法）。类的继承是单一的，implements可以指定多个接口。接口对实现没有任何限制，也就是说，接口可以由跟实现的继承没有任何关系的类来实现。<h3 id="接口的缺点"><a href="#接口的缺点" class="headerlink" title="接口的缺点"></a>接口的缺点</h3>为了解决多重继承的问题，人们允许了规格的多重继承，但是还是不允许实现多重继承。<h3 id="继承实现的方法"><a href="#继承实现的方法" class="headerlink" title="继承实现的方法"></a>继承实现的方法</h3>和静态语言Java不同，动态语言本来就没有继承规格这种概念。动态语言需要解决的就是实现的多重继承。<br>Lisp、Perl和Python都提供了多重继承功能，这样就不存在单一继承的问题了。<h3 id="从多重继承变形而来的Mix-in"><a href="#从多重继承变形而来的Mix-in" class="headerlink" title="从多重继承变形而来的Mix-in"></a>从多重继承变形而来的Mix-in</h3>Mix-in是降低多重继承复杂性的一个技术，最初是在Lisp中开始使用的。按以下规则来限制多重继承：</li><li>通常的继承用单一继承</li><li>第二个以及两个以上的父类必须是Mix-in的抽象类。<br>Mix-in类是具有以下特征的抽象类。</li><li>不能单独生成实例</li><li>不能继承普通类<h3 id="积极支持Mix-in的Ruby"><a href="#积极支持Mix-in的Ruby" class="headerlink" title="积极支持Mix-in的Ruby"></a>积极支持Mix-in的Ruby</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8B%E5%8D%885.39.58.png" alt="屏幕快照 2018-07-04 下午5.39.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-04 下午5.39.58</div>            </figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我理解的接口的作用：接口是一种协议，满足同一接口实际上是告诉计算机你们是满足了同一样协议，你们是有关系的，java以这种方式间接实现了多态。当然可以实现多个接口，抽象为不同的“种类”，这样就相当于某种意义上的”多继承“。</span><br><span class="line"></span><br><span class="line">InterA a;</span><br><span class="line">　　a= new B();</span><br><span class="line">　　a.fun();</span><br><span class="line">　　a = new C();</span><br><span class="line">　　a.fun();</span><br><span class="line">　　bc都实现a的接口</span><br></pre></td></tr></table></figure><h2 id="两个误解"><a href="#两个误解" class="headerlink" title="两个误解"></a>两个误解</h2><ol><li>对象是对现实世界中具体物体的反应，继承是对物体分类的反应。（误）</li><li>多重继承是不好的。Mix-in不错。（误）</li></ol><p>澄清：如果多继承用的不好就会出问题，Mix-in只不过是实现多重继承的一个技巧而已。</p><h3 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a>面向对象的编程</h3><p>不管过去怎样，现在面向对象最好的理解是，面向对象编程是结构化编程的延伸。<br>随着软件的复杂化，开发越来越复杂，Dijkstra提倡把程序控制限制为（1）顺序（2）循环（3）分支 使得程序变得简单且容易理解。<strong>面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上对数据的结构化。</strong><br>面向对象编程，封装（黑盒）和多态（减少分支处理）是提高生产率的技术。<br><strong>结构化编程通过整理数据流，提高程序的生成效率和可维护性。同样，面向对象编程通过对数据结构的整理，提高了程序的生产效率和可维护性。</strong></p><h3 id="对象的模板-类"><a href="#对象的模板-类" class="headerlink" title="对象的模板=类"></a>对象的模板=类</h3><p>类是吧数据黑盒化的工具，由于对类内部的操作都是通过类的方法来实现的，所以内部数据结构即使在以后发生变化，对外部也没有影响。</p><h3 id="利用模板的手段-继承"><a href="#利用模板的手段-继承" class="headerlink" title="利用模板的手段=继承"></a>利用模板的手段=继承</h3><p>类是模块，继承就是利用模块的方法。传统的面向对象编程语言是一下子把规格和实现都继承下来，在最近，有的是把这两种继承分开了。比如java里的接口就是规格继承。</p><h3 id="多重继承不好吗"><a href="#多重继承不好吗" class="headerlink" title="多重继承不好吗"></a>多重继承不好吗</h3><p>单一继承的类之间的关系是很单纯的树结构。但是对于多重继承而言，类之间的关系却是复杂得网状结构。<br><strong>静态语言中可以实现多态性只是局限于拥有共通父类的对象。</strong><br>为了解决这个问题，静态面向对象编程语言的代表<strong>C++支持多重继承</strong>。java也可以通过接口来支持规格的多重继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**静态类型语言**: 是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型，某些具有类型推导能力的现代语言可能能够部分减轻这个要求. </span><br><span class="line">**动态类型语言**: 是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 </span><br><span class="line">**强类型语言**: 是一旦变量的类型被确定，就不能转化的语言。实际上所谓的貌似转化，都是通过中间变量来达到，原本的变量的类型肯定是没有变化的。 </span><br><span class="line">**弱类型语言**: 则反之，一个变量的类型是由其应用上下文确定的。比如语言直接支持字符串和整数可以直接用 + 号搞定。当然，在支持运算符重载的强类型语言中也能通过外部实现的方式在形式上做到这一点，不过这个是完全不一样的内涵</span><br></pre></td></tr></table></figure></p><h3 id="动态编程语言也需要多重继承"><a href="#动态编程语言也需要多重继承" class="headerlink" title="动态编程语言也需要多重继承"></a>动态编程语言也需要多重继承</h3><p>动态编程语言没有类型检查，从这方面来说没有理由用多重继承，但是动态编程语言肯定需要多重继承。<br>实现共享可以通过多个对象的组合（composition）和委托（delegate）来做到。</p><h3 id="驯服多重继承的方法"><a href="#驯服多重继承的方法" class="headerlink" title="驯服多重继承的方法"></a>驯服多重继承的方法</h3><p>多重继承可能引发的问题：</p><ol><li>类关系复杂化</li><li>继承功能名字重复<br>最初的问题是因为类关系从简单的树结构变成了复杂的网状结构。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%889.18.30.png" alt="屏幕快照 2018-07-05 上午9.18.30" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 上午9.18.30</div>            </figure></li></ol><p>父类的优先级并不明确，多重继承设计的一个有效的技巧是Mix-in。用Mix-in做多继承设计时，从第2个父类开始的类要满足以下条件。</p><ol><li>不能单独生成实例的抽象类。</li><li>不能继承Mix-in以外的类。</li></ol><p><strong>抽象类和接口的对比</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.41.50.png" alt="屏幕快照 2018-07-05 上午10.41.50" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 上午10.41.50</div>            </figure></p><p>mix-in的例子<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.44.57.png" alt="屏幕快照 2018-07-05 上午10.44.57" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 上午10.44.57</div>            </figure></p><p><strong>通过对功能的分离，多重继承就可以由单一继承加上Mix-in类来实现。</strong>利用Mix-in就可以同时享有单一继承的单纯性和多重继承的共有性。</p><p>对于名字重复问题（如函数名），多重继承编程语言都有自己的应对方法，大致分为以下3种：</p><ol><li>给父类定义优先级</li><li>把重复的名字替换掉</li><li>指定使用类的名字<h3 id="ruby中多重继承的实现方法"><a href="#ruby中多重继承的实现方法" class="headerlink" title="ruby中多重继承的实现方法"></a>ruby中多重继承的实现方法</h3>Mix-in<h3 id="java实现多重继承的方法"><a href="#java实现多重继承的方法" class="headerlink" title="java实现多重继承的方法"></a>java实现多重继承的方法</h3>接口。。<h2 id="Duck-Typing诞生之前"><a href="#Duck-Typing诞生之前" class="headerlink" title="Duck Typing诞生之前"></a>Duck Typing诞生之前</h2>静态是指程序执行之前，从代码中就可以知道一切。程序静态的部分包括变量、方法的名称和类型以及控制程序的结构等等。<br>相对于静态，动态是指在程序执行之前有些地方是不知道的。程序动态的部分包括变量的值、执行时间和使用的内存等等。<br>通常情况下、程序本来就是不被执行就不知道结果的，所以在一定程度上说程序都具有动态特性。因此，严格说静态和动态之间的界限是很微妙的。<h3 id="为什么需要类型"><a href="#为什么需要类型" class="headerlink" title="为什么需要类型"></a>为什么需要类型</h3><h3 id="动态的类型是从Lisp中诞生的"><a href="#动态的类型是从Lisp中诞生的" class="headerlink" title="动态的类型是从Lisp中诞生的"></a>动态的类型是从Lisp中诞生的</h3><h3 id="动态类型在面向对象中发展起来了"><a href="#动态类型在面向对象中发展起来了" class="headerlink" title="动态类型在面向对象中发展起来了"></a>动态类型在面向对象中发展起来了</h3>对象保存着有关自己种类的信息，某个变量可以用各种类型的数据来赋值，这两点是多态这一面向对象重要特性的必要条件。<h3 id="动态类型和静态类型的邂逅"><a href="#动态类型和静态类型的邂逅" class="headerlink" title="动态类型和静态类型的邂逅"></a>动态类型和静态类型的邂逅</h3>20世纪80年代，面向对象编程语言主流是包含动态数据类型的语言，但是在21世纪的今天，使用最广泛的面向对象编程语言是具有静态类型的java和c++。<br>受simula很大影响的c++引入了子类对象可以看成是父类对象这个原则，对象也采用了静态类型。<br>根据这个原则，在编译时就可以知道变量或算式的类型，又可以根据执行时的数据类型自动选择合适的处理，从而同时具备了静态类型的优点和动态类型的多态性。<h3 id="静态类型的优点"><a href="#静态类型的优点" class="headerlink" title="静态类型的优点"></a>静态类型的优点</h3></li><li>最大的优点是在编译时能够发现不匹配的错误。</li><li>如果明确指定了数据类型，在编译时可以用到的信息就很多，利用这种信息可以在编译时对程序做优化，提高程序执行速度。</li><li>在读程序时提高理解度，IDE也可以自动补充。</li></ol><p>问题：</p><ol><li>不指定类型就写不了程序，数据类型只是一些辅助信息，并不是程序本质。有的类型声明仅仅是为了满足编译器的要求。程序规模也因为数据类型的定义而变大。</li><li>灵活性问题。静态类型本身限制了给某个变量只能赋值某种类型的对象，这种限制可能成为妨碍将来变化的枷锁。 <h3 id="动态类型的优点"><a href="#动态类型的优点" class="headerlink" title="动态类型的优点"></a>动态类型的优点</h3></li><li>源代码简洁，提高生产力。</li><li>会不会更难以理解，更突出程序处理的实质，程序函数相差几十倍并不少见，理解起来反而简单。</li><li>会不会运行更缓慢，同样的处理，在大多数情况下，静态类型编程语言运行得要快些。这是因为动态类型程序执行时要做类型检查。另外，静态类型的编程语言大都是通过编译把程序源代码转换成可以直接执行的形式，而动态类型的编程语言大多是边解释源代码（转换成内部形式）边执行，这种编译型处理和解释型处理的区别也是影响程序执行速度的愿意之一。</li><li>灵活，灵活性的关键是Duck Typing。</li><li>最大的缺点是不执行就检测不出错误。  </li></ol><h3 id="只关心行为的Duck-Typing"><a href="#只关心行为的Duck-Typing" class="headerlink" title="只关心行为的Duck Typing"></a>只关心行为的Duck Typing</h3><p>If it walks like a duck and quacks like a duck,it must be a duck.（走起路来像鸭子，叫起来也像鸭子，那么他就是鸭子）。<br>根本不考虑一个对象属于什么类，只关心它有什么样的行为（它有哪些方法）。<br><strong>动态语言用Duck Typing的概念设计时需要遵循的原则最低限度是避免明确的类型检查。</strong></p><h3 id="避免明确的类型检查"><a href="#避免明确的类型检查" class="headerlink" title="避免明确的类型检查"></a>避免明确的类型检查</h3><h3 id="克服动态类型的缺点"><a href="#克服动态类型的缺点" class="headerlink" title="克服动态类型的缺点"></a>克服动态类型的缺点</h3><ol><li>执行时才能发现可以用完备的单元测试来解决，如果能严格实行完备的单元测试的话，即使没有编译时的错误检查，程序的可靠性也不会降低。</li><li>读程序时可用到的线索少这一点可以通过完整的文档来解决。可以在源代码中同时写文档，减轻维护文档的负担。</li><li>运行速度慢，随着计算机性能的提升已经不再重要，现在的程序开发中，程序的灵活性和生产力更为重要。</li></ol><h3 id="动态编程语言"><a href="#动态编程语言" class="headerlink" title="动态编程语言"></a>动态编程语言</h3><p>现在我们对程序开发生产力的要求越来越高，也就是说，要在更短的时间内开发出更多的功能。<br>尽快着手开发，快速应对需求变更的开发方式变得越来越重要。<br>在这种快速开发模式中，Duck Typing所代表的执行时的灵活性就非常有用。Ruby、Python、Perl和PHP等优秀的动态类型编程语言，因为它们在执行时所具有的灵活性而越来越受到人们的关注。</p><h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><p>元编程是对程序进行编程的意思。</p><h3 id="元编程-1"><a href="#元编程-1" class="headerlink" title="元编程"></a>元编程</h3><p>利用元编程可以动态生成类的方法，而且重要的是你可以自己编写生成过程，不支持元编程的编程语言实现这样的功能是很麻烦的，要么需要扩展语言的语法，要么用宏定义等预处理方法来实现。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>元编程的反射（reflection）,在编程语言中它是指在程序执行时取出程序的信息或者改变程序的信息。<br>Ruby彻底实现了对程序的动态操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8B%E5%8D%887.10.21.png" alt="屏幕快照 2018-07-05 下午7.10.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 下午7.10.21</div>            </figure><h3 id="元编程的例子"><a href="#元编程的例子" class="headerlink" title="元编程的例子"></a>元编程的例子</h3><p>Ruby使用Delegator这个库实现了委托功能，调用对象d的方法时可以转变为调用a的方法。我们还可以给这个对象增加特意方法来改变它的部分行为，这就大大扩展了它的应用范围。</p><h3 id="使用反射功能"><a href="#使用反射功能" class="headerlink" title="使用反射功能"></a>使用反射功能</h3><h3 id="分布式Ruby的实现"><a href="#分布式Ruby的实现" class="headerlink" title="分布式Ruby的实现"></a>分布式Ruby的实现</h3><p>Delegator将被调用的方法直接委派到其他对象，这一功能在很多领域都有应用。如dRuby。<br>dRuby是通过网络来调用方法的库。dRuby可以生成服务器上存在的远程对象（Proxy），Proxy的方法调用可以通过网络执行。<br>调用的方法在服务器上的远程对象中执行，执行结果可以通过网络返回。这和java的RMI(Remote Method Invocation)功能比较相似。但是，利用Ruby的元编程功能，不用明确定义接口，也可以通过网络调用任一对象的方法。<br>C++和Java的远程调用是用IDL（Interface Definition Language）等语言来定义接口的，自动生成的存根（stub）必须编译和连接。和这些相比，Ruby的元编程更简单。</p><h3 id="数据库的应用"><a href="#数据库的应用" class="headerlink" title="数据库的应用"></a>数据库的应用</h3><p>在数据库领域，元编程也很有用。<br>web应用程序框架Ruby on Rails(也称为Rails或RoR)中也应用了元编程。具体地说是在与数据库关联的类库（ActiveRecord）中，利用元编程简单的把数据记录定义为对象。<br>由于元编程功能让我们可以获取类名，在执行时增加方法。元编程的功能使得Rails被称赞为生产效率高的Web应用程序框架。</p><h3 id="输出xml"><a href="#输出xml" class="headerlink" title="输出xml"></a>输出xml</h3><p>手工写XML是很麻烦的，利用Ruby块功能则可以很方便的处理。</p><h3 id="元编程和小编程语言"><a href="#元编程和小编程语言" class="headerlink" title="元编程和小编程语言"></a>元编程和小编程语言</h3><p>元编程功能可以运用到DSL领域，DSL是针对特定领域强化了功能的小规模编程语言。通过DSL用户可以强化应用程序的功能或者定制一些功能。</p><h3 id="声明的实现"><a href="#声明的实现" class="headerlink" title="声明的实现"></a>声明的实现</h3><p>Ruby的方法可以读取或改变程序自身的状态，利用普通的方法调用，可以实现其他编程语言中声明所完成的工作。</p><h3 id="上下文相关的实现"><a href="#上下文相关的实现" class="headerlink" title="上下文相关的实现"></a>上下文相关的实现</h3><p>instance_eval方法接受块作为参数，把调用对象置换成self来执行块。</p><h3 id="单位的实现"><a href="#单位的实现" class="headerlink" title="单位的实现"></a>单位的实现</h3><h3 id="词汇的实现"><a href="#词汇的实现" class="headerlink" title="词汇的实现"></a>词汇的实现</h3><p>针对特定领域，如果用Ruby来定义需要的类和方法，那么就可以认为Ruby是这个领域的专用语言。这些类和方法可以称为这个领域的词汇。</p><h3 id="层次数据的实现"><a href="#层次数据的实现" class="headerlink" title="层次数据的实现"></a>层次数据的实现</h3><h3 id="适合DSL的语言，不适合DSL的语言"><a href="#适合DSL的语言，不适合DSL的语言" class="headerlink" title="适合DSL的语言，不适合DSL的语言"></a>适合DSL的语言，不适合DSL的语言</h3><p>Ruby是非常适合DSL的语言。<br>首先定义好DSL用的小语言，然后编译成C++、java等目标语言。编译器经常用到Ruby这种具有优秀文本处理的语言。<br>另一种实现DSL方法的例子是解释器。比如开发应用程序时从设计到实现是很复杂的，可以利用固定的语法和类库函数来读取程序。具体方法是用XML、DOM等XML处理类库来解释小语言语法。这是Java应用程序的配置文件曹勇XML的原因之一。通过XML文件，不用每次编译Java程序就可以改变配置，定制程序的行为。<br>这种用法可以把XML称为Java界的DSL，或是Java应用程序的脚本语言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。</span><br><span class="line">早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是--解释运行--而非编译。虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-2-面向对象&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-2-面向对象&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 2 面向对象&quot;&gt;&lt;/a&gt;松本行弘的程序世界 2 面向对象&lt;/h1&gt;&lt;h2 id=&quot;编程和面向对象的关
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>周海宏音乐鉴赏 一 打开你的耳朵</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E5%91%A8%E6%B5%B7%E5%AE%8F%E9%9F%B3%E4%B9%90%E9%89%B4%E8%B5%8F%20%E4%B8%80%20%E6%89%93%E5%BC%80%E4%BD%A0%E7%9A%84%E8%80%B3%E6%9C%B5/"/>
    <id>https://github.com/zdkswd/2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/</id>
    <published>2018-07-04T14:28:13.000Z</published>
    <updated>2018-07-04T14:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="周海宏音乐鉴赏-一-打开你的耳朵"><a href="#周海宏音乐鉴赏-一-打开你的耳朵" class="headerlink" title="周海宏音乐鉴赏 一 打开你的耳朵"></a>周海宏音乐鉴赏 一 打开你的耳朵</h1><h2 id="1-1音乐鉴赏的误区"><a href="#1-1音乐鉴赏的误区" class="headerlink" title="1.1音乐鉴赏的误区"></a>1.1音乐鉴赏的误区</h2><p>音乐中包含各种内容的表现，说不出来是什么是因为你“听不懂”.<br>专业学生也”听不懂“。<br>音乐两个基本属性<br>1 没有视觉性<br>2 没有语义性<br>“听不懂”–说不出音乐表现的是什么并非听者欣赏水平差，因为音乐不能直接传达视觉性与语义性的内容。</p><p>在音乐的欣赏中<br>-不一定非要听出明确的视觉性、语义性内容。<br>-不一定非要用文学化、美术化的内容去解说音乐。</p><p>在音乐中追求明确的概念性、视觉性内容，用文学化与美术化的方式欣赏音乐是一个误区。</p><p><strong>音乐何须“懂”。</strong></p><h2 id="1-2音乐的艺术本质"><a href="#1-2音乐的艺术本质" class="headerlink" title="1.2音乐的艺术本质"></a>1.2音乐的艺术本质</h2><p>音乐是动态的。<br>音乐是情绪的艺术。<br>1 纯听觉感受<br>2 情绪的感受<br>动态纪实细腻地描摹内心的感受。</p><h2 id="1-3-音乐审美的基本概念"><a href="#1-3-音乐审美的基本概念" class="headerlink" title="1.3 音乐审美的基本概念"></a>1.3 音乐审美的基本概念</h2><p>幸福人生最重要的是丰富多彩，真正的欣赏音乐，就去听最伟大的音乐。<br>世界是这么龌龊这么黑暗，可悲的不是世界这么龌龊这么黑暗，而是不知道世界还有光明。<br>音乐是人类精神的避难所。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;周海宏音乐鉴赏-一-打开你的耳朵&quot;&gt;&lt;a href=&quot;#周海宏音乐鉴赏-一-打开你的耳朵&quot; class=&quot;headerlink&quot; title=&quot;周海宏音乐鉴赏 一 打开你的耳朵&quot;&gt;&lt;/a&gt;周海宏音乐鉴赏 一 打开你的耳朵&lt;/h1&gt;&lt;h2 id=&quot;1-1音乐鉴赏的误
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="音乐鉴赏" scheme="https://github.com/zdkswd/tags/%E9%9F%B3%E4%B9%90%E9%89%B4%E8%B5%8F/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界1 我为什么开发Ruby</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C1%20%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91Ruby/"/>
    <id>https://github.com/zdkswd/2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/</id>
    <published>2018-07-04T10:38:32.000Z</published>
    <updated>2018-07-04T10:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界1-我为什么开发Ruby"><a href="#松本行弘的程序世界1-我为什么开发Ruby" class="headerlink" title="松本行弘的程序世界1 我为什么开发Ruby"></a>松本行弘的程序世界1 我为什么开发Ruby</h1><h2 id="编程语言的重要性"><a href="#编程语言的重要性" class="headerlink" title="编程语言的重要性"></a>编程语言的重要性</h2><p>程序员由于使用的编程语言不同，思考方法和编写出的代码都会受到很大的影响。</p><h2 id="Ruby的原则"><a href="#Ruby的原则" class="headerlink" title="Ruby的原则"></a>Ruby的原则</h2><ol><li>简洁性</li><li>扩展性</li><li>稳定性<h2 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h2>随着编程语言的演进，程序员已经可以更简单、更抽象地编程了。面向对象的方法没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序运行开销。现在由于计算机性能大大提高，只要可以提高软件的开发效率，浪费一些计算机资源也无所谓了。<br>ruby的目标是成为开发效率高、能直接运行的伪码式编程语言。省去了不必要的声明。<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2>Ruby看重的不是明哲保身，而是如何最大限度的发挥程序员自身的能力。<br>编程的历史就是因为想当然而失败的历史，ruby对整数范围不做任何限定，尽最大努力排除“想当然”。<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2>虽然ruby非常重视扩展性，但明知道LISP风格的宏能带来巨大的扩展性，仍没有使用。<h2 id="一切皆因兴趣"><a href="#一切皆因兴趣" class="headerlink" title="一切皆因兴趣"></a>一切皆因兴趣</h2></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界1-我为什么开发Ruby&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界1-我为什么开发Ruby&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界1 我为什么开发Ruby&quot;&gt;&lt;/a&gt;松本行弘的程序世界1 我为什么开发Ruby&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界0 说在前面</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C0%20%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>https://github.com/zdkswd/2018/07/04/松本行弘的程序世界0 说在前面/</id>
    <published>2018-07-04T10:35:32.000Z</published>
    <updated>2018-07-04T10:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界0-说在前面"><a href="#松本行弘的程序世界0-说在前面" class="headerlink" title="松本行弘的程序世界0 说在前面"></a>松本行弘的程序世界0 说在前面</h1><h2 id="vczh如何设计一门语言（一）"><a href="#vczh如何设计一门语言（一）" class="headerlink" title="vczh如何设计一门语言（一）"></a>vczh如何设计一门语言（一）</h2><p>好的语言，除了库写起来又容易又好用以外，还有两个重要的特点：容易学，容易分析。关于容易学这一点，其实不是说，你随便看一看就能学会，而是说，只要你掌握了门道，很多未知的特性你都可以猜中。这就有一个语法的<strong>一致性问题</strong>在里面了。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ruby code for fun<br>这本书是松本行弘从一个编程语言设计者的角度去看待各种各样的流行编程语言，分析它们有哪些特点以及ruby编程语言如何进行取舍。ruby本身大量参考了一个更古老而著名的面向对象编程方法的开山鼻祖smalltalk以及偷师函数式编程语言鼻祖LISP。程序员社区有种说法：任何现代编程语言都脱胎于smalltalk于LISP。看看Ruby设计师是怎么设计Ruby语言的，则可以高屋建瓴的理解一些主流的编程语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界0-说在前面&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界0-说在前面&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界0 说在前面&quot;&gt;&lt;/a&gt;松本行弘的程序世界0 说在前面&lt;/h1&gt;&lt;h2 id=&quot;vczh如何设计一门语言（
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>growth全栈</title>
    <link href="https://github.com/zdkswd/2018/07/03/growth%E5%85%A8%E6%A0%88/"/>
    <id>https://github.com/zdkswd/2018/07/03/growth全栈/</id>
    <published>2018-07-03T01:12:25.000Z</published>
    <updated>2018-07-03T03:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识篇"><a href="#基础知识篇" class="headerlink" title="基础知识篇"></a>基础知识篇</h1><p>环境是生产率的一部分。高效的程序员与低效的程序员间十倍的差距，至少有三倍是因为环境差异。<br>语言和开发软件都是工具，都有相对更合适的情况。</p><h2 id="提高效率的工具："><a href="#提高效率的工具：" class="headerlink" title="提高效率的工具："></a>提高效率的工具：</h2><h3 id="快速启动软件"><a href="#快速启动软件" class="headerlink" title="快速启动软件"></a>快速启动软件</h3><p>windows-&gt; launcy</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><h3 id="DEBUG工具"><a href="#DEBUG工具" class="headerlink" title="DEBUG工具"></a>DEBUG工具</h3><h3 id="终端或命令提示符"><a href="#终端或命令提示符" class="headerlink" title="终端或命令提示符"></a>终端或命令提示符</h3><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="OSX"><a href="#OSX" class="headerlink" title="OSX"></a>OSX</h3><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><p>包管理工具，官方称之为 The missing package manager for OS X。 </p><h4 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a>Homebrew Cask</h4><p>brew-cask 允许你使用命令行安装 OS X 应用。 </p><h4 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h4><p>iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。 </p><h4 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h4><p>Zsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:<br>• 更高效<br>• 更好的自动补全• 更好的文件名展开(通配符展开) • 更好的数组处理• 可定制性高 </p><h4 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h4><p>Oh My Zsh 同时提供一套插件和工具，可以简化命令行操作。  </p><h4 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a>MacDown</h4><p>MacDown 是 Markdown 编辑器。 </p><h4 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h4><p>CheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按 。 </p><h4 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h4><p>SourceTree 是 Atlassian 公司出品的一款优秀的 Git 图形化客户端。 </p><h4 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h4><p>Mac 用户不用鼠标键盘的必备神器，配合大量 Workflows，习惯之后可以大 大减少操作时间。<br>上手简单，调教成本在后期自定义 Workflows，不过有大量雷锋使用者提供的现成 扩展，访问这里挑选喜欢的，并可以极其简单地根据自己的需要修改。 </p><h4 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a>Vimium</h4><p>Vimium 是一个 Google Chrome 扩展，让你可以纯键盘操作 Chrome。 </p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h4><p>Chocolatey 是一个软件包管理工具，类似于 Ubuntu 下面的 apt-get, 不过是 运行在 Windows 环境下面。 </p><h4 id="Wox"><a href="#Wox" class="headerlink" title="Wox"></a>Wox</h4><p>Wox 是一个高效的快速启动器工具，通过快捷键呼出，然后输入关键字来搜 索程序进行快速启动，或者搜索本地硬盘的文件，打开百度、Google 进行搜 索，甚至是通过一些插件的功能实现单词翻译、关闭屏幕、查询剪贴板历史、 查询编程文档、查询天气等更多功能。它最大的特点是可以支持中文拼音的 模糊匹配。 </p><h4 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h4><p>Windows PowerShell 是微软公司为 Windows 环境所开发的壳程序(shell) 及脚本语言技术，采用的是命令行界面。这项全新的技术提供了丰富的控制 与自动化的系统管理能力。 </p><h4 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h4><p>cmder 把 conemu，msysgit 和 clink 打包在一起，让你无需配置就能使用一 个真正干净的 Linux 终端!她甚至还附带了漂亮的 monokai 配色主题。 </p><h4 id="Total-Commander"><a href="#Total-Commander" class="headerlink" title="Total Commander"></a>Total Commander</h4><p>Total Commander 是一款应用于 Windows 平台的文件管理器，它包含两个 并排的窗又，这种设计可以让用户方便地对不同位置的 “文件或文件夹” 进 行操作，例如复制、移动、删除、比较等，相对 Windows 资源管理器而言 方便很多，极大地提高了文件操作的效率，被广大软件爱好者亲切地简称为: TC 。 </p><h3 id="GNU-Linux"><a href="#GNU-Linux" class="headerlink" title="GNU/Linux"></a>GNU/Linux</h3><h4 id="Zsh-1"><a href="#Zsh-1" class="headerlink" title="Zsh"></a>Zsh</h4><p>Zsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:<br>• 更高效<br>• 更好的自动补全<br>• 更好的文件名展开(通配符展开)<br>• 更好的数组处理• 可定制性高 </p><h4 id="Oh-My-Zsh-1"><a href="#Oh-My-Zsh-1" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h4><p>Oh My Zsh 同时提供一套插件和工具，可以简化命令行操作。</p><h4 id="ReText"><a href="#ReText" class="headerlink" title="ReText"></a>ReText</h4><p>ReText 是一个使用 Markdown 语法和 reStructuredText (reST) 结构的文本 编辑器，编辑的内容支持导出到 PDF、ODT 和 HTML 以及纯文本，支持即 时预览、网页生成以及 HTML 语法高亮、全屏模式，可导出文件到 Google Docs 等。 </p><h4 id="Launchy"><a href="#Launchy" class="headerlink" title="Launchy"></a>Launchy</h4><p>Launchy 是一款免费开源的协助您摒弃 Windows “运行” 的 Dock 式替代工 具，既方便又实用，自带多款皮肤，作为美化工具也未尝不可。 </p><p>学习一门语言，输出是最好的输入，实践更是硬道理。 </p><h1 id="Web编程基础"><a href="#Web编程基础" class="headerlink" title="Web编程基础"></a>Web编程基础</h1><p>运用HTTP传递数据,浏览器第一步Parser HTML,Paser HTML 实质上就是将其 将解析为 DOM Tree。与此同时，CSS 解析器会解析 CSS 会产生 CSS 规则树。<br>随后会根据生成的 DOM 树和 CSS 规则树来构建 Render Tree，接着生成 Render Tree 的布局，最后就是绘制出 Render Tree。<br> <img src="/img/media/15290576482384/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-17%20%E4%B8%8B%E5%8D%884.12.56.png" alt="屏幕快照 2018-06-17 下午4.12.56"></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>超文本标记语言 </p><ol><li>浏览器解析器对中文支持不友好。 </li><li>浏览器解析器对英文支持友好。 <h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3>类选择器，id选择器<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2>HTML 中插入 JavaScript 的方法，就需要用到 HTML 中的 &lt; script&gt; 标签 完整的 JavaScript 应该由下列三个部分组成:<br>• 核心 (ECMAScript)——核心语言功能<br>• 文档对象模型 (DOM)——访问和操作网页内容的方法和接口<br>• 浏览器对象模型 (BOM)——与浏览器交互的方法和接口</li></ol><p>有了 DOM 我们就可以对页面进行操作，可以说我们看<br>到的绝大部分的页面效果都是通过 DOM 操作实现的。 </p><h2 id="前端与后端"><a href="#前端与后端" class="headerlink" title="前端与后端"></a>前端与后端</h2><h3 id="后台语言选择"><a href="#后台语言选择" class="headerlink" title="后台语言选择"></a>后台语言选择</h3><h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><p>只要是 Web 就会有前端,只要有前端就需要有 JavaScript。与此同时 Node.js在后台中的地位已经愈发重要了。<br>对于 JavaScript 来说，它可以做很多类型的应用。这些应用都是基于浏览器来运行 的，有:<br>• Electron + Node.js + JavaScript 做桌面应用<br>• Ionic + JavaScript 做移动应用<br>• Node.js + JavaScript 网站前后台<br>• JavaScript + Tessl 做硬件 </p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><strong>Model</strong><br>模型用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。<br><strong>View</strong> 层只是单纯的一个显示作用，这也是我们推荐的做法。业务逻辑应 该尽可能的放置于业务层。<br><strong>Controller</strong><br>控制器层起到不同层面间的组织作用，用于控制应用程序的流程。</p><h3 id="后台即服务"><a href="#后台即服务" class="headerlink" title="后台即服务"></a>后台即服务</h3><p>移动端应用程序</p><h3 id="前端框架选择"><a href="#前端框架选择" class="headerlink" title="前端框架选择"></a>前端框架选择</h3><h4 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h4><p>AngularJS 对于后端人员写前端代码来说，是一个非常不错的选择。Angular 框架 采用并扩展了传统 HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许 模型和视图之间的自动同步。 </p><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>React 只是我们在上面章节里说到的 View 层，而这个 View 层需要辅以其他框架才 能完成更多的工作。<br>并且 React 还有一个不错的杀手锏——React Native，虽然这个框架还在有条不紊地 挖坑中，但是这真的是太爽了。以后我们只需要一次开发就可以多处运行了，再也没有 比这更爽的事情发生了。 </p><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><p>Vue.js 是一个轻量级的前端框架。它是一个更加灵活开放的解决方案。它允许你以 希望的方式组织应用程序，你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。 </p><h4 id="jQuery系"><a href="#jQuery系" class="headerlink" title="jQuery系"></a>jQuery系</h4><p>jQuery 还是一个不错的选择，不仅仅对于学习来说，而且对于工作来说也是如此。 如果你们不是新起一个项目或者重构旧的项目，那么必然你是没有多少机会去超越 DOM。 </p><h3 id="前台与后台交互"><a href="#前台与后台交互" class="headerlink" title="前台与后台交互"></a>前台与后台交互</h3><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>AJAX 即 “Asynchronous JavaScript And XML”(异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。<br>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更 新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的 网页如果需要更新内容，必须重载整个网页页面。 </p><h4 id="JSON-WEB-Tokens"><a href="#JSON-WEB-Tokens" class="headerlink" title="JSON WEB Tokens"></a>JSON WEB Tokens</h4><p>JSON Web Token (JWT) 是一种基于 token 的认证方案。<br>在人们大规模地开始 Web 应用的时候，我们在授权的时候遇到了一些问题，而这些 问题不是 Cookie 所能解决的。<br>通过 JWT 我们可以更方便地写出适用于前端应用的认证方案，如登陆、注册这些功能。<br>在使用 JWT 的时候也需要注意安全问题，在允许的情况下应该使用 HTTPS 协议。 </p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>HTML5 推出了一种 在单个 TCP 连接上进行全双工通讯的协议 WebSocket。WebSocket 可以让客户端和服务器之间存在持久的连接，而且双方都可以随时开始 发送数据。 </p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="Web-应用的构建系统"><a href="#Web-应用的构建系统" class="headerlink" title="Web 应用的构建系统"></a>Web 应用的构建系统</h2><p>构建系统 (build system) 是用来从源代码生成用户可以使用的目标的自动化 工具。目标可以包括库、可执行文件、或者生成的脚本等等。 </p><p>常用的构建工具包括 GNU Make、GNU autotools、CMake、Apache Ant(主要用于 JAVA)。此外，所有的集成开发环境(IDE)比如 Qt Creator、Microsoft Visual Studio 和 Eclipse 都对他们支持的语言添加了自己的构建系统配置工具。通常 IDE 中的构建系 统只是基于控制台的构建系统(比如 Autotool 和 CMake )的前端。<br>对比于 Web 应用开发来说，构建系统应该还包括应用打包 (如 Java 中的 Jar 包，或 者用于部署的 RPM 包、源代码分析、测试覆盖率分析等等。 </p><h2 id="Web-应用的构建"><a href="#Web-应用的构建" class="headerlink" title="Web 应用的构建"></a>Web 应用的构建</h2><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><strong>Gulp.js</strong>是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你 可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务 的 Gulp 文件都是通过 JavaScript(或者 CoffeeScript )源码来实现的。 </p><h3 id="JSHint"><a href="#JSHint" class="headerlink" title="JSHint"></a>JSHint</h3><p>最初，lint这个工具用来扫描C源文件并对源程序中不可移植的代码提出警告。但是现在大多数lint实用程序已经变得更加严密，它不但可以检查出可移植性问题，而且可以检查出那些虽然可移植并且完全合乎语法但却很可能是错误的特性。<br>对应于不同的语言都会有不同的 lint 工具，在 JavaScript 中就有JSLint。JavaScript 是一门年轻、语法灵活多变且对格式要求相对松散的语言，因此这样的工具对于这门语 言来说比较重要。<br>• 可配置规则，每个团队可以自己定义自己想要的代码规范。<br>• 对社区非常友好，社区支持度高。<br>• 可定制的结果报表。 </p><h3 id="自动化测试工具"><a href="#自动化测试工具" class="headerlink" title="自动化测试工具"></a>自动化测试工具</h3><p>Mocha 是一个可以运行在 Node.js 和浏览器环境里的测试框架。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>对于静态型语言来说，编译是一个很重要的步骤。不过，对于动态语言来说也存在这样的工具。<br><strong>动态语言的编译</strong>:是以我们常见的 JavaScript 为代表。<br><strong>打包</strong>,1.    DEB 2.RPM 3.压缩文档 tar.gz </p><h3 id="如何编写测试TODO"><a href="#如何编写测试TODO" class="headerlink" title="如何编写测试TODO"></a>如何编写测试TODO</h3><p>测试金字塔 从上到下 ui测试 服务测试 单元测试<br>测试替身 Stub Mock</p><h3 id="代码重构TODO"><a href="#代码重构TODO" class="headerlink" title="代码重构TODO"></a>代码重构TODO</h3><p>重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。 </p><h1 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h1><h2 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h2><p>目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。 </p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广 泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器 端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译 到服务器中。 </p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件(IMAP/ POP3)代理服务器，并在一个 BSD-like 协议下发行。由俄罗斯的程序设计师 Igor Sysoev 所开发，供俄国大型的入又网站及搜索引擎 Rambler(俄文:Рамблер)使用。 其特点是占有内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务 器中表现较好，中国大陆使用 Nginx 网站用户有:百度、新浪、网易、腾讯等。 </p><h3 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h3><p>Internet Information Services(IIS，互联网信息服务)，是由微软公司提供的基 于运行 Microsoft Windows 的互联网基本服务。最初是 Windows NT 版本的可选包，随 后内置在 Windows 2000、Windows XP Professional 和 Windows Server 2003 一起发 行，但在 Windows XP Home 版本上并没有 IIS。 </p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器(Proxy Server)是一种重要的服务器安全功能，它的工作主要在 开放系统互联 (OSI) 模型的会话层，从而起到防火墙的作用。代理服务器大 多被用来连接 INTERNET(国际互联网)和 Local Area Network(局域网)。 </p><h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><p>• 数据库端缓存<br>• 应用层缓存<br>• 前端缓存<br>• 客户端缓存 </p><h2 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h2><p>当我们上线了我们的新功能的时候，这时候如果有个 Bug，那么我们是下线么?要 知道这个版本里面包含了很多的 Bug 修复。<br>Feature Toggle 它是一种允许控制线上功能开启或者关闭的方式 </p><h2 id="依赖与包仓库"><a href="#依赖与包仓库" class="headerlink" title="依赖与包仓库"></a>依赖与包仓库</h2><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="SEO-搜索引擎优化"><a href="#SEO-搜索引擎优化" class="headerlink" title="SEO 搜索引擎优化"></a>SEO 搜索引擎优化</h2><h2 id="分析工具-google-analytics"><a href="#分析工具-google-analytics" class="headerlink" title="分析工具 google analytics"></a>分析工具 google analytics</h2><h2 id="网站性能-Apdex联盟"><a href="#网站性能-Apdex联盟" class="headerlink" title="网站性能 Apdex联盟"></a>网站性能 Apdex联盟</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础知识篇&quot;&gt;&lt;a href=&quot;#基础知识篇&quot; class=&quot;headerlink&quot; title=&quot;基础知识篇&quot;&gt;&lt;/a&gt;基础知识篇&lt;/h1&gt;&lt;p&gt;环境是生产率的一部分。高效的程序员与低效的程序员间十倍的差距，至少有三倍是因为环境差异。&lt;br&gt;语言和开发软件都是工
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="全栈" scheme="https://github.com/zdkswd/tags/%E5%85%A8%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>[Linux内核设计与实现]中断与中断处理</title>
    <link href="https://github.com/zdkswd/2018/07/01/%E3%80%90Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%91%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/01/【Linux内核设计与实现】中断与中断处理/</id>
    <published>2018-07-01T11:37:32.000Z</published>
    <updated>2018-07-01T11:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Linux内核设计与实现】中断与中断处理"><a href="#【Linux内核设计与实现】中断与中断处理" class="headerlink" title="【Linux内核设计与实现】中断与中断处理"></a>【Linux内核设计与实现】中断与中断处理</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在Linux中，中断处理程序就是普普通通的C函数。</p><h2 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h2><p>把中断处理分为两部分。中断处理程序是上半部–接收到一个中断，就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部。</p><h2 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h2><p>中断处理程序是管理硬件的驱动程序的组成部分。每一设备都有相关的驱动程序，如果设备使用中断，则对应的驱动程序就注册一个中断处理程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【Linux内核设计与实现】中断与中断处理&quot;&gt;&lt;a href=&quot;#【Linux内核设计与实现】中断与中断处理&quot; class=&quot;headerlink&quot; title=&quot;【Linux内核设计与实现】中断与中断处理&quot;&gt;&lt;/a&gt;【Linux内核设计与实现】中断与中断处理&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="纸质书笔记" scheme="https://github.com/zdkswd/tags/%E7%BA%B8%E8%B4%A8%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters</title>
    <link href="https://github.com/zdkswd/2018/06/15/%E5%BC%95%E5%85%A5module%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98%20;%20AsyncTask%20;Make%20Clean%20Project;abiFilters/"/>
    <id>https://github.com/zdkswd/2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/</id>
    <published>2018-06-15T09:49:56.000Z</published>
    <updated>2018-06-15T03:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters"><a href="#引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters" class="headerlink" title="引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters"></a>引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters</h1><h2 id="import-module"><a href="#import-module" class="headerlink" title="import module"></a>import module</h2><p>在import module时，如果图标没有变化，不要忘了改setting.gradle</p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask,即异步任务,是Android给我们提供的一个处理异步任务的类.通过此类,可以实现UI线程和后台线程进行通讯,后台线程执行异步任务,并把结果返回给UI线程.</p><p><strong>AsyncTask</strong>&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个<strong>泛型参数</strong>:<br><strong>Params</strong>:启动任务时输入的参数类型.<br><strong>Progress</strong>:后台任务执行中返回进度值的类型.<br><strong>Result</strong>:后台任务执行完成后返回结果的类型.</p><p><strong>AsyncTask</strong>主要有如下几个<strong>方法</strong>:<br><strong>doInBackground</strong>:<strong>必须重写</strong>,异步执行后台线程要完成的任务,<strong>耗时操作将在此方法中完成</strong>.<br><strong>onPreExecute</strong>:执行后台耗时操作前被调用,通常用于进行初始化操作.<br><strong>onPostExecute</strong>:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.<br><strong>onProgressUpdate</strong>:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度.</p><h2 id="Make-Project-Clean-Project"><a href="#Make-Project-Clean-Project" class="headerlink" title="Make Project Clean Project"></a>Make Project Clean Project</h2><ol><li>Make Project：编译Project下所有Module，一般是自上次编译后Project下有更新的文件，不生成apk。</li><li>Make Selected Modules：编译指定的Module，一般是自上次编译后Module下有更新的文件，不生成apk。</li><li>Clean Project：删除之前编译后的编译文件，并重新编译整个Project，比较花费时间，不生成apk。</li><li>Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成apk，这里效果其实跟Clean Project是一致的，这个不知道Google搞什么鬼～～</li><li>Build APK：前面4个选项都是编译，没有生成apk文件，如果想生成apk，需要点击Build APK。</li><li>Generate Signed APK：生成有签名的apk。</li></ol><p>平时小的改动直接用Make Project就可以，可以看到只有它有快捷方式，表明这个功能要经常用。对于一些大的改动比如更新lib，大功能修改等，用Clean或Rebuild，毕竟这两个编译起来要费时间。<br>如果有的时候死活编译不过，多试试Clean吧，会有意想不到的效果！</p><h2 id="关于abiFilters的使用"><a href="#关于abiFilters的使用" class="headerlink" title="关于abiFilters的使用"></a>关于abiFilters的使用</h2><p>最近项目中遇到了要使用opencv的情况，涉及到了abi兼容的选择。因为如果全部都适配的话，包很大，这样兼容那些用户数极少的cpu就很不划算，所以我只适配了armeabi-v7a这一个。但是今天在x64-v8a的模拟器上看的时候，提示我的library.so文件找不到，我记得这个应该是向下兼容的，但是出现这种情况很奇怪，于是我就在网上找了找答案。<br>解决方法：abiFilters<br>在app的gradle的defaultConfig里面加上这么一句<br>ndk {<br>    abiFilters  “armeabi-v7a”  // 指定要ndk需要兼容的架构(这样其他依赖包里mips,x86,armeabi,arm-v8之类的so会被过滤掉)<br>}</p><p>这句话的意思就是指定ndk需要兼容的架构，把除了v7a以外的兼容包都过滤掉，只剩下一个v7a的文件夹。用了这个方法之后，确实解决了问题。这就是解决方法。<br>具体分析<br>其实这个方法我开始是很奇怪的，我明明没有指定其他的兼容框架，为什么会需要一个过滤。我打来了apk的包，找到了里面的lib目录，发现里面有很多的兼容目录，然后看到里面目录里面的是一个fresco的.so文件。也就是说，fresco做了各个平台的兼容，所以它创建了各个兼容平台的目录。因为只要出现了这个目录，系统就只会在这个目录里找.so文件而不会遍历其他的目录，所以就出现了之前找不到.so文件的情况（因为其他目录没有我的.so文件）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters&quot;&gt;&lt;a href=&quot;#引入module后的问题-AsyncTask-Make-Clean-Project-abiFilters&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="AndroidStudio" scheme="https://github.com/zdkswd/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>[Linux内核设计与实现]系统调用</title>
    <link href="https://github.com/zdkswd/2018/06/15/%5BLinux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://github.com/zdkswd/2018/06/15/[Linux内核设计与实现]系统调用/</id>
    <published>2018-06-15T03:53:32.000Z</published>
    <updated>2018-06-18T02:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核设计与实现-系统调用"><a href="#Linux内核设计与实现-系统调用" class="headerlink" title="[Linux内核设计与实现]系统调用"></a>[Linux内核设计与实现]系统调用</h1><p>内核提供接口让应用程序调用实现特定功能，避免应用程序肆意妄为。</p><h2 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h2><p>系统调用在用户空间进程和硬件设备间添加了一个中间层。</p><ol><li>提供硬件的抽象接口，即无需管磁盘类型，介质等问题。</li><li>保证系统的安全。</li><li>告知内核自己在使用硬件以实现多任务和虚拟内存。内核知道了才能更好的管理分配。<br><strong>系统调用是用户空间访问内核的唯一手段。</strong></li></ol><h2 id="API、POSIX、和C库"><a href="#API、POSIX、和C库" class="headerlink" title="API、POSIX、和C库"></a>API、POSIX、和C库</h2><p>用户程序在用户空间使用API进行编程。API可以实现零个，一个或多个系统调用。<br>UNIX世界中，最流行的应用程序接口是基于POSIX标准的。在大多数Unix上，根据POSIX定义的API函数和系统调用之间有着直接的关系。这个协议是对操作系统服务接口的标准化，从而保证了应用程序在源码层次的可移植性。<br>具体来说是应用程序调用API，API中包含有系统调用，调用内核。<br>程序员与API打交道，内核与系统调用打交道。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>要访问系统调用（在Linux中常称为syscall）,通常通过C库中定义的函数调用来进行。</p><h3 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h3><p>在Linux中，每个系统调用被赋予一个系统调用号。通过这个独一无二的号可以关联系统调用。<strong>系统调用号非常重要，</strong>一旦分配就不能变更，否则编译好的应用就会崩溃。Linux中的<strong>sys_ni_syscall()</strong>系统调用几乎不做任何操作，相当于白板儿，用来替代那些被删除的或不可用的系统调用。<br>内核用<strong>sys_call_table</strong>记录注册过的系统调用。</p><h3 id="系统调用的性能"><a href="#系统调用的性能" class="headerlink" title="系统调用的性能"></a>系统调用的性能</h3><p>Linux系统调用比其他操作系统执行的快。一是因为Linux有很短的上下文切换时间。二是系统调用处理程序和每个系统调用都很简洁。</p><h2 id="系统调用的处理程序"><a href="#系统调用的处理程序" class="headerlink" title="系统调用的处理程序"></a>系统调用的处理程序</h2><p>应用程序实际在API中调用的系统调用也并不是直接执行内核代码。应用程序以<strong>软中断</strong>的方式来通知系统执行一个系统的调用。通过引发异常来促使系统切换到内核态去执行异常处理程序。正是系统调用的处理程序。通过<strong>int$0x80</strong>指令触发中断。</p><h3 id="指定恰当的系统调用"><a href="#指定恰当的系统调用" class="headerlink" title="指定恰当的系统调用"></a>指定恰当的系统调用</h3><p><strong>系统调用号</strong>通过<strong>eax寄存器</strong>传递给内核。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>也可以通过寄存器进行参数的传递。</p><h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><h3 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h3><p>Unix格言<strong>提供机制而不是策略</strong>，当写一个系统调用时，要时刻注意可移植性和健壮性，还要为以后做打算。</p><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p>系统调用必须仔细检查参数是否合法有效最重要的检查是用户提供的指针知否有效。内核无论何时都不能轻率接受来自用户空间的指针。</p><h2 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h2><p>在Context中，内核可以休眠可以被抢占。</p><h3 id="绑定一个系统调用的最后步骤"><a href="#绑定一个系统调用的最后步骤" class="headerlink" title="绑定一个系统调用的最后步骤"></a>绑定一个系统调用的最后步骤</h3><h3 id="从用户空间访问系统调用"><a href="#从用户空间访问系统调用" class="headerlink" title="从用户空间访问系统调用"></a>从用户空间访问系统调用</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux内核设计与实现-系统调用&quot;&gt;&lt;a href=&quot;#Linux内核设计与实现-系统调用&quot; class=&quot;headerlink&quot; title=&quot;[Linux内核设计与实现]系统调用&quot;&gt;&lt;/a&gt;[Linux内核设计与实现]系统调用&lt;/h1&gt;&lt;p&gt;内核提供接口让应
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="纸质书笔记" scheme="https://github.com/zdkswd/tags/%E7%BA%B8%E8%B4%A8%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
</feed>
