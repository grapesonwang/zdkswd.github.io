<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-12-19T12:14:26.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP协议  SSL/TLS协议</title>
    <link href="https://github.com/zdkswd/2018/12/19/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/zdkswd/2018/12/19/HTTP协议  SSL:TLS协议/</id>
    <published>2018-12-19T12:12:47.000Z</published>
    <updated>2018-12-19T12:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门 - 阮一峰的网络日志</a><br>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p><h1 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.11.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.12.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>服务器发送完毕，就关闭TCP连接。</p><h1 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p><p>HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><p>下面是一个1.0版的HTTP请求的例子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.19.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。</p><h2 id="回应格式"><a href="#回应格式" class="headerlink" title="回应格式"></a>回应格式</h2><p>服务器的回应如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.21.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>回应的格式是”头信息 + 一个空行（ \ r \ n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p><h2 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h2><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。除了预定义的类型，厂商也可以自定义类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.27.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的类型表明，发送的是Debian系统的二进制数据包。<br>MIME type还可以在尾部使用分号，添加参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.28.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.34.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，客户端声明自己可以接受任何格式的数据。<br>MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.35.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h2><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.36.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.37.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.39.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.39.19%202.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h1 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h1><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.43.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h2><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h2 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h2><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.47.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用Content-Length字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.56.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.57.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.06.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h1 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h1><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p><h2 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h2><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h2 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h2><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个<strong>数据流</strong>（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h2 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h2><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><h1 id="SSL-TLS协议运行机制的概述"><a href="#SSL-TLS协议运行机制的概述" class="headerlink" title="SSL/TLS协议运行机制的概述"></a>SSL/TLS协议运行机制的概述</h1><p>互联网的通信安全，建立在SSL/TLS协议之上。<br>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.40.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.40.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p><strong>如何保证公钥不被篡改？</strong><br>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><p><strong>公钥加密计算量太大，如何减少耗用的时间？</strong><br>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p><p>因此，SSL/TLS协议的基本过程是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.51.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面过程的前两步，又称为”握手阶段”（handshake）。</p><p><strong>握手阶段的详细过程</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/bg2014020502.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。</p><p>第一步，<strong>客户端（通常是浏览器）先向服务器发出加密通信的请求</strong>，这被叫做<strong>ClientHello</strong>请求。在这一步，客户端主要向服务器提供以下信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.55.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p><p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p><p>第二步，<strong>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.59.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p><p>第三步，<strong>客户端回应</strong>。客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%888.04.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>至于为什么一定要用三个随机数，来生成”会话密钥”<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%888.07.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><p>第四步，<strong>服务器的最后回应</strong>，服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%888.08.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/08/http.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 协议入门 - 阮一峰的网络日志&lt;/a&gt;&lt;br&gt;HTTP 协议是互联网的基础协议，
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>互联网协议复习</title>
    <link href="https://github.com/zdkswd/2018/12/19/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/"/>
    <id>https://github.com/zdkswd/2018/12/19/互联网协议复习/</id>
    <published>2018-12-19T11:55:47.000Z</published>
    <updated>2018-12-19T09:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p><h1 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052902.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h1><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p>这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h1 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p><h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052904.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>一块网卡怎么会知道另一块网卡的MAC地址？有一种ARP协议，可以解决这个问题。</p><p>有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052907.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的由来"><a href="#网络层的由来" class="headerlink" title="网络层的由来"></a>网络层的由来</h2><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052914.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，<strong>使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p><p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052908.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”<strong>子网掩码</strong>“（subnet mask）。</p><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><h2 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h2><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为”标头”和”数据”两个部分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052909.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052910.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。</p><p>我们需要一种机制，能够从IP地址得到MAC地址。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层的由来"><a href="#传输层的由来" class="headerlink" title="传输层的由来"></a>传输层的由来</h2><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”标头”和”数据”两部分组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052911.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052912.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p>“应用层”的作用，就是规定应用程序的数据格式。</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052913.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="网关转发"><a href="#网关转发" class="headerlink" title="网关转发"></a>网关转发</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061101.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是，于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%889.55.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。</strong></p><h1 id="用户的上网设置"><a href="#用户的上网设置" class="headerlink" title="用户的上网设置"></a>用户的上网设置</h1><h2 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a>静态IP地址</h2><p>一个电脑想要上网需要填入以下的内容：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%885.22.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p><p>这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p><h2 id="动态IP地址"><a href="#动态IP地址" class="headerlink" title="动态IP地址"></a>动态IP地址</h2><p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做<strong>DHCP协议</strong>。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p>如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定。</p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>首先，它是一种<strong>应用层协议</strong>，建立在UDP协议之上，所以整个数据包是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061102.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。<br>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。<br>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><h1 id="访问网页"><a href="#访问网页" class="headerlink" title="访问网页"></a>访问网页</h1><h2 id="本机参数"><a href="#本机参数" class="headerlink" title="本机参数"></a>本机参数</h2><p>假定用户设置好了网络参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%885.32.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>想要访问Google，在地址栏输入了网址：<a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a><br>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a href="http://www.google.com，不知道它的IP地址。" target="_blank" rel="noopener">www.google.com，不知道它的IP地址。</a></p><p><strong>DNS协议</strong>可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061105.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061106.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>HTTP部分的内容，类似于下面这样：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%885.39.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><h2 id="TCP协议-1"><a href="#TCP协议-1" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h2 id="IP协议-1"><a href="#IP协议-1" class="headerlink" title="IP协议"></a>IP协议</h2><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><h2 id="以太网协议-1"><a href="#以太网协议-1" class="headerlink" title="以太网协议"></a>以太网协议</h2><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061107.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a>服务器端响应</h2><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyif
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C C++程序的构筑过程</title>
    <link href="https://github.com/zdkswd/2018/12/18/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/12/18/C C++程序的构筑过程/</id>
    <published>2018-12-18T10:13:56.000Z</published>
    <updated>2018-12-18T10:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-程序的构筑过程"><a href="#C-C-程序的构筑过程" class="headerlink" title="C C++程序的构筑过程"></a>C C++程序的构筑过程</h1><p>参考：<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a><br>源码要运行，必须先转成二进制的机器码。这是编译器的任务。<br>如源码test.c<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.21.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要编译器处理一下才能运行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.23.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于复杂的项目，编译过程还必须分成三步。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.23.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/bg2014110803.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="第一步-配置（configure）"><a href="#第一步-配置（configure）" class="headerlink" title="第一步 配置（configure）"></a>第一步 配置（configure）</h2><p>编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。</p><p>这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。</p><p>configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。</p><h2 id="第二步-确定标准库和头文件的位置"><a href="#第二步-确定标准库和头文件的位置" class="headerlink" title="第二步 确定标准库和头文件的位置"></a>第二步 确定标准库和头文件的位置</h2><p>源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。</p><p>编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</p><h2 id="第三步-确定依赖关系"><a href="#第三步-确定依赖关系" class="headerlink" title="第三步 确定依赖关系"></a>第三步 确定依赖关系</h2><p>对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.35.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。</p><p>在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。</p><h2 id="第四步-头文件的预编译"><a href="#第四步-头文件的预编译" class="headerlink" title="第四步 头文件的预编译"></a>第四步 头文件的预编译</h2><p>不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。</p><p>不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。</p><h2 id="第五步-预处理（Preprocessing）"><a href="#第五步-预处理（Preprocessing）" class="headerlink" title="第五步 预处理（Preprocessing）"></a>第五步 预处理（Preprocessing）</h2><p>预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.41.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。</p><p>这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。</p><h2 id="第六步-编译（Compilation）"><a href="#第六步-编译（Compilation）" class="headerlink" title="第六步 编译（Compilation）"></a>第六步 编译（Compilation）</h2><p>预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。</p><p>下面是本文开头的那段源码转成的汇编码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.42.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种转码后的文件称为对象文件（object file）。</p><h2 id="第七步-连接（Linking）"><a href="#第七步-连接（Linking）" class="headerlink" title="第七步 连接（Linking）"></a>第七步 连接（Linking）</h2><p>对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。</p><p>编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。</p><p>make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。</p><h2 id="第八步-安装（Installation）"><a href="#第八步-安装（Installation）" class="headerlink" title="第八步 安装（Installation）"></a>第八步 安装（Installation）</h2><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。</p><p>表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。</p><h2 id="第九步-操作系统连接"><a href="#第九步-操作系统连接" class="headerlink" title="第九步 操作系统连接"></a>第九步 操作系统连接</h2><p>可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。</p><p>这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在 / usr/ share/ applications目录下的.desktop文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。</p><p>这些事情就叫做”操作系统连接”。make install命令，就用来完成”安装”和”操作系统连接”这两步。</p><h2 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h2><p>写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。</p><p>所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。</p><h2 id="动态连接（Dynamic-linking）"><a href="#动态连接（Dynamic-linking）" class="headerlink" title="动态连接（Dynamic linking）"></a>动态连接（Dynamic linking）</h2><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。</p><p>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。</p><p>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-C-程序的构筑过程&quot;&gt;&lt;a href=&quot;#C-C-程序的构筑过程&quot; class=&quot;headerlink&quot; title=&quot;C C++程序的构筑过程&quot;&gt;&lt;/a&gt;C C++程序的构筑过程&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;http://www.ruanyifen
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 函数 内存 名称空间</title>
    <link href="https://github.com/zdkswd/2018/12/18/C++%20Primer%20%E5%87%BD%E6%95%B0%20%E5%86%85%E5%AD%98%20%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/"/>
    <id>https://github.com/zdkswd/2018/12/18/C++ Primer 函数 内存 名称空间/</id>
    <published>2018-12-18T07:07:56.000Z</published>
    <updated>2018-12-18T07:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>定义函数:</strong><br>分为有返回值函数和无返回值函数。<br>void：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%888.56.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有返回值：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%889.00.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C++对于返回值的类型有一定的限制:不能是数组，但可以是其他任何类型，如整数、浮点数、指针，甚至可以是结构和对象(有趣的是，虽然C++函数不能直接返回数组，但可以将数组作为结构或对象组成部分来返回)。</p><p>通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。<br> <strong>函数原型和函数调用</strong><br> <strong>为什么需要原型:</strong><br>原型描述了函数到编译器的接口，即，将函数的返回值类型（如果有的话）以及参数的类型和数量告诉编译器。<br> <strong>原型的句法:</strong><br>函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.36.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在函数原型中不要求提供变量名，有类型列表就足够了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.37.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。<br><strong>原型的功能:</strong><br>原型可以帮助编译器完成许多工作，可以极大地降低程序出错的几率，具体说，原型确保：</p><ol><li>编译器正确处理函数返回值。</li><li>编译器检查使用的参数数目是否正确。</li><li>编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型（如果可能的话）。</li></ol><p>静态类型检查可捕获许多在运行阶段非常难以捕获的错误。</p><h2 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h2><p>C++使用参数（argument）来表示实参，使用参量（parameter）来表示形参。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.54.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.07.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。arr实际上并不是数组，而是一个指针。在编写函数的其余部分时，可以将arr看作是数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.09.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中使用int <em> arr 替换了int arr [] 。这证明这两个函数头都是正确的，因为在C++中，当(且仅当)用于函数头或函数原型中，int </em> arr 和int arr[ ]的含义才是相同的。它们都意味着arr是一个int指针。不过，数组表示法(int arr[]) 提醒用户，arr 不仅指向int, 还指向int数组的第一个int。当指针指向数组的第一个元素时， 本书使用数组表示法;而当指针指向一个独立的值时，使用指针表示法。 别忘了，在其他的上下文中，int * arr和int arr[]的含义并不相同。例如， 不能在函数体中使用int tip[ ]来声明指针。<br>两个恒等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.14.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型长度相等的值。对于遍历数组而言，使用指针加法和数组下标是等效的。</p><h3 id="将数组作为参数意味着什么"><a href="#将数组作为参数意味着什么" class="headerlink" title="将数组作为参数意味着什么"></a>将数组作为参数意味着什么</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.21.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将数组地址作为参数可以节省复制整个数组所需的时间和内存。 如果数组很大，则使用拷贝的系统开销将非常大;程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。可以使用const来解决这个问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.25.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h3><p>对于处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C、C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供了找到所有数据所需的信息。</p><p>还有另一种给两数提供所需信息的方法，即指定元素区间(range), 这可以通过传递两个指针来完成:一个指针标识数组的开头，另一个指针标识数组的尾部。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>可以用两种不同的方式将const用于指针。第一种是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值。第二种是将指针本身声明为常量，这样可以防止改变指针指向的位置。<br>指向常量的指针pt:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.51.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt 指向age, 而age不是const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它。</p><p>可以将const变量的地址赋给指向const的指针，但不能将const地址赋给常规指针。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.56.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.03.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上述函数调用试图将const指针赋给非const指针，编译器将禁止这种函数调用。</p><p>第二种使用const的方式使得无法修改指针的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.12.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>关键字const的位置与之前不同。这种声明格式使得finger只能指向sloth,但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。</p><h2 id="函数和二维数组"><a href="#函数和二维数组" class="headerlink" title="函数和二维数组"></a>函数和二维数组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.25.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>data是一个数组名，该数组有3个元素。每个元素都是数组，由4个int值组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.22.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="函数和C-风格字符串"><a href="#函数和C-风格字符串" class="headerlink" title="函数和C-风格字符串"></a>函数和C-风格字符串</h2><h3 id="将c-风格字符串作为参数的函数"><a href="#将c-风格字符串作为参数的函数" class="headerlink" title="将c-风格字符串作为参数的函数"></a>将c-风格字符串作为参数的函数</h3><p>假设要将字符串作为参数传递给函数，表示字符串的方式有3种：</p><ol><li>char数组。</li><li>用引号括起的字符串常量。</li><li>被设置为字符串的地址的char指针</li></ol><p>3种选择的类型都是char指针（即char <em> ），可将其作为字符串处理函数的参数。字符串函数原型应将其表示字符串的形参声明为char </em> 指针。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.31.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="返回C-风格字符串的函数"><a href="#返回C-风格字符串的函数" class="headerlink" title="返回C-风格字符串的函数"></a>返回C-风格字符串的函数</h3><p>函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。</p><p>要创建包含n个字符的字符串，需要能够存储n+1个字符的空间，以便能够存储空值字符。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>分为以下三个步骤。</p><h3 id="获取函数地址"><a href="#获取函数地址" class="headerlink" title="获取函数地址"></a>获取函数地址</h3><p>获取函数的地址很简单，只要使用函数名（后面不跟参数）即可。一定要区分传递的是函数的地址还是函数的返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.06.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="声明函数指针"><a href="#声明函数指针" class="headerlink" title="声明函数指针"></a>声明函数指针</h3><p>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.10.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>提示:通常，要声明指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用( * pf)替换函数名，这样pf就是这类函数的指针。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.15.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>正确地声明pf后，便可以将对应函数的地址赋给它：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.17.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用指针来调用函数"><a href="#使用指针来调用函数" class="headerlink" title="使用指针来调用函数"></a>使用指针来调用函数</h3><p>使用指针来调用被指向的函数。（ <em> pf）扮演的角色与函数名相同，因此使用（ </em> pf）时，只需将它看做函数名即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.24.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C++进行了折衷，这2种方式都是正确的。</p><h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><p>内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。</p><p>内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，然后再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数的10个代码拷贝。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.40.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要使用这项特性，必须采用下述措施之一：</p><ol><li>在函数声明前加关键字inline。</li><li>在函数定义前加上关键字inline。</li></ol><p>程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己(内联函数不能递归)，因此不将其作为内联函数;而有些编译器没有启用或实现这种特性。</p><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>C和C++使用&amp;符号来指示变量的地址。C++给&amp;符号赋了了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.00.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中,  &amp; 不是地址操作符，而是类型标识符的一部分。就像声明中的char * 指的是指向char的指针一样,int  &amp; 指的是指向int的引用。</p><p>看似引用和指针用法很类似，其实是有差别的，差别之一是，必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.05.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>引用更接近const指针，鼻血在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.18.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.39.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="引用的属性和特别之处"><a href="#引用的属性和特别之处" class="headerlink" title="引用的属性和特别之处"></a>引用的属性和特别之处</h3><h4 id="临时变量、引用参数和const"><a href="#临时变量、引用参数和const" class="headerlink" title="临时变量、引用参数和const"></a>临时变量、引用参数和const</h4><p>如果实参与引用参数不匹配，C++将生成临时变量。仅当参数为const引用时，C++才允许这样做。</p><p>如果引用参数时const，则编译器将在下面两种情况下生成临时变量：</p><ol><li>实参的类型正确，但不是左值。</li><li>实参的类型不正确，但可以转换为正确的类型。</li></ol><p>左值参数时可被引用的数据对象，例如，变量、数组元素、结构成员、引用和被解除引用的指针都是左值。非左值包括字面常量和包含多项的表达式。</p><p>记住:如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p><h3 id="应尽可能使用const"><a href="#应尽可能使用const" class="headerlink" title="应尽可能使用const"></a>应尽可能使用const</h3><p>将引用参数声明为常量数据的引用的理由有3个:</p><ol><li>使用const可以避免无意中修改数据的编程错误。</li><li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据。</li><li>使用const引用使函数能够正确生成并使用临时变量。</li></ol><p>因此，应尽可能将引用形参声明为const。</p><h3 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>引用非常适合用于结构和类(C++的用户定义类型).确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。</p><h3 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h3><p>使用引用参数的主要原因有两个：</p><ol><li>程序员能够修改调用函数的数据对象。</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li></ol><p>当数据对象较大时(如结构和类对象),第二个原因最重要。这些也是使用指针参数的原因。这是有道理的,因为引用参数实际上是基于指针的代码的另一个接口。</p><p>指导原则<br>对于使用传递的值而不作修改的函数:</p><ol><li>如果数据对象很小,如内置数据类型或小型结构,则按值传递。</li><li>如果数据对象是数组,则使用指针,因为这是惟一的选择,并将指针声明为指向 const的指针。</li><li>如果数据对象是较大的结构,则使用 const指针或 const引用,以提高程序的效率。这样可以节省复制结构所需的时间和空间。</li><li>如果数据对象是类对象,则使用 const引用。类设计的语义常常要求使用引用,这是C+新增这项特性的主要原因。因此,传递类对象参数的标准方式是按引用传递。</li></ol><p>对于修改调用函数中数据的函数。</p><ol><li>如果数据对象是内置数据类型，则使用指针。</li><li>如果数据对象是数组，则只能使用指针。</li><li>如果数据对象是结构， 则使用引用或指针。</li><li>如果数据对象是类对象，则使用引用。</li></ol><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边所有的参数提供默认值：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.40.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>实参按从左到右的顺序依次被賦给相应的形参，而不能跳过任何参数。下面的调用是不允许的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.43.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认参数不是编程方面的重大突破，而只是提供了一种便捷的方式。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>所数重载的关键是函数的参数列表一也称为函数特 征标( function signature). 如果两个函数的参数数目和类型相同， 同时参数的排列顺序也相同，则它们的特征标相同， 而变量名是无关紧要的。C++ 允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和或参数类型不同，则特征标也不同。</p><p>一些看起来彼此不同的特征标是不能共存的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.15.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为避免混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。</p><h3 id="何时使用函数重载"><a href="#何时使用函数重载" class="headerlink" title="何时使用函数重载"></a>何时使用函数重载</h3><p>函数重载很吸引人，但也不能滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时才应采用函数重载。</p><p>使用一个带默认参数的函数要简单些。只需编写一个函数(而不是两个函数)，程序也只需为一个函数(而不是两个)请求内存:需要修改函数时，只需修改一个。不过，如果需要使用不同类型的参数时，则默认参数便不管用了， 在这种情况下，应该使用函数重载。</p><h3 id="名称修饰"><a href="#名称修饰" class="headerlink" title="名称修饰"></a>名称修饰</h3><p>使用C++开发工具中的编辑器编写和编译程序时，C++将执行一些神奇的操作，名称修饰或名称矫正。根据函数原型中指定的形参类型对每个函数名进行加密。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板是通用的函数描述，就是使用通用类型来定义函数，其中的通用类型可用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.44.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>建立一个模板，将类型命名为Any。关键字template和class是必需的，类型名可以任意选择。关键字typename可用来替换关键字class，就是说可以编写模板定义：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.46.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>提示: 如果需要多个将同一种算法用于不同类型的函数，请使用模板，如果不考虑向后兼容的问题，并愿意键入较长的单词, 则声明类型参数时，应使用关键字typename而不使用class。</strong></p><h3 id="重载的模板"><a href="#重载的模板" class="headerlink" title="重载的模板"></a>重载的模板</h3><p>需要多个对不同类型使用同一种算法的函数时，可使用模板。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.54.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h3><p>在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。模板并非函数定义，但使用int的模板实例是函数定义。这种实例化方式被称为隐式实例化，因为编译器之所以知道需要进行定义，是由于程序调用Swap（）函数时提供了int参数。</p><p>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，C++还允许显示实例化。这意味着可以直接命令编译器创建特定的实例，Swap<int>()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.26.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>显示具体化使用下面两个等价声明之一：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.40.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>显示具体化声明在关键字Template后包含&lt;&gt;，而显式实例化没有。</int></p><p><strong>警告：视图在同一个编程单元中使用同一类型的显示实例和显示具体化将出错。</strong></p><p>隐式实例化、显式实例化和显式具体化统称为具体化(specialization)。 它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。</p><h1 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h1><p>C++为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据（作用域和链接）等。可以使用new来动态地分配内存而布局new操作符提供了这种技术的一种变种。C++名称空间是另一种控制访问权的方式。通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据。这样的程序涉及到程序文件的单独编译。</p><h2 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h2><p>和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。 可以单独编译这些文件，然后将它们链接成可执行的程序(通常，C++编译器既编译程序，也管理链接器)。,如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。另外，大多数C++环境都提供了其他工具来帮助管理。例如，UNIX和Linux系统都具有make程序， 可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序所需的步骤。</p><p>可以将原来的程序分为三部分：</p><ol><li>头文件：包含结构声明和使用这些结构的函数的原型</li><li>源代码文件：包含与结构有关的函数的代码。</li><li>源代码文件：包含调用与结构相关的函数的代码。</li></ol><p>不要将函数定义或变量声明放到头文件中。例如，如果在头文件包含—个函数定义，然后在其他两个文件(属于同一个程序)中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数是内联的， 否则这将出错。</p><p>下面列出了头文件中常包含的内容:</p><ol><li>函数原型</li><li>使用# define或const定义的符号常量</li><li>结构声明</li><li>类声明</li><li>模板声明</li><li>内联函数</li></ol><p>模板声明不是将被编译的代码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。被声明为const的数据和内联函数有特殊的链接属性，因此可将其放在头文件而不会引起问题。</p><p>注意，在包含头文件时，<br>我们使用“coordin.h”,而不是&lt; coodin.h &gt;。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找:但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录(或其他目录，这取决于编译器)。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用引号而不是尖括号。</p><p>在IDE中，不要将头文件加入到工程列表中，也不要在源代码文件中使用# include 来包含其他源代码文件。</p><h3 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h3><p>在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。例如， 可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef(即if not defined)的。下面的代码片段:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8810.57.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>意味着仅当以前没有使用预处理器编译指令# define定义名称COORDIN_H_时，才处理# ifndef和# endif之间的语句。</p><p>通常，使用# define语句来创建符号常量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但只要将# define用于名称，就足以完成该名称的定义。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>编译器首次遇到该文件时，名称COORDIN_H_没有定义（我们根据include文件名来选择名称，并加一些下划线，以创建一个在其他地方不太可能被定义的名称）。如果在同一个文件中遇到其他包含coordin.h的代码，编译器将知道COORDIN_H_已经被定义了，从而跳到# endif后面的一行上。这种方法并不能防止编译器将文件包含两次，而只是让它忽略了第一次包含之外的所有内容。大多数标准C和C++头文件都使用这种防护(guarding)方案。</p><h2 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h2><h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的名称，可在文件间共享，连接性为内部的名称，只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它不能共享。</p><h3 id="作用域和链接"><a href="#作用域和链接" class="headerlink" title="作用域和链接"></a>作用域和链接</h3><p>作用域（scope）描述了名称在文件的多大范围内可见。链接性(linkage) 描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。</p><h3 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h3><p>在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动， 作用域为局部，没有链接性。当程序开始执行这些变量所属的代码块时，将为其分配<br>内存;当函数结束时，这些变量都将消失(注意，执行到代码块时，将为变量分配内存， 但其作用域的起点为其声明位置)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.50.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以使用C++ (和C)关键字auto 来显式地指出存储类别:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.52.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="自动变量和堆栈"><a href="#自动变量和堆栈" class="headerlink" title="自动变量和堆栈"></a>自动变量和堆栈</h4><p>由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。常用的方法是<strong>留出一段内存，并将其视为堆栈</strong>，以管理变量的增减。之所以被称为堆栈，是由于新数据被象征性地放在原有数据的上面(也就是说，在相邻的内存单元中，而不是在同一个内存单元中)，当程序使用完后，将其从堆栈中删除。堆栈的默认长度取决于实现，但编译器通常提供改变堆栈长度的选项。程序使用两个指针来跟踪堆栈，一个指针指向栈底即堆栈的开始位置，另一个指针指向堆顶即下一个可用内存单元。当函数被调用时，其自动变量将被加入到堆栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p><p>堆栈是后进先出的，即最后加入到堆栈中的变量首先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.05.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以说形参存在于堆栈。堆栈是内存留出的一小段。</p><h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>和C语言一样，C++也支持使用register关键字来声明局部变量。寄存器变量是另一种形式的自动变量，因此其存储持续性为自动，作用域为局部，但没有链接性。关键字register提醒编译器，用户希望它通过使用CPU寄存器，而不是堆栈来处理特定的变量，从而提供对变量的快速访问。这里的理念是，CPU访问寄存器中的值的速度比访问堆栈中内存快。要声明寄存器变量，请在类型前加上关键字register:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.11.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>现代编译器已经足够聪明，在编写for循环时，编译器可能自动使用寄存器来存储循环计数。</p><p>如果变量被存储在寄存器则没有内存地址，因此不能讲地址操作符用于寄存器变量。</p><p>简而言之，常规局部变量、使用auto 声明的局部变量以及使用register 声明的局部变量的存储持续性都是自动的， 作用域都是局部的，也都没有链接性。</p><p>声明局部变量时，如果没有使用说明符，则与使用auto声明变量等效。通常， 处理这种变量的方式是将其放置到内存堆栈中。使用register说明符指出该变量将被频繁使用，编译器可能会选择使用内存堆栈之外的其他方式(如使用CPU寄存器)来存储它。</p><h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><p>和C语言一样，C++也为静态存储持续性变量提供了3种链接性:外部链接性、内部链接性和无链接性。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置(如堆栈)来管理它们。<strong>编译器将分配固定的内存块来存储所有的静态变量</strong>，<strong>这些变量在整个程序执行期间一直存在</strong>。另外， 如果没有显式地初始化静态变量，编译器就将把它<strong>设置为0</strong>。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。</p><p>要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它; 要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符:要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所有静态持续变量在整个程序执行期间都存在。在funct1（）中声明的变量count的作用域为局部，没有链接性，这意味着只能在funct1（）函数中使用它，就像自动变量一样，但不同之处在于，即使函数没有执行时，count也留在内存中。global和one_file的作用域为整个文件，即在从声明位置到文件结尾的范围内都可以被使用。由于one_file的链接性为内部，因此只能在包含上述代码的文件中；由于global的链接性为外部，因此可以在程序的其他文件中使用它。</p><p>所有静态持续变量只能使用常量表达式来初始化静态变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.54.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言都是外部的。外部变量也称为全局变量。如果定义了与外部变量同名的自动变量，该自动变量将隐藏同名的外部变量。</p><p>关键字extern的意思是“通过以前被外部定义的名称使用该变量”。外部变量声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.12.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>称为定义声明，给该变量分配存储空间。重新声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.13.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>称为引用声明，或简称为声明。它不给变量分配存储空间，因为它引用已有的变量。只能在引用其他地方（或函数）定义的变量的声明中使用关键字extern。当试图赋值时将会报错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>仅当声明将为变量分配存储空间时（即定义声明），才能在声明中初始化变量。毕竟，初始化指的是在分配内存单元时给它赋值。</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>过多使用全局变量会破坏数据的完整性，外部存储尤其适于表示常量数据，因为这样可以使用关键字const来防止数据被修改。</p><h3 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h3><p>对于外部链接变量，有且只有一个文件中包含了该变量的外部定义，其他文件要使用该变量，必须在引用声明中使用关键字extern。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果文件试图定义另一个同名的外部变量将出错：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.39.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="静态存储持续性、无连接性"><a href="#静态存储持续性、无连接性" class="headerlink" title="静态存储持续性、无连接性"></a>静态存储持续性、无连接性</h3><p>如果初始化了静态局部变量，则程序只在启动时进行一次初始化，以后再调用函数时，将不会像自动变量那样再次被初始化。</p><h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><p>存储说明符：</p><ol><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li></ol><p>在同一个声明中不能使用多个说明符。mutable 是为了突破 const 的限制而设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态，即使是 const 函数中也可以改变这个变量的值。</p><p>cv限定符：</p><ol><li>const</li><li>volatile(易变的，不稳定的)</li></ol><p><strong>volatile</strong>关键字表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。听起来似乎很神秘，实际上并非如此。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。在这种情况下，硬件(而不是程序)可能修改其中的内容。或者两个程序可能互相影响，共享数据。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile, 则编译器将进行这种优化;将变量声明为volatile,相当于告诉编译器，不要进行这种优化。避免出现和想象结果不一致的情况。</p><h3 id="再谈const"><a href="#再谈const" class="headerlink" title="再谈const"></a>再谈const</h3><p>在C++中，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，在C++看来， 全局const定义就像使用了static说明符一样。（就链接性而言）</p><p>内部链接还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量。每个定义都是共所属文件私有的，这就是能够将常量定义放在头文件中的原因。这样，只要在两个源代码文件中包括同一个头文件，则它们将获得同一组常量。</p><p>如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.09.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种情况下，必须在所有使用该常量的文件中使用extem关键字来声明它。这与常规外部变量不同，定义常规外部变量时，不必使用extem关键字，但在使用该变量的其他文件中必须使用extem。</p><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><p>C++不允许在一个函数中定义另一个函数，因此所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。可以在函数原型中使用关键字extern来指出函数时再另一个文件中定义的，不过这是可选的（要让程序在另一个文件中查找函数， 该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件)。还可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义汇总使用该关键字。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.31.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这意味着该函数以在这个文件中可见，还意味着可以在其他文件中定义同名的的函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。</p><p>C++有一个“单定义规则”，即对于每个非内联函数，程序中只能包含一个定义。对于链接性为外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。</p><p>内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定义。不过，C++要求同一个函数的所有内联定义都必须相同。</p><h3 id="C-在哪里查找函数"><a href="#C-在哪里查找函数" class="headerlink" title="C++在哪里查找函数"></a>C++在哪里查找函数</h3><p>如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义;否则， 编译器(包括链接程序)将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。<br>如果在程序文件中没有找到， 编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数， 编译器将使用程序员定义的版本， 而不是库函数(不过，C++保留了标准库函数的名称，即程序员不应使用它们).一些编译器-链接程序要求显式地指出要搜索哪些库。</p><h3 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h3><p>另一种形式的链接性称为语言链接性，也对函数有影响。链接程序要求每个不同的函数都有不同的符号名。在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。例如， 可能将spiff (int)转换为_spof_i,而将spiff (double, double) 转换为_spif_d_d.这种方法被称为C++语言链接(C++ language linkage)。</p><p>链接程序寻找与C++函数调用匹配的函数时，使用的方法与c语言不同。但如果要在c++程序中使用C库中预编译的兩数，将出现什么情况呢?例如，假设有下面的代码:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.53.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它在C库文件中的符号名称为_spif, 但对于我们假设的链接程序来说，C++查询约定是查找符号名称<em>spiff</em> i。为解决这种问题，可以用函数原型来指出要使用的约定:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.54.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第个原型使用C语言链接性:而后面的两个使用C+语言链接性。第二个原型是通过默认方式指出这一点的，而第三个显式地指出了这一点。</p><h3 id="存储方案和动态分配"><a href="#存储方案和动态分配" class="headerlink" title="存储方案和动态分配"></a>存储方案和动态分配</h3><p>与自动内存不同，动态内存不是LIFO,其分配和释放顺序要取决于new和delete 在何时以何种方式被使用。通常，<strong>编译器使用3块独立的内存:一块用于静态变量(可能再细分)，一块用于自动变量， 另外一块用于动态存储。</strong></p><p>如果将p_fees的链接性声明为外部的，则文件中位于该声明后面的所有函数都<br>可以使用它。另外，通过在另一个文件中使用：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.13.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以在这个文件中使用该指针。不过，请注意， 使用new来设置p_ fees 的语句必须位于函数中(如下面的代码段所示)，这是因为只能使用常量表达式来初始化静态存储变量:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.14.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.15.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注意: 在程序结束时，由new分配的内存通常都将被释放，不过情况也并不总是这样。例如,在不那么健壮的操作系统中，在某些情况下，请求大型内存块将导致该代码块在程序结束不会被自动释放。最佳的做法是， 使用delete 来释放new分配的内存。</strong></p><h2 id="布局new操作符"><a href="#布局new操作符" class="headerlink" title="布局new操作符"></a>布局new操作符</h2><p>new负责在<strong>堆(heap)</strong> 中找到一个足以能够满足要求的内存块。new操作符还有另一种变体，被称为布局(placement)new操作符，它能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程或处理需要通过特定地址进行访问的硬件。要使用布局new特性，首先需要包含头文件new。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.25.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它提供了new操作符原型，下面是new操作符的四种用法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.26.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中如果buffer是静态存储区，那么就new到了静态存储区。而常规new就到了动态管理的堆中。</p><p>由于buffer指定的内存是静态内存，而delete只能指向常规new操作符分配的堆内存，就是说数组buffer位于delete的管辖区域之外。</p><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>当随着工程的增大，名称相互冲突的可能性也将增加。使用多个厂商的类库时，可能导致名称冲突。C++标准提供了名称空间工具，以便更好地控制名称的作用域。</p><h3 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h3><p>几个概念：<br><strong>声明区域</strong>(declaration region)。 声明区域是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块。</p><p><strong>潜在作用域</strong>。变量的潜在作用域从声明点开始,到其声明域的结尾。因此潜在作用域比声明区域小,这是由于变量必须定义后才能使用。</p><h3 id="新的名称空间特性"><a href="#新的名称空间特性" class="headerlink" title="新的名称空间特性"></a>新的名称空间特性</h3><p>C++新增了这样一种功能,即通过定义一种新的声明区域来创建命名的名称空间,这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突,同时允许程序的其他部分使用该名称空间中声明的东西。例如,下面的代码使用新的关键字 namespace创建了两个名称空间:Jack和Jill。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.09.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>名称空间可以是全局的,也可以位于另一个名称空间中,但不能位于代码块中。因此,在默认情况下,在名称空间中声明的名称的链接性为外部的(除非它引用了常量)</p><p>除了用户定义的名称空间外，还存在另一个名称空间一全局名称空间(global namespace)。 它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。</p><p>任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。</p><p>当然, 需要有一种方法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析操作符::,使用名称空间来限定该名称。未被装饰的名称(如pail)被称为未限定的名称(unqualifed name);包含名称空间的名称(如Jack;pail)被称为限定的名称(qualified name).</p><h4 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h4><p>如果不希望每次使用名称都使用：：，C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。using声明使特定的表示符可用，using编译指令使整个名称空间可用。</p><p>using声明由限定的名称和它前面的关键字using组成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.24.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>using编译命令使所有的名称都可用。using编译命令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析操作符：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.32.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="using编译指令和using声明值比较"><a href="#using编译指令和using声明值比较" class="headerlink" title="using编译指令和using声明值比较"></a>using编译指令和using声明值比较</h4><p>使用using编译指令导入一个名称空间中所有的名称与使用using声明是不一样的，而更像是大量使用作用域解析操作符。使用 using声明时,就好像声明了相应的名称一样。如果某个名称已经在函数中声明了,则不能用 using声明导入相同的名称。然而,使用 using编译指令时,将进行名称解析,就像在包含 using声明和名称空间本身的最小声明区域中声明了名称一样。在下面的范例中,名称空间为全局的。如果使用 using编译指令导入一个已经在函数中声明的名称,则局部名称将隐藏名称空间名,就像隐藏同名的全局变量样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.11.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一般来说，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p><h4 id="名称空间的其他特性"><a href="#名称空间的其他特性" class="headerlink" title="名称空间的其他特性"></a>名称空间的其他特性</h4><p>可以将名称空间声明进行嵌套。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.39.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里flame指的是element:: fire  ::flame。</p><h4 id="未命名的名称空间"><a href="#未命名的名称空间" class="headerlink" title="未命名的名称空间"></a>未命名的名称空间</h4><p>可以通过省略名称空间的名称来创建未命名的名称空间：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.48.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不能再未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称，因此这种方法可以替代链接性为内部的静态变量。</p><h3 id="名称空间的指导原则"><a href="#名称空间的指导原则" class="headerlink" title="名称空间的指导原则"></a>名称空间的指导原则</h3><ol><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li><li>如果开发了一个函数库或类库，将其放在一个名称空间中。</li><li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。（其实若冲突IDE中会报含糊不清错误）</li><li>不要在头文件中使用using 编译指令。首先，这样做掩盖了要让哪些名称可用;另外， 包含头文件的顺序可能影响程序的行为。 如果非要使用编译指令using,应将其放在所有预处理器编译指令#include之后。</li><li>导入名称时， 首选使用作用域解析操作符或using声明的方法。</li><li>对于using声明，首选将其作用域设置为局部而不是全局。</li></ol><p>对于简单程序，使用using编译指令并非什么大逆不道的事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义函数:&lt;/strong&gt;&lt;br&gt;分为有返回值函数和无返回值函数。&lt;br&gt;void：&lt;br&gt;&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 数据 语句</title>
    <link href="https://github.com/zdkswd/2018/12/18/C++%20Primer%20%E6%95%B0%E6%8D%AE%20%E8%AF%AD%E5%8F%A5/"/>
    <id>https://github.com/zdkswd/2018/12/18/C++ Primer 数据 语句/</id>
    <published>2018-12-18T07:06:56.000Z</published>
    <updated>2018-12-18T08:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始学习C"><a href="#开始学习C" class="headerlink" title="开始学习C++"></a>开始学习C++</h1><h2 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h2><p>通常main()被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统的桥梁。</p><p>C++必修包含一个名为main()的函数，大小写拼写都要正确。如果没有main(),程序将不完整，编译器将指出未定义main()函数。</p><p>存在一些例外情况。例如,在 Windows编程中,可以编写一个动态链接库(DLL)模块,这是其他 Windows程序可以使用的代码。由于DLL模块不是独立的程序,因此不需要 main （）。</p><p>C++注释 （/ / ）以及（/ <em> 和 </em> /）</p><h3 id="C-预处理器和iostream文件"><a href="#C-预处理器和iostream文件" class="headerlink" title="C++预处理器和iostream文件"></a>C++预处理器和iostream文件</h3><p>C++和C一样,也使用一种预处理器,该程序在进行主编译之前对源文件进行处理(有些C++实现使用翻译器程序将C++程序转换为C程序。虽然翻译器也是一种预处理器,但这里不讨论这种预处理器,而只讨论处理名称以 # 开头的编译指令的预处理器)。不必执行任何特殊的操作来调用该预处理器,它会在编译程序时自动运行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.31.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>实际上，iostream文件的内容将取代程序中的代码行# include &lt; iostream&gt;。原始文件没有被修改，而是将源代码文件和iostream组合成一个复合文件，编译的下一阶段将使用该文件。</p><h3 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.37.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>像iostream这样的文件由于它们被包含在其他文件中叫做包含文件(include file)；由于它们被包含在文件起始处，也叫头文件(header file)。C++编译器自带了很多头文件，每个头文件都支持一组特定的工具。</p><p>C++的用法发生了变化。现在,对老式C的头文件保留了扩展名h(C++程序仍可以使用这种文件),而C++头文件则没有扩展名。有些C头文件被转换为C++头文件,这些文件被重新命名,去掉了扩展名h(使之成为C++风格的名称),并在文件名称前面加上前缀c(表明来自C语言)。例如,C++版本的math.h为 cmath头文件。有时C头文件的C版本和C++版本相同,而有时候新版本做了些修改。对于纯粹的C++头文件(如 iostream)来说,去掉h不只是形式上的变化,没有h的头文件也可以包含名称空间。</p><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.07.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这叫做using编译指令。</p><p>名称空间支持是C++中一项较新的特性,它是为了使编写将多个厂商已有的代码组合起来的程序更简单而设计的。一个潜在的问题是:可能使用两个已封装好的产品,而它们都包含一个名为 wanda()的函数。这样,使用 wanda函数时,编译器将不知道指的是哪个版本。名称空间让厂商能够将其产品封装在一个叫做名称空间的单元中,这样就可以用名称空间的名称来指出想使用哪个厂商的产品。因此, Microflop Industries可以将其定义放到一个名为 Microflop的名称空间中。这样,其 wanda函数的全称为Microflop:: wanda():同样, Piscine公司的 wandao版本可以表示为 Piscine: :wanda()。这样,程序就可以使用名称空间来区分不同的版本了:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.16.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>iostream是C++的标准库，标准库都被放置在命名空间std（standard）中。仅当头文件没有扩展名h时，情况才这样，也就是采用c++的新式风格，即采用了名称空间。头文件为.h由于没有采用名称空间，所以在采用不同库时，是存在命名冲突的风险的，没办法，自己想办法解决吧；）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言与c++，C语言确实是最底层，但是语法不完善，开发效率很低，c++就是为了解决某些问题才诞生的。</span><br><span class="line">鸡先生蛋还是蛋先生鸡，许多语言的编译都是c写的，那么c语言的编译器又是谁写的呢。</span><br><span class="line">1970年Tomphson和Ritchie在BCPL（一种解释型语言）的基础上开发了B语言，1973年又在B语言的基础上成功开发出了现在的C语言。在C语言被用作系统编程语言之前，Tomphson也用过B语言编写过操作系统。可见在C语言实现以前，B语言已经可以投入实用了。因此第一个C语言编译器的原型完全可能是用B语言或者混合B语言与PDP汇编语言编写的。我们现在都知道，B语言的执行效率比较低，但是如果全部用汇编语言来编写，不仅开发周期长、维护难度大，更可怕的是失去了高级程序设计语言必需的移植性。所以早期的C语言编译器就采取了一个取巧的办法：先用汇编语言编写一个C语言的一个子集的编译器，再通过这个子集去递推完成完整的C语言编译器。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编译器为什么会生成汇编语言而不是机器语言？</span><br><span class="line">1)其中有一个好处是方便优化，因为，编译器也是工具，也是机器，毕竟是机器生成的程序，不可以非常 完美的,而汇编是机器指令的助记符，一个汇编指令就对应一条机器指令（特殊指令除外）调试起来肯定会比 机器指令方便的方便，这样优化起来也方便。</span><br><span class="line">2)高级语言只需要编译成汇编代码就可以了,汇编代码到机器码的转换是由硬件实现即可,有必要用软件实 现这样分层可以有效地减弱编译器编写的复杂性,提高了效率.就像网络通讯的实现需要分成很多层一样,主要 目的就是为了从人脑可分析的粒度来减弱复杂性.</span><br><span class="line">3)如果把高级语言的源代码直接编译成机器码的话，那要做高级语言到机器码之间的映射,如果这样做的 话，每个写编译器的都必须熟练机器码。这个不是在做重复劳动么。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8811.16.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>c++在使用函数前需要有函数声明，有了函数声明还要有函数定义。c++不允许将函数定义嵌套在另一个函数定义中。每个函数定义都是独立的，所有函数<br>的创建都是平等的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%885.31.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>int main（）时return 0将返回值返回给了操作系统。例如。UNIX外壳脚本和DOS批处理文件都被设计成运行程序。很多操作系统都可以使用程序的返回值（通常也叫退出值）。通常的约定是，退出值为0则意味着程序运行成功，为非0则意味着存在问题。因此，如果c++程序无法打开文件，可以将它设计为返回一个非零值。然后，便可以设计一个外壳脚本或批处理文件来运行该程序，如果程序发出指示失败的消息，则采取其他措施。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.06.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><h3 id="short、int和long"><a href="#short、int和long" class="headerlink" title="short、int和long"></a>short、int和long</h3><p>如果在所有的系统中，每种类型的宽度都相同，则使用起来将非常方便。但是生活并非那么简单，C++提供了一种灵活的标准，它确保了最小长度（从C语言借鉴而来）：</p><ol><li>short至少16位</li><li>int至少和short一样长。</li><li>long至少32位，且至少与int一样长。</li></ol><p>当前很多系统都使用最小长度,即shot为16位,long为32位。这仍然为int提供了多种选择,其宽度可以是16位、24位或32位,同时又符合标准。通常,在老IMPC的实现中,int的宽度为16位(与short相同),而在 Windows98、 Windows nt、 Windows XP、 Macintosh OS X、VAX和很多其他微型计算机的实现中,为32位(与long相同)。有些实现允许选择如何处理int类型的宽度随实现而异,这可能在将C艹程序从种环境移到另…种环境时引发问题。但只要小心一点就可以最大限度地减少这种问题。</p><p>实际上，<strong>short是short int的简称，而long是long int的简称。</strong>这三种类型（int,short和long）都是符号类型，意思是有一位的符号位。</p><p>sizeof操作符返回类型或变量的长度，单位为字节。头文件 climits(在老式实现中为 limits h)中包含了关于整型限制的信息。具体地说,它定义了表示各种限制的符号名称。例如, INT_MAX为int的最大取值, CHAR_BIT为字节的位数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="符号常量—预处理器方式"><a href="#符号常量—预处理器方式" class="headerlink" title="符号常量—预处理器方式"></a>符号常量—预处理器方式</h3><p> # define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法(使用关键字 const）,所以不会经常使用 # define。不过,有些头文件,尤其是那些被设计成可用于C和C艹中的头文件,必须使用 # define</p><h3 id="无符号类型"><a href="#无符号类型" class="headerlink" title="无符号类型"></a>无符号类型</h3><p>要创建无符号版本的基本整形，只需要使用关键字unsigned来修改声明即可：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.15.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>climits文件与limits.h文件；老式编译器可能需要使用文件limits.h，有些非常老的编译器可能根本没有这两个文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.19.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="选择整型的类型"><a href="#选择整型的类型" class="headerlink" title="选择整型的类型"></a>选择整型的类型</h3><p>通常,int被设置为对目标计算机而言最为“自然”的长度。自然长度( natural size)指的是计算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其他类型,则应使用int。</p><p>如果知道变量可能表示的整数值大于16位整数的最大可能值,则使用long。即使系统上int为32位也应这样做。这样,当程序移植到16位的系统中时,程序就不会突然无法正常工作。</p><p>如果 short比int小,则使用 short可以节省内存。通常,仅当有大型整型数组时,才有必要使用 short(数组是一种数据结构,在内存中连续存储同类型的多个值)。如果节省内存很重要,则应使用 short而不是使用int,即使它们的长度是一样的。例如,假设要将程序从int为16位的 DOS PC系统移到int为32位的Windows XP系统,则用于存储int数组的内存量将加倍,但 short数组不受影响。记住,节省一点是一点。如果只需要一个字节，可使用char。</p><h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>十进制，八进制，十六进制。不管书写为10、012还是0xA，都将以相同的方式存储在计算机中—被存储为二进制数。</p><h3 id="C-如何确定常量的类型"><a href="#C-如何确定常量的类型" class="headerlink" title="C++如何确定常量的类型"></a>C++如何确定常量的类型</h3><p>程序将把常量1492存储为int、long还是其他整型呢?答案是,除非有理由存储为其他类型(如使用了特殊的后缀来表示特定的类型,或者值太大,不能存储为int),否则C++将整型常量存储为int类型。</p><p>首先来看看后缀。后缀是放在数字常量后面的字母,用于表示类型。整数后面的1或L后缀表示该整数为long常量,u或U后缀表示 unsigned int常量,ul(可以采用任何一种顺序,大写小写均可)表示 unsigned long常量(由于小写1看上去像1,因此应使用大写L作后缀)。例如,在int为16位、long为32位的系统上,数字22022被存储为int,占16位,数字2022L被存储为long,占32位。同样,22022LU和2202UL都被存储为 unsigned long。</p><p>接下来考察长度。在C艹中,对十进制整数采用的规则,与十六进制和八进制稍微有些不同。对于不带后缀的十进制整数,将使用下面几种类型中能够存储该数的最小类型来表示:int、long或 unsigned long。在int为16位、long为32位的计算机系统上,20000表示为int类型,40000被表示为long类型,3000000被表示为 unsigned long类型。对于不带后缀的十六进制或八进制整数,将使用下面几种类型中能够存储该数的最小类型来表示;int、 unsigned int、long或 unsigned long。在将40000表示为long的计算机系统中,六进制数Ox9C40(40000.将被表示为 unsigned int这是因为十六进制常用来表示内存地址,而内存地址是没有符号的,因此unsigned int比long更适合用来表示16位的地址。</p><h3 id="char类型：字符和小整数"><a href="#char类型：字符和小整数" class="headerlink" title="char类型：字符和小整数"></a>char类型：字符和小整数</h3><p>顾名思义，char类型是专为存储类型（如字母和数字）而设计的。编程语言通过字母的数值编码解决了字母的存储问题。因此，char类型是另一种整型（所以可以加1）。它足够长，能够表示目标计算机系统中所有基本符号—所有的字母、数字、标点符号等。实际上，多数系统所支持的字符都不超过256种，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以将它用做比short更小的整型。在美国，最常用的符号集是ASCII字符集，不过不能很好的满足国际需要，c++支持的宽字符类型可以存储更多的值，如国际Unicode字符集使用的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.53.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.55.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="wcha-t"><a href="#wcha-t" class="headerlink" title="wcha_t"></a>wcha_t</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.01.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.34.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>提示:如果读者在学习C艹之前学习过C语言,并打算使用 # define来定义符号常量,请不要这样做,而应使用 const。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="书写浮点数"><a href="#书写浮点数" class="headerlink" title="书写浮点数"></a>书写浮点数</h3><p>第一种是标准小数点表示法12.34。第二种表示浮点值的方法叫做E表示法3.45E(e)6</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>C++也有3种浮点类型float、double和long double。这些类型是按它们可以表示的有效位数和允许的指数最小范围来描述的。有效位是数字中有意义的位。事实上,C和C++对于有效位数的要求是,foat至少32位, double至少48位,且不少于float, long double至少和 double样多。这种类型的有效位数可以一样多。不过,通常foat为32位, double为64位,long double为80、96或128位。另外,这3种类型的指数范围至少是-37到37。可以从头文件cfloat或 float. h中找到系统的限制( float是C语言的 float h文件的C++版本)。</p><h3 id="浮点数的优缺点"><a href="#浮点数的优缺点" class="headerlink" title="浮点数的优缺点"></a>浮点数的优缺点</h3><p>与整数相比,浮点数有两大优点。首先,它们可以表示整数之间的值。其次,由于有缩放因子,它们可以表示的范围大得多。另一方面,浮点运算的速度比整数运算慢,至少在没有数学协处理器的计算机上是如此,而且精度将降低。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.00.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="C-算术操作符"><a href="#C-算术操作符" class="headerlink" title="C++算术操作符"></a>C++算术操作符</h2><h3 id="操作符优先级和结合性"><a href="#操作符优先级和结合性" class="headerlink" title="操作符优先级和结合性"></a>操作符优先级和结合性</h3><h3 id="除法分支"><a href="#除法分支" class="headerlink" title="除法分支"></a>除法分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.03.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="求模操作符"><a href="#求模操作符" class="headerlink" title="求模操作符"></a>求模操作符</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++自动执行很多类型转换：</p><ol><li>将一种算术类型的值赋给另一种算术类型的变量时，c++将对值进行转换。</li><li>表达式中包含不同的类型时，C++将对值进行转换。</li><li>将参数传递给函数时，C++将对值进行转换。<h4 id="赋值时进行的转换"><a href="#赋值时进行的转换" class="headerlink" title="赋值时进行的转换"></a>赋值时进行的转换</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.24.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>将0赋值给bool变量时，将被转换为false，而非零值将被转换为true。<h4 id="表达式中的转换"><a href="#表达式中的转换" class="headerlink" title="表达式中的转换"></a>表达式中的转换</h4>当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换：首先，一些类型在出现时便会自动转换。其次，有些类型在与其他类型同时出现在表达式中将被转换。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.32.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>还有其他些整型提升: 如果short比int短，则unsigned short 类型将被转换为int;如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。这种规则确保了在对unsigned short进行提升时不会损失数据。</li></ol><p>同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_ t 取值范围的类型: int. unsigned int、long或unsigned long.</p><p>将不同类型进行算术运算时， 也会进行一些转换，例如将int和float相加时。当运算涉及到两种类型时，较小的类型将破转换为较大的类型。例如，程序清单3.11中的程序用9.0除以5。 由于9.0的类型为double, 因此程序在用5除之前，将5转换为double类型。总之，编译器通过校验表来确定在算术表达式<br>中执行的转换。下面是一一个列表， 编译器将依次查阅该列表:<br>①如果有一个操作数的类型是long double, 则将另一个操作数转换为long double.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.28.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>ANSI C遵循的规则与C++相同，但传统K&amp;R C的规则稍有不同。例如，传统C语言总是将float提升为double,即使两个操作数都是float。</p><h4 id="传递参数时转换"><a href="#传递参数时转换" class="headerlink" title="传递参数时转换"></a>传递参数时转换</h4><p>传递参数时的类型转换通常由C++函数原型控制。不过,也可以取消原型对参      数传递的控制,尽管这样做并不明智。在这种情况下,C++将对char和 short类型( signed和 unsigned)应用整型提升。另外,为保持与传统C语言中大量代码的兼容性,在将参数传递给取消原型对参数传递控制的函数时,C+将float参数提升为 double。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>C++还允许通过强制类型转换机制显式地进行类型转换，强制类型转换的格式有两种。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.40.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第一种格式来自C语言,第二种格式是纯粹的C++。新格式的想法是,要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。</p><h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>计算机在内存中依次存储数组的各个元素。数组中的每一个元素可以看做一个简单变量。要创建数组，可使用声明语句，应指出三点。</p><ol><li>存储在每个元素中的值的类型</li><li>数组名</li><li>数组中的元素数</li></ol><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.47.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>表达式arraySize指定元素数目，它必须是整型常数(如10)或const值，也可以是常量表达式(如8*sizeof (in)),即其中所有的值在编译时都是已知的。具体地说，arraySize 不能是变量，变量的值是在程序运行时设置的。不过，可以使用new操作符来避开这种限制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.50.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="数组的初始化规则"><a href="#数组的初始化规则" class="headerlink" title="数组的初始化规则"></a>数组的初始化规则</h3><p>只有在定义数组时才能使用初始化，此后就不能使用了， 也不能将一 个数组赋给另一个数组:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.55.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不过， 可以使用下标分别给数组中的元素赋值。<br>初始化数组时，提供的值可以少于数组的元素数目。如果只对数组的部分进行初始化， 则编译器将把其他元素设置为0。<br>如果初始化数组时方括号内([])为空，C++编译器将计算元素个数。</p><p>通常，让编译器计算元素个数是一种很糟的做法，因为其计数可能与您想象的不一样。不过，这种方法对于将字符数组初始化为一个字符串来说比较安全。<br>C++标准模板库（STL）一种数组替代品—模板类vector，它比内置复合类型数组更复杂，也更灵活。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是存储在内存的连续字节中的一系列字符。C++处理字符串有两种方式。一，来自C语言，被称为C-风格字符串，还有一种就是基于string类库的方法。</p><p>存储在连续字节中的一-系列字符意味着可以将字符串存储在char数组中，每个字符都位于自己的数组元素中。C风格具有一种特殊的性质，以空字符结尾，空字符被写作\ 0 ，其ASCII码为0，用来标记字符串的结尾。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.35.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这两个数组都是char数组，但只有第二个数组是子符串。空子符对C-风格子付事心后里大里安。例如，C++有很多处理字符串的函数，其中包括cout使用的那些函数。它们都逐个地处理字符串中的字符， 直到到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示前4个字符，发现空字符后停止。但是，如果使用cout显示上面的dog数组(它不是字符串)，cout 将打印出数组中的5个字母，并接着将内存中随后的各个字节解释为要打印的字符，直到遇到空字符为止。由于空字符(实际上是被设置为0的字节)在内存中很常见，因此这一过程将很快停止。但尽管如此，还是<strong>不应将不是字符串的字符数组当作字符串来处理</strong>。</p><p>有一种更好地将字符数组初始化为字符串的方法，使用用引号括起来的字符串<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.39.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用引号括起的字符串隐式地包括结尾的空字符,因此不用显式地包括它。</p><p>应确保数组足够大,能够存储字符串中所有字符包括空字符。使用字符串常量初始化字符数组是这样的一种情况,即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处,只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置,而不是数组长度来进行处理。C++对字符串长度没有限制。<br>记住：在确定存储字符串所需的最短数组时，记得将结尾的空字符计算在内。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.45.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注意</strong>,字符串常量(使用双引号)不能与字符常量(使用单引号)互换。字符常量(如S)是字符串编码的简写表示。在ASCⅡ系统上,S只是83的另一种写法。因此,下面的语句:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.49.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>是将内存地址赋给变量。</p><h3 id="拼接字符串常量"><a href="#拼接字符串常量" class="headerlink" title="拼接字符串常量"></a>拼接字符串常量</h3><p>任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.08.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\ 0 )后面。第一个字符串的\ 0 字符将会被第二个字符串的第一个字符取代。</p><h3 id="在数组中使用字符串"><a href="#在数组中使用字符串" class="headerlink" title="在数组中使用字符串"></a>在数组中使用字符串</h3><p>要将字符串存储到数组中，最常用的方法有两种，一是将数组初始化为字符串常量、二将键盘或文件输入读入数组中。</p><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>cin</p><h3 id="每次读取一行字符串输入"><a href="#每次读取一行字符串输入" class="headerlink" title="每次读取一行字符串输入"></a>每次读取一行字符串输入</h3><h4 id="面向行的输入：getline"><a href="#面向行的输入：getline" class="headerlink" title="面向行的输入：getline()"></a>面向行的输入：getline()</h4><p>getline()函数读取整行,它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法,可以使用 cin. getline()。该函数有两个参数。第一个参数是用来存储输入行的数组的名称,第二个参数是要读取的字符数。</p><h4 id="面向行的输入：get"><a href="#面向行的输入：get" class="headerlink" title="面向行的输入：get()"></a>面向行的输入：get()</h4><h3 id="混合输入字符串和数字"><a href="#混合输入字符串和数字" class="headerlink" title="混合输入字符串和数字"></a>混合输入字符串和数字</h3><p>混合输入数字和面向行的字符串会导致问题。</p><h2 id="string类简介"><a href="#string类简介" class="headerlink" title="string类简介"></a>string类简介</h2><p>string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表示方法。</p><p>要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，需要提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，可以像处理普通变量那样处理字符串。</p><h3 id="赋值、拼接和附加"><a href="#赋值、拼接和附加" class="headerlink" title="赋值、拼接和附加"></a>赋值、拼接和附加</h3><p>使用 string类时,某些操作比使用数组时更简单。例如,不能将一个数组赋给另一个数组,但可以将个 string对象赋给另一个string对象。string类简化的字符串合并操作。可以使用操作符+将两个string对象合并起来,还可以使用操作符+      =一个字符串附加到个 string对象的末尾。</p><h3 id="string类的其他操作"><a href="#string类的其他操作" class="headerlink" title="string类的其他操作"></a>string类的其他操作</h3><p>在C艹新增 string类之前,程序员也需要完成诸如给字符串赋值等工作。对于C语言式的字符串,程序员使用C语言库中的函数来完成这些任务。头文件cstring(以前为 string. h)提供了这些函数。例如,可以使用函数 strcpy()将字符串复制到字符数组中,使用函数 strcat()将字符串附加到字符数组末尾:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.51.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="string类I-O"><a href="#string类I-O" class="headerlink" title="string类I/O"></a>string类I/O</h3><p>正如读者知道的,可以使用cin和操作符&lt;&lt;来将输入存储到 string对象中,使用cout和操作符&gt;&gt;来显示 string对象,其句法与处理C-风格字符串相同。但每次读取一行而不是一个单词时,使用的句法不同。</p><h2 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.58.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.50.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>C++运行在声明结构变量时省略关键字struct。<br>可以使用成员操作符（.）来访问各个成员。访问类成员函数的方式也是类似的。</p><h3 id="在程序中使用结构"><a href="#在程序中使用结构" class="headerlink" title="在程序中使用结构"></a>在程序中使用结构</h3><p>结构声明的位置很重要。可以将声明放在main()函数中，紧跟在开始括号的后面，另一种选择是将声明放在main()的前面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.57.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C++不提倡使用外部变量但提倡使用外部结构声明。<br>初始化结构：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.11.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当然也可以把它们放在同一行中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.13.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="结构可以将string类作为成员吗"><a href="#结构可以将string类作为成员吗" class="headerlink" title="结构可以将string类作为成员吗"></a>结构可以将string类作为成员吗</h3><p>大体上说，答案是肯定的。</p><h3 id="其他结构属性"><a href="#其他结构属性" class="headerlink" title="其他结构属性"></a>其他结构属性</h3><p>C++使用户定义的类型与内置类型尽可能相似。例如， 可以将结构作为参数传递给函数, 也可以让函数返同—个结构。另外，还可以使用赋值操作符(=) 将结构賦给另一个同类型的结构， 这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值。</p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="结构中的位字段"><a href="#结构中的位字段" class="headerlink" title="结构中的位字段"></a>结构中的位字段</h3><p>与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整型或枚举(稍后将介绍),接下来是冒号，冒号后面是一一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段(bit field)。下面是一个例子:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.23.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.27.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>位字段通常用在低级编程中。</p><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体（union）是一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时存储int、long和double,共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。<br>声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.32.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以使用one4all变量来存储int、long或double，条件是在不同的时间进行：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.34.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此，pail 有时可以是int变量，而有时义可以是double变量。成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。在存储了double后int值就丢失了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.57.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于共用体是匿名的，因此id_ num和id_ char被视为prize 的两个成员，它们的地址相同，所以不需要中间标识符id_ val。程序员负责确定当前哪个成员是活动的。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。使用enum的句法与使用结构相似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.00.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这条语句完成两项工作：<br>第一让spectrum称为新类型的名称，spectrum被称为枚举，就像struct变量被称为结构一样。<br>第二将red,orange,yellow等作为符号常量，它们对应整数值0-7.这些常量叫做枚举量。<br>可以用枚举名来声明这种类型的变量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.07.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.11.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于枚举，只定义了赋值操作符，具体说就是没有为枚举定义算术运算：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.12.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于最后一个式子<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.18.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>枚举时整型，可被提升为Int类型，但int类型不能自动转换为枚举类型：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.16.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>枚举的规则相当严格，实际上，枚举更常被用来定义相关的符号常量，而不是新类型。如果打算只使用常量而不创建枚举类型的变量，则可以省略枚举类型的名称。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.21.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="设置枚举量的值"><a href="#设置枚举量的值" class="headerlink" title="设置枚举量的值"></a>设置枚举量的值</h3><p>可以使用赋值操作符来显示地设置枚举量的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.22.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>指定的值必须是整数。 也可以只显式地定义其中一些枚举量的值:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.23.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里，first在默认情况下为0，后面没有被初始化的枚举量的值将比其前面的枚举量大1，因此，third的值为101。<br>还可以创建多个值相同的枚举量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.27.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在早期版本中，只能将int值（或提升为int的值）赋给枚举量，现在这种限制已经取消了，因此可以使用long类型的值。</p><h3 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h3><p>最初，对于枚举来说，只有声明中指出的那些值是有效的。不过，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围(range)， 通过强制类型转换， 可以将取值范围中的任何整数值赋给枚举变量， 即使这个值不是枚举值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.30.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>则如下代码将是合法的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中6不是枚举值，但它位于枚举定义的取值范围中。<br>取值范围的定义如下。首先， 要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1, 得到的便是取值范围的上限。例如， 前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0,则取值范围的下限为0;否则，采用与寻找上限方式相同的方式， 但加上负号。例如， 如果最小的枚举量为-6， 而比它小的、最大的2的幂是-8 (加上负号)，因此下限为-7。</p><p>选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举,使用一个字节或更少的空间而对于包含long类型值的枚举,则使用4个字节。</p><h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><p>指针是一个变量，其存储的是值的地址而不是值本身，对变量应用地址操作符（&amp;）就可以获得它的位置，如home是一个变量，则&amp;home是它的地址。</p><p>面向对象编程与传统过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。即使用new和指定固定长度的数组的区别。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.53.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="声明和初始化指针"><a href="#声明和初始化指针" class="headerlink" title="声明和初始化指针"></a>声明和初始化指针</h3><p>计算机需要跟踪指针指向的值的类型。例如，char 的地址与double的地址看上去没什么两样，但char和double使用的字节数是不同的，它们存储值时使用的内部格式也不同。因此，指针声明必须指定指针指向的数据的类型。但是地址的格式是相同的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.58.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要强调的是，int <em> 是一种类型，是指向int的指针。在哪里添加空格对于编译器是没有任何区别的。以下声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.03.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将创建一个指针p1和一个常规int变量p2。对每个指针变量名，都需要使用一个 </em> 。</p><h3 id="指针的危险"><a href="#指针的危险" class="headerlink" title="指针的危险"></a>指针的危险</h3><p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。</p><p><strong>警告</strong>：<strong>一定要在对指针应用解除引用操作符（ * ）之前，将指针初始化为一个确定的、适当的地址。</strong></p><h3 id="指针和数字"><a href="#指针和数字" class="headerlink" title="指针和数字"></a>指针和数字</h3><p>指针不是整型，虽然计算机通常把地址当做整数来处理。在C99标准发布前，C语言允许直接对指针赋值整数，但C++在类型一致性上要求更严格，编译器将显示一条错误信息，要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.58.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，pt是int值的地址，并不意味着pt本身的类型是int。</p><h3 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h3><p>指针的真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc()来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—使用new操作符。</p><p>在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new操作符。程序员要告诉new,需要为哪种数据类型分配内存; <strong>new将找到一个长度正确的内存块，并返回该内存块的地址。</strong>程序员的责任是将该地址赋给一个指针。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.50.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在之前是通过如下方式指定指针的地址的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.51.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两种情况都是将一个int变量的地址赋给了指针。第二种情况下还可以通过名称来访问该int，第一种情况下，则只能通过该指针进行访问。pn指向的内存没有名称，该怎么称呼呢？我们称pn指向一个数据对象。这里的对象不是面向对象中的那个对象，术语数据对象比变量更通用，指为数据项分配的内存块，因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。</p><p>为一个数据对象(可以是结构，也可以是基本类型)获得并指定分配内存的通用格式如下:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.59.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要在两个地方指定数据类型:用来指定需要什么样的内存和用来声明合适的指针。由于内存地址形式一样，所以得通过指针的类型知道需要读几个内存单元的值。</p><h3 id="内存被耗尽"><a href="#内存被耗尽" class="headerlink" title="内存被耗尽"></a>内存被耗尽</h3><p>计算机可能会由于没有足够的内存而无法满足new的请求。此时，new将返回0。在C++中，值为0的指针被称为空值指针（null pointer）。C++确保空值指针不会指向有效的数据，因此它常被用来表示操作符或函数失效，如果成功，它们将返回一个有用的指针。可以通过if语句来检查new是否返回的是空值指针，从而防止程序超界。如果无法分配内存，new除返回空值指针外，还可能引发bad_alloc异常。</p><h3 id="使用delete来释放内存"><a href="#使用delete来释放内存" class="headerlink" title="使用delete来释放内存"></a>使用delete来释放内存</h3><p>当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是delete操作符，它使得在使用完内存后， 能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放(free)的内存可供程序的其他部分使用。使用delete时，后面要加.比指向内存块的指针(这些内存块最初是用new分配的):<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.09.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这将释放ps指向的内存，但不会删除指针ps本身。例如，可以将ps重新指向另一个新分配的内存块。一定要配对地使用new和delete: 否则将发生内存泄漏(memory leak), 也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。</p><p>不要尝试释放已经释放的内存，这样做的结果是不确定的，不能使用delete来释放声明变量获得的内存。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.15.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>只能用delete来释放使用new分配的内存</strong>，不过对空指针使用delete是安全的。</p><p>使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.19.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一般来说， 不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。</p><h3 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h3><p>如果通过声明来创建数组,则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组,数组都在那里,它占用了内存。在编译时给数组分配内存被称为静态联编( static binding),意味着数组是在编译时加入到程序中的。但使用new时,如果在运行阶段需要数组,则创建它:如果不需要, 则不创建。还可以在程序运行时选择数组的长度。这被称为动态联编(dynamic binding),意味着数组是在程序运行时创建的。这种数组叫作动态数组(dynamic array)使用静态联编时,必须在编写程序时指定数组的长度;使用动态联编时,程序将在运行时确定数组的长度。</p><h4 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h4><p>在C++中,创建动态数组很容易;只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号,其中包含元素数目。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.28.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>new操作符返回第一个元素的地址，当程序结束使用内存块后，应使用delete释放它们。</p><p>使用new创建数组时，应使用另一种格式的delete,它能指出所要释放的是一个数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.49.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意delete和指针之间的方括号。如果使用new时，不带方括号，则使用delete时，也不应带方括号。如果使用new时带方括号，则使用delete时也应带方括号。</p><p>总之, 使用new和delete时，应遵守以下规则:</p><ol><li>不要使用delete来释放不是new分配的内存。</li><li>不要使用delete释放同一个内存块两次。</li><li>如果使用new[ ]为数组分配内存，则应使用delete[ ]来释放。</li><li>如果使用new[ ]为一个实体分配内存，则应使用delete (没有方括号)来释放。</li><li>对空值指针应用delete是安全的。</li></ol><p>由于动态数组返回的是指向第一个元素的指针，所以程序员需要跟踪内存块中的元素个数，实际上程序跟踪了分配的内存量以便在使用delete[]操作符时能正确地释放这些内存。但是这些信息是不公用的，如，不能使用sizeof操作符来确定动态分配的数组包含的字节数。</p><p>为数组分配内存的通用格式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%886.12.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用new操作符可以确保内存块足以存储num_elements 个类型为type_ name的元素，而pointer_ name将指向第1个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于new与delete的问题</span><br><span class="line">一般来说在程序结束后操作系统会收回分配的所有资源，不delete也不会造成影响。但是如果程序常驻内存只new不delete就会很快耗尽内存，造成内存泄露，所以要养成new delete的习惯。</span><br></pre></td></tr></table></figure></p><h4 id="使用动态数组"><a href="#使用动态数组" class="headerlink" title="使用动态数组"></a>使用动态数组</h4><p>将指针当做数组名使用即可，对于第一个元素，即为p[0]。<br>数组名和指针的根本区别在于，不能修改数组名的值，但指针是变量，因此可以修改它的值。相邻的int地址通常相差2个字节或4个字节，而将p3加1后，它将指向下一个元素的地址，这表明指针算术有:些特别的地方。情况确实如此。</p><h2 id="指针、数组和指针算术"><a href="#指针、数组和指针算术" class="headerlink" title="指针、数组和指针算术"></a>指针、数组和指针算术</h2><p>指针和数组基本等价的原因在于指针算术( pointer arithmetic和C++内部处理数组的方式。算术。将整数变量加1后,其值将增加1;但将指针变量加1后,增加的量等于它指向的类型的字节数。将指向double的指针加1后,如果系统对double使用8个字节存储,则数值将增加8;将指向short的指针加1后,如果系统对 short使用2个字节存储,则指针值（存储的地址值）将增加2。C++将数组名解释为地址。</p><p>如数组表达式stack[1]，C++编译器将该表达式看作是*(stacks+1)，这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。<br>区别之一在于可以修改指针的值，而数组名是常量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%884.26.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一个区别是，对数组应用sizeof操作符得到的数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。</p><h3 id="指针算术："><a href="#指针算术：" class="headerlink" title="指针算术："></a>指针算术：</h3><p>C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种运算才有意义;这将得到两个元素的间隔。</p><h3 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h3><p>cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。在C++中，用引号括起来的字符串像数组名一样，也是第一个元素的地址。</p><p><strong>在cout和多数C++表达式中, char数组名、指向char的指针以及用引号括起的宇符串常量都被解释为字符串第一个字符的地址。</strong></p><h3 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用new创建动态结构</h3><p>将new用于结构由两步组成:创建结构和访问其成员。要创建结构，需要同时使用结构类型和new。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%885.39.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这将把足以存储infatable结构的 块可用内存的地址赋给ps。 这种句法和C++的内置类型完全相同。</p><p>箭头成员操作符（-&gt;），可用于指向结构的指针，就像点操作符可用于结构名一样。如ps指向一个inflatable结构，则ps-&gt;price是被指向的结构的price成员。如果结构标识符是结构名，则使用句点操作符;如果标识符是指向结构的指针，则使用箭头操作符。</p><p>另一种访问结构成员的方法是，如果ps是指向结构的指针，则 <em> ps 就是被指向的值一结构本身。 由于 </em> ps是一个结构，因此( * ps) .price 是该结构的price 成员。C++的操作符优先规则要求使用括号。</p><h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C++有3种管理数据内存的方式: 自助存储、静态存储和动态存储(有时也叫作自由存储空间或堆)。</p><h4 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h4><p>在函数内部定义的常规变量使用自助存储空间，被称为自动变量(automatic variable),这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。</p><p>实际上，自动变量是一个局部变量，其作用域为包它的代码块。代码块是被包含在花括号中的一段代码。</p><h4 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h4><p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种:一种是在函数外面定义它:另一种是在声明变量时使用关键字static。</p><p>自动存储和静态存储的关键在于:这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期(静态变量)，也可能只是在特定函数被执行时存在(自动变量)。</p><h4 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h4><p>new和delete操作符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间(free store)。内存池同用于静态变量和自动变量的内存是分开的。new和delete允许在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期就不完全受到程序或函数的生存时间的控制了。与使用常规变量相比， 使用new和delete使程序员对程序如何使用内存有更大的控制权。</p><h3 id="堆栈、堆和内存泄露"><a href="#堆栈、堆和内存泄露" class="headerlink" title="堆栈、堆和内存泄露"></a>堆栈、堆和内存泄露</h3><p>如果使用new在自由空间（或堆）上创建变量后，没有调用delete，即使指针由于作用域规则和对象声明周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄露。被泄露的内存将在程序的整个生命周期都不可使用。</p><h1 id="循环和关系表达式"><a href="#循环和关系表达式" class="headerlink" title="循环和关系表达式"></a>循环和关系表达式</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%886.15.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>循环只执行一次初始化。</p><p>测试表达式结果为真，则程序将执行循环体，为假循环结束。<br>C++并没有将test expression的值限制为只能为真或假。可以使用任意表达式，C++将把结果强制转换为bool类型。因此， 值为0的表达式将被转换为bool值false,导致循环结束。 如果表达式的值为非零，则被强制转换为bool值true。</p><h3 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h3><p><strong>在C++中，每个表达式都有值。</strong><br>通常值是很明显的，如22+27<br>但x=20这个表达式由两个值和一个赋值操作符组成。C++将赋值表达式的值定义为左侧成员的值。因此maids=（x=20）+2可得maids为22。对于x=y=z=0，赋值操作符是从右向左结合的，因此首先将0赋给z，然后将z=0赋给y，以此类推。</p><p>从表达式到语句的转变是很小的一步，只要加一个分号就可以完成。</p><h3 id="递增操作符（-）和递减操作符（—）"><a href="#递增操作符（-）和递减操作符（—）" class="headerlink" title="递增操作符（++）和递减操作符（—）"></a>递增操作符（++）和递减操作符（—）</h3><p>a++意味着使用a的当前值计算表达式，然后将a的值加1;而++b的意思是先将b的值加1, 然后使用新的值来计算表达式。</p><h3 id="组合赋值操作符"><a href="#组合赋值操作符" class="headerlink" title="组合赋值操作符"></a>组合赋值操作符</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.08.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.10.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="可能犯的错误"><a href="#可能犯的错误" class="headerlink" title="可能犯的错误"></a>可能犯的错误</h3><p>==与=</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.21.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="for与while"><a href="#for与while" class="headerlink" title="for与while"></a>for与while</h3><p>在C++中， for和while循环本质上是相同的。<br>可以相互改写。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>C++为类型建立别名的方式有两种。一种是使用预处理器<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.31.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这样，预处理器将在编译程序时用char替换所有的BYTE,从而使BYTE成为char的别名。<br>第二种方法是使用C++(和C)的关键字typedef来创建别名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.32.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.34.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以使用#define，不过声明一系列变量时，这种方法不适用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.36.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>typedef方法不会有这样的问题。它能够处理更复杂的类型别名，这使得与使用#define相比，使用typedef时一种更佳的选择，有时也是唯一的选择。</p><p>注意, typedef不会创建新类型,而只是为已有的类型建立一个新名称。</p><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.47.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="嵌套循环和二维数组"><a href="#嵌套循环和二维数组" class="headerlink" title="嵌套循环和二维数组"></a>嵌套循环和二维数组</h2><p>声明数组：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.55.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.56.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.59.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于二维数组，由于每个元素本身就是一个数组，因此可以使用与上述代码类似的格式来初始化每一个元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.00.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>}；</p><h1 id="分支语句和逻辑操作符"><a href="#分支语句和逻辑操作符" class="headerlink" title="分支语句和逻辑操作符"></a>分支语句和逻辑操作符</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="格式化if-else语句"><a href="#格式化if-else语句" class="headerlink" title="格式化if else语句"></a>格式化if else语句</h3><p>如果需要多条语句，需要用花括号将它们括起来，组成一个块语句。和有些语言不同的是，由于C++不会自动将if和else之间的所有代码视为一个代码块，因此必须使用花括号将这些语句组合成一个语句块。</p><h3 id="if-else-if-else结构"><a href="#if-else-if-else结构" class="headerlink" title="if else if else结构"></a>if else if else结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.12.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><h3 id="逻辑OR操作符："><a href="#逻辑OR操作符：" class="headerlink" title="逻辑OR操作符：| |"></a>逻辑OR操作符：| |</h3><h3 id="逻辑AND操作符：-amp-amp"><a href="#逻辑AND操作符：-amp-amp" class="headerlink" title="逻辑AND操作符：&amp;&amp;"></a>逻辑AND操作符：&amp;&amp;</h3><h3 id="逻辑NOT操作符：！"><a href="#逻辑NOT操作符：！" class="headerlink" title="逻辑NOT操作符：！"></a>逻辑NOT操作符：！</h3><h3 id="逻辑操作符细节"><a href="#逻辑操作符细节" class="headerlink" title="逻辑操作符细节"></a>逻辑操作符细节</h3><p>OR和AND操作符的优先级都低于关系操作符。这意味着<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.19.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一方面！操作符的优先级高于所有的关系操作符和算术操作符。因此，要对表达式求反，必须用括号将其括起来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.20.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>逻辑AND操作符的优先级高于逻辑OR操作符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.21.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="其他表示方式"><a href="#其他表示方式" class="headerlink" title="其他表示方式"></a>其他表示方式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.22.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库cctype</h2><p>C++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（老式风格为ctype.h）中定义的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.34.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="？：操作符"><a href="#？：操作符" class="headerlink" title="？：操作符"></a>？：操作符</h2><p>C++有一个常被用来代替if else语句的操作符，这个操作符被称为条件操作符（?:），它是C++中唯一一个需要3个操作数的操作符。该操作符通用格式如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.36.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果expressionl 为true, 则整个条件表达式的值为expression2 的值; 否则，整个表达式的值为expression3的值。</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.53.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意使用break。</p><h3 id="将枚举量作为标签"><a href="#将枚举量作为标签" class="headerlink" title="将枚举量作为标签"></a>将枚举量作为标签</h3><h3 id="switch和if-else"><a href="#switch和if-else" class="headerlink" title="switch和if else"></a>switch和if else</h3><p>switch并不是为处理取值范围而设计的。switch语句中的每一个case标签都必须是一个单独的值。另外这个值必须是整数（包括char），因此switch无法处理浮点测试。如果既可以使用if else语句，也可以使用switch语句，则当选项不少于3个时，应使用switch语句。</p><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h2 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h2><h3 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h3><ol><li>必须包含头文件iostream</li><li>头文件iostream定义了个用处理输入的istream类。</li><li>头文件iostream声明了一个名为cin的istream变量(对象)。</li><li>必须指明名称空间std;例如,为引用元素cin,必须使用编译指令 using或前缀std::。</li><li>可以结合使用cin和操作符&lt;&lt;来读取各种类型的数据。</li><li>可以使用cin和get（）方法来读取一个字符,使用cin和 getline（）来读取一行字符。</li><li>可以结合使用cin和eof()、fail()方法来判断输入是否成功。</li><li>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ol><h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><ol><li>必须包含头文件fstream</li><li>头文件 fstream定义了一个用于处理输入的 ifstream类。</li><li>需要声明一个或多个 ifstream变量(对象),并以自己喜欢的方式对其进行命名,条件是遵守常用的命名规则。</li><li>必须指明名称空间std:例如，为引用元素ifstream, 必须使用编译指令using 或前缀std:.。</li><li>需要将ifstream对象与文件关联起来。为此， 方法之一是使用open()方法。</li><li>使用完文件后，应使用close()方法将其关闭。</li><li>可结合使用ifstream对象和操作符&lt;&lt;来读取各种类型的数据。</li><li>可以使用ifstream 对象和get() 方法来读取一个字符， 使用ifstream对象和getine()来读取一行字符。</li><li>可以结合使用ifstream 和eof()、 fail()等方法来判断输入是否成功。</li><li>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true,否则被转换为false。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开始学习C&quot;&gt;&lt;a href=&quot;#开始学习C&quot; class=&quot;headerlink&quot; title=&quot;开始学习C++&quot;&gt;&lt;/a&gt;开始学习C++&lt;/h1&gt;&lt;h2 id=&quot;进入C&quot;&gt;&lt;a href=&quot;#进入C&quot; class=&quot;headerlink&quot; title=&quot;进入C
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>具体数学 Interger Functions</title>
    <link href="https://github.com/zdkswd/2018/12/07/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/"/>
    <id>https://github.com/zdkswd/2018/12/07/具体数学 Interger Functions/</id>
    <published>2018-12-07T09:15:32.000Z</published>
    <updated>2018-12-07T09:18:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="取整基础"><a href="#取整基础" class="headerlink" title="取整基础"></a>取整基础</h1><h2 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h2><p>向下取整函数⌊x⌋定义为小于等于x的最大整数。<br>向上取整函数⌈x⌉定义为大于等于x的最小整数。<br>{x}定义为实数x的小数部分，即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.21.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.22.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>表示x是整数则取0，x不是整数则取1。</p><h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>取整函数范围：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.23.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>负数的取整：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.24.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h3><p>取整函数中的整数可以提取出来：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.24.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="应用1"><a href="#应用1" class="headerlink" title="应用1"></a>应用1</h3><p>证明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.39.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>更一般的，我们还可以证明，对于任意连续、递增的函数f(x)，如果它满足<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.41.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.41.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们证明第2个式子，第1个同理可证。<br>如果x=⌈x⌉，显然成立。<br>否则x&lt;⌈x⌉，因为f(x)递增，所以有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.43.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两边同时取整，有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.50.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若是想要证左右两边相等，只需要证<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.52.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>不成立</strong>即可。<br>假设上式成立，那么由中间值定理，一定存在x≤y&lt;⌈x⌉，使得<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%882.55.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由上图可以看出，当下面式子成立时，满足中间值定理<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%883.17.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但是，我们假设是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%883.18.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>那么由⌈f(x)⌉&lt;⌈f(⌈x⌉)⌉能否推出⌈f(x)⌉&lt;f(⌈x⌉)呢？当然是可以的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%883.19.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%883.20.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>（怎么得到的。。）<br>又因为x≤y&lt;⌈x⌉，所以不存在整数y，矛盾！<br>所以证得<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%883.20.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一个特殊的例子是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%883.21.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中m和n都是整数，并且n是正整数。</p><h3 id="应用2"><a href="#应用2" class="headerlink" title="应用2"></a>应用2</h3><p>求1到1000中使得下列式子成立的n一共有多少个？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.03.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>求解方法如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.04.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>继续推广，求1到N中使得上面式子成立的n有多少个，令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.09.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也就是小于等于的最大整数。所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.10.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>渐进地等于<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.10.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="应用3"><a href="#应用3" class="headerlink" title="应用3"></a>应用3</h3><p>定义一个实数的谱为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.11.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>很容易证明如果两个实数α≠β，那么<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.11.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>假设α&lt;β，那么令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.12.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.12.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以集合Spec(β)中小于⌊mα⌋的元素个数小于m。而集合Spec(α)中小于⌊mα⌋的元素个数大于等于m。所以两个集合不相等。</p><p>谱有很多奇妙的性质，例如下面两个谱：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.12.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以发现，这两个谱正好划分了正整数集。<br>证明方法也很简单，只要证明对任意正整数n，两个集合中小于n的元素个数之和为n，过程如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.13.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以第一个集合中小于n的元素个数为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.13.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同理第二个集合中小于n的元素个数为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.13.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以总个数为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.14.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>得证。</p><h1 id="取整进阶"><a href="#取整进阶" class="headerlink" title="取整进阶"></a>取整进阶</h1><h2 id="约瑟夫环新解"><a href="#约瑟夫环新解" class="headerlink" title="约瑟夫环新解"></a>约瑟夫环新解</h2><p>这里我们继续推广到一般情况，如果有n个人，每隔q个人踢掉一个人，最后剩下的是几号？初始编号为1…n，现在考虑一种新的编号方式。第一个人不会被踢掉，编号加1，变成n+1，然后第二个人编号变为n+2，直到第q个人，他被踢掉了。然后第q+1个人编号继续加1，变成了n+q，依次下去。考虑当前踢到的人编号为kq，那么此时已经踢掉了k个人，所以接下去的人新的编号为n+k(q−1)+1…。所以编号为kq+d的人编号变成了n+k(q−1)+d，其中1≤d&lt;q。直到最后，可以发现活下来的人编号为qn，问题是怎么根据这个编号推出他原来的编号？以n=10，q=3为例，下图就是每个人新的编号：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/1%202.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令<br>N=n+k(q−1)+d<br>所以他上一次的编号是<br>kq+d=kq+N−n−k(q−1)=k+N−n<br>因为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.19.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以上一次编号可以写为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.19.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果我们用D=qn+1−N替代N，将会进一步简化算法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.19.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="模的性质"><a href="#模的性质" class="headerlink" title="模的性质"></a>模的性质</h1><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><p>模定义如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.21.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>特别的<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.22.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与此类似，定义一个与模类似的运算：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.23.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>模有一些性质：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.23.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>考虑如下问题，怎么平均分配n个东西给m个人？很容易想到，首先分给每个人⌊n/m⌋个东西，剩下n mod m件东西分给前n mod m个人，一人多一件就行。概括起来就是，前n mod m个人，每人⌈ n / m⌉件，剩下的人，每人⌊n /  m⌋件。统一表示呢？有的，每个人分到的件数为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.26.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为什么呢？假设<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.29.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>那么<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.30.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当1≤k≤r时，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.30.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当r&lt;k≤m时，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.30.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>得证，因此可以得到如下等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.30.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由n=⌊n / 2⌋+⌈n / 2⌉<br>可以进一步将其转换为下取整形式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.31.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令n=⌊mx⌋<br>我们得到了一个令人惊奇的等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.31.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><p>题目：求⌊nx⌋=n⌊x⌋的充要条件。<br>解答：<br>因为x=⌊x⌋+{x}，所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.32.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要使得⌊nx⌋=n⌊x⌋，就必须有⌊n{x}⌋=0，所以n{x}&lt;1即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.34.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="题7"><a href="#题7" class="headerlink" title="题7"></a>题7</h2><p>题目：求下列递推式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.34.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>解答：<br>因为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.34.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.35.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="题8"><a href="#题8" class="headerlink" title="题8"></a>题8</h2><p>题目：n个物品放到m个盒子中，求证至少有一个盒子物品数大于等于⌈n / m⌉，至少有一个盒子物品数小于等于⌊n / m⌋。<br>解答：假设所有的盒子物品数都小于⌈n / m⌉，那么总物品数S满足<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.40.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令n=qm+r,0≤r&lt;m，那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.40.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果r=0，那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.41.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果r&gt;0，那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.41.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这与S=n矛盾！所以至少有一个盒子物品数大于等于⌈n / m⌉。<br>假设所有的盒子物品数都大于⌊n / m⌋，那么总物品数S满足<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.49.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令n=qm+r,0≤r&lt;m，那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.50.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这与S=n矛盾！所以至少有一个盒子物品数小于等于⌊n / m⌋。</p><h1 id="取整进阶-1"><a href="#取整进阶-1" class="headerlink" title="取整进阶"></a>取整进阶</h1><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p>求和：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.55.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>首先令m=⌊√k⌋<br>那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.56.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们先算左半部分，先假设n=a的2次方，那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.57.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>而对于一般的n，令a=⌊√n⌋，我们只需要计算a的2次方≤k&lt;n的部分，而这部分√k=a，所以结果为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.58.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以总的结果为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%884.59.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为什么没有算右半部分？因为右半部分就是a2≤k&lt;n的这部分，已经计算过了。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.05.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个公式说明了，无理数α的整数倍的小数部分均匀分布在(0,1)之间。这就给了我们一个启示，我们可以用它来生成随机数啊！其他用处还有很多。</p><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p>求如下和式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.07.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中整数m&gt;0，n也是整数。<br>通过枚举m=1,2,3,…，可以发现和式满足如下形式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.07.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如何进行计算：<br>首先做一个变形：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.08.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这就将原来的和式分为了三个部分求和。<br>第一个部分为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.08.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里通过枚举可以发现它的值是有周期的，周期重复次数是d=gcd(m,n)。所以算出来结果为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.09.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第二个部分为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.09.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第三个部分为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.09.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以总的结果为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.10.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对结果稍稍变形，可以得到另一个结果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.10.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以发现，m和n是对称的！所以可以得到如下结论：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.13.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这有什么用呢？当m特别大、n很小的时候可以大大减少项的个数！<br>如果我们令n=1，就会发现，得到的式子和之前证过的一个式子一模一样！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20Interger%20Functions/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%885.14.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;取整基础&quot;&gt;&lt;a href=&quot;#取整基础&quot; class=&quot;headerlink&quot; title=&quot;取整基础&quot;&gt;&lt;/a&gt;取整基础&lt;/h1&gt;&lt;h2 id=&quot;符号定义&quot;&gt;&lt;a href=&quot;#符号定义&quot; class=&quot;headerlink&quot; title=&quot;符号定义&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>具体数学 第二章</title>
    <link href="https://github.com/zdkswd/2018/12/06/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>https://github.com/zdkswd/2018/12/06/具体数学 第二章/</id>
    <published>2018-12-06T05:24:32.000Z</published>
    <updated>2018-12-06T05:27:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求递推式本身的表达式"><a href="#求递推式本身的表达式" class="headerlink" title="求递推式本身的表达式"></a>求递推式本身的表达式</h1><p>将递归式转化为求和再求出递推式本身的表达式。<br>考虑如下递归式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.59.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两边同时乘以sn得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.59.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>观察Tn项和Tn-1项之前的系数，要想转化为可以求和的递归式，必须有：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%881.09.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%881.10.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%881.12.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%881.13.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时再求和可得：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%881.14.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.35.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p>设n个数快速排序的操作次数为Cn，那么有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.49.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用n-1取代n可以得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.50.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两式相减可以得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.50.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>观察形式，由上面方法可以得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.53.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以得<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.54.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>进而带入公式。可以求得<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.57.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中调和级数为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.58.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以最后结果为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%884.58.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="求和三大定律"><a href="#求和三大定律" class="headerlink" title="求和三大定律"></a>求和三大定律</h1><p>结合律、分配率、交换律。</p><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p>求<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%885.03.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里使用求和定律来做<br>用n-k取代k,得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%885.06.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%885.06.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两式相加得<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%885.06.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%885.08.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h2><p>求<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%887.00.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里用到另一种求和的方法。<br>两边同时加上第n+1项，得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%887.00.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%887.05.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以这样求解：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%887.08.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>求导得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%887.10.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%887.11.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样可以得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%887.11.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="多重求和"><a href="#多重求和" class="headerlink" title="多重求和"></a>多重求和</h1><p>多重求和，也就是一个和式由多个下标来指定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%884.00.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h2><p>一个对称矩阵<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%887.27.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>求：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%887.27.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这是这个矩阵的上三角加对角线求和，因为是对称的嘛，可以补全下三角，加上对角线就行了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%887.34.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%887.34.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h2><p>有如下式子，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%887.46.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>调换j,k位置，得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%887.48.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.03.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至此解完，可以推出一个著名不等式—-切比雪夫不等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.04.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="例题3-1"><a href="#例题3-1" class="headerlink" title="例题3"></a>例题3</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.19.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用三种方法解这个式子：</p><h3 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h3><p>调和级数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%889.59.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>首先将j和k分开，首先计算对j求和：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.20.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>先计算对k求和：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.21.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>按对角线求和：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.21.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由此得到了一个完全不同的表示形式，所以得到了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.27.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="几种求和方法"><a href="#几种求和方法" class="headerlink" title="几种求和方法"></a>几种求和方法</h1><p>针对以下求和式，使用八种方法来求解：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.55.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它的答案为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.55.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="扰动法"><a href="#扰动法" class="headerlink" title="扰动法"></a>扰动法</h2><p>令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.57.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.57.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>解出<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.58.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最终得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%888.58.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看出，我们本来是要对k的二次方求和的，但是只要对k的三次方用扰动法求和即可，因为求和过程中k的三次方项会被抵消掉。</p><h2 id="扩展成二重指标求和"><a href="#扩展成二重指标求和" class="headerlink" title="扩展成二重指标求和"></a>扩展成二重指标求和</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%889.35.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="用有限微分求和"><a href="#用有限微分求和" class="headerlink" title="用有限微分求和"></a>用有限微分求和</h2><p>微分的形式为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.55.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果定义<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.55.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>则有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.55.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>似乎不能和导数形式统一起来，用起来也不方便，定义一个新的函数，叫<strong>下降阶乘幂</strong>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.57.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个函数有一个很好的性质，那就是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%881.09.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%881.12.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>和积分类似，有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%881.13.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%881.13.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因为有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%881.14.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%881.14.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样可以得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%881.14.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="下降阶乘幂"><a href="#下降阶乘幂" class="headerlink" title="下降阶乘幂"></a>下降阶乘幂</h1><h2 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%889.26.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h2><p>给出下降阶乘幂为负数的定义：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%889.27.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%889.33.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="性质四"><a href="#性质四" class="headerlink" title="性质四"></a>性质四</h2><p>定义下降阶乘幂的好处就是为了求差分方便，下降阶乘幂的差分为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%889.35.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>类比不定积分，不定和为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%889.37.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但是这里m≠−1，若是m=−1，直接运用差分定义可以求出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.01.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.06.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="性质五"><a href="#性质五" class="headerlink" title="性质五"></a>性质五</h2><p>什么函数的差分是自身。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.24.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>进一步推广可得：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.25.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以得到一种新的等比数列计算方法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.26.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="性质六"><a href="#性质六" class="headerlink" title="性质六"></a>性质六</h2><p>结合律和分配率在差分运算中也适用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.31.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="性质七"><a href="#性质七" class="headerlink" title="性质七"></a>性质七</h2><p>类似分部积分，这里也可以分部来求差分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.36.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>给出一个新的记号移位运算：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.37.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以得到了差分的分部运算法则：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.37.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对两边求和，又可以得到不定求和的分布运算法则：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.38.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>计算<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.40.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先计算<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.41.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里可以令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.41.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.42.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>求和式就可以转化为不定求和来算了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.42.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>计算<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.43.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先计算<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.43.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里注意要令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.44.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不能倒过来，因为Hx的不定和很难求出来。所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.44.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8A%E5%8D%8810.45.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="无限求和"><a href="#无限求和" class="headerlink" title="无限求和"></a>无限求和</h1><p>之前求和式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.14.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两边同时乘2，得：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.14.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>解得：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.15.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但是同样的方式计算式子：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.15.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两边同时乘2，得：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.16.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>解出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.16.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>显然是不可能的，因为这里T是发散的，所以不能这么求。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.19.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.22.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>比如<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.22.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>再如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.23.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>求有正有负的和式。<br>可以考虑用不同的配对，将正负组合在一起，从而相消求和。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.34.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们可以将正数和负数分开求和，因为正数求和已经解决了。定义：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.35.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.37.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>求和式对两部分分别求和：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.38.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最后可以推广到二重求和。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%8812.39.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求递推式本身的表达式&quot;&gt;&lt;a href=&quot;#求递推式本身的表达式&quot; class=&quot;headerlink&quot; title=&quot;求递推式本身的表达式&quot;&gt;&lt;/a&gt;求递推式本身的表达式&lt;/h1&gt;&lt;p&gt;将递归式转化为求和再求出递推式本身的表达式。&lt;br&gt;考虑如下递归式：&lt;br&gt;
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>具体数学 第一章</title>
    <link href="https://github.com/zdkswd/2018/12/04/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://github.com/zdkswd/2018/12/04/具体数学 第一章/</id>
    <published>2018-12-04T04:33:32.000Z</published>
    <updated>2018-12-04T04:37:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h1><p>3个柱子的汉诺塔问题，最少移动次数记为T(n)。<br>T(n)=2T(n−1)+1<br>边界条件为T(0)=0。解出<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%888.35.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中等比数列求和公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/7dd98d1001e93901d3c632667bec54e737d196a6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>递归<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/v2-0ff29cd5195ff3e432fef0247a798c4b_b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>移动的时候的原则就如下表示：<br>第一阶段：（n-1）A—&gt;B（把所有的n-1个盘子从A移动到B上）<br>第二阶段：n A—&gt;C（把最底下的n号盘从A移动到C上）<br>第三阶段：（n-1）B—&gt;C（把n-1个盘子从B移动到C上）</p><h1 id="直线分割平面问题"><a href="#直线分割平面问题" class="headerlink" title="直线分割平面问题"></a>直线分割平面问题</h1><p>n条直线最多分割平面为几部分，记为L(n)。所以。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%888.57.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>边界条件为L(0)=1。得。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%888.58.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这题有个扩展，n个V型最多分割平面为几部分？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将V型补全（红色虚线部分），那么就转化为了2n条直线划分平面数，那么n个V型划分数只要减去2n就行了，所以答案为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8810.15.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h1><p>约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。<br>书中的例子是每隔一个人杀死一个。J（n）是最后一个幸存者的位置。</p><p>分两种情况讨论：<br>当有2n个人时，踢掉n个人之后，情况如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>观察发现一圈当中的对应位置相同，且左图的数字为右图数字*2-1。所以最后幸存者的位置也有着相同的关系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8810.59.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同理，当有2n+1个人时，踢掉n+1个人之后<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>观察对应关系可以得出<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8811.00.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>边界条件为，J(1)=1。<br>这个递推式很难求解，但是枚举出前面几项可以发现，如果令n=2的m次方+l，其中2的m次方是小于等于n的最大2的幂，那么<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8811.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将n写成二进制可以发现，f(n)就是n的二进制循环左移1位。如n=10，即1010，f(10)=0101=5。<br>现在将其推广到一般形式，原始的式子中α=1，β=-1，r=1。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.29.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由此可见可以设<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.29.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.31.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.30.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过观察得出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.32.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将递推式继续推广：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.39.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以得到解为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.40.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>具体为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/WechatIMG11543844531_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="递推式求和"><a href="#递推式求和" class="headerlink" title="递推式求和"></a>递推式求和</h1><p>使用成套方法。<br>成套方法的一般步骤是：寻求一组已知其解的通用参数，然后将特殊情况组合起来得到一般的情形，<br>有多少个独立的参数就需要多少个独立的特解。<br>求解如下递推式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用成套方法求解，设<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.45.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.46.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于更复杂得递推式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.25.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样设<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.26.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.31.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;汉诺塔问题&quot;&gt;&lt;a href=&quot;#汉诺塔问题&quot; class=&quot;headerlink&quot; title=&quot;汉诺塔问题&quot;&gt;&lt;/a&gt;汉诺塔问题&lt;/h1&gt;&lt;p&gt;3个柱子的汉诺塔问题，最少移动次数记为T(n)。&lt;br&gt;T(n)=2T(n−1)+1&lt;br&gt;边界条件为T(0)=0。
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SVM</title>
    <link href="https://github.com/zdkswd/2018/11/28/SVM/"/>
    <id>https://github.com/zdkswd/2018/11/28/SVM/</id>
    <published>2018-11-28T12:48:47.000Z</published>
    <updated>2018-12-02T11:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>已修改</p><h1 id="统计学习方法-支持向量机"><a href="#统计学习方法-支持向量机" class="headerlink" title="统计学习方法 支持向量机"></a>统计学习方法 支持向量机</h1><p>支持向量机（support vector machines,SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。</p><p>支持向量机学习方法包括构建由简至繁的模型：线性可分支持向量机（linear support vector machine in linearly separable case），线性支持向量机（linear support vector machine）及非线性支持向量机（non-linear support vector machine）。简单的模型是复杂模型的基础，也是复杂模型的特殊情况。当训练数据线性可分时，通过硬间隔最大化（hard margin maximization），学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；当训练数据近似线性可分时，通过软间隔最大化（soft margin maximization），也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；当训练数据线性不可分时，通过使用核技巧（kernel trick）及软间隔最大化，学习非线性支持向量机。</p><p>当输入空间为欧式空间或离散集合、特征空间为希尔贝特空间时，核函数（kernel function）表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。这样的方法称为核技巧。<strong>核方法（kernel method）是比支持向量机更为一般的机器学习方法。</strong></p><h2 id="线性可分支持向量机与硬间隔最大化"><a href="#线性可分支持向量机与硬间隔最大化" class="headerlink" title="线性可分支持向量机与硬间隔最大化"></a>线性可分支持向量机与硬间隔最大化</h2><h3 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h3><p>考虑一个二类分类问题。假设输入空间与特征空间为两个不同的空间。输入空间为欧式空间或离散集合，特征空间为欧式空间或希尔伯特空间，线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应，并将输入空间的输入映射为特征空间中的特征向量。非线性支持向量机利用一个从输入空间到特征空间的非线性映射将输入映射为特征向量。支持向量机的学习是在特征空间进行的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.47.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定义（线性可分支持向量机）"><a href="#定义（线性可分支持向量机）" class="headerlink" title="定义（线性可分支持向量机）"></a>定义（线性可分支持向量机）</h4><p>给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.51.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.55.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>函数间隔不是距离，注意上句话中所说的“能够<strong>相对</strong>地表示”。</p><h4 id="定义（函数间隔）"><a href="#定义（函数间隔）" class="headerlink" title="定义（函数间隔）"></a>定义（函数间隔）</h4><p>对于给定的训练数据集T和超平面（w,b），定义超平<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.58.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>函数间隔可以表示分类预测的正确性及确信度。但是选择分离超平面时，只有函数间隔还不够。因为只要成比例改变w和b，如改为2w和2b，超平面并没有改变，但函数间隔却成为原来的2倍，所以应该对分离超平面的法向量w加以约束，如规范化||w||=1,使得间隔是确定的。这时函数间隔成为几何间隔。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定义（几何间隔）"><a href="#定义（几何间隔）" class="headerlink" title="定义（几何间隔）"></a>定义（几何间隔）</h4><p>对于给定的训练数据集T和超平面（w,b）,定义超平<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.18.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面.对线性可分的训练数据集而言,线性可分分离超平面有无穷多个(等价于感知机),但是几何间隔最大的分离超平面是唯一的.这里的间隔最大化又称为硬间隔最大化(与将要讨论的训练数据集近似线性可分时的软间隔最大化相对应).</p><p>间隔最大化的直观解释是;对训练数据集找到几何间隔最大的超平面意味着<br>以充分大的确信度对训练数据进行分类.也就是说,不仅将正负实例点分开,而      且对最难分的实例点(离超平面最近的点)也有足够大的确信度将它们分开.这<br>样的超平面应该对未知的新实例有很好的分类预测能力。</p><h4 id="最大间隔分离超平面"><a href="#最大间隔分离超平面" class="headerlink" title="最大间隔分离超平面"></a>最大间隔分离超平面</h4><p>考虑如何求得一个几何间隔最大的分离超平面,即最大间隔分离超平面.具体地,这个问题可以表示为下面的约束最优化问题:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.34.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>函数间隔yhat的取值并不影响最优化问题的解。事实上，假设将w和b按比例改变为λw和λb,这时函数间隔称为λyhat。函数间隔的这一改变对上面最优化问题的不等式约束没有影响，对目标函数的优化也没有影响，也就是说，它产生一<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.40.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这是一个凸二次规划(convex quadratic programming)问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.44.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>仿射函数</strong>，即最高次数为1的多项式函数。常数项为零的仿射函数称为线性函数。</p><h5 id="线性可分支持向量机学习——最大间隔法"><a href="#线性可分支持向量机学习——最大间隔法" class="headerlink" title="线性可分支持向量机学习——最大间隔法"></a>线性可分支持向量机学习——最大间隔法</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.46.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="最大间隔分离超平面的存在唯一性"><a href="#最大间隔分离超平面的存在唯一性" class="headerlink" title="最大间隔分离超平面的存在唯一性"></a>最大间隔分离超平面的存在唯一性</h4><p>线性可分训练集的最大间隔分离超平面是存在且唯一的。</p><h5 id="定理（最大间隔分离超平面的存在唯一性）"><a href="#定理（最大间隔分离超平面的存在唯一性）" class="headerlink" title="定理（最大间隔分离超平面的存在唯一性）"></a>定理（最大间隔分离超平面的存在唯一性）</h5><p>若训练数据集T线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。</p><h4 id="支持向量和间隔边界"><a href="#支持向量和间隔边界" class="headerlink" title="支持向量和间隔边界"></a>支持向量和间隔边界</h4><p>在线性可分情况下,训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量( support vector).支持向量是使约束条件式(7.14)等号成立的点,即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.24.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.25.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在决定分离超平面时只有支持向量起作用,而其他实例点并不起作用.如果移动支持向量将改变所求的解;但是如果在间隔边界以外移动其他实例点,甚至去掉这些点,则解是不会改变的.由于支持向量在确定分离超平面中起着决定性作用,所以将这种分类模型称为支持向量机.支持向量的个数一般很少,所以支持向量机由很少的“重要的”训练样本确定.</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.31.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>为了求解线性可分支持向量机的最优化问题(7.13,7.14)，将它作为原始最优化问题,应用拉格朗日对偶性,通过求解对偶问题(dual problem)得到原始问题( primal problem)的最优解,这就是线性可分支持向量机的对偶算法( dual algorithm).这样做的优点,一是对偶问题往往更容易求解;二是自然引入核函数,进而推广到非线性分类问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.35.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先构建拉格朗日函数( Lagrange function).为此,对每一个不等式约束(7.14)引进拉格朗日乘子( Lagrange multiplier )αi≥0,i=1,2,…,N,定义拉格朗日函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.39.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.42.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.47.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.48.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.50.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.52.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种算法称为线性可分支持向量机的对偶学习算法，是线性可分支持向量机学习的基本算法。</p><h4 id="算法（线性可分支持向量机学习算法）"><a href="#算法（线性可分支持向量机学习算法）" class="headerlink" title="算法（线性可分支持向量机学习算法）"></a>算法（线性可分支持向量机学习算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.06.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.07.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于线性可分问题,上述线性可分支持向量机的学习(硬间隔最大化)算法是完美的,但是,训练数据集线性可分是理想的情形.在现实问题中,训练数据集往往是线性不可分的,即在样本中出现噪声或特异点.此时,有更一般的学习算法。</p><h2 id="线性支持向量机与软间隔最大化"><a href="#线性支持向量机与软间隔最大化" class="headerlink" title="线性支持向量机与软间隔最大化"></a>线性支持向量机与软间隔最大化</h2><h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><p>线性可分问题的支持向量机学习方法,对线性不可分训练数据是不适用的,因为这时上述方法中的不等式约束并不能都成立.怎么才能将它扩展到线性不可分问题呢?这就需要修改硬间隔最大化,使其成为软间隔最大化.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了上面的思路,可以和训练数据集线性可分时一样来考虑训练数据集线性不可分时的线性支持向量机学习问题相应于硬间隔最大化,它称为软间隔最大化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.00.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定义（线性支持向量机）"><a href="#定义（线性支持向量机）" class="headerlink" title="定义（线性支持向量机）"></a>定义（线性支持向量机）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.01.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="学习的对偶算法-1"><a href="#学习的对偶算法-1" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.02.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.03.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.13.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以通过求解对偶问题而得到原始问题的解，进而确定分离超平面和决策函数.为此，就可以定理的形式叙述原始问题的最优解和对偶问题的最优解的关系.</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.19.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="算法（线性支持向量机学习算法）"><a href="#算法（线性支持向量机学习算法）" class="headerlink" title="算法（线性支持向量机学习算法）"></a>算法（线性支持向量机学习算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.21.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>符合条件的样本点上的平均值。</p><h3 id="支持向量-1"><a href="#支持向量-1" class="headerlink" title="支持向量"></a>支持向量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.25.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.27.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>目标函数的第一项是经验损失或经验风险，函数<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="序列最小最优化算法"><a href="#序列最小最优化算法" class="headerlink" title="序列最小最优化算法"></a>序列最小最优化算法</h2><p>支持向量机的学习问题可以形式化为求解凸二次规划问题，这样的图二次规划问题具有全局最优解，且有许多最优化算法可以用于这一问题的求解。但当训练样本容量很大时，这些算法往往变得非常低效，以致于无法使用。序列最小最优化算法就是一种快速实现算法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.05.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>SMO算法是一种启发式算法，其基本思路是:如果所有变量的解都满足此最优化问题的KKT条件(Karush-Kuhn-Tucker conditions),那么这个最优化问题的解就得到了。因为KKT条件是该最优化问题的充分必要条件.否则， 选择两个变量，固定其他变量，针对这两个变量构建一个二次规划问题，这个二次规划问题关于这两个变量的解应该更接近原始二次规划问题的解，因为这会使得原始二次规划问题的目标函数值变得更小.重要的是，这时子问题可以通过解析方法求解，这样就可以大大提高整个算法的计算速度.子问题有两个变量，一个是违反KKT条件最严重的那一个，另一个由约束条件自动确定.如此，SMO算法将原问题不断分解为子问题并对子问题求解，进而达到求解原问题的目的.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.13.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>整个SMO算法包括两个部分:求解两个变量二次规划的解析方法和选择变量的启发式方法.</p><h3 id="两个变量二次规划的求解方法"><a href="#两个变量二次规划的求解方法" class="headerlink" title="两个变量二次规划的求解方法"></a>两个变量二次规划的求解方法</h3><p>不失一般性，假设选择的两个变量是α1，α2，其他变量αi（i=3，4，…，N）是固定的。于是SMO的最优化问题（7.98~7.100）的子问题可以写成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.17.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.18.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了求解两个变量的二次规划问题(7.101)-(7.103)，首先分析约束条件，然后在此约束条件下求极小。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.20.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不等式约束(7.103)使得(a,a2)在盒子[0,C]x[0,C]内，等式约束(7.102)使(α1，α2)在平行于盒子[0,C]x[0,C]的对角线的直线上.因此要求的是目标函数在一条平行于对角线的线段.上的最优值.这使得两个变量的最优化问题成为实质上的单变量的最优化问题，不妨考患为变量α2的最优化问题.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.27.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.30.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.33.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="变量的选择方法"><a href="#变量的选择方法" class="headerlink" title="变量的选择方法"></a>变量的选择方法</h3><p>SMO算法在每个子问题中选择两个变量优化，其中至少一个变量是违反KKT条件的。</p><h4 id="第一个变量的选择"><a href="#第一个变量的选择" class="headerlink" title="第一个变量的选择"></a>第一个变量的选择</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="第二个变量的选择"><a href="#第二个变量的选择" class="headerlink" title="第二个变量的选择"></a>第二个变量的选择</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.42.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="计算阈值b和差值Ei"><a href="#计算阈值b和差值Ei" class="headerlink" title="计算阈值b和差值Ei"></a>计算阈值b和差值Ei</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="非线性支持向量机与核函数"><a href="#非线性支持向量机与核函数" class="headerlink" title="非线性支持向量机与核函数"></a>非线性支持向量机与核函数</h2><p>对解线性分类问题，线性分类支持向量机是一种非常有效的方法。但是，有时分类问题是非线性的，这时可以使用非线性支持向量机，其主要特点是利用核技巧(kernel trick)。核技巧不仅应用于支持向量机，而且应用于其他统计学习问题。</p><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><h4 id="非线性分类问题"><a href="#非线性分类问题" class="headerlink" title="非线性分类问题"></a>非线性分类问题</h4><p>非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题.先看<br>一个例子:如7.7 左图，是一个分类问题，图中“。”表示正实例点，“x”表示负<br>实例点. 由图可，见， 无法用直线(线性模型)将正负实例正确分开，但可以用一条椭圆曲线(非线性模型)将它们正确分开.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.29.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.28.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决这个问题.所采取的方法是进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题、对图7.7所示的例子， 通过变换，将左图中椭圆变换成右图中的直线,将非线性分类问题变换为线性分类问题.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.32.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用线性分类方法求解非线性分类问题分为两步: 首先使用一个变换将原空间的数据映射到新空间;然后在新空间里用线性分类学习方法从训练数据中学习分类模型. 核技巧就属于这样的方法.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.34.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="核函数的定义"><a href="#核函数的定义" class="headerlink" title="核函数的定义"></a>核函数的定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.18.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.19.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.20.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="核技巧在支持向量机中的应用"><a href="#核技巧在支持向量机中的应用" class="headerlink" title="核技巧在支持向量机中的应用"></a>核技巧在支持向量机中的应用</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.23.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.25.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="正定核"><a href="#正定核" class="headerlink" title="正定核"></a>正定核</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.29.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="定理（正定核的充要条件）"><a href="#定理（正定核的充要条件）" class="headerlink" title="定理（正定核的充要条件）"></a>定理（正定核的充要条件）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.32.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>定理给出了正定核的充要条件，因此可以作为正定核，即核函数的另一定义。</p><h4 id="定义（正定核的等价定义）"><a href="#定义（正定核的等价定义）" class="headerlink" title="定义（正定核的等价定义）"></a>定义（正定核的等价定义）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.34.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h3><h4 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.43.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.44.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="字符串核函数"><a href="#字符串核函数" class="headerlink" title="字符串核函数"></a>字符串核函数</h4><p>核函数不仅可以定义在欧氏空间上，还可以定义在离散数据的集合上.比如，字符串核是定义在字符串集合上的核函数.字符串核函数在文本分类信息检索、生物信息学等方面都有应用.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.46.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>字符串核函数k,(s,t)给出了字符串s和t中长度等于n的所有子串组成的特征向量的余弦相似度(cosine similarity).直观上，两个字符串相同的子串越多， 它们就越相似，字符串核函数的值就越大.字符串核函数可以由动态规划快速地计算.</p><h3 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h3><p>利用核技巧，可以将线性分类的学习方法应用到非线性分类问题中去.将线性支持向量机扩展到非线性支持向量机，只需将线性支持向量机对偶形式中的内积换成核函数.</p><h4 id="定义-非线性支持向量机"><a href="#定义-非线性支持向量机" class="headerlink" title="定义 非线性支持向量机"></a>定义 非线性支持向量机</h4><p>从非线性分类训练集，通过核函数与软间隔最大化，或凸二次规划(7.95~7.97)，学习得到的分类决策函数<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.52.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="算法-非线性支持向量机学习算法"><a href="#算法-非线性支持向量机学习算法" class="headerlink" title="算法 非线性支持向量机学习算法"></a>算法 非线性支持向量机学习算法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.54.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a href="https://cuijiahua.com/blog/2017/11/ml_8_svm_1.html" target="_blank" rel="noopener">机器学习实战教程（八）：支持向量机原理篇之手撕线性SVM</a></p><h2 id="决策面方程"><a href="#决策面方程" class="headerlink" title="决策面方程"></a>决策面方程</h2><p>在二维空间下一条直线的方程为y=ax+b<br>现在我们做一个小小的改变，让原来的x轴变成x1,y轴变成x2<br>x2=ax1+b<br>移项得：ax1-x2+b=0<br>将公式向量化得：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>进一步向量化，用w列向量和标量r进一步向量化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中向量w和x分别为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里w1=a,w2=-1。最初的直线方程a和b的几何意义，a表示直线的斜率，b表示截距，向量化后的直线的w和r的几何意义为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>向量w和直线的关系为垂直的，标量r的作用也没有变，依然决定了直线的截距。</p><p>将其推广到n维空间，就变成了超平面方程，公式没变，依然是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不同在于：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="“分类间隔”方程"><a href="#“分类间隔”方程" class="headerlink" title="“分类间隔”方程"></a>“分类间隔”方程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>间隔的大小实际上就是支持向量对应的样本点到决策面的距离的二倍。d的求法如下：<br>点到直线的距离距离公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>公式中的直线方程为Ax0+By0+C=0，点P的坐标为(x0,y0)。<br>将直线方程扩展到多维，求得我们现在的超平面方程，对公式进行如下变形：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个d就是”分类间隔”。其中||w||表示w的二范数，求所有元素的平方和，然后再开方。</p><h2 id="核函数与超平面"><a href="#核函数与超平面" class="headerlink" title="核函数与超平面"></a>核函数与超平面</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h2><p>1.我们的<strong>最优化问题</strong>是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们要求解的是最小化问题，所以一个直观的想法是如果我能够构造一个函数，使得该函数在可行解区域内与原目标函数完全一致，而在可行解区域外的数值非常大，甚至是无穷大，那么这个没有约束条件的新目标函数的优化问题就与原来有约束条件的原始目标函数的优化问题是等价的问题。这就是使用拉格朗日方程的目的，它将约束条件放到目标函数中，从而将有约束优化问题转换为无约束优化问题。</p><p>2.<strong>将有约束的原始目标函数转换为无约束的新构造的拉格朗日目标函数</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中αi是拉格朗日乘子，αi大于等于0，是我们构造新目标函数时引入的系数变量(我们自己设置)。现在我们令：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当样本点不满足约束条件时，即在可行解区域外：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时，我们将αi设置为正无穷，此时θ(w)显然也是正无穷。<br>当样本点满足约束条件时，即在可行解区域内：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时，显然θ(w)为原目标函数本身。我们将上述两种情况结合一下，就得到了新的目标函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时，再看我们的初衷，就是为了建立一个在可行解区域内与原目标函数相同，在可行解区域外函数值趋近于无穷大的新函数，现在我们做到了。<br>现在，我们的问题变成了求新目标函数的最小值，即：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里用p*表示这个问题的最优值，且和最初的问题是等价的。</p><p>3.<strong>将不易求解的优化问题转化为易求解的优化</strong><br>我们看一下我们的新目标函数，先求最大值，再求最小值。这样的话，我们首先就要面对带有需要求解的参数w和b的方程，而αi又是不等式约束，这个求解过程不好做。所以，我们需要使用拉格朗日函数对偶性，将最小和最大的位置交换一下，这样就变成了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>交换以后的新问题是原始问题的对偶问题，这个新问题的最优值用d<strong>来表示。而且d</strong>&lt;=p*。我们关心的是d=p的时候，这才是我们要的解。需要什么条件才能让d=p呢？首先必须满足这个优化问题是凸优化问题。其次，需要满足KKT条件。<br>求取最小值的目标函数为凸函数的一类优化问题。目标函数是凸函数我们已经知道，这个优化问题又是求最小值。所以我们的最优化问题就是凸优化问题。<br>而且KKT条件也满足了。</p><p>求解这个对偶学习问题，可以分为三个步骤：首先要让L(w,b,α)关于w和b最小化，然后求对α的极大，最后利用SMO算法求解对偶问题中的拉格朗日乘子。</p><p>4.<strong>让L(w,b,α)关于w和b最小化</strong><br>根据上述推导已知：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先固定α，要让L(w,b,α)关于w和b最小化，我们分别对w和b偏导数，令其等于0，即：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将上述结果带回L(w,b,α)得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_60.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从上面的最后一个式子，我们可以看出，此时的L(w,b,α)函数只含有一个变量，即αi。</p><p>5.<strong>对α求极大</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_61.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在我们的优化问题变成了如上的形式。对于这个问题，我们有更高效的优化算法，即序列最小优化（SMO）算法。我们通过这个优化算法能得到α，再根据α，我们就可以求解出w和b，进而求得我们最初的目的：找到超平面，即”决策平面”。</p><p>6.<strong>使用SMO算法</strong><br>步骤一：计算误差<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_106.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤二：计算上下界L和H：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_107-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤三：计算η：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_108.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤四：更新αj<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml-8-109.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤五：根据取值范围修剪αj：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_110.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤六：更新αi：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_111.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤七：更新b1和b2：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_112.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤八：根据b1和b2更新b：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_113.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h2><p>对于非线性的情况，SVM的处理方式就是选择一个核函数。简而言之：在线性不可分的情况下，SVM通过某种事先选择的非线性映射（核函数）将输入变量映到一个高维特征空间，将其变成在高维空间线性可分，在这个高维空间中构造最优分类超平面。</p><p>线性可分的情况下，可知最终的超平面方程为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将上述公式用内积来表示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于线性不可分，我们使用一个非线性映射，将数据映射到特征空间，在特征空间中使用线性学习器，分类函数变形如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中ϕ从输入空间(X)到某个特征空间(F)的映射，这意味着建立非线性学习器分为两步：首先使用一个非线性映射将数据变换到一个特征空间F；然后在特征空间使用线性学习器分类。</p><p>如果有一种方法可以在特征空间中直接计算内积 &lt;ϕ(xi),ϕ(x)&gt;，就像在原始输入点的函数中一样，就有可能将两个步骤融合到一起建立一个分线性的学习器，这样直接计算的方法称为核函数方法。</p><p>这种将内积替换成核函数的方式被称为核技巧(kernel trick)。<br>如：<br>假设已知映射函数为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>对于两个向量a1=(x1,x2)和a2=(y1,y2)有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果我们不进行映射计算，直接运算下面的公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这两个公式的计算结果是相同的。区别在于：一个是根据映射函数，映射到高维空间中，然后再根据内积的公式进行计算，计算量大；另一个则直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果，计算量小。</p><p>核函数就是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="SVM-simple"><a href="#SVM-simple" class="headerlink" title="SVM-simple"></a>SVM-simple</h2><p>简化版的SMO算法，第二个α的选择是随机的。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-simple.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-simple.py</a></p><h2 id="完整SMO算法"><a href="#完整SMO算法" class="headerlink" title="完整SMO算法"></a>完整SMO算法</h2><p>完整的SMO算法可以启发式选择第二个α值。<br>在实现SMO算法的时候，先计算η，再更新αj。为了加快第二个αj乘子的迭代速度，需要让直线的斜率增大，对于αj的更新公式，其中η值没有什么文章可做，于是只能令:max|Ei-Ej|。<br>因此，优化方法为：</p><ol><li>最外层循环，首先在样本中选择违反KKT条件的一个乘子作为最外层循环，然后用”启发式选择”选择另外一个乘子并进行这两个乘子的优化。</li><li>在非边界乘子中寻找使得 |Ei - Ej| 最大的样本<br>3.如果没有找到，则从整个样本中随机选择一个样本</li></ol><p>完整版SMO算法覆盖整个数据集进行计算，而简化版SMO算法是随机选择的。可以看出，完整版SMO算法选出的支持向量样点更多，更接近理想的分隔超平面。</p><p>对比两种算法的运算时间，结果是完整版SMO算法的速度比简化版SMO算法的速度快6倍左右。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-smo.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-smo.py</a></p><h2 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h2><p><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svmMLiA.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svmMLiA.py</a><br>高斯核函数<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从图像中我们可以看出，离中心点越近，函数值就越接近于1。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此以任意一种颜色的同心圆作为决策边界，我们都可以完成对数据集的简单非线性划分。那么问题来了，如何映射到高维空间上去呢？——————高斯核函数！ </p><h2 id="sklearn-svm-SVC"><a href="#sklearn-svm-SVC" class="headerlink" title="sklearn.svm.SVC"></a>sklearn.svm.SVC</h2><p>参数说明：<br>C:惩罚项，float类型，可选参数，默认为1.0，C越大，即对分错样本的惩罚程度越大，因此在训练样本中准确率越高，但是泛化能力降低，也就是对测试数据的分类准确率降低。相反，减小C的话，容许训练样本中有一些误分类错误样本，泛化能力强。对于训练样本带有噪声的情况，一般采用后者，把训练样本集中错误分类的样本作为噪声。</p><p>kernel：核函数类型，str类型，默认为’rbf’。可选参数为：’linear’：线性核函数，’poly’：多项式核函数，’rbf’：径像核函数/高斯核，’sigmod’：sigmod核函数，’precomputed’：核矩阵，precomputed表示自己提前计算好核函数矩阵，这时候算法内部就不再用核函数去计算核矩阵，而是直接用你给的核矩阵，核矩阵需要为n*n的。</p><p>degree：多项式核函数的阶数，int类型，可选参数，默认为3。这个参数只对多项式核函数有用，是指多项式核函数的阶数n，如果给的核函数参数是其他核函数，则会自动忽略该参数。</p><p>gamma：核函数系数，float类型，可选参数，默认为auto。只对’rbf’ ,’poly’ ,’sigmod’有效。如果gamma为auto，代表其值为样本特征数的倒数，即1/n_features。</p><p>coef0：核函数中的独立项，float类型，可选参数，默认为0.0。只有对’poly’ 和,’sigmod’核函数有用，是指其中的参数c。</p><p>probability：是否启用概率估计，bool类型，可选参数，默认为False，这必须在调用fit()之前启用，并且会fit()方法速度变慢。</p><p>shrinking：是否采用启发式收缩方式，bool类型，可选参数，默认为True。</p><p>tol：svm停止训练的误差精度，float类型，可选参数，默认为1e^-3。</p><p>cache_size：内存大小，float类型，可选参数，默认为200。指定训练所需要的内存，以MB为单位，默认为200MB。</p><p>class_weight：类别权重，dict类型或str类型，可选参数，默认为None。给每个类别分别设置不同的惩罚参数C，如果没有给，则会给所有类别都给C=1，即前面参数指出的参数C。如果给定参数’balance’，则使用y的值自动调整与输入数据中的类频率成反比的权重。</p><p>verbose：是否启用详细输出，bool类型，默认为False，此设置利用libsvm中的每个进程运行时设置，如果启用，可能无法在多线程上下文中正常工作。一般情况都设为False，不用管它。</p><p>max_iter：最大迭代次数，int类型，默认为-1，表示不限制。</p><p>decision_function_shape：决策函数类型，可选参数’ovo’和’ovr’，默认为’ovr’。’ovo’表示one vs one，’ovr’表示one vs rest。</p><p>random_state：数据洗牌时的种子值，int类型，可选参数，默认为None。伪随机数发生器的种子,在混洗数据时用于概率估计。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已修改&lt;/p&gt;
&lt;h1 id=&quot;统计学习方法-支持向量机&quot;&gt;&lt;a href=&quot;#统计学习方法-支持向量机&quot; class=&quot;headerlink&quot; title=&quot;统计学习方法 支持向量机&quot;&gt;&lt;/a&gt;统计学习方法 支持向量机&lt;/h1&gt;&lt;p&gt;支持向量机（support vecto
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯概率</title>
    <link href="https://github.com/zdkswd/2018/11/22/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/"/>
    <id>https://github.com/zdkswd/2018/11/22/贝叶斯概率/</id>
    <published>2018-11-22T08:49:47.000Z</published>
    <updated>2018-11-23T05:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>已修改</p><h1 id="人工智能课上内容"><a href="#人工智能课上内容" class="headerlink" title="人工智能课上内容"></a>人工智能课上内容</h1><p><a href="https://www.zhihu.com/question/21134457" target="_blank" rel="noopener">你对贝叶斯统计都有怎样的理解？ - 知乎</a></p><h2 id="贝叶斯概率vs经典概率"><a href="#贝叶斯概率vs经典概率" class="headerlink" title="贝叶斯概率vs经典概率"></a>贝叶斯概率vs经典概率</h2><p>关于统计推断的主张和想法，大体可以纳入到两个体系之内，其一叫频率学派，其特征是把需要推断的参数θ视作固定且未知的常数，而样本X是随机的，其着眼点在样本空间，有关的概率计算都是针对X的分布。另一派叫做贝叶斯学派，他们把参数θ视作随机变量，而样本X是固定的，其着眼点在参数空间，重视参数θ的分布，固定的操作模式是通过参数的先验分布结合样本信息得到参数的后验分布。</p><h2 id="经典概率"><a href="#经典概率" class="headerlink" title="经典概率"></a>经典概率</h2><p>即我们学习的概率论呀。<br>方法：MLE（极大似然估计）<br>认为世界是确定的。θ是唯一的。</p><h2 id="贝叶斯概率"><a href="#贝叶斯概率" class="headerlink" title="贝叶斯概率"></a>贝叶斯概率</h2><p>方法：MAP（最大后验估计）<br>频率派认为估计对象（参数）是一个未知的固定值。而贝叶斯却认为未知的参数都是随机变量。</p><p>我们要通过一些事实估计“爱因斯坦在1905年12月25日晚上八点吸烟”的真假。定义参数:，吸烟；，没吸烟。那么频率派认为，爱因斯坦有没有曾经在这时刻吸烟是事实，是取值0或者1的固定数，不能说”=1的概率是xxx”；然而贝叶斯派认为可以说“=1概率是30%”。而且随着所得资料（样本x）的增多，我们可以把这个概率加以变化，记得到的分布。这个概率其实是“信心”的含义。</p><p>后验（输出）=先验（输入）*似然（输入）</p><p>贝叶斯思想的优势<br>1、  对于某一种独立重复随机事件，如果采用最大似然法计算出两个极值点，例如99、100，此时最大似然法只会取最大值点100的概率值。但是使用贝叶斯思想，我们就可以同时考虑极值点99、100的概率。</p><p>在实际应用中，事件A的概率可能不是一成不变的（实验难以重复独立，或者事件A的概率就是随机的）。比如考虑一个人生病的概率，幼年时生病概率高，中年时生病概率低，老年时生病概率高，或者冬天生病概率高，夏天生病概率低。频率派思想认为的概率是事件A的固定属性在这些状况下就不适用。严格的来说，任何场景下你都无法保证事件A概率是固定的。</p><p>2、  频率派使用的最大似然法，只能得到概率的最大似然估计。但是通过贝叶斯公式得到概率后验分布函数后，我们可以进行各种处理，比如取概率期望，概率中位数，概率极大值等等。</p><h2 id="后验分布"><a href="#后验分布" class="headerlink" title="后验分布"></a>后验分布</h2><p>以前我们想知道一个参数，要通过大量的观测值才能得出，而且是只能得出一个参数值。而现在运用了贝叶斯统计思想，这个后验概率分布其实是一系列参数值的概率分布，再说简单点就是我们得到了许多个参数及其对应的可能性，我们只需要从中选取我们想要的值就可以了：有时我们想要概率最大的那个参数，那这就是 后验众数估计(posterior mode estimator)；有时我们想知道参数分布的中位数，那这就是 后验中位数估计(posterior median estimator);有时我们想知道的是这个参数分布的均值，那就是 后验期望估计。这三种估计没有谁好谁坏，只是提供了三种方法得出参数，看需要来选择。现在这样看来得到的参数是不是更具有说服力？</p><h2 id="先验分布"><a href="#先验分布" class="headerlink" title="先验分布"></a>先验分布</h2><p>说完了后验分布，现在就来说说先验分布。先验分布就是你在取得实验观测值以前对一个参数概率分布的 主观判断，这也就是为什么贝叶斯统计学一直不被认可的原因，统计学或者数学都是客观的，怎么能加入主观因素呢？但事实证明这样的效果会非常好！再拿掷硬币的例子来看(怎么老是拿这个举例，是有多爱钱。。。)，在扔之前你会有判断正面的概率是50%，这就是所谓的先验概率，但如果是在打赌，为了让自己的描述准确点，我们可能会说正面的概率为0.5的可能性最大，0.45的几率小点，0.4的几率再小点，0.1的几率几乎没有等等，这就形成了一个先验概率分布。</p><p>你这个硬币的材质是不均匀的，那正面的可能性是多少呢？这就让人犯糊涂了，我们想有主观判断也无从下手，于是我们就想说那就先认为0~1之间每一种的可能性都是相同的吧，也就是设置成0~1之间的均匀分布  作为先验分布吧，这就是贝叶斯统计学当中的 无信息先验(noninformative prior)！那么下面我们就通过不断掷硬币来看看，这个概率到是多少，贝叶斯过程如下： (图来自[3])<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/v2-3ef5e8c52f6257d7624dcae8496dc14c_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/v2-0fc8c439d5a4eebf0ca11b46d1b5135d_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从图中我们可以看出，0次试验的时候就是我们的先验假设——均匀分布，然后掷了第一次是正面，于是概率分布倾向于1，第二次又是正，概率是1的可能性更大了，但 注意：这时候在0.5的概率还是有的，只不过概率很小，在0.2的概率变得更小。第三次是反面，于是概率分布被修正了一下，从为1的概率最大变成了2/3左右最大(3次试验，2次正1次反当然概率是2/3的概率最大)。再下面就是进行更多次的试验，后验概率不断根据观测值在改变，当次数很大的时候，结果趋向于0.5(哈哈，结果这还是一枚普通的硬币，不过这个事件告诉我们，直觉是不可靠的，一定亲自实验才行~)。有的人会说，这还不是在大量数据下得到了正面概率为0.5嘛，有什么好稀奇的？ 注意了！画重点了！(敲黑板) 记住，不要和一个统计学家或者数学家打赌！跑题了，跑题了。。。说回来，我们上面就说到了古典概率学的弊端就是如果掷了2次都是正面，那我们就会认为正面的概率是1，而在贝叶斯统计学中，如果我们掷了2次都是正面，只能说明正面是1的可能性最大，但还是有可能为0.5, 0.6, 0.7等等的，这就是对古典统计学的一种完善和补充，于是我们也就是解释了，我们所谓的 地震的概率为5%；生病的概率为10%等等这些概率的意义了，这就是贝叶斯统计学的哲学思想。</p><p>所以贝叶斯得到的是θ的分布。</p><h2 id="贝叶斯分析"><a href="#贝叶斯分析" class="headerlink" title="贝叶斯分析"></a>贝叶斯分析</h2><p>贝叶斯分析的思路对于由证据的积累来推测一个事物发生的概率具有重大作用， 它告诉我们当我们要预测一个事物， 我们需要的是首先根据已有的经验和知识推断一个先验概率， 然后在新证据不断积累的情况下调整这个概率，整个通过积累证据来得到一个事件发生概率的过程我们称为贝叶斯分析。</p><p>贝叶斯决策如果一旦变成自动化的计算机算法， 它就是机器学习。</p><h1 id="统计学习方法-朴素贝叶斯法"><a href="#统计学习方法-朴素贝叶斯法" class="headerlink" title="统计学习方法 朴素贝叶斯法"></a>统计学习方法 朴素贝叶斯法</h1><h2 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p><strong>注意：朴素贝叶斯法与贝叶斯估计是不同的概念。</strong></p><p>朴素贝叶斯法对条件概率分布作了条件独立性的假设.由于这是一个较强的<br>假设, 朴素贝叶斯法也由此得名.具体地，条件独立性假设是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.04.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型.条件独立假设等于是说用于分类的特征在类确定的条件下都是条件独立的.这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.08.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.11.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这是朴素贝叶斯法分类的基本公式，于是，朴素贝叶斯分类器可表示为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.12.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.12.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="后验概率最大化的含义"><a href="#后验概率最大化的含义" class="headerlink" title="后验概率最大化的含义"></a>后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中.这等价于期望风险最小化.假设选择0-1损失函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.17.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.18.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.20.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="朴素贝叶斯的参数估计"><a href="#朴素贝叶斯的参数估计" class="headerlink" title="朴素贝叶斯的参数估计"></a>朴素贝叶斯的参数估计</h2><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.22.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="学习与分类算法"><a href="#学习与分类算法" class="headerlink" title="学习与分类算法"></a>学习与分类算法</h3><h4 id="朴素贝叶斯算法（naive-Bayes-algorithm）"><a href="#朴素贝叶斯算法（naive-Bayes-algorithm）" class="headerlink" title="朴素贝叶斯算法（naive  Bayes algorithm）"></a>朴素贝叶斯算法（naive  Bayes algorithm）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.23.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.24.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.24.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.27.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.28.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="西瓜书-关于朴素贝叶斯分类器的补充"><a href="#西瓜书-关于朴素贝叶斯分类器的补充" class="headerlink" title="西瓜书 关于朴素贝叶斯分类器的补充"></a>西瓜书 关于朴素贝叶斯分类器的补充</h2><p>在现实任务中朴素贝叶斯分类器有多种使用方式.例如，若任务对预测速度要求较高，则对给定训练集,可将朴素贝叶斯分类器涉及的所有概率估值事先计算好存储起来,这样在进行预测时只需“查表”即可进行判别;若任务数据更替频繁，则可采用“懒惰学习”(lazy learning) 方式，先不进行任何训练，待收到预测请求时再根据当前数据集进行概率估值;若数据不断增加，则可在现有估值基础_上，仅对新增样本的属性值所涉及的概率估值进行计数修正即可实现增量学习。</p><h1 id="西瓜书-半朴素贝叶斯分类器"><a href="#西瓜书-半朴素贝叶斯分类器" class="headerlink" title="西瓜书 半朴素贝叶斯分类器"></a>西瓜书 半朴素贝叶斯分类器</h1><p>为了降低贝叶斯公式中估计后验概率P(c|x)的困难，朴素贝叶斯分类器采用了属性条件独立性假设,但在现实任务中这个假设往往很难成立.于是，人们尝试对属性条件独立性假设进行一定程度的放松,由此产生了一类称为“半朴素贝叶斯分类器”(semi-naive Bayes clasifers)的学习方法。</p><p>半朴素贝叶斯分类器的基本思想是适当考虑一部分属性间的互相依赖信息，从而既不需要进行完全联合概率计算，又不至于彻底忽略了比较强的属性依赖关系。“独依赖估计”（One-Dependent Estimator,简称ODE）是半朴素贝叶斯分类器最常用的一种策略。顾名思义，所谓“独依赖”就是假设每个属性在类别之外最多仅依赖一个其他属性，即：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8B%E5%8D%883.34.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>于是，问题的关键就转化为如何确定每个属性的父属性，不同的做法产生不同的独依赖分类器</p><p>最直接的做法是假设所有属性都依赖同一个属性，称为“超父”（super-parent),然后通过交叉验证等模型选择方法来确定超父属性，由此形成了SPODE方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8B%E5%8D%883.45.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>按下不表</p><h1 id="西瓜书-贝叶斯网"><a href="#西瓜书-贝叶斯网" class="headerlink" title="西瓜书 贝叶斯网"></a>西瓜书 贝叶斯网</h1><p>贝叶斯网亦称“信念网”，它借助有向无环图（Directed Acyclic Graph,简称DAG）来刻画属性间的依赖关系，并使用条件概率表（Conditional Probability Table,简称CPT）来描述属性的联合概率分布。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8B%E5%8D%883.52.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>按下不表。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_15.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>P(A)称为”先验概率”（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。</p><p>P(A|B)称为”后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。</p><p>P(B|A)/P(B)称为”可能性函数”（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。</p><p>这就是贝叶斯推断的含义。我们先预估一个”先验概率”，然后加入实验结果，看这个实验到底是增强还是削弱了”先验概率”，由此得到更接近事实的”后验概率”。</p><p>在这里，如果”可能性函数”P(B|A)/P(B)&gt;1，意味着”先验概率”被增强，事件A的发生的可能性变大；如果”可能性函数”=1，意味着B事件无助于判断事件A的可能性；如果”可能性函数”&lt;1，意味着”先验概率”被削弱，事件A的可能性变小。</p><p>要知道我们只需要比较 P(H1|E)和P(H2|E)的大小，找到那个最大的概率就可以。既然如此，两者的分母都是相同的，那我们只需要比较分子即可。即比较P(E|H1)P(H1)和P(E|H2)P(H2)的大小，<strong>所以为了减少计算量，全概率公式在实际编程中可以不使用。</strong></p><p>其中P(B):<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_10.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_11.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_12.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_13.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_14.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="朴素贝叶斯推断"><a href="#朴素贝叶斯推断" class="headerlink" title="朴素贝叶斯推断"></a>朴素贝叶斯推断</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_21.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于每个特征都是独立的，我们可以进一步拆分公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_22.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/bayes.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/bayes.py</a></p><h2 id="sklearn-朴素贝叶斯"><a href="#sklearn-朴素贝叶斯" class="headerlink" title="sklearn-朴素贝叶斯"></a>sklearn-朴素贝叶斯</h2><p>在sklearn中一共有三个朴素贝叶斯分类算法类。分别是GaussianNB,MultinomialNB和BernoulliNB。其中GaussianNB就是先验为高斯分布的朴素贝叶斯，MultinomialNB就是先验为多项式分布的朴素贝叶斯，而BernoulliNB就是先验为伯努利分布的朴素贝叶斯。</p><p>对于新闻分类，属于多分类问题。我们可以使用MultinamialNB()完成我们的新闻分类问题。MultinomialNB假设特征的先验概率为多项式分布，即如下式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中， P(Xj = Xjl | Y = Ck)是第k个类别的第j维特征的第l个取值条件概率。mk是训练集中输出为第k类的样本个数。λ为一个大于0的常数，常常取值为1，即拉普拉斯平滑，也可以取其他值。</p><p>MultinamialNB这个函数，只有3个参数：<br>参数说明如下:</p><ol><li>alpha：浮点型可选参数，默认为1.0，其实就是添加拉普拉斯平滑，即为上述公式中的λ ，如果这个参数设置为0，就是不添加平滑；</li><li>fit_prior：布尔型可选参数，默认为True。布尔参数fit_prior表示是否要考虑先验概率，如果是false,则所有的样本类别输出都有相同的类别先验概率。否则可以自己用第三个参数class_prior输入先验概率，或者不输入第三个参数class_prior让MultinomialNB自己从训练集样本来计算先验概率，此时的先验概率为P(Y=Ck)=mk/m。其中m为训练集样本总数量，mk为输出为第k类别的训练集样本数。</li><li>class_prior：可选参数，默认为None。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>MultinomialNB一个重要的功能是有partial_fit方法，这个方法的一般用在如果训练集数据量非常大，一次不能全部载入内存的时候。这时我们可以把训练集分成若干等分，重复调用partial_fit来一步步的学习训练集，非常方便。GaussianNB和BernoulliNB也有类似的功能。 在使用MultinomialNB的fit方法或者partial_fit方法拟合数据后，我们可以进行预测。此时预测有三种方法，包括predict，predict_log_proba和predict_proba。predict方法就是我们最常用的预测方法，直接给出测试集的预测类别输出。predict_proba则不同，它会给出测试集样本在各个类别上预测的概率。容易理解，predict_proba预测出的各个类别概率里的最大值对应的类别，也就是predict方法得到类别。predict_log_proba和predict_proba类似，它会给出测试集样本在各个类别上预测的概率的一个对数转化。转化后predict_log_proba预测出的各个类别对数概率里的最大值对应的类别，也就是predict方法得到类别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已修改&lt;/p&gt;
&lt;h1 id=&quot;人工智能课上内容&quot;&gt;&lt;a href=&quot;#人工智能课上内容&quot; class=&quot;headerlink&quot; title=&quot;人工智能课上内容&quot;&gt;&lt;/a&gt;人工智能课上内容&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/ques
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AutoEncoder by Forest</title>
    <link href="https://github.com/zdkswd/2018/11/21/AutoEncoder%20by%20Forest/"/>
    <id>https://github.com/zdkswd/2018/11/21/AutoEncoder by Forest/</id>
    <published>2018-11-21T12:16:32.000Z</published>
    <updated>2018-11-21T12:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1709.09018" target="_blank" rel="noopener">https://arxiv.org/abs/1709.09018</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>自动编码是一个重要的任务，通常由深度神经网络比如CNN来实现。在这篇论文中，我们提出了EncoderForest （eForest）这是第一个基于树集成的自编码器。我们提出了一种方法，让森林能够利用树的决策路径所定义的等效类来进行后向重建，并在监督和无监督环境中展示了其使用情况。实验结果表明，与DNN自编码器相比，eForest能够以较快的训练速度获得更低的重建误差，同时模型本身具有可重用性和容损性。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>自动编码器是一类将输入数据映射到隐藏空间，然后再映射到原始空间的模型，它使用重建误差作为目标函数。自动编码器分为两个过程：编码和解码。编码过程将原始数据映射到隐藏空间，解码数据将数据从隐藏空间映射到原始数据空间。传统实现这两个过程的方式是使用神经网络。</p><p>文章提出了一种编码森林（EncoderForest），通过一个集成树模型进行前向编码和反向解码，而且可以使用监督或者无监督训练。实验显示EncoderFroest有如下优点:</p><ol><li>准确： 它的实验重建误差比使用MLP和CNN的自动编码器低。</li><li>有效： efroest在一个单一KNL(多核CPU)上运行比CNN-Base自动编码器在一个Titan-X GPU上运行还快。</li><li>容错率：训练好的模型能够正常运行即使模型部分损坏。</li><li>重利用： 在同一个领域下，使用一个数据集训练的模型可以直接应用到另一个数据集下。</li></ol><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>自动编码器有两个基本的功能，编码和解码。对于一个森林来说，编码并不困难，因为至少其叶节点信息可以被看做一种编码，甚至可以说，结点集合的一个子集或者路径的分支都能够为编码提供更多的信息。</p><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><p>对于给定的一个训练过的有T棵树的集成树模型（也可以是空的森林，编码过程即森林形成过程），前向编码过程将输入数据送到每棵树的根节点，并计算每棵树，得到其所属的叶节点，最后返回一个T维向量，这个T维向量的每一项是每棵树中求到的上述叶节点在树中的编号。注意，算法跟决策树的分割规则无关。只需要是T棵树即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_algo1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h2><p>一般来说，决策树都是用来前向预测，将数据计算从树的根节点到叶子结点，但是其反向重建是未定义的。下面通过一个小例子来探索解码过程。</p><p>假设我们正在解决一个二分类问题，数据有三个属性，第一个和第二个属性是数值型属性，第三个属性是布尔型属性（取值为YES, NO），第四个属性是一个三值属性，取值可以是RED，BLUE，GREEN。给定一个实例x，xi代表x的第i个属性值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_forest.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在我们只知道，实例x落在每棵树的哪个结点，上图中的红色结点，我们的目标是重构实例x。文章提出了一种简洁有效的反向重建方法。首先，在树中的每个叶子结点对应于一条唯一的从根到叶子的路径。在上面的图中已经用红色标出这样的路径。然后，每条路径都会对应一条符号规则，所以我们就得到<br>了n条（树的数目）符号规则：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_rule.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后，我们可以根据上面的规则推出MCR(最大完备规则)，最大完备规则的意思是，在规则中的每一个约束的范围不能再扩大。如果扩大，则会产生冲突。</p><p>例如，由上面的规则集我们可以得到MCR:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_mcr.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>那么显然，原始的数据肯定落在有MCR定义的范围内。</p><p>计算完MCR之后，就可以根据MCR重构原始样本了，目录型属性如上面的第三和第四属性只需要根据MCR中的指定取即可，而数值型属性则可以根据MCR中的范围取一个特殊值即可（中位数、均值、或者最大最小值）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_algo2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先根据编码完的T维向量从树中得到T个决策规则，再根据这些规则得到MCR，再根据MCR重构得到x，算法如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_algo3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_exp_image2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.09018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/abs/1709.09018&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>特征工程与表示学习,数据的粒度,数据量</title>
    <link href="https://github.com/zdkswd/2018/11/21/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0,%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B2%92%E5%BA%A6,%E6%95%B0%E6%8D%AE%E9%87%8F/"/>
    <id>https://github.com/zdkswd/2018/11/21/特征工程与表示学习,数据的粒度,数据量/</id>
    <published>2018-11-21T10:48:47.000Z</published>
    <updated>2018-11-21T10:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/41521695" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41521695</a></p><p>正因为数据表示的重要性，机器学习一般有两种思路来提升原始数据的表达</p><ol><li>特征学习(feature learning)，又叫表示学习(representation learning)或者表征学习，一般指的是自动学习有用的数据特征。</li><li>特征工程(feature engineering)，主要指对于数据的人为处理提取，有时候也代指“洗数据”。</li></ol><h1 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h1><p>模型自动对输入数据进行学习，得到更有利于使用的特征(*可能同时做出了预测)。代表的算法大致包括：</p><ol><li>深度学习，包括大部分常见的模型如CNN_RNN_DBN等。</li><li>某些无监督学习算法，如主成分分析(PCA)及自编码器（autoencoder）通过对数据转化而使得输入数据更有意义。</li><li>某些树模型可以自动的学习到数据中的特征并同时作出预测。</li></ol><h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><p>什么时候用「手工提取」什么时候用「表示学习」。一种简单的看法是，要想自动学习到数据的良好表达，就需要大量的数据。这个现象也解释了为什么「特征工程」往往在中小数据集上表现良好，而「表示学习」在大量复杂数据上更有用武之地。</p><p>比如我们会假设数据分布，会假设映射函数的性质，也会假设预测值与输入值间的关系。这一切假设其实并非凭空猜想，而是基于我们对于问题的理解，从某种角度来看，这是一种先验，是贝叶斯模型。在中小数据集上的机器学习往往使用的就是强假设模型（人类知识先验）+一个简单线性分类器。当数据愈发复杂，数据量逐渐加大后，我们对于数据的理解越来越肤浅，做出的假设也越来越倾向于随机，那么此时人工特征工程往往是有害的，而需要使用摆脱了人类先验的模型，比如深度学习或者集成模型。</p><p>模型选择的过程其实也是在衡量我们对于问题及数据的理解是否深刻，是在人类先验与数据量之间的一场博弈。从这个角度来看，深度学习首先革的是传统机器学习模型的命：最先被淘汰的不是工人，而是特定场景下的传统机器学习模型。</p><h1 id="数据的粒度"><a href="#数据的粒度" class="headerlink" title="数据的粒度"></a>数据的粒度</h1><p>数据的粒度可以理解为数据的细分程度。随着细分程度的改变，那么数据量也会有明显的变化。数据的粒度越细，数据量越大。</p><p>过于具体的数据缺失了特征，有效的特征仅在某个特定的粒度才存在。打个比方，人是由原子、分子、细胞、组织、器官构成，但在分子层面我们不一定能分辨它是人，只有到达一定的粒度才可以。因此，数据收集的第一个重点是搞清楚，在什么粒度可以解决我们的问题，而不是盲目的收集一大堆数据，或者收集过于抽象的数据。</p><h1 id="到底需要多少数据？"><a href="#到底需要多少数据？" class="headerlink" title="到底需要多少数据？"></a>到底需要多少数据？</h1><h2 id="数据量与特征量的比例"><a href="#数据量与特征量的比例" class="headerlink" title="数据量与特征量的比例"></a>数据量与特征量的比例</h2><p>谈论数据量，不能光说有多少条数据n，一定也要考虑数据的特征数m。</p><p>人们讨论数据量，往往讨论的是n，也就是有多少条数据。但这个是不准确的，因为更加适合的评估应该是n/m，也就是样本量除以特征数，原因很简单。如果你只有100条数据，但只有2个特征。如果用线性函数来拟合，相当于给你100个点来拟合到二次函数上，这个数据量一般来说是比较充裕的。但还是100个数据点，每个数据的特征数是200，那么很明显你的数据是不够的，过拟合的风险极高。</p><h2 id="特征间的相关性和有效性"><a href="#特征间的相关性和有效性" class="headerlink" title="特征间的相关性和有效性"></a>特征间的相关性和有效性</h2><p>数据间重复性低：包括样本间重复性比较低，特征间重复性比较低，即特征间线性无关</p><p>数据的有效性：此处的有效性指的是你的变量对于解决问题有帮助，而不是完全无关或者关联性极低的数据。</p><h2 id="数据是否越多越好？"><a href="#数据是否越多越好？" class="headerlink" title="数据是否越多越好？"></a>数据是否越多越好？</h2><p>数据比模型更重要，数据重要性 &gt;&gt; 模型重要性。机器学习模型的表现高度依赖于数据量，选择对的模型只是其次，因为巧妇难为无米之炊。</p><p>数据不是越多越好，随机数据中也可能因为巧合而存在某种关联。</p><h2 id="数据量与模型选择"><a href="#数据量与模型选择" class="headerlink" title="数据量与模型选择"></a>数据量与模型选择</h2><p>数据量很小，用朴素贝叶斯、逻辑回归或支持向量机<br>数据量适中或者较大，用树模型，优先 xgboost和lightgbm<br>数据量较大，尝试使用神经网络<br>所以说到底，依然不存在定式，而依赖于经验和理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41521695&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/41521695&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正因为数据表示的重
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Deep Forest: Towards An Alternative to Deep Neural Networks</title>
    <link href="https://github.com/zdkswd/2018/11/21/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/"/>
    <id>https://github.com/zdkswd/2018/11/21/Deep Forest: Towards An Alternative to Deep Neural Networks/</id>
    <published>2018-11-21T10:44:32.000Z</published>
    <updated>2018-11-21T10:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ijcai.org/proceedings/2017/0497.pdf" target="_blank" rel="noopener">https://www.ijcai.org/proceedings/2017/0497.pdf</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>提出了gcForest,一种能够与深层神经网络的表现高度抗衡的决策树集成方法。相比于深层神经网络需要化大力气调整超参数，gcForest更容易去训练。实际上，就算gcForest被应用于不同领域使用不同的数据，也可以通过设置几乎相同的超参数获得极好的表现。gcForest的训练时高效的可扩展的。在作者的实验中使用PC进行gcForest的训练和使用GPU设备进行训练时间差不多，并且效率的优势可能会比这更加明显，因为gcForest更容易并行实现。更重要的是，深层神经网络需要大规模的训练数据，但是gcForest即使只有小规模的训练数据也能表现很好。还有，作为以树为基础的方法，gcForest比深层神经网络更容易进行理论分析。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>深度神经网络的不足：</p><ol><li>需要大量数据。然而就算是大数据领域也有待带标签数据不足等问题。</li><li>模型复杂，需要强计算力设备进行训练。</li><li>最重要的是有太多超参数，学习的表现又很依赖它们。即使是使用同样的网络模型也由于各种参数设置的不同而变得实际上使用的是不同的学习模型。这让深层学习的训练变得棘手，更像是一门艺术而不是一门科学。同时由于影响的因素太多而难以理论分析深层神经网络。</li></ol><p>作者设想能不能给一些学习模型赋予一些属性让其具有深层学习网络的能力而又没有上述的不足。</p><p>所以论文提出gcForest(multi-Grained Cascade forest )</p><h1 id="k折交叉验证"><a href="#k折交叉验证" class="headerlink" title="k折交叉验证"></a>k折交叉验证</h1><p>常用的精度测试方法主要是交叉验证，例如10折交叉验证(10-fold cross validation)，将数据集分成十份，轮流将其中9份做训练1份做验证，10次的结果的均值作为对算法精度的估计，一般还需要进行多次10折交叉验证求均值，例如：10次10折交叉验证，以求更精确一点。交叉验证有时也称为交叉比对，如：10折交叉比对。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h2 id="级联森林"><a href="#级联森林" class="headerlink" title="级联森林"></a>级联森林</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305230315119.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>级联的每个级别包括两个随机森林（蓝色字体标出）和两个完全随机树木森林（黑色）。假设有三个类要预测; 因此，每个森林将输出三维类向量，然后将其连接以重新表示原始输入。注意，要将前一级的特征和这一级的特征连接在一起。</p><p>论文中为了简单起见，在实现中，使用了两个完全随机的树森林（complete-random tree forests）和两个随机森林[Breiman，2001]。每个完全随机的树森林包含1000个完全随机树[Liu et al。，2008]，每棵树通过随机选择一个特征在树的每个节点进行分割实现生成，树一直生长，直到每个叶节点只包含相同类的实例或不超过10个实例。类似地，每个随机森林也包含1000棵树，通过随机选择sqrt(d) 数量的特征作为候选（d是输入特征的数量），然后选择具有最佳 gini 值的特征作为分割。每个森林中的树的数值是一个超参数。</p><p>给定一个实例（就是一个样本），每个森林会通过计算在相关实例落入的叶节点处的不同类的训练样本的百分比，然后对森林中的所有树计平均值，以生成对类的分布的估计。如下图所示，其中红色部分突出了每个实例遍历到叶节点的路径。叶节点中的不同标记表示了不同的类。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305230948452.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>被估计的类分布形成类向量（class vector），该类向量接着与输入到级联的下一级的原始特征向量相连接。例如，假设有三个类，则四个森林每一个都将产生一个三维的类向量，因此，级联的下一级将接收12 = 3×4个增强特征（augmented feature）。</p><p>为了降低过拟合风险，每个森林产生的类向量由k折交叉验证（k-fold cross validation）产生。具体来说，每个实例都将被用作 k -1 次训练数据，产生 k -1 个类向量，然后对其取平均值以产生作为级联中下一级的增强特征的最终类向量。需要注意的是，在扩展一个新的级后，整个级联的性能将在验证集上进行估计，如果没有显着的性能增益，训练过程将终止；因此，级联中级的数量是自动确定的。与模型的复杂性固定的大多数深度神经网络相反，gcForest 能够适当地通过终止训练来决定其模型的复杂度（early stop）。这使得 gcForest 能够适用于不同规模的训练数据，而不局限于大规模训练数据。</p><h2 id="多粒度扫描（Multi-Grained-Scanning）"><a href="#多粒度扫描（Multi-Grained-Scanning）" class="headerlink" title="多粒度扫描（Multi-Grained Scanning）"></a>多粒度扫描（Multi-Grained Scanning）</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305233438302.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>滑动窗口用于扫描原始特征。假设有400个原始特征，并且使用100个特征的窗口大小。对于序列数据，将通过滑动一个特征的窗口来生成100维的特征向量；总共产生301个特征向量。如果原始特征具有空间关系，比如图像像素为400的20×20的面板，则10×10窗口将产生121个特征向量（即121个10×10的面板）。从正<em>负训练样例中提取的所有特征向量被视为正</em>负实例；它们将被用于生成类向量：从相同大小的窗口提取的实例将用于训练完全随机树森林和随机森林，然后生成类向量并连接为转换后的像素。如上图的上半部分所示，假设有3个类，并且使用100维的窗口；然后，每个森林产生301个三维类向量，导致对应于原始400维原始特征向量的1,806维变换特征向量。</p><p>通过使用多个尺寸的滑动窗口，最终的变换特征矢量将包括更多的特征，如下图所示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305234423503.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>concat成一个3618-dim的原始数据，表示原始的一个数据样本，第一级的输出是12+3618=3630，后面也是一样，直到最后第N级，只有12个输出，然后在每一类别上做avg，然后输出max那一类的label，那就是最终的预测类别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>带着深度学习的关键在于特征学习和巨大模型的能力这一认识，我们在本文中试图赋予树集成这些属性，并提出了 gcForest 方法。与深度神经网络相比，gcForest在我们的实验中表现了极高的竞争力或更好的性能。更重要的是，gcForest 具有少得多的超参数，并且对参数设置不太敏感；实际上在我们的实验中，通过使用相同的参数设置在不同的域中都获得了优异的性能，并且无论是大规模还是小规模的数据，它的工作都很好。此外，作为一种基于树的方法，gcForest 应该比深度神经网络更容易进行理论分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.ijcai.org/proceedings/2017/0497.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ijcai.org/proceedings/2017/0497.pdf&lt;
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线</title>
    <link href="https://github.com/zdkswd/2018/11/20/%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81%E7%9C%9F%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88TPR%EF%BC%89%E3%80%81%E5%81%87%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88FPR%EF%BC%89ROC%E6%9B%B2%E7%BA%BF/"/>
    <id>https://github.com/zdkswd/2018/11/20/精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线/</id>
    <published>2018-11-20T12:21:47.000Z</published>
    <updated>2018-11-23T13:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>已修改</p><h1 id="精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线"><a href="#精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线" class="headerlink" title="精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线"></a>精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线</h1><p>针对二分类问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81%E7%9C%9F%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88TPR%EF%BC%89%E3%80%81%E5%81%87%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88FPR%EF%BC%89ROC%E6%9B%B2%E7%BA%BF/314331-2023b85ae2a8d04f.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>精确率 = TP / (TP + FP)，表示返回的正例中真正例所占的比例；<br>召回率 = TP / (TP + FN)，表示返回的真正例占所有正例的比例。<br>真正类率（TPR），TPR = TP / (TP + FN)，返回的正类占所有正类的比例；（没错，跟召回率一个公式）TPR越大越好。<br>假正类率（FPR），FPR = FP / (FP + TN)，返回的负类占所有负类的比例。FPR越小越好<br>ROC curve:FPR越小越好。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81%E7%9C%9F%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88TPR%EF%BC%89%E3%80%81%E5%81%87%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88FPR%EF%BC%89ROC%E6%9B%B2%E7%BA%BF/2394427-5f11fd1e6af07393.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于ROC来说，横坐标就是FPR，而纵坐标就是TPR，因此可以想见，当 TPR越大，而FPR越小时，说明分类结果是较好的。</p><p>AUC:<br>AUC 即ROC曲线下的面积，计算方式即为ROC Curve的微积分值，其物理意义可以表示为：随机给定一正一负两个样本，将正样本排在负样本之前的概率，因此AUC越大，说明正样本越有可能被排在负样本之前，即分类的结果越好。</p><p>ROC的总结：</p><ol><li>ROC 可以反映二分类器的总体分类性能，但是无法直接从图中识别出分类最好的阈值，事实上最好的阈值也是视具体的场景所定；</li><li>ROC Curve 对应的AUC越大说明分类性能越好;</li><li>ROC曲线一定是需要在 y = x之上的，否则就是一个不理想的分类器；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已修改&lt;/p&gt;
&lt;h1 id=&quot;精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线&quot;&gt;&lt;a href=&quot;#精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线&quot; class=&quot;headerlink&quot; title=&quot;精确率、召回率、真正类率（TPR）
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GBDT+LR</title>
    <link href="https://github.com/zdkswd/2018/11/20/GBDT+LR/"/>
    <id>https://github.com/zdkswd/2018/11/20/GBDT+LR/</id>
    <published>2018-11-20T07:56:56.000Z</published>
    <updated>2018-11-20T12:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h1><p>gbdt在各种竞赛是大放异彩。原因大概有几个，一是效果确实挺不错。二是即可以用于分类也可以用于回归。三是可以筛选特征。</p><h2 id="GBDT如何选择特征"><a href="#GBDT如何选择特征" class="headerlink" title="GBDT如何选择特征"></a>GBDT如何选择特征</h2><p>gbdt选择特征的细节其实是想问你CART Tree生成的过程。这里有一个前提，gbdt的弱分类器默认选择的是CART TREE。其实也可以选择其他弱分类器的，选择的前提是低方差和高偏差。框架服从boosting 框架即可。</p><h2 id="GBDT如何构建特征"><a href="#GBDT如何构建特征" class="headerlink" title="GBDT如何构建特征"></a>GBDT如何构建特征</h2><p>其实说gbdt 能够构建特征并非很准确，gbdt 本身是不能产生特征的，但是我们可以利用gbdt去产生特征的组合。逻辑回归本身是适合处理线性可分的数据，如果我们想让逻辑回归处理非线性的数据，其中一种方式便是组合不同特征，增强逻辑回归对非线性分布的拟合能力。</p><h2 id="GBDT如何用于分类"><a href="#GBDT如何用于分类" class="headerlink" title="GBDT如何用于分类"></a>GBDT如何用于分类</h2><p>GBDT 无论用于分类还是回归一直都是使用的CART <strong>回归树</strong>。不会因为我们所选择的任务是分类任务就选用分类树。</p><h2 id="GB训练强学习器的思路"><a href="#GB训练强学习器的思路" class="headerlink" title="GB训练强学习器的思路"></a>GB训练强学习器的思路</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/20180128125923199.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.49.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.50.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.51.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="GBDT原理"><a href="#GBDT原理" class="headerlink" title="GBDT原理"></a>GBDT原理</h2><p>对于任意的基分类器都可以利用GB的思想训练一个强分类器。而把基分类器选为决策树（DT)时，就是我们常用的GBDT。 </p><p>对于回归任务，当选择的loss function为Least-square。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.53.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>伪代码为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.54.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="GBDT例"><a href="#GBDT例" class="headerlink" title="GBDT例"></a>GBDT例</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.57.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.08.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="GDBT分类篇"><a href="#GDBT分类篇" class="headerlink" title="GDBT分类篇"></a>GDBT分类篇</h2><p>对于回归和分类，其实GBDT过程简直就是一模一样的。如果说最大的不同的话，那就是在于由于loss function不同而引起的初始化不同、叶子节点取值不同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.12.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="分类例"><a href="#分类例" class="headerlink" title="分类例"></a>分类例</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.13.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.14.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.16.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.17.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.18.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.18.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.19.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.21.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>多分类：<a href="https://blog.csdn.net/qq_22238533/article/details/79199605" target="_blank" rel="noopener">GBDT原理与实践-多分类篇 - SCUT_Sam - CSDN博客</a></p><h1 id="GBDT-LR"><a href="#GBDT-LR" class="headerlink" title="GBDT+LR"></a>GBDT+LR</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CTR预估（Click-Through Rate Prediction）是互联网计算广告中的关键环节，预估准确性直接影响公司广告收入。CTR预估中用的最多的模型是LR（Logistic Regression），LR是广义线性模型，与传统线性模型相比，LR使用了Logit变换将函数值映射到0~1区间，映射后的函数值就是CTR的预估值。LR这种线性模型很容易并行化，处理上亿条训练样本不是问题，但线性模型学习能力有限，需要大量特征工程预先分析出有效的特征、特征组合，从而去间接增强LR的非线性学习能力。</p><p>LR模型中的特征组合很关键， 但又无法直接通过特征笛卡尔积解决，只能依靠人工经验，耗时耗力同时并不一定会带来效果提升。如何自动发现有效的特征、特征组合，弥补人工经验不足，缩短LR特征实验周期，是亟需解决的问题。Facebook 2014年的文章介绍了通过GBDT（Gradient Boost Decision Tree）解决LR的特征组合问题，随后Kaggle竞赛也有实践此思路，GBDT与LR融合开始引起了业界关注。</p><p>GBDT（Gradient Boost Decision Tree）是一种常用的非线性模型，它基于集成学习中的boosting思想，每次迭代都在减少残差的梯度方向新建立一颗决策树，迭代多少次就会生成多少颗决策树。GBDT的思想使其具有天然优势可以发现多种有区分性的特征以及特征组合，决策树的路径可以直接作为LR输入特征使用，省去了人工寻找特征、特征组合的步骤。这种通过GBDT生成LR特征的方式（GBDT+LR），业界已有实践（Facebook，Kaggle-2014），且效果不错，是非常值得尝试的思路。</p><p>融合前人工寻找有区分性特征（raw feature）、特征组合、融合后直接通过黑盒子（Tree模型GBDT）进行特征、特种组合的自动发现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/2127249-a81329ce18881864.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在介绍这个模型之前，我们先来介绍两个问题：</p><ol><li>为什么要使用集成的决策树模型而不是单颗的决策树模型：<br>一棵树的表达能力很弱，不足以表达多个有区分性的特征组合，多棵树的表达能力更强一些。GBDT每棵树都在学习前面棵树尚存的不足，迭代多少次就会生成多少颗树。按paper以及Kaggle竞赛中的GBDT+LR融合方式，多棵树正好满足LR每条训练样本可以通过GBDT映射成多个特征的需求。</li><li>为什么建树采用GBDT而非RF：RF也是多棵树，但从效果上有实践证明不如GBDT。且GBDT前面的树，特征分裂主要体现对多数样本有区分度的特征；后面的树，主要体现的是经过前N颗树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，思路更加合理，这应该也是用GBDT的原因。</li></ol><h2 id="GBDT-LR的结构"><a href="#GBDT-LR的结构" class="headerlink" title="GBDT+LR的结构"></a>GBDT+LR的结构</h2><p>GBDT用来对训练集提取特征作为新的训练输入数据，LR作为新训练输入数据的分类器。</p><p>具体步骤：</p><ol><li>GBDT首先对原始训练数据做训练，得到一个二分类器，当然这里也需要利用网格搜索寻找最佳参数组合。</li><li>与通常做法不同的是，当GBDT训练好做预测的时候，输出的并不是最终的二分类概率值，而是要把模型中的每棵树计算得到的预测概率值所属的叶子结点位置记为1，这样，就构造出了新的训练数据。在用GBDT构造新的训练数据时，采用的正是One-hot方法。并且由于每一弱分类器有且只有一个叶子节点输出预测结果，所以在一个具有n个弱分类器、共计m个叶子结点的GBDT中，每一条训练数据都会被转换为1*m维稀疏向量，且有n个元素为1，其余m-n 个元素全为0。</li><li>新的训练数据构造完成后，下一步就要与原始的训练数据中的label(输出)数据一并输入到Logistic Regression分类器中进行最终分类器的训练。思考一下，在对原始数据进行GBDT提取为新的数据这一操作之后，数据不仅变得稀疏，而且由于弱分类器个数，叶子结点个数的影响，可能会导致新的训练数据特征维度过大的问题，因此，在Logistic Regression这一层中，可使用正则化来减少过拟合的风险，在Facebook的论文中采用的是L1正则化。</li></ol><p>GBDT与LR的融合方式，Facebook的paper有个例子如下图2所示，图中Tree1、Tree2为通过GBDT模型学出来的两颗树，x为一条输入样本，遍历两棵树后，x样本分别落到两颗树的叶子节点上，每个叶子节点对应LR一维特征，那么通过遍历树，就得到了该样本对应的所有LR特征。由于树的每条路径，是通过最小化均方差等方法最终分割出来的有区分性路径，根据该路径得到的特征、特征组合都相对有区分性，效果理论上不会亚于人工经验的处理方式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/1473228-20180917183111311-2021770645.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>论文中GBDT的参数，树的数量最多500颗（500以上就没有提升了），每棵树的节点不多于12。</p><p>GBDT模型的特点，非常适合用来挖掘有效的特征、特征组合。业界不仅GBDT+LR融合有实践，GBDT+FM也有实践，2014 Kaggle CTR竞赛冠军就是使用GBDT+FM（因子分解机），可见，使用GBDT融合其它模型是非常值得尝试的思路。</p><h2 id="RF-LR-Xgb-LR"><a href="#RF-LR-Xgb-LR" class="headerlink" title="RF + LR ? Xgb + LR?"></a>RF + LR ? Xgb + LR?</h2><p>例如Random Forest以及Xgboost等是并不是也可以按类似的方式来构造新的训练样本呢？没错，所有这些基于树的模型都可以和Logistic Regression分类器组合。</p><p>RF也是多棵树，但从效果上有实践证明不如GBDT。且GBDT前面的树，特征分裂主要体现对多数样本有区分度的特征；后面的树，主要体现的是经过前N颗树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，思路更加合理，这应该也是用GBDT的原因。</p><h2 id="GBDT与LR融合具体方案"><a href="#GBDT与LR融合具体方案" class="headerlink" title="GBDT与LR融合具体方案"></a>GBDT与LR融合具体方案</h2><p>在CTR预估中，如何利用AD ID是一个问题。直接将AD ID作为特征建树不可行，而onehot编码过于稀疏，为每个AD ID建GBDT树，相当于发掘出区分每个广告的特征。而对于曝光不充分的样本即长尾部分，无法单独建树。</p><p>综合方案为：使用GBDT对非ID和ID分别建一类树。</p><ol><li>非ID类树：<br>不以细粒度的ID建树，此类树作为base，即这些ID一起构建GBDT。即便曝光少的广告、广告主，仍可以通过此类树得到有区分性的特征、特征组合。</li><li>ID类树：<br>以细粒度 的ID建一类树（每个ID构建GBDT），用于发现曝光充分的ID对应有区分性的特征、特征组合。</li></ol><p>如何根据GBDT建的两类树，对原始特征进行映射？当一条样本x进来之后，遍历两类树到叶子节点，得到的特征作为LR的输入。当AD曝光不充分不足以训练树时，其它树恰好作为补充。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/GBDT%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8GBDT%E6%9E%84%E9%80%A0%E6%96%B0%E7%9A%84%E7%89%B9%E5%BE%814.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过GBDT转换得到特征空间相比于原始ID低了很多。</p><h2 id="如何使用得到的特征？"><a href="#如何使用得到的特征？" class="headerlink" title="如何使用得到的特征？"></a>如何使用得到的特征？</h2><p>通过GBDT生成的特征，可直接作为LR的特征使用，省去人工处理分析特征的环节，LR的输入特征完全依赖于通过GBDT得到的特征。此思路已尝试，通过实验发现GBDT+LR在曝光充分的广告上确实有效果，但整体效果需要权衡优化各类树的使用。同时，也可考虑将GBDT生成特征与LR原有特征结合起来使用，待尝试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于样本量大的数据，线性模型具有训练速度快的特点，但线性模型学习能力限于线性可分数据，所以就需要特征工程将数据尽可能地从输入空间转换到线性可分的特征空间。GBDT与LR的融合模型，其实使用GBDT来发掘有区分度的特征以及组合特征，来替代人工组合特征</p><h1 id="GBDT-LR-代码"><a href="#GBDT-LR-代码" class="headerlink" title="GBDT + LR 代码"></a>GBDT + LR 代码</h1><h2 id="sklearn多种模型ROC比较"><a href="#sklearn多种模型ROC比较" class="headerlink" title="sklearn多种模型ROC比较"></a>sklearn多种模型ROC比较</h2><p><a href="https://github.com/zdkswd/MLcode/blob/master/scikit-learn-code/sklearn-gbdt%2Blr.py">MLcode/sklearn-gbdt+lr.py at master · zdkswd/MLcode · GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GBDT&quot;&gt;&lt;a href=&quot;#GBDT&quot; class=&quot;headerlink&quot; title=&quot;GBDT&quot;&gt;&lt;/a&gt;GBDT&lt;/h1&gt;&lt;p&gt;gbdt在各种竞赛是大放异彩。原因大概有几个，一是效果确实挺不错。二是即可以用于分类也可以用于回归。三是可以筛选特征。&lt;/p
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>提升 boosting</title>
    <link href="https://github.com/zdkswd/2018/11/16/%E6%8F%90%E5%8D%87%20boosting/"/>
    <id>https://github.com/zdkswd/2018/11/16/提升 boosting/</id>
    <published>2018-11-16T08:08:47.000Z</published>
    <updated>2018-11-16T08:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习升级版-提升"><a href="#机器学习升级版-提升" class="headerlink" title="机器学习升级版 提升"></a>机器学习升级版 提升</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.25.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.27.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>把分错的样本权值调高，把分对的样本权值调低。会存在本来已经分对的点在下次划分时被分错的情况。基本上可以避免这种情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.28.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%883.41.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对树求梯度，一个树就是一个函数的样子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%883.50.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.49.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.12.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>yhat（t-1）是前t-1棵树累加对样本的预测值，ft(x)是第t棵树对样本的预测值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.13.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.36.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.37.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>ft没什么意义，只有变成w才有意义。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.40.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.54.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>wj就是样本落在叶子节点的预测值，Gj就是落在节点的一阶梯度的加和，Hj是落在节点的二阶梯度的加和。λ是一个超参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8B%E5%8D%882.54.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XGBoost小结<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8B%E5%8D%882.58.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8B%E5%8D%883.13.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>αm是第m个分类器的权值。</p><h1 id="统计学习方法-提升方法"><a href="#统计学习方法-提升方法" class="headerlink" title="统计学习方法 提升方法"></a>统计学习方法 提升方法</h1><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><p>在概率近似正确(probably approximately correct, <strong>PAC</strong>)学习的框架中，一个概念(一个类)，如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是<strong>强可学习</strong>的;一个概念，如果存在一个多项式的学习算法能够学习它,学习的正确率仅比随机猜测略好，那么就称这个概念是<strong>弱可学习</strong>的.</p><p>如果已经发现了“弱学习算法”，将它提升(boost) 为“强学习算法”.大家知道，发现弱学习算法通常要比发现强学习算法容易得多.那么如何具体实施提升，便成为开发提升方法时所要解决的问题.关于提升方法的研究很多，有很多算法被提出.最具代表性的是AdaBoost算法。</p><p>对于分类问题而言，给定一个训练样本集，求比较粗糙的分类规则(弱分类器)要比求精确的分类规则(强分类器)容易得多.提升方法就是从弱学习算法出发， 反复学习，得到一系列弱分类器(又称为基本分类器)，然后组合这些弱分类器，构成一个强分类器.大多数的提升方法都是改变训练数据的概率分布(训练数据的权值分布)，针对不同的训练数据分布调用弱学习算法学习一系列弱分类器.</p><p>对提升方法来说，有两个问题需要回答:一是在每一轮如何改变训练数据的权值或概率分布;二是如何将弱分类器组合成一个强分类器.关于第1个问题，AdaBoost的做法是，<strong>提高</strong>那些被前一轮弱分类器<strong>错误分类样本的权值</strong>，而<strong>降低</strong>那些被<strong>正确分类样本的权值</strong>.这样一来，那些没有得到正确分类的数据，由于其权值的加大而受到后一轮的弱分类器的更大关注.于是，分类问题被一系列的弱分类器“分而治之”.至于第2个问题，即弱分类器的组合，AdaBoost 采取加权多数表决的方法.具体地，<strong>加大</strong>分类<strong>误差率小</strong>的弱分类器的<strong>权值</strong>，使其在表决中起较大的作用，<strong>减小</strong>分类<strong>误差率大</strong>的弱分类器的<strong>权值</strong>，使其在表决中起较小的作用.</p><h3 id="AdaBoost算法"><a href="#AdaBoost算法" class="headerlink" title="AdaBoost算法"></a>AdaBoost算法</h3><p>给定一个二类分类的训练数据集。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%884.52.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="算法（AdaBoost）"><a href="#算法（AdaBoost）" class="headerlink" title="算法（AdaBoost）"></a>算法（AdaBoost）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%884.53.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%884.55.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="AdaBoost的例子"><a href="#AdaBoost的例子" class="headerlink" title="AdaBoost的例子"></a>AdaBoost的例子</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.08.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.09.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.10.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="AdaBoost算法的训练误差分析"><a href="#AdaBoost算法的训练误差分析" class="headerlink" title="AdaBoost算法的训练误差分析"></a>AdaBoost算法的训练误差分析</h2><p>AdaBoost最基本的性质是它能在学习过程中不断减少训练误差，即在训练数据集上的分类误差率。</p><h3 id="定理（AdaBoost的训练误差界）"><a href="#定理（AdaBoost的训练误差界）" class="headerlink" title="定理（AdaBoost的训练误差界）"></a>定理（AdaBoost的训练误差界）</h3><p>AdaBoost算法最终分类器的训练误差界为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.21.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一定理说明，可以在每一轮选取适当的Gm使得Zm最小，从而使训练误差下降最快。对二类分类问题，有如下结果：</p><h3 id="定理（二类分类问题AdaBoost的训练误差界）"><a href="#定理（二类分类问题AdaBoost的训练误差界）" class="headerlink" title="定理（二类分类问题AdaBoost的训练误差界）"></a>定理（二类分类问题AdaBoost的训练误差界）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.24.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.24.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这表明在此条件下AdaBoost的训练误差是以指数速率下降的。这一性质当然很有吸引力。</p><p>AdaBoost算法不需要知道下界y.与早期的提升方法不同，AdaBoost具有适应性，即它能适应弱分类器各自的训练误差率。</p><h2 id="AdaBoost算法的解释"><a href="#AdaBoost算法的解释" class="headerlink" title="AdaBoost算法的解释"></a>AdaBoost算法的解释</h2><p>AdaBoost算法还有另一个解释，即可以认为AdaBoost算法是模型为加法模型、损失函数为指数函数、学习算法为前向分布算法时的二类分类学习方法。</p><h3 id="前向分布算法"><a href="#前向分布算法" class="headerlink" title="前向分布算法"></a>前向分布算法</h3><p>考虑加法模型<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.01.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中b（x;ym）为基函数，ym为基函数的参数，Bm为基函数的系数。</p><p>在给定训练数据及损失函数L（y，f（x））的条件下，学习加法模型f(x)成为损失函数极小化问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.06.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通常这是一个复杂得优化问题。前向分步算法求解这一优化问题的想法是，因为学习的是加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近目标函数式，就可以简化优化的复杂度。具体的，每步只需优化损失函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.09.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="前向分步算法"><a href="#前向分步算法" class="headerlink" title="前向分步算法"></a>前向分步算法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.12.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.14.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="前向分步算法与AdaBoost"><a href="#前向分步算法与AdaBoost" class="headerlink" title="前向分步算法与AdaBoost"></a>前向分步算法与AdaBoost</h3><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>AdaBoost算法是前向分步算法加法算法的特例。这时模型是由基本分类器组成的加法模型，损失函数是指数函数。</p><h2 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h2><p>提升树是以分类树或回归树为基本分类器的提升方法.提升树被认为是统计学习中性能最好的方法之一。</p><h3 id="提升树模型"><a href="#提升树模型" class="headerlink" title="提升树模型"></a>提升树模型</h3><p>提升方法实际采用加法模型（即基函数的线性组合）与前向分步算法。以决策树为基函数的提升方法称为提升树（boosting tree）。对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。基本分类器x&lt;v,或x&gt;v，可以看做是由一个根结点直接连接两个叶节点的简单决策树，即所谓的决策树桩。提升树模型可以表示为决策树的加法模型：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%8810.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%8810.00.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="提升树算法"><a href="#提升树算法" class="headerlink" title="提升树算法"></a>提升树算法</h3><p>提升树算法采用前向分步算法.首先确定初始提升树f0(x)=0,第m步的模型是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.12.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，fm-1(x)为当前模型，通过最小化损失函数确定下一棵决策树的参数θm。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.13.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于树的线性组合可以很好地拟合训练数据，即使数据中的输入与输出之间的关系很复杂也是如此，所以提升树是一个高功能的学习算法.</p><p>针对不同问题的提升树学习算法，其主要区别在于使用的<strong>损失函数不同</strong>.包括用<strong>平方误差损失函数</strong>的<strong>回归</strong>问题，用<strong>指数损失</strong>函数的<strong>分类</strong>问题，以及用<strong>一般损失函数</strong>的<strong>一般决策问题</strong>.</p><h4 id="基函数是分类树（二叉分类树）"><a href="#基函数是分类树（二叉分类树）" class="headerlink" title="基函数是分类树（二叉分类树）"></a>基函数是分类树（二叉分类树）</h4><p>对于基函数是分类树时，我们使用指数损失函数，此时正是AdaBoost算法的特殊情况，即将AdaBoost算法中的基分类器使用分类树即可。</p><h4 id="回归问题的提升树算法（基函数是回归树）"><a href="#回归问题的提升树算法（基函数是回归树）" class="headerlink" title="回归问题的提升树算法（基函数是回归树）"></a>回归问题的提升树算法（基函数是回归树）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.18.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.19.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.22.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.22.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.24.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h3><p>提升树利用加法模型与前向分步算法实现学习的优化过程.当损失函数是平方损失和指数损失函数时，每一步优化是很简单的.但对一一般损失函数而言，往往每一步优化并不那么容易.针对这一问题，Freidman 提出了梯度提升(gradient<br>boosting)算法，这是利用最速下降法的近似方法，其关键是利用损失函数负梯度在当前模型的值<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.27.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>作为回归问题提升树算法中的<strong>残差的近似值</strong>，拟合一个<strong>回归树</strong>。</p><h4 id="梯度提升算法"><a href="#梯度提升算法" class="headerlink" title="梯度提升算法"></a>梯度提升算法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.31.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>Bagging + 决策树 = 随机森林<br>AdaBoost + 决策树 = 提升树<br>Gradient Boosting + 决策树 = GBDT</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="AdaBoost单层决策树"><a href="#AdaBoost单层决策树" class="headerlink" title="AdaBoost单层决策树"></a>AdaBoost单层决策树</h2><p>分类问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/mL_10_12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，如果想要试着从某个坐标轴上选择一个值（即选择一条与坐标轴平行的直线）来将所有的蓝色圆点和橘色圆点分开，这显然是不可能的。这就是单层决策树难以处理的一个著名问题。通过使用多颗单层决策树，我们可以构建出一个能够对该数据集完全正确分类的分类器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/mL_10_13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>蓝横线上边的是一个类别，蓝横线下边是一个类别。显然，此时有一个蓝点分类错误，计算此时的分类误差，误差为1/5 = 0.2。这个横线与坐标轴的y轴的交点，就是我们设置的阈值，通过不断改变阈值的大小，找到使单层决策树的分类误差最小的阈值。同理，竖线也是如此，找到最佳分类的阈值，就找到了最佳单层决策树。</p><p>通过遍历，改变不同的阈值，计算最终的分类误差，找到分类误差最小的分类方式，即为我们要找的最佳单层决策树。这里lt表示less than，表示分类方式，对于小于阈值的样本点赋值为-1，gt表示greater than，也是表示分类方式，对于大于阈值的样本点赋值为-1。经过遍历，我们找到，训练好的最佳单层决策树的最小分类误差为0.2，就是对于该数据集，无论用什么样的单层决策树，分类误差最小就是0.2。这就是我们训练好的弱分类器。接下来，使用AdaBoost算法提升分类器性能，将分类误差缩短到0。此时使用AdaBoost提升分类器性能。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/AdaBoost%E5%8D%95%E5%B1%82%E5%86%B3%E7%AD%96%E6%A0%91.py">MLcode/AdaBoost单层决策树.py at master · zdkswd/MLcode · GitHub</a></p><p>通过改变样本的权值，会改变分类误差率，以选择分类误差率最小的弱选择器。</p><h2 id="scikit-learn-AdaBoost"><a href="#scikit-learn-AdaBoost" class="headerlink" title="scikit-learn AdaBoost"></a>scikit-learn AdaBoost</h2><p>sklearn.ensemble.AdaBoostClassifier共有五个参数，参数说明。</p><ol><li><strong>base_estimator</strong>:默认为<strong>DecisionTreeClassifier</strong>。理论上可以选择任何一个分类或者回归学习器，不过需要支持样本权重。AdaBoostClassifier默认使用CART分类树DecisionTreeClassifier，而AdaBoostRegressor默认使用CART回归树DecisionTreeRegressor。另外有一个要注意的点是，如果我们选择的AdaBoostClassifier算法是SAMME.R，则我们的弱分类学习器还需要支持概率预测，也就是在scikit-learn中弱分类学习器对应的预测方法除了predict还需要有predict_proba。</li><li><strong>algorithm</strong>：可选参数，默认为<strong>SAMME.R</strong>。scikit-learn实现了两种Adaboost分类算法，SAMME和SAMME.R。两者的主要区别是弱学习器权重的度量，SAMME使用对样本集分类效果作为弱学习器权重，而SAMME.R使用了对样本集分类的预测概率大小来作为弱学习器权重。由于SAMME.R使用了概率度量的连续值，迭代一般比SAMME快，因此AdaBoostClassifier的默认算法algorithm的值也是SAMME.R。我们一般使用默认的SAMME.R就够了，但是要注意的是使用了SAMME.R， 则弱分类学习器参数base_estimator必须限制使用支持概率预测的分类器。SAMME算法则没有这个限制。</li><li><strong>n_estimators</strong>：整数型，可选参数，默认为50。弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。默认是50。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。</li><li><strong>learning_rate</strong>：浮点型，可选参数，默认为1.0。每个弱学习器的权重缩减系数，取值范围为0到1，对于同样的训练集拟合效果，较小的v意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。所以这两个参数n_estimators和learning_rate要一起调参。一般来说，可以从一个小一点的v开始调参，默认是1。</li><li><strong>random_state</strong>：整数型，可选参数，默认为None。如果RandomState的实例，random_state是随机数生成器; 如果None，则随机数生成器是由np.random使用的RandomState实例。<br><a href="https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn-AdaBoost">https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn-AdaBoost</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习升级版-提升&quot;&gt;&lt;a href=&quot;#机器学习升级版-提升&quot; class=&quot;headerlink&quot; title=&quot;机器学习升级版 提升&quot;&gt;&lt;/a&gt;机器学习升级版 提升&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
           
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Practical Lessons from Predicting Clicks on Ads at Facebook</title>
    <link href="https://github.com/zdkswd/2018/11/16/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/"/>
    <id>https://github.com/zdkswd/2018/11/16/Practical Lessons from Predicting Clicks on Ads at Facebook/</id>
    <published>2018-11-16T07:48:56.000Z</published>
    <updated>2018-11-16T07:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dl.acm.org/citation.cfm?id=2648589" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=2648589</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在线广告允许广告商只投标和支付可测量的用户响应，比如广告的点击。所以，点击预测系统时大多数广告系统的中心。有超过7.5亿的日活用户和超过一百万的活跃广告商，预测Facebook广告点击是一项有挑战的机器学习任务。这篇论文介绍一个决策树加逻辑回归的组合模型，使用组合模型的效果比单独使用模型的效果提升3%，这会对整体系统的表现的提升产生重大影响。作者探索了一些基础参数怎么影响系统的最终预测表现。不出意外的是，最重要的事情是拥有正确的特征：捕获到的用户和广告的历史信息支配着其他类型的特征。一旦我们有了正确的特征和正确的模型（决策树加逻辑回归），其他的因素就影响很小（虽然小的改进在规模上很重要）。选择对数据新鲜度，学习率模式，和数据采样的最佳处理能够轻微的改变模型，但远不如一开始就选择高价值的特征或选择正确的模型。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这篇论文的目的就是分享用真实世界的数据，并且具有鲁棒性和适应性的实验中得到的见解。</p><p>Facebook由于其特殊性，不能使用搜索记录进行广告推荐，而是基于对用户的定位，所以可展示广告的量也更多。Facebook为此建立的<strong>级联分类器</strong>。这篇文章专注于级联分类器的最后一个阶段点击预测模型，就是这个模型对最终的候选广告集的广告进行预测是否会被点击。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*级联分类器*</span><br><span class="line">级联是基于几个分类器的串联的集合学习的特定情况，使用从给定分类器的输出收集的所有信息作为级联中的下一个分类器的附加信息。与投票或堆叠合奏（多专家系统）不同，级联是多阶段的。</span><br></pre></td></tr></table></figure></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>主要介绍实验计划。<br><strong>实验数据</strong>：2013年第4季度任意1周的离线训练数据，与线上数据相似。分为训练集和测试集，并且使用它们模拟在线训练和预测的流数据。论文中实验使用的都是相同的训练/测试数据。</p><p><strong>评估指标</strong>：<br><strong>Normalized Entropy</strong> （NE），NE定义为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%881.26.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中yi属于{-1，+1}，p为经验点击通过率CTR（即广告实际点击次数除以广告展示量）。NE在计算相关的信息增益时是至关重要的。上面是逻辑回归的损失函数，也就是交叉熵。下面是个常数，所以越小值，模型越好。</p><p><strong>Calibration</strong> （刻度标度）：评价估计CTR和经验CTR的比率。即预期点击次数与实际观察点击次数的比率。越接近1模型效果越好。</p><h1 id="预测模型结构"><a href="#预测模型结构" class="headerlink" title="预测模型结构"></a>预测模型结构</h1><p>评估不同的概率线性分类器和不同的在线学习算法。<br>混合模型结构：提升决策树和概率稀疏线性分类器的串联。<br>学习算法是用的是Stochastic Gradient Descent(SGD)，或者Bayesian online learning scheme for probit regression(BOPR)都可以。但是最终选择的是SGD，原因是资源消耗要小一些。<br>SGD和BOPR都可以针对单个样本进行训练，所以他们可以做成流式的学习器(stream learner)。</p><h2 id="决策树特征转换"><a href="#决策树特征转换" class="headerlink" title="决策树特征转换"></a>决策树特征转换</h2><p>对于一个样本，针对每一颗树得到一个类别型特征。该特征取值为样本在树中落入的叶节点的编号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288567782120.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上图中的提升决策树包含两棵子树，第一棵树包含3个叶节点，第二棵树包含2个叶节点。输入样本x，在两棵树种分别落入叶子节点2和叶子节点1。那么特征转换就得到特征向量[0 1 0 1 0]。也就是说，把叶节点编号进行one-hot编码。</p><p>直观的理解这种特征变化：</p><ol><li>看做是一种有监督的特征编码。把实值的vector转化为紧凑的二值的vector。</li><li>从根节点到叶节点的一条路径，表示的是在特征上的一个特定的规则。所以，叶节点的编号代表了这种规则。表征了样本中的信息，而且进行了非线性的组合变换。</li><li>最后再对叶节点编号组合，相当于学习这些规则的权重。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288712733387.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Data-freshness"><a href="#Data-freshness" class="headerlink" title="Data freshness"></a>Data freshness</h2><p>一天的数据作为训练集，其后的一天活几天作为测试数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288714646409.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以发现随着天数的增加，data freshness也变得越来越差，模型的性能也越来越差。</p><p>一种做法是说每天都重新训练。即使是mini-batch来训练，也会非常耗时。提升树的训练时间受很多因素的影响，比如：样本数量、树深度、树数量、叶子节点个数等。为了加快速度，可以在多CPU上通过并行化来实现。</p><p>我们可以：</p><ol><li>提升树可以一天或者几天来训练一次。</li><li>LR可以实现在线学习，几乎是实时训练。</li></ol><h2 id="LR线性分类器"><a href="#LR线性分类器" class="headerlink" title="LR线性分类器"></a>LR线性分类器</h2><p>针对Logistic Regression进行在线增量训练。也就是说只要用户点击了广告，生成了新的样本，就进行增量训练。</p><p>Facebook针对SGD-based online learning研究了5中学习速率的设置方式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288719387888.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ol><li>前三种使得不同的参数有不同的学习速率</li><li>后两种对于所有的参数都是用相同的学习速率<br>实验结果显示Per-coordinate learning rate效果最好： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288720145598.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="线上模型架构"><a href="#线上模型架构" class="headerlink" title="线上模型架构"></a>线上模型架构</h1>最关键的步骤就是把labels(click/no-click)和训练输入(ad impressions)以一种在线的方式连起(join)起来。所以系统被称为online data joiner。<h2 id="label标注"><a href="#label标注" class="headerlink" title="label标注"></a>label标注</h2>首先设定一个足够长的阈值。一个广告展示给用户之后，如果用户在阈值的时间内没有点击广告就标记为no-click，点击了的话就标记为click。这个等待的时间窗口需要非常小心的调整。<br>如果太长了，会增加缓存impression的内存消耗，而且影响实时数据的产生；如果太短了则会导致丢失一部分的点击样本，会影响click converage 点击覆盖。<br>click converage 点击覆盖表示有多少个点击行为被记录了下来生成了样本。online data joiner必须保证尽可能高的点击覆盖，也就是尽可能多的来记录下来所有的点击行为。但是如果等待太久就会增加缓存开销等影响。所以online data joiner必须在click converage和资源消耗之间做出平衡<h2 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288063310673.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="处理大量的训练数据"><a href="#处理大量的训练数据" class="headerlink" title="处理大量的训练数据"></a>处理大量的训练数据</h1>很多的计算广告领域的训练数据量都是非常巨大的，那么如何有效的控制训练带来的开销就非常重要。常用的办法是采样<h2 id="均匀采样"><a href="#均匀采样" class="headerlink" title="均匀采样"></a>均匀采样</h2>均匀采样非常的简单，易于实现。而且使用均匀采样没有改变训练数据的分布，所以模型不需要修改就可以直接应用于测试数据。</li></ol><p>不同采样率对模型性能的影响：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288758580098.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Negative-down-sampling"><a href="#Negative-down-sampling" class="headerlink" title="Negative down sampling"></a>Negative down sampling</h2><p>计算广告中大部分的训练样本都极度不平衡，这对模型会造成很大影响。一种解决办法就是对负样本进行欠采样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288761292102.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到采样率不同，对模型性能影响很大。采样率为0.025的时候取得最好结果。</p><h2 id="Model-Re-Calibration"><a href="#Model-Re-Calibration" class="headerlink" title="Model Re-Calibration"></a>Model Re-Calibration</h2><p>负样本欠采样可以加快训练速度并提升模型性能。但是同样带来了问题：改变了训练数据分布。所以需要进行校准。<br>举例来说，采样之前CTR均值为0.1%，使用0.01采样之后，CTR均值变为10%。我们需要对模型进行Calibration(校准)使得模型在实际预测的时候恢复成0.1%。调整公式如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288763715313.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中w是采样率，p是在采样后空间中给出的CTR预估值，计算得到的q就是修正后的结果。</p><h1 id="其他实验结果"><a href="#其他实验结果" class="headerlink" title="其他实验结果"></a>其他实验结果</h1><p>所有的这些探索都是为了能够平衡模型性能(accuracy)和资源消耗(内存、CPU)。只有当你充分了解模型和数据每个部分后，才能根据实际情况做出最佳的取舍。</p><h2 id="Number-of-boosting-trees"><a href="#Number-of-boosting-trees" class="headerlink" title="Number of boosting trees"></a>Number of boosting trees</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288739728495.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>boosting tree数量从1到2000，叶节点个数被限制为最大12个。submodel之间的区别在于训练数据大小的不同，比如submodel 2的训练数据只有前面两个的1/4。<br>可以看到随着boosting tree数量的增加，模型的性能有所提升。但是几乎所有的提升都来自于前500个trees，而后面的1000个trees的提升甚至都不到0.1%。submodel 2在1000颗trees甚至模型效果在变差，原因是过拟合。</p><h2 id="Boosting-feature-importance"><a href="#Boosting-feature-importance" class="headerlink" title="Boosting feature importance"></a>Boosting feature importance</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288742530967.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图首先对特征按照重要程度来进行排序，编号后再画图。特征重要程度按照使用该特征进行分裂，所带来的loss减小的累积量。因为一个特征可以在多颗树上进行使用，所以累积要在所有的树上进行。</p><p>上图中，黄线表示对特征进行累加后的值，然后进行log变换。可以看到最终结果是1，表示所有特征的重要度总和是1. 最重要的是期初非常陡峭，上升的非常快，说明特征重要度主要集中在top10这些特征中。前10个特征，贡献了50%的重要度，后面300个特征，贡献了1%的重要度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288746104351.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>显然，全部去掉是不行的。说明大量弱特征的累积也是很重要的，但是去掉部分不那么重要的特征，对模型的影响比较小，比如从400到200。</p><h2 id="Historical-features-VS-Context-features"><a href="#Historical-features-VS-Context-features" class="headerlink" title="Historical features VS Context features"></a>Historical features VS Context features</h2><p>针对两大类特征：历史信息特征（用户+广告）、上下文特征。论文还研究了这两类特征对模型性能的贡献程度。先给出结论：历史信息特征占主导地位。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288750694203.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样，先把特征按照重要程度排序，再画图。横轴是特征数量，纵轴是historical特征在top k个重要特征中所占的百分比。可以看到前10个特征中，全是历史信息特征；前20个特征中，只有2个上下文特征。所以：历史信息特征比上下文特征重要太多了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Facebook提出的LR + GBDT来提取非线性特征进行特征组合的方式非常经典，主要特性总结如下：</p><ol><li>Data Freshness很重要。模型至少一天需要重新训练一次</li><li>使用Boosted Decision Tree进行特征转换很大程度上提高了模型的性能</li><li>最好的在线学习方法：LR + per-coordinate learning rate</li></ol><p>关于平衡计算开销和模型性能所采用的技巧：</p><ol><li>调整Boosted decision trees数量</li><li>去掉部分重要性低的特征，对模型的影响比较小。但是不能全去掉</li><li>相比于上下文特征，用户/广告历史特征要重要的多</li><li>针对大量训练数据可以进行欠采样</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2648589&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dl.acm.org/citation.cfm?id=2648589&lt;/a&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>回归</title>
    <link href="https://github.com/zdkswd/2018/11/16/%E5%9B%9E%E5%BD%92/"/>
    <id>https://github.com/zdkswd/2018/11/16/回归/</id>
    <published>2018-11-16T04:34:47.000Z</published>
    <updated>2018-11-16T10:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习升级版-回归"><a href="#机器学习升级版-回归" class="headerlink" title="机器学习升级版 回归"></a>机器学习升级版 回归</h1><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.12.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.13.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.15.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 通过样本拟合直线，线性回归。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.27.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>做一个理论的假定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.30.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.35.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.36.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>目标函数不就是个最小二乘法了吗。</p><p>关于假设：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.39.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.40.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.41.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.49.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.59.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.06.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至于为什么要跟西塔有关，因为在震荡很大的函数中θ系数很大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.07.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Ridge是θ的平方和，LASSO是θ绝对值相加。</p><p>L2范数，L1范数与混合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.13.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>LASSO有一定的特征选择能力，随着次数的增高，高次项系数趋近于0了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.44.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>L1的形式很像拉格拉日乘子法，正方形区域内是可行域，当取最小值时，某些轴上会取0值。推广一下，轴数高了，某些权值是0，也就具有了一定选择能力。</p><p>对于L1范数中的λ，就是超参数，我们无法从样本中确定λ的值，只能通过验证数据去选。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.34.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.45.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.46.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个函数是个凸函数，解出来的一定是全局最小的。可以看到式中的求和符号，所有样本求和下降一回。BSD<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.52.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>式中没有求和符号，一个样本下降一回。SGD，适合做在线学习。适合跳出局部极小值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.58.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>mini-batchSGD，简称了SGD，其实这种叫法并不严谨。习惯用语。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%889.06.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们的线性回归是对参数的线性。对样本无所谓。</p><h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>分类问题的首选算法，多分类：softmax回归。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.14.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.25.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.32.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里的目标函数取最大值，因为是最大似然估计。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.48.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.50.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>逻辑回归是一个对数上的线性模型。 </p><p>若是想让一个几率是线性的函数，反过来求概率，就是逻辑回归的形式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.53.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>损失函数就是似然函数取负号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.19.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个损失函数不那么漂亮，我们可以把它写得漂亮一些。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.21.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.56.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>关于似然函数的解释：最靠近p的那个乘积由于是one-hot编码所以其实连乘的话只有一项就是表达式其他项均为1。<br>由于是求随机梯度下降，所以可以不管第一个求和符号，目标函数为后一部分。<br>logistic回归中式子中的1其实是e的零次方。</p><h2 id="定义信息量"><a href="#定义信息量" class="headerlink" title="定义信息量"></a>定义信息量</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>期望的结果就是信息熵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.35.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>底无所谓是几，因为有换底公式，无非就是多了个系数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.37.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> 这个图像说明当两点分布时如果概率相同，熵是最大的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.46.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.48.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.50.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="联合熵和条件熵"><a href="#联合熵和条件熵" class="headerlink" title="联合熵和条件熵"></a>联合熵和条件熵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.54.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.56.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.58.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.04.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.06.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.05.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.07.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>相对熵（relative entropy）就是KL散度（Kullback–Leibler divergence），用于衡量两个概率分布之间的差异。相对熵的特点，是只有p(x)=q(x)时，其值为0。若p(x)和q(x)略有差异，其值就会大于0。</p><p>假设我们想知道某个策略和最优策略之间的差异，我们就可以用相对熵来衡量这两者之间的差异。即，相对熵 = 某个策略的交叉熵 - 信息熵（根据系统真实分布计算而得的信息熵，为最优策略）</p><p>后半部分相当于了一个常数，相对熵达到最小值的时候，也意味着交叉熵达到了最小值。</p><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>负对数似然就等于交叉熵损失。我们可以把Logstic回归损失叫做交叉熵损失。其中p表示真实分布，q表示非真实分布。p表示真实标记的分布，q则为训练后的模型的预测标记分布。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="统计学习方法-逻辑斯蒂回归与最大熵模型"><a href="#统计学习方法-逻辑斯蒂回归与最大熵模型" class="headerlink" title="统计学习方法 逻辑斯蒂回归与最大熵模型"></a>统计学习方法 逻辑斯蒂回归与最大熵模型</h1><p>逻辑斯蒂回归与最大熵模型都属于对数线性模型。</p><h2 id="逻辑斯蒂回归模型"><a href="#逻辑斯蒂回归模型" class="headerlink" title="逻辑斯蒂回归模型"></a>逻辑斯蒂回归模型</h2><h3 id="逻辑斯蒂分布"><a href="#逻辑斯蒂分布" class="headerlink" title="逻辑斯蒂分布"></a>逻辑斯蒂分布</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设X是连续随机变量，X服从逻辑斯蒂分布时指X具有下列分布函数和密度函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%8812.43.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>u为位置参数，y&gt;0为形状参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%8812.45.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="二项逻辑斯蒂回归模型"><a href="#二项逻辑斯蒂回归模型" class="headerlink" title="二项逻辑斯蒂回归模型"></a>二项逻辑斯蒂回归模型</h3><p>二项逻辑斯蒂回归模型是一种分类模型，形式为参数化的逻辑斯蒂分布。随机变量X取值为实数，随机变量Y取值为1或0。我们通过监督学习方法来估计模型参数。</p><h4 id="定义（逻辑斯蒂回归模型）"><a href="#定义（逻辑斯蒂回归模型）" class="headerlink" title="定义（逻辑斯蒂回归模型）"></a>定义（逻辑斯蒂回归模型）</h4><p>二项逻辑斯蒂回归模型是如下的条件概率分布：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%8812.54.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>x是输入，Y取{0，1}是输出，w，b是参数，w称为权值向量，b称为偏置。对于输入实例x，逻辑回归比较两个条件概率值的大小，将x分到概率值较大的那一类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.04.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一个事件的几率（odds）指该事件发生的概率与该事件不发生的概率的比值，事件发生的概率为p，则事件的对数几率（log odds）或logit函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.11.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即输出Y=1的对数几率是由输入x的线性函数表示的模型，即逻辑斯蒂回归模型。<br>换一个角度看，考虑对输入x进行分类的线性函数wx,其值域为实数域。通过逻辑斯蒂回归模型可以将线性函数wx转换为概率：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.22.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这时，线性函数的值越接近正无穷，概率值就越接近1，线性函数的值越接近负无穷，概率值就越接近0.</p><h3 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h3><p>可以应用极大似然估计法估计模型参数，从而得到逻辑斯蒂回归模型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.41.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="多项逻辑斯蒂回归"><a href="#多项逻辑斯蒂回归" class="headerlink" title="多项逻辑斯蒂回归"></a>多项逻辑斯蒂回归</h3><p>假设离散型随机变量Y的取值集合是{1,2,…,K}，那么多项逻辑斯蒂回归模型是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.44.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>二项逻辑斯蒂回归的参数估计法也可以推广到多项逻辑斯蒂回归。</p><h2 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h2><p>最大熵原理是概率模型学习的一个准则.最大熵原理认为，学习概率模型时，在所有可能的概率模型(分布)中，熵最大的模型是最好的模型.通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中<strong>选取熵最大的模型</strong>.</p><p>假设离散随机变量X的概率分布是P（X），则其熵是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.49.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当X服从均匀分布时，熵最大。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h2 id="梯度上升算法"><a href="#梯度上升算法" class="headerlink" title="梯度上升算法"></a>梯度上升算法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>z是一个矩阵，θ是参数列向量(要求解的)，x是样本列向量(给定的数据集)。θ^T表示θ的转置。g(z)函数实现了任意实数到[0,1]的映射，这样我们的数据集([x0,x1,…,xn])，不管是大于1或者小于0，都可以映射到[0,1]区间进行分类。hθ(x)给出了输出为1的概率。比如当hθ(x)=0.7，那么说明有70%的概率输出为1。输出为0的概率是输出为1的补集，也就是30%。如果这个概率大于0.5，我们就可以说样本是正样本，否则样本是负样本。</p><p>对于正样本，概率越接近一，分类效果越好，对于负样本，1-负样本的值越接近1越好。对于正样本和负样本两个公式合二为一：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了简化问题，对表达式求对数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至此，针对一个样本的代价函数已经出来了，假定样本与样本之间相互独立，整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便得到公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%886.54.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>满足J(θ)的最大的θ值即是我们需要求解的模型。<br>由于是求最大值，所以我们需要使用梯度上升算法，也就是求负值的最小也就是梯度下降。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="逻辑回归的优缺点"><a href="#逻辑回归的优缺点" class="headerlink" title="逻辑回归的优缺点"></a>逻辑回归的优缺点</h2><p>如何凸显你是一个对逻辑回归已经非常了解的人呢。那就是用一句话概括它！逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。</p><p>逻辑回归应用到工业界中的一些优点：</p><ol><li>形式简单，模型的可解释性非常好。从特征的权重可以看到不同的特征对最后结果的影响，某个特征的权重值比较高，那么这个特征最后对结果的影响会比较大。</li><li>模型效果不错。在工程上是可以接受的（作为baseline)，如果特征工程做的好，效果不会太差，并且特征工程可以大家并行开发，大大加快开发的速度。</li><li>训练速度较快。分类的时候，计算量仅仅只和特征的数目相关。并且逻辑回归的分布式优化sgd发展比较成熟，训练的速度可以通过堆机器进一步提高，这样我们可以在短时间内迭代好几个版本的模型。</li><li>资源占用小,尤其是内存。因为只需要存储各个维度的特征值。</li><li>方便输出结果调整。逻辑回归可以很方便的得到最后的分类结果，因为输出的是每个样本的概率分数，我们可以很容易的对这些概率分数进行cutoff，也就是划分阈值(大于某个阈值的是一类，小于某个阈值的是一类)。</li></ol><p>缺点：</p><ol><li>准确率并不是很高。因为形式非常的简单(非常类似线性模型)，很难去拟合数据的真实分布。</li><li>很难处理数据不平衡的问题。</li><li>处理非线性数据较麻烦。逻辑回归在不引进其他方法的情况下，只能处理线性可分的数据，或者进一步说，处理二分类的问题。</li><li>逻辑回归本身无法筛选特征。有时候，我们会用gbdt来筛选特征，然后再上逻辑回归。</li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h2><p>评价分类的指标。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%882.40.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="差分与取对数"><a href="#差分与取对数" class="headerlink" title="差分与取对数"></a>差分与取对数</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%882.54.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%883.01.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>滑动平均值是从一个有n项的时间序列中来计算多个连续m项序列的平均值。</p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>关键词：正则化，get_Variable,sess.run<br><a href="https://github.com/zdkswd/myTensorflowExamples/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92.py">https://github.com/zdkswd/myTensorflowExamples/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92.py</a></p><h2 id="逻辑回归与Softmax回归"><a href="#逻辑回归与Softmax回归" class="headerlink" title="逻辑回归与Softmax回归"></a>逻辑回归与Softmax回归</h2><p>softmax就是多分类的逻辑回归，使用的损失函数是交叉熵，交叉熵就是负的逻辑回归的极大似然估计。<br>softmax成为了激活函数。<br><a href="https://github.com/zdkswd/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py">https://github.com/zdkswd/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py</a></p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>从博客内容可知，为了使J(θ)最大，就尽可能的分对。<br><a href="https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92</a><br>这个分类结果相当不错，从上图可以看出，只分错了几个点而已。但是，尽管例子简单切数据集很小，但是这个方法却需要大量的计算(300次乘法)。因此将对改算法稍作改进，从而减少计算量，使其可以应用于大数据集上。</p><h2 id="逻辑回归算法的改进"><a href="#逻辑回归算法的改进" class="headerlink" title="逻辑回归算法的改进"></a>逻辑回归算法的改进</h2><p>梯度上升算法在每次更新回归系数(最优参数)时，都需要遍历整个数据集。<br>假设，我们使用的数据集一共有100个样本。那么，dataMatrix就是一个100<strong>3的矩阵。每次计算h的时候，都要计算dataMatrix</strong>weights这个矩阵乘法运算，要进行100<strong>3次乘法运算和100</strong>2次加法运算。同理，更新回归系数(最优参数)weights时，也需要用到整个数据集，要进行矩阵乘法运算。总而言之，该方法处理100个左右的数据集时尚可，但如果有数十亿样本和成千上万的特征，那么该方法的计算复杂度就太高了。因此，需要对算法进行改进，我们每次更新回归系数(最优参数)的时候，能不能不用所有样本呢？一次只用一个样本点去更新回归系数(最优参数)？这样就可以有效减少计算量了，这种方法就叫做随机梯度上升算法。</p><p>算法改进的第一点在于alpha在每次迭代都会调整，并且，虽然alpha会随着迭代次数不断减小，但永远不会减小到0，因为这里还存在一个常数项。必须这样做的原因是为了保证在多次迭代之后新数据仍然具有一定的影响。如果需要处理的问题是动态变化的，那么可以适当加大上述常数项，来确保新的值获得更大的回归系数。另一点值得注意的是，在降低alpha的函数中，alpha每次减少1/(j+i)，其中j是迭代次数，i是样本点的下标。第二个改进的地方在于更新回归系数(最优参数)时，只使用一个样本点，并且选择的样本点是随机的，每次迭代不使用已经用过的样本点。这样的方法，就有效地减少了计算量，并保证了回归效果。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.py">MLcode/逻辑回归随机梯度下降.py at master · zdkswd/MLcode · GitHub</a><br>当数据集较小时，我们使用梯度上升算法<br>当数据集较大时，我们使用改进的随机梯度上升算法<br>对应的，在Sklearn中，我们就可以根据数据情况选择优化算法，比如数据较小的时候，我们使用liblinear，数据较大时，我们使用sag和saga。</p><h2 id="使用Sklearn构建Logistic回归分类器"><a href="#使用Sklearn构建Logistic回归分类器" class="headerlink" title="使用Sklearn构建Logistic回归分类器"></a>使用Sklearn构建Logistic回归分类器</h2><p>LogisticRegression这个函数，一共有14个参数：<br><a href="https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html</a><br>看文中的参数说明。<br>代码：<br><a href="https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/sklearn-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/sklearn-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、Logistic回归的优缺点<br>优点：<br>实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低。<br>缺点：<br>容易欠拟合，分类精度可能不高。<br>2、其他<br>Logistic回归的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，求解过程可以由最优化算法完成。<br>改进的一些最优化算法，比如sag。它可以在新数据到来时就完成参数更新，而不需要重新读取整个数据集来进行批量处理。<br>机器学习的一个重要问题就是如何处理缺失数据。这个问题没有标准答案，取决于实际应用中的需求。现有一些解决方案，每种方案都各有优缺点。<br>我们需要根据数据的情况，这是Sklearn的参数，以期达到更好的分类效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习升级版-回归&quot;&gt;&lt;a href=&quot;#机器学习升级版-回归&quot; class=&quot;headerlink&quot; title=&quot;机器学习升级版 回归&quot;&gt;&lt;/a&gt;机器学习升级版 回归&lt;/h1&gt;&lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;head
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>决策树和随机森林</title>
    <link href="https://github.com/zdkswd/2018/11/10/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <id>https://github.com/zdkswd/2018/11/10/决策树和随机森林/</id>
    <published>2018-11-10T12:01:47.000Z</published>
    <updated>2018-11-10T12:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习升级版-决策树和随机森林"><a href="#机器学习升级版-决策树和随机森林" class="headerlink" title="机器学习升级版 决策树和随机森林"></a>机器学习升级版 决策树和随机森林</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.26.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.29.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.31.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.32.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.50.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.55.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.55.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.21.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.22.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.24.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.25.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.28.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.31.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.32.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.44.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.50.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基于样本和特征的双重随机性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.59.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>之所以有那么多种的处理办法，是因为没有某一种是十分有效的。</p><p>CART<br>classification and regression tree</p><h1 id="统计学习方法-决策树"><a href="#统计学习方法-决策树" class="headerlink" title="统计学习方法 决策树"></a>统计学习方法 决策树</h1><p>决策树( decision tree)是一种基本的分类与回归方法。这里主要是用于分类的决策树.决策树模型呈树形结构,在分类问题中,表示基于特征对实例进行分类的过程。它可以认为是 if-then规则的集合,也可以认为是定义在特征空间与类空间上的条件概率分布。</p><p>其主要优点是模型具有可读性,分类速度快。学习时,利用训练数据根据损失函数最小化的原则建立决策树模型。预测时,对新的数据,利用决策树模型进行分类。</p><p>决策树学习通常包括3个步骤:特征选择、决策树的生成和决策树的修剪。</p><h2 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h2><h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><p>分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边( directed edge)组成。<br>结点有两种类型:内部结点( internal node)和叶结点( leaf node)。内部结点表示一个特征或属性,叶结点表示一个类。</p><p>用决策树分类,从根结点开始,对实例的某一特征进行测试,根据测试结果,将实例分配到其子结点;这时,每一个子结点对应着该特征的一个取值.如此递归地对实例进行测试并分配,直至达到叶结点.最后将实例分到叶结点的类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%884.41.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>圆代表内部节点，方框代表叶节点。</p><h3 id="决策树与if-then规则"><a href="#决策树与if-then规则" class="headerlink" title="决策树与if-then规则"></a>决策树与if-then规则</h3><p>可以将决策树看成一个 if-then规则的集合.将决策树转换成 if-then规则的过程是这样的:由决策树的根结点到叶结点的每一条路径构建一条规则;路径上内部结点的特征对应着规则的条件,而叶结点的类对应着规则的结论.决策树的路径或其对应的 if-then规则集合具有一个重要的性质:互斥并且完备.这就是说,每一个实例都被一条路径或一条规则所覆盖,而且只被一条路径或一条规则所覆盖.这里所谓覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p><h3 id="决策树与条件概率分布"><a href="#决策树与条件概率分布" class="headerlink" title="决策树与条件概率分布"></a>决策树与条件概率分布</h3><p>决策树还表示给定特征条件下类的条件概率分布。假设X为表示特征的随机变量,Y为表示类的随机变量,那么这个条件概率分布可以表示为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%884.49.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>X取值与给定划分下单元的集合，Y取值于类的集合。各叶节点上的条件概率往往偏向某一类，即属于某一类的概率较大。决策树分类时将该节点的实例强行分到条件概率大的那一类去。</p><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习本质上是从训练数据集中归纳出一组分类规则。与训练数据集不<br>相矛盾的决策树(即能对训练数据进行正确分类的决策树)可能有多个,也可能<br>一个也没有。我们需要的是一个与训练数据矛盾较小的决策树,同时具有很好的<br>泛化能力。</p><p>决策树学习用损失函数表示这一目标,如下所述,决策树学习的损失函数通常是正则化的极大似然函数.决策树学习的策略是以损失函数为目标函数的最小化。</p><p>当损失函数确定以后,学习问题就变为在损失函数意义下选择最优决策树的问题,因为从所有可能的决策树中选取最优决策树是NP完全问题,所以现实中决策树学习算法通常采用<strong>启发式方法</strong>,近似求解这一最优化问题.这样得到的决策树是次最优(sub- optimal)的。</p><p>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。</p><p>生成的决策树可能对训练数据有很好的分类能力,但对未知的测试数据却未必有很好的分类能力,即可能发生过拟合现象.我们需要对已生成的树自下而上进行剪枝,将树变得更简单,从而使它具有更好的泛化能力。</p><p>如果特征数量很多,也可以在决策树学习开始的时候,对特征进行选择,只留下对训练数据有足够分类能力的特征。</p><p>决策树学习算法包含特征选择、决策树的生成与决策树的剪枝过程.由于决策树表示一个条件概率分布,所以深浅不同的决策树对应着不同复杂度的概率模型.决策树的生成对应于模型的局部选择,决策树的剪枝对应于模型的全局选择.决策树的生成只考虑局部最优,相对地,决策树的剪枝则考虑全局最优。</p><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><h3 id="特征选择问题"><a href="#特征选择问题" class="headerlink" title="特征选择问题"></a>特征选择问题</h3><p>特征选择在于选取对训练数据具有分类能力的特征.这样可以提高决策树学习的效率.如果利用一个特征进行分类的结果与随机分类的结果没有很大差别,则称这个特征是没有分类能力的,经验上扔掉这样的特征对决策树学习的精度影响不大,通常特征选择的准则是<strong>信息增益</strong>或<strong>信息增益比</strong>。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><h4 id="信息增益的算法"><a href="#信息增益的算法" class="headerlink" title="信息增益的算法"></a>信息增益的算法</h4><p>输入训练集D和特征A：<br>输出：特征A对训练数据集D的信息增益g(D,A)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.38.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.39.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.44.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>A3，A4类似，最后比较各特征的信息增益值。由于特征A3的信息增益值最大，所以选择特征A3作为最优特征。</p><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><h4 id="信息增益比定义"><a href="#信息增益比定义" class="headerlink" title="信息增益比定义"></a>信息增益比定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.47.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法的<strong>核心</strong>是在决策树各个结点上应用<strong>信息增益</strong>准则选择特征,递归地构建决策树.具体方法是:从根结点( root node)开始,对结点计算所有可能的特征的信息增益,选择信息增益最大的特征作为结点的特征,由该特征的不同取值建立子结点;再对子结点递归地调用以上方法,构建决策树;直到所有特征的信息增益均很小或没有特征可以选择为止,最后得到一个决策树.ID3相当于用极大似然法进行概率模型的选择。</p><h4 id="算法（ID3算法）"><a href="#算法（ID3算法）" class="headerlink" title="算法（ID3算法）"></a>算法（ID3算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.51.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.52.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.54.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ID3算法只有树的生成，所以该算法生成的树容易产生过拟合。而且ID3还存在着不能直接处理连续型特征的问题。只有事先将连续型特征离散化，才能在ID3算法中使用，但这种转换过程会破坏连续型变量的内在特性。</p><h3 id="C4-5的生成算法"><a href="#C4-5的生成算法" class="headerlink" title="C4.5的生成算法"></a>C4.5的生成算法</h3><p>C4.5算法与ID3算法相似，C4.5算法对ID3算法进行了改进。C4.5在生成的过程中，用<strong>信息增益比</strong>来选择特征。</p><h4 id="算法（C4-5的生成算法）"><a href="#算法（C4-5的生成算法）" class="headerlink" title="算法（C4.5的生成算法）"></a>算法（C4.5的生成算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.57.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><p>决策树生成算法递归地产生决策树,直到不能继续下去为止,这样产生的树往往对训练数据的分类很准确,但对未知的测试数据的分类却没有那么准确,即出现过拟合现象.过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类,从而构建出过于复杂的决策树,解决这个问题的办法是考虑决策树的复杂度,对已生成的决策树进行简化。</p><p>在决策树学习中将已生成的树进行简化的过程称为剪枝( pruning).具体地,剪枝从已生成的树上裁掉一些子树或叶结点,并将其根结点或父结点作为新的叶结点,从而简化分类树模型。</p><p>决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。设树T的叶节点个数为|T|，t是树T的叶节点，该<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%889.18.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C（T）表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型复杂度，参数α≥0控制两者之间的影响。较大的α促使选择较简单的模型（树），较小的α促使选择较复杂的模型（树）。α=0意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。</p><p>剪枝,就是当α确定时,选择损失函数最小的模型,即损失函数最小的子树.当α值确定时,子树越大,往往与训练数据的拟合越好,但是模型的复杂度就越髙;相反,子树越小,模型的复杂度就越低,但是往往与训练数据的拟合不好,损失函数正好表示了对两者的平衡。</p><h3 id="算法（树的剪枝算法）"><a href="#算法（树的剪枝算法）" class="headerlink" title="算法（树的剪枝算法）"></a>算法（树的剪枝算法）</h3><p>输入：生成算法产生的整个树T，参数α；<br>输出：修剪后的子树Tα。</p><ol><li>计算每个结点的经验熵。</li><li>递归地从树的叶节点向上回缩。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%889.30.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="3"><li>返回2，直至不能继续为止，得到损失函数最小的子树Tα。</li></ol><p>式(515)只需考虑两个树的损失函数的差,其计算可以在局部进行,所以,决策树的剪枝算法可以由一种动态规划的算法实现。</p><h2 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h2><p>CART：classification and regression tree<br>CART算法有两步：</p><ol><li>决策树生成，基于<strong>训练数据集</strong>生成决策树，生成的决策树要<strong>尽量大</strong></li><li><p>决策树剪枝，用<strong>验证数据集</strong>对已生成的树进行剪枝并选择最优子树，这时用<strong>损失函数最小</strong>作为剪枝的标准。</p><h3 id="CART生成"><a href="#CART生成" class="headerlink" title="CART生成"></a>CART生成</h3><p>决策树的生成就是递归地构建二叉决策树的过程。对<strong>回归</strong>树用<strong>平方误差</strong>最小化准则，对<strong>分类</strong>树用<strong>基尼指数</strong>最小化准则，进行特征选择，生成二叉树。</p><h4 id="回归树的生成"><a href="#回归树的生成" class="headerlink" title="回归树的生成"></a>回归树的生成</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%889.10.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>用人话解释：回归树的原理及Python实现 - 李小文的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/43939904" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43939904</a><br>就是把连续的数据分为几个区间，问题的关键就是分割点的选取。</p><h4 id="分类树的生成"><a href="#分类树的生成" class="headerlink" title="分类树的生成"></a>分类树的生成</h4><p>分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%889.16.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>生成方法与ID3决策树类似。</p><h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><p>CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小(模型变简单)，从而能够对未知数据有更准确的预测。</p><p>CART剪枝算法由两步组成:首先从生成算法产生的决策树To底端开始不断剪枝,直到To的根结点，形成一个子树序列{T1,…,Tn};然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p><h4 id="剪枝，形成一个子树序列"><a href="#剪枝，形成一个子树序列" class="headerlink" title="剪枝，形成一个子树序列"></a>剪枝，形成一个子树序列</h4><p>在剪枝过程中，计算子树的损失函数:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.24.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>T为任意子树，C（T）为训练数据的预测误差（如基尼指数），|T|为子树的叶节点个数，α≥0为参数，Cα（T）为参数是α时的子树T的整体损失。参数α权衡训练数据的拟合程度与模型的复杂度。</p></li></ol><p>对固定的α,一定存在使损失函数C(T)最小的子树，将其表示为Tα. Tα在损失函数Cα(T)最小的意义下是最优的.容易验证这样的最优子树是唯一的.当α大的时候，最优子树Tα偏小;当α小的时候，最优子树Tα偏大. 极端情况，当α=0时，整体树是最优的，当α趋近正无穷时，根结点组成的单结点树是最优的.</p><p>从整体树T0开始剪枝，对T0的任意内部节点t，以t为单结点树的损失函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.55.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>以t为根结点的子树Tt的损失函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.56.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α=0及α充分小时，有不等式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.02.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α增大时，在某一α有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.02.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α再增大时，不等式反向。只要<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Tt与t有相同的损失函数值，而t的节点少，因此t比Tt更可取，对Tt进行剪枝。</p><p>为此，对T0中每一内部结点t，计算<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.05.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它表示剪枝后整体损失函数减少的程度.在T0中剪去g(t)最小的Tt,将得到的子<br>树作为T1，同时将最小的g(t)设为α1. T1为区间[α1,α2)的最优子树.</p><p>如此剪枝下去，直到得到根节点。在这一过程中，不断增加α的值，产生新的区间。</p><h4 id="在剪枝得到的子树序列T0-T1-…-Tn中通过交叉验证选取最优子树Tα"><a href="#在剪枝得到的子树序列T0-T1-…-Tn中通过交叉验证选取最优子树Tα" class="headerlink" title="在剪枝得到的子树序列T0,T1,…,Tn中通过交叉验证选取最优子树Tα"></a>在剪枝得到的子树序列T0,T1,…,Tn中通过交叉验证选取最优子树Tα</h4><p>具体地，利用独立的验证数据集，测试子树序列T0,T1,…,Tn中各棵子树的平方误差或基尼指数.平方误差或基尼指数最小的决策树被认为是最优的决策树.在子树序列中，每棵子树T1,T2,.,Tn都对应于一个参数α1,α2,…,αn,.所以，当最优子树Tk确定时，对应的ak也确定了，即得到最优决策树Tα。</p><h3 id="CART剪枝算法"><a href="#CART剪枝算法" class="headerlink" title="CART剪枝算法"></a>CART剪枝算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.11.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="西瓜书-树剪枝"><a href="#西瓜书-树剪枝" class="headerlink" title="西瓜书 树剪枝"></a>西瓜书 树剪枝</h1><p>可以采用留出法，即预留一部分数据用作“验证集”以进行性能评估。</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%889.49.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>预剪枝使得决策树的很多分支都没有“展开”，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间开销和测试时间开销。但在另一方面，有些分支的当前划分虽不能提高泛化性能、甚至可能导致泛化性能暂时下降，但在其基础上进行的后续划分却有可能导致性能显著提高；预剪枝基于“贪心”本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险。</p><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝先从训练集生成一颗完整决策树。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8A%E5%8D%8810.03.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8A%E5%8D%8810.03.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对比可得，后剪枝决策树通常比预剪枝决策树保留了更多的分支。一般来说，后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但后剪枝过程是在生成完全决策树之后进行的，并且要自底向上地对树中的所有非叶节点进行逐一考察，因此其训练时间开销比未剪枝决策树和预剪枝决策树都要大。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>回归树：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/1%20dt%20divide.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>回归树与线性回归的对比：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/1%20dt%20sklearn.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="西瓜书-Bagging与随机森林"><a href="#西瓜书-Bagging与随机森林" class="headerlink" title="西瓜书 Bagging与随机森林"></a>西瓜书 Bagging与随机森林</h1><p>欲得到泛化性能强的集成,集成中的个体学习器应<strong>尽可能相互独立</strong>;虽然“独立”在现实任务中无法做到，但可以设法使基学习器尽可能具有较大的差异.给定一个训练数据集,一种可能的做法是对训练样本进行采样，产生出若干个不同的子集，再从每个数据子集中训练出一个基学习器.这样，由于训练数据不同,我们获得的基学习器可望具有比较大的差异.然而，为获得好的集成，我们同时还希望个体学习器不能太差.如果采样出的每个子集都<strong>完全不同</strong>，则每个基学习器只用到了<strong>一小部分训练数据</strong>，甚至不足以进行有效学习,这显然无法确保产生出比较好的基学习器.为解决这个问题，我们可考虑使用相互有交叠的采样子集.</p><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>Bagging是并行式集成学习最著名的代表，直接基于自助采样法（bootstrap sampling）。给定包含m个样本的数据集,我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中,这样,经过m次随机采样操作,我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现，由式(2.1)可知, 初始训练集中约有63.2%的样本出现在采样集中.</p><p>我们可采样出T个含m个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合.这就是Bagging的基本流程.在对预测输出进行结合时，Bagging通常对分类任务使用简单投票法，对回归任务使用简单平均法.若分类预测时出现两个类收到同样票数的情形,则最简单的做法是随机选择一个,也可进一步考察学习器投票的置信度来确定最终胜者.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%883.16.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>自助采样过程还给Bagging带来了另一个优点:由于每个基学习器只使用了初始训练集中约63.2%的样本,剩下约36.8%的样本可用作验证集来对泛化性能进行“包外估计”。</p><p>包外样本还有许多其他用途.例如当基学习器是决策树时，可使用包外样本来辅助剪枝,或用于估计决策树中各结点的后验概率以辅助对零训练样本结点的处理;当基学习器是神经网络时，可使用包外样本来辅助早期停止以减小过拟合风险.</p><p>从偏差方差分解的角度看，Bagging主要关注降低方差，因此它在不剪枝决策树、神经网络等易受样本扰动的学习器上效用更为明显。</p><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>随机森林(Random Forest,简称RF) 是Bagging的一个扩展变体. RF在以决策树为基学习器构建Bagging集成的基础上,进一步在决策树的训练过程中引入了随机属性选择.具体来说，传统决策树在选择划分属性时是在当前结点的属性集合(假定有d个属性)中选择一个最优属性;而在RF中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含k个属性的子集，然后再从这个子集中选择一个最优属性用于划分。这里的参数k控制了随机性的引入程度。若k=d则基决策树的构建与传统决策树相同，一般，推荐k=log2d。</p><p>随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能,被誉为“代表集成学习技术水平的方法”.可以看出，随机森林对Bagging只做了小改动,但是与Bagging中基学习器的“多样性”仅通过样本扰动(通过对初始训练集采样)而来不同，随机森林中基学习器的多样性<strong>不仅来自样本扰动</strong>,还来自<strong>属性扰动</strong>，这就使得最终集成的泛化性能可通过个体学习器之间差异度的增加而进一步提升.</p><p>随机森林的收敛性与Bagging相似，起始性能往往相对较差，特别是在集成中只包含一个基学习器时。这不难理解，因为通过引入属性扰动，随机森林中个体学习器的性能往往有所降低，但是随着个体学习器数目的增加，随机森林通常会收敛到更低的泛化误差值得一提的是,随机森林的训练效率常优于Bagging,因为在个体决策树的构建过程中, Bagging使用的是“确定型”决策树,在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的“随机型”央策树则只需考察一个属性子集.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%883.41.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h2><h3 id="学习器结合的好处"><a href="#学习器结合的好处" class="headerlink" title="学习器结合的好处"></a>学习器结合的好处</h3><p>学习器结合会带来三个方面的好处：</p><ol><li>统计方面，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能会因为误选而导致泛化性能不佳，结合多个学习器则会减小这一风险。</li><li>计算方面，学习算法往往会陷入局部极小,有的局部极小点所对应的泛化性能可能很糟糕，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险。</li><li>表示方面，某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中，此时若使用单学习器则肯定无效,而通过结合多个学习器，由于相应的假设空间有所扩大，有可能学得更好的近似。<h3 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h3>对于数值型输出，最常见的就是平均法。<h4 id="简单平均法"><a href="#简单平均法" class="headerlink" title="简单平均法"></a>简单平均法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.35.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="加权平均法"><a href="#加权平均法" class="headerlink" title="加权平均法"></a>加权平均法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.35.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.35.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>加权平均法的权重一般是从训练数据中学习而得，现实任务中的训练样本通常不充分或存在噪声，这将使得学出的权重不完全可靠.尤其是对规模比较大的集成来说，要学习的权重比较多,较容易导致过拟合.因此,实验和应用均显示出，加权平均法未必一定优于简单平均法.一般而言,在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时宜使用简单平均法.<h3 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h3><h4 id="绝对多数投票法"><a href="#绝对多数投票法" class="headerlink" title="绝对多数投票法"></a>绝对多数投票法</h4>即若某标记得票过半数，则预测为该标记，否则拒绝预测。<h4 id="相对多数投票法"><a href="#相对多数投票法" class="headerlink" title="相对多数投票法"></a>相对多数投票法</h4>即预测为得票最多的标记，若同时又多个标记获最高票，则从中随机选取一个。<h4 id="加权投票法"><a href="#加权投票法" class="headerlink" title="加权投票法"></a>加权投票法</h4>与加权平均法类似。</li></ol><p>标准的绝对多数投票法提供了“拒绝预测”选项,这在可靠性要求较高的学习任务中是一个很好的机制.但若学习任务要求必须提供预测结果，则绝对多数投票法将退化为相对多数投票法.因此,在不允许拒绝预测的任务中,绝对多数、相对多数投票法统称为“多数投票法”。</p><p>硬投票：输出预测的类标记，软投票，输出一个概率估计。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.54.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.55.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>算法实现。<br>背景：贷款放贷与否<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%86%B3%E7%AD%96%E6%A0%91.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%86%B3%E7%AD%96%E6%A0%91.py</a></p><h2 id="scikit-learn决策树"><a href="#scikit-learn决策树" class="headerlink" title="scikit-learn决策树"></a>scikit-learn决策树</h2><p>使用scikit-learn实现。<br>背景：配隐形眼镜<br><a href="https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn%E5%86%B3%E7%AD%96%E6%A0%91">https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn%E5%86%B3%E7%AD%96%E6%A0%91</a></p><h2 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h2><p>关键词：<strong>CART，预剪枝，后剪枝</strong></p><p>回归树与分类树比较类似，不同的是分类树最后的决策的结果是离散型的值，回归树决策的结果是输出一个实数。实例中的实数输出（就是叶子节点）的是四个样本的平均值（四个样本是在进行预剪枝时设置的值）。</p><p>CART回归树这里使用最小总方差法选取划分特征。示例中采用的是REP（错误率降低剪枝）。还有一种方法叫做PEP（悲观剪枝）把一颗子树（具有多个叶子节点）用一个叶子节点来替代的话，比起REP剪枝法，它不需要一个单独的测试数据集。</p><p>本例中既有预剪枝又有后剪枝。一般来说都是结合着使用。</p><p>背景：连续数据的离散的点<br><a href="https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%9B%9E%E5%BD%92%E6%A0%91">https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%9B%9E%E5%BD%92%E6%A0%91</a></p><h2 id="scikit-learn随机森林"><a href="#scikit-learn随机森林" class="headerlink" title="scikit-learn随机森林"></a>scikit-learn随机森林</h2><p>待解决问题，在scikit-learn的随机森林中如何决定k值。<br><a href="https://github.com/zdkswd/MLcode/blob/master/scikit-learn-code/scikit-learn%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.py">https://github.com/zdkswd/MLcode/blob/master/scikit-learn-code/scikit-learn%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习升级版-决策树和随机森林&quot;&gt;&lt;a href=&quot;#机器学习升级版-决策树和随机森林&quot; class=&quot;headerlink&quot; title=&quot;机器学习升级版 决策树和随机森林&quot;&gt;&lt;/a&gt;机器学习升级版 决策树和随机森林&lt;/h1&gt;&lt;figure class=&quot;im
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn介绍</title>
    <link href="https://github.com/zdkswd/2018/11/08/scikit-learn%E4%BB%8B%E7%BB%8D/"/>
    <id>https://github.com/zdkswd/2018/11/08/scikit-learn介绍/</id>
    <published>2018-11-08T07:56:56.000Z</published>
    <updated>2018-11-12T09:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习：问题背景"><a href="#机器学习：问题背景" class="headerlink" title="机器学习：问题背景"></a>机器学习：问题背景</h1><p>学习问题分以下几类：</p><h2 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>聚类，密度估计等</p><h1 id="加载示例数据集"><a href="#加载示例数据集" class="headerlink" title="加载示例数据集"></a>加载示例数据集</h1><p>有几个标准数据集，鸢尾花和手写字用于分类，以及波士顿房价数据集用于回归。<br>鸢尾花与手写字数据集的导入。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.30.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>数据集就是一个字典对象，包含了所有的数据以及一些关于数据的元数据。数据存储在.data成员中，它是一个n个样本，n个特征的数组。在监督学习的问题中，因变量存在.target成员中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.37.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.41.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数据数组的形状"><a href="#数据数组的形状" class="headerlink" title="数据数组的形状"></a>数据数组的形状</h2><p>数据总是二维数组，（n_sample,n_features）的形状，即使原始数据可能有着不同的形状。在手写字识别中，每个原始例子是（8  *  8）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.48.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但是在data中变成了（1  * 64）。</p><h1 id="学习以及预测"><a href="#学习以及预测" class="headerlink" title="学习以及预测"></a>学习以及预测</h1><p>在scikit-learn中，分类器是一个实现了方法fit(x,y)和predict(T)的Python对象。</p><p>先把分类器当做是一个黑盒。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.57.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>选择模型的参数<br>在这个例子中我们是人工选择的参数，为了寻找这些参数的更好的值，我们能使用例如网格搜索和交叉验证的工具。</p><p>分类器实例拟合模型是通过传递训练集给fit方法。对于训练集，我们使用除了最后一张图片的所有图片，最后一张图片用来做预测。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.48.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>来预测：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.49.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="模型持久化"><a href="#模型持久化" class="headerlink" title="模型持久化"></a>模型持久化</h1><p>使用pickle。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.50.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用joblib，joblib在大数据方面更加高效，但是遗憾的是它只能把数据持久化到硬盘而不是字符串（搬到字符串意味着数据在内存中）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.57.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>之后可以重新加载模型（也可以在其他的Python进程中）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.59.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注意</strong>：joblib.dump和joblib.load也接收像文件一样的对象而不是文件名。</p><h1 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>除非特别指明，输入将被转换为float64:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%882.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>x是float32型，可以通过fit_transform(x)转换为float64。</p><p>回归的目标类型转化为float64，分类的目标类型保留下来。</p><h2 id="改装和更新参数"><a href="#改装和更新参数" class="headerlink" title="改装和更新参数"></a>改装和更新参数</h2><p>超参数在通过set_params()方法创建后能够更新。调用fit()函数超过一次将会重写之前fit()所学的内容。</p><h2 id="多类别vs多标签拟合"><a href="#多类别vs多标签拟合" class="headerlink" title="多类别vs多标签拟合"></a>多类别vs多标签拟合</h2><p>当使用多类别分类器，所执行的学习和预测任务取决于适合于目标数据的格式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习：问题背景&quot;&gt;&lt;a href=&quot;#机器学习：问题背景&quot; class=&quot;headerlink&quot; title=&quot;机器学习：问题背景&quot;&gt;&lt;/a&gt;机器学习：问题背景&lt;/h1&gt;&lt;p&gt;学习问题分以下几类：&lt;/p&gt;
&lt;h2 id=&quot;有监督学习&quot;&gt;&lt;a href=&quot;#有监
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
