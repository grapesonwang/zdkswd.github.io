<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-12-04T04:37:58.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>具体数学 第一章</title>
    <link href="https://github.com/zdkswd/2018/12/04/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://github.com/zdkswd/2018/12/04/具体数学 第一章/</id>
    <published>2018-12-04T04:33:32.000Z</published>
    <updated>2018-12-04T04:37:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h1><p>3个柱子的汉诺塔问题，最少移动次数记为T(n)。<br>T(n)=2T(n−1)+1<br>边界条件为T(0)=0。解出<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%888.35.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中等比数列求和公式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/7dd98d1001e93901d3c632667bec54e737d196a6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>递归<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/v2-0ff29cd5195ff3e432fef0247a798c4b_b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>移动的时候的原则就如下表示：<br>第一阶段：（n-1）A—&gt;B（把所有的n-1个盘子从A移动到B上）<br>第二阶段：n A—&gt;C（把最底下的n号盘从A移动到C上）<br>第三阶段：（n-1）B—&gt;C（把n-1个盘子从B移动到C上）</p><h1 id="直线分割平面问题"><a href="#直线分割平面问题" class="headerlink" title="直线分割平面问题"></a>直线分割平面问题</h1><p>n条直线最多分割平面为几部分，记为L(n)。所以。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%888.57.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>边界条件为L(0)=1。得。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%888.58.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这题有个扩展，n个V型最多分割平面为几部分？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将V型补全（红色虚线部分），那么就转化为了2n条直线划分平面数，那么n个V型划分数只要减去2n就行了，所以答案为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8810.15.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h1><p>约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。<br>书中的例子是每隔一个人杀死一个。J（n）是最后一个幸存者的位置。</p><p>分两种情况讨论：<br>当有2n个人时，踢掉n个人之后，情况如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>观察发现一圈当中的对应位置相同，且左图的数字为右图数字*2-1。所以最后幸存者的位置也有着相同的关系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8810.59.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同理，当有2n+1个人时，踢掉n+1个人之后<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>观察对应关系可以得出<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8811.00.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>边界条件为，J(1)=1。<br>这个递推式很难求解，但是枚举出前面几项可以发现，如果令n=2的m次方+l，其中2的m次方是小于等于n的最大2的幂，那么<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8A%E5%8D%8811.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将n写成二进制可以发现，f(n)就是n的二进制循环左移1位。如n=10，即1010，f(10)=0101=5。<br>现在将其推广到一般形式，原始的式子中α=1，β=-1，r=1。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.29.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由此可见可以设<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.29.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.31.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.30.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过观察得出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%886.32.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将递推式继续推广：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.39.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以得到解为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.40.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>具体为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/WechatIMG11543844531_.pic.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="递推式求和"><a href="#递推式求和" class="headerlink" title="递推式求和"></a>递推式求和</h1><p>使用成套方法。<br>成套方法的一般步骤是：寻求一组已知其解的通用参数，然后将特殊情况组合起来得到一般的情形，<br>有多少个独立的参数就需要多少个独立的特解。<br>求解如下递推式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用成套方法求解，设<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.45.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%20%E4%B8%8B%E5%8D%889.46.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于更复杂得递推式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.25.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样设<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.26.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%20%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%8812.31.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;汉诺塔问题&quot;&gt;&lt;a href=&quot;#汉诺塔问题&quot; class=&quot;headerlink&quot; title=&quot;汉诺塔问题&quot;&gt;&lt;/a&gt;汉诺塔问题&lt;/h1&gt;&lt;p&gt;3个柱子的汉诺塔问题，最少移动次数记为T(n)。&lt;br&gt;T(n)=2T(n−1)+1&lt;br&gt;边界条件为T(0)=0。
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SVM</title>
    <link href="https://github.com/zdkswd/2018/11/28/SVM/"/>
    <id>https://github.com/zdkswd/2018/11/28/SVM/</id>
    <published>2018-11-28T12:48:47.000Z</published>
    <updated>2018-12-02T11:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>已修改</p><h1 id="统计学习方法-支持向量机"><a href="#统计学习方法-支持向量机" class="headerlink" title="统计学习方法 支持向量机"></a>统计学习方法 支持向量机</h1><p>支持向量机（support vector machines,SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。</p><p>支持向量机学习方法包括构建由简至繁的模型：线性可分支持向量机（linear support vector machine in linearly separable case），线性支持向量机（linear support vector machine）及非线性支持向量机（non-linear support vector machine）。简单的模型是复杂模型的基础，也是复杂模型的特殊情况。当训练数据线性可分时，通过硬间隔最大化（hard margin maximization），学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；当训练数据近似线性可分时，通过软间隔最大化（soft margin maximization），也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；当训练数据线性不可分时，通过使用核技巧（kernel trick）及软间隔最大化，学习非线性支持向量机。</p><p>当输入空间为欧式空间或离散集合、特征空间为希尔贝特空间时，核函数（kernel function）表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。这样的方法称为核技巧。<strong>核方法（kernel method）是比支持向量机更为一般的机器学习方法。</strong></p><h2 id="线性可分支持向量机与硬间隔最大化"><a href="#线性可分支持向量机与硬间隔最大化" class="headerlink" title="线性可分支持向量机与硬间隔最大化"></a>线性可分支持向量机与硬间隔最大化</h2><h3 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h3><p>考虑一个二类分类问题。假设输入空间与特征空间为两个不同的空间。输入空间为欧式空间或离散集合，特征空间为欧式空间或希尔伯特空间，线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应，并将输入空间的输入映射为特征空间中的特征向量。非线性支持向量机利用一个从输入空间到特征空间的非线性映射将输入映射为特征向量。支持向量机的学习是在特征空间进行的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.47.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定义（线性可分支持向量机）"><a href="#定义（线性可分支持向量机）" class="headerlink" title="定义（线性可分支持向量机）"></a>定义（线性可分支持向量机）</h4><p>给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.51.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.55.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>函数间隔不是距离，注意上句话中所说的“能够<strong>相对</strong>地表示”。</p><h4 id="定义（函数间隔）"><a href="#定义（函数间隔）" class="headerlink" title="定义（函数间隔）"></a>定义（函数间隔）</h4><p>对于给定的训练数据集T和超平面（w,b），定义超平<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%889.58.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>函数间隔可以表示分类预测的正确性及确信度。但是选择分离超平面时，只有函数间隔还不够。因为只要成比例改变w和b，如改为2w和2b，超平面并没有改变，但函数间隔却成为原来的2倍，所以应该对分离超平面的法向量w加以约束，如规范化||w||=1,使得间隔是确定的。这时函数间隔成为几何间隔。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.12.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定义（几何间隔）"><a href="#定义（几何间隔）" class="headerlink" title="定义（几何间隔）"></a>定义（几何间隔）</h4><p>对于给定的训练数据集T和超平面（w,b）,定义超平<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.18.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面.对线性可分的训练数据集而言,线性可分分离超平面有无穷多个(等价于感知机),但是几何间隔最大的分离超平面是唯一的.这里的间隔最大化又称为硬间隔最大化(与将要讨论的训练数据集近似线性可分时的软间隔最大化相对应).</p><p>间隔最大化的直观解释是;对训练数据集找到几何间隔最大的超平面意味着<br>以充分大的确信度对训练数据进行分类.也就是说,不仅将正负实例点分开,而      且对最难分的实例点(离超平面最近的点)也有足够大的确信度将它们分开.这<br>样的超平面应该对未知的新实例有很好的分类预测能力。</p><h4 id="最大间隔分离超平面"><a href="#最大间隔分离超平面" class="headerlink" title="最大间隔分离超平面"></a>最大间隔分离超平面</h4><p>考虑如何求得一个几何间隔最大的分离超平面,即最大间隔分离超平面.具体地,这个问题可以表示为下面的约束最优化问题:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.34.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>函数间隔yhat的取值并不影响最优化问题的解。事实上，假设将w和b按比例改变为λw和λb,这时函数间隔称为λyhat。函数间隔的这一改变对上面最优化问题的不等式约束没有影响，对目标函数的优化也没有影响，也就是说，它产生一<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.40.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这是一个凸二次规划(convex quadratic programming)问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.44.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>仿射函数</strong>，即最高次数为1的多项式函数。常数项为零的仿射函数称为线性函数。</p><h5 id="线性可分支持向量机学习——最大间隔法"><a href="#线性可分支持向量机学习——最大间隔法" class="headerlink" title="线性可分支持向量机学习——最大间隔法"></a>线性可分支持向量机学习——最大间隔法</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8A%E5%8D%8810.46.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="最大间隔分离超平面的存在唯一性"><a href="#最大间隔分离超平面的存在唯一性" class="headerlink" title="最大间隔分离超平面的存在唯一性"></a>最大间隔分离超平面的存在唯一性</h4><p>线性可分训练集的最大间隔分离超平面是存在且唯一的。</p><h5 id="定理（最大间隔分离超平面的存在唯一性）"><a href="#定理（最大间隔分离超平面的存在唯一性）" class="headerlink" title="定理（最大间隔分离超平面的存在唯一性）"></a>定理（最大间隔分离超平面的存在唯一性）</h5><p>若训练数据集T线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。</p><h4 id="支持向量和间隔边界"><a href="#支持向量和间隔边界" class="headerlink" title="支持向量和间隔边界"></a>支持向量和间隔边界</h4><p>在线性可分情况下,训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量( support vector).支持向量是使约束条件式(7.14)等号成立的点,即<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.24.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.25.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在决定分离超平面时只有支持向量起作用,而其他实例点并不起作用.如果移动支持向量将改变所求的解;但是如果在间隔边界以外移动其他实例点,甚至去掉这些点,则解是不会改变的.由于支持向量在确定分离超平面中起着决定性作用,所以将这种分类模型称为支持向量机.支持向量的个数一般很少,所以支持向量机由很少的“重要的”训练样本确定.</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.31.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>为了求解线性可分支持向量机的最优化问题(7.13,7.14)，将它作为原始最优化问题,应用拉格朗日对偶性,通过求解对偶问题(dual problem)得到原始问题( primal problem)的最优解,这就是线性可分支持向量机的对偶算法( dual algorithm).这样做的优点,一是对偶问题往往更容易求解;二是自然引入核函数,进而推广到非线性分类问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.35.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先构建拉格朗日函数( Lagrange function).为此,对每一个不等式约束(7.14)引进拉格朗日乘子( Lagrange multiplier )αi≥0,i=1,2,…,N,定义拉格朗日函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.39.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.42.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.47.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.48.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.50.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%881.52.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种算法称为线性可分支持向量机的对偶学习算法，是线性可分支持向量机学习的基本算法。</p><h4 id="算法（线性可分支持向量机学习算法）"><a href="#算法（线性可分支持向量机学习算法）" class="headerlink" title="算法（线性可分支持向量机学习算法）"></a>算法（线性可分支持向量机学习算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.05.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.06.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.07.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%20%E4%B8%8B%E5%8D%882.08.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于线性可分问题,上述线性可分支持向量机的学习(硬间隔最大化)算法是完美的,但是,训练数据集线性可分是理想的情形.在现实问题中,训练数据集往往是线性不可分的,即在样本中出现噪声或特异点.此时,有更一般的学习算法。</p><h2 id="线性支持向量机与软间隔最大化"><a href="#线性支持向量机与软间隔最大化" class="headerlink" title="线性支持向量机与软间隔最大化"></a>线性支持向量机与软间隔最大化</h2><h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><p>线性可分问题的支持向量机学习方法,对线性不可分训练数据是不适用的,因为这时上述方法中的不等式约束并不能都成立.怎么才能将它扩展到线性不可分问题呢?这就需要修改硬间隔最大化,使其成为软间隔最大化.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%889.56.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了上面的思路,可以和训练数据集线性可分时一样来考虑训练数据集线性不可分时的线性支持向量机学习问题相应于硬间隔最大化,它称为软间隔最大化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.00.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定义（线性支持向量机）"><a href="#定义（线性支持向量机）" class="headerlink" title="定义（线性支持向量机）"></a>定义（线性支持向量机）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.01.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="学习的对偶算法-1"><a href="#学习的对偶算法-1" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.02.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.03.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.13.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以通过求解对偶问题而得到原始问题的解，进而确定分离超平面和决策函数.为此，就可以定理的形式叙述原始问题的最优解和对偶问题的最优解的关系.</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.19.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="算法（线性支持向量机学习算法）"><a href="#算法（线性支持向量机学习算法）" class="headerlink" title="算法（线性支持向量机学习算法）"></a>算法（线性支持向量机学习算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.21.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>符合条件的样本点上的平均值。</p><h3 id="支持向量-1"><a href="#支持向量-1" class="headerlink" title="支持向量"></a>支持向量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.25.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.27.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>目标函数的第一项是经验损失或经验风险，函数<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8A%E5%8D%8810.28.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="序列最小最优化算法"><a href="#序列最小最优化算法" class="headerlink" title="序列最小最优化算法"></a>序列最小最优化算法</h2><p>支持向量机的学习问题可以形式化为求解凸二次规划问题，这样的图二次规划问题具有全局最优解，且有许多最优化算法可以用于这一问题的求解。但当训练样本容量很大时，这些算法往往变得非常低效，以致于无法使用。序列最小最优化算法就是一种快速实现算法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.05.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>SMO算法是一种启发式算法，其基本思路是:如果所有变量的解都满足此最优化问题的KKT条件(Karush-Kuhn-Tucker conditions),那么这个最优化问题的解就得到了。因为KKT条件是该最优化问题的充分必要条件.否则， 选择两个变量，固定其他变量，针对这两个变量构建一个二次规划问题，这个二次规划问题关于这两个变量的解应该更接近原始二次规划问题的解，因为这会使得原始二次规划问题的目标函数值变得更小.重要的是，这时子问题可以通过解析方法求解，这样就可以大大提高整个算法的计算速度.子问题有两个变量，一个是违反KKT条件最严重的那一个，另一个由约束条件自动确定.如此，SMO算法将原问题不断分解为子问题并对子问题求解，进而达到求解原问题的目的.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.13.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>整个SMO算法包括两个部分:求解两个变量二次规划的解析方法和选择变量的启发式方法.</p><h3 id="两个变量二次规划的求解方法"><a href="#两个变量二次规划的求解方法" class="headerlink" title="两个变量二次规划的求解方法"></a>两个变量二次规划的求解方法</h3><p>不失一般性，假设选择的两个变量是α1，α2，其他变量αi（i=3，4，…，N）是固定的。于是SMO的最优化问题（7.98~7.100）的子问题可以写成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.17.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.18.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了求解两个变量的二次规划问题(7.101)-(7.103)，首先分析约束条件，然后在此约束条件下求极小。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.20.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不等式约束(7.103)使得(a,a2)在盒子[0,C]x[0,C]内，等式约束(7.102)使(α1，α2)在平行于盒子[0,C]x[0,C]的对角线的直线上.因此要求的是目标函数在一条平行于对角线的线段.上的最优值.这使得两个变量的最优化问题成为实质上的单变量的最优化问题，不妨考患为变量α2的最优化问题.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.27.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.30.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a>定理</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.33.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="变量的选择方法"><a href="#变量的选择方法" class="headerlink" title="变量的选择方法"></a>变量的选择方法</h3><p>SMO算法在每个子问题中选择两个变量优化，其中至少一个变量是违反KKT条件的。</p><h4 id="第一个变量的选择"><a href="#第一个变量的选择" class="headerlink" title="第一个变量的选择"></a>第一个变量的选择</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.38.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="第二个变量的选择"><a href="#第二个变量的选择" class="headerlink" title="第二个变量的选择"></a>第二个变量的选择</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.42.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="计算阈值b和差值Ei"><a href="#计算阈值b和差值Ei" class="headerlink" title="计算阈值b和差值Ei"></a>计算阈值b和差值Ei</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.43.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%881.47.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="非线性支持向量机与核函数"><a href="#非线性支持向量机与核函数" class="headerlink" title="非线性支持向量机与核函数"></a>非线性支持向量机与核函数</h2><p>对解线性分类问题，线性分类支持向量机是一种非常有效的方法。但是，有时分类问题是非线性的，这时可以使用非线性支持向量机，其主要特点是利用核技巧(kernel trick)。核技巧不仅应用于支持向量机，而且应用于其他统计学习问题。</p><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><h4 id="非线性分类问题"><a href="#非线性分类问题" class="headerlink" title="非线性分类问题"></a>非线性分类问题</h4><p>非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题.先看<br>一个例子:如7.7 左图，是一个分类问题，图中“。”表示正实例点，“x”表示负<br>实例点. 由图可，见， 无法用直线(线性模型)将正负实例正确分开，但可以用一条椭圆曲线(非线性模型)将它们正确分开.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.29.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.28.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决这个问题.所采取的方法是进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题、对图7.7所示的例子， 通过变换，将左图中椭圆变换成右图中的直线,将非线性分类问题变换为线性分类问题.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.32.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用线性分类方法求解非线性分类问题分为两步: 首先使用一个变换将原空间的数据映射到新空间;然后在新空间里用线性分类学习方法从训练数据中学习分类模型. 核技巧就属于这样的方法.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%882.34.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="核函数的定义"><a href="#核函数的定义" class="headerlink" title="核函数的定义"></a>核函数的定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.18.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.19.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.20.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="核技巧在支持向量机中的应用"><a href="#核技巧在支持向量机中的应用" class="headerlink" title="核技巧在支持向量机中的应用"></a>核技巧在支持向量机中的应用</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.23.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.25.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="正定核"><a href="#正定核" class="headerlink" title="正定核"></a>正定核</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.29.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="定理（正定核的充要条件）"><a href="#定理（正定核的充要条件）" class="headerlink" title="定理（正定核的充要条件）"></a>定理（正定核的充要条件）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.32.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>定理给出了正定核的充要条件，因此可以作为正定核，即核函数的另一定义。</p><h4 id="定义（正定核的等价定义）"><a href="#定义（正定核的等价定义）" class="headerlink" title="定义（正定核的等价定义）"></a>定义（正定核的等价定义）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.34.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h3><h4 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.43.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.44.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="字符串核函数"><a href="#字符串核函数" class="headerlink" title="字符串核函数"></a>字符串核函数</h4><p>核函数不仅可以定义在欧氏空间上，还可以定义在离散数据的集合上.比如，字符串核是定义在字符串集合上的核函数.字符串核函数在文本分类信息检索、生物信息学等方面都有应用.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.46.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>字符串核函数k,(s,t)给出了字符串s和t中长度等于n的所有子串组成的特征向量的余弦相似度(cosine similarity).直观上，两个字符串相同的子串越多， 它们就越相似，字符串核函数的值就越大.字符串核函数可以由动态规划快速地计算.</p><h3 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h3><p>利用核技巧，可以将线性分类的学习方法应用到非线性分类问题中去.将线性支持向量机扩展到非线性支持向量机，只需将线性支持向量机对偶形式中的内积换成核函数.</p><h4 id="定义-非线性支持向量机"><a href="#定义-非线性支持向量机" class="headerlink" title="定义 非线性支持向量机"></a>定义 非线性支持向量机</h4><p>从非线性分类训练集，通过核函数与软间隔最大化，或凸二次规划(7.95~7.97)，学习得到的分类决策函数<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.52.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="算法-非线性支持向量机学习算法"><a href="#算法-非线性支持向量机学习算法" class="headerlink" title="算法 非线性支持向量机学习算法"></a>算法 非线性支持向量机学习算法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%20%E4%B8%8B%E5%8D%883.54.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a href="https://cuijiahua.com/blog/2017/11/ml_8_svm_1.html" target="_blank" rel="noopener">机器学习实战教程（八）：支持向量机原理篇之手撕线性SVM</a></p><h2 id="决策面方程"><a href="#决策面方程" class="headerlink" title="决策面方程"></a>决策面方程</h2><p>在二维空间下一条直线的方程为y=ax+b<br>现在我们做一个小小的改变，让原来的x轴变成x1,y轴变成x2<br>x2=ax1+b<br>移项得：ax1-x2+b=0<br>将公式向量化得：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>进一步向量化，用w列向量和标量r进一步向量化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中向量w和x分别为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里w1=a,w2=-1。最初的直线方程a和b的几何意义，a表示直线的斜率，b表示截距，向量化后的直线的w和r的几何意义为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>向量w和直线的关系为垂直的，标量r的作用也没有变，依然决定了直线的截距。</p><p>将其推广到n维空间，就变成了超平面方程，公式没变，依然是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不同在于：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="“分类间隔”方程"><a href="#“分类间隔”方程" class="headerlink" title="“分类间隔”方程"></a>“分类间隔”方程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>间隔的大小实际上就是支持向量对应的样本点到决策面的距离的二倍。d的求法如下：<br>点到直线的距离距离公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>公式中的直线方程为Ax0+By0+C=0，点P的坐标为(x0,y0)。<br>将直线方程扩展到多维，求得我们现在的超平面方程，对公式进行如下变形：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个d就是”分类间隔”。其中||w||表示w的二范数，求所有元素的平方和，然后再开方。</p><h2 id="核函数与超平面"><a href="#核函数与超平面" class="headerlink" title="核函数与超平面"></a>核函数与超平面</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h2><p>1.我们的<strong>最优化问题</strong>是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们要求解的是最小化问题，所以一个直观的想法是如果我能够构造一个函数，使得该函数在可行解区域内与原目标函数完全一致，而在可行解区域外的数值非常大，甚至是无穷大，那么这个没有约束条件的新目标函数的优化问题就与原来有约束条件的原始目标函数的优化问题是等价的问题。这就是使用拉格朗日方程的目的，它将约束条件放到目标函数中，从而将有约束优化问题转换为无约束优化问题。</p><p>2.<strong>将有约束的原始目标函数转换为无约束的新构造的拉格朗日目标函数</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中αi是拉格朗日乘子，αi大于等于0，是我们构造新目标函数时引入的系数变量(我们自己设置)。现在我们令：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当样本点不满足约束条件时，即在可行解区域外：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时，我们将αi设置为正无穷，此时θ(w)显然也是正无穷。<br>当样本点满足约束条件时，即在可行解区域内：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时，显然θ(w)为原目标函数本身。我们将上述两种情况结合一下，就得到了新的目标函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时，再看我们的初衷，就是为了建立一个在可行解区域内与原目标函数相同，在可行解区域外函数值趋近于无穷大的新函数，现在我们做到了。<br>现在，我们的问题变成了求新目标函数的最小值，即：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里用p*表示这个问题的最优值，且和最初的问题是等价的。</p><p>3.<strong>将不易求解的优化问题转化为易求解的优化</strong><br>我们看一下我们的新目标函数，先求最大值，再求最小值。这样的话，我们首先就要面对带有需要求解的参数w和b的方程，而αi又是不等式约束，这个求解过程不好做。所以，我们需要使用拉格朗日函数对偶性，将最小和最大的位置交换一下，这样就变成了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>交换以后的新问题是原始问题的对偶问题，这个新问题的最优值用d<strong>来表示。而且d</strong>&lt;=p*。我们关心的是d=p的时候，这才是我们要的解。需要什么条件才能让d=p呢？首先必须满足这个优化问题是凸优化问题。其次，需要满足KKT条件。<br>求取最小值的目标函数为凸函数的一类优化问题。目标函数是凸函数我们已经知道，这个优化问题又是求最小值。所以我们的最优化问题就是凸优化问题。<br>而且KKT条件也满足了。</p><p>求解这个对偶学习问题，可以分为三个步骤：首先要让L(w,b,α)关于w和b最小化，然后求对α的极大，最后利用SMO算法求解对偶问题中的拉格朗日乘子。</p><p>4.<strong>让L(w,b,α)关于w和b最小化</strong><br>根据上述推导已知：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先固定α，要让L(w,b,α)关于w和b最小化，我们分别对w和b偏导数，令其等于0，即：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将上述结果带回L(w,b,α)得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_60.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从上面的最后一个式子，我们可以看出，此时的L(w,b,α)函数只含有一个变量，即αi。</p><p>5.<strong>对α求极大</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_61.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在我们的优化问题变成了如上的形式。对于这个问题，我们有更高效的优化算法，即序列最小优化（SMO）算法。我们通过这个优化算法能得到α，再根据α，我们就可以求解出w和b，进而求得我们最初的目的：找到超平面，即”决策平面”。</p><p>6.<strong>使用SMO算法</strong><br>步骤一：计算误差<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_106.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤二：计算上下界L和H：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_107-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤三：计算η：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_108.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤四：更新αj<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml-8-109.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤五：根据取值范围修剪αj：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_110.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤六：更新αi：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_111.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤七：更新b1和b2：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_112.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>步骤八：根据b1和b2更新b：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_8_113.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h2><p>对于非线性的情况，SVM的处理方式就是选择一个核函数。简而言之：在线性不可分的情况下，SVM通过某种事先选择的非线性映射（核函数）将输入变量映到一个高维特征空间，将其变成在高维空间线性可分，在这个高维空间中构造最优分类超平面。</p><p>线性可分的情况下，可知最终的超平面方程为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将上述公式用内积来表示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于线性不可分，我们使用一个非线性映射，将数据映射到特征空间，在特征空间中使用线性学习器，分类函数变形如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中ϕ从输入空间(X)到某个特征空间(F)的映射，这意味着建立非线性学习器分为两步：首先使用一个非线性映射将数据变换到一个特征空间F；然后在特征空间使用线性学习器分类。</p><p>如果有一种方法可以在特征空间中直接计算内积 &lt;ϕ(xi),ϕ(x)&gt;，就像在原始输入点的函数中一样，就有可能将两个步骤融合到一起建立一个分线性的学习器，这样直接计算的方法称为核函数方法。</p><p>这种将内积替换成核函数的方式被称为核技巧(kernel trick)。<br>如：<br>假设已知映射函数为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>对于两个向量a1=(x1,x2)和a2=(y1,y2)有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果我们不进行映射计算，直接运算下面的公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这两个公式的计算结果是相同的。区别在于：一个是根据映射函数，映射到高维空间中，然后再根据内积的公式进行计算，计算量大；另一个则直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果，计算量小。</p><p>核函数就是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SVM/ml_9_15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="SVM-simple"><a href="#SVM-simple" class="headerlink" title="SVM-simple"></a>SVM-simple</h2><p>简化版的SMO算法，第二个α的选择是随机的。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-simple.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-simple.py</a></p><h2 id="完整SMO算法"><a href="#完整SMO算法" class="headerlink" title="完整SMO算法"></a>完整SMO算法</h2><p>完整的SMO算法可以启发式选择第二个α值。<br>在实现SMO算法的时候，先计算η，再更新αj。为了加快第二个αj乘子的迭代速度，需要让直线的斜率增大，对于αj的更新公式，其中η值没有什么文章可做，于是只能令:max|Ei-Ej|。<br>因此，优化方法为：</p><ol><li>最外层循环，首先在样本中选择违反KKT条件的一个乘子作为最外层循环，然后用”启发式选择”选择另外一个乘子并进行这两个乘子的优化。</li><li>在非边界乘子中寻找使得 |Ei - Ej| 最大的样本<br>3.如果没有找到，则从整个样本中随机选择一个样本</li></ol><p>完整版SMO算法覆盖整个数据集进行计算，而简化版SMO算法是随机选择的。可以看出，完整版SMO算法选出的支持向量样点更多，更接近理想的分隔超平面。</p><p>对比两种算法的运算时间，结果是完整版SMO算法的速度比简化版SMO算法的速度快6倍左右。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-smo.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svm-smo.py</a></p><h2 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h2><p><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svmMLiA.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/svm/svmMLiA.py</a><br>高斯核函数<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从图像中我们可以看出，离中心点越近，函数值就越接近于1。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此以任意一种颜色的同心圆作为决策边界，我们都可以完成对数据集的简单非线性划分。那么问题来了，如何映射到高维空间上去呢？——————高斯核函数！ </p><h2 id="sklearn-svm-SVC"><a href="#sklearn-svm-SVC" class="headerlink" title="sklearn.svm.SVC"></a>sklearn.svm.SVC</h2><p>参数说明：<br>C:惩罚项，float类型，可选参数，默认为1.0，C越大，即对分错样本的惩罚程度越大，因此在训练样本中准确率越高，但是泛化能力降低，也就是对测试数据的分类准确率降低。相反，减小C的话，容许训练样本中有一些误分类错误样本，泛化能力强。对于训练样本带有噪声的情况，一般采用后者，把训练样本集中错误分类的样本作为噪声。</p><p>kernel：核函数类型，str类型，默认为’rbf’。可选参数为：’linear’：线性核函数，’poly’：多项式核函数，’rbf’：径像核函数/高斯核，’sigmod’：sigmod核函数，’precomputed’：核矩阵，precomputed表示自己提前计算好核函数矩阵，这时候算法内部就不再用核函数去计算核矩阵，而是直接用你给的核矩阵，核矩阵需要为n*n的。</p><p>degree：多项式核函数的阶数，int类型，可选参数，默认为3。这个参数只对多项式核函数有用，是指多项式核函数的阶数n，如果给的核函数参数是其他核函数，则会自动忽略该参数。</p><p>gamma：核函数系数，float类型，可选参数，默认为auto。只对’rbf’ ,’poly’ ,’sigmod’有效。如果gamma为auto，代表其值为样本特征数的倒数，即1/n_features。</p><p>coef0：核函数中的独立项，float类型，可选参数，默认为0.0。只有对’poly’ 和,’sigmod’核函数有用，是指其中的参数c。</p><p>probability：是否启用概率估计，bool类型，可选参数，默认为False，这必须在调用fit()之前启用，并且会fit()方法速度变慢。</p><p>shrinking：是否采用启发式收缩方式，bool类型，可选参数，默认为True。</p><p>tol：svm停止训练的误差精度，float类型，可选参数，默认为1e^-3。</p><p>cache_size：内存大小，float类型，可选参数，默认为200。指定训练所需要的内存，以MB为单位，默认为200MB。</p><p>class_weight：类别权重，dict类型或str类型，可选参数，默认为None。给每个类别分别设置不同的惩罚参数C，如果没有给，则会给所有类别都给C=1，即前面参数指出的参数C。如果给定参数’balance’，则使用y的值自动调整与输入数据中的类频率成反比的权重。</p><p>verbose：是否启用详细输出，bool类型，默认为False，此设置利用libsvm中的每个进程运行时设置，如果启用，可能无法在多线程上下文中正常工作。一般情况都设为False，不用管它。</p><p>max_iter：最大迭代次数，int类型，默认为-1，表示不限制。</p><p>decision_function_shape：决策函数类型，可选参数’ovo’和’ovr’，默认为’ovr’。’ovo’表示one vs one，’ovr’表示one vs rest。</p><p>random_state：数据洗牌时的种子值，int类型，可选参数，默认为None。伪随机数发生器的种子,在混洗数据时用于概率估计。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已修改&lt;/p&gt;
&lt;h1 id=&quot;统计学习方法-支持向量机&quot;&gt;&lt;a href=&quot;#统计学习方法-支持向量机&quot; class=&quot;headerlink&quot; title=&quot;统计学习方法 支持向量机&quot;&gt;&lt;/a&gt;统计学习方法 支持向量机&lt;/h1&gt;&lt;p&gt;支持向量机（support vecto
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯概率</title>
    <link href="https://github.com/zdkswd/2018/11/22/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/"/>
    <id>https://github.com/zdkswd/2018/11/22/贝叶斯概率/</id>
    <published>2018-11-22T08:49:47.000Z</published>
    <updated>2018-11-23T05:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>已修改</p><h1 id="人工智能课上内容"><a href="#人工智能课上内容" class="headerlink" title="人工智能课上内容"></a>人工智能课上内容</h1><p><a href="https://www.zhihu.com/question/21134457" target="_blank" rel="noopener">你对贝叶斯统计都有怎样的理解？ - 知乎</a></p><h2 id="贝叶斯概率vs经典概率"><a href="#贝叶斯概率vs经典概率" class="headerlink" title="贝叶斯概率vs经典概率"></a>贝叶斯概率vs经典概率</h2><p>关于统计推断的主张和想法，大体可以纳入到两个体系之内，其一叫频率学派，其特征是把需要推断的参数θ视作固定且未知的常数，而样本X是随机的，其着眼点在样本空间，有关的概率计算都是针对X的分布。另一派叫做贝叶斯学派，他们把参数θ视作随机变量，而样本X是固定的，其着眼点在参数空间，重视参数θ的分布，固定的操作模式是通过参数的先验分布结合样本信息得到参数的后验分布。</p><h2 id="经典概率"><a href="#经典概率" class="headerlink" title="经典概率"></a>经典概率</h2><p>即我们学习的概率论呀。<br>方法：MLE（极大似然估计）<br>认为世界是确定的。θ是唯一的。</p><h2 id="贝叶斯概率"><a href="#贝叶斯概率" class="headerlink" title="贝叶斯概率"></a>贝叶斯概率</h2><p>方法：MAP（最大后验估计）<br>频率派认为估计对象（参数）是一个未知的固定值。而贝叶斯却认为未知的参数都是随机变量。</p><p>我们要通过一些事实估计“爱因斯坦在1905年12月25日晚上八点吸烟”的真假。定义参数:，吸烟；，没吸烟。那么频率派认为，爱因斯坦有没有曾经在这时刻吸烟是事实，是取值0或者1的固定数，不能说”=1的概率是xxx”；然而贝叶斯派认为可以说“=1概率是30%”。而且随着所得资料（样本x）的增多，我们可以把这个概率加以变化，记得到的分布。这个概率其实是“信心”的含义。</p><p>后验（输出）=先验（输入）*似然（输入）</p><p>贝叶斯思想的优势<br>1、  对于某一种独立重复随机事件，如果采用最大似然法计算出两个极值点，例如99、100，此时最大似然法只会取最大值点100的概率值。但是使用贝叶斯思想，我们就可以同时考虑极值点99、100的概率。</p><p>在实际应用中，事件A的概率可能不是一成不变的（实验难以重复独立，或者事件A的概率就是随机的）。比如考虑一个人生病的概率，幼年时生病概率高，中年时生病概率低，老年时生病概率高，或者冬天生病概率高，夏天生病概率低。频率派思想认为的概率是事件A的固定属性在这些状况下就不适用。严格的来说，任何场景下你都无法保证事件A概率是固定的。</p><p>2、  频率派使用的最大似然法，只能得到概率的最大似然估计。但是通过贝叶斯公式得到概率后验分布函数后，我们可以进行各种处理，比如取概率期望，概率中位数，概率极大值等等。</p><h2 id="后验分布"><a href="#后验分布" class="headerlink" title="后验分布"></a>后验分布</h2><p>以前我们想知道一个参数，要通过大量的观测值才能得出，而且是只能得出一个参数值。而现在运用了贝叶斯统计思想，这个后验概率分布其实是一系列参数值的概率分布，再说简单点就是我们得到了许多个参数及其对应的可能性，我们只需要从中选取我们想要的值就可以了：有时我们想要概率最大的那个参数，那这就是 后验众数估计(posterior mode estimator)；有时我们想知道参数分布的中位数，那这就是 后验中位数估计(posterior median estimator);有时我们想知道的是这个参数分布的均值，那就是 后验期望估计。这三种估计没有谁好谁坏，只是提供了三种方法得出参数，看需要来选择。现在这样看来得到的参数是不是更具有说服力？</p><h2 id="先验分布"><a href="#先验分布" class="headerlink" title="先验分布"></a>先验分布</h2><p>说完了后验分布，现在就来说说先验分布。先验分布就是你在取得实验观测值以前对一个参数概率分布的 主观判断，这也就是为什么贝叶斯统计学一直不被认可的原因，统计学或者数学都是客观的，怎么能加入主观因素呢？但事实证明这样的效果会非常好！再拿掷硬币的例子来看(怎么老是拿这个举例，是有多爱钱。。。)，在扔之前你会有判断正面的概率是50%，这就是所谓的先验概率，但如果是在打赌，为了让自己的描述准确点，我们可能会说正面的概率为0.5的可能性最大，0.45的几率小点，0.4的几率再小点，0.1的几率几乎没有等等，这就形成了一个先验概率分布。</p><p>你这个硬币的材质是不均匀的，那正面的可能性是多少呢？这就让人犯糊涂了，我们想有主观判断也无从下手，于是我们就想说那就先认为0~1之间每一种的可能性都是相同的吧，也就是设置成0~1之间的均匀分布  作为先验分布吧，这就是贝叶斯统计学当中的 无信息先验(noninformative prior)！那么下面我们就通过不断掷硬币来看看，这个概率到是多少，贝叶斯过程如下： (图来自[3])<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/v2-3ef5e8c52f6257d7624dcae8496dc14c_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/v2-0fc8c439d5a4eebf0ca11b46d1b5135d_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从图中我们可以看出，0次试验的时候就是我们的先验假设——均匀分布，然后掷了第一次是正面，于是概率分布倾向于1，第二次又是正，概率是1的可能性更大了，但 注意：这时候在0.5的概率还是有的，只不过概率很小，在0.2的概率变得更小。第三次是反面，于是概率分布被修正了一下，从为1的概率最大变成了2/3左右最大(3次试验，2次正1次反当然概率是2/3的概率最大)。再下面就是进行更多次的试验，后验概率不断根据观测值在改变，当次数很大的时候，结果趋向于0.5(哈哈，结果这还是一枚普通的硬币，不过这个事件告诉我们，直觉是不可靠的，一定亲自实验才行~)。有的人会说，这还不是在大量数据下得到了正面概率为0.5嘛，有什么好稀奇的？ 注意了！画重点了！(敲黑板) 记住，不要和一个统计学家或者数学家打赌！跑题了，跑题了。。。说回来，我们上面就说到了古典概率学的弊端就是如果掷了2次都是正面，那我们就会认为正面的概率是1，而在贝叶斯统计学中，如果我们掷了2次都是正面，只能说明正面是1的可能性最大，但还是有可能为0.5, 0.6, 0.7等等的，这就是对古典统计学的一种完善和补充，于是我们也就是解释了，我们所谓的 地震的概率为5%；生病的概率为10%等等这些概率的意义了，这就是贝叶斯统计学的哲学思想。</p><p>所以贝叶斯得到的是θ的分布。</p><h2 id="贝叶斯分析"><a href="#贝叶斯分析" class="headerlink" title="贝叶斯分析"></a>贝叶斯分析</h2><p>贝叶斯分析的思路对于由证据的积累来推测一个事物发生的概率具有重大作用， 它告诉我们当我们要预测一个事物， 我们需要的是首先根据已有的经验和知识推断一个先验概率， 然后在新证据不断积累的情况下调整这个概率，整个通过积累证据来得到一个事件发生概率的过程我们称为贝叶斯分析。</p><p>贝叶斯决策如果一旦变成自动化的计算机算法， 它就是机器学习。</p><h1 id="统计学习方法-朴素贝叶斯法"><a href="#统计学习方法-朴素贝叶斯法" class="headerlink" title="统计学习方法 朴素贝叶斯法"></a>统计学习方法 朴素贝叶斯法</h1><h2 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p><strong>注意：朴素贝叶斯法与贝叶斯估计是不同的概念。</strong></p><p>朴素贝叶斯法对条件概率分布作了条件独立性的假设.由于这是一个较强的<br>假设, 朴素贝叶斯法也由此得名.具体地，条件独立性假设是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.04.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型.条件独立假设等于是说用于分类的特征在类确定的条件下都是条件独立的.这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.08.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.11.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这是朴素贝叶斯法分类的基本公式，于是，朴素贝叶斯分类器可表示为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.12.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.12.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="后验概率最大化的含义"><a href="#后验概率最大化的含义" class="headerlink" title="后验概率最大化的含义"></a>后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中.这等价于期望风险最小化.假设选择0-1损失函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.17.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.18.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.20.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="朴素贝叶斯的参数估计"><a href="#朴素贝叶斯的参数估计" class="headerlink" title="朴素贝叶斯的参数估计"></a>朴素贝叶斯的参数估计</h2><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.22.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="学习与分类算法"><a href="#学习与分类算法" class="headerlink" title="学习与分类算法"></a>学习与分类算法</h3><h4 id="朴素贝叶斯算法（naive-Bayes-algorithm）"><a href="#朴素贝叶斯算法（naive-Bayes-algorithm）" class="headerlink" title="朴素贝叶斯算法（naive  Bayes algorithm）"></a>朴素贝叶斯算法（naive  Bayes algorithm）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.23.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.24.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.24.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.27.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8A%E5%8D%8810.28.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="西瓜书-关于朴素贝叶斯分类器的补充"><a href="#西瓜书-关于朴素贝叶斯分类器的补充" class="headerlink" title="西瓜书 关于朴素贝叶斯分类器的补充"></a>西瓜书 关于朴素贝叶斯分类器的补充</h2><p>在现实任务中朴素贝叶斯分类器有多种使用方式.例如，若任务对预测速度要求较高，则对给定训练集,可将朴素贝叶斯分类器涉及的所有概率估值事先计算好存储起来,这样在进行预测时只需“查表”即可进行判别;若任务数据更替频繁，则可采用“懒惰学习”(lazy learning) 方式，先不进行任何训练，待收到预测请求时再根据当前数据集进行概率估值;若数据不断增加，则可在现有估值基础_上，仅对新增样本的属性值所涉及的概率估值进行计数修正即可实现增量学习。</p><h1 id="西瓜书-半朴素贝叶斯分类器"><a href="#西瓜书-半朴素贝叶斯分类器" class="headerlink" title="西瓜书 半朴素贝叶斯分类器"></a>西瓜书 半朴素贝叶斯分类器</h1><p>为了降低贝叶斯公式中估计后验概率P(c|x)的困难，朴素贝叶斯分类器采用了属性条件独立性假设,但在现实任务中这个假设往往很难成立.于是，人们尝试对属性条件独立性假设进行一定程度的放松,由此产生了一类称为“半朴素贝叶斯分类器”(semi-naive Bayes clasifers)的学习方法。</p><p>半朴素贝叶斯分类器的基本思想是适当考虑一部分属性间的互相依赖信息，从而既不需要进行完全联合概率计算，又不至于彻底忽略了比较强的属性依赖关系。“独依赖估计”（One-Dependent Estimator,简称ODE）是半朴素贝叶斯分类器最常用的一种策略。顾名思义，所谓“独依赖”就是假设每个属性在类别之外最多仅依赖一个其他属性，即：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8B%E5%8D%883.34.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>于是，问题的关键就转化为如何确定每个属性的父属性，不同的做法产生不同的独依赖分类器</p><p>最直接的做法是假设所有属性都依赖同一个属性，称为“超父”（super-parent),然后通过交叉验证等模型选择方法来确定超父属性，由此形成了SPODE方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8B%E5%8D%883.45.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>按下不表</p><h1 id="西瓜书-贝叶斯网"><a href="#西瓜书-贝叶斯网" class="headerlink" title="西瓜书 贝叶斯网"></a>西瓜书 贝叶斯网</h1><p>贝叶斯网亦称“信念网”，它借助有向无环图（Directed Acyclic Graph,简称DAG）来刻画属性间的依赖关系，并使用条件概率表（Conditional Probability Table,简称CPT）来描述属性的联合概率分布。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-22%20%E4%B8%8B%E5%8D%883.52.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>按下不表。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_15.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>P(A)称为”先验概率”（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。</p><p>P(A|B)称为”后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。</p><p>P(B|A)/P(B)称为”可能性函数”（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。</p><p>这就是贝叶斯推断的含义。我们先预估一个”先验概率”，然后加入实验结果，看这个实验到底是增强还是削弱了”先验概率”，由此得到更接近事实的”后验概率”。</p><p>在这里，如果”可能性函数”P(B|A)/P(B)&gt;1，意味着”先验概率”被增强，事件A的发生的可能性变大；如果”可能性函数”=1，意味着B事件无助于判断事件A的可能性；如果”可能性函数”&lt;1，意味着”先验概率”被削弱，事件A的可能性变小。</p><p>要知道我们只需要比较 P(H1|E)和P(H2|E)的大小，找到那个最大的概率就可以。既然如此，两者的分母都是相同的，那我们只需要比较分子即可。即比较P(E|H1)P(H1)和P(E|H2)P(H2)的大小，<strong>所以为了减少计算量，全概率公式在实际编程中可以不使用。</strong></p><p>其中P(B):<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_10.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_11.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_12.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_13.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_14.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="朴素贝叶斯推断"><a href="#朴素贝叶斯推断" class="headerlink" title="朴素贝叶斯推断"></a>朴素贝叶斯推断</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_21.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于每个特征都是独立的，我们可以进一步拆分公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A6%82%E7%8E%87/ml_4_22.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/bayes.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/bayes.py</a></p><h2 id="sklearn-朴素贝叶斯"><a href="#sklearn-朴素贝叶斯" class="headerlink" title="sklearn-朴素贝叶斯"></a>sklearn-朴素贝叶斯</h2><p>在sklearn中一共有三个朴素贝叶斯分类算法类。分别是GaussianNB,MultinomialNB和BernoulliNB。其中GaussianNB就是先验为高斯分布的朴素贝叶斯，MultinomialNB就是先验为多项式分布的朴素贝叶斯，而BernoulliNB就是先验为伯努利分布的朴素贝叶斯。</p><p>对于新闻分类，属于多分类问题。我们可以使用MultinamialNB()完成我们的新闻分类问题。MultinomialNB假设特征的先验概率为多项式分布，即如下式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中， P(Xj = Xjl | Y = Ck)是第k个类别的第j维特征的第l个取值条件概率。mk是训练集中输出为第k类的样本个数。λ为一个大于0的常数，常常取值为1，即拉普拉斯平滑，也可以取其他值。</p><p>MultinamialNB这个函数，只有3个参数：<br>参数说明如下:</p><ol><li>alpha：浮点型可选参数，默认为1.0，其实就是添加拉普拉斯平滑，即为上述公式中的λ ，如果这个参数设置为0，就是不添加平滑；</li><li>fit_prior：布尔型可选参数，默认为True。布尔参数fit_prior表示是否要考虑先验概率，如果是false,则所有的样本类别输出都有相同的类别先验概率。否则可以自己用第三个参数class_prior输入先验概率，或者不输入第三个参数class_prior让MultinomialNB自己从训练集样本来计算先验概率，此时的先验概率为P(Y=Ck)=mk/m。其中m为训练集样本总数量，mk为输出为第k类别的训练集样本数。</li><li>class_prior：可选参数，默认为None。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>MultinomialNB一个重要的功能是有partial_fit方法，这个方法的一般用在如果训练集数据量非常大，一次不能全部载入内存的时候。这时我们可以把训练集分成若干等分，重复调用partial_fit来一步步的学习训练集，非常方便。GaussianNB和BernoulliNB也有类似的功能。 在使用MultinomialNB的fit方法或者partial_fit方法拟合数据后，我们可以进行预测。此时预测有三种方法，包括predict，predict_log_proba和predict_proba。predict方法就是我们最常用的预测方法，直接给出测试集的预测类别输出。predict_proba则不同，它会给出测试集样本在各个类别上预测的概率。容易理解，predict_proba预测出的各个类别概率里的最大值对应的类别，也就是predict方法得到类别。predict_log_proba和predict_proba类似，它会给出测试集样本在各个类别上预测的概率的一个对数转化。转化后predict_log_proba预测出的各个类别对数概率里的最大值对应的类别，也就是predict方法得到类别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已修改&lt;/p&gt;
&lt;h1 id=&quot;人工智能课上内容&quot;&gt;&lt;a href=&quot;#人工智能课上内容&quot; class=&quot;headerlink&quot; title=&quot;人工智能课上内容&quot;&gt;&lt;/a&gt;人工智能课上内容&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/ques
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AutoEncoder by Forest</title>
    <link href="https://github.com/zdkswd/2018/11/21/AutoEncoder%20by%20Forest/"/>
    <id>https://github.com/zdkswd/2018/11/21/AutoEncoder by Forest/</id>
    <published>2018-11-21T12:16:32.000Z</published>
    <updated>2018-11-21T12:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1709.09018" target="_blank" rel="noopener">https://arxiv.org/abs/1709.09018</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>自动编码是一个重要的任务，通常由深度神经网络比如CNN来实现。在这篇论文中，我们提出了EncoderForest （eForest）这是第一个基于树集成的自编码器。我们提出了一种方法，让森林能够利用树的决策路径所定义的等效类来进行后向重建，并在监督和无监督环境中展示了其使用情况。实验结果表明，与DNN自编码器相比，eForest能够以较快的训练速度获得更低的重建误差，同时模型本身具有可重用性和容损性。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>自动编码器是一类将输入数据映射到隐藏空间，然后再映射到原始空间的模型，它使用重建误差作为目标函数。自动编码器分为两个过程：编码和解码。编码过程将原始数据映射到隐藏空间，解码数据将数据从隐藏空间映射到原始数据空间。传统实现这两个过程的方式是使用神经网络。</p><p>文章提出了一种编码森林（EncoderForest），通过一个集成树模型进行前向编码和反向解码，而且可以使用监督或者无监督训练。实验显示EncoderFroest有如下优点:</p><ol><li>准确： 它的实验重建误差比使用MLP和CNN的自动编码器低。</li><li>有效： efroest在一个单一KNL(多核CPU)上运行比CNN-Base自动编码器在一个Titan-X GPU上运行还快。</li><li>容错率：训练好的模型能够正常运行即使模型部分损坏。</li><li>重利用： 在同一个领域下，使用一个数据集训练的模型可以直接应用到另一个数据集下。</li></ol><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>自动编码器有两个基本的功能，编码和解码。对于一个森林来说，编码并不困难，因为至少其叶节点信息可以被看做一种编码，甚至可以说，结点集合的一个子集或者路径的分支都能够为编码提供更多的信息。</p><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><p>对于给定的一个训练过的有T棵树的集成树模型（也可以是空的森林，编码过程即森林形成过程），前向编码过程将输入数据送到每棵树的根节点，并计算每棵树，得到其所属的叶节点，最后返回一个T维向量，这个T维向量的每一项是每棵树中求到的上述叶节点在树中的编号。注意，算法跟决策树的分割规则无关。只需要是T棵树即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_algo1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h2><p>一般来说，决策树都是用来前向预测，将数据计算从树的根节点到叶子结点，但是其反向重建是未定义的。下面通过一个小例子来探索解码过程。</p><p>假设我们正在解决一个二分类问题，数据有三个属性，第一个和第二个属性是数值型属性，第三个属性是布尔型属性（取值为YES, NO），第四个属性是一个三值属性，取值可以是RED，BLUE，GREEN。给定一个实例x，xi代表x的第i个属性值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_forest.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在我们只知道，实例x落在每棵树的哪个结点，上图中的红色结点，我们的目标是重构实例x。文章提出了一种简洁有效的反向重建方法。首先，在树中的每个叶子结点对应于一条唯一的从根到叶子的路径。在上面的图中已经用红色标出这样的路径。然后，每条路径都会对应一条符号规则，所以我们就得到<br>了n条（树的数目）符号规则：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_rule.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后，我们可以根据上面的规则推出MCR(最大完备规则)，最大完备规则的意思是，在规则中的每一个约束的范围不能再扩大。如果扩大，则会产生冲突。</p><p>例如，由上面的规则集我们可以得到MCR:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_mcr.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>那么显然，原始的数据肯定落在有MCR定义的范围内。</p><p>计算完MCR之后，就可以根据MCR重构原始样本了，目录型属性如上面的第三和第四属性只需要根据MCR中的指定取即可，而数值型属性则可以根据MCR中的范围取一个特殊值即可（中位数、均值、或者最大最小值）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_algo2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>首先根据编码完的T维向量从树中得到T个决策规则，再根据这些规则得到MCR，再根据MCR重构得到x，算法如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_algo3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/AutoEncoder%20by%20Forest/ae_eforest_exp_image2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.09018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/abs/1709.09018&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>特征工程与表示学习,数据的粒度,数据量</title>
    <link href="https://github.com/zdkswd/2018/11/21/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0,%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B2%92%E5%BA%A6,%E6%95%B0%E6%8D%AE%E9%87%8F/"/>
    <id>https://github.com/zdkswd/2018/11/21/特征工程与表示学习,数据的粒度,数据量/</id>
    <published>2018-11-21T10:48:47.000Z</published>
    <updated>2018-11-21T10:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/41521695" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41521695</a></p><p>正因为数据表示的重要性，机器学习一般有两种思路来提升原始数据的表达</p><ol><li>特征学习(feature learning)，又叫表示学习(representation learning)或者表征学习，一般指的是自动学习有用的数据特征。</li><li>特征工程(feature engineering)，主要指对于数据的人为处理提取，有时候也代指“洗数据”。</li></ol><h1 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h1><p>模型自动对输入数据进行学习，得到更有利于使用的特征(*可能同时做出了预测)。代表的算法大致包括：</p><ol><li>深度学习，包括大部分常见的模型如CNN_RNN_DBN等。</li><li>某些无监督学习算法，如主成分分析(PCA)及自编码器（autoencoder）通过对数据转化而使得输入数据更有意义。</li><li>某些树模型可以自动的学习到数据中的特征并同时作出预测。</li></ol><h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><p>什么时候用「手工提取」什么时候用「表示学习」。一种简单的看法是，要想自动学习到数据的良好表达，就需要大量的数据。这个现象也解释了为什么「特征工程」往往在中小数据集上表现良好，而「表示学习」在大量复杂数据上更有用武之地。</p><p>比如我们会假设数据分布，会假设映射函数的性质，也会假设预测值与输入值间的关系。这一切假设其实并非凭空猜想，而是基于我们对于问题的理解，从某种角度来看，这是一种先验，是贝叶斯模型。在中小数据集上的机器学习往往使用的就是强假设模型（人类知识先验）+一个简单线性分类器。当数据愈发复杂，数据量逐渐加大后，我们对于数据的理解越来越肤浅，做出的假设也越来越倾向于随机，那么此时人工特征工程往往是有害的，而需要使用摆脱了人类先验的模型，比如深度学习或者集成模型。</p><p>模型选择的过程其实也是在衡量我们对于问题及数据的理解是否深刻，是在人类先验与数据量之间的一场博弈。从这个角度来看，深度学习首先革的是传统机器学习模型的命：最先被淘汰的不是工人，而是特定场景下的传统机器学习模型。</p><h1 id="数据的粒度"><a href="#数据的粒度" class="headerlink" title="数据的粒度"></a>数据的粒度</h1><p>数据的粒度可以理解为数据的细分程度。随着细分程度的改变，那么数据量也会有明显的变化。数据的粒度越细，数据量越大。</p><p>过于具体的数据缺失了特征，有效的特征仅在某个特定的粒度才存在。打个比方，人是由原子、分子、细胞、组织、器官构成，但在分子层面我们不一定能分辨它是人，只有到达一定的粒度才可以。因此，数据收集的第一个重点是搞清楚，在什么粒度可以解决我们的问题，而不是盲目的收集一大堆数据，或者收集过于抽象的数据。</p><h1 id="到底需要多少数据？"><a href="#到底需要多少数据？" class="headerlink" title="到底需要多少数据？"></a>到底需要多少数据？</h1><h2 id="数据量与特征量的比例"><a href="#数据量与特征量的比例" class="headerlink" title="数据量与特征量的比例"></a>数据量与特征量的比例</h2><p>谈论数据量，不能光说有多少条数据n，一定也要考虑数据的特征数m。</p><p>人们讨论数据量，往往讨论的是n，也就是有多少条数据。但这个是不准确的，因为更加适合的评估应该是n/m，也就是样本量除以特征数，原因很简单。如果你只有100条数据，但只有2个特征。如果用线性函数来拟合，相当于给你100个点来拟合到二次函数上，这个数据量一般来说是比较充裕的。但还是100个数据点，每个数据的特征数是200，那么很明显你的数据是不够的，过拟合的风险极高。</p><h2 id="特征间的相关性和有效性"><a href="#特征间的相关性和有效性" class="headerlink" title="特征间的相关性和有效性"></a>特征间的相关性和有效性</h2><p>数据间重复性低：包括样本间重复性比较低，特征间重复性比较低，即特征间线性无关</p><p>数据的有效性：此处的有效性指的是你的变量对于解决问题有帮助，而不是完全无关或者关联性极低的数据。</p><h2 id="数据是否越多越好？"><a href="#数据是否越多越好？" class="headerlink" title="数据是否越多越好？"></a>数据是否越多越好？</h2><p>数据比模型更重要，数据重要性 &gt;&gt; 模型重要性。机器学习模型的表现高度依赖于数据量，选择对的模型只是其次，因为巧妇难为无米之炊。</p><p>数据不是越多越好，随机数据中也可能因为巧合而存在某种关联。</p><h2 id="数据量与模型选择"><a href="#数据量与模型选择" class="headerlink" title="数据量与模型选择"></a>数据量与模型选择</h2><p>数据量很小，用朴素贝叶斯、逻辑回归或支持向量机<br>数据量适中或者较大，用树模型，优先 xgboost和lightgbm<br>数据量较大，尝试使用神经网络<br>所以说到底，依然不存在定式，而依赖于经验和理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41521695&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/41521695&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正因为数据表示的重
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Deep Forest: Towards An Alternative to Deep Neural Networks</title>
    <link href="https://github.com/zdkswd/2018/11/21/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/"/>
    <id>https://github.com/zdkswd/2018/11/21/Deep Forest: Towards An Alternative to Deep Neural Networks/</id>
    <published>2018-11-21T10:44:32.000Z</published>
    <updated>2018-11-21T10:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ijcai.org/proceedings/2017/0497.pdf" target="_blank" rel="noopener">https://www.ijcai.org/proceedings/2017/0497.pdf</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>提出了gcForest,一种能够与深层神经网络的表现高度抗衡的决策树集成方法。相比于深层神经网络需要化大力气调整超参数，gcForest更容易去训练。实际上，就算gcForest被应用于不同领域使用不同的数据，也可以通过设置几乎相同的超参数获得极好的表现。gcForest的训练时高效的可扩展的。在作者的实验中使用PC进行gcForest的训练和使用GPU设备进行训练时间差不多，并且效率的优势可能会比这更加明显，因为gcForest更容易并行实现。更重要的是，深层神经网络需要大规模的训练数据，但是gcForest即使只有小规模的训练数据也能表现很好。还有，作为以树为基础的方法，gcForest比深层神经网络更容易进行理论分析。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>深度神经网络的不足：</p><ol><li>需要大量数据。然而就算是大数据领域也有待带标签数据不足等问题。</li><li>模型复杂，需要强计算力设备进行训练。</li><li>最重要的是有太多超参数，学习的表现又很依赖它们。即使是使用同样的网络模型也由于各种参数设置的不同而变得实际上使用的是不同的学习模型。这让深层学习的训练变得棘手，更像是一门艺术而不是一门科学。同时由于影响的因素太多而难以理论分析深层神经网络。</li></ol><p>作者设想能不能给一些学习模型赋予一些属性让其具有深层学习网络的能力而又没有上述的不足。</p><p>所以论文提出gcForest(multi-Grained Cascade forest )</p><h1 id="k折交叉验证"><a href="#k折交叉验证" class="headerlink" title="k折交叉验证"></a>k折交叉验证</h1><p>常用的精度测试方法主要是交叉验证，例如10折交叉验证(10-fold cross validation)，将数据集分成十份，轮流将其中9份做训练1份做验证，10次的结果的均值作为对算法精度的估计，一般还需要进行多次10折交叉验证求均值，例如：10次10折交叉验证，以求更精确一点。交叉验证有时也称为交叉比对，如：10折交叉比对。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h2 id="级联森林"><a href="#级联森林" class="headerlink" title="级联森林"></a>级联森林</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305230315119.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>级联的每个级别包括两个随机森林（蓝色字体标出）和两个完全随机树木森林（黑色）。假设有三个类要预测; 因此，每个森林将输出三维类向量，然后将其连接以重新表示原始输入。注意，要将前一级的特征和这一级的特征连接在一起。</p><p>论文中为了简单起见，在实现中，使用了两个完全随机的树森林（complete-random tree forests）和两个随机森林[Breiman，2001]。每个完全随机的树森林包含1000个完全随机树[Liu et al。，2008]，每棵树通过随机选择一个特征在树的每个节点进行分割实现生成，树一直生长，直到每个叶节点只包含相同类的实例或不超过10个实例。类似地，每个随机森林也包含1000棵树，通过随机选择sqrt(d) 数量的特征作为候选（d是输入特征的数量），然后选择具有最佳 gini 值的特征作为分割。每个森林中的树的数值是一个超参数。</p><p>给定一个实例（就是一个样本），每个森林会通过计算在相关实例落入的叶节点处的不同类的训练样本的百分比，然后对森林中的所有树计平均值，以生成对类的分布的估计。如下图所示，其中红色部分突出了每个实例遍历到叶节点的路径。叶节点中的不同标记表示了不同的类。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305230948452.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>被估计的类分布形成类向量（class vector），该类向量接着与输入到级联的下一级的原始特征向量相连接。例如，假设有三个类，则四个森林每一个都将产生一个三维的类向量，因此，级联的下一级将接收12 = 3×4个增强特征（augmented feature）。</p><p>为了降低过拟合风险，每个森林产生的类向量由k折交叉验证（k-fold cross validation）产生。具体来说，每个实例都将被用作 k -1 次训练数据，产生 k -1 个类向量，然后对其取平均值以产生作为级联中下一级的增强特征的最终类向量。需要注意的是，在扩展一个新的级后，整个级联的性能将在验证集上进行估计，如果没有显着的性能增益，训练过程将终止；因此，级联中级的数量是自动确定的。与模型的复杂性固定的大多数深度神经网络相反，gcForest 能够适当地通过终止训练来决定其模型的复杂度（early stop）。这使得 gcForest 能够适用于不同规模的训练数据，而不局限于大规模训练数据。</p><h2 id="多粒度扫描（Multi-Grained-Scanning）"><a href="#多粒度扫描（Multi-Grained-Scanning）" class="headerlink" title="多粒度扫描（Multi-Grained Scanning）"></a>多粒度扫描（Multi-Grained Scanning）</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305233438302.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>滑动窗口用于扫描原始特征。假设有400个原始特征，并且使用100个特征的窗口大小。对于序列数据，将通过滑动一个特征的窗口来生成100维的特征向量；总共产生301个特征向量。如果原始特征具有空间关系，比如图像像素为400的20×20的面板，则10×10窗口将产生121个特征向量（即121个10×10的面板）。从正<em>负训练样例中提取的所有特征向量被视为正</em>负实例；它们将被用于生成类向量：从相同大小的窗口提取的实例将用于训练完全随机树森林和随机森林，然后生成类向量并连接为转换后的像素。如上图的上半部分所示，假设有3个类，并且使用100维的窗口；然后，每个森林产生301个三维类向量，导致对应于原始400维原始特征向量的1,806维变换特征向量。</p><p>通过使用多个尺寸的滑动窗口，最终的变换特征矢量将包括更多的特征，如下图所示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Deep%20Forest:%20Towards%20An%20Alternative%20to%20Deep%20Neural%20Networks/20170305234423503.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>concat成一个3618-dim的原始数据，表示原始的一个数据样本，第一级的输出是12+3618=3630，后面也是一样，直到最后第N级，只有12个输出，然后在每一类别上做avg，然后输出max那一类的label，那就是最终的预测类别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>带着深度学习的关键在于特征学习和巨大模型的能力这一认识，我们在本文中试图赋予树集成这些属性，并提出了 gcForest 方法。与深度神经网络相比，gcForest在我们的实验中表现了极高的竞争力或更好的性能。更重要的是，gcForest 具有少得多的超参数，并且对参数设置不太敏感；实际上在我们的实验中，通过使用相同的参数设置在不同的域中都获得了优异的性能，并且无论是大规模还是小规模的数据，它的工作都很好。此外，作为一种基于树的方法，gcForest 应该比深度神经网络更容易进行理论分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.ijcai.org/proceedings/2017/0497.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ijcai.org/proceedings/2017/0497.pdf&lt;
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线</title>
    <link href="https://github.com/zdkswd/2018/11/20/%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81%E7%9C%9F%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88TPR%EF%BC%89%E3%80%81%E5%81%87%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88FPR%EF%BC%89ROC%E6%9B%B2%E7%BA%BF/"/>
    <id>https://github.com/zdkswd/2018/11/20/精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线/</id>
    <published>2018-11-20T12:21:47.000Z</published>
    <updated>2018-11-23T13:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>已修改</p><h1 id="精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线"><a href="#精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线" class="headerlink" title="精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线"></a>精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线</h1><p>针对二分类问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81%E7%9C%9F%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88TPR%EF%BC%89%E3%80%81%E5%81%87%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88FPR%EF%BC%89ROC%E6%9B%B2%E7%BA%BF/314331-2023b85ae2a8d04f.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>精确率 = TP / (TP + FP)，表示返回的正例中真正例所占的比例；<br>召回率 = TP / (TP + FN)，表示返回的真正例占所有正例的比例。<br>真正类率（TPR），TPR = TP / (TP + FN)，返回的正类占所有正类的比例；（没错，跟召回率一个公式）TPR越大越好。<br>假正类率（FPR），FPR = FP / (FP + TN)，返回的负类占所有负类的比例。FPR越小越好<br>ROC curve:FPR越小越好。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%B2%BE%E7%A1%AE%E7%8E%87%E3%80%81%E5%8F%AC%E5%9B%9E%E7%8E%87%E3%80%81%E7%9C%9F%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88TPR%EF%BC%89%E3%80%81%E5%81%87%E6%AD%A3%E7%B1%BB%E7%8E%87%EF%BC%88FPR%EF%BC%89ROC%E6%9B%B2%E7%BA%BF/2394427-5f11fd1e6af07393.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于ROC来说，横坐标就是FPR，而纵坐标就是TPR，因此可以想见，当 TPR越大，而FPR越小时，说明分类结果是较好的。</p><p>AUC:<br>AUC 即ROC曲线下的面积，计算方式即为ROC Curve的微积分值，其物理意义可以表示为：随机给定一正一负两个样本，将正样本排在负样本之前的概率，因此AUC越大，说明正样本越有可能被排在负样本之前，即分类的结果越好。</p><p>ROC的总结：</p><ol><li>ROC 可以反映二分类器的总体分类性能，但是无法直接从图中识别出分类最好的阈值，事实上最好的阈值也是视具体的场景所定；</li><li>ROC Curve 对应的AUC越大说明分类性能越好;</li><li>ROC曲线一定是需要在 y = x之上的，否则就是一个不理想的分类器；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已修改&lt;/p&gt;
&lt;h1 id=&quot;精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线&quot;&gt;&lt;a href=&quot;#精确率、召回率、真正类率（TPR）、假正类率（FPR）ROC曲线&quot; class=&quot;headerlink&quot; title=&quot;精确率、召回率、真正类率（TPR）
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GBDT+LR</title>
    <link href="https://github.com/zdkswd/2018/11/20/GBDT+LR/"/>
    <id>https://github.com/zdkswd/2018/11/20/GBDT+LR/</id>
    <published>2018-11-20T07:56:56.000Z</published>
    <updated>2018-11-20T12:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h1><p>gbdt在各种竞赛是大放异彩。原因大概有几个，一是效果确实挺不错。二是即可以用于分类也可以用于回归。三是可以筛选特征。</p><h2 id="GBDT如何选择特征"><a href="#GBDT如何选择特征" class="headerlink" title="GBDT如何选择特征"></a>GBDT如何选择特征</h2><p>gbdt选择特征的细节其实是想问你CART Tree生成的过程。这里有一个前提，gbdt的弱分类器默认选择的是CART TREE。其实也可以选择其他弱分类器的，选择的前提是低方差和高偏差。框架服从boosting 框架即可。</p><h2 id="GBDT如何构建特征"><a href="#GBDT如何构建特征" class="headerlink" title="GBDT如何构建特征"></a>GBDT如何构建特征</h2><p>其实说gbdt 能够构建特征并非很准确，gbdt 本身是不能产生特征的，但是我们可以利用gbdt去产生特征的组合。逻辑回归本身是适合处理线性可分的数据，如果我们想让逻辑回归处理非线性的数据，其中一种方式便是组合不同特征，增强逻辑回归对非线性分布的拟合能力。</p><h2 id="GBDT如何用于分类"><a href="#GBDT如何用于分类" class="headerlink" title="GBDT如何用于分类"></a>GBDT如何用于分类</h2><p>GBDT 无论用于分类还是回归一直都是使用的CART <strong>回归树</strong>。不会因为我们所选择的任务是分类任务就选用分类树。</p><h2 id="GB训练强学习器的思路"><a href="#GB训练强学习器的思路" class="headerlink" title="GB训练强学习器的思路"></a>GB训练强学习器的思路</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/20180128125923199.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.49.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.50.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.51.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="GBDT原理"><a href="#GBDT原理" class="headerlink" title="GBDT原理"></a>GBDT原理</h2><p>对于任意的基分类器都可以利用GB的思想训练一个强分类器。而把基分类器选为决策树（DT)时，就是我们常用的GBDT。 </p><p>对于回归任务，当选择的loss function为Least-square。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.53.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>伪代码为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.54.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="GBDT例"><a href="#GBDT例" class="headerlink" title="GBDT例"></a>GBDT例</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%887.57.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.07.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.08.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="GDBT分类篇"><a href="#GDBT分类篇" class="headerlink" title="GDBT分类篇"></a>GDBT分类篇</h2><p>对于回归和分类，其实GBDT过程简直就是一模一样的。如果说最大的不同的话，那就是在于由于loss function不同而引起的初始化不同、叶子节点取值不同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.12.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="分类例"><a href="#分类例" class="headerlink" title="分类例"></a>分类例</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.13.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.14.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.16.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.17.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.18.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.18.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.19.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%888.21.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>多分类：<a href="https://blog.csdn.net/qq_22238533/article/details/79199605" target="_blank" rel="noopener">GBDT原理与实践-多分类篇 - SCUT_Sam - CSDN博客</a></p><h1 id="GBDT-LR"><a href="#GBDT-LR" class="headerlink" title="GBDT+LR"></a>GBDT+LR</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CTR预估（Click-Through Rate Prediction）是互联网计算广告中的关键环节，预估准确性直接影响公司广告收入。CTR预估中用的最多的模型是LR（Logistic Regression），LR是广义线性模型，与传统线性模型相比，LR使用了Logit变换将函数值映射到0~1区间，映射后的函数值就是CTR的预估值。LR这种线性模型很容易并行化，处理上亿条训练样本不是问题，但线性模型学习能力有限，需要大量特征工程预先分析出有效的特征、特征组合，从而去间接增强LR的非线性学习能力。</p><p>LR模型中的特征组合很关键， 但又无法直接通过特征笛卡尔积解决，只能依靠人工经验，耗时耗力同时并不一定会带来效果提升。如何自动发现有效的特征、特征组合，弥补人工经验不足，缩短LR特征实验周期，是亟需解决的问题。Facebook 2014年的文章介绍了通过GBDT（Gradient Boost Decision Tree）解决LR的特征组合问题，随后Kaggle竞赛也有实践此思路，GBDT与LR融合开始引起了业界关注。</p><p>GBDT（Gradient Boost Decision Tree）是一种常用的非线性模型，它基于集成学习中的boosting思想，每次迭代都在减少残差的梯度方向新建立一颗决策树，迭代多少次就会生成多少颗决策树。GBDT的思想使其具有天然优势可以发现多种有区分性的特征以及特征组合，决策树的路径可以直接作为LR输入特征使用，省去了人工寻找特征、特征组合的步骤。这种通过GBDT生成LR特征的方式（GBDT+LR），业界已有实践（Facebook，Kaggle-2014），且效果不错，是非常值得尝试的思路。</p><p>融合前人工寻找有区分性特征（raw feature）、特征组合、融合后直接通过黑盒子（Tree模型GBDT）进行特征、特种组合的自动发现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/2127249-a81329ce18881864.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在介绍这个模型之前，我们先来介绍两个问题：</p><ol><li>为什么要使用集成的决策树模型而不是单颗的决策树模型：<br>一棵树的表达能力很弱，不足以表达多个有区分性的特征组合，多棵树的表达能力更强一些。GBDT每棵树都在学习前面棵树尚存的不足，迭代多少次就会生成多少颗树。按paper以及Kaggle竞赛中的GBDT+LR融合方式，多棵树正好满足LR每条训练样本可以通过GBDT映射成多个特征的需求。</li><li>为什么建树采用GBDT而非RF：RF也是多棵树，但从效果上有实践证明不如GBDT。且GBDT前面的树，特征分裂主要体现对多数样本有区分度的特征；后面的树，主要体现的是经过前N颗树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，思路更加合理，这应该也是用GBDT的原因。</li></ol><h2 id="GBDT-LR的结构"><a href="#GBDT-LR的结构" class="headerlink" title="GBDT+LR的结构"></a>GBDT+LR的结构</h2><p>GBDT用来对训练集提取特征作为新的训练输入数据，LR作为新训练输入数据的分类器。</p><p>具体步骤：</p><ol><li>GBDT首先对原始训练数据做训练，得到一个二分类器，当然这里也需要利用网格搜索寻找最佳参数组合。</li><li>与通常做法不同的是，当GBDT训练好做预测的时候，输出的并不是最终的二分类概率值，而是要把模型中的每棵树计算得到的预测概率值所属的叶子结点位置记为1，这样，就构造出了新的训练数据。在用GBDT构造新的训练数据时，采用的正是One-hot方法。并且由于每一弱分类器有且只有一个叶子节点输出预测结果，所以在一个具有n个弱分类器、共计m个叶子结点的GBDT中，每一条训练数据都会被转换为1*m维稀疏向量，且有n个元素为1，其余m-n 个元素全为0。</li><li>新的训练数据构造完成后，下一步就要与原始的训练数据中的label(输出)数据一并输入到Logistic Regression分类器中进行最终分类器的训练。思考一下，在对原始数据进行GBDT提取为新的数据这一操作之后，数据不仅变得稀疏，而且由于弱分类器个数，叶子结点个数的影响，可能会导致新的训练数据特征维度过大的问题，因此，在Logistic Regression这一层中，可使用正则化来减少过拟合的风险，在Facebook的论文中采用的是L1正则化。</li></ol><p>GBDT与LR的融合方式，Facebook的paper有个例子如下图2所示，图中Tree1、Tree2为通过GBDT模型学出来的两颗树，x为一条输入样本，遍历两棵树后，x样本分别落到两颗树的叶子节点上，每个叶子节点对应LR一维特征，那么通过遍历树，就得到了该样本对应的所有LR特征。由于树的每条路径，是通过最小化均方差等方法最终分割出来的有区分性路径，根据该路径得到的特征、特征组合都相对有区分性，效果理论上不会亚于人工经验的处理方式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/1473228-20180917183111311-2021770645.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>论文中GBDT的参数，树的数量最多500颗（500以上就没有提升了），每棵树的节点不多于12。</p><p>GBDT模型的特点，非常适合用来挖掘有效的特征、特征组合。业界不仅GBDT+LR融合有实践，GBDT+FM也有实践，2014 Kaggle CTR竞赛冠军就是使用GBDT+FM（因子分解机），可见，使用GBDT融合其它模型是非常值得尝试的思路。</p><h2 id="RF-LR-Xgb-LR"><a href="#RF-LR-Xgb-LR" class="headerlink" title="RF + LR ? Xgb + LR?"></a>RF + LR ? Xgb + LR?</h2><p>例如Random Forest以及Xgboost等是并不是也可以按类似的方式来构造新的训练样本呢？没错，所有这些基于树的模型都可以和Logistic Regression分类器组合。</p><p>RF也是多棵树，但从效果上有实践证明不如GBDT。且GBDT前面的树，特征分裂主要体现对多数样本有区分度的特征；后面的树，主要体现的是经过前N颗树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，思路更加合理，这应该也是用GBDT的原因。</p><h2 id="GBDT与LR融合具体方案"><a href="#GBDT与LR融合具体方案" class="headerlink" title="GBDT与LR融合具体方案"></a>GBDT与LR融合具体方案</h2><p>在CTR预估中，如何利用AD ID是一个问题。直接将AD ID作为特征建树不可行，而onehot编码过于稀疏，为每个AD ID建GBDT树，相当于发掘出区分每个广告的特征。而对于曝光不充分的样本即长尾部分，无法单独建树。</p><p>综合方案为：使用GBDT对非ID和ID分别建一类树。</p><ol><li>非ID类树：<br>不以细粒度的ID建树，此类树作为base，即这些ID一起构建GBDT。即便曝光少的广告、广告主，仍可以通过此类树得到有区分性的特征、特征组合。</li><li>ID类树：<br>以细粒度 的ID建一类树（每个ID构建GBDT），用于发现曝光充分的ID对应有区分性的特征、特征组合。</li></ol><p>如何根据GBDT建的两类树，对原始特征进行映射？当一条样本x进来之后，遍历两类树到叶子节点，得到的特征作为LR的输入。当AD曝光不充分不足以训练树时，其它树恰好作为补充。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/GBDT+LR/GBDT%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8GBDT%E6%9E%84%E9%80%A0%E6%96%B0%E7%9A%84%E7%89%B9%E5%BE%814.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过GBDT转换得到特征空间相比于原始ID低了很多。</p><h2 id="如何使用得到的特征？"><a href="#如何使用得到的特征？" class="headerlink" title="如何使用得到的特征？"></a>如何使用得到的特征？</h2><p>通过GBDT生成的特征，可直接作为LR的特征使用，省去人工处理分析特征的环节，LR的输入特征完全依赖于通过GBDT得到的特征。此思路已尝试，通过实验发现GBDT+LR在曝光充分的广告上确实有效果，但整体效果需要权衡优化各类树的使用。同时，也可考虑将GBDT生成特征与LR原有特征结合起来使用，待尝试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于样本量大的数据，线性模型具有训练速度快的特点，但线性模型学习能力限于线性可分数据，所以就需要特征工程将数据尽可能地从输入空间转换到线性可分的特征空间。GBDT与LR的融合模型，其实使用GBDT来发掘有区分度的特征以及组合特征，来替代人工组合特征</p><h1 id="GBDT-LR-代码"><a href="#GBDT-LR-代码" class="headerlink" title="GBDT + LR 代码"></a>GBDT + LR 代码</h1><h2 id="sklearn多种模型ROC比较"><a href="#sklearn多种模型ROC比较" class="headerlink" title="sklearn多种模型ROC比较"></a>sklearn多种模型ROC比较</h2><p><a href="https://github.com/zdkswd/MLcode/blob/master/scikit-learn-code/sklearn-gbdt%2Blr.py">MLcode/sklearn-gbdt+lr.py at master · zdkswd/MLcode · GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GBDT&quot;&gt;&lt;a href=&quot;#GBDT&quot; class=&quot;headerlink&quot; title=&quot;GBDT&quot;&gt;&lt;/a&gt;GBDT&lt;/h1&gt;&lt;p&gt;gbdt在各种竞赛是大放异彩。原因大概有几个，一是效果确实挺不错。二是即可以用于分类也可以用于回归。三是可以筛选特征。&lt;/p
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>提升 boosting</title>
    <link href="https://github.com/zdkswd/2018/11/16/%E6%8F%90%E5%8D%87%20boosting/"/>
    <id>https://github.com/zdkswd/2018/11/16/提升 boosting/</id>
    <published>2018-11-16T08:08:47.000Z</published>
    <updated>2018-11-16T08:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习升级版-提升"><a href="#机器学习升级版-提升" class="headerlink" title="机器学习升级版 提升"></a>机器学习升级版 提升</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.25.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.27.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>把分错的样本权值调高，把分对的样本权值调低。会存在本来已经分对的点在下次划分时被分错的情况。基本上可以避免这种情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.28.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%883.41.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对树求梯度，一个树就是一个函数的样子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%883.50.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%889.49.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.12.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>yhat（t-1）是前t-1棵树累加对样本的预测值，ft(x)是第t棵树对样本的预测值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.13.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.36.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.37.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>ft没什么意义，只有变成w才有意义。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.40.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8A%E5%8D%8810.54.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>wj就是样本落在叶子节点的预测值，Gj就是落在节点的一阶梯度的加和，Hj是落在节点的二阶梯度的加和。λ是一个超参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8B%E5%8D%882.54.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>XGBoost小结<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8B%E5%8D%882.58.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-11%20%E4%B8%8B%E5%8D%883.13.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>αm是第m个分类器的权值。</p><h1 id="统计学习方法-提升方法"><a href="#统计学习方法-提升方法" class="headerlink" title="统计学习方法 提升方法"></a>统计学习方法 提升方法</h1><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><p>在概率近似正确(probably approximately correct, <strong>PAC</strong>)学习的框架中，一个概念(一个类)，如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是<strong>强可学习</strong>的;一个概念，如果存在一个多项式的学习算法能够学习它,学习的正确率仅比随机猜测略好，那么就称这个概念是<strong>弱可学习</strong>的.</p><p>如果已经发现了“弱学习算法”，将它提升(boost) 为“强学习算法”.大家知道，发现弱学习算法通常要比发现强学习算法容易得多.那么如何具体实施提升，便成为开发提升方法时所要解决的问题.关于提升方法的研究很多，有很多算法被提出.最具代表性的是AdaBoost算法。</p><p>对于分类问题而言，给定一个训练样本集，求比较粗糙的分类规则(弱分类器)要比求精确的分类规则(强分类器)容易得多.提升方法就是从弱学习算法出发， 反复学习，得到一系列弱分类器(又称为基本分类器)，然后组合这些弱分类器，构成一个强分类器.大多数的提升方法都是改变训练数据的概率分布(训练数据的权值分布)，针对不同的训练数据分布调用弱学习算法学习一系列弱分类器.</p><p>对提升方法来说，有两个问题需要回答:一是在每一轮如何改变训练数据的权值或概率分布;二是如何将弱分类器组合成一个强分类器.关于第1个问题，AdaBoost的做法是，<strong>提高</strong>那些被前一轮弱分类器<strong>错误分类样本的权值</strong>，而<strong>降低</strong>那些被<strong>正确分类样本的权值</strong>.这样一来，那些没有得到正确分类的数据，由于其权值的加大而受到后一轮的弱分类器的更大关注.于是，分类问题被一系列的弱分类器“分而治之”.至于第2个问题，即弱分类器的组合，AdaBoost 采取加权多数表决的方法.具体地，<strong>加大</strong>分类<strong>误差率小</strong>的弱分类器的<strong>权值</strong>，使其在表决中起较大的作用，<strong>减小</strong>分类<strong>误差率大</strong>的弱分类器的<strong>权值</strong>，使其在表决中起较小的作用.</p><h3 id="AdaBoost算法"><a href="#AdaBoost算法" class="headerlink" title="AdaBoost算法"></a>AdaBoost算法</h3><p>给定一个二类分类的训练数据集。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%884.52.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="算法（AdaBoost）"><a href="#算法（AdaBoost）" class="headerlink" title="算法（AdaBoost）"></a>算法（AdaBoost）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%884.53.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%884.55.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="AdaBoost的例子"><a href="#AdaBoost的例子" class="headerlink" title="AdaBoost的例子"></a>AdaBoost的例子</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.08.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.09.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.10.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="AdaBoost算法的训练误差分析"><a href="#AdaBoost算法的训练误差分析" class="headerlink" title="AdaBoost算法的训练误差分析"></a>AdaBoost算法的训练误差分析</h2><p>AdaBoost最基本的性质是它能在学习过程中不断减少训练误差，即在训练数据集上的分类误差率。</p><h3 id="定理（AdaBoost的训练误差界）"><a href="#定理（AdaBoost的训练误差界）" class="headerlink" title="定理（AdaBoost的训练误差界）"></a>定理（AdaBoost的训练误差界）</h3><p>AdaBoost算法最终分类器的训练误差界为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.21.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一定理说明，可以在每一轮选取适当的Gm使得Zm最小，从而使训练误差下降最快。对二类分类问题，有如下结果：</p><h3 id="定理（二类分类问题AdaBoost的训练误差界）"><a href="#定理（二类分类问题AdaBoost的训练误差界）" class="headerlink" title="定理（二类分类问题AdaBoost的训练误差界）"></a>定理（二类分类问题AdaBoost的训练误差界）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.24.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%885.24.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这表明在此条件下AdaBoost的训练误差是以指数速率下降的。这一性质当然很有吸引力。</p><p>AdaBoost算法不需要知道下界y.与早期的提升方法不同，AdaBoost具有适应性，即它能适应弱分类器各自的训练误差率。</p><h2 id="AdaBoost算法的解释"><a href="#AdaBoost算法的解释" class="headerlink" title="AdaBoost算法的解释"></a>AdaBoost算法的解释</h2><p>AdaBoost算法还有另一个解释，即可以认为AdaBoost算法是模型为加法模型、损失函数为指数函数、学习算法为前向分布算法时的二类分类学习方法。</p><h3 id="前向分布算法"><a href="#前向分布算法" class="headerlink" title="前向分布算法"></a>前向分布算法</h3><p>考虑加法模型<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.01.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中b（x;ym）为基函数，ym为基函数的参数，Bm为基函数的系数。</p><p>在给定训练数据及损失函数L（y，f（x））的条件下，学习加法模型f(x)成为损失函数极小化问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.06.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通常这是一个复杂得优化问题。前向分步算法求解这一优化问题的想法是，因为学习的是加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近目标函数式，就可以简化优化的复杂度。具体的，每步只需优化损失函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.09.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="前向分步算法"><a href="#前向分步算法" class="headerlink" title="前向分步算法"></a>前向分步算法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.12.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%886.14.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="前向分步算法与AdaBoost"><a href="#前向分步算法与AdaBoost" class="headerlink" title="前向分步算法与AdaBoost"></a>前向分步算法与AdaBoost</h3><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>AdaBoost算法是前向分步算法加法算法的特例。这时模型是由基本分类器组成的加法模型，损失函数是指数函数。</p><h2 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h2><p>提升树是以分类树或回归树为基本分类器的提升方法.提升树被认为是统计学习中性能最好的方法之一。</p><h3 id="提升树模型"><a href="#提升树模型" class="headerlink" title="提升树模型"></a>提升树模型</h3><p>提升方法实际采用加法模型（即基函数的线性组合）与前向分步算法。以决策树为基函数的提升方法称为提升树（boosting tree）。对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。基本分类器x&lt;v,或x&gt;v，可以看做是由一个根结点直接连接两个叶节点的简单决策树，即所谓的决策树桩。提升树模型可以表示为决策树的加法模型：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%8810.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8B%E5%8D%8810.00.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="提升树算法"><a href="#提升树算法" class="headerlink" title="提升树算法"></a>提升树算法</h3><p>提升树算法采用前向分步算法.首先确定初始提升树f0(x)=0,第m步的模型是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.12.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，fm-1(x)为当前模型，通过最小化损失函数确定下一棵决策树的参数θm。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.13.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于树的线性组合可以很好地拟合训练数据，即使数据中的输入与输出之间的关系很复杂也是如此，所以提升树是一个高功能的学习算法.</p><p>针对不同问题的提升树学习算法，其主要区别在于使用的<strong>损失函数不同</strong>.包括用<strong>平方误差损失函数</strong>的<strong>回归</strong>问题，用<strong>指数损失</strong>函数的<strong>分类</strong>问题，以及用<strong>一般损失函数</strong>的<strong>一般决策问题</strong>.</p><h4 id="基函数是分类树（二叉分类树）"><a href="#基函数是分类树（二叉分类树）" class="headerlink" title="基函数是分类树（二叉分类树）"></a>基函数是分类树（二叉分类树）</h4><p>对于基函数是分类树时，我们使用指数损失函数，此时正是AdaBoost算法的特殊情况，即将AdaBoost算法中的基分类器使用分类树即可。</p><h4 id="回归问题的提升树算法（基函数是回归树）"><a href="#回归问题的提升树算法（基函数是回归树）" class="headerlink" title="回归问题的提升树算法（基函数是回归树）"></a>回归问题的提升树算法（基函数是回归树）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.18.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.19.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.22.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.22.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.24.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h3><p>提升树利用加法模型与前向分步算法实现学习的优化过程.当损失函数是平方损失和指数损失函数时，每一步优化是很简单的.但对一一般损失函数而言，往往每一步优化并不那么容易.针对这一问题，Freidman 提出了梯度提升(gradient<br>boosting)算法，这是利用最速下降法的近似方法，其关键是利用损失函数负梯度在当前模型的值<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.27.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>作为回归问题提升树算法中的<strong>残差的近似值</strong>，拟合一个<strong>回归树</strong>。</p><h4 id="梯度提升算法"><a href="#梯度提升算法" class="headerlink" title="梯度提升算法"></a>梯度提升算法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.31.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8A%E5%8D%8810.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>Bagging + 决策树 = 随机森林<br>AdaBoost + 决策树 = 提升树<br>Gradient Boosting + 决策树 = GBDT</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="AdaBoost单层决策树"><a href="#AdaBoost单层决策树" class="headerlink" title="AdaBoost单层决策树"></a>AdaBoost单层决策树</h2><p>分类问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/mL_10_12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，如果想要试着从某个坐标轴上选择一个值（即选择一条与坐标轴平行的直线）来将所有的蓝色圆点和橘色圆点分开，这显然是不可能的。这就是单层决策树难以处理的一个著名问题。通过使用多颗单层决策树，我们可以构建出一个能够对该数据集完全正确分类的分类器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%8F%90%E5%8D%87%20boosting/mL_10_13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>蓝横线上边的是一个类别，蓝横线下边是一个类别。显然，此时有一个蓝点分类错误，计算此时的分类误差，误差为1/5 = 0.2。这个横线与坐标轴的y轴的交点，就是我们设置的阈值，通过不断改变阈值的大小，找到使单层决策树的分类误差最小的阈值。同理，竖线也是如此，找到最佳分类的阈值，就找到了最佳单层决策树。</p><p>通过遍历，改变不同的阈值，计算最终的分类误差，找到分类误差最小的分类方式，即为我们要找的最佳单层决策树。这里lt表示less than，表示分类方式，对于小于阈值的样本点赋值为-1，gt表示greater than，也是表示分类方式，对于大于阈值的样本点赋值为-1。经过遍历，我们找到，训练好的最佳单层决策树的最小分类误差为0.2，就是对于该数据集，无论用什么样的单层决策树，分类误差最小就是0.2。这就是我们训练好的弱分类器。接下来，使用AdaBoost算法提升分类器性能，将分类误差缩短到0。此时使用AdaBoost提升分类器性能。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/AdaBoost%E5%8D%95%E5%B1%82%E5%86%B3%E7%AD%96%E6%A0%91.py">MLcode/AdaBoost单层决策树.py at master · zdkswd/MLcode · GitHub</a></p><p>通过改变样本的权值，会改变分类误差率，以选择分类误差率最小的弱选择器。</p><h2 id="scikit-learn-AdaBoost"><a href="#scikit-learn-AdaBoost" class="headerlink" title="scikit-learn AdaBoost"></a>scikit-learn AdaBoost</h2><p>sklearn.ensemble.AdaBoostClassifier共有五个参数，参数说明。</p><ol><li><strong>base_estimator</strong>:默认为<strong>DecisionTreeClassifier</strong>。理论上可以选择任何一个分类或者回归学习器，不过需要支持样本权重。AdaBoostClassifier默认使用CART分类树DecisionTreeClassifier，而AdaBoostRegressor默认使用CART回归树DecisionTreeRegressor。另外有一个要注意的点是，如果我们选择的AdaBoostClassifier算法是SAMME.R，则我们的弱分类学习器还需要支持概率预测，也就是在scikit-learn中弱分类学习器对应的预测方法除了predict还需要有predict_proba。</li><li><strong>algorithm</strong>：可选参数，默认为<strong>SAMME.R</strong>。scikit-learn实现了两种Adaboost分类算法，SAMME和SAMME.R。两者的主要区别是弱学习器权重的度量，SAMME使用对样本集分类效果作为弱学习器权重，而SAMME.R使用了对样本集分类的预测概率大小来作为弱学习器权重。由于SAMME.R使用了概率度量的连续值，迭代一般比SAMME快，因此AdaBoostClassifier的默认算法algorithm的值也是SAMME.R。我们一般使用默认的SAMME.R就够了，但是要注意的是使用了SAMME.R， 则弱分类学习器参数base_estimator必须限制使用支持概率预测的分类器。SAMME算法则没有这个限制。</li><li><strong>n_estimators</strong>：整数型，可选参数，默认为50。弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。默认是50。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。</li><li><strong>learning_rate</strong>：浮点型，可选参数，默认为1.0。每个弱学习器的权重缩减系数，取值范围为0到1，对于同样的训练集拟合效果，较小的v意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。所以这两个参数n_estimators和learning_rate要一起调参。一般来说，可以从一个小一点的v开始调参，默认是1。</li><li><strong>random_state</strong>：整数型，可选参数，默认为None。如果RandomState的实例，random_state是随机数生成器; 如果None，则随机数生成器是由np.random使用的RandomState实例。<br><a href="https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn-AdaBoost">https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn-AdaBoost</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习升级版-提升&quot;&gt;&lt;a href=&quot;#机器学习升级版-提升&quot; class=&quot;headerlink&quot; title=&quot;机器学习升级版 提升&quot;&gt;&lt;/a&gt;机器学习升级版 提升&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
           
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Practical Lessons from Predicting Clicks on Ads at Facebook</title>
    <link href="https://github.com/zdkswd/2018/11/16/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/"/>
    <id>https://github.com/zdkswd/2018/11/16/Practical Lessons from Predicting Clicks on Ads at Facebook/</id>
    <published>2018-11-16T07:48:56.000Z</published>
    <updated>2018-11-16T07:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dl.acm.org/citation.cfm?id=2648589" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=2648589</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在线广告允许广告商只投标和支付可测量的用户响应，比如广告的点击。所以，点击预测系统时大多数广告系统的中心。有超过7.5亿的日活用户和超过一百万的活跃广告商，预测Facebook广告点击是一项有挑战的机器学习任务。这篇论文介绍一个决策树加逻辑回归的组合模型，使用组合模型的效果比单独使用模型的效果提升3%，这会对整体系统的表现的提升产生重大影响。作者探索了一些基础参数怎么影响系统的最终预测表现。不出意外的是，最重要的事情是拥有正确的特征：捕获到的用户和广告的历史信息支配着其他类型的特征。一旦我们有了正确的特征和正确的模型（决策树加逻辑回归），其他的因素就影响很小（虽然小的改进在规模上很重要）。选择对数据新鲜度，学习率模式，和数据采样的最佳处理能够轻微的改变模型，但远不如一开始就选择高价值的特征或选择正确的模型。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这篇论文的目的就是分享用真实世界的数据，并且具有鲁棒性和适应性的实验中得到的见解。</p><p>Facebook由于其特殊性，不能使用搜索记录进行广告推荐，而是基于对用户的定位，所以可展示广告的量也更多。Facebook为此建立的<strong>级联分类器</strong>。这篇文章专注于级联分类器的最后一个阶段点击预测模型，就是这个模型对最终的候选广告集的广告进行预测是否会被点击。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*级联分类器*</span><br><span class="line">级联是基于几个分类器的串联的集合学习的特定情况，使用从给定分类器的输出收集的所有信息作为级联中的下一个分类器的附加信息。与投票或堆叠合奏（多专家系统）不同，级联是多阶段的。</span><br></pre></td></tr></table></figure></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>主要介绍实验计划。<br><strong>实验数据</strong>：2013年第4季度任意1周的离线训练数据，与线上数据相似。分为训练集和测试集，并且使用它们模拟在线训练和预测的流数据。论文中实验使用的都是相同的训练/测试数据。</p><p><strong>评估指标</strong>：<br><strong>Normalized Entropy</strong> （NE），NE定义为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-16%20%E4%B8%8B%E5%8D%881.26.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中yi属于{-1，+1}，p为经验点击通过率CTR（即广告实际点击次数除以广告展示量）。NE在计算相关的信息增益时是至关重要的。上面是逻辑回归的损失函数，也就是交叉熵。下面是个常数，所以越小值，模型越好。</p><p><strong>Calibration</strong> （刻度标度）：评价估计CTR和经验CTR的比率。即预期点击次数与实际观察点击次数的比率。越接近1模型效果越好。</p><h1 id="预测模型结构"><a href="#预测模型结构" class="headerlink" title="预测模型结构"></a>预测模型结构</h1><p>评估不同的概率线性分类器和不同的在线学习算法。<br>混合模型结构：提升决策树和概率稀疏线性分类器的串联。<br>学习算法是用的是Stochastic Gradient Descent(SGD)，或者Bayesian online learning scheme for probit regression(BOPR)都可以。但是最终选择的是SGD，原因是资源消耗要小一些。<br>SGD和BOPR都可以针对单个样本进行训练，所以他们可以做成流式的学习器(stream learner)。</p><h2 id="决策树特征转换"><a href="#决策树特征转换" class="headerlink" title="决策树特征转换"></a>决策树特征转换</h2><p>对于一个样本，针对每一颗树得到一个类别型特征。该特征取值为样本在树中落入的叶节点的编号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288567782120.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上图中的提升决策树包含两棵子树，第一棵树包含3个叶节点，第二棵树包含2个叶节点。输入样本x，在两棵树种分别落入叶子节点2和叶子节点1。那么特征转换就得到特征向量[0 1 0 1 0]。也就是说，把叶节点编号进行one-hot编码。</p><p>直观的理解这种特征变化：</p><ol><li>看做是一种有监督的特征编码。把实值的vector转化为紧凑的二值的vector。</li><li>从根节点到叶节点的一条路径，表示的是在特征上的一个特定的规则。所以，叶节点的编号代表了这种规则。表征了样本中的信息，而且进行了非线性的组合变换。</li><li>最后再对叶节点编号组合，相当于学习这些规则的权重。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288712733387.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Data-freshness"><a href="#Data-freshness" class="headerlink" title="Data freshness"></a>Data freshness</h2><p>一天的数据作为训练集，其后的一天活几天作为测试数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288714646409.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以发现随着天数的增加，data freshness也变得越来越差，模型的性能也越来越差。</p><p>一种做法是说每天都重新训练。即使是mini-batch来训练，也会非常耗时。提升树的训练时间受很多因素的影响，比如：样本数量、树深度、树数量、叶子节点个数等。为了加快速度，可以在多CPU上通过并行化来实现。</p><p>我们可以：</p><ol><li>提升树可以一天或者几天来训练一次。</li><li>LR可以实现在线学习，几乎是实时训练。</li></ol><h2 id="LR线性分类器"><a href="#LR线性分类器" class="headerlink" title="LR线性分类器"></a>LR线性分类器</h2><p>针对Logistic Regression进行在线增量训练。也就是说只要用户点击了广告，生成了新的样本，就进行增量训练。</p><p>Facebook针对SGD-based online learning研究了5中学习速率的设置方式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288719387888.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ol><li>前三种使得不同的参数有不同的学习速率</li><li>后两种对于所有的参数都是用相同的学习速率<br>实验结果显示Per-coordinate learning rate效果最好： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288720145598.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="线上模型架构"><a href="#线上模型架构" class="headerlink" title="线上模型架构"></a>线上模型架构</h1>最关键的步骤就是把labels(click/no-click)和训练输入(ad impressions)以一种在线的方式连起(join)起来。所以系统被称为online data joiner。<h2 id="label标注"><a href="#label标注" class="headerlink" title="label标注"></a>label标注</h2>首先设定一个足够长的阈值。一个广告展示给用户之后，如果用户在阈值的时间内没有点击广告就标记为no-click，点击了的话就标记为click。这个等待的时间窗口需要非常小心的调整。<br>如果太长了，会增加缓存impression的内存消耗，而且影响实时数据的产生；如果太短了则会导致丢失一部分的点击样本，会影响click converage 点击覆盖。<br>click converage 点击覆盖表示有多少个点击行为被记录了下来生成了样本。online data joiner必须保证尽可能高的点击覆盖，也就是尽可能多的来记录下来所有的点击行为。但是如果等待太久就会增加缓存开销等影响。所以online data joiner必须在click converage和资源消耗之间做出平衡<h2 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288063310673.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="处理大量的训练数据"><a href="#处理大量的训练数据" class="headerlink" title="处理大量的训练数据"></a>处理大量的训练数据</h1>很多的计算广告领域的训练数据量都是非常巨大的，那么如何有效的控制训练带来的开销就非常重要。常用的办法是采样<h2 id="均匀采样"><a href="#均匀采样" class="headerlink" title="均匀采样"></a>均匀采样</h2>均匀采样非常的简单，易于实现。而且使用均匀采样没有改变训练数据的分布，所以模型不需要修改就可以直接应用于测试数据。</li></ol><p>不同采样率对模型性能的影响：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288758580098.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Negative-down-sampling"><a href="#Negative-down-sampling" class="headerlink" title="Negative down sampling"></a>Negative down sampling</h2><p>计算广告中大部分的训练样本都极度不平衡，这对模型会造成很大影响。一种解决办法就是对负样本进行欠采样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288761292102.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到采样率不同，对模型性能影响很大。采样率为0.025的时候取得最好结果。</p><h2 id="Model-Re-Calibration"><a href="#Model-Re-Calibration" class="headerlink" title="Model Re-Calibration"></a>Model Re-Calibration</h2><p>负样本欠采样可以加快训练速度并提升模型性能。但是同样带来了问题：改变了训练数据分布。所以需要进行校准。<br>举例来说，采样之前CTR均值为0.1%，使用0.01采样之后，CTR均值变为10%。我们需要对模型进行Calibration(校准)使得模型在实际预测的时候恢复成0.1%。调整公式如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288763715313.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中w是采样率，p是在采样后空间中给出的CTR预估值，计算得到的q就是修正后的结果。</p><h1 id="其他实验结果"><a href="#其他实验结果" class="headerlink" title="其他实验结果"></a>其他实验结果</h1><p>所有的这些探索都是为了能够平衡模型性能(accuracy)和资源消耗(内存、CPU)。只有当你充分了解模型和数据每个部分后，才能根据实际情况做出最佳的取舍。</p><h2 id="Number-of-boosting-trees"><a href="#Number-of-boosting-trees" class="headerlink" title="Number of boosting trees"></a>Number of boosting trees</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288739728495.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>boosting tree数量从1到2000，叶节点个数被限制为最大12个。submodel之间的区别在于训练数据大小的不同，比如submodel 2的训练数据只有前面两个的1/4。<br>可以看到随着boosting tree数量的增加，模型的性能有所提升。但是几乎所有的提升都来自于前500个trees，而后面的1000个trees的提升甚至都不到0.1%。submodel 2在1000颗trees甚至模型效果在变差，原因是过拟合。</p><h2 id="Boosting-feature-importance"><a href="#Boosting-feature-importance" class="headerlink" title="Boosting feature importance"></a>Boosting feature importance</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288742530967.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图首先对特征按照重要程度来进行排序，编号后再画图。特征重要程度按照使用该特征进行分裂，所带来的loss减小的累积量。因为一个特征可以在多颗树上进行使用，所以累积要在所有的树上进行。</p><p>上图中，黄线表示对特征进行累加后的值，然后进行log变换。可以看到最终结果是1，表示所有特征的重要度总和是1. 最重要的是期初非常陡峭，上升的非常快，说明特征重要度主要集中在top10这些特征中。前10个特征，贡献了50%的重要度，后面300个特征，贡献了1%的重要度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288746104351.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>显然，全部去掉是不行的。说明大量弱特征的累积也是很重要的，但是去掉部分不那么重要的特征，对模型的影响比较小，比如从400到200。</p><h2 id="Historical-features-VS-Context-features"><a href="#Historical-features-VS-Context-features" class="headerlink" title="Historical features VS Context features"></a>Historical features VS Context features</h2><p>针对两大类特征：历史信息特征（用户+广告）、上下文特征。论文还研究了这两类特征对模型性能的贡献程度。先给出结论：历史信息特征占主导地位。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Practical%20Lessons%20from%20Predicting%20Clicks%20on%20Ads%20at%20Facebook/15288750694203.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样，先把特征按照重要程度排序，再画图。横轴是特征数量，纵轴是historical特征在top k个重要特征中所占的百分比。可以看到前10个特征中，全是历史信息特征；前20个特征中，只有2个上下文特征。所以：历史信息特征比上下文特征重要太多了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Facebook提出的LR + GBDT来提取非线性特征进行特征组合的方式非常经典，主要特性总结如下：</p><ol><li>Data Freshness很重要。模型至少一天需要重新训练一次</li><li>使用Boosted Decision Tree进行特征转换很大程度上提高了模型的性能</li><li>最好的在线学习方法：LR + per-coordinate learning rate</li></ol><p>关于平衡计算开销和模型性能所采用的技巧：</p><ol><li>调整Boosted decision trees数量</li><li>去掉部分重要性低的特征，对模型的影响比较小。但是不能全去掉</li><li>相比于上下文特征，用户/广告历史特征要重要的多</li><li>针对大量训练数据可以进行欠采样</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2648589&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dl.acm.org/citation.cfm?id=2648589&lt;/a&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="论文" scheme="https://github.com/zdkswd/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>回归</title>
    <link href="https://github.com/zdkswd/2018/11/16/%E5%9B%9E%E5%BD%92/"/>
    <id>https://github.com/zdkswd/2018/11/16/回归/</id>
    <published>2018-11-16T04:34:47.000Z</published>
    <updated>2018-11-16T10:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习升级版-回归"><a href="#机器学习升级版-回归" class="headerlink" title="机器学习升级版 回归"></a>机器学习升级版 回归</h1><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.12.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.13.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.15.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 通过样本拟合直线，线性回归。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.27.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>做一个理论的假定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.30.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.35.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.36.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>目标函数不就是个最小二乘法了吗。</p><p>关于假设：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.39.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.40.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.41.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.49.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%886.59.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.06.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至于为什么要跟西塔有关，因为在震荡很大的函数中θ系数很大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.07.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Ridge是θ的平方和，LASSO是θ绝对值相加。</p><p>L2范数，L1范数与混合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.13.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>LASSO有一定的特征选择能力，随着次数的增高，高次项系数趋近于0了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%887.44.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>L1的形式很像拉格拉日乘子法，正方形区域内是可行域，当取最小值时，某些轴上会取0值。推广一下，轴数高了，某些权值是0，也就具有了一定选择能力。</p><p>对于L1范数中的λ，就是超参数，我们无法从样本中确定λ的值，只能通过验证数据去选。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.05.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.34.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.45.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.46.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个函数是个凸函数，解出来的一定是全局最小的。可以看到式中的求和符号，所有样本求和下降一回。BSD<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.52.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>式中没有求和符号，一个样本下降一回。SGD，适合做在线学习。适合跳出局部极小值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%888.58.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>mini-batchSGD，简称了SGD，其实这种叫法并不严谨。习惯用语。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%889.06.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们的线性回归是对参数的线性。对样本无所谓。</p><h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>分类问题的首选算法，多分类：softmax回归。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.14.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.25.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.32.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里的目标函数取最大值，因为是最大似然估计。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.48.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.50.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>逻辑回归是一个对数上的线性模型。 </p><p>若是想让一个几率是线性的函数，反过来求概率，就是逻辑回归的形式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%889.53.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>损失函数就是似然函数取负号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.19.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个损失函数不那么漂亮，我们可以把它写得漂亮一些。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.21.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8A%E5%8D%8810.56.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>关于似然函数的解释：最靠近p的那个乘积由于是one-hot编码所以其实连乘的话只有一项就是表达式其他项均为1。<br>由于是求随机梯度下降，所以可以不管第一个求和符号，目标函数为后一部分。<br>logistic回归中式子中的1其实是e的零次方。</p><h2 id="定义信息量"><a href="#定义信息量" class="headerlink" title="定义信息量"></a>定义信息量</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>期望的结果就是信息熵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.35.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>底无所谓是几，因为有换底公式，无非就是多了个系数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.37.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> 这个图像说明当两点分布时如果概率相同，熵是最大的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.46.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.48.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.50.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="联合熵和条件熵"><a href="#联合熵和条件熵" class="headerlink" title="联合熵和条件熵"></a>联合熵和条件熵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.54.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.56.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%887.58.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.04.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.06.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.05.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-03%20%E4%B8%8B%E5%8D%888.07.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>相对熵（relative entropy）就是KL散度（Kullback–Leibler divergence），用于衡量两个概率分布之间的差异。相对熵的特点，是只有p(x)=q(x)时，其值为0。若p(x)和q(x)略有差异，其值就会大于0。</p><p>假设我们想知道某个策略和最优策略之间的差异，我们就可以用相对熵来衡量这两者之间的差异。即，相对熵 = 某个策略的交叉熵 - 信息熵（根据系统真实分布计算而得的信息熵，为最优策略）</p><p>后半部分相当于了一个常数，相对熵达到最小值的时候，也意味着交叉熵达到了最小值。</p><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>负对数似然就等于交叉熵损失。我们可以把Logstic回归损失叫做交叉熵损失。其中p表示真实分布，q表示非真实分布。p表示真实标记的分布，q则为训练后的模型的预测标记分布。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="统计学习方法-逻辑斯蒂回归与最大熵模型"><a href="#统计学习方法-逻辑斯蒂回归与最大熵模型" class="headerlink" title="统计学习方法 逻辑斯蒂回归与最大熵模型"></a>统计学习方法 逻辑斯蒂回归与最大熵模型</h1><p>逻辑斯蒂回归与最大熵模型都属于对数线性模型。</p><h2 id="逻辑斯蒂回归模型"><a href="#逻辑斯蒂回归模型" class="headerlink" title="逻辑斯蒂回归模型"></a>逻辑斯蒂回归模型</h2><h3 id="逻辑斯蒂分布"><a href="#逻辑斯蒂分布" class="headerlink" title="逻辑斯蒂分布"></a>逻辑斯蒂分布</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设X是连续随机变量，X服从逻辑斯蒂分布时指X具有下列分布函数和密度函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%8812.43.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>u为位置参数，y&gt;0为形状参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%8812.45.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="二项逻辑斯蒂回归模型"><a href="#二项逻辑斯蒂回归模型" class="headerlink" title="二项逻辑斯蒂回归模型"></a>二项逻辑斯蒂回归模型</h3><p>二项逻辑斯蒂回归模型是一种分类模型，形式为参数化的逻辑斯蒂分布。随机变量X取值为实数，随机变量Y取值为1或0。我们通过监督学习方法来估计模型参数。</p><h4 id="定义（逻辑斯蒂回归模型）"><a href="#定义（逻辑斯蒂回归模型）" class="headerlink" title="定义（逻辑斯蒂回归模型）"></a>定义（逻辑斯蒂回归模型）</h4><p>二项逻辑斯蒂回归模型是如下的条件概率分布：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%8812.54.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>x是输入，Y取{0，1}是输出，w，b是参数，w称为权值向量，b称为偏置。对于输入实例x，逻辑回归比较两个条件概率值的大小，将x分到概率值较大的那一类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.04.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一个事件的几率（odds）指该事件发生的概率与该事件不发生的概率的比值，事件发生的概率为p，则事件的对数几率（log odds）或logit函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.11.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即输出Y=1的对数几率是由输入x的线性函数表示的模型，即逻辑斯蒂回归模型。<br>换一个角度看，考虑对输入x进行分类的线性函数wx,其值域为实数域。通过逻辑斯蒂回归模型可以将线性函数wx转换为概率：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.22.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这时，线性函数的值越接近正无穷，概率值就越接近1，线性函数的值越接近负无穷，概率值就越接近0.</p><h3 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h3><p>可以应用极大似然估计法估计模型参数，从而得到逻辑斯蒂回归模型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.41.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="多项逻辑斯蒂回归"><a href="#多项逻辑斯蒂回归" class="headerlink" title="多项逻辑斯蒂回归"></a>多项逻辑斯蒂回归</h3><p>假设离散型随机变量Y的取值集合是{1,2,…,K}，那么多项逻辑斯蒂回归模型是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.44.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>二项逻辑斯蒂回归的参数估计法也可以推广到多项逻辑斯蒂回归。</p><h2 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h2><p>最大熵原理是概率模型学习的一个准则.最大熵原理认为，学习概率模型时，在所有可能的概率模型(分布)中，熵最大的模型是最好的模型.通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中<strong>选取熵最大的模型</strong>.</p><p>假设离散随机变量X的概率分布是P（X），则其熵是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%881.49.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当X服从均匀分布时，熵最大。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h2 id="梯度上升算法"><a href="#梯度上升算法" class="headerlink" title="梯度上升算法"></a>梯度上升算法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>z是一个矩阵，θ是参数列向量(要求解的)，x是样本列向量(给定的数据集)。θ^T表示θ的转置。g(z)函数实现了任意实数到[0,1]的映射，这样我们的数据集([x0,x1,…,xn])，不管是大于1或者小于0，都可以映射到[0,1]区间进行分类。hθ(x)给出了输出为1的概率。比如当hθ(x)=0.7，那么说明有70%的概率输出为1。输出为0的概率是输出为1的补集，也就是30%。如果这个概率大于0.5，我们就可以说样本是正样本，否则样本是负样本。</p><p>对于正样本，概率越接近一，分类效果越好，对于负样本，1-负样本的值越接近1越好。对于正样本和负样本两个公式合二为一：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了简化问题，对表达式求对数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至此，针对一个样本的代价函数已经出来了，假定样本与样本之间相互独立，整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便得到公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-15%20%E4%B8%8B%E5%8D%886.54.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>满足J(θ)的最大的θ值即是我们需要求解的模型。<br>由于是求最大值，所以我们需要使用梯度上升算法，也就是求负值的最小也就是梯度下降。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/ml_6_26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="逻辑回归的优缺点"><a href="#逻辑回归的优缺点" class="headerlink" title="逻辑回归的优缺点"></a>逻辑回归的优缺点</h2><p>如何凸显你是一个对逻辑回归已经非常了解的人呢。那就是用一句话概括它！逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。</p><p>逻辑回归应用到工业界中的一些优点：</p><ol><li>形式简单，模型的可解释性非常好。从特征的权重可以看到不同的特征对最后结果的影响，某个特征的权重值比较高，那么这个特征最后对结果的影响会比较大。</li><li>模型效果不错。在工程上是可以接受的（作为baseline)，如果特征工程做的好，效果不会太差，并且特征工程可以大家并行开发，大大加快开发的速度。</li><li>训练速度较快。分类的时候，计算量仅仅只和特征的数目相关。并且逻辑回归的分布式优化sgd发展比较成熟，训练的速度可以通过堆机器进一步提高，这样我们可以在短时间内迭代好几个版本的模型。</li><li>资源占用小,尤其是内存。因为只需要存储各个维度的特征值。</li><li>方便输出结果调整。逻辑回归可以很方便的得到最后的分类结果，因为输出的是每个样本的概率分数，我们可以很容易的对这些概率分数进行cutoff，也就是划分阈值(大于某个阈值的是一类，小于某个阈值的是一类)。</li></ol><p>缺点：</p><ol><li>准确率并不是很高。因为形式非常的简单(非常类似线性模型)，很难去拟合数据的真实分布。</li><li>很难处理数据不平衡的问题。</li><li>处理非线性数据较麻烦。逻辑回归在不引进其他方法的情况下，只能处理线性可分的数据，或者进一步说，处理二分类的问题。</li><li>逻辑回归本身无法筛选特征。有时候，我们会用gbdt来筛选特征，然后再上逻辑回归。</li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h2><p>评价分类的指标。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%882.40.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="差分与取对数"><a href="#差分与取对数" class="headerlink" title="差分与取对数"></a>差分与取对数</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%882.54.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%9B%9E%E5%BD%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%883.01.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>滑动平均值是从一个有n项的时间序列中来计算多个连续m项序列的平均值。</p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>关键词：正则化，get_Variable,sess.run<br><a href="https://github.com/zdkswd/myTensorflowExamples/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92.py">https://github.com/zdkswd/myTensorflowExamples/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92.py</a></p><h2 id="逻辑回归与Softmax回归"><a href="#逻辑回归与Softmax回归" class="headerlink" title="逻辑回归与Softmax回归"></a>逻辑回归与Softmax回归</h2><p>softmax就是多分类的逻辑回归，使用的损失函数是交叉熵，交叉熵就是负的逻辑回归的极大似然估计。<br>softmax成为了激活函数。<br><a href="https://github.com/zdkswd/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py">https://github.com/zdkswd/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py</a></p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>从博客内容可知，为了使J(θ)最大，就尽可能的分对。<br><a href="https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92</a><br>这个分类结果相当不错，从上图可以看出，只分错了几个点而已。但是，尽管例子简单切数据集很小，但是这个方法却需要大量的计算(300次乘法)。因此将对改算法稍作改进，从而减少计算量，使其可以应用于大数据集上。</p><h2 id="逻辑回归算法的改进"><a href="#逻辑回归算法的改进" class="headerlink" title="逻辑回归算法的改进"></a>逻辑回归算法的改进</h2><p>梯度上升算法在每次更新回归系数(最优参数)时，都需要遍历整个数据集。<br>假设，我们使用的数据集一共有100个样本。那么，dataMatrix就是一个100<strong>3的矩阵。每次计算h的时候，都要计算dataMatrix</strong>weights这个矩阵乘法运算，要进行100<strong>3次乘法运算和100</strong>2次加法运算。同理，更新回归系数(最优参数)weights时，也需要用到整个数据集，要进行矩阵乘法运算。总而言之，该方法处理100个左右的数据集时尚可，但如果有数十亿样本和成千上万的特征，那么该方法的计算复杂度就太高了。因此，需要对算法进行改进，我们每次更新回归系数(最优参数)的时候，能不能不用所有样本呢？一次只用一个样本点去更新回归系数(最优参数)？这样就可以有效减少计算量了，这种方法就叫做随机梯度上升算法。</p><p>算法改进的第一点在于alpha在每次迭代都会调整，并且，虽然alpha会随着迭代次数不断减小，但永远不会减小到0，因为这里还存在一个常数项。必须这样做的原因是为了保证在多次迭代之后新数据仍然具有一定的影响。如果需要处理的问题是动态变化的，那么可以适当加大上述常数项，来确保新的值获得更大的回归系数。另一点值得注意的是，在降低alpha的函数中，alpha每次减少1/(j+i)，其中j是迭代次数，i是样本点的下标。第二个改进的地方在于更新回归系数(最优参数)时，只使用一个样本点，并且选择的样本点是随机的，每次迭代不使用已经用过的样本点。这样的方法，就有效地减少了计算量，并保证了回归效果。<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.py">MLcode/逻辑回归随机梯度下降.py at master · zdkswd/MLcode · GitHub</a><br>当数据集较小时，我们使用梯度上升算法<br>当数据集较大时，我们使用改进的随机梯度上升算法<br>对应的，在Sklearn中，我们就可以根据数据情况选择优化算法，比如数据较小的时候，我们使用liblinear，数据较大时，我们使用sag和saga。</p><h2 id="使用Sklearn构建Logistic回归分类器"><a href="#使用Sklearn构建Logistic回归分类器" class="headerlink" title="使用Sklearn构建Logistic回归分类器"></a>使用Sklearn构建Logistic回归分类器</h2><p>LogisticRegression这个函数，一共有14个参数：<br><a href="https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html</a><br>看文中的参数说明。<br>代码：<br><a href="https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/sklearn-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/sklearn-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、Logistic回归的优缺点<br>优点：<br>实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低。<br>缺点：<br>容易欠拟合，分类精度可能不高。<br>2、其他<br>Logistic回归的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，求解过程可以由最优化算法完成。<br>改进的一些最优化算法，比如sag。它可以在新数据到来时就完成参数更新，而不需要重新读取整个数据集来进行批量处理。<br>机器学习的一个重要问题就是如何处理缺失数据。这个问题没有标准答案，取决于实际应用中的需求。现有一些解决方案，每种方案都各有优缺点。<br>我们需要根据数据的情况，这是Sklearn的参数，以期达到更好的分类效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习升级版-回归&quot;&gt;&lt;a href=&quot;#机器学习升级版-回归&quot; class=&quot;headerlink&quot; title=&quot;机器学习升级版 回归&quot;&gt;&lt;/a&gt;机器学习升级版 回归&lt;/h1&gt;&lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;head
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>决策树和随机森林</title>
    <link href="https://github.com/zdkswd/2018/11/10/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <id>https://github.com/zdkswd/2018/11/10/决策树和随机森林/</id>
    <published>2018-11-10T12:01:47.000Z</published>
    <updated>2018-11-10T12:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习升级版-决策树和随机森林"><a href="#机器学习升级版-决策树和随机森林" class="headerlink" title="机器学习升级版 决策树和随机森林"></a>机器学习升级版 决策树和随机森林</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.26.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.29.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.31.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.32.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.50.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.55.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%884.55.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.21.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.22.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.24.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.25.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.28.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.31.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.32.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.44.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.50.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>基于样本和特征的双重随机性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%886.59.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>之所以有那么多种的处理办法，是因为没有某一种是十分有效的。</p><p>CART<br>classification and regression tree</p><h1 id="统计学习方法-决策树"><a href="#统计学习方法-决策树" class="headerlink" title="统计学习方法 决策树"></a>统计学习方法 决策树</h1><p>决策树( decision tree)是一种基本的分类与回归方法。这里主要是用于分类的决策树.决策树模型呈树形结构,在分类问题中,表示基于特征对实例进行分类的过程。它可以认为是 if-then规则的集合,也可以认为是定义在特征空间与类空间上的条件概率分布。</p><p>其主要优点是模型具有可读性,分类速度快。学习时,利用训练数据根据损失函数最小化的原则建立决策树模型。预测时,对新的数据,利用决策树模型进行分类。</p><p>决策树学习通常包括3个步骤:特征选择、决策树的生成和决策树的修剪。</p><h2 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h2><h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><p>分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边( directed edge)组成。<br>结点有两种类型:内部结点( internal node)和叶结点( leaf node)。内部结点表示一个特征或属性,叶结点表示一个类。</p><p>用决策树分类,从根结点开始,对实例的某一特征进行测试,根据测试结果,将实例分配到其子结点;这时,每一个子结点对应着该特征的一个取值.如此递归地对实例进行测试并分配,直至达到叶结点.最后将实例分到叶结点的类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%884.41.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>圆代表内部节点，方框代表叶节点。</p><h3 id="决策树与if-then规则"><a href="#决策树与if-then规则" class="headerlink" title="决策树与if-then规则"></a>决策树与if-then规则</h3><p>可以将决策树看成一个 if-then规则的集合.将决策树转换成 if-then规则的过程是这样的:由决策树的根结点到叶结点的每一条路径构建一条规则;路径上内部结点的特征对应着规则的条件,而叶结点的类对应着规则的结论.决策树的路径或其对应的 if-then规则集合具有一个重要的性质:互斥并且完备.这就是说,每一个实例都被一条路径或一条规则所覆盖,而且只被一条路径或一条规则所覆盖.这里所谓覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p><h3 id="决策树与条件概率分布"><a href="#决策树与条件概率分布" class="headerlink" title="决策树与条件概率分布"></a>决策树与条件概率分布</h3><p>决策树还表示给定特征条件下类的条件概率分布。假设X为表示特征的随机变量,Y为表示类的随机变量,那么这个条件概率分布可以表示为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-02%20%E4%B8%8B%E5%8D%884.49.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>X取值与给定划分下单元的集合，Y取值于类的集合。各叶节点上的条件概率往往偏向某一类，即属于某一类的概率较大。决策树分类时将该节点的实例强行分到条件概率大的那一类去。</p><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习本质上是从训练数据集中归纳出一组分类规则。与训练数据集不<br>相矛盾的决策树(即能对训练数据进行正确分类的决策树)可能有多个,也可能<br>一个也没有。我们需要的是一个与训练数据矛盾较小的决策树,同时具有很好的<br>泛化能力。</p><p>决策树学习用损失函数表示这一目标,如下所述,决策树学习的损失函数通常是正则化的极大似然函数.决策树学习的策略是以损失函数为目标函数的最小化。</p><p>当损失函数确定以后,学习问题就变为在损失函数意义下选择最优决策树的问题,因为从所有可能的决策树中选取最优决策树是NP完全问题,所以现实中决策树学习算法通常采用<strong>启发式方法</strong>,近似求解这一最优化问题.这样得到的决策树是次最优(sub- optimal)的。</p><p>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。</p><p>生成的决策树可能对训练数据有很好的分类能力,但对未知的测试数据却未必有很好的分类能力,即可能发生过拟合现象.我们需要对已生成的树自下而上进行剪枝,将树变得更简单,从而使它具有更好的泛化能力。</p><p>如果特征数量很多,也可以在决策树学习开始的时候,对特征进行选择,只留下对训练数据有足够分类能力的特征。</p><p>决策树学习算法包含特征选择、决策树的生成与决策树的剪枝过程.由于决策树表示一个条件概率分布,所以深浅不同的决策树对应着不同复杂度的概率模型.决策树的生成对应于模型的局部选择,决策树的剪枝对应于模型的全局选择.决策树的生成只考虑局部最优,相对地,决策树的剪枝则考虑全局最优。</p><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><h3 id="特征选择问题"><a href="#特征选择问题" class="headerlink" title="特征选择问题"></a>特征选择问题</h3><p>特征选择在于选取对训练数据具有分类能力的特征.这样可以提高决策树学习的效率.如果利用一个特征进行分类的结果与随机分类的结果没有很大差别,则称这个特征是没有分类能力的,经验上扔掉这样的特征对决策树学习的精度影响不大,通常特征选择的准则是<strong>信息增益</strong>或<strong>信息增益比</strong>。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><h4 id="信息增益的算法"><a href="#信息增益的算法" class="headerlink" title="信息增益的算法"></a>信息增益的算法</h4><p>输入训练集D和特征A：<br>输出：特征A对训练数据集D的信息增益g(D,A)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.38.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.39.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.44.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>A3，A4类似，最后比较各特征的信息增益值。由于特征A3的信息增益值最大，所以选择特征A3作为最优特征。</p><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><h4 id="信息增益比定义"><a href="#信息增益比定义" class="headerlink" title="信息增益比定义"></a>信息增益比定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.47.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法的<strong>核心</strong>是在决策树各个结点上应用<strong>信息增益</strong>准则选择特征,递归地构建决策树.具体方法是:从根结点( root node)开始,对结点计算所有可能的特征的信息增益,选择信息增益最大的特征作为结点的特征,由该特征的不同取值建立子结点;再对子结点递归地调用以上方法,构建决策树;直到所有特征的信息增益均很小或没有特征可以选择为止,最后得到一个决策树.ID3相当于用极大似然法进行概率模型的选择。</p><h4 id="算法（ID3算法）"><a href="#算法（ID3算法）" class="headerlink" title="算法（ID3算法）"></a>算法（ID3算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.51.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.52.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.54.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ID3算法只有树的生成，所以该算法生成的树容易产生过拟合。而且ID3还存在着不能直接处理连续型特征的问题。只有事先将连续型特征离散化，才能在ID3算法中使用，但这种转换过程会破坏连续型变量的内在特性。</p><h3 id="C4-5的生成算法"><a href="#C4-5的生成算法" class="headerlink" title="C4.5的生成算法"></a>C4.5的生成算法</h3><p>C4.5算法与ID3算法相似，C4.5算法对ID3算法进行了改进。C4.5在生成的过程中，用<strong>信息增益比</strong>来选择特征。</p><h4 id="算法（C4-5的生成算法）"><a href="#算法（C4-5的生成算法）" class="headerlink" title="算法（C4.5的生成算法）"></a>算法（C4.5的生成算法）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%888.57.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><p>决策树生成算法递归地产生决策树,直到不能继续下去为止,这样产生的树往往对训练数据的分类很准确,但对未知的测试数据的分类却没有那么准确,即出现过拟合现象.过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类,从而构建出过于复杂的决策树,解决这个问题的办法是考虑决策树的复杂度,对已生成的决策树进行简化。</p><p>在决策树学习中将已生成的树进行简化的过程称为剪枝( pruning).具体地,剪枝从已生成的树上裁掉一些子树或叶结点,并将其根结点或父结点作为新的叶结点,从而简化分类树模型。</p><p>决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。设树T的叶节点个数为|T|，t是树T的叶节点，该<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%889.18.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C（T）表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型复杂度，参数α≥0控制两者之间的影响。较大的α促使选择较简单的模型（树），较小的α促使选择较复杂的模型（树）。α=0意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度。</p><p>剪枝,就是当α确定时,选择损失函数最小的模型,即损失函数最小的子树.当α值确定时,子树越大,往往与训练数据的拟合越好,但是模型的复杂度就越髙;相反,子树越小,模型的复杂度就越低,但是往往与训练数据的拟合不好,损失函数正好表示了对两者的平衡。</p><h3 id="算法（树的剪枝算法）"><a href="#算法（树的剪枝算法）" class="headerlink" title="算法（树的剪枝算法）"></a>算法（树的剪枝算法）</h3><p>输入：生成算法产生的整个树T，参数α；<br>输出：修剪后的子树Tα。</p><ol><li>计算每个结点的经验熵。</li><li>递归地从树的叶节点向上回缩。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-06%20%E4%B8%8B%E5%8D%889.30.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="3"><li>返回2，直至不能继续为止，得到损失函数最小的子树Tα。</li></ol><p>式(515)只需考虑两个树的损失函数的差,其计算可以在局部进行,所以,决策树的剪枝算法可以由一种动态规划的算法实现。</p><h2 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h2><p>CART：classification and regression tree<br>CART算法有两步：</p><ol><li>决策树生成，基于<strong>训练数据集</strong>生成决策树，生成的决策树要<strong>尽量大</strong></li><li><p>决策树剪枝，用<strong>验证数据集</strong>对已生成的树进行剪枝并选择最优子树，这时用<strong>损失函数最小</strong>作为剪枝的标准。</p><h3 id="CART生成"><a href="#CART生成" class="headerlink" title="CART生成"></a>CART生成</h3><p>决策树的生成就是递归地构建二叉决策树的过程。对<strong>回归</strong>树用<strong>平方误差</strong>最小化准则，对<strong>分类</strong>树用<strong>基尼指数</strong>最小化准则，进行特征选择，生成二叉树。</p><h4 id="回归树的生成"><a href="#回归树的生成" class="headerlink" title="回归树的生成"></a>回归树的生成</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%889.10.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>用人话解释：回归树的原理及Python实现 - 李小文的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/43939904" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43939904</a><br>就是把连续的数据分为几个区间，问题的关键就是分割点的选取。</p><h4 id="分类树的生成"><a href="#分类树的生成" class="headerlink" title="分类树的生成"></a>分类树的生成</h4><p>分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%889.16.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>生成方法与ID3决策树类似。</p><h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><p>CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小(模型变简单)，从而能够对未知数据有更准确的预测。</p><p>CART剪枝算法由两步组成:首先从生成算法产生的决策树To底端开始不断剪枝,直到To的根结点，形成一个子树序列{T1,…,Tn};然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p><h4 id="剪枝，形成一个子树序列"><a href="#剪枝，形成一个子树序列" class="headerlink" title="剪枝，形成一个子树序列"></a>剪枝，形成一个子树序列</h4><p>在剪枝过程中，计算子树的损失函数:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.24.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>T为任意子树，C（T）为训练数据的预测误差（如基尼指数），|T|为子树的叶节点个数，α≥0为参数，Cα（T）为参数是α时的子树T的整体损失。参数α权衡训练数据的拟合程度与模型的复杂度。</p></li></ol><p>对固定的α,一定存在使损失函数C(T)最小的子树，将其表示为Tα. Tα在损失函数Cα(T)最小的意义下是最优的.容易验证这样的最优子树是唯一的.当α大的时候，最优子树Tα偏小;当α小的时候，最优子树Tα偏大. 极端情况，当α=0时，整体树是最优的，当α趋近正无穷时，根结点组成的单结点树是最优的.</p><p>从整体树T0开始剪枝，对T0的任意内部节点t，以t为单结点树的损失函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.55.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>以t为根结点的子树Tt的损失函数是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%885.56.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α=0及α充分小时，有不等式<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.02.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α增大时，在某一α有<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.02.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当α再增大时，不等式反向。只要<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Tt与t有相同的损失函数值，而t的节点少，因此t比Tt更可取，对Tt进行剪枝。</p><p>为此，对T0中每一内部结点t，计算<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.05.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它表示剪枝后整体损失函数减少的程度.在T0中剪去g(t)最小的Tt,将得到的子<br>树作为T1，同时将最小的g(t)设为α1. T1为区间[α1,α2)的最优子树.</p><p>如此剪枝下去，直到得到根节点。在这一过程中，不断增加α的值，产生新的区间。</p><h4 id="在剪枝得到的子树序列T0-T1-…-Tn中通过交叉验证选取最优子树Tα"><a href="#在剪枝得到的子树序列T0-T1-…-Tn中通过交叉验证选取最优子树Tα" class="headerlink" title="在剪枝得到的子树序列T0,T1,…,Tn中通过交叉验证选取最优子树Tα"></a>在剪枝得到的子树序列T0,T1,…,Tn中通过交叉验证选取最优子树Tα</h4><p>具体地，利用独立的验证数据集，测试子树序列T0,T1,…,Tn中各棵子树的平方误差或基尼指数.平方误差或基尼指数最小的决策树被认为是最优的决策树.在子树序列中，每棵子树T1,T2,.,Tn都对应于一个参数α1,α2,…,αn,.所以，当最优子树Tk确定时，对应的ak也确定了，即得到最优决策树Tα。</p><h3 id="CART剪枝算法"><a href="#CART剪枝算法" class="headerlink" title="CART剪枝算法"></a>CART剪枝算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-07%20%E4%B8%8B%E5%8D%886.11.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="西瓜书-树剪枝"><a href="#西瓜书-树剪枝" class="headerlink" title="西瓜书 树剪枝"></a>西瓜书 树剪枝</h1><p>可以采用留出法，即预留一部分数据用作“验证集”以进行性能评估。</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-09%20%E4%B8%8B%E5%8D%889.49.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>预剪枝使得决策树的很多分支都没有“展开”，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间开销和测试时间开销。但在另一方面，有些分支的当前划分虽不能提高泛化性能、甚至可能导致泛化性能暂时下降，但在其基础上进行的后续划分却有可能导致性能显著提高；预剪枝基于“贪心”本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险。</p><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝先从训练集生成一颗完整决策树。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8A%E5%8D%8810.03.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8A%E5%8D%8810.03.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对比可得，后剪枝决策树通常比预剪枝决策树保留了更多的分支。一般来说，后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但后剪枝过程是在生成完全决策树之后进行的，并且要自底向上地对树中的所有非叶节点进行逐一考察，因此其训练时间开销比未剪枝决策树和预剪枝决策树都要大。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>回归树：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/1%20dt%20divide.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>回归树与线性回归的对比：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/1%20dt%20sklearn.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="西瓜书-Bagging与随机森林"><a href="#西瓜书-Bagging与随机森林" class="headerlink" title="西瓜书 Bagging与随机森林"></a>西瓜书 Bagging与随机森林</h1><p>欲得到泛化性能强的集成,集成中的个体学习器应<strong>尽可能相互独立</strong>;虽然“独立”在现实任务中无法做到，但可以设法使基学习器尽可能具有较大的差异.给定一个训练数据集,一种可能的做法是对训练样本进行采样，产生出若干个不同的子集，再从每个数据子集中训练出一个基学习器.这样，由于训练数据不同,我们获得的基学习器可望具有比较大的差异.然而，为获得好的集成，我们同时还希望个体学习器不能太差.如果采样出的每个子集都<strong>完全不同</strong>，则每个基学习器只用到了<strong>一小部分训练数据</strong>，甚至不足以进行有效学习,这显然无法确保产生出比较好的基学习器.为解决这个问题，我们可考虑使用相互有交叠的采样子集.</p><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>Bagging是并行式集成学习最著名的代表，直接基于自助采样法（bootstrap sampling）。给定包含m个样本的数据集,我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中,这样,经过m次随机采样操作,我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现，由式(2.1)可知, 初始训练集中约有63.2%的样本出现在采样集中.</p><p>我们可采样出T个含m个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合.这就是Bagging的基本流程.在对预测输出进行结合时，Bagging通常对分类任务使用简单投票法，对回归任务使用简单平均法.若分类预测时出现两个类收到同样票数的情形,则最简单的做法是随机选择一个,也可进一步考察学习器投票的置信度来确定最终胜者.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%883.16.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>自助采样过程还给Bagging带来了另一个优点:由于每个基学习器只使用了初始训练集中约63.2%的样本,剩下约36.8%的样本可用作验证集来对泛化性能进行“包外估计”。</p><p>包外样本还有许多其他用途.例如当基学习器是决策树时，可使用包外样本来辅助剪枝,或用于估计决策树中各结点的后验概率以辅助对零训练样本结点的处理;当基学习器是神经网络时，可使用包外样本来辅助早期停止以减小过拟合风险.</p><p>从偏差方差分解的角度看，Bagging主要关注降低方差，因此它在不剪枝决策树、神经网络等易受样本扰动的学习器上效用更为明显。</p><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>随机森林(Random Forest,简称RF) 是Bagging的一个扩展变体. RF在以决策树为基学习器构建Bagging集成的基础上,进一步在决策树的训练过程中引入了随机属性选择.具体来说，传统决策树在选择划分属性时是在当前结点的属性集合(假定有d个属性)中选择一个最优属性;而在RF中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含k个属性的子集，然后再从这个子集中选择一个最优属性用于划分。这里的参数k控制了随机性的引入程度。若k=d则基决策树的构建与传统决策树相同，一般，推荐k=log2d。</p><p>随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能,被誉为“代表集成学习技术水平的方法”.可以看出，随机森林对Bagging只做了小改动,但是与Bagging中基学习器的“多样性”仅通过样本扰动(通过对初始训练集采样)而来不同，随机森林中基学习器的多样性<strong>不仅来自样本扰动</strong>,还来自<strong>属性扰动</strong>，这就使得最终集成的泛化性能可通过个体学习器之间差异度的增加而进一步提升.</p><p>随机森林的收敛性与Bagging相似，起始性能往往相对较差，特别是在集成中只包含一个基学习器时。这不难理解，因为通过引入属性扰动，随机森林中个体学习器的性能往往有所降低，但是随着个体学习器数目的增加，随机森林通常会收敛到更低的泛化误差值得一提的是,随机森林的训练效率常优于Bagging,因为在个体决策树的构建过程中, Bagging使用的是“确定型”决策树,在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的“随机型”央策树则只需考察一个属性子集.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%883.41.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h2><h3 id="学习器结合的好处"><a href="#学习器结合的好处" class="headerlink" title="学习器结合的好处"></a>学习器结合的好处</h3><p>学习器结合会带来三个方面的好处：</p><ol><li>统计方面，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能会因为误选而导致泛化性能不佳，结合多个学习器则会减小这一风险。</li><li>计算方面，学习算法往往会陷入局部极小,有的局部极小点所对应的泛化性能可能很糟糕，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险。</li><li>表示方面，某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中，此时若使用单学习器则肯定无效,而通过结合多个学习器，由于相应的假设空间有所扩大，有可能学得更好的近似。<h3 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h3>对于数值型输出，最常见的就是平均法。<h4 id="简单平均法"><a href="#简单平均法" class="headerlink" title="简单平均法"></a>简单平均法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.35.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="加权平均法"><a href="#加权平均法" class="headerlink" title="加权平均法"></a>加权平均法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.35.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.35.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>加权平均法的权重一般是从训练数据中学习而得，现实任务中的训练样本通常不充分或存在噪声，这将使得学出的权重不完全可靠.尤其是对规模比较大的集成来说，要学习的权重比较多,较容易导致过拟合.因此,实验和应用均显示出，加权平均法未必一定优于简单平均法.一般而言,在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时宜使用简单平均法.<h3 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h3><h4 id="绝对多数投票法"><a href="#绝对多数投票法" class="headerlink" title="绝对多数投票法"></a>绝对多数投票法</h4>即若某标记得票过半数，则预测为该标记，否则拒绝预测。<h4 id="相对多数投票法"><a href="#相对多数投票法" class="headerlink" title="相对多数投票法"></a>相对多数投票法</h4>即预测为得票最多的标记，若同时又多个标记获最高票，则从中随机选取一个。<h4 id="加权投票法"><a href="#加权投票法" class="headerlink" title="加权投票法"></a>加权投票法</h4>与加权平均法类似。</li></ol><p>标准的绝对多数投票法提供了“拒绝预测”选项,这在可靠性要求较高的学习任务中是一个很好的机制.但若学习任务要求必须提供预测结果，则绝对多数投票法将退化为相对多数投票法.因此,在不允许拒绝预测的任务中,绝对多数、相对多数投票法统称为“多数投票法”。</p><p>硬投票：输出预测的类标记，软投票，输出一个概率估计。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.54.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-10%20%E4%B8%8B%E5%8D%884.55.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>算法实现。<br>背景：贷款放贷与否<br><a href="https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%86%B3%E7%AD%96%E6%A0%91.py">https://github.com/zdkswd/MLcode/blob/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%86%B3%E7%AD%96%E6%A0%91.py</a></p><h2 id="scikit-learn决策树"><a href="#scikit-learn决策树" class="headerlink" title="scikit-learn决策树"></a>scikit-learn决策树</h2><p>使用scikit-learn实现。<br>背景：配隐形眼镜<br><a href="https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn%E5%86%B3%E7%AD%96%E6%A0%91">https://github.com/zdkswd/MLcode/tree/master/scikit-learn-code/scikit-learn%E5%86%B3%E7%AD%96%E6%A0%91</a></p><h2 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h2><p>关键词：<strong>CART，预剪枝，后剪枝</strong></p><p>回归树与分类树比较类似，不同的是分类树最后的决策的结果是离散型的值，回归树决策的结果是输出一个实数。实例中的实数输出（就是叶子节点）的是四个样本的平均值（四个样本是在进行预剪枝时设置的值）。</p><p>CART回归树这里使用最小总方差法选取划分特征。示例中采用的是REP（错误率降低剪枝）。还有一种方法叫做PEP（悲观剪枝）把一颗子树（具有多个叶子节点）用一个叶子节点来替代的话，比起REP剪枝法，它不需要一个单独的测试数据集。</p><p>本例中既有预剪枝又有后剪枝。一般来说都是结合着使用。</p><p>背景：连续数据的离散的点<br><a href="https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%9B%9E%E5%BD%92%E6%A0%91">https://github.com/zdkswd/MLcode/tree/master/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/%E5%9B%9E%E5%BD%92%E6%A0%91</a></p><h2 id="scikit-learn随机森林"><a href="#scikit-learn随机森林" class="headerlink" title="scikit-learn随机森林"></a>scikit-learn随机森林</h2><p>待解决问题，在scikit-learn的随机森林中如何决定k值。<br><a href="https://github.com/zdkswd/MLcode/blob/master/scikit-learn-code/scikit-learn%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.py">https://github.com/zdkswd/MLcode/blob/master/scikit-learn-code/scikit-learn%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习升级版-决策树和随机森林&quot;&gt;&lt;a href=&quot;#机器学习升级版-决策树和随机森林&quot; class=&quot;headerlink&quot; title=&quot;机器学习升级版 决策树和随机森林&quot;&gt;&lt;/a&gt;机器学习升级版 决策树和随机森林&lt;/h1&gt;&lt;figure class=&quot;im
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn介绍</title>
    <link href="https://github.com/zdkswd/2018/11/08/scikit-learn%E4%BB%8B%E7%BB%8D/"/>
    <id>https://github.com/zdkswd/2018/11/08/scikit-learn介绍/</id>
    <published>2018-11-08T07:56:56.000Z</published>
    <updated>2018-11-12T09:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习：问题背景"><a href="#机器学习：问题背景" class="headerlink" title="机器学习：问题背景"></a>机器学习：问题背景</h1><p>学习问题分以下几类：</p><h2 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>聚类，密度估计等</p><h1 id="加载示例数据集"><a href="#加载示例数据集" class="headerlink" title="加载示例数据集"></a>加载示例数据集</h1><p>有几个标准数据集，鸢尾花和手写字用于分类，以及波士顿房价数据集用于回归。<br>鸢尾花与手写字数据集的导入。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.30.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>数据集就是一个字典对象，包含了所有的数据以及一些关于数据的元数据。数据存储在.data成员中，它是一个n个样本，n个特征的数组。在监督学习的问题中，因变量存在.target成员中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.37.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.41.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数据数组的形状"><a href="#数据数组的形状" class="headerlink" title="数据数组的形状"></a>数据数组的形状</h2><p>数据总是二维数组，（n_sample,n_features）的形状，即使原始数据可能有着不同的形状。在手写字识别中，每个原始例子是（8  *  8）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.48.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但是在data中变成了（1  * 64）。</p><h1 id="学习以及预测"><a href="#学习以及预测" class="headerlink" title="学习以及预测"></a>学习以及预测</h1><p>在scikit-learn中，分类器是一个实现了方法fit(x,y)和predict(T)的Python对象。</p><p>先把分类器当做是一个黑盒。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8A%E5%8D%8810.57.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>选择模型的参数<br>在这个例子中我们是人工选择的参数，为了寻找这些参数的更好的值，我们能使用例如网格搜索和交叉验证的工具。</p><p>分类器实例拟合模型是通过传递训练集给fit方法。对于训练集，我们使用除了最后一张图片的所有图片，最后一张图片用来做预测。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.48.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>来预测：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.49.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="模型持久化"><a href="#模型持久化" class="headerlink" title="模型持久化"></a>模型持久化</h1><p>使用pickle。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.50.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用joblib，joblib在大数据方面更加高效，但是遗憾的是它只能把数据持久化到硬盘而不是字符串（搬到字符串意味着数据在内存中）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.57.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>之后可以重新加载模型（也可以在其他的Python进程中）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%881.59.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注意</strong>：joblib.dump和joblib.load也接收像文件一样的对象而不是文件名。</p><h1 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>除非特别指明，输入将被转换为float64:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/scikit-learn%E4%BB%8B%E7%BB%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-08%20%E4%B8%8B%E5%8D%882.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>x是float32型，可以通过fit_transform(x)转换为float64。</p><p>回归的目标类型转化为float64，分类的目标类型保留下来。</p><h2 id="改装和更新参数"><a href="#改装和更新参数" class="headerlink" title="改装和更新参数"></a>改装和更新参数</h2><p>超参数在通过set_params()方法创建后能够更新。调用fit()函数超过一次将会重写之前fit()所学的内容。</p><h2 id="多类别vs多标签拟合"><a href="#多类别vs多标签拟合" class="headerlink" title="多类别vs多标签拟合"></a>多类别vs多标签拟合</h2><p>当使用多类别分类器，所执行的学习和预测任务取决于适合于目标数据的格式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习：问题背景&quot;&gt;&lt;a href=&quot;#机器学习：问题背景&quot; class=&quot;headerlink&quot; title=&quot;机器学习：问题背景&quot;&gt;&lt;/a&gt;机器学习：问题背景&lt;/h1&gt;&lt;p&gt;学习问题分以下几类：&lt;/p&gt;
&lt;h2 id=&quot;有监督学习&quot;&gt;&lt;a href=&quot;#有监
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow基础知识上</title>
    <link href="https://github.com/zdkswd/2018/11/04/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/"/>
    <id>https://github.com/zdkswd/2018/11/04/TensorFlow基础知识上/</id>
    <published>2018-11-04T10:56:41.000Z</published>
    <updated>2018-11-05T04:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%887.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>自底向上为设备层和网络层、数据操作层、图计算层、API层、应用层。</p><p>其中设备层和网络层、数据操作层、图计算层是TensorFlow的核心层。</p><h2 id="网络通信层和设备管理层"><a href="#网络通信层和设备管理层" class="headerlink" title="网络通信层和设备管理层"></a>网络通信层和设备管理层</h2><p>网络通信层包括gRPC( google Remote Procedure Call Protocol)和远程直接数据存取( Remote direct Memory Access,RDMA),这都是在分布式计算时需要用到的。设备管理层包括 TensorFlow分别在CPU、GPU、FPGA等设备上的实现,也就是对上层提供了一个统一的接口,使上层只需要处理卷积等逻辑,而不需要关心在硬件上的卷积的实现过程。</p><h2 id="数据操作层"><a href="#数据操作层" class="headerlink" title="数据操作层"></a>数据操作层</h2><p>主要包括卷积函数、激活函数等操作。</p><h2 id="图计算层（了解的核心）"><a href="#图计算层（了解的核心）" class="headerlink" title="图计算层（了解的核心）"></a>图计算层（了解的核心）</h2><p>包含本地计算图和分布式计算图的实现。</p><h2 id="API层和应用层"><a href="#API层和应用层" class="headerlink" title="API层和应用层"></a>API层和应用层</h2><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>TensorFlow的设计理念主要体现在以下两个方面。</p><h2 id="将图的定义和图的运行完全分开"><a href="#将图的定义和图的运行完全分开" class="headerlink" title="将图的定义和图的运行完全分开"></a>将图的定义和图的运行完全分开</h2><p>编程模式通常分为<strong>命令式编程</strong>和<strong>符号式编程</strong>。命令式编程就是我们理解的通常意义上的程序，很容易理解和调试，按照原有的逻辑执行。符号式编程涉及很多的嵌入和优化,不容易理解和调试,但<strong>运行速度相对有所提升</strong>。现有的深度学习框架中, Torch是典型的命令式的,Cafe、 MXNet采用了两种编程模式混合的方法,而 TensorFlow完全釆用符号式编程。</p><p>符号式计算一般是先定义各种变量,然后建立一个数据流图,在数据流图中规定各个变量之间的计算关系,最后需要对数据流图进行编译,但此时的数据流图还是一个空壳儿,里面没有任何实际数据,只有把需要运算的输入放进去后,才能在整个模型中形成数据流,从而形成输出值。</p><p>在传统的程序操作中,定义了t的运算,在运行时就执行了,并输出17。而在TensorFlow中,数据流图中的节点,实际上对应的是 Tensor Flow APi中的一个操作,并没有真正去运行:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%887.56.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="TensorFlow中涉及的运算都要放在图中-而图的运行只发生在会话-session-中"><a href="#TensorFlow中涉及的运算都要放在图中-而图的运行只发生在会话-session-中" class="headerlink" title="TensorFlow中涉及的运算都要放在图中,而图的运行只发生在会话( session)中"></a>TensorFlow中涉及的运算都要放在图中,而图的运行只发生在会话( session)中</h2><p>开启会话后,就可以用数据去填充节点,进行运算;关闭会话后,就不能进行计算了。因此,会话提供了操作运行和 Tensor求值的环境。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%887.57.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h1><h2 id="边"><a href="#边" class="headerlink" title="边"></a>边</h2><p>TensorFlow的边有两种连接关系:数据依赖和控制依赖。</p><h3 id="实线边表示数据依赖"><a href="#实线边表示数据依赖" class="headerlink" title="实线边表示数据依赖"></a>实线边表示数据依赖</h3><p>代表数据，即张量。任意纬度的数据统称为张量。在机器学习算法中，张量在数据流图中从前往后流动一遍就完成了一次前向传播，而残差从后向前流动一遍就完成了一次反向传播。（在数理统计中，残差是指实际观察值与训练的估计值之间的差。）</p><h3 id="虚线边表示控制依赖（control-dependency-）"><a href="#虚线边表示控制依赖（control-dependency-）" class="headerlink" title="虚线边表示控制依赖（control dependency ）"></a>虚线边表示控制依赖（control dependency ）</h3><p>可以用于控制操作的运行，这被确保happens-before关系，这类边上没有数据流过，但源节点必须在目的节点开始执行前完成执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%889.06.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>TensorFlow 支持的张量具有表 4-1 所示的数据属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%889.07.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>图中的节点又称为算子，它代表一个操作(operation，OP)，一般用来表示施加的数学运算，也可以表示数据输入(feed in)的起点以及输出(push out)的终点，或者是读取/写入持久变量(persistent variable)的终点。 表 4-2 列举了一些 TensorFlow 实现的算子。算子支持表 4-1 所示的张量的各种数据属性，并且需要在建立图的时候确定下来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-26%20%E4%B8%8B%E5%8D%889.18.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与操作相关的代码位于 tensorflow-1.1.0/tensorflow_python_ops_目录下。以数学运算为例，代 码为上述目录下的 math_ops.py，里面定义了 add、subtract、multiply、scalar_mul、div、divide、 truediv、floordiv 等数学运算，每个函数里面调用了 gen_math_ops.py 中的方法，这个文件是在 编译(安装时)TensorFlow 时生成的，位于 Python 库 site-packages_tensorflow_python_ops_gen_ math_ops.py 中，随后又调用了 tensorflow-1.1.0_tensorflow_core_kernels/下面的核函数实现。 </p><h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>把操作任务描述成有向无环图。构建图的第一步是创建各个节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.30.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>启动图的第一步是创建一个 Session对象。会话( session)提供在图中执行操作的一些方法。一般的模式是,建立会话,此时会生成一张空图,在会话中添加节点和边,形成一张图,然后执行。</p><p>要创建一张图并运行操作的类,在 Python的API中使用tf. Session,在C++的API中使用tensorflow: Session。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.33.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在调用 Session对象的run（）方法来执行图时,传入一些 Tensor,这个过程叫填充(feed)返回的结果类型根据输入的类型而定,这个过程叫取回( fetch)。</p><p>与会话相关的源代码位于 tensorfow-11.0/ tensorfow/ python/ client/session. py。</p><p><strong>会话</strong>是<strong>图交互的一个桥梁,</strong>一个会话可以有多个图,会话可以修改图的结构,也可以往图中注入数据进行计算。因此,会话主要有两个AP接口: <strong>Extend</strong>和<strong>Run</strong>。 <strong>Extend</strong>操作是<strong>在 Graph中添加节点和边</strong>,<strong>Run</strong>操作是<strong>输入计算的节点和填充必要的数据后,进行运算,并输出运算结果。</strong></p><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>设备（device）是指一块可以用来运算并且拥有自己的地址空间的硬件，如GPU和CPU。</p><p>TensorFlow为了实现分布式执行操作,充分利用计算资源,可以明确指定操作在哪个设备上执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.40.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与设备相关的源代码位于 tensorfow-1.1.0 tensorflow_python_ framework/device. py。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量( variable）是一种特殊的数据,<strong>它在图中有固定的位置,不像普通张量那样可以流动</strong>。例如,创建一个变量张量,使用tf.Variable()构造函数,这个构造函数需要一个初始值,初始值的形状和类型决定了这个变量的形状和类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.45.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建一个常量张量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.46.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>TensorFlow还提供了填充机制,可以在构建图时使用tf.placeholder临时替代任意操作的张量,在调用 Session对象的run（）方法去执行图时,使用填充数据作为调用的参数,调用结束后,填充数据就消失。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.52.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与变量相关的源代码位于 tensorflow/ tensorflow/ python_ops_ variables. py。</p><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>我们知道操作( operation)是对抽象操作(如 matmul或者ad)的一个统称,而内核( kemel)则是能够运行在特定设备(如CPU、GPU)上的一种对操作的实现。因此,同一个操作可能会对应多个内核。</p><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="图、操作和张量"><a href="#图、操作和张量" class="headerlink" title="图、操作和张量"></a>图、操作和张量</h2><p>与图相关的API均位于tf.Graph类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%889.57.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>tf.Operation类代表图中的一个节点，用于<strong>计算张量数据</strong>。该类型由节点构造器（如tf.matmul()或者Graph.create_op()）产生。例如，c=tf.matmul(a,b)<br>创建一个Operation类，其类型为MatMul的操作类。与操作相关的API均位于tf.Operation类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%8810.13.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%8810.14.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>tf.Tensor类是操作输出的符号句柄,它不包含操作输出的值,而是提供了一种在tf.Session中计算这些值的方法。这样就可以在操作之间构建一个数据流连接,使 TensorFlow能够执行一个表示大量多步计算的图形。与张量相关的API均位于tf.Tensor类中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8A%E5%8D%8810.33.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>在 TensorFlow中有两个作用域( scope),一个是 name_scope,另一个是 variable_scope。简而言之, name_scope主要是给 variable_name加前缀,也可以给 op_ name加前缀; name_scope是给 op_name加前缀。</p><h2 id="variable-scope"><a href="#variable-scope" class="headerlink" title="variable_scope"></a>variable_scope</h2><p>variable_scope变量作用域机制在 TensorFlow中主要由两部分组成:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.29.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建或是返回一个变量，或是为变量指定命名空间。</p><p>当 tf. get_variable_scope. reuse==False时, variable_scope作用域只能用来创建新变量:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.32.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上述程序会抛出ValueError错误，因为v这个变量已经被定义过了，但tf.get_variable_scope().reuse默认为False，所以不能重用。</p><p>当tf.get_variable_scope().reuse=True时,作用域可以共享变量:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.38.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="获取变量作用域"><a href="#获取变量作用域" class="headerlink" title="获取变量作用域"></a>获取变量作用域</h3><p>可以直接通过 tf.variable_scope()来获取变量作用域:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.41.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果在开启的一个变量作用域里使用之前预先定义的一个作用域,则会跳过当前变量的作用域,保持预先存在的作用域不变。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.43.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="变量作用域的初始化"><a href="#变量作用域的初始化" class="headerlink" title="变量作用域的初始化"></a>变量作用域的初始化</h3><p>变量作用域可以默认携带一个初始化器,在这个作用域中的子作用域或变量都可以继承或者重写父作用域初始化器中的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.46.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在variable_scope作用域下的操作op_name也会被加上前缀。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.50.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.50.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>variable scope主要用在循环神经网络(RNN)的操作中,其中需要大量的共享变量。</p><h2 id="name-scope示例"><a href="#name-scope示例" class="headerlink" title="name_scope示例"></a>name_scope示例</h2><p>TensorFlow中常常会有数以千计的节点,在可视化的过程中很难一下子展示出来,因此用name_scope为变量划分范围,在可视化中,这表示在计算图中的一个层级。name_scope会影响op_name,不会影响get_variableo创建的变量,而会影响通过 Variableo创建的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%887.59.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="批标准化"><a href="#批标准化" class="headerlink" title="批标准化"></a>批标准化</h1><p>批标准化( batch normalization,BN)是为了克服神经网络层数加深导致难以训练而诞生的我们知道,深度神经网络随着网络深度加深,训练起来会越来越困难,收敛速度会很慢,常常会导致梯度弥散问题( vanishing gradient problem)。</p><p>统计机器学习中有一个<strong>ICS</strong>( Internal Covariate shift)理论,这是一个经典假设:源域( source domain)和目标域( target domain)的数据分布是一致的。也就是说,训练数据和测试数据是满足相同分布的。这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。</p><p><strong>Covariate shift</strong>是指训练集的样本数据和目标样本集分布不一致时,训练得到的模型无法很好地泛化( generalization)。它是分布不一致假设之下的一个分支问题,也就是指源域和目标域的条件概率是一致的,但是其边缘概率不同。的确,对于神经网络的各层输出,在经过了层内操作后,各层输出分布就会与对应的输入信号分布不同,而且差异会随着网络深度增大而加大,但是每一层所指向的样本标记( label)仍然是不变的。</p><p>解决思路一般是根据训练样本和目标样本的比例对训练样本做一个矫正。因此，通过引入批标准化来规范化某些层或者所有层的输入，从而固定每层输入信号的均值与方差。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>批标准化一般用在非线性映射(激活函数)之前,对x=Wu+b做规范化,使结果(输出信号各个维度)的均值为0,方差为1。让每一层的输入有一个稳定的分布会有利于网络的训练。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>批标准化通过规范化让激活函数分布在线性区间,结果就是加大了梯度,让模型更加大胆地进行梯度下降,于是有如下优点：</p><ol><li>加大探索的步长，加快收敛的速度。</li><li>更容易跳出局部最小值。</li><li>破坏原来的数据分布，一定程度上缓解过拟合。</li></ol><p>在遇到神经网络收敛速度很慢或梯度爆炸等无法训练的情况下，都可以尝试用批标准化来解决。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>对每层的Wx_plus_b进行批标准化，这个步骤在激活函数之前。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-04%20%E4%B8%8B%E5%8D%886.52.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>规范化，也可以称为标准化，是将数据按比例缩放，使之落在一个小的特定区间。这里是指数据减去平均值，再除以标准差。</p><h1 id="tf-add-a-b-与-a-b"><a href="#tf-add-a-b-与-a-b" class="headerlink" title="tf.add(a, b) 与 a+b"></a>tf.add(a, b) 与 a+b</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统架构&quot;&gt;&lt;a href=&quot;#系统架构&quot; class=&quot;headerlink&quot; title=&quot;系统架构&quot;&gt;&lt;/a&gt;系统架构&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="https://github.com/zdkswd/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Python数据科学手册 Matplotlib数据可视化</title>
    <link href="https://github.com/zdkswd/2018/11/01/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2018/11/01/Python数据科学手册 Matplotlib数据可视化/</id>
    <published>2018-11-01T13:00:56.000Z</published>
    <updated>2018-11-01T13:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib是建立在 NumPy数组基础上的多平台数据可视化程序库。</p><p>Matplotlib最重要的特性之一就是具有良好的操作系统兼容性和图形显示底层接口兼容性( graphics backend)。 Matplotlib支持几十种图形显示接口与输出格式,这使得用户无论在哪种操作系统上都可以输出自己想要的图形格式。这种跨平台、面面俱到的特点已经成为 Matplotlib最强大的功能之一, Matplotlib也因此吸引了大量用户,进而形成了一个活跃的开发者团队,晋升为 Python科学领域不可或缺的强大武器。</p><h1 id="Matplotlib常用技巧"><a href="#Matplotlib常用技巧" class="headerlink" title="Matplotlib常用技巧"></a>Matplotlib常用技巧</h1><h2 id="导入-Matplotlib"><a href="#导入-Matplotlib" class="headerlink" title="导入 Matplotlib"></a>导入 Matplotlib</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%889.53.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="设置绘图样式"><a href="#设置绘图样式" class="headerlink" title="设置绘图样式"></a>设置绘图样式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%889.54.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="用不用show-如何显示图形"><a href="#用不用show-如何显示图形" class="headerlink" title="用不用show()?如何显示图形"></a>用不用show()?如何显示图形</h2><h3 id="在脚本中画图"><a href="#在脚本中画图" class="headerlink" title="在脚本中画图"></a>在脚本中画图</h3><p>如果你在一个脚本文件中使用 Matplotlib,那么显示图形的时候必须使用plt.show()。plt.show()会启动一个事件循环( event lop),并找到所有当前可用的图形对象,然后打开一个或多个交互式窗口显示图形。</p><p>plt,show()这行代码在后面完成了许多事情,它需要与你使用的操作系统的图形显示接口进行交互。虽然具体的操作细节会因操作系统和安装过程不同而有很大的差异,但是 Matplotlib为你隐藏所有的细节,非常省心。</p><p>不过有一点需要注意,一个 Python会话( session)中只能使用一次plt.show(),因此通常都把它放在脚本的最后。多个plt.show()命令会导致难以预料的显示异常,应该尽量避免。</p><h3 id="在IPython-shell中画图"><a href="#在IPython-shell中画图" class="headerlink" title="在IPython shell中画图"></a>在IPython shell中画图</h3><h3 id="在IPython-Notebook中画图"><a href="#在IPython-Notebook中画图" class="headerlink" title="在IPython Notebook中画图"></a>在IPython Notebook中画图</h3><h2 id="将图形保存为文件"><a href="#将图形保存为文件" class="headerlink" title="将图形保存为文件"></a>将图形保存为文件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%8810.00.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%8810.01.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当你保存图形文件时,不需要使用plt.show()。</p><h1 id="两种画图接口"><a href="#两种画图接口" class="headerlink" title="两种画图接口"></a>两种画图接口</h1><p> Matplotlib有一个容易让人混淆的特性,就是它的两种画图接口,一个是便捷的 MATLAB风格接口,另一个是功能更强大的面向对象接口。</p><h2 id="MATLAB风格接口"><a href="#MATLAB风格接口" class="headerlink" title="MATLAB风格接口"></a>MATLAB风格接口</h2><p>Matplotlib最初作为 MATLAB用户的 Python替代品,许多语法都和MATLAB类似。 MATLAB风格的工具位于 pyplot(plt)接口中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.35.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种接口最重要的特性是有状态的( stateful):它会持续跟踪“当前的图形和坐标轴,所有plt命令都可以应用。你可以用plt.gcf()(获取当前图形)和plt,gca()(获取当前坐标轴)来查看具体信息。</p><p>虽然这个有状态的接口画起来图又快又方便，但是也很容易出问题。当创建上面的第二个子图时,怎么才能回到第一个子图,并增加新内容呢?虽然用 MATLAB风格接口也能实现,但未免过于复杂,好在还有一种更好的办法!</p><h2 id="面向对象接口"><a href="#面向对象接口" class="headerlink" title="面向对象接口"></a>面向对象接口</h2><p>面向对象接口可以适应更复杂的场景,更好地控制你自己的图形。在面向对象接口中,画图函数不再受到当前“活动”图形或坐标轴的限制,而变成了显式的 Figure和Axes的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.40.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然在画简单图形时,选择哪种绘图风格主要看个人喜好,但是在画比较复杂的图形时,面向对象方法会更方便。在本章中,我们将在MATLAB风格接口与面向对象接口间来回转换,具体内容根据实际情况而定。在绝大多数场中,plt.plot()与ax.plot()的差异非常小,但是其中会有一些陷阱。</p><h1 id="简易线形图"><a href="#简易线形图" class="headerlink" title="简易线形图"></a>简易线形图</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.41.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在 Matplotlib里面, figure(plt.Figure类的一个实例)可以被看成是个能够容纳各种坐标轴、图形、文字和标签的容器。就像你在图中看到的那样,axes(plt.Axes类的一个实例)是一个带有刻度和标签的矩形,最终会包含所有可视化的图形元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%889.59.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.13.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="调整图形：线条的颜色与风格"><a href="#调整图形：线条的颜色与风格" class="headerlink" title="调整图形：线条的颜色与风格"></a>调整图形：线条的颜色与风格</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.14.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果不指定颜色, Matplotlib就会为多条线自动循环使用一组默认的颜色。</p><p>与之类似，也可以用linestyle调整线条的风格。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.15.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.15.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一种更简洁的方式,则可以将linstyle和 color编码组合起来,作为plt.plot()函数的一个非关键字参数使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.27.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.27.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="调整图形：坐标轴上下限"><a href="#调整图形：坐标轴上下限" class="headerlink" title="调整图形：坐标轴上下限"></a>调整图形：坐标轴上下限</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.29.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果你想要让坐标轴逆序显示,那么也可以逆序设置坐标轴刻度值。</p><p>还有一个方法是plt,axis()(注意不要搞混axes和axis)。通过传入[xmin,xmax,ymin,ymax]对应的值,plt,axis()方法可以让你用一行代码设置x或y的限值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.31.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>plt axis（）还可以按照图形的内容自动收紧坐标轴，不留空白区域。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.32.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以xy轴单位长度相等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.33.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="设置图形标签"><a href="#设置图形标签" class="headerlink" title="设置图形标签"></a>设置图形标签</h2><p>图形标题与坐标轴标题是最简单的标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.34.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Matplotlib内置了一个简单快速的方法,可以用来创建图例,那就是plt. legend()。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.39.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在用面向对象接口画图时，不需要单独调用这些函数，通常采用ax.set()方法一次性设置所有的属性是更简便的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.41.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.41.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="简易散点图"><a href="#简易散点图" class="headerlink" title="简易散点图"></a>简易散点图</h1><p>另一种常用的图形是简易散点图( scatter plot),与线形图类似。这种图形不再由线段连接,而是由独立的点、圆圈或其他形状构成。开始的时候需要导入函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.43.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="用plt-plot画散点图"><a href="#用plt-plot画散点图" class="headerlink" title="用plt.plot画散点图"></a>用plt.plot画散点图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.45.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>函数的第三个参数是一个字符，表示图形符号的类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.47.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这些代码还可以与线条、颜色代码组合起来，画出一条连接散点的线。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.48.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.50.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="用plt-scatter画散点图"><a href="#用plt-scatter画散点图" class="headerlink" title="用plt.scatter画散点图"></a>用plt.scatter画散点图</h2><p>另一个可以创建散点图的函数是plt.scatter。它的功能非常强大其用法与plt.plot函数类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8A%E5%8D%8810.52.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>plt scatter与p1t.plot的主要差别在于,前者在创建散点图时具有更高的灵活性,可以单独控制每个散点与数据匹配,也可以让每个散点具有不同的属性(大小、表面颜色、边框颜色、透明度等)。</p><h2 id="plot与scatter：效率对比"><a href="#plot与scatter：效率对比" class="headerlink" title="plot与scatter：效率对比"></a>plot与scatter：效率对比</h2><p>plt.plot与plt.scatter除了特征上的差异之外,还有什么影响我们选择的因素呢?在数据量较小的时候,两者在效率上的差异不大。但是当数据变大到几千个散点时,plt.plot的效率将大大高于plt.scatter。这是由于plt.scatter会对每个散点进行单独的大小与颜色的渲染,因此渲染器会消耗更多的资源。而在plt.plot中,散点基本都彼此复制,因此整个数据集中所有点的颜色、尺寸只需要配置一次。由于这两种方法在处理大型数据集时有很大的性能差异,因此面对大型数据集时,plt.plot方法比plt.scatter方法好。</p><h1 id="可视化异常处理"><a href="#可视化异常处理" class="headerlink" title="可视化异常处理"></a>可视化异常处理</h1><h2 id="基本误差线"><a href="#基本误差线" class="headerlink" title="基本误差线"></a>基本误差线</h2><p>基本误差线( errorbar)可以通过一个 Matplotlib函数来创建。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%8812.49.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%8812.50.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>除了这些选项之外,你还可以设置水平方向的误差线(xerr)、单侧误差线( one-sided errorbar),以及其他形式的误差线。</p><h2 id="连续误差"><a href="#连续误差" class="headerlink" title="连续误差"></a>连续误差</h2><h1 id="密度图与等高线图"><a href="#密度图与等高线图" class="headerlink" title="密度图与等高线图"></a>密度图与等高线图</h1><p>Matplotlib提供了三个函数来解决这个问题:用plt.contour画等高线图、用plt.contourf画带有填充色的等高线图( filled contour plot)的色彩、用plt.imshow显示图形。</p><h2 id="三维函数的可视化"><a href="#三维函数的可视化" class="headerlink" title="三维函数的可视化"></a>三维函数的可视化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.04.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.04.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当图形中只使用一种颜色时,默认使用虚线表示负数,使用实线表示正数。我们可以通过plt.contourf()函数来填充等高线图，它的语法和plt.contour()是一样的。</p><p>还可以通过plt. colorbar()命令自动创建一个表示图形各种颜色对应标签信息的颜色条。但是图形还有一点不尽如人意的地方,就是看起来有点儿“污渍斑斑“不是那么干净。这是由于颜色的改变是一个离散而非连续的过程,这并不是我们想要的效果。你当然可以通过将等高线的数量设置得非常多来解决这个问题,但是最终获得的图形性能会很不好,因为 Matplotlib必须渲染每一级的等高线。其实有更好的做法,那就是通过plt.imshow()函数来处理,它可以将二维数组渲染成渐变图。</p><p>使用imshow（）函数有一些注意事项。</p><ol><li>plt.imshow()不支持用x轴和y轴数据设置网格，而是必须通过extent参数设置图形的坐标范围[xmin,xmax,ymin,ymax]。</li><li>plt.imshow()默认使用标准的图形数组定义，就是原点位于左上角，而不是绝大多数等高线图中使用的左下角，这一点在显示网格数据图形时必须调整。</li><li>plt.imshow()会自动调整坐标轴的精度以适应数据显示。可以通过plt.axis(aspect=‘image’)来设置x轴与y轴的单位。</li></ol><h1 id="频次直方图、数据区间划分和分布密度"><a href="#频次直方图、数据区间划分和分布密度" class="headerlink" title="频次直方图、数据区间划分和分布密度"></a>频次直方图、数据区间划分和分布密度</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.38.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>hist()有许多用来调整计算过程和显示效果的选项。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.39.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>histtype=‘ stepfilled’与透明性设置参数 alpha搭配使用的效果:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.41.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.41.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="二维频次直方图与数据区间划分"><a href="#二维频次直方图与数据区间划分" class="headerlink" title="二维频次直方图与数据区间划分"></a>二维频次直方图与数据区间划分</h2><p>就像将一维数组分为区间创建一维频次直方图一样,我们也可以将二维数组按照二维区间进行切分,来创建二维频次直方图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.50.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="plt-hist2d-二维频次直方图"><a href="#plt-hist2d-二维频次直方图" class="headerlink" title="plt.hist2d:二维频次直方图"></a>plt.hist2d:二维频次直方图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.50.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>plt.hist2d类似的函数式np.histogram2d。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%881.51.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="plt-hexbin-六边形区间划分"><a href="#plt-hexbin-六边形区间划分" class="headerlink" title="plt.hexbin:六边形区间划分"></a>plt.hexbin:六边形区间划分</h3><p>二维频次直方图是由于坐标轴正交的方块分割而成的，还有一种常用的方式是用正六边形分割。Matplotlib提供的plt.hexbin满足此类需求，将二维数据集分割成蜂窝状。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.02.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a>核密度估计</h3><p>有一种评估多维数据分布密度的常用方法是核密度估计KDE。KDE方法通过不同的平滑带宽长度( smoothing length)在拟合函数的准确性与平滑性之间作出权衡(无处不在的偏差与方差的取舍问题的一个例子)。想找到恰当的平滑带宽长度是件很困难的事, gaussian_kde通过一种经验方法试图找到输入数据平滑长度的近似最优解。</p><h1 id="配置图例"><a href="#配置图例" class="headerlink" title="配置图例"></a>配置图例</h1><p>设置图例的位置，并取消外框。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.11.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以用ncol参数设置图例的标签列数。还可以为图例定义圆角边框( fancybox)、增加阴影、改变外边框透明度( framealpha值),或者改变文字间距。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.13.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="选择图例显示的元素"><a href="#选择图例显示的元素" class="headerlink" title="选择图例显示的元素"></a>选择图例显示的元素</h2><p>图例会默认显示所有元素的标签。如果你不想显示全部,可以通过一些图形命令来指定显示图例中的哪些元素和标签。plt.plot()命令可以一次创建多条线,返回线条实例列表。一种方法是将需要显示的线条传入plt.legend(),另一种方法是只为需要在图例中显示的线条设置标签。默认情况下图例会忽略那些不带标签的元素。</p><h2 id="在图例中显示不同尺寸的点"><a href="#在图例中显示不同尺寸的点" class="headerlink" title="在图例中显示不同尺寸的点"></a>在图例中显示不同尺寸的点</h2><h2 id="同时显示多个图例"><a href="#同时显示多个图例" class="headerlink" title="同时显示多个图例"></a>同时显示多个图例</h2><p>我们可以通过从头开始创建一个图例艺术家对象（legend artist），然后用底层的（lower-level）ax.add_artiest()方法在图上添加第二个图例。</p><h1 id="配置颜色条"><a href="#配置颜色条" class="headerlink" title="配置颜色条"></a>配置颜色条</h1><p>在Matplotlib中，颜色条是一个独立的坐标轴，可以指明图形中颜色的含义。</p><h2 id="配置颜色条-1"><a href="#配置颜色条-1" class="headerlink" title="配置颜色条"></a>配置颜色条</h2><p>可以通过cmap参数为图形设置颜色条的配色方案。</p><h3 id="选择配色方案"><a href="#选择配色方案" class="headerlink" title="选择配色方案"></a>选择配色方案</h3><h4 id="顺序配色方案"><a href="#顺序配色方案" class="headerlink" title="顺序配色方案"></a>顺序配色方案</h4><p>由一组连续的颜色构成的配色方案(例如 binary或viridis)。</p><h4 id="互逆配色方案"><a href="#互逆配色方案" class="headerlink" title="互逆配色方案"></a>互逆配色方案</h4><p>通常由两种互补的颜色构成,表示正反两种含义(例如RdBu或PuOr)。</p><h4 id="定性配色方案"><a href="#定性配色方案" class="headerlink" title="定性配色方案"></a>定性配色方案</h4><p>随机顺序的一组颜色(例如 rainbow或jet)。</p><h3 id="颜色条刻度的限制与扩展功能的设置"><a href="#颜色条刻度的限制与扩展功能的设置" class="headerlink" title="颜色条刻度的限制与扩展功能的设置"></a>颜色条刻度的限制与扩展功能的设置</h3><p>Matplotlib提供了丰富的颜色条配置功能。由于可以将颜色条本身仅看作是一个plt.Axes实例,因此前面所学的所有关于坐标轴和刻度值的格式配置技巧都可以派上用场。</p><h3 id="离散型颜色条"><a href="#离散型颜色条" class="headerlink" title="离散型颜色条"></a>离散型颜色条</h3><p>虽然颜色条默认都是连续的,但有时你可能也需要表示离散数据。最简单的做法就是使用plt.cm.get_cmap()函数,将适当的配色方案的名称以及需要的区间数量传进去即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%882.54.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="多子图"><a href="#多子图" class="headerlink" title="多子图"></a>多子图</h1><h2 id="plt-axes-手动创建子图"><a href="#plt-axes-手动创建子图" class="headerlink" title="plt.axes:手动创建子图"></a>plt.axes:手动创建子图</h2><p>创建坐标轴最基本的方法就是使用p1t.axes函数。前面已经介绍过,这个函数的默认配置是创建一个标准的坐标轴,填满整张图。它还有个可选参数,由图形坐标系统的四个值构成。这四个值分别表示图形坐标系统的[bottom,Left, width, height](底坐标、左坐标、宽度、高度),数值的取值范围是左下角(原点)为0,右上角为1。</p><p>如果想要在右上角创建一个画中画,那么可以首先将x与y设置为0.65(就是坐标轴原点位于图形高度65%和宽度65%的位置),然后将x与y扩展到0,2(也就是将坐标轴的宽度与高度设置为图形的20%)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%883.00.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%883.00.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>面向对象画图接口中类似的命令有fig.add_axes()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.12.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="plt-subplot-简易网格子图"><a href="#plt-subplot-简易网格子图" class="headerlink" title="plt.subplot:简易网格子图"></a>plt.subplot:简易网格子图</h2><p>最底层的方法是用plt.subplot()在一个网格中创建一个子图。这个命令有三个整型参数—将要创建的网格子图行数、列数和索引值,索引值从1开始,从左上角到右下角依次增大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.17.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>plt.subplots_adjust命令可以调整子图之间的间隔。用面向对象接口的命令fig.ad_subplot()可以取得同样的效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.20.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="plt-subplots-用一行代码创建网格"><a href="#plt-subplots-用一行代码创建网格" class="headerlink" title="plt.subplots:用一行代码创建网格"></a>plt.subplots:用一行代码创建网格</h2><p>想隐藏内部子图的x轴与y轴标题时。出于这一需求,plt.subplots()实现了你想要的功能(需要注意此处 subplots结尾多了个s)。这个函数不是用来创建单个子图的,而是用一行代码创建多个子图,并返回一个包含子图的 NumPy数组。关键参数是行数与列数,以及可选参数 sharex与 sharey,通过它们可以设置不同子图之间的关联关系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.27.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>设置 sharex与 sharey参数之后,我们就可以自动去掉网格内部子图的标签,让图形看起来更整洁。坐标轴实例网格的返回结果是一个NumPy数组,这样就可以通过标准的数组取值方式轻松获取想要的坐标轴了。</p><p>与plt.subplot()相比,p1t. subplots()与 Python索引从0开始的习惯保持一致。</p><h2 id="plt-Gridspec-实现更复杂的排列方式"><a href="#plt-Gridspec-实现更复杂的排列方式" class="headerlink" title="plt.Gridspec:实现更复杂的排列方式"></a>plt.Gridspec:实现更复杂的排列方式</h2><p>如果想实现不规则的多行多列子图网格,plt. Gridspec()是最好的工具。plt.Gridspec()对象本身不能直接创建一个图形,它只是plt.subplot()命令可以识别的简易接口。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.32.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.32.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.32.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="文字与注释"><a href="#文字与注释" class="headerlink" title="文字与注释"></a>文字与注释</h1><h2 id="坐标变换与文字位置"><a href="#坐标变换与文字位置" class="headerlink" title="坐标变换与文字位置"></a>坐标变换与文字位置</h2><ol><li>ax.transData，以数据为基准的坐标变换。</li><li>ax.transAxes，以坐标轴为基准的坐标变换（以坐标轴维度为单位）。</li><li>fig.transFigure，以图形为基准的坐标变换（以图形维度为单位）。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%886.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>transData坐标用x轴与y轴的标签作为数据坐标。 transAxes坐标以坐标轴(图中白色矩形)左下角的位置为原点,按坐标轴尺寸的比例呈现坐标。 trans Figure坐标与之类似,不过是以图形(图中灰色矩形)左下角的位置为原点,按图形尺寸的比例呈现坐标。</p><h2 id="箭头与注释"><a href="#箭头与注释" class="headerlink" title="箭头与注释"></a>箭头与注释</h2><p>在 Matplotlib里面画箭头通常比你想象的要困难。虽然有一个plt.arrow()函数可以实现这个功能,但是我不推荐使用它,因为它创建出的箭头是SvG向量图对象,会随着图形分辨率的变化而改变,最终的结果可能完全不是用户想要的。我要推荐的是plt.annotate()函数。这个函数既可以创建文字,也可以创建箭头,而且它创建的箭头能够进行非常灵活的配置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.21.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>箭头的风格是通过arrowprops字典控制的。</p><h1 id="自定义坐标轴刻度"><a href="#自定义坐标轴刻度" class="headerlink" title="自定义坐标轴刻度"></a>自定义坐标轴刻度</h1><p>在介绍示例之前,我们最好先对 Matplotlib图形的对象层级有更深入的理解。 Matplotlib的目标是用 Python对象表现任意图形元素。例如,figure对象其实就是一个盛放图形元素的包围盒( bounding box)。可以将每个 Matplotlib对象都看成是子对象(sub-object)的容器,例如每个 figure都会包含一个或多个axes对象,每个aXes对象又会包含其他表示图形内容的对象。</p><p>坐标轴刻度线也不例外。每个axeS都有 axis和 yaxis属性,每个属性同样包含构成坐标轴的线条、刻度和标签的全部属性。</p><h2 id="主要刻度与次要刻度"><a href="#主要刻度与次要刻度" class="headerlink" title="主要刻度与次要刻度"></a>主要刻度与次要刻度</h2><p>我们发现每个主要刻度都显示为一个较大的刻度线和标签,而次要刻度都显示为一个较小的刻度线,且不显示标签。</p><p>可以通过设置每个坐标轴的 formatter与 locator对象,自定义这些刻度属性(包括刻度线的位置和标签)。</p><p>主要刻度标签和次要刻度标签的位置都是通过一个LogLocator对象(在对数图中可以看到)设置的。然而,次要刻度有个NullFormatter对象处理标签,这样标签就不会在图上显示了。</p><h2 id="隐藏刻度与标签"><a href="#隐藏刻度与标签" class="headerlink" title="隐藏刻度与标签"></a>隐藏刻度与标签</h2><p>最常用的刻度/标签格式化操作可能就是隐藏刻度与标签了,可以通过plt. NullLocator()与plt.NullFormatter()实现。</p><h2 id="增减刻度数量"><a href="#增减刻度数量" class="headerlink" title="增减刻度数量"></a>增减刻度数量</h2><p>默认刻度标签有一个问题,就是显示较小图形时,通常刻度显得十分拥挤。数字几乎都重叠在一起,辨识起来非常困难。我们可以用plt. MaxNLocator()来解决这个问题,通过它可以设置最多需要显示多少刻度。根据设置的最多刻度数量, Matplotlib会自动为刻度安排恰当的位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.36.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="花哨的刻度格式"><a href="#花哨的刻度格式" class="headerlink" title="花哨的刻度格式"></a>花哨的刻度格式</h2><p>可以通过设置一个MultipleLocator来实现将刻度放在你提供的数值的倍数上。让图形会更加自然。</p><h2 id="格式生成器与定位器小结"><a href="#格式生成器与定位器小结" class="headerlink" title="格式生成器与定位器小结"></a>格式生成器与定位器小结</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.42.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.43.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.43.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.43.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Matplotlib自定义：配置文件与样式表"><a href="#Matplotlib自定义：配置文件与样式表" class="headerlink" title="Matplotlib自定义：配置文件与样式表"></a>Matplotlib自定义：配置文件与样式表</h1><h2 id="手动配置图形"><a href="#手动配置图形" class="headerlink" title="手动配置图形"></a>手动配置图形</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.45.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.45.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次都要手动配置一番太麻烦了，可以配置一次默认图形将其应用到所有图形上。</p><h2 id="修改默认配置：rcParams"><a href="#修改默认配置：rcParams" class="headerlink" title="修改默认配置：rcParams"></a>修改默认配置：rcParams</h2><p>Matplotlib每次加载时,都会定义一个运行时配置(rc),其中包含了所有你创建的图形元素的默认风格。你可以用plt.rc简便方法随时修改这个配置。</p><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><h3 id="默认风格"><a href="#默认风格" class="headerlink" title="默认风格"></a>默认风格</h3><h3 id="FiveThirtyEight风格"><a href="#FiveThirtyEight风格" class="headerlink" title="FiveThirtyEight风格"></a>FiveThirtyEight风格</h3><h3 id="ggplot风格"><a href="#ggplot风格" class="headerlink" title="ggplot风格"></a>ggplot风格</h3><h3 id="bmh风格"><a href="#bmh风格" class="headerlink" title="bmh风格"></a>bmh风格</h3><h3 id="黑色背景风格"><a href="#黑色背景风格" class="headerlink" title="黑色背景风格"></a>黑色背景风格</h3><h3 id="灰度风格"><a href="#灰度风格" class="headerlink" title="灰度风格"></a>灰度风格</h3><h3 id="Seaborn风格"><a href="#Seaborn风格" class="headerlink" title="Seaborn风格"></a>Seaborn风格</h3><h1 id="用Matplotlib画三维图"><a href="#用Matplotlib画三维图" class="headerlink" title="用Matplotlib画三维图"></a>用Matplotlib画三维图</h1><p>我们可以导入 Matplotlib自带的plot3d工具箱来画三维图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.53.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>导入这个子模块之后,就可以在创建任意一个普通坐标轴的过程中加入projection=‘3d’关键字,从而创建一个三维坐标轴。</p><h2 id="三维数据点与线"><a href="#三维数据点与线" class="headerlink" title="三维数据点与线"></a>三维数据点与线</h2><p>最基本的三维图是由(x,y,z)三维坐标点构成的线图与散点图。与前面介绍的普通二维图类似,可以用 ax.plot3D与ax.scatter3D函数来创建它们。三维图函数的参数与前面二维图函数的参数基本相同。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%887.57.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>默认情况下，散点会自动改变透明度，以在平面上呈现出立体感。</p><h2 id="三维等高线"><a href="#三维等高线" class="headerlink" title="三维等高线"></a>三维等高线</h2><p>与之前的等高线类似,mplot3d也有用同样的输入数据创建三维晕渲( relief)图的工具。与二维ax.contour图形一样,ax.contour3D要求所有数据都是二维网格数据的形式,并且由函数计算z轴数值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.02.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="线框图和曲面图"><a href="#线框图和曲面图" class="headerlink" title="线框图和曲面图"></a>线框图和曲面图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.04.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.04.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>曲面图与线框图类似,只不过线框图的每个面都是由多边形构成的。只要增加一个配色方案来填充这些多边形。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.05.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>画曲面图需要二维数据,但可以不是直角坐标系(也可以用极坐标)。</p><h2 id="曲面三角剖分"><a href="#曲面三角剖分" class="headerlink" title="曲面三角剖分"></a>曲面三角剖分</h2><h1 id="用Basemap可视化地理数据"><a href="#用Basemap可视化地理数据" class="headerlink" title="用Basemap可视化地理数据"></a>用Basemap可视化地理数据</h1><p>地理数据可视化是数据科学中一种十分常见的可视化类型。 Matplotlib做此类可视化的主要工具是 Basemap工具箱。</p><p>安装并导入 Basemap工具箱后,只用几行代码就可以画出地理图形。</p><h1 id="用Seaborn做数据可视化"><a href="#用Seaborn做数据可视化" class="headerlink" title="用Seaborn做数据可视化"></a>用Seaborn做数据可视化</h1><p>虽然 Matplotlib已经证明了自己绝对是一款超级实用且流行的数据可视化工具,但是即使骨灰粉也不得不承认它不支持的功能还有很多。</p><p>Seaborn在Matplotlib的基础上开发了一套API,为默认的图形样式和颜色设置提供了理智的选择,为常用的统计图形定义了许多简单的高级函数,并与Pandas dataFrame的功能有机结合。</p><h2 id="Seaborn与Matplotlib"><a href="#Seaborn与Matplotlib" class="headerlink" title="Seaborn与Matplotlib"></a>Seaborn与Matplotlib</h2><p>Seaborn不仅有许多高级的画图功能,而且可以改写 Matplotlib的默认参数,从而用简单的Matplotlib脚本获得更好的效果。可以用 Seaborn的set()方法设置样式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.54.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.54.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.55.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-01%20%E4%B8%8B%E5%8D%888.55.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Seaborn图形介绍"><a href="#Seaborn图形介绍" class="headerlink" title="Seaborn图形介绍"></a>Seaborn图形介绍</h2><h3 id="频次直方图、KDE和密度图"><a href="#频次直方图、KDE和密度图" class="headerlink" title="频次直方图、KDE和密度图"></a>频次直方图、KDE和密度图</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Matplotlib是建立在 NumPy数组基础上的多平台数据可视化程序库。&lt;/p&gt;
&lt;p&gt;Matplotlib最重要的特性之一就是具有良好的操作系统兼容性和图形显示底层接口兼容性( graphics backend)。 Matplotlib支持几十种图形显示接口与输出格式
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据科学手册 Pandas数据处理</title>
    <link href="https://github.com/zdkswd/2018/10/31/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/10/31/Python数据科学手册 Pandas数据处理/</id>
    <published>2018-10-31T13:00:56.000Z</published>
    <updated>2018-10-31T13:07:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas是在NumPy基础上建立的新程序库,提供了一种高效的 DataFrame数据结构。 DataFrame本质上是一种带行标签和列标签、支持相同类型数据和缺失值的多维数组。 Pandas不仅为带各种标签的数据提供了便利的存储界面,还实现了许多强大的操作,这些操作对数据库框架和电子表格程序的用户来说非常熟悉。</p><p>建立在NumPy数组结构上的 Pandas,尤其是它的 Series和 DataFrame对象,为数据科学家们处理那些消耗大量时间的“数据清理”(data munging)任务提供了捷径。</p><h1 id="安装并使用Pandas"><a href="#安装并使用Pandas" class="headerlink" title="安装并使用Pandas"></a>安装并使用Pandas</h1><p>在安装Pandas之前，确保操作系统中有NumPy。</p><h1 id="Pandas对象简介"><a href="#Pandas对象简介" class="headerlink" title="Pandas对象简介"></a>Pandas对象简介</h1><p>如果从底层视角观察Pandas对象，可以把它们看成增强版的NumPy结构化数组，行列都不再只是简单的整数索引，还可以带上标签。Pandas的三个基本数据结构：Series、DataFrame和Index。</p><h2 id="Pandas的Series对象"><a href="#Pandas的Series对象" class="headerlink" title="Pandas的Series对象"></a>Pandas的Series对象</h2><p>Pandas的 Series对象是一个带索引数据构成的一维数组。可以用一个数组创建 Series对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%888.45.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从上面的结果中,你会发现 Series对象将一组数据和一组索引绑定在一起,我们可以通过 values属性和 index属性获取数据。 values属性返回的结果与 NumPy数组类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.33.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>index属性返回的结果是一个类型为pd. Index的类数组对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.34.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>和 NumPy数组一样,数据可以通过 Python的中括号索引标签获取。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.35.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Pandas的 Series对象比它模仿的一维 NumPy数组更加通用、灵活。</p><h3 id="Serise是通用的-NumPy数组"><a href="#Serise是通用的-NumPy数组" class="headerlink" title="Serise是通用的 NumPy数组"></a>Serise是通用的 NumPy数组</h3><p>Series对象和一维 NumPy数组两者间的本质差异其实是索引: NumPy数组通<br>过隐式定义的整数索引获取数值,而 Pandas的 Series对象用一种显式定义的索引与数值关联。显式索引的定义让 Series对象拥有了更强的能力。例如,索引不<br>再仅仅是整数,还可以是任意想要的类型。如果需要,完全可以用字符串定义索引。也可以使用不连续或不按顺序的索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.39.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.40.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Series是特殊的字典"><a href="#Series是特殊的字典" class="headerlink" title="Series是特殊的字典"></a>Series是特殊的字典</h3><p>可以把 Pandas的 Series对象看成一种特殊的 Python字典。字典是一种将任意键映射到一组任意值的数据结构,而 Series对象其实是一种将类型键映射到一组类型值的数据结构。类型至关重要:就像 NumPy数组背后特定类型的经过编译的代码使得它在某些操作上比普通的 Python列表更加高效一样, Pandas series的类型信息使得它在某些操作上比 Python的字典更高效。用字典创建 Series对象时,其索引默认按照顺序排列。典型的字典数值获取方式仍然有效。和字典不同, Series对象还支持数组形式的操作,比如切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8810.45.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="创建Series对象"><a href="#创建Series对象" class="headerlink" title="创建Series对象"></a>创建Series对象</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.06.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中，index是一个可选参数，data参数支持多种数据类型。data可以是列表或 NumPy数组,这时 index默认值为整数序列，data也可以是一个标量,创建 Series对象时会重复填充到每个索引上。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.08.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>data还可以是一个字典，index默认是排序的字典键。每一种形式都可以通过显式指定索引筛选需要的结果，这里需要注意的是, Series对象只会保留显式定义的键值对。</p><h2 id="Pandas的-DataFrame对象"><a href="#Pandas的-DataFrame对象" class="headerlink" title="Pandas的 DataFrame对象"></a>Pandas的 DataFrame对象</h2><p>DataFrame既可以作为一个通用型 NumPy数组,也可以看作特殊的 Python字典。</p><h3 id="Dataframe是通用的-NumPy数组"><a href="#Dataframe是通用的-NumPy数组" class="headerlink" title="Dataframe是通用的 NumPy数组"></a>Dataframe是通用的 NumPy数组</h3><p>把 DataFrame看成是有序排列的若干 Series对象。这里的“排<br>列指的是它们拥有共同的索引。</p><p>再结合之前创建的 population的 Series对象,用一个字典创建<br>个包含这些信息的二维对象<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.36.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.36.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>和 Series对象一样, DataFrame也有一个 index属性可以获取索引标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.37.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另外, DataFrame还有一个 columns属性,是存放列标签的Index对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.05.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> Dataframe可以看作一种通用的 NumPy二维数组,它的行与列都可以通过索引获取。</p><h3 id="DataFrame是特殊的字典"><a href="#DataFrame是特殊的字典" class="headerlink" title="DataFrame是特殊的字典"></a>DataFrame是特殊的字典</h3><p>与 Series类似,我们也可以把 DataFrame看成一种特殊的字典。字典是一个键映射一个值,而 DataFrame是一列映射一个Series的数据。例如,通过’area’的列属性可以返回包含面积数据的Series对象。</p><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><h4 id="通过单个Series对象创建"><a href="#通过单个Series对象创建" class="headerlink" title="通过单个Series对象创建"></a>通过单个Series对象创建</h4><p>DataFrame是一组 Series对象的集合,可以用单个 Series创建一个单列的 Dataframe。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.15.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="通过字典列表创建"><a href="#通过字典列表创建" class="headerlink" title="通过字典列表创建"></a>通过字典列表创建</h4><p>任何元素是字典的列表都可以变成DataFrame。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即使字典中有些键不存在, Pandas也会用缺失值NaN(不是数字,not a number)来表示。</p><h4 id="通过Series对象字典创建"><a href="#通过Series对象字典创建" class="headerlink" title="通过Series对象字典创建"></a>通过Series对象字典创建</h4><p>DataFrame也可以用一个由 Series对象构成的字典创建。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.24.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="通过NumPy二维数组创建"><a href="#通过NumPy二维数组创建" class="headerlink" title="通过NumPy二维数组创建"></a>通过NumPy二维数组创建</h4><p>假如有一个二维数组,就可以创建个可以指定行列索引值的 DataFrame。如果不指定行列索引值那么行列默认都是整数索引值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.28.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="通过NumPy结构化数组创建"><a href="#通过NumPy结构化数组创建" class="headerlink" title="通过NumPy结构化数组创建"></a>通过NumPy结构化数组创建</h4><p>由于 Pandas的 DataFrame与结构化数组十分相似,因此可以通过结<br>构化数组创建 Dataframe。</p><h2 id="Pandas的Index对象"><a href="#Pandas的Index对象" class="headerlink" title="Pandas的Index对象"></a>Pandas的Index对象</h2><p>Series和 DataFrame对象都使用便于引用和调整的显式索引。 Pandas的 Index对象是一个很有趣的数据结构,可以将它看作是一个不可变数组或有序集合(实际上是一个多集,因为 Index对象可能会包含重复值)。这两种观点使得 Index对象能呈现一些有趣的功能。让我们用一个简单的整数列表来创建一个 Index对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.36.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="将Index看作不可变数组"><a href="#将Index看作不可变数组" class="headerlink" title="将Index看作不可变数组"></a>将Index看作不可变数组</h3><p>Index对象的许多操作都像数组。例如,可以通过标准 Python的取值方法获取数值,也可以通过切片获取数值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.38.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Index对象与 NumPy数组之间的不同在于, Index对象的索引是不可变的,也就是说不能通过通常的方式进行调整。Index对象的不可变特征使得多个DataFrame和数组之间进行索引共享时更加安全,尤其是可以避免因修改索引时粗心大意而导致的副作用。</p><h3 id="将Index看作有序集合"><a href="#将Index看作有序集合" class="headerlink" title="将Index看作有序集合"></a>将Index看作有序集合</h3><p>Pandas对象被设计用于实现许多操作,如连接(join)数据集,其中会涉及许多集合操作。Index对象遵循 Python标准库的集合(set)数据结构的许多习惯用法,包括并集、交集、差集等。</p><h1 id="数据取值与选择"><a href="#数据取值与选择" class="headerlink" title="数据取值与选择"></a>数据取值与选择</h1><h2 id="Series数据选择方法"><a href="#Series数据选择方法" class="headerlink" title="Series数据选择方法"></a>Series数据选择方法</h2><h3 id="将-Series看作字典"><a href="#将-Series看作字典" class="headerlink" title="将 Series看作字典"></a>将 Series看作字典</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.46.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们还可以用 Python字典的表达式和方法来检测键/索引和值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.49.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Series对象还可以用字典语法调整数据。就像你可以通过增加新的键扩展字典一样,你也可以通过增加新的索引值扩展 Series。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%885.50.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Series对象的可变性是一个非常方便的特性: Pandas在底层已经为可能发生的内存布局和数据复制自动决策,用户不需要担心这些问题。</p><h3 id="将-Series看作一维数组"><a href="#将-Series看作一维数组" class="headerlink" title="将 Series看作一维数组"></a>将 Series看作一维数组</h3><p>Series不仅有着和字典一样的接口,而且还具备和 NumPy数组一样的数组数据选择功能,包括索引、掩码、花哨的索引等操作。切片是绝大部分混乱之源。需要注意的是,当使用显式索引(即data[‘a’:’c’])作切片时,结果包含最后一个索引;而当使用隐式索引(即data[0:2])作切片时,结果不包含最后一个索引。</p><h3 id="索引器：loc、iloc和ix"><a href="#索引器：loc、iloc和ix" class="headerlink" title="索引器：loc、iloc和ix"></a>索引器：loc、iloc和ix</h3><p>这些切片和取值的习惯用法经常会造成混乱。例如,如果你的Series是显式整数索引,那么data[1]这样的取值操作会使用显式索引,而data[1:3]这样的切片操作却会使用隐式索引。由于整数索引很容易造成混淆,所以 Pandas提供了一些索引器( indexer)属性来作为取值的方法。它们不是 Series对象的函数方法,而是暴露切片接口的属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.00.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.01.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>即从0开始，左闭右开区间。<br>第三种取值属性是ix,它是前两种索引器的混合形式,在 Series对象中ix等价于标准的<a href="Python列表"></a>取值方式。ix索引器主要用于DataFrame对象。</p><p>Python代码的设计原则之一是“显式优于隐式”。使用loc和iloc可以让代码更容易维护,可读性更高。特别是在处理整数索引的对象时,强烈推荐使用这两种索引器。它们既可以让代码阅读和理解起来更容易,也能避免因误用索引/切片而产生的小bug。</p><h2 id="DataFrame数据选择方法"><a href="#DataFrame数据选择方法" class="headerlink" title="DataFrame数据选择方法"></a>DataFrame数据选择方法</h2><p>Dataframe在有些方面像二维或结构化数组,在有些方面又像一个共享索引的若干 Series对象构成的字典。</p><h3 id="将-Dataframe看作字典"><a href="#将-Dataframe看作字典" class="headerlink" title="将 Dataframe看作字典"></a>将 Dataframe看作字典</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.20.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>两个 Series分别构成 Dataframe的一列,可以通过对列名进行字典形式( dictionary- style)的取值获取数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然属性形式的数据选择方法很方便,但是它并不是通用的。如果列名不是纯字符串,或者列名与 DataFrame的方法同名,那么就不能用属性索引。例如, Dataframe有一个pop()方法,如果用data.pop就不会获取’pop’列,而是显示为方法。另外,还应该避免对用属性形式选择的列直接赋值(即可以用data[‘pop’]=z,但不要用data.pop=z)。</p><h3 id="将DataFrame看作二维数组"><a href="#将DataFrame看作二维数组" class="headerlink" title="将DataFrame看作二维数组"></a>将DataFrame看作二维数组</h3><p>可以把 Dataframe看成是一个增强版的二维数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.29.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>理解了这一点,就可以把许多数组操作方式用在 DataFrame上。例如,可以对 DataFrame进行行列转置。<br>获取一行数据时。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>获取一列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.39.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在进行数组形式的取值时，我们就需要用另一种方法。loc、iloc和ix。通过iloc索引器，我们就可以像对待NumPy数组一样索引Pandas的底层数组（Python的隐式索引）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.44.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用ix索引器可以实现一种混合效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.46.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是,ix索引器对于整数索引的处理和之前在 Series对象中介绍的一样,都容易让人混淆。任何用于处理 NumPy形式数据的方法都可以用于这些索引器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%886.51.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="其他取值方法"><a href="#其他取值方法" class="headerlink" title="其他取值方法"></a>其他取值方法</h3><p>还有一些取值方法看着有点奇怪，但在实践中还是好用。首先，如果对单个标签取值就选择列，而对多个标签用切边就选择行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%887.01.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>切片也可以不用索引值，而直接用行数来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%887.02.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与此类似，掩码操作也可以直接对每一行进行过滤，而不需要使用loc索引器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.12.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Pandas数值运算方法"><a href="#Pandas数值运算方法" class="headerlink" title="Pandas数值运算方法"></a>Pandas数值运算方法</h1><p>NumPy的基本能力之一是快速对每个元素进行运算,既包括基本算术运算(加、减、乘、除),也包括更复杂的运算(三角函数、指数函数和对数函数等)。 Pandas继承了 NumPy的功能,通用函数是关键。</p><h2 id="通用函数：保留索引"><a href="#通用函数：保留索引" class="headerlink" title="通用函数：保留索引"></a>通用函数：保留索引</h2><p>因为 Pandas是建立在 NumPy基础之上的,所以 NumPy的通用函数同样适用于 Pandas的 Series和 DataFrame对象。</p><h2 id="通用函数：索引对齐"><a href="#通用函数：索引对齐" class="headerlink" title="通用函数：索引对齐"></a>通用函数：索引对齐</h2><p>当在两个 Series或 DataFrame对象上进行二元计算时, Pandas会在计算过程中对齐两个对象的索引。</p><h3 id="Series索引对齐"><a href="#Series索引对齐" class="headerlink" title="Series索引对齐"></a>Series索引对齐</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.25.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于缺失位置的数据, Pandas会用NaN填充,表示“此处无数”。这种索引对齐方式是通过 Python内置的集合运算规则实现的,任何缺失值默认都用NaN填充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.29.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果用NaN值不是我们想要的结果,那么可以用适当的对象方法代替运算符。例如，A.add(B)等价于A+B，也可以设置参数自定义A或B缺失的数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.31.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="DataFrame索引对齐"><a href="#DataFrame索引对齐" class="headerlink" title="DataFrame索引对齐"></a>DataFrame索引对齐</h3><p>在计算两个 DataFrame时,类似的索引对齐规则也同样会出现在共同(并集)列中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.42.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>你会发现,两个对象的行列索引可以是不同顺序的,结果的索引会自动按顺序排列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%888.45.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="通用函数-DataFrame与-Series的运算"><a href="#通用函数-DataFrame与-Series的运算" class="headerlink" title="通用函数: DataFrame与 Series的运算"></a>通用函数: DataFrame与 Series的运算</h2><p>对一个 DataFrame和一个 Series进行计算,行列对齐方式与之前类似。也就是说, DataFrame和 Series的运算规则,与NumPy中二维数组与一维数组的运算规则是一样的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.11.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.11.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>根据 NumPy的广播规则，让二维数组减自身的行数据会按行计算。在 Pandas里默认也是按行运算的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.13.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果你想按列计算,那么就需要利用前面介绍过的运算符方法,通过axis参数设置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8B%E5%8D%889.16.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h1><p>大多数教程里使用的数据与现实工作中的数据的区别在于后者很少是干净整齐的,许多目前流行的数据集都会有数据缺失的现象。更为甚者处理不同数据源缺失值的方法还不同。</p><h2 id="选择处理缺失值的方法"><a href="#选择处理缺失值的方法" class="headerlink" title="选择处理缺失值的方法"></a>选择处理缺失值的方法</h2><p>在数据表或 DataFrame中有很多识别缺失值的方法。一般情况下可以分为两种:一种方法是通过一个覆盖全局的掩码表示缺失值,另一种方法是用一个标签值( sentinel value)表示缺失值。在掩码方法中,掩码可能是一个与原数组维度相同的完整布尔类型数组,也可能是用一个比特(0或1)表示有缺失值的局部状态。在标签方法中,标签值可能是具体的数据(例如用9999表示缺失的整数),也可能是些极少出现的形式。另外,标签值还可能是更全局的值,比如用NaN(不是一个数)表示缺失的浮点数,它是IEEE浮点数规范中指定的特殊字符。</p><p>使用这两种方法之前都需要先综合考量:使用单独的掩码数组会额外出现一个布尔类型数组,从而增加存储与计算的负担;而标签值方法缩小了可以被表示为有效值的范围,可能需要在CPU或GPU算术逻辑单元中增加额外的(往往也不是最优的)计算逻辑。通常使用的NaN也不能表示所有数据类型。</p><p>大多数情况下,都不存在最佳选择,不同的编程语言与系统使用不同的方法。</p><h2 id="Pandas的缺失值"><a href="#Pandas的缺失值" class="headerlink" title="Pandas的缺失值"></a>Pandas的缺失值</h2><p>Pandas里处理缺失值的方式延续了 NumPy程序包的方式,并没有为浮点数据类型提供内置的NA作为缺失值。</p><p>Pandas原本也可以按照R语言采用的比特模式为每一种数据类型标注缺失值，但是这种方法非常笨拙。其工作量几乎相当于创建一个新的NumPy程序包。另外，对于一些较小的数据类型，牺牲一个比特作为缺失值标注的掩码还会导致其数据范围缩小。当然, NumPy也是支持掩码数据的,也就是说可以用一个布尔掩码数组为原数组标注“无缺失值”或“有缺失值”。 Pandas也集成了这个功能,<br>但是在存储、计算和编码维护方面都需要耗费不必要的资源,因此这种方式并不可取。</p><p>综合考虑各种方法的优缺点, Pandas最终选择用标签方法表示缺失值,包括两种 Python原有的缺失值:浮点数据类型的NaN值,以及 Python的None对象。后面我们将会发现,虽然这么做也会有一些副作用,但是在实际运用中的效果还是不错的。</p><h3 id="None：Python对象类型的缺失值"><a href="#None：Python对象类型的缺失值" class="headerlink" title="None：Python对象类型的缺失值"></a>None：Python对象类型的缺失值</h3><p>Pandas可以使用的第一种缺失值标签是None,它是一个 Python单体对象,经常在代码中表示缺失值。由于None是一个 Python对象,所以不能作为任何 NumPy/ Pandas数组类型的缺失值,只能用于object数组类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.42.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里 dtype= object表示 NumPy认为由于这个数组是 Python对象构成的,因此将其类型判断为 object。虽然这种类型在某些情景中非常有用,对数据的任何操作最终都会在 Python层面完成,但是在进行常见的快速操作时,这种类型比其他原生类型数组要消耗更多的资源。</p><p>使用 Python对象构成的数组就意味着如果你对一个包含None的数组进行累计操作,如sum()或者min(),那么通常会出现类型错误。这就是说,在 Python中没有定义整数与None之间的加法运算。</p><h3 id="NaN-数值类型的缺失值"><a href="#NaN-数值类型的缺失值" class="headerlink" title="NaN:数值类型的缺失值"></a>NaN:数值类型的缺失值</h3><p>另一种缺失值的标签是NaN(全称 Not a number,不是一个数字),是一种按照IEEE浮点数标准设计、在任何系统中都兼容的特殊浮点数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.47.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>NumPy会为这个数组选择一个原生浮点类型,这意味着和之前的 object类型数组不同,这个数组会被编译成C代码从而实现快速操作。你可以把NaN看作是一个数据类病毒它会将与它接触过的数据同化。无论和NaN进行何种操作,最终结果都是NaN。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.48.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>NumPy也提供了一些特殊的累计函数,它们可以忽略缺失值的影响。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8810.49.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>谨记,NaN是一种特殊的浮点数,不是整数、字符串以及其他数据类型。</p><h3 id="Pandas中NaN与None的差异"><a href="#Pandas中NaN与None的差异" class="headerlink" title="Pandas中NaN与None的差异"></a>Pandas中NaN与None的差异</h3><p>虽然NaN与None各有各的用处,但是 Pandas把它们看成是可以等价交换的,在适当的时候会将两者进行替换。</p><p>Pandas会将没有标签值的数据类型自动转换为NA。例如,当我们将整型数组中的一个值设置为np.nan时,这个值就会强制转换成浮点数缺失值NA。除了将整型数组的缺失值强制转换为浮点数, Pandas还会自动将None转换为NaN。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.36.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是, Pandas中字符串类型的数据通常是用 object类型存储的。</p><h2 id="处理缺失值-1"><a href="#处理缺失值-1" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><p>Pandas基本上把None和NaN看成是可以等价交换的缺失值形式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.40.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>返回一个填充看缺失值的数据副本。</p><h3 id="发现缺失值"><a href="#发现缺失值" class="headerlink" title="发现缺失值"></a>发现缺失值</h3><p>Pandas数据结构有两种有效的方法可以发现缺失值:isnull()和notnull()。每种方法都返回布尔类型的掩码数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.42.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>布尔类型掩码数组可以直接作为 Series或 DataFrame的索引使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.43.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在 Series里使用的isnull()和notnull()同样适用于Dataframe,产生的结果同样是布尔类型。</p><h3 id="剔除缺失值"><a href="#剔除缺失值" class="headerlink" title="剔除缺失值"></a>剔除缺失值</h3><p>dropna（）（剔除缺失值）和fillna（）（填充缺失值）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.49.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们没法从 DataFrame中单独剔除一个值,要么是剔除缺失值所在的整行,要么是整列。根据实际需求,有时你需要剔除整行,有时可能是整列, DataFrame中的 drona()会有一些参数可以配置。默认情况下, drona()会剔除任何包含缺失值的整行数据。可以设置按不同的坐标轴剔除缺失值,比如axis=1(或axis=‘ columns’)会剔除任何包含缺失值的整列数据。</p><p>但是这么做也会把非缺失值一并剔除,因为可能有时候只需要剔除全部是缺失值的行或列,或者绝大多数是缺失值的行或列。这些需求可以通过设置how或 thresh参数来满足,它们可以设置剔除行或列缺失值的数量阈值。</p><p>默认设置是how=‘any’,也就是说只要有缺失值就剔除整行或整列(通过axis设置坐标轴)。你还可以设置how=‘all’,这样就只会剔除全部是缺失值的行或列了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.53.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以通过 thresh参数设置行或列中非缺失值的最小数量,从而实现更加个性化的配置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.54.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h3><p>有时候你可能并不想移除缺失值,而是想把它们替换成有效的数值。有效的值可能是像0、1、2那样单独的值,也可能是经过填充( Imputation)或转换( interpolation)得到的。Pandas为此专门提供了一个fillna（）方法，将返回填充了缺失值后的数组副本。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8A%E5%8D%8811.56.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以用缺失值前面的有效值来从前往后填充。也可以用缺失值后面的有效值来从后往前填充(back-fil)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.20.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Dataframe的操作方法与 Series类似,只是在填充时需要设置坐标轴参数axis。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.24.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是,假如在从前往后填充时,需要填充的缺失值前面没有值,那么它就仍然是缺失值。</p><h1 id="层级索引"><a href="#层级索引" class="headerlink" title="层级索引"></a>层级索引</h1><p>当目前为止,我们接触的都是一维数据和二维数据,用 Pandas的Series和 DataFrame对象就可以存储。但我们也经常会遇到存储多维数据的需求,数据索引超过一两个键。因此, Pandas提供了 Panel和Pane4D对象解决三维数据与四维数据。而在实践中,更直观的形式是通过层级索引( hierarchical indexing,也被称为多级索引,muli- indexing)配合多个有不同等级( level)的一级索引一起使用,这样就可以将高维数组转换成类似一维 Series和二维DataFrame对象的形式。</p><h2 id="所及索引Series"><a href="#所及索引Series" class="headerlink" title="所及索引Series"></a>所及索引Series</h2><h3 id="笨方法"><a href="#笨方法" class="headerlink" title="笨方法"></a>笨方法</h3><p>使用元组。</p><h3 id="好方法：Pandas多级索引"><a href="#好方法：Pandas多级索引" class="headerlink" title="好方法：Pandas多级索引"></a>好方法：Pandas多级索引</h3><p>用元组表示索引其实是多级索引的基础。Pandas的 MultiIndex类型提供了更丰富的操作方法。我们可以用元组创建一个多级索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.35.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="高维数据的多级索引"><a href="#高维数据的多级索引" class="headerlink" title="高维数据的多级索引"></a>高维数据的多级索引</h3><p>unstack()方法可以快速将一个多级索引的 Series转化为普通索引的DataFrame。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.46.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当然了，也有stack（）方法实现相反的效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8812.47.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果我们可以用含多级索引的一维 Series数据表示二维数据,那么我们就可以用 Series或 Dataframe表示三维甚至更高维度的数据。多级索引每增加一级,就表示数据增加一维,利用这一特点就可以轻松表示任意维度的数据了。假如要增加一列显示每一年各州的人口统计指标(例如18岁以下的人口),那么对于这种带有<br>Multiindexⅹ的对象,增加一列就像 DataFrame的操作一样简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.35.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.40.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多级索引的创建方法"><a href="#多级索引的创建方法" class="headerlink" title="多级索引的创建方法"></a>多级索引的创建方法</h2><p>为 Series或 DataFrame创建多级索引最直接的办法就是将 index参数设置为至少二维的索引数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.42.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.42.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Multiindex的创建工作将在后台完成。同理,如果你把将元组作为键的字典传递给 Pandas, Pandas也会默认转MultiIndex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.44.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="显式地创建多级索引"><a href="#显式地创建多级索引" class="headerlink" title="显式地创建多级索引"></a>显式地创建多级索引</h3><p>可以通过一个有不同等级的若干简单数组组成的列表来构建 Multiindex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.48.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以通过包含多个索引值的元组构成的列表创建 MultiIndex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.56.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以用两个索引的笛卡尔积( Cartesian product)创建Multiindex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%881.58.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>更可以直接提供levels(包含每个等级的索引值列表的列表)和labels(包含每个索引值标签列表的列表)创建 MultiIndex。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.00.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在创建 Series或 Dataframe时,可以将这些对象作为 index参数,或者通过 reindex方法更新 Series或 Dataframe的索引。</p><h3 id="多级索引的等级名称"><a href="#多级索引的等级名称" class="headerlink" title="多级索引的等级名称"></a>多级索引的等级名称</h3><p>给MultIindex的等级加上名称会为一些操作提供便利。你可以在前面任何一个 Multiindex构造器中通过 names参数设置等级名称,也可以在创建之后通过索引的names属性来修改名称。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.09.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="多级列索引"><a href="#多级列索引" class="headerlink" title="多级列索引"></a>多级列索引</h3><p>每个 Dataframe的行与列都是对称的,也就是说既然有多级行索引,那么同样可以有多级列索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.14.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多级索引的取值与切片"><a href="#多级索引的取值与切片" class="headerlink" title="多级索引的取值与切片"></a>多级索引的取值与切片</h2><h3 id="Series多级索引"><a href="#Series多级索引" class="headerlink" title="Series多级索引"></a>Series多级索引</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.18.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>MultIindex也支持局部取值( partial indexing),即只取索引的某一个层级。假如只取最高级的索引,获得的结果是一个新的Series,未被选中的低层索引值会被保留。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.20.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>类似的还有局部切片,不过要求MultiIndex是按顺序排列的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.21.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果索引已经排序,那么可以用较低层级的索引取值,第一层级的索引可以用空切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其他取值与数据选择的方法也都起作用。下面的例子是通过布尔掩码选择数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.25.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.25.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以用花哨的索引选择数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.26.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="DataFrame多级索引"><a href="#DataFrame多级索引" class="headerlink" title="DataFrame多级索引"></a>DataFrame多级索引</h3><p>DataFrame多级索引的用法与 Series类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.32.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于Dataframe的基本索引是列索引,因此 Series中多级索引的用法到了 DataFrame中就应用在列上了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.35.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.35.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与单索引类似，loc、iloc和ix索引器都可以使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.36.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然这些索引器将多维数据当作二维数据处理,但是在loc和iloc中可以传递多个层级的索引元组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.38.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种索引元组的用法不是很方便,如果在元组中使用切片还会导致语法错误。<br>虽然可以用Python内置的slice（）函数获取想要的切片，但是还可以使用IndexSlice对象，Pandas专门用它解决这些问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.42.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多级索引行列转换"><a href="#多级索引行列转换" class="headerlink" title="多级索引行列转换"></a>多级索引行列转换</h2><h3 id="有序的索引和无序的索引"><a href="#有序的索引和无序的索引" class="headerlink" title="有序的索引和无序的索引"></a>有序的索引和无序的索引</h3><p>如果MultiIndex不是有序的索引，那么大多数切片操作都会失败。局部切片和许多其他相似的操作都要求MultiIndex的各级索引是有序的（即按照字典顺序由A至Z）。为此Pandas提供了许多便捷的操作完成排序，如sort_index()和sortlevel()方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%882.55.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>索引排序之后,局部切片就可以正常使用了。</p><h3 id="索引stack与unstack"><a href="#索引stack与unstack" class="headerlink" title="索引stack与unstack"></a>索引stack与unstack</h3><p>我们可以将一个多级索引数据集转换成简单的二维形式,可以通过level参数设置转换的索引层级。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.01.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>unstack()是 stack()的逆操作,同时使用这两种方法让数据保持不变。</p><h3 id="索引的设置与重置"><a href="#索引的设置与重置" class="headerlink" title="索引的设置与重置"></a>索引的设置与重置</h3><p>层级数据维度转换的另一种方法是行列标签转换,可以通过reset_index方法实现。</p><h2 id="多级索引的数据累计方法"><a href="#多级索引的数据累计方法" class="headerlink" title="多级索引的数据累计方法"></a>多级索引的数据累计方法</h2><p>对于层级索引数据，可以设置参数level实现对数据子集的累计操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.27.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要计算每一年的各项平均值，可以将参数level设置为索引year。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.28.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果再设置axis参数,就可以对列索引进行类似的累计操作了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.29.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="合并数据集：Concat与Append操作"><a href="#合并数据集：Concat与Append操作" class="headerlink" title="合并数据集：Concat与Append操作"></a>合并数据集：Concat与Append操作</h1><h2 id="使用pd-concat实现简易合并"><a href="#使用pd-concat实现简易合并" class="headerlink" title="使用pd.concat实现简易合并"></a>使用pd.concat实现简易合并</h2><p>Pandas有一个pd.concat()函数与 np. concatenate语法类似,但是配置参数更多,功能也更强大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.38.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>pd. concat()可以简单地合并一维的 Series或 Dataframe对象,与np. concatenate()合并数组一样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.39.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%883.39.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它也可以用来合并高维数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.02.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认情况下，DataFrame的合并都是逐行进行的（默认设置是axis=0）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.03.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里使用axis=1效果是一样的，但是用axis=‘col’会更直观。</p><h3 id="索引重复"><a href="#索引重复" class="headerlink" title="索引重复"></a>索引重复</h3><p>np. concatenate与pd. concat最主要的差异之一就是 Pandas在合并时会保留索引,即使索引是重复的!<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.06.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="捕捉索引重复的错误"><a href="#捕捉索引重复的错误" class="headerlink" title="捕捉索引重复的错误"></a>捕捉索引重复的错误</h4><p>可以设置verify_integrity参数为True，合并时若有索引重复就会触发异常。</p><h4 id="忽略索引"><a href="#忽略索引" class="headerlink" title="忽略索引"></a>忽略索引</h4><p>有时索引无关紧要，那么合并时就可以忽略它们，可以通过设置ignore_index参数来实现，如果参数设置为True，那么合并时会创建一个新的整数索引。</p><h4 id="增加多级索引"><a href="#增加多级索引" class="headerlink" title="增加多级索引"></a>增加多级索引</h4><p>另一种处理方法是通过keys参数为数据源设置多级索引标签。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%884.12.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>结果是多级索引的DataFrame。</p><h3 id="类似join的合并"><a href="#类似join的合并" class="headerlink" title="类似join的合并"></a>类似join的合并</h3><p>实际中，需要合并的数据往往不带有相同的列名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.37.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认下，某个位置上的缺失会用NaN表示。如果不想这样，可以用join和join_axes参数设置合并方式。默认的合并方式是对所有的输入列进行并集合并（join=‘outer’）,当然也可以用join=‘inner’实现对输入列的交集合并。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.40.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一种合并方式是直接确定结果使用的列名,设置 join_axes参数,里面是索引对象构成的列表(是列表的列表)。</p><h3 id="append-方法"><a href="#append-方法" class="headerlink" title="append()方法"></a>append()方法</h3><p>可以使用df1. append(df2),效果与pd. concat([df1,df2])一样。Pandas的 append()不直接更新原有对象的值,而是为合并后的数据创建一个新对象。因此,它不能被称之为一个非常高效的解决方案,因为每次合并都需要重新创建索引和数据缓存。总之,如果你需要进行多个 append操作,还是建议先创建一个 Dataframe列表,然后用 concat()函数一次性解决所有合并任务。</p><h1 id="合并数据集：合并与连接"><a href="#合并数据集：合并与连接" class="headerlink" title="合并数据集：合并与连接"></a>合并数据集：合并与连接</h1><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>pd. merge()实现的功能基于关系代数( relational algebra)的一部分关系代数是处理关系型数据的通用理论,绝大部分数据库的可用操作都以此为理论基础。</p><h2 id="数据连接的类型"><a href="#数据连接的类型" class="headerlink" title="数据连接的类型"></a>数据连接的类型</h2><h3 id="一对一连接"><a href="#一对一连接" class="headerlink" title="一对一连接"></a>一对一连接</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.48.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.48.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="多对一连接"><a href="#多对一连接" class="headerlink" title="多对一连接"></a>多对一连接</h3><p>多对一连接是指,在需要连接的两个列中,有一列的值有重复。通过多对一连接获得的结果 DataFrame将会保留重复值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%887.56.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="多对多连接"><a href="#多对多连接" class="headerlink" title="多对多连接"></a>多对多连接</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.02.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.02.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="设置数据合并的键"><a href="#设置数据合并的键" class="headerlink" title="设置数据合并的键"></a>设置数据合并的键</h2><h3 id="参数on的用法"><a href="#参数on的用法" class="headerlink" title="参数on的用法"></a>参数on的用法</h3><p>最简单的方法就是直接将参数on设置为一个列名字符串或者一个包含多列名称的列表。这个参数只能在两个 DataFrame有共同列名的时候才可以使用。</p><h3 id="left-on与right-on参数"><a href="#left-on与right-on参数" class="headerlink" title="left_on与right_on参数"></a>left_on与right_on参数</h3><p>有时你也需要合并两个列名不同的数据集,例如前面的员工信息表中有一个字段不是“ employee’,而是 name”。在这种情况下,就可以用left on和 right on参数来指定列名:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.08.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>获取的结果中会有一个多余的列,可以通过 Dataframe的drop()方法将这列去掉。</p><h3 id="left-index与right-index参数"><a href="#left-index与right-index参数" class="headerlink" title="left index与right index参数"></a>left index与right index参数</h3><p>除了合并列之外,你可能还需要合并索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.11.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="设置数据连接的集合操作规则"><a href="#设置数据连接的集合操作规则" class="headerlink" title="设置数据连接的集合操作规则"></a>设置数据连接的集合操作规则</h2><p>通过前面的示例,我们总结出数据连接的一个重要条件:集合操作规则。当一个值出现在一列,却没有出现在另一列时,就需要考虑集合操作规则了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.17.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以用how参数设置连接方式，默认值为‘inner’，还有‘outer’、‘left’和‘right’。</p><h2 id="重复列名：suffixes参数"><a href="#重复列名：suffixes参数" class="headerlink" title="重复列名：suffixes参数"></a>重复列名：suffixes参数</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.43.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于输出结果中有两个重复的列名,因此pd. merge()函数会自动为它们增加后缀_x或_y,当然也可以通过 suffixes参数自定义后缀名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.44.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>suffixes参数同样适用于任何连接方式,即使有三个及三个以上的重复列名时也同样适用。</p><h1 id="累计与分组"><a href="#累计与分组" class="headerlink" title="累计与分组"></a>累计与分组</h1><p>在对较大的数据进行分析时,一项基本的工作就是有效的数据累计( summarization):计算累计( aggregation)指标,如sum()、mean()、 median()、min()和max(),其中每一个指标都呈现了大数据集的特征。</p><h2 id="Pandas的简单累计功能"><a href="#Pandas的简单累计功能" class="headerlink" title="Pandas的简单累计功能"></a>Pandas的简单累计功能</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.47.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.48.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Pandas的 Series和 DataFrame支持所有24节中介绍的常用累计函数。另外,还有一个非常方便的 describe()方法可以计算每一列的若干常用统计值。</p><p><img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.50.19.png" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.50.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DataFrame和 Series对象支持以上所有方法。</p><h2 id="GroupBy-分割、应用和组合"><a href="#GroupBy-分割、应用和组合" class="headerlink" title="GroupBy:分割、应用和组合"></a>GroupBy:分割、应用和组合</h2><h3 id="分割、应用和组合"><a href="#分割、应用和组合" class="headerlink" title="分割、应用和组合"></a>分割、应用和组合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.53.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>GroupBy的用处就是将这些步骤进行抽象:用户不需要知道在底层如何计算,只要把操作看成一个整体就够了。</p><p>我们可以用 DataFrame的 groupby()方法进行绝大多数常见的分割-应用-组合操作,将需要分组的列名传进去即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%888.57.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要注意的是,这里的返回值不是一个 DataFrame对象,而是个 DataFrame GroupBy对象。这个对象的魔力在于,你可以将它看成是一种特殊形式的 DataFrame,里面隐藏着若干组数据,但是在没有应用累计函数之前不会计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.02.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>sum()只是众多可用方法中的一个。你可以用 Pandas或 NumPy的任意一种累计函数,也可以用任意有效的 DataFrame对象。</p><h3 id="GroupBy对象"><a href="#GroupBy对象" class="headerlink" title="GroupBy对象"></a>GroupBy对象</h3><p>GroupBy对象是一种非常灵活的抽象类型。在大多数场景中,你可以将它看成是 Dataframe的集合,在底层解决所有难题。</p><h4 id="按列取值"><a href="#按列取值" class="headerlink" title="按列取值"></a>按列取值</h4><p>GroupBy对象与 Dataframe一样,也支持按列取值,并返回一个修改过的 GroupBy对象。</p><p>这里从原来的 DataFrame中取某个列名作为一个 Series组。与GroupBy对象一样,直到我们运行累计函数,才会开始计算。</p><h4 id="按组迭代"><a href="#按组迭代" class="headerlink" title="按组迭代"></a>按组迭代</h4><p>GroupBy对象支持直接按组进行迭代,返回的每组都是 Series或 Dataframe。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.17.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>借助 Python类的魔力(@ classmethod),可以让任何不由 GroupBy对象直接实现的方法直接应用到每一组,无论是 Dataframe还是 Series对象都同样适用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.17.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="累计、过滤、转换和应用"><a href="#累计、过滤、转换和应用" class="headerlink" title="累计、过滤、转换和应用"></a>累计、过滤、转换和应用</h3><h4 id="累计"><a href="#累计" class="headerlink" title="累计"></a>累计</h4><p>aggregate()可以支持更复杂得操作。比如字符串、函数或者函数列表，并且能一次性计算所有累计值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.27.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.27.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一种用法是通过Python字典指定不同列需要累计的函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.28.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>过滤操作可以让呢按照分组的属性丢弃若干数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.59.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%889.59.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>累计操作返回的是对组内全量数据缩减过的结果,而转换操作会返回一个新的全量数据。数据经过转换之后,其形状与原来的输入数据是一样的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-30%20%E4%B8%8B%E5%8D%8810.00.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply()方法"></a>apply()方法</h4><p>apply()方法让你可以在每个组上应用任意方法。这个函数输入一个 DataFrame,返回一个 Pandas对象( Data Frame或 Series)或一个标量( scalar,单个数值)。</p><h3 id="设置分割的键"><a href="#设置分割的键" class="headerlink" title="设置分割的键"></a>设置分割的键</h3><h4 id="将列表、数组、Series或索引作为分组键"><a href="#将列表、数组、Series或索引作为分组键" class="headerlink" title="将列表、数组、Series或索引作为分组键"></a>将列表、数组、Series或索引作为分组键</h4><h4 id="用字典或Series将索引映射到分组名称"><a href="#用字典或Series将索引映射到分组名称" class="headerlink" title="用字典或Series将索引映射到分组名称"></a>用字典或Series将索引映射到分组名称</h4><h4 id="任意Python函数"><a href="#任意Python函数" class="headerlink" title="任意Python函数"></a>任意Python函数</h4><h4 id="多个有效键构成的列表"><a href="#多个有效键构成的列表" class="headerlink" title="多个有效键构成的列表"></a>多个有效键构成的列表</h4><h1 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h1><h1 id="向量化字符串操作"><a href="#向量化字符串操作" class="headerlink" title="向量化字符串操作"></a>向量化字符串操作</h1><h2 id="Pandas字符串操作简介"><a href="#Pandas字符串操作简介" class="headerlink" title="Pandas字符串操作简介"></a>Pandas字符串操作简介</h2><p>Pandas为包含字符串的 Series和 Index对象提供的str属性堪称两全其美的方法,它既可以满足向量化字符串操作的需求,又可以正确地处理缺失值。例如,我们用前面的数据data创建了一个 Pandas的Series。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.25.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以直接调用转换大写方法capitalize()将所有的字符串变成大写形式，缺失值会被跳过。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.27.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Pandas字符串方法列表"><a href="#Pandas字符串方法列表" class="headerlink" title="Pandas字符串方法列表"></a>Pandas字符串方法列表</h2><h3 id="与Python字符串方法相似的方法"><a href="#与Python字符串方法相似的方法" class="headerlink" title="与Python字符串方法相似的方法"></a>与Python字符串方法相似的方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.29.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意，这些方法的返回值不同。有的返回一个字符串Series，有的返回数值，有的返回布尔值，有的返回列表或其他复合值。</p><h3 id="使用正则表达式的方法"><a href="#使用正则表达式的方法" class="headerlink" title="使用正则表达式的方法"></a>使用正则表达式的方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.32.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.34.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>还可以用正则表达式中的开始符号（\^）与结尾符号（\$）来实现。能将正则表达式应用到Series与DataFrame之中的话，就有可能实现更多的数据分析与清洗方法。</p><h3 id="其他字符串方法"><a href="#其他字符串方法" class="headerlink" title="其他字符串方法"></a>其他字符串方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.36.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="处理时间序列"><a href="#处理时间序列" class="headerlink" title="处理时间序列"></a>处理时间序列</h1><p>Pandas最初是为金融模型而创建的，因此它拥有一些功能非常强大的日期、时间、带时间索引数据的处理工具。</p><p><strong>时间戳</strong>表示某个具体的时间点(例如2015年7月4日上午7点)。</p><p><strong>时间间隔与周期</strong>表示开始时间点与结束时间点之间的时间长度,例如2015年(指的是2015年1月1日至2015年12月31日这段时间间隔)。周期通常是指一种特殊形式的时间间隔,每个间隔长度相同,彼此之间不会重叠(例如,以24小时为周期构成每天）。</p><p><strong>时间增量</strong>( time delta)或<strong>持续时间</strong>( duration)表示精确的时间长度(例如,某程序运行持续时间2256秒)。</p><h2 id="Python的日期与时间工具"><a href="#Python的日期与时间工具" class="headerlink" title="Python的日期与时间工具"></a>Python的日期与时间工具</h2><h3 id="原生Python的日期与时间工具：datetime与dateutil"><a href="#原生Python的日期与时间工具：datetime与dateutil" class="headerlink" title="原生Python的日期与时间工具：datetime与dateutil"></a>原生Python的日期与时间工具：datetime与dateutil</h3><p>datetime和 dateuti1模块在灵活性与易用性方面都表现出色你可以用这些对象及其相应的方法轻松完成你感兴趣的任意操作但如果你处理的时间数据量比较大,那么速度就会比较慢。就像之前介绍过的 Python的原生列表对象没有 NumPy中已经被编码的数值类型数组的性能好一样, Python的原生日期对象同样也没有NumPy中已经被编码的日期( encoded dates)类型数组的性能好。</p><h3 id="时间类型数组：NumPy的datetime64类型"><a href="#时间类型数组：NumPy的datetime64类型" class="headerlink" title="时间类型数组：NumPy的datetime64类型"></a>时间类型数组：NumPy的datetime64类型</h3><p>Python原生日期格式的性能弱点促使 NumPy团队为 NumPy增加了自己的时间序列类型。 datetime64类型将日期编码为64位整数,这样可以让日期数组非常紧凑(节省内存)。datetime64需要在设置日期时确定具体的输入类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%885.53.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>只要有了这个日期格式，就可以快速的向量化运算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.00.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>虽然 datetime64弥补了 Python原生的datetime类型的不足,但它缺少了许多 datetime(尤其是dateutil)原本具备的便捷方法与函数。</p><h3 id="Pandas的日期与时间工具：理想与现实的最佳解决方案"><a href="#Pandas的日期与时间工具：理想与现实的最佳解决方案" class="headerlink" title="Pandas的日期与时间工具：理想与现实的最佳解决方案"></a>Pandas的日期与时间工具：理想与现实的最佳解决方案</h3><p>Pandas所有关于日期与时间的处理方法全部都是通过 Timestamp对象实现的,它利用 numpy. datetime64的有效存储和向量化接口将 datetime和 dateutil的易用性有机结合起来。 Pandas通过一组 Timestamp对象就可以创建一个可以作为 Series或DataFrame索引的 Datetimelndex。</p><h2 id="Pandas时间序列：用时间作索引"><a href="#Pandas时间序列：用时间作索引" class="headerlink" title="Pandas时间序列：用时间作索引"></a>Pandas时间序列：用时间作索引</h2><p>Pandas时间序列工具非常适合用来处理带时间戳的索引数据。我们可以通过一个时间索引数据创建一个 Series对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.11.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了一个带时间索引的Series之后,就能用它来演示之前介绍过的Series取值方法,可以直接用日期进行切片取值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.12.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另外,还有一些仅在此类 Series上可用的取值操作,例如直接通过年份切片获取该年的数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.14.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Pandas时间序列数据结构"><a href="#Pandas时间序列数据结构" class="headerlink" title="Pandas时间序列数据结构"></a>Pandas时间序列数据结构</h2><ol><li>针对时间戳数据, Pandas提供了 Timestamp类型。与前面介绍的一样,它本质上是 Python的原生 datetime类型的替代品,但是在性能更好的 numpy.datetime64类型的基础上创建。对应的索引数据结构是Datetimeindex。</li><li>针对时间周期数据, Pandas提供了 Period类型。这是利用numpy. datetime64类型将固定频率的时间间隔进行编码。对应的索引数据结构是 Periodindex。</li><li>针对时间增量或持续时间, Pandas提供了 Timedelta类型。Timedelta是一种代替 Python原生 datetime, timedelta类型的高性能数据结构,同样是基于 numpy. timedelta64类型。对应的索引数据结构是 Timedeltaindex。</li></ol><p>最基础的日期/时间对象是 Timestamp和 Datetimeindex。这两种对象可以直接使用,最常用的方法是pd.to_datetime()函数,它可以解析许多日期与时间格式。对pd.to_datetime()传递一个日期会返回一个 Timestamp类型,传递一个时间序列会返回一个Datetimelndex类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.24.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.25.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>任何Datetimeindex类型都可以通过to_ period()方法和一个频率代码转换成 Periodindex类型。下面用‘D’将数据转换成单日的时间序列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.25.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当用一个日期减去另一个日期时,返回的结果是 Timedeltaindex类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.26.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有规律的时间序列：<strong>pd.date_range()</strong>。</p><p>为了能更简便地创建有规律的时间序列, Pandas提供了一些方法:pd.daterange()可以处理时间戳、pd. period range()可以处理周期、pd.timedelta range()可以处理时间间隔。我们已经介绍过, Python的 range()和NumPy的 np.arange()可以用起点、终点和步长(可选的)创建一个序列。pd.daterange()与之类似,通过开始日期、结束日期和频率代码(同样是可选的)创建一个有规律的日期序列,默认的频率是天。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.42.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此外,日期范围不一定非是开始时间与结束时间,也可以是开始时间与周期数periods。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.43.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>你可以通过freq参数改变时间间隔,默认值是D。例如,可以创建个按小时变化的时间戳。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.43.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要创建一个有规律的周期或时间间隔序列,有类似的函数pd.period_range()和pd. timedelta_range()。下面是一个以月为周期的示例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.46.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一个以小时递增的序列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.46.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="时间频率与偏移量"><a href="#时间频率与偏移量" class="headerlink" title="时间频率与偏移量"></a>时间频率与偏移量</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.48.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.48.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.49.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以在频率代码后面加三位月份缩写字母来改变季、年频率的开始时间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.52.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以将频率组合起来创建新的周期。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%886.53.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="重新取样、迁移和窗口"><a href="#重新取样、迁移和窗口" class="headerlink" title="重新取样、迁移和窗口"></a>重新取样、迁移和窗口</h2><h3 id="重新取样与频率转换"><a href="#重新取样与频率转换" class="headerlink" title="重新取样与频率转换"></a>重新取样与频率转换</h3><p>处理时间序列数据时,经常需要按照新的频率(更高频率、更低频率)对数据进行重新取样。你可以通过 resample()方法解决这个问题,或者用更简单的 asfreq()方法。这两个方法的主要差异在于, resample()方法是以数据累计( data aggregation)为基础,而 asfreq()方法是以数据选择( data selection)为基础。</p><h3 id="时间迁移"><a href="#时间迁移" class="headerlink" title="时间迁移"></a>时间迁移</h3><p>一种常用的时间序列操作时对数据按时间进行迁移。Pandas有两种解决这类问题的方法：shift()和tshift()。简单来说，shift（）就是迁移数据，而tshift（）就是迁移索引。两种方法都是按照频率代码进行迁移。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%887.38.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>shift（900）将数据向前推进了900天，而tshift(900)将时间索引向前推进了900天。</p><h3 id="移动时间窗口"><a href="#移动时间窗口" class="headerlink" title="移动时间窗口"></a>移动时间窗口</h3><h1 id="高性能-Pandas-eval-与-query"><a href="#高性能-Pandas-eval-与-query" class="headerlink" title="高性能 Pandas:eval()与 query()"></a>高性能 Pandas:eval()与 query()</h1><h2 id="query-与eval-的设计动机-复合代数式"><a href="#query-与eval-的设计动机-复合代数式" class="headerlink" title="query()与eval()的设计动机:复合代数式"></a>query()与eval()的设计动机:复合代数式</h2><p>NumPy与Pandas都支持快速的向量化运算。</p><h2 id="用pandas-eval-实现高性能运算"><a href="#用pandas-eval-实现高性能运算" class="headerlink" title="用pandas.eval()实现高性能运算"></a>用pandas.eval()实现高性能运算</h2><p>Pandas的eval()函数用字符串代数式实现了 DataFrame的高性能运算。eval()版本的代数式比普通方法快一倍（而且内存消耗更少），结果也是一样的。</p><h3 id="pd-eval-支持的运算"><a href="#pd-eval-支持的运算" class="headerlink" title="pd.eval()支持的运算"></a>pd.eval()支持的运算</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>pd.eval()支持所有的算术运算符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.06.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>pd.eval()支持所有的比较运算符,包括链式代数式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.06.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.06.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="对象属性与索引"><a href="#对象属性与索引" class="headerlink" title="对象属性与索引"></a>对象属性与索引</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.07.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h4><p>目前pd.eval()还不支持函数调用、条件语句、循环以及更复杂的运算。如果你想要进行这些运算,可以借助 Numexpr来实现。</p><h2 id="用-DataFrame-eval-实现列间运算"><a href="#用-DataFrame-eval-实现列间运算" class="headerlink" title="用 DataFrame.eval()实现列间运算"></a>用 DataFrame.eval()实现列间运算</h2><p>由于 pd. eval()是 Pandas的顶层函数,因此 Dataframe有一个eval()方法可以做类似的运算。使用eval()方法的好处是可以借助列名称进行运算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.13.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.14.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>Dataframe.eval()方法可以通过列名称实现简洁的代数式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.15.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="用-DataFrame-eval-新增列"><a href="#用-DataFrame-eval-新增列" class="headerlink" title="用 DataFrame. eval()新增列"></a>用 DataFrame. eval()新增列</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.18.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.18.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Dataframe-eval-使用局部变量"><a href="#Dataframe-eval-使用局部变量" class="headerlink" title="Dataframe.eval()使用局部变量"></a>Dataframe.eval()使用局部变量</h3><p>Dataframe.eval()方法还支持通过@符号使用 Python的局部变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.20.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>@符号表示“这是一个变量名称而不是一个列名称”,从而让你灵活地用两个“命名空间”的资源(列名称的命名空间和 Python对象的命名空间)计算代数式。需要注意的是,@符号只能在Dataframe.eval()方法中使用,而不能在 pandas.eval()函数中使用,因为 pandas. eval()函数只能获取一个( Python)命名空间的内容。</p><h2 id="DataFrame-query-方法"><a href="#DataFrame-query-方法" class="headerlink" title="DataFrame.query()方法"></a>DataFrame.query()方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.44.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>除了计算性能更优以外，这种方法的语法也比掩码代数式语法更好理解。需要注意的是，query()方法也支持@符号引用局部变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.46.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="性能决定使用时机"><a href="#性能决定使用时机" class="headerlink" title="性能决定使用时机"></a>性能决定使用时机</h2><p>在考虑要不要用这两个函数时,需要思考两个方面:计算时间和内存消耗,而内存消耗是更重要的影响因素。就像前面介绍的那样,每个涉及NumPy数组或Pandas的 DataFrame的复合代数式都会产生临时数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C%20Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-31%20%E4%B8%8B%E5%8D%888.50.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果临时 DataFrame的内存需求比你的系统内存还大(通常是几吉字),那么最好还是使用eval()和 query()代数式。</p><p>在性能方面，即使没有使用最大的系统内存，eval（）的计算速度也比普通方法快。在实际工作中,我发现普通的计算方法与eval/ query计算方法在计算时间上的差异并非总是那么明显,普通方法在处理较小的数组时反而速度更快!eval/ query方法的优点主要是节省内存,有时语法也更加简洁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pandas是在NumPy基础上建立的新程序库,提供了一种高效的 DataFrame数据结构。 DataFrame本质上是一种带行标签和列标签、支持相同类型数据和缺失值的多维数组。 Pandas不仅为带各种标签的数据提供了便利的存储界面,还实现了许多强大的操作,这些操作对数
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer  面试的流程</title>
    <link href="https://github.com/zdkswd/2018/10/28/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/10/28/剑指offer  面试的流程/</id>
    <published>2018-10-28T08:16:12.000Z</published>
    <updated>2018-10-28T08:17:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试的三种形式"><a href="#面试的三种形式" class="headerlink" title="面试的三种形式"></a>面试的三种形式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%885.49.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="电话面试"><a href="#电话面试" class="headerlink" title="电话面试"></a>电话面试</h3><p>与现场面试最大的区别就是应聘者见不到面试官，双方的沟通只能依靠声音。很多外企在电话面试时都会加上英语面试的环节，甚至有些公司全部面试都会用英语进行。对应聘者的听力提出了更高的要求。如果在面试的时候没有听清楚或听懂面试官的问题，千万不要不懂装懂答非所问，这是面试的大忌。当不确定面试官的问题时，一定要大胆的多提问，直到弄清楚面试官的意图为止。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%885.55.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="共享桌面远程面试"><a href="#共享桌面远程面试" class="headerlink" title="共享桌面远程面试"></a>共享桌面远程面试</h3><p>目前只有为数不多的几家大公司会在邀请应聘者到公司参加现场面试前，先进行一两轮共享桌面的远程面试。面试最关心的是应聘者的编程习惯及调试能力。通常面试官认可的习惯：</p><ol><li>思考清楚再开始编程。</li><li>良好的代码命名和缩进对齐习惯。</li><li>更够<strong>单元测试</strong>。通常面试官出的题目都是要求写函数解决某一问题,如果应聘者能够在定义函数之后,立即对该函数进行全面的单元测试,那就相当于向面试官证明了自己有着专业的软件开发经验。如果应聘者是<strong>先写单元测试用例</strong>,再写解决问题的函数,我相信面试官定会对你刮目相看,因为能做到测试在前、开发在后的程序员实在是太稀缺了,他会毫不犹豫地抛出绿色的橄榄枝。</li></ol><p>通常我们在写代码的时候都会遇到问题。当应聘者运行代码发现结果不对之后的表现,也是面试官关注的重点,因为应聘者此时的反应、采取的措施都能体现出他的<strong>调试功底</strong>。如果应聘者能够熟练地<strong>设置断点</strong>、<strong>单步跟踪</strong>、<strong>查看内存</strong>、<strong>分析调用栈</strong>,能很快发现问题的根源并最终解决问题,那么面试官将会觉得他的开发经验很丰富。调试能力是在书本上学不到的只有通过大量的软件开发实践才能积累出调试技巧。当面试官发现一个应聘者的调试功底很扎实的时候,他在写面试报告的时候是不会吝啬赞美之词的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.04.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="现场面试"><a href="#现场面试" class="headerlink" title="现场面试"></a>现场面试</h3><p>在通过上述两个面试后，就会进行现场面试，应当做好以下准备：</p><ol><li>规划好路线并估算出行时间，不迟到。</li><li>准备好得体的衣服，没有必要穿正装。</li><li>注意面试邀请函的面试流程。如果面试有好几轮，时间也很长，在面试过程中可能会觉得疲劳并思维变得迟钝。比如微软对技术职位通常有五论面试，连续几个小时处在高压的面试中，人难免会变得精疲力尽，因此可以带一些提神的饮料或食品。</li><li>准备几个问题。每一轮面试的最后，面试官都会让应聘者问几个问题，应聘者可以提前准备好问题。</li></ol><p>现场面试时整个面试流程中的重头戏。由于是坐在面试官的对面，应聘者的一举一动都看在面试官的眼力。面试官通过应聘者的语言和行动，考查他的<strong>沟通能力</strong>、<strong>学习能力</strong>、<strong>编程能力</strong>等综合实力。</p><h2 id="现场面试的三个环节"><a href="#现场面试的三个环节" class="headerlink" title="现场面试的三个环节"></a>现场面试的三个环节</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.19.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="行为面试环节"><a href="#行为面试环节" class="headerlink" title="行为面试环节"></a>行为面试环节</h3><p>面试开始的5~10分钟通常是行为面试的时间。在行为面试这个环节里,面试官会注意应聘者的性格特点,深入地了解简历中列举的项目经历。由于这一环节一般不会问技术难题,因此也是一个暖场的过程,应聘者可以利用这几分钟时间调整自己的情绪,进入面试的状态。</p><p>不少面试官会让应聘者做一个简短的自我介绍。由于面试官手中拿着应聘者的简历,而那里有应聘者的详细信息,因此此时的自我介绍不用花很多时间,用30秒到1分钟的时间介绍自己的主要学习、工作经历就即可如果面试官对你的某一段经历或者参与的某一个项目很感兴趣,他会有针对性地提几个问题详细了解。</p><h4 id="简历中应聘者的项目经验"><a href="#简历中应聘者的项目经验" class="headerlink" title="简历中应聘者的项目经验"></a>简历中应聘者的项目经验</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.26.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li><strong>Situation:简短的项目背景</strong>，比如项目的规模，开发的软件的功能、目标用户等。</li><li><strong>Task：自己完成的任务</strong>。这个要写<strong>详细</strong>，要让面试官对自己的工作一目了然。在用词上要注意区分“参与”和“负责”:如果只是加入某一个开发团队写了几行代码就用“负责”,那就很危险。面试官看到简历上应聘者“负责”了某个项目,他可能就会问项目的总体框架设计、核心算法、团队合作等问题。这些问题对于只是简单参与”的人来说,是很难回答的,会让面试官认为你不诚实,印象分会减去很多。</li><li><strong>Action：为了完成任务自己做了哪些工作，是怎么做的。</strong>这里可以<strong>详细</strong>介绍。做系统设计的,可以介绍系统架构的特点;做软件开发的,可以写基于什么工具在哪个平台下应用了哪些技术;做软件测试的,可以写是手工测试还是自动化测试,是白盒测试还是黑盒测试等。</li><li><strong>Result：自己的贡献。</strong>这些方面信息可以写得具体些，最好能用数字加以说明。如果是参与功能开发,可以说按时完成了多少功能;如果做优化,可以说性能提高的百分比是多少;如果是维护,可以说修改了多少个Bug。</li></ol><p>举例：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.36.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.37.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.37.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="应聘者掌握的技能，了解，熟悉，精通"><a href="#应聘者掌握的技能，了解，熟悉，精通" class="headerlink" title="应聘者掌握的技能，了解，熟悉，精通"></a>应聘者掌握的技能，了解，熟悉，精通</h4><p><strong>了解</strong>：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.41.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>熟悉：</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.43.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>精通：</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%886.43.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="回答“为什么跳槽”"><a href="#回答“为什么跳槽”" class="headerlink" title="回答“为什么跳槽”"></a>回答“为什么跳槽”</h4><p>面试官只是想通过这个问题来了解应聘者的性格，可以根据自己的真实想法来回答这个问题但也不能想说什么就说什么，回答这个问题时不要抱怨，也不要流露出负面的情绪。应当尽量避免以下4个原因：</p><ol><li><strong>老板太苛刻。</strong></li><li><strong>同事太难相处。</strong>面试官可能会觉得这个人本身就很难相处。</li><li><strong>加班太频繁。</strong>对于大部分IT企业来说，加班是家常便饭。这么说等于不想进这家公司。</li><li><strong>工资太低。</strong>不建议在面试的时候对面试官抱怨，等完成技术面试之后谈offer时，再和HR谈工资也不迟。通过面试后我们就掌握主动了，想怎么谈就怎么谈，如果工资真的开高了HR会和你很客气地商量的。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.04.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.04.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><h3 id="技术面试环节"><a href="#技术面试环节" class="headerlink" title="技术面试环节"></a>技术面试环节</h3><p>面试官在通过简历及行为面试大致了解应聘者的背景之后，接下来就要开始技术面试了。一轮1小时的面试，通常技术面试会占40-50分钟，这是面试的重头戏，对面试的结果起决定性作用。总体面试官会关注应聘者5种素质：<strong>扎实的基础知识、能写高质量的代码、分析问题思路清晰、能优化时间和空间效率，以及学习沟通等各方面的能力。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.08.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="扎实的基础知识"><a href="#扎实的基础知识" class="headerlink" title="扎实的基础知识"></a>扎实的基础知识</h4><p>基本功在编程面试环节体现在三个方面：编程语言、数据结构和算法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.11.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.11.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.12.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="高质量的代码"><a href="#高质量的代码" class="headerlink" title="高质量的代码"></a>高质量的代码</h4><p>只有注重质量的程序员,才能写出鲁棒稳定的大型软件。在面试过程中,面试官总会格外关注<strong>边界条件</strong>、<strong>特殊输入</strong>等看似细枝末节但实质至关重要的地方,以考查应聘者是否注重代码质量。很多时候,面试官发现应聘者写出来的代码只能完成最基本的功能,一旦输入特殊的边界条件参数就会错误百出甚至程序崩溃。</p><p>总有些应聘者很困惑:面试的时候觉得题目很简单,感觉自己都做出来了,可最后为什么被拒了呢?在技术面试过程中,技术面试的面试官一般都是程序员,他们只认一个理:题目做对、做完整了,就让你通过面试;否则失败。所以遇到简单题目却被拒的情况,应聘者应认真反思在思路或者代码中存在哪些漏洞。</p><p>通常越是简单的问题，面试官的期望值就会越高。如果题目很简单，面试官会期待应聘者能够很<strong>完整</strong>的解决问题。除了完成基本功能以外，还要考虑到边界条件、错误处理等各个方面。还要考虑程序是否足够鲁棒。</p><p>要想很好地解决前面的问题,最好的办法是在动手写代码之后想好<strong>测试用例</strong>。只有把各种可能的输入事先都想好了,才能在写代码的时候把各种情况都做相应的处理。写完代码之后,也不要立刻给面试官检查,而是先在心里默默地运行。当输入之前想好的所有测试用例都能得到合理的输出时,再把代码交给面试官。做到了这一步,offer就很简单了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.39.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="清晰的思路"><a href="#清晰的思路" class="headerlink" title="清晰的思路"></a>清晰的思路</h4><p>对于确实很复杂的问题，面试官甚至不期待应聘者能在面试不到一个小时的时间里给出完整的答案，更看重的可能还是应聘者是否有清晰的思路。面试官通常不喜欢应聘者在没有形成清晰思路之前就草率地开始写代码，这样写出来的代码容易逻辑混乱、错误百出。</p><p>应聘者可以用几个简单的方法帮助自己形成清晰的思路。<br>首先是举几个简单的具体例子让自己理解问题。当我们一眼看不出问题中隐藏的规律的时候,可以试着用一两个具体的例子模拟操作的过程,这样说不定就能通过具体的例子找到抽象的规律。<br>其次可以试着用图形表示抽象的数据结构。像分析与链表、二叉树相关的题目,我们都可以画出它们的结构来简化题目。<br>最后可以试着把复杂的问题分解成若干个简单的子问题,再解决。很多基于递归的思路,包括分治法和动态规划,都是把复杂的问题分解成一个或者多个简单的子问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%887.47.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="优化效率的能力"><a href="#优化效率的能力" class="headerlink" title="优化效率的能力"></a>优化效率的能力</h4><p>优秀的程序员对时间和内存的消耗锱铢必较,他们很有激情地不断优化自己的代码。当面试官出的题目有多种解法的时候,通常他会期待应聘者最终能够找到最优解。当面试官提示还有更好的解法的时候,应聘者不能放弃思考,而应该努力寻找在时间消耗或者空间消耗上可以优化的地方。</p><p>要想优化时间或者空间效率,首先要知道如何分析效率。即使是同一个算法,用不同方法实现的效率可能也会大不相同,我们要能够分析出算法及其代码实现的效率。</p><p>要想优化代码的效率,我们还要熟知各种数据结构的优缺点,并能选择合适的数据结构解决问题。</p><p>要想优化代码的效率,我们也要熟练掌握常用的算法。面试中最常用的算法是査找和排序。</p><h4 id="优秀的综合能力"><a href="#优秀的综合能力" class="headerlink" title="优秀的综合能力"></a>优秀的综合能力</h4><p>除了展示自己的编程能力和技术功底之外，还需要展示自己的软能力，诸如自己的<strong>沟通能力</strong>和<strong>学习能力</strong>。软件开发已经告别了单打独斗的年代，程序员与他人的沟通变得越来越重要。<strong>知识迁移</strong>能力是一种特殊的学习能力。如果我们能够把已经掌握的知识迁移到其他领域，那么学习新技术或者解决新问题就会变得容易。还有些面试官喜欢考察应聘者的抽象建模能力和发散思维能力。</p><h3 id="应聘者提问环节"><a href="#应聘者提问环节" class="headerlink" title="应聘者提问环节"></a>应聘者提问环节</h3><p>在结束面试前的5-10分钟，面试官会给应聘者机会提几个问题，应聘者的问题质量也会对面试的结果有一定的影响。面试官让应聘者问几个问题，主要是想了解他最关心的问题有哪些，因此应聘者至少要问一两个问题。问得问题合适，是加分项，问的问题不合适，那就是减分项。</p><p>有些问题是不适合在技术面试这个环节问的。首先，不要问和自己职位没有关系的问题。比如面试职位是一线的开发问公司五年的发展战略。其次是不要问薪水，技术面试不是谈薪水的时候，要谈工资要等通过面试后和HR谈。再次是不要立即打听面试结果，现在大部分公司面试都有好几轮，最终决定应聘者能不能通过面试，是要把面试官的评价综合起来的，问这个等于白问。还会让人觉得没有自我评价的能力。</p><p>推荐问的问题是与招聘的职位或者与项目相关的问题，如果这种类的问题问的很好，就加分。不过要问好这类的问题首先应聘者应对应聘的职位或项目的背景有一定的了解。可以从两方面去了解。一是面试前做足功课，到网上去搜集相关的信息，做到对公司成立时间、主要业务、职位要求都了解。二是在面试过程中留意面试官说过的话。有不少面试官在面试前会简单介绍与招聘职位相关的项目，其中会包含其他渠道无法获得的信息，比如项目的进展情况等，可以从中找出一两个点，然后向面试官提问。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%89%91%E6%8C%87offer%20%20%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-24%20%E4%B8%8B%E5%8D%888.20.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试的三种形式&quot;&gt;&lt;a href=&quot;#面试的三种形式&quot; class=&quot;headerlink&quot; title=&quot;面试的三种形式&quot;&gt;&lt;/a&gt;面试的三种形式&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div cl
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="offer" scheme="https://github.com/zdkswd/tags/offer/"/>
    
  </entry>
  
  <entry>
    <title>Python数据科学手册 NumPy入门</title>
    <link href="https://github.com/zdkswd/2018/10/28/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/"/>
    <id>https://github.com/zdkswd/2018/10/28/Python数据科学手册/</id>
    <published>2018-10-28T07:00:56.000Z</published>
    <updated>2018-10-28T07:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python数据科学手册-NumPy入门"><a href="#Python数据科学手册-NumPy入门" class="headerlink" title="Python数据科学手册 NumPy入门"></a>Python数据科学手册 NumPy入门</h1><p>数据集的来源与格式都十分丰富，比如文档集合、图像集合、声音片段集合、数值数据集合，等等。这些数据虽然存在明显的异构性，但是将所有数据简单地看作数字数组非常有助于我们理解和处理数据。</p><p>例如，可以将图像（尤其是数字图像）简单地看作二维数字数组，这些数字数组代表各区域的像素值；声音片段可以看做时间和强度的一维数组；文本也可以通过各种方式转化为数值表示，一种可能的转换时用二进制数表示特定单词或单词对出现的频率。不管数据是何种形式，第一步都是将这些数据转化为数值叔祖形式的可分析数据。</p><p>正因如此，有效地存储和操作数值数组是数据科学中绝对的基础过程。NumPy(Numerical Python的简称)提供了高效3存储和操作密集数据缓存的接口。</p><h1 id="理解Python中的数据类型"><a href="#理解Python中的数据类型" class="headerlink" title="理解Python中的数据类型"></a>理解Python中的数据类型</h1><p>Python的类型灵活性指出了一个事实：Python变量不仅是它们的值，还包括了关于值得类型的一些额外信息。</p><h2 id="Python整型不仅仅是一个整型"><a href="#Python整型不仅仅是一个整型" class="headerlink" title="Python整型不仅仅是一个整型"></a>Python整型不仅仅是一个整型</h2><p>标准的Python实现是用C语言编写的。这意味着每一个Python对象都是一聪明的伪C语言结构体，该结构体不仅包含其值，还有其他信息。例如当我们在Python中定义一个整型，x=10000时，x并不是一个‘原生’整型，而是一个指针，指向一个C语言的复合结构体，结构体里包含了一些值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%882.47.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%882.48.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这意味着与C语言这样的编译语言的整型相比，在python中存储一个整型会有一些开销。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%882.51.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里PyObject_HEAD是结构体中包含引用计数、类型编码和其他之前提到的内容的部分。</p><p>两者的差异在于，C语言整型本质上是对应某个内存位置的标签，里面存储的字节会编码成整型。而Python的整型其实是一个指针，指向包含这个Python对象所有信息的某个内存位置，其中包括可以转换成整型的字节。由于Python的整型结构体中还包含了大量额外的信息，所以Python可以自由、动态地编码，但是Python类型中的这些额外信息也会成为负担，在多个对象组合的结构体中尤其明显。</p><h2 id="Python列表不仅仅是一个列表"><a href="#Python列表不仅仅是一个列表" class="headerlink" title="Python列表不仅仅是一个列表"></a>Python列表不仅仅是一个列表</h2><p>python中的标准可变多元素容器是列表。为了获得这些灵活的类型，列表中每一项必须包含各自的类型信息、引用计数和其他信息。也就是每一项都是一个完整的Python对象。python的列表甚至可以是异构的，即每项的类型可以不同。如果列表中的所有变量都是同一类型的，那么很多信息会显得多余—将数据存储在固定类型的数组应该会更高效。动态类型的列表和固定类型（NumPy式）数组的区别。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.06.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在实现层面,数组基本上包含一个指向连续数据块的指针。另一方面,Python列表包含一个指向指针块的指针,这其中的每一个指针对应一个完整的 Python对象(如前面看到的 Python整型)。另外,列表的优势是灵活,因为每个列表元素是一个包含数据和类型信息的完整结构体,而且列表可以用任意类型的数据填充。固定类型的 NumPy式数组缺乏这种灵活性,但是能更有效地存储和操作数据。</p><h2 id="Python中固定类型数组"><a href="#Python中固定类型数组" class="headerlink" title="Python中固定类型数组"></a>Python中固定类型数组</h2><p>Python提供了几种将数据存储在有效的、固定类型的数据缓存中的选项。内置的数组( array)模块(在 Python3.3之后可用)可以用于创建统一类型的密集数组:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.15.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.16.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="从Python列表创建数组"><a href="#从Python列表创建数组" class="headerlink" title="从Python列表创建数组"></a>从Python列表创建数组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.17.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最后，不同于Python列表，NumPy数组可以被指定为多维的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.19.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="从头创建数组"><a href="#从头创建数组" class="headerlink" title="从头创建数组"></a>从头创建数组</h2><p>面对大型数组的时候，用NumPy内置的方法从头创建数组是一种更高效的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.26.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.31.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="NumPy标准数据类型"><a href="#NumPy标准数据类型" class="headerlink" title="NumPy标准数据类型"></a>NumPy标准数据类型</h2><p>NumPy数组包含同一类型的值，因此详细了解这些数据类型及其限制是非常重要的。因为NumPy是在C语言的基础上开发的，所以c的用户会比较熟悉这些数据类型。</p><p>当构建一个数组时，你可以用一个字符串参数来指定数据类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.34.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.45.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%883.45.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以进行更高级的数据类型指定，例如指定高位字节数或低位字节数。</p><h1 id="NumPy数组基础"><a href="#NumPy数组基础" class="headerlink" title="NumPy数组基础"></a>NumPy数组基础</h1><p>python中的数据操作几乎等同于NumPy数组操作，甚至新出现的Pandas工具也是构建在NumPy数组基础上的。</p><h2 id="NumPy数组的属性"><a href="#NumPy数组的属性" class="headerlink" title="NumPy数组的属性"></a>NumPy数组的属性</h2><p>我们将用NumPy的随机数生成器设置一组种子值，以确保每次程序执行时都可以生成同样的随机数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%884.14.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>每个数组有nidm(维度)、shape(数组每个维度的大小)和size(数组的大小)属性：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%884.18.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一个有用的属性时dtype,它是数组的数据类型。其他的属性包括每个数组元素字节的大小itemsize,以及表示数组总字节大小的属性nbytes。可以认为nbytes跟itemsize和size的乘积大小相等。</p><h2 id="数组索引：获取单个元素"><a href="#数组索引：获取单个元素" class="headerlink" title="数组索引：获取单个元素"></a>数组索引：获取单个元素</h2><p>NumPy中可以通过中括号指定索引获取第i个值（从0开始计数），为了获取数组的末尾索引，可以用负值索引，在多维数组中，可以用逗号分隔的索引元组获取元素。也可以用以上索引方式修改元素值。注意：和Python列表不同，NumPy数组是固定类型的。这意味着当试图将一个浮点值插入一个整型数组时，浮点值会被截断成整型，并且是自动完成的。</p><h2 id="数组切片：获取子数组"><a href="#数组切片：获取子数组" class="headerlink" title="数组切片：获取子数组"></a>数组切片：获取子数组</h2><p>可以用切片（slice）符号获取子数组，切片符号用冒号（：）表示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%884.43.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.16.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.17.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多维子数组"><a href="#多维子数组" class="headerlink" title="多维子数组"></a>多维子数组</h2><p>多维切片也采用同样的方式处理，用冒号分隔。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.25.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>子数组维度也可以同时被逆序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.26.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="获取数组的行和列"><a href="#获取数组的行和列" class="headerlink" title="获取数组的行和列"></a>获取数组的行和列</h2><p>一种常见的需求是获取数组的单行和单列。你可以将索引与切片组合起来实现这个功能。用一个冒号（：）表示空切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.28.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在获取行时，出于语法的简介考虑，可以省略空的切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.30.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%886.30.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="非副本视图的子数组"><a href="#非副本视图的子数组" class="headerlink" title="非副本视图的子数组"></a>非副本视图的子数组</h2><p>关于数组切片有一点很重要也非常有用,那就是数组切片返回的是数组数据的视图,而不是数值数据的副本。这一点也是 NumPy数组切片和 Python列表切片的不同之处:在 Python列表中,切片是值的副本。这种默认的处理方式实际上非常有用：它意味着在处理非常大的数据集时，可以获取或处理这些数据集的片段，而不用复制底层的数据缓存。</p><h2 id="创建数组的副本"><a href="#创建数组的副本" class="headerlink" title="创建数组的副本"></a>创建数组的副本</h2><p>尽管数组视图有一些非常好的特性，但是在有些时候明确地复制数组里的数据或子数组也是非常有用的。可以简单地通过copy（）方法实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%889.36.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果修改这个子数组，原始的数值不会被改变。</p><h2 id="数组的变形"><a href="#数组的变形" class="headerlink" title="数组的变形"></a>数组的变形</h2><p>数组变形最灵活的实现方式是通过reshape()函数来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%889.39.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果希望该方法可行，那么原始数组的大小必须和变形后数组的大小一致。如果满足条件reshape方法将会用到原始数组的一个非副本视图。但实际是，在非连续的数据缓存下，返回非副本视图往往不可能实现。</p><p>一个常见的变形模式是将一个一位数组转变为二维的行或列的矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8B%E5%8D%889.53.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数组拼接和分裂"><a href="#数组拼接和分裂" class="headerlink" title="数组拼接和分裂"></a>数组拼接和分裂</h2><h3 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h3><p>拼接或连接NumPy中的两个数组主要由np.concatenate、np.vstack和np.hstack例程实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以一次拼接两个以上数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.00.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>np.concatentate也可以由于二维数组的拼接。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.02.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>沿着固定维度处理数组时，使用np.vstack(垂直栈)和np.hstack(水平栈)函数会更简洁。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.04.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与之类似，np.dstack将沿着第三个维度拼接数组。</p><h3 id="数组的分裂"><a href="#数组的分裂" class="headerlink" title="数组的分裂"></a>数组的分裂</h3><p>分裂可以通过np.split、np.hsplit和np.vsplit函数来实现。可以转递一个索引列表作为参数，索引列表记录的是分裂点位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.09.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>n分裂点会得到n+1个子数组。np.hsplit和np.vsplit的用法也类似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.11.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同样，np.dspliy将数组沿着第三个维度分裂。</p><h1 id="NumPy数组的计算：通用函数"><a href="#NumPy数组的计算：通用函数" class="headerlink" title="NumPy数组的计算：通用函数"></a>NumPy数组的计算：通用函数</h1><h2 id="缓慢的循环"><a href="#缓慢的循环" class="headerlink" title="缓慢的循环"></a>缓慢的循环</h2><p>Python的默认实现(被称作 CPython)处理起某些操作时非常慢,一部分原因是该语言的动态性和解释性—数据类型灵活的特性决定了序列操作不能像C语言和 Fortran语言一样被编译成有效的机器码。目前,有一些项目试图解决 Python这一弱点,比较知名的包括:PyPy项目一个实时的 Python编译实现; Cython项目,将 Python代码转换成可编译的C代码;Nuba项目,将 Python代码的片段转换成快速的LLⅴM字节码。以上这些项目都各有其优势和劣势,但是比较保守地说,这些方法中还没有一种能达到或超过标准 CPython引擎的受欢迎程度。</p><p>Python的相对缓慢通常出现在很多小操作需要不断重复的时候,比如对数组的每个元素做循环操作时。处理结果所花费的时间是不合时宜的慢，处理瓶颈并不是运算本身，而是CPython在每次循环时必须做数据类型的检查和函数调度。在进行循环中每一轮的运算时，Python首先检查对象的类型，并且动态查找可以使用该数据类型的正确函数。如果我们在编译代码时进行这样的操作，那么就能在代码执行之前知晓类型的声明，结果的计算也会更加有效率。</p><h2 id="通用函数介绍"><a href="#通用函数介绍" class="headerlink" title="通用函数介绍"></a>通用函数介绍</h2><p>NumPy为很多类型的操作提供了非常方便的、静态类型的、可编译程序的接口,也被称作向量操作。你可以通过简单地对数组执行操作来实现,这里对数组的操作将会被用于数组中的每一个元素。这种向量方法被用于将循环推送至 NumPy之下的编译层,这样会取得更快的执行效率。如果计算一个较大数组的运行时间，可以看到它的时间比Python循环花费的时间更短。</p><h2 id="探索NumPy的通用函数"><a href="#探索NumPy的通用函数" class="headerlink" title="探索NumPy的通用函数"></a>探索NumPy的通用函数</h2><p>通用函数有两种存在形式:一元通用函数( unary func)对单个输入操作,二元通用函数( binary ufunc)对两个输入操作。</p><h3 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h3><p>NumPy通用函数的使用方式非常自然,因为它用到了 Python原生的算术运算符,标准的加、减、乘、除都可以使用，还有逻辑非，指数运算符和模运算符的一元通用函数。可以任意将这些算术运算符组合使用，当然得考虑这些运算符的优先级。所有这些算术运算符都是NumPy内置函数的简单封装器，例如+运算符就是一个add函数的封装器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.35.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h3><p>正如 NumPy能理解 Python内置的运算操作, NumPy也可以理解Python内置的绝对值函数。对应的 NumPy通用函数是 np. absolute,该函数也可以用别名np. abs来访问。</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>NumPy提供了大量好用的通用函数,其中对于数据科学家最有用的就是三角函数。<br>np.sin() np.cos() np.tan()<br>逆三角函数同样可以使用。<br>np.arcsin() np.arccos() np.arctan()</p><h3 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h3><p>np.log np.exp</p><h3 id="专用的通用函数"><a href="#专用的通用函数" class="headerlink" title="专用的通用函数"></a>专用的通用函数</h3><p>除了以上介绍到的, NumPy还提供了很多通用函数,包括双曲三角函数、比特位运算、比较运算符、弧度转化为角度的运算、取整和求余运算,等等。浏览 NumPy的文档将会揭示很多有趣的功能。还有一个更加专用,也更加晦涩的通用函数优异来源是子模块scipy. special。如果你希望对你的数据进行一些更晦涩的数学计算, scipy. special可能包含了你需要的计算函数。</p><p>NumPy和 scIpy. specia1中提供了大量的通用函数,这些包的文档在网上就可以查到,搜索“ gamma function python”即可。</p><h2 id="高级的通用函数特性"><a href="#高级的通用函数特性" class="headerlink" title="高级的通用函数特性"></a>高级的通用函数特性</h2><h3 id="指定输出"><a href="#指定输出" class="headerlink" title="指定输出"></a>指定输出</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.53.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于较大的数组，通过慎重使用out参数能有效节约内存。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>二元通用函数有些非常有趣的聚合功能,这些聚合可以直接在对象上计算。例如,如果我们希望用一个特定的运算 reduce一个数组,那么可以用任何通用函数的 reduce方法。一个 reduce方法会对给定的元素和操作重复执行,直至得到单个的结果。如果需要存储每次计算的中间结果，可以使用accumulate。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%883.00.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%882.59.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>请注意,在一些特殊情况中, NumPy提供了专用的函数(np.sum、np.prod、np. cumsum、np. cumprod),它们也可以实现以上 reduce的功能。</p><h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>最后,任何通用函数都可以用 outer方法获得两个不同输入数组所有元素对的函数运算结果。这意味着你可以用一行代码实现一个乘法表。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%883.03.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="通用函数：更多的信息"><a href="#通用函数：更多的信息" class="headerlink" title="通用函数：更多的信息"></a>通用函数：更多的信息</h2><p>有关通用函数的更多信息(包括可用的通用函数的完整列表)可以在NumPy和SciPy文档的网站找到。</p><h1 id="聚合：最小值、最大值和其他值"><a href="#聚合：最小值、最大值和其他值" class="headerlink" title="聚合：最小值、最大值和其他值"></a>聚合：最小值、最大值和其他值</h1><p>当面对大量的数据时，第一个步骤通常都是计算相关数据的概括统计值。最常用的概括统计值可能是均值和标准差，这两个值能让你分别概括出数据集中的“经典”值，但是其他一些形式的聚合也是非常有用的（如求和、乘积、中位数、最小值和最大值、分位数，等等）。</p><h2 id="数组值求和"><a href="#数组值求和" class="headerlink" title="数组值求和"></a>数组值求和</h2><p>Sum函数和np.sum函数并不等同,这有时会导致混淆。尤其是它们各自的可选参数都有不同的含义,np.sum函数是知道数组的维度的。sum是python求和，当然np.sum更快。</p><h2 id="最小值和最大值"><a href="#最小值和最大值" class="headerlink" title="最小值和最大值"></a>最小值和最大值</h2><p>Python也有内置的min函数和max函数,分别被用于获取给定数组的最小值和最大值，NumPy对应的函数也有类似的语法,并且也执行得更快。</p><h3 id="多维度聚合"><a href="#多维度聚合" class="headerlink" title="多维度聚合"></a>多维度聚合</h3><p>一种常用的聚合操作时沿着一行或一列聚合。默认情况下，每一个NumPy聚合函数将会返回对整个数组的聚合结果，聚合函数还有一个参数，用于指定沿着哪个轴的方向进行聚合。axis关键字指定的是数组将会被折叠的维度，而不是将要返回的维度。因此指定axis=0意味着第一个轴将要被折叠。对于二维数组，这意味着每一列的值都将被聚合。</p><h3 id="其他聚合函数"><a href="#其他聚合函数" class="headerlink" title="其他聚合函数"></a>其他聚合函数</h3><p>大多数的聚合都有对NaN值的安全处理策略，即计算时忽略所有的缺失值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%883.51.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="数组的计算：广播"><a href="#数组的计算：广播" class="headerlink" title="数组的计算：广播"></a>数组的计算：广播</h1><p>另外一种向量化操作的方法是利用 NumPy的广播功能。广播可以简单理解为用于不同大小数组的二进制通用函数(加、减、乘等)的一组规则。</p><h2 id="广播的介绍"><a href="#广播的介绍" class="headerlink" title="广播的介绍"></a>广播的介绍</h2><p>对于同样大小的数组，二进制操作是对相应元素逐个计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.14.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>广播允许这些二进制操作可以用于不同大小的数组，例如可以将一个标量和一个数组相加。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.15.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们也可以将这个原理扩展到更高维度，将一个一位数组和一个二维数组相加。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.17.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.25.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>浅色的盒子表示广播的值。需要注意的是,这个额外的内存并没有在实际操作中进行分配,但是这样的想象方式更方便我们从概念上理解。</p><h2 id="广播的规则"><a href="#广播的规则" class="headerlink" title="广播的规则"></a>广播的规则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.27.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="比较、掩码和布尔逻辑"><a href="#比较、掩码和布尔逻辑" class="headerlink" title="比较、掩码和布尔逻辑"></a>比较、掩码和布尔逻辑</h1><p>这一节将会介绍如何用布尔掩码来查看和操作 NumPy数组中的值。当你想基于某些准则来抽取、修改、计数或对一个数组中的值进行其他操作时,掩码就可以派上用场了。例如你可能希望统计数组中有多少值大于某一个给定值,或者删除所有超出某些门限值的异常点。在NumPy中,布尔掩码通常是完成这类任务的最高效方式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%884.52.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="操作布尔数组"><a href="#操作布尔数组" class="headerlink" title="操作布尔数组"></a>操作布尔数组</h2><h3 id="统计记录的个数"><a href="#统计记录的个数" class="headerlink" title="统计记录的个数"></a>统计记录的个数</h3><p>如果需要统计布尔数组中True记录的个数,可以使用np. count_nonzero函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.07.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如要快速检查任意或者所有的值是否为True，可以用np.any()或np.all()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.09.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="布尔运算值"><a href="#布尔运算值" class="headerlink" title="布尔运算值"></a>布尔运算值</h3><p>同标准的算术运算符一样，NumPy用通用函数重载了这些逻辑运算符，这样可以实现数组的逐位运算（通常是布尔运算）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.12.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.12.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="将布尔数组作为掩码"><a href="#将布尔数组作为掩码" class="headerlink" title="将布尔数组作为掩码"></a>将布尔数组作为掩码</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.18.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="花哨的索引"><a href="#花哨的索引" class="headerlink" title="花哨的索引"></a>花哨的索引</h1><p>花哨的索引和前面那些简单的索引非常类似，但是传递的是索引数组，而不是单个标量。花哨的索引让我们能够快速获得并修改复杂得数组值的字数据集。</p><h2 id="探索花哨的索引"><a href="#探索花哨的索引" class="headerlink" title="探索花哨的索引"></a>探索花哨的索引</h2><p>花哨的索引在概念上非常简单,它意味着传递一个索引数组来一次性获得多个数组元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.23.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-27%20%E4%B8%8B%E5%8D%885.24.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>花哨的索引也对多个维度适用。</p><h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>花哨的索引可以和其他索引方案结合起来形成更强大的索引操作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.44.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>更可以将花哨的索引和掩码组合使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.48.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h1><h2 id="NumPy中的快速排序：np-sort和np-argsort"><a href="#NumPy中的快速排序：np-sort和np-argsort" class="headerlink" title="NumPy中的快速排序：np.sort和np.argsort"></a>NumPy中的快速排序：np.sort和np.argsort</h2><p>尽管Python有内置的sort和sorted函数可以对列表进行排序，但是效率并不高，NumPy的np.sort函数实际上效率更高。默认情况下，np.sort的排序算法是快速排序，其算法复杂度O[NlogN]，另外也可以选择归并排序和堆排序。对于大多数应用场景，默认的快速排序已经足够高效了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.58.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%881.59.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>NumPy排序算法的一个有用功能是通过axis参数，沿着多维数组的行或列进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.01.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种处理方式是将行或列当做独立的数组，任何行或列的值之间的关系将会丢失。</p><h2 id="部分排序：分隔"><a href="#部分排序：分隔" class="headerlink" title="部分排序：分隔"></a>部分排序：分隔</h2><p>有时候我们不希望对整个数组进行排序，仅仅希望找到数组中第K小的值，NumPy的np.partition函数提供了该功能，最左边是第K小的值，往右是任意顺序的其他值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.07.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>与排序类似，也可以沿着多维数组任意的轴进行分割。<br>正如np.argsort函数计算的是排序的索引值，也有一个np.argpartition函数计算的是分隔的索引值。</p><h1 id="结构化数据：NumPy的结构化数组"><a href="#结构化数据：NumPy的结构化数组" class="headerlink" title="结构化数据：NumPy的结构化数组"></a>结构化数据：NumPy的结构化数组</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.18.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里U1表示“长度不超过10的 Unicode字符串”,i4表示“4字节(即32比特)整型”,f8表示“8字节(即64比特)浮点型”。</p><p>现在生成了一个空的数组容器，可以将列表数据放入数组中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.21.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>正如我们希望的，所有的数据被安排在一个内存块中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.37.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.36.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.34.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="更高级的复合类型"><a href="#更高级的复合类型" class="headerlink" title="更高级的复合类型"></a>更高级的复合类型</h2><p>NumPy中也可以定义更高级的复合数据类型。例如,你可以创建一种类型,其中每个元素都包含一个数组或矩阵。我们会创建一个数据类型,该数据类型用mat组件包含一个3×3的浮点矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-28%20%E4%B8%8B%E5%8D%882.49.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在X数组的每个元素都包含一个id和一个3×3的矩阵。为什么我们宁愿用这种方法存储数据,也不用简单的多维数组,或者 Python字典呢?原因是 NumPy的 dtype直接映射到C结构的定义,因此包含数组内容的缓存可以直接在C程序中使用。如果你想写一个 Python接口与一个遗留的C语言或 Fortran库交互,从而操作结构化数据,你将会发现结构化数组非常有用!</p><h2 id="记录数组：结构化数组的扭转"><a href="#记录数组：结构化数组的扭转" class="headerlink" title="记录数组：结构化数组的扭转"></a>记录数组：结构化数组的扭转</h2><p>NumPy还提供了np.recarray类。它和前面介绍的结构化数组几乎相同，但是它有一个独特的特征：域可以像属性一样获取，而不是像字典的键那样获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python数据科学手册-NumPy入门&quot;&gt;&lt;a href=&quot;#Python数据科学手册-NumPy入门&quot; class=&quot;headerlink&quot; title=&quot;Python数据科学手册 NumPy入门&quot;&gt;&lt;/a&gt;Python数据科学手册 NumPy入门&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础下</title>
    <link href="https://github.com/zdkswd/2018/10/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/"/>
    <id>https://github.com/zdkswd/2018/10/23/机器学习数学基础下/</id>
    <published>2018-10-23T13:28:47.000Z</published>
    <updated>2018-10-23T13:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性代数进阶"><a href="#线性代数进阶" class="headerlink" title="线性代数进阶"></a>线性代数进阶</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.26.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="矩阵的标准型：相似变换（把矩阵看做线性映射）"><a href="#矩阵的标准型：相似变换（把矩阵看做线性映射）" class="headerlink" title="矩阵的标准型：相似变换（把矩阵看做线性映射）"></a>矩阵的标准型：相似变换（把矩阵看做线性映射）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%883.30.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.15.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.16.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="矩阵的标准型：相合变换（二次型）"><a href="#矩阵的标准型：相合变换（二次型）" class="headerlink" title="矩阵的标准型：相合变换（二次型）"></a>矩阵的标准型：相合变换（二次型）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.34.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.35.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.36.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8A%E5%8D%8811.36.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h3><p>PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</p><p>选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/e01296f282109b59e18086843866f81a_b.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如图中如果想要将二维转化为一维，若想少丢失信息，则应将投影尽可能的分散。而这种分散程度，可以用数学上的方差来表述。</p><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</p><p>考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。数学上可以用两个字段的协方差表示其相关性。</p><p>至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。</p><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.07.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.16.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.17.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.18.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.19.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.19.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>最后需要说明的是，PCA是一种无参数技术，也就是说面对同样的数据，如果不考虑清洗，谁来做结果都一样，没有主观参数的介入，所以PCA便于通用实现，但是本身无法个性化的优化。</p><h3 id="（奇异值分解）SVD"><a href="#（奇异值分解）SVD" class="headerlink" title="（奇异值分解）SVD"></a>（奇异值分解）SVD</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.48.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.54.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%8812.55.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="SVD与PCA"><a href="#SVD与PCA" class="headerlink" title="SVD与PCA"></a>SVD与PCA</h3><p>我们讲到要用PCA降维，需要找到样本协方差矩阵的最大的k个特征向量，然后用这最大的k个特征向量张成的矩阵来做低维投影降维。 SVD也可以得到协方差矩阵最大的k个特征向量张成的矩阵。 就是说，PCA算法可以不用做特征分解，而是做SVD来完成。</p><h1 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.06.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.08.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.14.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.08.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最小二乘法是经常使用的优化算法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.38.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/v2-079ffd6e8865d3644fd2cfa1e7521e79_hd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于目标函数，我们限定是凸函数；对于优化变量的可行域（注意，还要包括目标函数定义域的约束），我们限定它是凸集。同时满足这两个限制条件的最优化问题称为凸优化问题，这类问题有一个非常好性质，那就是局部最优解一定是全局最优解。</p><p><strong>凸集</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.00.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.19.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.42.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%887.47.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%887.50.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%888.22.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%889.34.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-17%20%E4%B8%8B%E5%8D%888.24.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.09.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.21.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="优化问题举例：EM算法简介与混合高斯模型"><a href="#优化问题举例：EM算法简介与混合高斯模型" class="headerlink" title="优化问题举例：EM算法简介与混合高斯模型"></a>优化问题举例：EM算法简介与混合高斯模型</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.38.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.39.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.44.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.46.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.49.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8A%E5%8D%8810.51.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.51.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>第一步（E）:如果这个混合模型中，每一次的输出我们知道它是从哪一个模型里边出来的就好了</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>第二步（M）：最大化似然函数</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.53.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%8812.47.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>逐次逼近最优解。</p><h1 id="凸优化进阶"><a href="#凸优化进阶" class="headerlink" title="凸优化进阶"></a>凸优化进阶</h1><h2 id="机器学习与优化"><a href="#机器学习与优化" class="headerlink" title="机器学习与优化"></a>机器学习与优化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%881.57.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="共轭函数与对偶方法"><a href="#共轭函数与对偶方法" class="headerlink" title="共轭函数与对偶方法"></a>共轭函数与对偶方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.05.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>给定一个优化问题，如果比较复杂，可以转化为优化问题的对偶问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.10.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%882.29.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>勒让德（Legendre）变化的理解：函数上境图的支撑超平面的截距。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.09.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对偶（共轭）函数抓住了原来函数的一些性质，没有抓住全部性质，抓住了原来函数凸闭包的性质。非凸函数的凸闭包函数是最接近其性质的凸函数，所以可以拿来做近似。第一个结论告诉我勒让德变换抓的是凸包的性质，第二个性质告诉我们，如果是凸函数了。变成共轭函数了没有丢失信息，再做一次变换还能变回来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.48.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第三点说明对于一般的函数，共轭变换是丢失了一部分信息的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%883.50.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>第二点说的就是几何性质。</p><h2 id="对偶问题：拉格朗日对偶问题"><a href="#对偶问题：拉格朗日对偶问题" class="headerlink" title="对偶问题：拉格朗日对偶问题"></a>对偶问题：拉格朗日对偶问题</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.38.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于没有约束条件的问题，可以使用牛顿法。对于有约束条件的问题，最优解可能不在可行域里，这时就不太好解了。</p><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.35.31.png" alt=""><br>当对一群线性函数取逐点极小值的时候，得到的是一个凹函数。所以g函数是一个凹函数。其中x属于全部定义域，是没有约束条件的，这样再做就比较简单。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们将一个待求函数比较简单但约束条件比较复杂得问题转换为了一个待求函数比较复杂但约束条件比较简单的问题。把问题的复杂性转化到了函数里面去。待求函数不管凸的凹的可以用牛顿法去做逼近。</p><p>那转化后的问题与原问题有什么关系呢？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.25.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.28.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用g的上界提供了原问题的下界。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.52.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>d是g的最大值，p是f的最小值。</p><h2 id="强对偶性条件"><a href="#强对偶性条件" class="headerlink" title="强对偶性条件"></a>强对偶性条件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%884.50.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>凸优化问题比较容易去求解，但是为什么还需要求对偶变化呢，是因为约束条件比较复杂。需要简化。</p><p>当你是对偶问题时，在凸性上一定是变好的，但是不一定能抓住原来问题的所有性质。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.43.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.43.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%886.45.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.19.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.20.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.22.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.52.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>琴生不等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.54.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.47.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.48.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上确界（Supremum）：一个集合的最小上界， 数学符号sups<br>下确界（greatest lower boundinf）：一个集合的最大下界,数学符号inf<br>上确界与最大值：上确界类似于最大值，但是和最大值不同的是，最大值有时候会遇到无法取到的情况。比如x∈R,x&lt;2这样的情况下就不存在一个确定的最大值。但是可以确定上确界为2。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.50.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%884.53.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.21.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>a,x都是向量，b是常数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.24.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.26.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.26.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>简单来说仿射变换就是线性变换加平移。线性变化中原点还在原点，但仿射变换后，原点就移动了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%889.18.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如何通俗地讲解「<em>仿射变换</em>」这个概念？ - 马同学的回答 - 知乎<br><a href="https://www.zhihu.com/question/20666664/answer/157400568" target="_blank" rel="noopener">https://www.zhihu.com/question/20666664/answer/157400568</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.28.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将前z维每一项都除以最后一维t,将最后一项t舍弃。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.29.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.30.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.32.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.33.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.34.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.35.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%883.41.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.47.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.51.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>分割使用的是n-1维的超平面。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.53.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%887.56.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.00.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>等式条件定义了一个球面，球面不是一个凸集合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.20.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此时把支持向量机问题转化为了一个凸优化问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.32.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.36.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.40.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.44.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.48.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.56.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>允许c和d有一部分交叉。<br>或者使用核方法，将维度增加，再进行划分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%888.58.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.01.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.03.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>C抜D抜离得最近的两个点的垂直平分线。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.06.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.08.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="压缩感知与图像处理"><a href="#压缩感知与图像处理" class="headerlink" title="压缩感知与图像处理"></a>压缩感知与图像处理</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.13.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.20.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.22.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.24.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.24.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.25.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-23%20%E4%B8%8B%E5%8D%889.25.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="算法和理论与数学知识点"><a href="#算法和理论与数学知识点" class="headerlink" title="算法和理论与数学知识点"></a>算法和理论与数学知识点</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-16%20%E4%B8%8B%E5%8D%882.52.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性代数进阶&quot;&gt;&lt;a href=&quot;#线性代数进阶&quot; class=&quot;headerlink&quot; title=&quot;线性代数进阶&quot;&gt;&lt;/a&gt;线性代数进阶&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="https://github.com/zdkswd/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常见的几种最优化方法</title>
    <link href="https://github.com/zdkswd/2018/10/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/zdkswd/2018/10/22/常见的几种最优化方法/</id>
    <published>2018-10-22T13:32:51.000Z</published>
    <updated>2018-11-06T05:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/maybe2030/p/4751804.html" target="_blank" rel="noopener">Math 常见的几种最优化方法 - Poll的笔记 - 博客园</a><br>最优化方法与凸优化，我们研究凸优化，是因为凸优化比较好研究，其实正确的叫法应当叫最优化方法。</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>梯度下降法是最早最简单，也是最为常用的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。<strong>梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/350px-Gradient_descent.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>梯度下降的缺点：</p><ol><li>靠近极小值时收敛速度减慢，如下图所示</li><li>直线搜索时可能会产生一些问题</li><li>可能会“之字形”地下降。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/Banana-SteepDesc.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><p>为什么计算函数极值用梯度下降算法而不直接令导数为0求解<br>并不是所有的函数都可以根据导数求出取得0值的点的, 现实的情况可能是:<br>1、可以求出导数在每个点的值, 但是直接解方程解不出来,<br>2、计算机更加适合用循环迭代的方法来求极值。</p><h2 id="批量梯度下降法（BGD）"><a href="#批量梯度下降法（BGD）" class="headerlink" title="批量梯度下降法（BGD）"></a>批量梯度下降法（BGD）</h2><p>最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</p><h2 id="随机梯度下降法（SGD）"><a href="#随机梯度下降法（SGD）" class="headerlink" title="随机梯度下降法（SGD）"></a>随机梯度下降法（SGD）</h2><p>最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。</p><p><strong>两者的关系可以这样理解：随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</strong></p><h1 id="牛顿法和拟牛顿法"><a href="#牛顿法和拟牛顿法" class="headerlink" title="牛顿法和拟牛顿法"></a>牛顿法和拟牛顿法</h1><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p><a href="https://matongxue.com/madocs/205.html" target="_blank" rel="noopener">如何通俗易懂地讲解牛顿迭代法？</a><br>五次及以上多项式方程没有根式解（就是没有像二次方程那样的万能公式）。没有根式解不意味着方程解不出来，数学家也提供了很多方法，牛顿迭代法就是其中一种。</p><h3 id="代数解法"><a href="#代数解法" class="headerlink" title="代数解法"></a>代数解法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-18%20%E4%B8%8A%E5%8D%8810.30.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="不总是收敛（不总是能求得足够近似的根）"><a href="#不总是收敛（不总是能求得足够近似的根）" class="headerlink" title="不总是收敛（不总是能求得足够近似的根）"></a>不总是收敛（不总是能求得足够近似的根）</h3><p>充分条件：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-18%20%E4%B8%8A%E5%8D%8810.28.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也就是说有很多情况下选择牛顿法，根不收敛。</p><p>而且不能完整求出所有的根，只能求到起始点附近的根。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>应用牛顿法最好：</p><ol><li>函数在整个定义域内最好是二阶可导的</li><li>起始点对求根计算影响重大，可以增加一些别的手段进行试错。</li></ol><h3 id="求解最值问题"><a href="#求解最值问题" class="headerlink" title="求解最值问题"></a>求解最值问题</h3><p>牛顿法也被用于求函数的最值。由于函数取最值的点处的导数值为零，故可用牛顿法求导函数的零点，其迭代式为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/b812c8fcc3cec3fddbb30b10dd88d43f869427c1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="高维情况的牛顿迭代式"><a href="#高维情况的牛顿迭代式" class="headerlink" title="高维情况的牛顿迭代式"></a>高维情况的牛顿迭代式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/0_1307264790QzWk.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>高维情况依然可以用牛顿迭代求解，但是问题是Hessian矩阵引入的复杂性，使得牛顿迭代求解的难度大大增加，但是已经有了解决这个问题的办法就是Quasi-Newton methond，不再直接计算hessian矩阵，而是每一步的时候使用梯度向量更新hessian矩阵的近似。</p><h3 id="关于牛顿法与梯度下降法效率的对比"><a href="#关于牛顿法与梯度下降法效率的对比" class="headerlink" title="关于牛顿法与梯度下降法效率的对比"></a>关于牛顿法与梯度下降法效率的对比</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/697b070fjw1dvpdvu65zij.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</p><p>根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：二阶收敛，收敛速度快；<br>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</p><h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2><p><strong>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。</strong>拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p><p>针对牛顿法中海塞矩阵的计算问题，拟牛顿法主要是使用一个海塞矩阵的近似矩阵来代替原来的还塞矩阵，通过这种方式来减少运算的复杂度。其主要过程是先推导出海塞矩阵需要满足的条件，即拟牛顿条件（也可以称为拟牛顿方程）。然后我们构造一个满足拟牛顿条件的近似矩阵来代替原来的海塞矩阵。</p><p>外，在满足拟牛顿条件的基础上如何构造近似的海塞矩阵，这有很多种方法，比如：DFP算法，BFGS算法，L-BFGS算法以及Broyden类算法等。常用前两种。</p><p>在牛顿法推导中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090055594094281.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后对f(x)求偏导：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090056311435787.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>令x=xk得到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090057071597116.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>g等于f的一阶导。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090057354245982.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>简化：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090058041599302.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>于是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/090100178627788.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在满足此条件的基础上如何构造近似海塞矩阵呢？下面介绍两个方法：DFP算法和BFGS算法。</p><h3 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a>DFP算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324000528609.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324000539484.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="BFGS算法"><a href="#BFGS算法" class="headerlink" title="BFGS算法"></a>BFGS算法</h3><p>　　BFGS算法是用直接逼近海塞矩阵的方式来构造近似海塞矩阵，同样，我们使用迭代的方式来逐步逼近。我们使用B来表示海塞矩阵的近似矩阵，而在DFP算法中我们是直接使用D来构造近似海塞矩阵的逆矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324001108453.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/20140324001126671.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h1><p><strong>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。</strong> 在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/220px-Conjugate_gradient_illustration.svg.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注：绿色为梯度下降法，红色代表共轭梯度法</strong></p><h1 id="启发式优化方法"><a href="#启发式优化方法" class="headerlink" title="启发式优化方法"></a>启发式优化方法</h1><p>启发式方法指人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。启发式优化方法种类繁多，包括经典的模拟退火方法、遗传算法、蚁群算法以及粒子群算法等等。</p><p>　　还有一种特殊的优化算法被称之多目标优化算法，它主要针对同时优化多个目标（两个及两个以上）的优化问题，这方面比较经典的算法有NSGAII算法、MOEA/D算法以及人工免疫算法等。</p><h1 id="解决约束优化问题—拉格朗日乘数法"><a href="#解决约束优化问题—拉格朗日乘数法" class="headerlink" title="解决约束优化问题—拉格朗日乘数法"></a>解决约束优化问题—拉格朗日乘数法</h1><h2 id="拉格朗日乘数法的基本思想"><a href="#拉格朗日乘数法的基本思想" class="headerlink" title="拉格朗日乘数法的基本思想"></a>拉格朗日乘数法的基本思想</h2><p>　<strong>作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数</strong></p><p>　　<strong>如何将一个含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题？拉格朗日乘数法从数学意义入手，通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解。</strong></p><h2 id="拉格朗日乘数法的基本形态"><a href="#拉格朗日乘数法的基本形态" class="headerlink" title="拉格朗日乘数法的基本形态"></a>拉格朗日乘数法的基本形态</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-22%20%E4%B8%8B%E5%8D%888.56.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="拉格朗日乘数法与KKT条件"><a href="#拉格朗日乘数法与KKT条件" class="headerlink" title="拉格朗日乘数法与KKT条件"></a>拉格朗日乘数法与KKT条件</h2><p>我们上述讨论的问题均为等式约束优化问题，但等式约束并不足以描述人们面临的问题，不等式约束比等式约束更为常见，大部分实际问题的约束都是不超过多少时间，不超过多少人力，不超过多少成本等等。所以有几个科学家拓展了拉格朗日乘数法，增加了KKT条件之后便可以用拉格朗日乘数法来求解不等式约束的优化问题了。</p><p>　<strong>KKT条件是指在满足一些有规则的条件下, 一个非线性规划(Nonlinear Programming)问题能有最优化解法的一个必要和充分条件.</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-22%20%E4%B8%8B%E5%8D%889.07.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/maybe2030/p/4751804.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Math 常见的几种最优化方法 - Poll的笔记 - 博客园&lt;/a&gt;&lt;br&gt;最优化方法与凸优化
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
