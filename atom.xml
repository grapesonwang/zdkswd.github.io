<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-08-31T04:13:52.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/zdkswd/2018/08/29/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E8%AF%AD%E6%B3%95%20%E4%BA%8C/"/>
    <id>https://github.com/zdkswd/2018/08/29/Python廖雪峰 语法 二/</id>
    <published>2018-08-29T08:19:56.000Z</published>
    <updated>2018-08-31T04:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python廖雪峰-语法-二"><a href="#Python廖雪峰-语法-二" class="headerlink" title="Python廖雪峰 语法 二"></a>Python廖雪峰 语法 二</h1><h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取数组前3个元素，用一行代码就可以完成切片。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.21.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从索引0开始取，直到索引3为止，但不包括索引3。</p><p>如果第一个索引是0，还可以省略。</p><p>Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片。</p><p>后10个数，L[-10:]。前10个数，每两个取一个，L[:10:2]。甚至什么都不写，只写[:]就可以原样复制一个list。</p><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。</p><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串。</p><p>Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</p><p>通过collections模块的Iterable类型判断一个对象是可迭代对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.34.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.35.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环里，同时引用了两个变量，在Python里是很常见的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.36.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))。</p><p>列表生成式则可以用一行语句代替循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.38.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环后面还可以加上if判断。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.44.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以使用两层循环，还可以使用两层循环。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.45.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.46.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>如果列表元素可以按照某种算法推算出来，可以在循环的过程中不断推算出后续的元素，就不必创建完整的list。Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>把一个列表生成式的[]改成()，就创建了一个generator。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-29%20%E4%B8%8B%E5%8D%884.50.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>通过next()函数获得generator的下一个返回值。</p><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%889.57.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。</p><p>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.20.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.22.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.32.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以直接作用于for循环的对象统称为可迭代对象：<strong>Iterable</strong>。如集合数据类型，如list、tuple、dict、set、str等，generator，包括生成器和带yield的generator function。</p><p>可以使用isinstance()判断一个对象是否是Iterable对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.35.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：<strong>Iterator</strong>。</p><p>可以使用isinstance()判断一个对象是否是Iterator对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.36.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</strong></p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.37.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。所以list、dict、str等数据类型不是Iterator。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>Python内建了map()和reduce()函数。</p><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.41.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p><p>所以，map()作为高阶函数，事实上它把运算规则抽象了，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list。</p><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.45.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.47.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的filter()函数用于过滤序列。</p><p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.48.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>Python内置的sorted()函数就可以对list进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.50.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.51.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-30%20%E4%B8%8B%E5%8D%8810.52.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.18.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>返回的函数并没有立刻执行，而是直到调用了f()才执行。</p><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数lambda x: x * x实际上就是<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.35.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.37.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>同样，也可以把匿名函数作为返回值返回，比如。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.38.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><p>函数对象有一个<strong>name</strong>属性，可以拿到函数的名字。</p><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。</p><p>我们要定义一个能打印日志的decorator，可以定义如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.42.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>我们要借助Python的@语法，把decorator置于函数的定义处。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.42.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>把@log放到now()函数的定义处，相当于执行了语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.43.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.45.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p><p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.51.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。</p><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p><p>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<strong>author</strong>，<strong>name</strong>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<strong>doc</strong>访问，我们自己的变量一般不要用这种变量名；</p><p>类似_xxx和<strong>xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，</strong>abc等；</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public，这也是一种非常有用的代码封装和抽象的方法。</p><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。</p><p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15355307965600/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-31%20%E4%B8%8A%E5%8D%8811.57.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="安装常用模块"><a href="#安装常用模块" class="headerlink" title="安装常用模块"></a>安装常用模块</h3><p>我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。</p><p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</p><p>如果我们要添加自己的搜索目录，有两种方法<br>一是直接修改sys.path，添加要搜索的目录。<br>第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python廖雪峰-语法-二&quot;&gt;&lt;a href=&quot;#Python廖雪峰-语法-二&quot; class=&quot;headerlink&quot; title=&quot;Python廖雪峰 语法 二&quot;&gt;&lt;/a&gt;Python廖雪峰 语法 二&lt;/h1&gt;&lt;h1 id=&quot;高级特性&quot;&gt;&lt;a href=&quot;#高
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python廖雪峰 语法 一</title>
    <link href="https://github.com/zdkswd/2018/08/27/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%20%E8%AF%AD%E6%B3%95%20%E4%B8%80/"/>
    <id>https://github.com/zdkswd/2018/08/27/Python廖雪峰 语法 一/</id>
    <published>2018-08-27T11:33:56.000Z</published>
    <updated>2018-08-31T03:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h1><p>Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。</p><p>除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。</p><h2 id="那Python适合开发哪些类型的应用呢？"><a href="#那Python适合开发哪些类型的应用呢？" class="headerlink" title="那Python适合开发哪些类型的应用呢？"></a>那Python适合开发哪些类型的应用呢？</h2><p>首选是网络应用，包括网站、后台服务等等；</p><p>其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</p><p>另外就是把其他语言开发的程序再包装起来，方便使用。</p><h2 id="Python的缺点"><a href="#Python的缺点" class="headerlink" title="Python的缺点"></a>Python的缺点</h2><p>第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</p><p>第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。</p><h1 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h1><p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p><h2 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h2><p>官方版本的解释器：CPython。这个解释器是用C语言开发的。CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p><h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p><h2 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h2><p>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。<br>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。</p><h2 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h2><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p><h2 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h2><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在Python中，能够直接处理的数据类型有以下几种：</p><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p><p>如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识。</p><p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义。</p><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容。用在命令行中，py文件中直接换行也可输出换行后的内容。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>一个布尔值只有True、False两种值，要么是True，要么是False。</p><p>布尔值可以用and、or和not运算。</p><p><strong>空值</strong><br>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头。</p><p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8A%E5%8D%8810.53.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>可以看到赋值前不需要声明变量。</p><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>。</p><p><strong>变量在计算机内存中的表示</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8A%E5%8D%8811.07.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Python解释器干了两件事情：<br>在内存中创建了一个’ABC’的字符串；<br>在内存中创建了一个名为a的变量，并把它指向’ABC’。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量。</p><p>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变。用全部大写的变量名表示常量只是一个习惯上的用法。</p><p>/ 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数。</p><h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。</p><p>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><h3 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h3><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。</p><p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p><p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的str通过encode()方法可以编码为指定的bytes。</p><p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法。</p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数。</p><p>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.00.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.00.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。Python当然也支持其他编码方式，比如把Unicode编码成GB2312。但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。</p><p>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用%实现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.07.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>常见的占位符有：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.04.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。</p><p>转义，用%%来表示一个%。</p><h4 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h4><p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.07.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一种有序的集合，可以随时添加和删除其中的元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.10.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>len()函数可以获得list元素的个数。</p><p>用索引来访问list中每一个位置的元素，记得索引是从0开始的。</p><p>-1做索引，直接获取最后一个元素。</p><p>append()可以往list中追加元素到末尾<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.12.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>insert()也可以把元素插入到指定的位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.14.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>pop()方法，删除list末尾的元素。要删除指定位置的元素，用pop(i)方法。</p><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置。</p><p>list里面的元素的数据类型也可以不同。list元素也可以是另一个list。</p><p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0。</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.37.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</p><p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><p>tuple的陷阱：只有1个元素的tuple定义时必须加一个逗号“  ,   ”，来消除歧义。</p><p>Python在显示只有1个元素的tuple时，也会加一个逗号“ , ”，以免你误解成数学计算意义上的括号。</p><p>tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><p>创建一个内容也不变的tuple那就必须保证tuple的每一个元素本身也不能变。</p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if语句elif是else if的缩写。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.43.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>input()读取用户的输入，这样可以自己输入。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.48.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。</p><p>range()函数，可以生成一个整数序列，range(5)生成的序列是从0开始小于5（没有5）的整数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.53.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>0-100。</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%883.53.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break语句可以提前退出循环。</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue语句，跳过当前的这次循环，直接开始下一次循环。</p><h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%884.01.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入。</p><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。</p><p>如果key不存在，dict就会报错，要避免key不存在的错误，有两种办法，一是通过in判断key是否存在，二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value。注意：返回None的时候Python的交互环境不显示结果。</p><p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-26%20%E4%B8%8B%E5%8D%884.11.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p><p>和list比较，dict有以下几个特点<br>查找和插入的速度极快，不会随着key的增加而变慢<br>需要占用大量的内存，内存浪费多<br>而list相反</p><p>dict是用空间来换取时间的一种方法。</p><p>正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%882.58.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>重复元素在set中自动被过滤。</p><p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果。</p><p>通过remove(key)方法可以删除元素。</p><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.26.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象。</p><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。</p><p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误。如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息。</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.37.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.39.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.40.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）。</p><h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果想定义一个什么事也不做的空函数，可以用pass语句。</p><p>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p><p>缺少了pass，代码运行就会有语法错误。</p><h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError。但是如果参数类型不对，Python解释器就无法帮我们检查。</p><p>对参数的限制需要我们手动完成，数据类型检查可以用内置函数isinstance()实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.51.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%883.52.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但其实这只是一种假象，Python函数返回的仍然是单一值。</p><p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>函数体内部可以用return随时返回函数结果；<br>函数执行完毕也没有return语句时，自动return None。</p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>对于power(x)函数，参数x就是一个位置参数。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p> power(x, n=2)</p><p>当我们调用power(5)时，相当于调用power(5, 2)</p><p>设置默认参数时，有几点要注意<br>一是必选参数在前，默认参数在后，否则Python的解释器会报错。<br>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><p>默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.01.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll(‘Bob’, ‘M’, 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</p><p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(‘Adam’, ‘M’, city=’Tianjin’)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</p><p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑。<strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p><p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.49.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。</p><p>Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.50.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.54.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.55.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%884.56.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p><h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.00.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。</p><p>调用方式如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.09.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.10.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15352502018689/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%885.10.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>命名关键字参数可以有缺省值，从而简化调用。</p><h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。</p><p><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></p><p>对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。</p><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p><p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python简介&quot;&gt;&lt;a href=&quot;#Python简介&quot; class=&quot;headerlink&quot; title=&quot;Python简介&quot;&gt;&lt;/a&gt;Python简介&lt;/h1&gt;&lt;p&gt;Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 DOM模型 一</title>
    <link href="https://github.com/zdkswd/2018/08/22/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%E6%A8%A1%E5%9E%8B%20%E4%B8%80/"/>
    <id>https://github.com/zdkswd/2018/08/22/JavaScript标准参考教程 DOM模型 一/</id>
    <published>2018-08-22T10:33:56.000Z</published>
    <updated>2018-08-26T02:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM模型概述"><a href="#DOM模型概述" class="headerlink" title="DOM模型概述"></a>DOM模型概述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p><p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p><p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p><p>节点的类型有七种<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%889.50.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。</p><h3 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h3><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</p><p>浏览器原生提供document节点，代表整个文档。</p><p>文档的第一层只有一个节点，就是 HTML 网页的第一个标签&lt; html&gt;，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p><p>除了根节点，其他节点都有三种层级关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.05.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括firstChild（第一个子节点）和lastChild（最后一个子节点）等属性，同级节点接口包括nextSibling（紧邻在后的那个同级节点）和previousSibling（紧邻在前的那个同级节点）属性。</p><h2 id="Node-接口的属性"><a href="#Node-接口的属性" class="headerlink" title="Node 接口的属性"></a>Node 接口的属性</h2><p>所有 DOM 节点都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p><h3 id="Node-nodeType"><a href="#Node-nodeType" class="headerlink" title="Node.nodeType"></a>Node.nodeType</h3><p>nodeType属性返回一个整数值，表示节点的类型。</p><p>Node 对象定义了几个常量，对应这些类型值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.07.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>确定节点类型时，使用nodeType属性是常用方法。</p><h3 id="Node-nodeName"><a href="#Node-nodeName" class="headerlink" title="Node.nodeName"></a>Node.nodeName</h3><p>nodeName属性返回节点的名称。</p><p>不同节点的nodeName属性值如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.10.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Node-nodeValue"><a href="#Node-nodeValue" class="headerlink" title="Node.nodeValue"></a>Node.nodeValue</h3><p>nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p><p>只有文本节点（text）和注释节点（comment）有文本值，因此这两类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这两类节点可以设置nodeValue属性的值，其他类型的节点设置无效。</p><h3 id="Node-textContent"><a href="#Node-textContent" class="headerlink" title="Node.textContent"></a>Node.textContent</h3><p>textContent属性返回当前节点和它的所有后代节点的文本内容。</p><p>textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p><p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p><p>对于文本节点（text）和注释节点（comment），textContent属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括注释节点。如果一个节点没有子节点，则返回空字符串。</p><p>文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。</p><h3 id="Node-baseURI"><a href="#Node-baseURI" class="headerlink" title="Node.baseURI"></a>Node.baseURI</h3><p>baseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p><p>如果无法读到网页的 URL，baseURI属性返回null。</p><p>该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的&lt; base&gt;标签，改变该属性的值。</p><p>设置了以后，baseURI属性就返回<base>标签设置的值。</p><h3 id="Node-ownerDocument"><a href="#Node-ownerDocument" class="headerlink" title="Node.ownerDocument"></a>Node.ownerDocument</h3><p>Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。</p><p>document对象本身的ownerDocument属性，返回null。</p><h3 id="Node-nextSibling"><a href="#Node-nextSibling" class="headerlink" title="Node.nextSibling"></a>Node.nextSibling</h3><p>Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</p><p>注意，该属性还包括文本节点和注释节点（<!-- comment -->）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p><p>nextSibling属性可以用来遍历所有子节点。</p><h3 id="Node-previousSibling"><a href="#Node-previousSibling" class="headerlink" title="Node.previousSibling"></a>Node.previousSibling</h3><p>previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。</p><p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p><h3 id="Node-parentNode"><a href="#Node-parentNode" class="headerlink" title="Node.parentNode"></a>Node.parentNode</h3><p>parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p><p>文档节点（document）和文档片段节点（documentfragment）的父节点都是null。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是null。</p><h3 id="Node-parentElement"><a href="#Node-parentElement" class="headerlink" title="Node.parentElement"></a>Node.parentElement</h3><p>parentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。</p><p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。parentElement属性相当于把后两种父节点都排除了。</p><h3 id="Node-firstChild，Node-lastChild"><a href="#Node-firstChild，Node-lastChild" class="headerlink" title="Node.firstChild，Node.lastChild"></a>Node.firstChild，Node.lastChild</h3><p>firstChild属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。</p><p>注意，firstChild返回的除了元素节点，还可能是文本节点或注释节点。</p><p>lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。用法与firstChild属性相同。</p><h3 id="Node-childNodes"><a href="#Node-childNodes" class="headerlink" title="Node.childNodes"></a>Node.childNodes</h3><p>childNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。</p><p>使用该属性，可以遍历某个节点的所有子节点。</p><p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p><h3 id="Node-isConnected"><a href="#Node-isConnected" class="headerlink" title="Node.isConnected"></a>Node.isConnected</h3><p>isConnected属性返回一个布尔值，表示当前节点是否在文档之中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8810.56.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Node-接口的方法"><a href="#Node-接口的方法" class="headerlink" title="Node 接口的方法"></a>Node 接口的方法</h2><h3 id="Node-appendChild"><a href="#Node-appendChild" class="headerlink" title="Node.appendChild()"></a>Node.appendChild()</h3><p>appendChild方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.00.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果参数节点是 DOM 已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置。</p><p>如果appendChild方法的参数是DocumentFragment节点，那么插入的是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值是一个空的DocumentFragment节点。</p><h3 id="Node-hasChildNodes"><a href="#Node-hasChildNodes" class="headerlink" title="Node.hasChildNodes()"></a>Node.hasChildNodes()</h3><p>hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。</p><p>注意，子节点包括所有节点，哪怕节点只包含一个空格，hasChildNodes方法也会返回true。</p><p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.05.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Node-cloneNode"><a href="#Node-cloneNode" class="headerlink" title="Node.cloneNode()"></a>Node.cloneNode()</h3><p>cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p><p>该方法有一些使用注意点。</p><ol><li>克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即node.onclick = fn），添加在这个节点上的事件回调函数。</li><li>该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如Node.appendChild这样的方法添加到文档之中。</li><li>克隆一个节点之后，DOM 有可能出现两个有相同id属性（即id=”xxx”）的网页元素，这时应该修改其中一个元素的id属性。如果原节点有name属性，可能也需要修改。</li></ol><h3 id="Node-insertBefore"><a href="#Node-insertBefore" class="headerlink" title="Node.insertBefore()"></a>Node.insertBefore()</h3><p>insertBefore方法用于将某个节点插入父节点内部的指定位置。</p><p>insertBefore方法接受两个参数，第一个参数是所要插入的节点newNode，第二个参数是父节点parentNode内部的一个子节点referenceNode。newNode将插在referenceNode这个子节点的前面。返回值是插入的新节点newNode。</p><p>如果insertBefore方法的第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p><p><strong>注意</strong>，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p><p>由于不存在insertAfter方法，如果新节点要插在父节点的某个子节点后面，可以用insertBefore方法结合nextSibling属性模拟。</p><p>如果要插入的节点是DocumentFragment类型，那么插入的将是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值将是一个空的DocumentFragment节点。</p><h3 id="Node-removeChild"><a href="#Node-removeChild" class="headerlink" title="Node.removeChild()"></a>Node.removeChild()</h3><p>removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p><p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p><p>如果参数节点不是当前节点的子节点，removeChild方法将报错。</p><h3 id="Node-replaceChild"><a href="#Node-replaceChild" class="headerlink" title="Node.replaceChild()"></a>Node.replaceChild()</h3><p>replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。</p><p>replaceChild方法接受两个参数，第一个参数newChild是用来替换的新节点，第二个参数oldChild是将要替换走的子节点。返回值是替换走的那个节点oldChild。</p><h3 id="Node-contains"><a href="#Node-contains" class="headerlink" title="Node.contains()"></a>Node.contains()</h3><p>contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.21.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Node-compareDocumentPosition"><a href="#Node-compareDocumentPosition" class="headerlink" title="Node.compareDocumentPosition()"></a>Node.compareDocumentPosition()</h3><p>compareDocumentPosition方法的用法，与contains方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%8811.22.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于compareDocumentPosition返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p><p>进行与运算（&amp;）。</p><h3 id="Node-isEqualNode-，Node-isSameNode"><a href="#Node-isEqualNode-，Node-isSameNode" class="headerlink" title="Node.isEqualNode()，Node.isSameNode()"></a>Node.isEqualNode()，Node.isSameNode()</h3><p>isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p><p>isSameNode方法返回一个布尔值，表示两个节点是否为同一个节点。</p><h3 id="Node-normalize"><a href="#Node-normalize" class="headerlink" title="Node.normalize()"></a>Node.normalize()</h3><p>normailize方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p><p>该方法是Text.splitText的逆方法。</p><h3 id="Node-getRootNode"><a href="#Node-getRootNode" class="headerlink" title="Node.getRootNode()"></a>Node.getRootNode()</h3><p>getRootNode方法返回当前节点所在文档的根节点。</p><h2 id="NodeList-接口"><a href="#NodeList-接口" class="headerlink" title="NodeList 接口"></a>NodeList 接口</h2><p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：NodeList和HTMLCollection。</p><p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是NodeList实例或HTMLCollection实例。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%883.58.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。</p><p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。</p><h3 id="NodeList-prototype-length"><a href="#NodeList-prototype-length" class="headerlink" title="NodeList.prototype.length"></a>NodeList.prototype.length</h3><p>length属性返回 NodeList 实例包含的节点数量。</p><p>document.getElementsByTagName返回一个 NodeList 集合。对于那些不存在的 HTML 标签，length属性返回0。</p><h3 id="NodeList-prototype-forEach"><a href="#NodeList-prototype-forEach" class="headerlink" title="NodeList.prototype.forEach()"></a>NodeList.prototype.forEach()</h3><p>forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。</p><p>forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。</p><h3 id="NodeList-prototype-item"><a href="#NodeList-prototype-item" class="headerlink" title="NodeList.prototype.item()"></a>NodeList.prototype.item()</h3><p>item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p><p>如果参数值大于实际长度，或者索引不合法（比如负数），item方法返回null。如果省略参数，item方法会报错。</p><p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用item方法。</p><h3 id="NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries"><a href="#NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries" class="headerlink" title="NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()"></a>NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h3><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过for…of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。</p><h2 id="HTMLCollection-接口"><a href="#HTMLCollection-接口" class="headerlink" title="HTMLCollection 接口"></a>HTMLCollection 接口</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历。</p><p>HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中。</p><p>如果元素节点有id或name属性，那么HTMLCollection实例上面，可以使用id属性或name属性引用该节点元素。如果没有对应的节点，则返回null。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%884.25.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="HTMLCollection-prototype-length"><a href="#HTMLCollection-prototype-length" class="headerlink" title="HTMLCollection.prototype.length"></a>HTMLCollection.prototype.length</h3><p>length属性返回HTMLCollection实例包含的成员数量。</p><h3 id="HTMLCollection-prototype-item"><a href="#HTMLCollection-prototype-item" class="headerlink" title="HTMLCollection.prototype.item()"></a>HTMLCollection.prototype.item()</h3><p>item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p><p>如果参数值超出成员数量或者不合法（比如小于0），那么item方法返回null。</p><h3 id="HTMLCollection-prototype-namedItem"><a href="#HTMLCollection-prototype-namedItem" class="headerlink" title="HTMLCollection.prototype.namedItem()"></a>HTMLCollection.prototype.namedItem()</h3><p>namedItem方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%884.28.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="ParentNode-接口"><a href="#ParentNode-接口" class="headerlink" title="ParentNode 接口"></a>ParentNode 接口</h2><p>节点对象除了继承 Node 接口以外，还会继承其他接口。ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。ChildNode接口表示当前节点是一个子节点，提供一些相关方法。</p><p>如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口。</p><h3 id="ParentNode-children"><a href="#ParentNode-children" class="headerlink" title="ParentNode.children"></a>ParentNode.children</h3><p>children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。</p><p>children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。</p><p>HTMLCollection是动态集合，会实时反映 DOM 的任何变化。</p><h3 id="ParentNode-firstElementChild"><a href="#ParentNode-firstElementChild" class="headerlink" title="ParentNode.firstElementChild"></a>ParentNode.firstElementChild</h3><p>firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。</p><h3 id="ParentNode-lastElementChild"><a href="#ParentNode-lastElementChild" class="headerlink" title="ParentNode.lastElementChild"></a>ParentNode.lastElementChild</h3><p>lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。</p><h3 id="ParentNode-childElementCount"><a href="#ParentNode-childElementCount" class="headerlink" title="ParentNode.childElementCount"></a>ParentNode.childElementCount</h3><p>childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。</p><h3 id="ParentNode-append-，ParentNode-prepend"><a href="#ParentNode-append-，ParentNode-prepend" class="headerlink" title="ParentNode.append()，ParentNode.prepend()"></a>ParentNode.append()，ParentNode.prepend()</h3><p>append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p><p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p><p>注意，该方法没有返回值。</p><p>prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。</p><h2 id="ChildNode-接口"><a href="#ChildNode-接口" class="headerlink" title="ChildNode 接口"></a>ChildNode 接口</h2><p>如果一个节点有父节点，那么该节点就继承了ChildNode接口。</p><h3 id="ChildNode-remove"><a href="#ChildNode-remove" class="headerlink" title="ChildNode.remove()"></a>ChildNode.remove()</h3><p>remove方法用于从父节点移除当前节点。</p><h3 id="ChildNode-before-，ChildNode-after"><a href="#ChildNode-before-，ChildNode-after" class="headerlink" title="ChildNode.before()，ChildNode.after()"></a>ChildNode.before()，ChildNode.after()</h3><p>before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p><p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p><p>after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。</p><h3 id="ChildNode-replaceWith"><a href="#ChildNode-replaceWith" class="headerlink" title="ChildNode.replaceWith()"></a>ChildNode.replaceWith()</h3><p>replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p><h1 id="document-对象"><a href="#document-对象" class="headerlink" title="document 对象"></a>document 对象</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>document对象是文档的根节点，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p><p>document对象有不同的办法可以获取。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%885.01.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>document对象继承了EventTarget接口、Node接口、ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="快捷方式属性"><a href="#快捷方式属性" class="headerlink" title="快捷方式属性"></a>快捷方式属性</h3><p>以下属性是指向文档内部的某个节点的快捷方式。</p><h4 id="document-defaultView"><a href="#document-defaultView" class="headerlink" title="document.defaultView"></a>document.defaultView</h4><p>document.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。</p><h4 id="document-doctype"><a href="#document-doctype" class="headerlink" title="document.doctype"></a>document.doctype</h4><p>对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt; DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt; !DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。</p><p>document.firstChild通常就返回这个节点。</p><h4 id="document-documentElement"><a href="#document-documentElement" class="headerlink" title="document.documentElement"></a>document.documentElement</h4><p>document.documentElement属性返回当前文档的根节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是<html>节点。</html></p><h4 id="document-body，document-head"><a href="#document-body，document-head" class="headerlink" title="document.body，document.head"></a>document.body，document.head</h4><p>document.body属性指向&lt; body&gt;节点，document.head属性指向&lt; head&gt;节点。</p><p>这两个属性总是存在的，如果网页源码里面省略了&lt; head&gt;或&lt; body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p><h4 id="document-scrollingElement"><a href="#document-scrollingElement" class="headerlink" title="document.scrollingElement"></a>document.scrollingElement</h4><p>document.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p><p>标准模式下，这个属性返回的文档的根元素document.documentElement（即<html>）。兼容（quirk）模式下，返回的是<body>元素，如果该元素不存在，返回null。</body></html></p><h4 id="document-activeElement"><a href="#document-activeElement" class="headerlink" title="document.activeElement"></a>document.activeElement</h4><p>document.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt; input&gt;、&lt; textarea&gt;、&lt; select&gt;等表单元素，如果当前没有焦点元素，返回&lt; body&gt;元素或null。</p><h4 id="document-fullscreenElement"><a href="#document-fullscreenElement" class="headerlink" title="document.fullscreenElement"></a>document.fullscreenElement</h4><p>document.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。</p><h2 id="节点集合属性"><a href="#节点集合属性" class="headerlink" title="节点集合属性"></a>节点集合属性</h2><p>以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p><h3 id="document-links"><a href="#document-links" class="headerlink" title="document.links"></a>document.links</h3><p>document.links属性返回当前文档所有设定了href属性的&lt; a&gt;及&lt; area&gt;节点。</p><h3 id="document-forms"><a href="#document-forms" class="headerlink" title="document.forms"></a>document.forms</h3><p>document.forms属性返回所有&lt; form&gt;表单节点。</p><h3 id="document-images"><a href="#document-images" class="headerlink" title="document.images"></a>document.images</h3><p>document.images属性返回页面所有&lt; img&gt;图片节点。</p><h3 id="document-embeds，document-plugins"><a href="#document-embeds，document-plugins" class="headerlink" title="document.embeds，document.plugins"></a>document.embeds，document.plugins</h3><p>document.embeds属性和document.plugins属性，都返回所有&lt; embed&gt;节点。</p><h3 id="document-scripts"><a href="#document-scripts" class="headerlink" title="document.scripts"></a>document.scripts</h3><p>document.scripts属性返回所有&lt; script&gt;节点。</p><h3 id="document-styleSheets"><a href="#document-styleSheets" class="headerlink" title="document.styleSheets"></a>document.styleSheets</h3><p>document.styleSheets属性返回文档内嵌或引入的样式表集合。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。</p><p>HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%886.03.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文档静态信息属性"><a href="#文档静态信息属性" class="headerlink" title="文档静态信息属性"></a>文档静态信息属性</h2><p>以下属性返回文档信息。</p><h3 id="document-documentURI，document-URL"><a href="#document-documentURI，document-URL" class="headerlink" title="document.documentURI，document.URL"></a>document.documentURI，document.URL</h3><p>document.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。</p><p>如果文档的锚点（#anchor）变化，这两个属性都会跟着变化。</p><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>document.domain属性返回当前文档的域名，不包含协议和接口。</p><p>比如，网页的网址是<a href="http://www.example.com:80/hello.html，" target="_blank" rel="noopener">http://www.example.com:80/hello.html，</a> 那么domain属性就等于<a href="http://www.example.com。如果无法获取域名，该属性返回null。" target="_blank" rel="noopener">www.example.com。如果无法获取域名，该属性返回null。</a></p><p>document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p><p>另外，设置document.domain会导致端口被改成null。因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同</p><h3 id="document-location"><a href="#document-location" class="headerlink" title="document.location"></a>document.location</h3><p>Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。</p><h3 id="document-lastModified"><a href="#document-lastModified" class="headerlink" title="document.lastModified"></a>document.lastModified</h3><p>document.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</p><p>注意，document.lastModified属性的值是字符串，所以不能直接用来比较。Date.parse方法将其转为Date实例，才能比较两个网页。</p><h3 id="document-title"><a href="#document-title" class="headerlink" title="document.title"></a>document.title</h3><p>document.title属性返回当前文档的标题。默认情况下，返回<title>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</title></p><h3 id="document-characterSet"><a href="#document-characterSet" class="headerlink" title="document.characterSet"></a>document.characterSet</h3><p>document.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。</p><h3 id="document-referrer"><a href="#document-referrer" class="headerlink" title="document.referrer"></a>document.referrer</h3><p>document.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。</p><h3 id="document-dir"><a href="#document-dir" class="headerlink" title="document.dir"></a>document.dir</h3><p>document.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p><h3 id="document-compatMode"><a href="#document-compatMode" class="headerlink" title="document.compatMode"></a>document.compatMode</h3><p>compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。</p><p>一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat。</p><h2 id="文档状态属性"><a href="#文档状态属性" class="headerlink" title="文档状态属性"></a>文档状态属性</h2><h3 id="document-hidden"><a href="#document-hidden" class="headerlink" title="document.hidden"></a>document.hidden</h3><p>document.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。</p><h3 id="document-visibilityState"><a href="#document-visibilityState" class="headerlink" title="document.visibilityState"></a>document.visibilityState</h3><p>document.visibilityState返回文档的可见状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%886.34.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</p><h3 id="document-readyState"><a href="#document-readyState" class="headerlink" title="document.readyState"></a>document.readyState</h3><p>document.readyState属性返回当前文档的状态，共有三种可能的值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-21%20%E4%B8%8B%E5%8D%886.35.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个属性变化的过程如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.19.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次状态变化都会触发一个readystatechange事件。</p><h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p>document.cookie属性用来操作浏览器 Cookie。</p><h3 id="document-designMode"><a href="#document-designMode" class="headerlink" title="document.designMode"></a>document.designMode</h3><p>document.designMode属性控制当前文档是否可编辑，通常用在所见即所得编辑器。该属性只有两个值on和off，默认值为off。</p><h3 id="document-implementation"><a href="#document-implementation" class="headerlink" title="document.implementation"></a>document.implementation</h3><p>document.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.24.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="document-open-，document-close"><a href="#document-open-，document-close" class="headerlink" title="document.open()，document.close()"></a>document.open()，document.close()</h3><p>document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。</p><p>document.close方法用来关闭document.open()打开的文档。</p><h3 id="document-write-，document-writeln"><a href="#document-write-，document-writeln" class="headerlink" title="document.write()，document.writeln()"></a>document.write()，document.writeln()</h3><p>document.write方法用于向当前文档写入内容。</p><p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。</p><p>注意，document.write会当作 HTML 代码解析，不会转义。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.27.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。</p><p>如果在页面渲染过程中调用write方法，并不会自动调用open方法。（可以理解成，open方法已调用，但close方法还未调用。）</p><p>document.write是JavaScript语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对innerHTML属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。</p><p>document.writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。</p><p>注意，writeln方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<br>。</p><h3 id="document-querySelector-，document-querySelectorAll"><a href="#document-querySelector-，document-querySelectorAll" class="headerlink" title="document.querySelector()，document.querySelectorAll()"></a>document.querySelector()，document.querySelectorAll()</h3><p>document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.53.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。</p><p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p><p>这两个方法都支持复杂的 CSS 选择器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8A%E5%8D%8811.55.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是，它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。</p><p>如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。</p><p>最后，这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。</p><h3 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName()"></a>document.getElementsByTagName()</h3><p>document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p><p>HTML 标签名是大小写不敏感的，因此getElementsByTagName方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p><p>注意，元素节点本身也定义了getElementsByTagName方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。</p><h3 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName()"></a>document.getElementsByClassName()</h3><p>document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p><p>由于class是保留字，所以 JavaScript 一律使用className表示 CSS 的class。</p><p>参数可以是多个class，它们之间使用空格分隔。</p><p>注意，正常模式下，CSS 的class是大小写敏感的。（quirks mode下，大小写不敏感。）</p><p>与getElementsByTagName方法一样，getElementsByClassName方法不仅可以在document对象上调用，也可以在任何元素节点上调用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%8812.08.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName()"></a>document.getElementsByName()</h3><p>document.getElementsByName方法用于选择拥有name属性的 HTML 元素,返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。</p><h3 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById()"></a>document.getElementById()</h3><p>document.getElementById方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。</p><p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的id属性是main，那么document.getElementById(‘Main’)将返回null。</p><p>document.getElementById方法与document.querySelector方法都能获取元素节点，不同之处是document.querySelector方法的参数使用 CSS 选择器语法，document.getElementById方法的参数是元素的id属性。document.getElementById()比document.querySelector()效率高得多。</p><p>另外，这个方法只能在document对象上使用，不能在其他元素节点上使用。</p><h3 id="document-elementFromPoint-，document-elementsFromPoint"><a href="#document-elementFromPoint-，document-elementsFromPoint" class="headerlink" title="document.elementFromPoint()，document.elementsFromPoint()"></a>document.elementFromPoint()，document.elementsFromPoint()</h3><p>document.elementFromPoint方法返回位于页面指定位置最上层的元素节点。</p><p>elementFromPoint方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回null。</p><p>document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p><h3 id="document-caretPositionFromPoint"><a href="#document-caretPositionFromPoint" class="headerlink" title="document.caretPositionFromPoint()"></a>document.caretPositionFromPoint()</h3><p>document.caretPositionFromPoint()返回一个 CaretPosition 对象，包含了指定坐标点在节点对象内部的位置信息。CaretPosition 对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。</p><p>CaretPosition 对象。该对象有两个属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.04.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h3><p>document.createElement方法用来生成元素节点，并返回该节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.05.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感，即参数为div或DIV返回的是同一种节点。如果参数里面包含尖括号（即&lt;和&gt;）会报错。</p><p>注意，document.createElement的参数可以是自定义的标签名。</p><h3 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h3><p>document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.07.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</p><h3 id="document-createAttribute"><a href="#document-createAttribute" class="headerlink" title="document.createAttribute()"></a>document.createAttribute()</h3><p>document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。</p><p>document.createAttribute方法的参数name，是属性的名称。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.09.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="document-createComment"><a href="#document-createComment" class="headerlink" title="document.createComment()"></a>document.createComment()</h3><p>document.createComment方法生成一个新的注释节点，并返回该节点。</p><p>document.createComment方法的参数是一个字符串，会成为注释节点的内容。</p><h3 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h3><p>document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。</p><p>DocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.12.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="document-createEvent"><a href="#document-createEvent" class="headerlink" title="document.createEvent()"></a>document.createEvent()</h3><p>document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。</p><p>document.createEvent方法的参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents。</p><h3 id="document-addEventListener-，document-removeEventListener-，document-dispatchEvent"><a href="#document-addEventListener-，document-removeEventListener-，document-dispatchEvent" class="headerlink" title="document.addEventListener()，document.removeEventListener()，document.dispatchEvent()"></a>document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h3><p>这三个方法用于处理document节点的事件。它们都继承自EventTarget接口。</p><h3 id="document-hasFocus"><a href="#document-hasFocus" class="headerlink" title="document.hasFocus()"></a>document.hasFocus()</h3><p>document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p><p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p><h3 id="document-adoptNode-，document-importNode"><a href="#document-adoptNode-，document-importNode" class="headerlink" title="document.adoptNode()，document.importNode()"></a>document.adoptNode()，document.importNode()</h3><p>document.adoptNode方法将某个节点及其子节点，从原来所在的文档或DocumentFragment里面移除，归属当前document对象，返回插入后的新节点。插入的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。</p><p>注意，document.adoptNode方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用appendChild方法或insertBefore方法，将新节点插入当前文档树。</p><p>document.importNode方法则是从原来所在的文档或DocumentFragment里面，拷贝某个节点及其子节点，让它们归属当前document对象。拷贝的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。</p><p>document.importNode方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为true。</p><p>注意，document.importNode方法只是拷贝外部节点，这时该节点的父节点是null。下一步还必须将这个节点插入当前文档树。</p><h3 id="document-createNodeIterator"><a href="#document-createNodeIterator" class="headerlink" title="document.createNodeIterator()"></a>document.createNodeIterator()</h3><p>document.createNodeIterator方法返回一个子节点遍历器。</p><p>document.createNodeIterator方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（NodeFilter.SHOW_ELEMENT）。几种主要的节点类型写法如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.35.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>document.createNodeIterator方法返回一个“遍历器”对象（NodeFilter实例）。该实例的nextNode()方法和previousNode()方法，可以用来遍历所有子节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347699009417/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.40.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>currentNode和previousNode都指向同一个的节点。</p><p>注意，遍历器返回的第一个节点，总是根节点。</p><h3 id="document-createTreeWalker"><a href="#document-createTreeWalker" class="headerlink" title="document.createTreeWalker()"></a>document.createTreeWalker()</h3><p>document.createTreeWalker方法返回一个 DOM 的子树遍历器。它与document.createNodeIterator方法基本是类似的，区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。另外，它的第一个节点不是根节点。</p><p>document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与document.createNodeIterator方法的第二个参数相同）。</p><h3 id="document-getSelection"><a href="#document-getSelection" class="headerlink" title="document.getSelection()"></a>document.getSelection()</h3><p>这个方法指向window.getSelection()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DOM模型概述&quot;&gt;&lt;a href=&quot;#DOM模型概述&quot; class=&quot;headerlink&quot; title=&quot;DOM模型概述&quot;&gt;&lt;/a&gt;DOM模型概述&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>健身</title>
    <link href="https://github.com/zdkswd/2018/08/21/%E5%81%A5%E8%BA%AB/"/>
    <id>https://github.com/zdkswd/2018/08/21/健身/</id>
    <published>2018-08-21T01:49:12.000Z</published>
    <updated>2018-08-21T01:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><p>关注引领性指标</p><p>3900大卡差值消耗一斤脂肪。</p><p>计算每日消耗总热量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348093471499.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>计算摄入量<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348095297404.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果差值过大，会导致肌肉减少和基础代谢率降低，很容易反弹，难以持续。</p><p>随着体重降低，也要不断的调整。</p><p>把摄入热量除以3得到每餐要吃的热量。</p><p>三餐热量不同也可以，只要一天内摄入不超过即可。</p><p>每餐一个拳头的蛋白质，一个拳头的碳水化合物，蔬菜随便吃。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348099519577.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>蛋白质的主要来源 精瘦的鸡肉，猪肉，牛肉，海鲜，鱼，鸡蛋，牛奶，豆类。</p><p>碳水化合物尽量选择粗粮，比如说玉米，红薯，土豆，糙米，米粉，面条，面包。</p><p>追踪自己的减脂进展。</p><h2 id="超实用技巧"><a href="#超实用技巧" class="headerlink" title="超实用技巧"></a>超实用技巧</h2><p>餐前吃半根香蕉或者一粒糖。</p><p>第二个，每餐前吃六到七粒坚果。增加饱腹感。英国有研究表明每天吃20粒坚果能降低癌症和心脏病的风险。</p><p>第三个，用南瓜代替主食。</p><p>第四点，少油盐，外食要过水，油的热量远远大于菜的热量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348110037373.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>图中的食物可以随便吃。无限量吃。</p><p>第六个，嚼无糖口香糖，咀嚼感。</p><h2 id="瘦了后保持体形"><a href="#瘦了后保持体形" class="headerlink" title="瘦了后保持体形"></a>瘦了后保持体形</h2><p>保持期可以放宽，不需要赤字了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15348080259493/15348113398115.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>早睡11点</li><li>吃早饭</li><li>冥想拉伸</li><li>少盐多蛋白质</li><li>跳绳</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;健身&quot;&gt;&lt;a href=&quot;#健身&quot; class=&quot;headerlink&quot; title=&quot;健身&quot;&gt;&lt;/a&gt;健身&lt;/h1&gt;&lt;p&gt;关注引领性指标&lt;/p&gt;
&lt;p&gt;3900大卡差值消耗一斤脂肪。&lt;/p&gt;
&lt;p&gt;计算每日消耗总热量。&lt;br&gt;&lt;figure class=&quot;ima
      
    
    </summary>
    
      <category term="知乎Live" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E4%B9%8ELive/"/>
    
    
      <category term="健身" scheme="https://github.com/zdkswd/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 语法专题</title>
    <link href="https://github.com/zdkswd/2018/08/20/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <id>https://github.com/zdkswd/2018/08/20/JavaScript标准参考教程 语法专题/</id>
    <published>2018-08-20T11:14:56.000Z</published>
    <updated>2018-08-20T11:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步操作概述"><a href="#异步操作概述" class="headerlink" title="异步操作概述"></a>异步操作概述</h1><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p><p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p><p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p><p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h2 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h2><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件。</p><h2 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h2><p>下面总结一下异步操作的几种模式。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是异步操作最基本的方法。</p><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><p>首先，为f1绑定一个事件（这里采用的 jQuery 的写法）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.52.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.53.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。</p><p>这个模式有多种实现，下面采用的是 Ben Alman 的 Tiny Pub/Sub，这是 jQuery 的一个插件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.56.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.56.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>f2完成执行后，可以取消订阅（unsubscribe）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8A%E5%8D%889.57.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><h2 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h2><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p><h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。</p><p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p><h3 id="并行与串行的结合"><a href="#并行与串行的结合" class="headerlink" title="并行与串行的结合"></a>并行与串行的结合</h3><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。</p><p>上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。</p><p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节limit变量，达到效率和资源的最佳平衡。</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p>setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p><p>setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。</p><p>除了前两个参数，setTimeout还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p><p>还有一个需要注意的地方，如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。</p><p>为了防止出现这个问题，一种解决方法是将obj.y放入一个函数。obj.y放在一个匿名函数之中，这使得obj.y在obj的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p><p>另一种解决方法是，使用bind方法，将obj.y这个方法绑定在obj上面。</p><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p>setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p><p>与setTimeout一样，除了前两个参数，setInterval方法还可以接受更多的参数，它们会传入回调函数。</p><h2 id="clearTimeout-，clearInterval"><a href="#clearTimeout-，clearInterval" class="headerlink" title="clearTimeout()，clearInterval()"></a>clearTimeout()，clearInterval()</h2><p>setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。</p><p>连续调用三次setTimeout，返回值都比上一次大了1。</p><p>利用这一点，可以写一个函数，取消当前所有的setTimeout定时器。</p><h2 id="实例：debounce-函数"><a href="#实例：debounce-函数" class="headerlink" title="实例：debounce 函数"></a>实例：debounce 函数</h2><p>有时，我们不希望回调函数被频繁调用。如果用户连续击键，就会连续触发keydown事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的keydown事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，再将数据发送出去。</p><p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%884.50.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p><p>这意味着，setTimeout和setInterval指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。</p><h2 id="setTimeout-f-0"><a href="#setTimeout-f-0" class="headerlink" title="setTimeout(f, 0)"></a>setTimeout(f, 0)</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f, 0)，那么会立刻执行吗？</p><p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行setTimeout指定的回调函数f。也就是说，setTimeout(f, 0)会在下一轮事件循环一开始就执行。</p><p>setTimeout(f, 0)这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f。</p><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p><p>首先，Promise 是一个对象，也是一个构造函数。</p><p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.02.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p><p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p><h2 id="Promise-对象的状态"><a href="#Promise-对象的状态" class="headerlink" title="Promise 对象的状态"></a>Promise 对象的状态</h2><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.04.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。</p><p>这三种的状态的变化途径只有两种。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.04.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p><p>因此，Promise 的最终结果只有两种。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.05.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h2><p>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.20.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例的then方法，用来添加回调函数。</p><p>then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p><p>then方法可以链式使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.26.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。</p><p>最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。</p><h2 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then() 用法辨析"></a>then() 用法辨析</h2><p>Promise 的用法，简单说就是一句话：使用then方法添加回调函数。</p><h2 id="Promise-的实例"><a href="#Promise-的实例" class="headerlink" title="Promise 的实例"></a>Promise 的实例</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%885.33.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Ajax-操作"><a href="#Ajax-操作" class="headerlink" title="Ajax 操作"></a>Ajax 操作</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p><p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的</p><p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p><p>是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p><p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%886.42.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p><h2 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h2><p>进入严格模式的标志，是一行字符串use strict。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15347284055768/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-20%20%E4%B8%8B%E5%8D%886.43.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p><p>严格模式可以用于整个脚本，也可以只用于单个函数。</p><h3 id="整个脚本文件"><a href="#整个脚本文件" class="headerlink" title="整个脚本文件"></a>整个脚本文件</h3><p>use strict放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。</p><h3 id="单个函数"><a href="#单个函数" class="headerlink" title="单个函数"></a>单个函数</h3><p>use strict放在函数体的第一行，则整个函数以严格模式运行。</p><p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p><h2 id="显式报错"><a href="#显式报错" class="headerlink" title="显式报错"></a>显式报错</h2><p>严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。</p><h3 id="只读属性不可写"><a href="#只读属性不可写" class="headerlink" title="只读属性不可写"></a>只读属性不可写</h3><p>严格模式下，设置字符串的length属性，会报错。正常模式下，改变length属性是无效的，但不会报错。</p><p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p><h3 id="只设置了取值器的属性不可写"><a href="#只设置了取值器的属性不可写" class="headerlink" title="只设置了取值器的属性不可写"></a>只设置了取值器的属性不可写</h3><p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p><h3 id="禁止扩展的对象不可扩展"><a href="#禁止扩展的对象不可扩展" class="headerlink" title="禁止扩展的对象不可扩展"></a>禁止扩展的对象不可扩展</h3><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p><h3 id="eval、arguments-不可用作标识名"><a href="#eval、arguments-不可用作标识名" class="headerlink" title="eval、arguments 不可用作标识名"></a>eval、arguments 不可用作标识名</h3><p>严格模式下，使用eval或者arguments作为标识名，将会报错。下面的语句都会报错。</p><h3 id="函数不能有重名的参数"><a href="#函数不能有重名的参数" class="headerlink" title="函数不能有重名的参数"></a>函数不能有重名的参数</h3><p>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。</p><h3 id="禁止八进制的前缀0表示法"><a href="#禁止八进制的前缀0表示法" class="headerlink" title="禁止八进制的前缀0表示法"></a>禁止八进制的前缀0表示法</h3><p>正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。</p><h2 id="增强的安全措施"><a href="#增强的安全措施" class="headerlink" title="增强的安全措施"></a>增强的安全措施</h2><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。</p><h3 id="全局变量显式声明"><a href="#全局变量显式声明" class="headerlink" title="全局变量显式声明"></a>全局变量显式声明</h3><p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p><p>因此，严格模式下，变量都必须先声明，然后再使用。</p><h3 id="禁止-this-关键字指向全局对象"><a href="#禁止-this-关键字指向全局对象" class="headerlink" title="禁止 this 关键字指向全局对象"></a>禁止 this 关键字指向全局对象</h3><p>正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p><p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加new，这时this不再指向全局对象，而是报错。</p><h3 id="禁止使用-fn-callee、fn-caller"><a href="#禁止使用-fn-callee、fn-caller" class="headerlink" title="禁止使用 fn.callee、fn.caller"></a>禁止使用 fn.callee、fn.caller</h3><p>函数内部不得使用fn.caller、fn.arguments，否则会报错。这意味着不能在函数内部得到调用栈了。</p><h3 id="禁止使用-arguments-callee、arguments-caller"><a href="#禁止使用-arguments-callee、arguments-caller" class="headerlink" title="禁止使用 arguments.callee、arguments.caller"></a>禁止使用 arguments.callee、arguments.caller</h3><p>arguments.callee和arguments.caller是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用arguments.callee、arguments.caller将会报错。</p><h3 id="禁止删除变量"><a href="#禁止删除变量" class="headerlink" title="禁止删除变量"></a>禁止删除变量</h3><p>严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。</p><h2 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h2><p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p><p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p><h3 id="禁止使用-with-语句"><a href="#禁止使用-with-语句" class="headerlink" title="禁止使用 with 语句"></a>禁止使用 with 语句</h3><p>严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p><h3 id="创设-eval-作用域"><a href="#创设-eval-作用域" class="headerlink" title="创设 eval 作用域"></a>创设 eval 作用域</h3><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。</p><p>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。</p><h3 id="arguments-不再追踪参数的变化"><a href="#arguments-不再追踪参数的变化" class="headerlink" title="arguments 不再追踪参数的变化"></a>arguments 不再追踪参数的变化</h3><p>变量arguments代表函数的参数。严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系。</p><h2 id="向下一个版本的-JavaScript-过渡"><a href="#向下一个版本的-JavaScript-过渡" class="headerlink" title="向下一个版本的 JavaScript 过渡"></a>向下一个版本的 JavaScript 过渡</h2><p>JavaScript语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p><h3 id="非函数代码块不得声明函数"><a href="#非函数代码块不得声明函数" class="headerlink" title="非函数代码块不得声明函数"></a>非函数代码块不得声明函数</h3><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。</p><p>ES6 允许在代码块之中声明函数。</p><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异步操作概述&quot;&gt;&lt;a href=&quot;#异步操作概述&quot; class=&quot;headerlink&quot; title=&quot;异步操作概述&quot;&gt;&lt;/a&gt;异步操作概述&lt;/h1&gt;&lt;h2 id=&quot;单线程模型&quot;&gt;&lt;a href=&quot;#单线程模型&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title> JavaScript标准参考教程 面向对象编程</title>
    <link href="https://github.com/zdkswd/2018/08/19/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/08/19/JavaScript标准参考教程 面向对象编程/</id>
    <published>2018-08-19T15:33:56.000Z</published>
    <updated>2018-08-19T15:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数与-new-命令"><a href="#构造函数与-new-命令" class="headerlink" title="构造函数与 new 命令"></a>构造函数与 new 命令</h1><p>JavaScript 语言具有很强的面向对象编程能力。</p><h2 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h2><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p><p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p><p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p><p>为了与普通函数区别，构造函数名字的第一个字母通常大写。</p><p>构造函数的特点有两个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.13.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>new命令的作用，就是执行构造函数，返回一个实例对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.14.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用new命令时，根据需要，构造函数也可以接受参数。</p><p>new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p><p>如果忘了使用new命令，构造函数就变成了普通函数，并不会生成实例对象。this这时代表全局对象，将造成一些意想不到的结果。</p><p>因此，应该非常小心，避免不使用new命令、直接调用构造函数。</p><p>为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.18.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。</p><p>不管加不加new命令，都会得到同样的结果。</p><h3 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h3><p>使用new命令时，它后面的函数依次执行下面的步骤。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%883.19.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。</p><p>如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。这一点需要特别引起<strong>注意</strong>。</p><p>另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。</p><p>使用这个属性，可以判断函数调用的时候，是否使用new命令。</p><h2 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h2><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。</p><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><h2 id="涵义"><a href="#涵义" class="headerlink" title="涵义"></a>涵义</h2><p>this都有一个共同点：它总是返回一个对象。</p><p>简单说，this就是属性或方法“当前”所在的对象。</p><p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。</p><p>总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。</p><h2 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h2><h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>全局环境使用this，它指的就是顶层对象window。</p><p>不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。</p><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数中的this，指的是实例对象。</p><h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</p><p>如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.20.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b。</p><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><h3 id="避免多层-this"><a href="#避免多层-this" class="headerlink" title="避免多层 this"></a>避免多层 this</h3><p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。内层的this直接指向顶层对象<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.10.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>因为实际执行的是下面的代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.34.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.09.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。</p><h3 id="避免数组处理方法中的-this"><a href="#避免数组处理方法中的-this" class="headerlink" title="避免数组处理方法中的 this"></a>避免数组处理方法中的 this</h3><p>数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%884.37.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最主要的问题就是函数表达式的出现，此时变成了全局环境。</span><br></pre></td></tr></table></figure><p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。</p><p>另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</p><h3 id="避免回调函数中的-this"><a href="#避免回调函数中的-this" class="headerlink" title="避免回调函数中的 this"></a>避免回调函数中的 this</h3><p>回调函数中的this往往会改变指向，最好避免使用。</p><h2 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定this的方法</h2><p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p><h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.23.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.24.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。</p><p>call方法还可以接受多个参数。</p><p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p><p><strong>call方法的一个应用是调用对象的原生方法。</strong></p><p>继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.29.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p><p>apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8B%E5%8D%885.31.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>利用这一点，可以做一些有趣的应用。</p><h4 id="找出数组最大元素"><a href="#找出数组最大元素" class="headerlink" title="找出数组最大元素"></a>找出数组最大元素</h4><p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p><h4 id="将数组的空元素变为undefined"><a href="#将数组的空元素变为undefined" class="headerlink" title="将数组的空元素变为undefined"></a>将数组的空元素变为undefined</h4><p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p><p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。</p><h4 id="转换类似数组的对象"><a href="#转换类似数组的对象" class="headerlink" title="转换类似数组的对象"></a>转换类似数组的对象</h4><p>另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p><h4 id="绑定回调函数的对象"><a href="#绑定回调函数的对象" class="headerlink" title="绑定回调函数的对象"></a>绑定回调函数的对象</h4><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</p><p>bind还可以接受更多的参数，将这些参数绑定原函数的参数。</p><p>bind还可以接受更多的参数，将这些参数绑定原函数的参数。</p><p>bind方法有一些使用注意点。</p><h4 id="每一次返回一个新函数"><a href="#每一次返回一个新函数" class="headerlink" title="每一次返回一个新函数"></a>每一次返回一个新函数</h4><p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。</p><h4 id="结合回调函数使用"><a href="#结合回调函数使用" class="headerlink" title="结合回调函数使用"></a>结合回调函数使用</h4><p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。</p><h4 id="结合call方法使用"><a href="#结合call方法使用" class="headerlink" title="结合call方法使用"></a>结合call方法使用</h4><h1 id="prototype-对象"><a href="#prototype-对象" class="headerlink" title="prototype 对象"></a>prototype 对象</h1><p>面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。</p><p>大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。JavaScript 语言的继承则是通过“原型对象”（prototype）。</p><h2 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h2><h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8812.28.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。</p><p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p><h3 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h3><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p><p>JavaScript 规定，每个<strong>函数</strong>都有一个prototype属性，指向一个对象。</p><p>对于普通函数来说，该属性基本无用。但是，对于<strong>构造函数</strong>来说，生成实例的时候，<strong>该属性会自动成为类类。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类类是自创的概念，类似于类的东西，即指不管实例对象是否存在，它都客观存在的实例对象的原型。</span><br></pre></td></tr></table></figure></p><p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</p><p>当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p><p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p><p>原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。</p><p>那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。</p><p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p><p><strong>注意</strong>，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。</p><p>由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。</p><p>constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p><p>constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%881.12.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>构造函数Person的原型对象改掉了，但是没有修改constructor属性，导致这个属性不再指向Person。由于Person的新原型是一个普通对象，而普通对象的contructor属性指向Object构造函数，导致Person.prototype.constructor变成了Object。</p><p>修改原型对象时，一般要同时修改constructor属性的指向。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%881.12.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法。</p><p>如果不能确定constructor属性是什么函数，还有一个办法：通过name属性，从实例得到构造函数的名称。</p><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p><p>instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。</p><p>只要一个对象的原型不是null，instanceof运算符的判断就不会失真。</p><p>instanceof运算符的一个用处，是判断值的类型。</p><p><strong>注意</strong>，instanceof运算符只能用于对象，不适用原始类型的值。</p><p>对于undefined和null，instanceOf运算符总是返回false。</p><p>利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%882.49.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h1><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.59.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.07.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><p>Object.setPrototypeOf方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p><p>new命令可以使用Object.setPrototypeOf方法模拟。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.15.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>new命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的prototype属性（上例是F.prototype）；第二步，将构造函数内部的this绑定这个空对象，然后执行构造函数，使得定义在this上面的方法和属性（上例是this.foo），都转移到这个空对象上。</p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>JavaScript 提供了Object.create方法，该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p><p>下面三种方式生成的新对象是等价的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.29.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。</p><p>使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p><p>Object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p><p>除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Object.create方法生成的对象，继承了它的原型对象的构造函数。</p><h2 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h2><p>实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。</p><p>只要实例对象处在参数对象的原型链上，isPrototypeOf方法都返回true。</p><h2 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.proto"></a>Object.prototype.<strong>proto</strong></h2><p>实例对象的<strong>proto</strong>属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p><p>根据语言标准，<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()和Object.setPrototypeOf()，进行原型对象的读写操作。</p><h2 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h2><p>获取实例对象obj的原型对象，有三种方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%883.48.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>前两种都不是很可靠。<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。</p><p>推荐使用第三种Object.getPrototypeOf方法，获取原型对象。</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>Object.getOwnPropertyNames方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p><p>Object.getOwnPropertyNames方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用Object.keys方法。</p><h2 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h2><p>对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p><p><strong>注意</strong>，hasOwnProperty方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p><h2 id="in-运算符和-for…in-循环"><a href="#in-运算符和-for…in-循环" class="headerlink" title="in 运算符和 for…in 循环"></a>in 运算符和 for…in 循环</h2><p>in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</p><p>in运算符常用于检查一个属性是否存在。</p><p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for…in循环。</p><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>如果要拷贝一个对象，需要做到下面两件事情。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%884.08.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="面向对象编程的模式"><a href="#面向对象编程的模式" class="headerlink" title="面向对象编程的模式"></a>面向对象编程的模式</h1><h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>让一个构造函数继承另一个构造函数，是非常常见的需求。</p><p>这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.41.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> JavaScript 中对象的赋值是默认引用赋值的，如果你想要复制赋值，则必须要重新分配对象</span><br></pre></td></tr></table></figure><p>另外一种写法是Sub.prototype等于一个父类实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.50.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p><p>有时只需要单个方法的继承，这时可以采用下面的写法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.51.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面代码中，子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8810.52.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种模式又称为 Mixin（混入）。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>JavaScript不是一种模块化编程语言，ES5不支持”类”（class），更遑论”模块”（module）了。ES6正式支持”类”和”模块”，但还没有成为主流。</p><h3 id="基本的实现方法"><a href="#基本的实现方法" class="headerlink" title="基本的实现方法"></a>基本的实现方法</h3><p>模块是实现特定功能的一组属性和方法的封装。</p><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p><p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p><p>上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。</p><p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p><h3 id="封装私有变量：构造函数的写法"><a href="#封装私有变量：构造函数的写法" class="headerlink" title="封装私有变量：构造函数的写法"></a>封装私有变量：构造函数的写法</h3><p>我们可以利用构造函数，封装私有变量。</p><p>这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。</p><h3 id="封装私有变量：立即执行函数的写法"><a href="#封装私有变量：立即执行函数的写法" class="headerlink" title="封装私有变量：立即执行函数的写法"></a>封装私有变量：立即执行函数的写法</h3><p>使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.03.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面的module1就是JavaScript模块的基本写法。下面，再对这种写法进行加工。</p><h3 id="模块的放大模式"><a href="#模块的放大模式" class="headerlink" title="模块的放大模式"></a>模块的放大模式</h3><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.28.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.29.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p><h3 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h3><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15344898704884/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-19%20%E4%B8%8B%E5%8D%8811.30.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数与-new-命令&quot;&gt;&lt;a href=&quot;#构造函数与-new-命令&quot; class=&quot;headerlink&quot; title=&quot;构造函数与 new 命令&quot;&gt;&lt;/a&gt;构造函数与 new 命令&lt;/h1&gt;&lt;p&gt;JavaScript 语言具有很强的面向对象编程能力。&lt;/p
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 标准参考教程 标准库</title>
    <link href="https://github.com/zdkswd/2018/08/17/JavaScript%20%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>https://github.com/zdkswd/2018/08/17/JavaScript 标准参考教程 标准库/</id>
    <published>2018-08-17T04:02:56.000Z</published>
    <updated>2018-08-17T04:09:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 原生提供Object对象（注意起首的O是大写）。</p><p>JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。</p><p>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。</p><h3 id="Object对象本身的方法"><a href="#Object对象本身的方法" class="headerlink" title="Object对象本身的方法"></a>Object对象本身的方法</h3><h3 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h3><h2 id="Object（）"><a href="#Object（）" class="headerlink" title="Object（）"></a>Object（）</h2><p>Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p><p>如果参数为空（或者为undefined和null），Object()返回一个空对象。</p><p>instanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例。</p><p>如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例。</p><p>如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。</p><p>利用这一点，可以写一个判断变量是否为对象的函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.50.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Object构造函数"><a href="#Object构造函数" class="headerlink" title="Object构造函数"></a>Object构造函数</h2><p>Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。</p><p>Object构造函数的首要用途，是直接通过它来生成新对象。</p><p>注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。或者说，后者只是前者的一种简便写法。</p><h2 id="Object的静态方法"><a href="#Object的静态方法" class="headerlink" title="Object的静态方法"></a>Object的静态方法</h2><p>所谓“静态方法”，是指部署在Object对象自身的方法。</p><h3 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h3><p>Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。</p><p>Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。</p><p>对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。</p><p>由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="对象属性模型的相关方法"><a href="#对象属性模型的相关方法" class="headerlink" title="对象属性模型的相关方法"></a>对象属性模型的相关方法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.54.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="控制对象状态的方法"><a href="#控制对象状态的方法" class="headerlink" title="控制对象状态的方法"></a>控制对象状态的方法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.56.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="原型链相关方法"><a href="#原型链相关方法" class="headerlink" title="原型链相关方法"></a>原型链相关方法</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%886.56.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Object的实例方法-1"><a href="#Object的实例方法-1" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h2><p>除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。</p><p>Object实例对象的方法，主要有以下六个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.02.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p>valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p><p>valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.05.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p>toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</p><p>通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p><p>数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。覆盖原始方法。</p><h3 id="toString-的应用：判断数据类型"><a href="#toString-的应用：判断数据类型" class="headerlink" title="toString() 的应用：判断数据类型"></a>toString() 的应用：判断数据类型</h3><p>Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p><p>由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.12.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不同数据类型的Object.prototype.toString方法返回值如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.13.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。</p><h3 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h3><p>Object.prototype.toLocaleString方法与toString的返回结果相同，也是返回一个值的字符串形式。</p><p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%887.21.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>举例来说，日期的实例对象的toString和toLocaleString返回值就不一样，而且toLocaleString的返回值跟用户设定的所在地域相关。</p><h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。而不显示继承而来的属性。</p><h1 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p><p>Array构造函数的参数2，表示生成一个两个成员的数组，每个位置都是空值。</p><p>如果没有使用new，运行结果也是一样的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%8810.41.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%8810.42.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8B%E5%8D%8810.44.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p>Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。</p><p>typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h3><p>valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。</p><p>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p><h3 id="push-，pop"><a href="#push-，pop" class="headerlink" title="push()，pop()"></a>push()，pop()</h3><p>push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p><p>pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</p><p>对空数组使用pop方法，不会报错，而是返回undefined。</p><h3 id="shift-，unshift"><a href="#shift-，unshift" class="headerlink" title="shift()，unshift()"></a>shift()，unshift()</h3><p>shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p><p>shift方法可以遍历并清空一个数组。</p><p>push和shift结合使用，就构成了“先进先出”的队列结构（queue）。</p><p>unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p><p>unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。</p><h3 id="join（）"><a href="#join（）" class="headerlink" title="join（）"></a>join（）</h3><p>join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p><p>如果数组成员是undefined或null或空位，会被转成空字符串。</p><p>通过call方法，这个方法也可以用于字符串或类似数组的对象。</p><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p><p>除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。</p><p>如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</p><p>它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p><p>如果slice方法的参数是负数，则表示倒数计算的位置。</p><p>slice没有参数，实际上等于返回一个原数组的拷贝。</p><p>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。</p><p>slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%882.32.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>起始位置如果是负数，就表示从倒数位置开始删除。</p><p>如果只是单纯地插入元素，splice方法的第二个参数可以设为0。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p><p>sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。</p><p>如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%882.36.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个<strong>新数组</strong>返回。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%882.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。</p><p>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量。</p><p>如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。</p><p>map方法不会跳过undefined和null，但是会跳过空位。</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法<strong>不返回值，只用来操作数据</strong>。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。</p><p>forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</p><p>forEach方法也可以接受第二个参数，绑定参数函数的this变量。</p><p>forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。</p><p>forEach方法也会跳过数组的空位。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p><p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法<strong>不会改变原数组</strong>。</p><p>filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</p><p>filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</p><h3 id="some-，every"><a href="#some-，every" class="headerlink" title="some()，every()"></a>some()，every()</h3><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p><p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p><p>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</p><p>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</p><p>注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。</p><p>some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</p><h3 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h3><p>reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p><p>reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.03.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p><p>如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。</p><p>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。</p><h3 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h3><p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p><p>indexOf方法还可以接受第二个参数，表示搜索的开始位置。</p><p>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p><p><strong>注意</strong>，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。</p><p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</p><h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p><p>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.25.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。</p><p><strong>Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。</strong></p><p>即，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</p><h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><p>包装对象的实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。</p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p>valueOf方法返回包装对象实例对应的原始类型的值。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>toString方法返回对应的字符串形式。</p><h2 id="原始类型与实例对象的自动转换"><a href="#原始类型与实例对象的自动转换" class="headerlink" title="原始类型与实例对象的自动转换"></a>原始类型与实例对象的自动转换</h2><p>原始类型的值，可以自动当作包装对象调用，即调用各种包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。</p><p>比如，字符串可以调用length属性，返回字符串的长度。</p><p>abc是一个字符串，本身不是对象，不能调用length属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p><p>自动转换生成的包装对象是<strong>只读</strong>的，无法修改。所以，字符串无法添加新属性。</p><p>调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。</p><h2 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>三种包装对象除了提供很多原生的实例方法，还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。</p><p>这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。</p><h2 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。</p><h3 id="Boolean-函数的类型转换作用"><a href="#Boolean-函数的类型转换作用" class="headerlink" title="Boolean 函数的类型转换作用"></a>Boolean 函数的类型转换作用</h3><p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。</p><h1 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p><p>作为构造函数时，它用于生成值为数值的对象。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.44.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实例方法-2"><a href="#实例方法-2" class="headerlink" title="实例方法"></a>实例方法</h2><p>Number对象有4个实例方法，都跟将数值转换成指定格式有关。</p><h3 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h3><p>Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。</p><p>toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%883.46.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。</p><p>除了为10加上括号，还可以在10后面加两个点，JavaScript 会把第一个点理解成小数点（即10.0），把第二个点理解成调用对象属性，从而得到正确结果。</p><p>意味着，可以直接对一个小数使用toString方法。</p><p>通过方括号运算符也可以调用toString方法。</p><p>toString方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用parseInt方法。</p><h3 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h3><p>toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p><h3 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h3><p>toExponential方法用于将一个数转为科学计数法形式。</p><p>toExponential方法的参数是小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个 RangeError 错误。</p><h3 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h3><p>toPrecision方法用于将一个数转为指定位数的有效数字。</p><p>toPrecision方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出 RangeError 错误。</p><p>toPrecision方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p><h2 id="自定义方法-1"><a href="#自定义方法-1" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。 </p><p>注意，数值的自定义方法，只能定义在它的原型对象Number.prototype上面，数值本身是无法自定义属性的。</p><h1 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p><p>字符串对象是一个类似数组的对象（很像数组，但不是数组）。</p><p>String对象还可以当作工具方法使用，将任意类型的值转为字符串。</p><h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h3><p>该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p><p>String.fromCharCode方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。</p><p><strong>注意</strong>，该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）。</p><p>String.fromCharCode发现参数值大于0xFFFF，就会忽略多出的位（即忽略0x20BB7里面的2）。</p><p>码点大于0xFFFF的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把0x20BB7拆成两个字符表示。</p><p>码点大于0xFFFF的字符的四字节表示法，由 UTF-16 编码方法决定。</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="String-prototype-length"><a href="#String-prototype-length" class="headerlink" title="String.prototype.length"></a>String.prototype.length</h3><p>字符串实例的length属性返回字符串的长度。</p><h2 id="实例方法-3"><a href="#实例方法-3" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="String-prototype-charAt"><a href="#String-prototype-charAt" class="headerlink" title="String.prototype.charAt()"></a>String.prototype.charAt()</h3><p>charAt方法返回指定位置的字符，参数是从0开始编号的位置。</p><p>如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。</p><h3 id="String-prototype-charCodeAt"><a href="#String-prototype-charCodeAt" class="headerlink" title="String.prototype.charCodeAt()"></a>String.prototype.charCodeAt()</h3><p>charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。</p><p>如果没有任何参数，charCodeAt返回首字符的 Unicode 码点。</p><p>如果参数为负数，或大于等于字符串的长度，charCodeAt返回NaN。</p><p>charCodeAt方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必需连续使用两次charCodeAt，不仅读入charCodeAt(i)，还要读入charCodeAt(i+1)，将两个值放在一起，才能得到准确的字符。</p><h3 id="String-prototype-concat"><a href="#String-prototype-concat" class="headerlink" title="String.prototype.concat()"></a>String.prototype.concat()</h3><p>concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p><p>如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%884.26.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h3><p>slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p><p>如果省略第二个参数，则表示子字符串一直到原字符串结束。</p><p>如果参数是负值，表示从结尾开始倒数计算的位置。</p><p>如果第一个参数大于第二个参数，slice方法返回一个空字符串。</p><h3 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h3><p>substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</p><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p><p>如果第一个参数大于第二个参数，substring方法会自动更换两个参数的位置。</p><p>如果参数是负数，substring方法会自动将负数转为0。</p><p>由于这些规则违反直觉，因此不建议使用substring方法，应该优先使用slice。</p><h3 id="String-prototype-substr"><a href="#String-prototype-substr" class="headerlink" title="String.prototype.substr()"></a>String.prototype.substr()</h3><p>substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。</p><p>substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。</p><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p><p>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</p><h3 id="String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>String.prototype.indexOf()，String.prototype.lastIndexOf()</h3><p>indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p><p>indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。</p><p>lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。</p><p>lastIndexOf的第二个参数表示从该位置起向前匹配。</p><h3 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h3><p>trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p><p>该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。</p><h3 id="String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>String.prototype.toLowerCase()，String.prototype.toUpperCase()</h3><p>toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p><h3 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p>match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</p><p>match方法还可以使用正则表达式作为参数。</p><h3 id="String-prototype-search-，String-prototype-replace"><a href="#String-prototype-search-，String-prototype-replace" class="headerlink" title="String.prototype.search()，String.prototype.replace()"></a>String.prototype.search()，String.prototype.replace()</h3><p>search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</p><p>search方法还可以使用正则表达式作为参数。</p><p>replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配。</p><p>replace方法还可以使用正则表达式作为参数。</p><h3 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p>split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p><p>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</p><p>如果省略参数，则返回数组的唯一成员就是原字符串。</p><p>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。</p><p>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。</p><p>split方法还可以接受第二个参数，限定返回数组的最大成员数。</p><p>split方法还可以使用正则表达式作为参数。</p><h3 id="String-prototype-localeCompare"><a href="#String-prototype-localeCompare" class="headerlink" title="String.prototype.localeCompare()"></a>String.prototype.localeCompare()</h3><p>localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</p><p>该方法的最大特点，就是会<strong>考虑自然语言的顺序</strong>。举例来说，正常情况下，大写的英文字母小于小写字母。</p><p>JavaScript 采用的是 Unicode 码点比较但是，localeCompare方法会考虑自然语言的排序情况，大写字母比小写字母大。</p><p>localeCompare还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</p><h1 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h1><p>Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，<strong>不能生成实例</strong>，所有的属性和方法都必须在Math对象上调用。</p><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.10.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这些属性都是只读的，不能修改。</p><h2 id="静态方法-2"><a href="#静态方法-2" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.11.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。</p><p>Math.floor方法返回小于参数值的最大整数（地板值）。</p><p>Math.ceil方法返回大于参数值的最小整数（天花板值）。</p><p>Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。</p><p>Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。</p><p>如果要计算以10为底的对数，可以先用Math.log求出自然对数，然后除以Math.LN10；求以2为底的对数，可以除以Math.LN2。</p><p>Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p><h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.16.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h1><p>Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p><h2 id="普通函数的用法"><a href="#普通函数的用法" class="headerlink" title="普通函数的用法"></a>普通函数的用法</h2><p>Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</p><p>即使带有参数，Date作为普通函数使用时，返回的还是当前时间。</p><p>无论有没有参数，直接调用Date总是返回当前时间。</p><h2 id="构造函数的用法"><a href="#构造函数的用法" class="headerlink" title="构造函数的用法"></a>构造函数的用法</h2><p>Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。</p><p>Date实例有一个独特的地方。其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。</p><p>作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.48.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>关于Date构造函数的参数，</p><p>第一点，参数可以是负整数，代表1970年元旦之前的时间。</p><p>第二点，只要是能被Date.parse()方法解析的字符串，都可以当作参数。</p><p>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。</p><p>各个参数的取值范围如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.49.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。</p><p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。</p><p>日期设为0，就代表上个月的最后一天。</p><p>参数还可以使用负数，表示扣去的时间。</p><h2 id="日期的运算"><a href="#日期的运算" class="headerlink" title="日期的运算"></a>日期的运算</h2><p>类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。</p><h2 id="静态方法-3"><a href="#静态方法-3" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h3><p>Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p><h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h3><p>Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。</p><p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%887.55.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果解析失败，返回NaN。</p><h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><p>Date.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</p><p>该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。</p><h2 id="实例方法-4"><a href="#实例方法-4" class="headerlink" title="实例方法"></a>实例方法</h2><p>Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%8810.12.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf()"></a>Date.prototype.valueOf()</h3><p>valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。</p><h3 id="to-类方法"><a href="#to-类方法" class="headerlink" title="to 类方法"></a>to 类方法</h3><h4 id="Date-prototype-toString"><a href="#Date-prototype-toString" class="headerlink" title="Date.prototype.toString()"></a>Date.prototype.toString()</h4><p>toString方法返回一个完整的日期字符串。</p><h4 id="Date-prototype-toUTCString"><a href="#Date-prototype-toUTCString" class="headerlink" title="Date.prototype.toUTCString()"></a>Date.prototype.toUTCString()</h4><p>toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。</p><h4 id="Date-prototype-toISOString"><a href="#Date-prototype-toISOString" class="headerlink" title="Date.prototype.toISOString()"></a>Date.prototype.toISOString()</h4><p>toISOString方法返回对应时间的 ISO8601 写法。</p><p>toISOString方法返回的总是 UTC 时区的时间。</p><h4 id="Date-prototype-toJSON"><a href="#Date-prototype-toJSON" class="headerlink" title="Date.prototype.toJSON()"></a>Date.prototype.toJSON()</h4><p>toJSON方法返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同。</p><h4 id="Date-prototype-toDateString"><a href="#Date-prototype-toDateString" class="headerlink" title="Date.prototype.toDateString()"></a>Date.prototype.toDateString()</h4><p>toDateString方法返回日期字符串（不含小时、分和秒）。</p><h4 id="Date-prototype-toTimeString"><a href="#Date-prototype-toTimeString" class="headerlink" title="Date.prototype.toTimeString()"></a>Date.prototype.toTimeString()</h4><p>toTimeString方法返回时间字符串（不含年月日）。</p><h4 id="Date-prototype-toLocaleDateString"><a href="#Date-prototype-toLocaleDateString" class="headerlink" title="Date.prototype.toLocaleDateString()"></a>Date.prototype.toLocaleDateString()</h4><p>toLocaleDateString方法返回一个字符串，代表日期的当地写法（不含小时、分和秒）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.32.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="get类方法"><a href="#get类方法" class="headerlink" title="get类方法"></a>get类方法</h3><p>Date对象提供了一系列get*方法，用来获取实例对象某个方面的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.39.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所有这些get*方法返回的都是整数，不同方法返回值的范围不一样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.40.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.42.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="set-类方法"><a href="#set-类方法" class="headerlink" title="set 类方法"></a>set 类方法</h3><p>Date对象提供了一系列set*方法，用来设置实例对象的各个方面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.44.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>set*方法的参数都会自动折算。以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p><p>set*系列方法除了setTime()和setYear()，都有对应的 UTC 版本，即设置 UTC 时区的时间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.49.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p><p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.52.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>另一种是使用RegExp构造函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%889.52.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p><p>RegExp构造函数还可以接受第二个参数，表示修饰符。</p><h2 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h2><p>正则对象的实例属性分成两类。</p><p>一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.14.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>三个属性都是只读的。</p><p>另一类是与修饰符无关的属性，主要是下面两个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.15.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="实例方法-5"><a href="#实例方法-5" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h3><p>正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p><p>如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。</p><p>带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。</p><p>lastIndex属性只对同一个正则表达式有效。</p><p>如果正则模式是一个空字符串，则匹配所有字符串。</p><h3 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h3><p>正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。</p><p>exec方法的返回数组还包含以下两个属性：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.26.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p><p>正则实例对象的lastIndex属性不仅可读，还可写。设置了g修饰符的时候，只要手动设置了lastIndex的值，就会从指定位置开始匹配。</p><h2 id="字符串的实例方法"><a href="#字符串的实例方法" class="headerlink" title="字符串的实例方法"></a>字符串的实例方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.28.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="String-prototype-match-1"><a href="#String-prototype-match-1" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p>字符串实例对象的match方法对字符串进行正则匹配，返回匹配结果。</p><p>字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。</p><p>如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。</p><p>设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。</p><p>设置正则对象的lastIndex属性是无效的。</p><h3 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h3><p>字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。</p><h3 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h3><p>字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p><p>正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p><p>replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.34.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p><h3 id="String-prototype-split-1"><a href="#String-prototype-split-1" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p>字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p><p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p><p>正则默认是贪婪匹配。</p><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><h3 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h3><p>如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。</p><p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p><h4 id="点字符（-）"><a href="#点字符（-）" class="headerlink" title="点字符（.）"></a>点字符（.）</h4><p>点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。注意，对于码点大于0xFFFF的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。</p><h4 id="位置字符"><a href="#位置字符" class="headerlink" title="位置字符"></a>位置字符</h4><p>位置字符用来提示字符所处的位置，主要有两个字符。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.40.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="选择符（-）"><a href="#选择符（-）" class="headerlink" title="选择符（|）"></a>选择符（|）</h4><p>竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。</p><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成\ +。</p><p>正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.43.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</p><h4 id="脱字符（-）"><a href="#脱字符（-）" class="headerlink" title="脱字符（ ^ ）"></a>脱字符（ ^ ）</h4><p>如果方括号内的第一个字符是[^ ]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^ xyz]表示除了x、y、z之外都可以匹配。</p><p>如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</p><p><strong>注意</strong>，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p><h4 id="连字符（-）"><a href="#连字符（-）" class="headerlink" title="连字符（-）"></a>连字符（-）</h4><p>某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。</p><p>[1-31]，不代表1到31，只代表1到3。</p><p>连字符还可以用来指定 Unicode 字符的范围。</p><h3 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.51.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h3><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p><h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><p>量词符用来设定某个模式出现的次数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8810.53.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p><p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p><p>模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p><p>修饰符可以单个使用，也可以多个一起使用。</p><h4 id="g-修饰符"><a href="#g-修饰符" class="headerlink" title="g 修饰符"></a>g 修饰符</h4><p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p><h4 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h4><p>默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。</p><p>m修饰符表示多行模式（multiline），会修改\^和\$的行为。默认情况下（即不加m修饰符时），\^<br>和\$匹配字符串的开始处和结尾处，加上m修饰符以后，\^和\$还会匹配行首和行尾，即\^和\$会识别换行符（\n）。</p><h3 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p><p>注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。</p><p>这时必须使用正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获。</p><p>正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。</p><h4 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h4><p>(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8A%E5%8D%8811.51.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h4><p>x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。</p><h4 id="先行否定断言"><a href="#先行否定断言" class="headerlink" title="先行否定断言"></a>先行否定断言</h4><p>x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。</p><h1 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h1><h2 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h2><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式。</p><p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p><p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。</p><p>JSON 对值的类型和格式有严格的规定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.02.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</p><p><strong>注意</strong>，对于原始类型的字符串，转换结果会带双引号。</p><p>如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。</p><p>如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。</p><p>正则对象会被转成空对象。</p><p>JSON.stringify方法会忽略对象的不可遍历属性。</p><h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p>JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</p><p>这个类似白名单的数组，只对对象的属性有效，对数组无效。</p><p>第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。</p><p>f函数，接受两个参数，分别是被转换的对象的键名和键值。</p><p>这个处理函数是递归处理所有的键。</p><h3 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h3><p>JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</p><h3 id="参数对象的-toJSON-方法"><a href="#参数对象的-toJSON-方法" class="headerlink" title="参数对象的 toJSON 方法"></a>参数对象的 toJSON 方法</h3><p>如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p><h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>JSON.parse方法用于将 JSON 字符串转换成对应的值。</p><p>如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。</p><p>单引号字符串不符合 JSON 格式，会报错。</p><p>为了处理解析错误，可以将JSON.parse方法放在try…catch代码块中。</p><p>JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。</p><h1 id="console对象"><a href="#console对象" class="headerlink" title="console对象"></a>console对象</h1><p>console对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p><p>console的常见用途有两个。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.24.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="浏览器实现"><a href="#浏览器实现" class="headerlink" title="浏览器实现"></a>浏览器实现</h2><p>可以使用下面三种方法的打开它。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.27.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>面板。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.29.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Console面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。</p><h2 id="console-对象的静态方法"><a href="#console-对象的静态方法" class="headerlink" title="console 对象的静态方法"></a>console 对象的静态方法</h2><p>console对象提供的各种静态方法，用来与控制台窗口互动。</p><h3 id="console-log-，console-info-，console-debug"><a href="#console-log-，console-info-，console-debug" class="headerlink" title="console.log()，console.info()，console.debug()"></a>console.log()，console.info()，console.debug()</h3><p>console.log方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p><p>console.log方法会自动在每次输出的结尾，添加换行符。</p><p>如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</p><p>不同类型的数据必须使用对应的占位符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%882.30.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>console.info是console.log方法的别名，用法完全一样。只不过console.info方法会在输出信息的前面，加上一个蓝色图标。</p><p>console.debug方法与console.log方法类似，会在控制台输出调试信息。但是，默认情况下，console.debug输出的信息不会显示，只有在打开显示级别在verbose的情况下，才会显示。</p><p>console对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。</p><h3 id="console-warn-，console-error"><a href="#console-warn-，console-error" class="headerlink" title="console.warn()，console.error()"></a>console.warn()，console.error()</h3><p>warn方法和error方法也是在控制台输出信息，它们与log方法的不同之处在于，warn方法输出信息时，在最前面加一个黄色三角，表示警告；error方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>对于某些复合类型的数据，console.table方法可以将其转为表格显示。</p><h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p>count方法用于计数，输出它被调用了多少次。</p><p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p><h3 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h3><p>dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p><p>dir方法的输出结果，比log方法更易读，信息也更丰富。</p><p>对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p><p>Node 环境之中，还可以指定以代码高亮的形式输出。</p><p>dirxml方法主要用于以目录树的形式，显示 DOM 节点。</p><p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。</p><h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><p>console.assert方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p><p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p><h3 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p><p>time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p><h3 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p>console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p><p>console.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p><h3 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h3><p>console.trace方法显示当前执行的代码在堆栈中的调用路径。</p><p>console.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，console.clear方法将不起作用。</p><h2 id="命令行API"><a href="#命令行API" class="headerlink" title="命令行API"></a>命令行API</h2><p>浏览器控制台中，除了使用console对象，还可以使用一些控制台自带的命令行方法。</p><h3 id=""><a href="#" class="headerlink" title="$_"></a>$_</h3><p>$_属性返回上一个表达式的值。</p><h3 id="0-4"><a href="#0-4" class="headerlink" title="\$0 - \$4"></a>\$0 - \$4</h3><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，\$0代表倒数第一个（最近一个），\$1代表倒数第二个，以此类推直到\$4。</p><h3 id="selector"><a href="#selector" class="headerlink" title="$(selector)"></a>$(selector)</h3><p>\$(selector)返回第一个匹配的元素，等同于document.querySelector()。注意，如果页面脚本对\$有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行\$(selector)就会采用 jQuery 的实现，返回一个数组。</p><h3 id="selector-1"><a href="#selector-1" class="headerlink" title="$$(selector)"></a>$$(selector)</h3><p>$$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。</p><h3 id="x-path"><a href="#x-path" class="headerlink" title="$x(path)"></a>$x(path)</h3><p>$x(path)方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p><h3 id="inspect-object"><a href="#inspect-object" class="headerlink" title="inspect(object)"></a>inspect(object)</h3><p>inspect(object)方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在Elements面板中显示，比如inspect(document)会在 Elements 面板显示document元素。JavaScript 对象在控制台面板Profiles面板中显示，比如inspect(window)。</p><h3 id="getEventListeners-object"><a href="#getEventListeners-object" class="headerlink" title="getEventListeners(object)"></a>getEventListeners(object)</h3><p>getEventListeners(object)方法返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。</p><h3 id="keys-object-，values-object"><a href="#keys-object-，values-object" class="headerlink" title="keys(object)，values(object)"></a>keys(object)，values(object)</h3><p>keys(object)方法返回一个数组，包含object的所有键名。<br>values(object)方法返回一个数组，包含object的所有键值。</p><h3 id="monitorEvents-object-events-，unmonitorEvents-object-events"><a href="#monitorEvents-object-events-，unmonitorEvents-object-events" class="headerlink" title="monitorEvents(object[, events]) ，unmonitorEvents(object[, events])"></a>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</h3><p>monitorEvents(object[, events])方法监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息。unmonitorEvents方法用于停止监听。</p><p>monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%884.52.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h3><p>命令行 API 还提供以下方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%884.53.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h2><p>debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p><p>Chrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-16%20%E4%B8%8B%E5%8D%884.54.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p><p>属性描述对象提供6个元属性。</p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>value是该属性的属性值，默认为undefined。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。</p><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for…in循环、Object.keys()，JSON.stringify方法）跳过该属性。</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get是一个函数，表示该属性的取值函数（getter），默认为undefined。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set是一个函数，表示该属性的存值函数（setter），默认为undefined。</p><h2 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h2><p>Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。</p><p><strong>注意</strong>，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。</p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p><p>这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。</p><h2 id="Object-defineProperty-，Object-defineProperties"><a href="#Object-defineProperty-，Object-defineProperties" class="headerlink" title="Object.defineProperty()，Object.defineProperties()"></a>Object.defineProperty()，Object.defineProperties()</h2><p>Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%889.34.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Object.defineProperty方法接受三个参数，依次如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%889.34.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%889.37.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。</p><p>Object.defineProperty()和Object.defineProperties()的第三个参数，是一个属性对象。它的writable、configurable、enumerable这三个属性的默认值都为false。</p><h2 id="Object-prototype-propertyIsEnumerable"><a href="#Object-prototype-propertyIsEnumerable" class="headerlink" title="Object.prototype.propertyIsEnumerable()"></a>Object.prototype.propertyIsEnumerable()</h2><p>实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。</p><h2 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h2><p>属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。</p><h3 id="value-1"><a href="#value-1" class="headerlink" title="value"></a>value</h3><p>value属性是目标属性的值。</p><h3 id="writable-1"><a href="#writable-1" class="headerlink" title="writable"></a>writable</h3><h3 id="enumerable-1"><a href="#enumerable-1" class="headerlink" title="enumerable"></a>enumerable</h3><h3 id="configurable-1"><a href="#configurable-1" class="headerlink" title="configurable"></a>configurable</h3><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。</p><p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。</p><p>存取器往往用于，属性的值依赖对象内部数据的场合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.20.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>next属性的存值函数和取值函数，都依赖于内部属性$n。</p><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象。</p><p>可以通过Object.defineProperty方法来拷贝属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.23.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>hasOwnProperty那一行用来过滤掉继承的属性，否则会报错，因为Object.getOwnPropertyDescriptor读不到继承属性的属性描述对象。</p><h2 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h2><p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。</p><h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><p>Object.preventExtensions方法可以使得一个对象无法再添加新的属性。</p><h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h3><p>Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。</p><h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><p>Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。</p><p>Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。</p><p>Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15342338033089/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-17%20%E4%B8%8A%E5%8D%8810.29.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed()"></a>Object.isSealed()</h3><p>Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。</p><p>这时，Object.isExtensible方法也返回false。</p><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p>Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p><p>这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。</p><h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h3><p>Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。</p><p>使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。</p><p>一种解决方案是，把obj的原型也冻结住。</p><p>另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p><p>obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object对象&quot;&gt;&lt;a href=&quot;#Object对象&quot; class=&quot;headerlink&quot; title=&quot;Object对象&quot;&gt;&lt;/a&gt;Object对象&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标准参考教程 语法</title>
    <link href="https://github.com/zdkswd/2018/08/14/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E8%AF%AD%E6%B3%95/"/>
    <id>https://github.com/zdkswd/2018/08/14/JavaScript标准参考教程 语法/</id>
    <published>2018-08-14T02:36:56.000Z</published>
    <updated>2018-08-26T08:11:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="1-语句"><a href="#1-语句" class="headerlink" title="1 语句"></a>1 语句</h3><blockquote><p>var a=1+3;</p></blockquote><p>分号语句结束。</p><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h3><p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><blockquote><p>var a = 1;<br>a = ‘hello’;</p></blockquote><p><strong>变量提升</strong><br>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的<strong>变量</strong>，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p><h3 id="3-标识符"><a href="#3-标识符" class="headerlink" title="3 标识符"></a>3 标识符</h3><p>中文是合法的标识符，可以用作变量名。<br>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。</p><h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4 注释"></a>4 注释</h3><p>//单行<br>/*多行*/<br>由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<!--和-->也被视为合法的单行注释。</p><h3 id="5-区块"><a href="#5-区块" class="headerlink" title="5 区块"></a>5 区块</h3><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“<strong>区块</strong>”（block）。<br>对于var命令来说，JavaScript 的区块不构成单独的<strong>作用域</strong>（scope）。</p><h3 id="6-条件语句"><a href="#6-条件语句" class="headerlink" title="6 条件语句"></a>6 条件语句</h3><p>if和switch 还有三元运算符<br>if switch与c一样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%885.19.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="7-循环语句"><a href="#7-循环语句" class="headerlink" title="7 循环语句"></a>7 循环语句</h3><p>while \for\ do..while<br>while for do..while语法与c一样。<br>break退出循环，continue退出本轮循环。</p><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置。与汇编语言类似。<br><strong>标签</strong>:标签通常与break语句和continue语句配合使用，跳出特定的循环.</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%885.35.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>JavaScript中的值分为2大类：基本类型和引用类型。<br>基本类型：<br>数字类型：Number；字符串类型：String；布尔类型：Boolean(true和false)；Undefined；Null。</p><p>引用类型：<br>对象。</p><p>对象是最复杂的数据类型，又可以分成三个子类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.03.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p><p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。</p><p>对基本类型，是按值访问的，即通过<strong>值复制</strong>的方式来赋值和传递。<br>对引用类型，是按引用访问的，即通过<strong>引用复制</strong>的方式赋值和传递。</p><p>当一个变量进行赋值操作时，就是在重新将变量进行指向。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="2-typeof-运算符"><a href="#2-typeof-运算符" class="headerlink" title="2 typeof 运算符"></a>2 typeof 运算符</h3><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.08.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>typeof可以用来检查一个没有声明的变量，而不报错。</p><p>instanceof运算符可以区分数组和对象。</p><p>typeof null的类型是object，这是由于历史原因造成的。</p><h3 id="3-null-和-undefined"><a href="#3-null-和-undefined" class="headerlink" title="3 null 和 undefined"></a>3 null 和 undefined</h3><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。</p><p>在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。</p><p>区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。</p><h3 id="4-布尔值"><a href="#4-布尔值" class="headerlink" title="4 布尔值"></a>4 布尔值</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.23.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.24.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>空数组（[]）和空对象（{}）对应的布尔值，都是true。</p><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.39.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="2-数值精度"><a href="#2-数值精度" class="headerlink" title="2 数值精度"></a>2 数值精度</h3><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.40.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有效数字的第一位默认总是1。</p><h3 id="3-数值范围"><a href="#3-数值范围" class="headerlink" title="3 数值范围"></a>3 数值范围</h3> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.42.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p><h3 id="4-数值的表示法"><a href="#4-数值的表示法" class="headerlink" title="4 数值的表示法"></a>4 数值的表示法</h3><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。<br>数值也可以采用科学计数法表示。</p><p>科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.48.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。<br>（1）小数点前的数字多于21位。<br>（2）小数点后的零多于5个。</p><h3 id="5-数值的进制"><a href="#5-数值的进制" class="headerlink" title="5 数值的进制"></a>5 数值的进制</h3><p>JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.51.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。</p><p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p><p>有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%886.52.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="6-特殊数值"><a href="#6-特殊数值" class="headerlink" title="6 特殊数值"></a>6 特殊数值</h3><p><strong>正零和负零</strong><br>JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的。<br><strong>NaN</strong><br>NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p><p>0除以0也会得到NaN。</p><p>NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。</p><p>NaN不等于任何值，包括它本身。</p><p>数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。</p><p>NaN在布尔运算时被当作false。</p><p>NaN与任何数（包括它自己）的运算，得到的都是NaN。<br><strong>Infinity</strong><br>Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。</p><p>Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。</p><p>由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。</p><p>Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。</p><p>Infinity与NaN比较，总是返回false。</p><p>Infinity的四则运算，符合无穷的数学计算规则。</p><p>0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。</p><p>Infinity减去或除以Infinity，得到NaN。</p><p>Infinity与null计算时，null会转成0，等同于与0的计算。</p><p>Infinity与undefined计算，返回的都是NaN。</p><h3 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h3><p>parseInt方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。如果parseInt的参数不是字符串，则会先转为字符串再转换。</p><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</p><p>所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。</p><p>如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。</p><p>如果字符串以0开头，将其按照10进制解析。</p><p>对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p><p><strong>进制转换</strong><br>parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。</p><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。</p><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。</p><p>前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p>parseFloat方法用于将一个字符串转为浮点数。</p><p>如果字符串符合科学计数法，则会进行相应的转换。</p><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><p>parseFloat方法会自动过滤字符串前导的空格。</p><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。</p><p>上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。这些特点使得parseFloat的转换结果不同于Number函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%888.04.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>isNaN</strong><br>isNaN方法可以用来判断一个值是否为NaN。</p><p>但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%888.05.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>出于同样的原因，对于对象和数组，isNaN也返回true。</p><p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。</p><p>上面代码之所以返回false，原因是这些数组能被Number函数转成数值。</p><p><strong>因此，使用isNaN之前，最好判断一下数据类型。</strong></p><p>判断NaN更可靠的方法是，<strong>利用NaN为唯一不等于自身的值的这个特点，进行判断。</strong></p><p><strong>isFinite（）</strong><br>isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p><p>除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p><p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p><p>字符串默认只能写在一行内，分成多行将会报错。</p><p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p><p>连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p><h3 id="2-转义"><a href="#2-转义" class="headerlink" title="2 转义"></a>2 转义</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.15.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>反斜杠还有三种特殊用法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.17.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p><h3 id="3-字符串与数组"><a href="#3-字符串与数组" class="headerlink" title="3 字符串与数组"></a>3 字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p><p>字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p><h3 id="4-length-属性"><a href="#4-length-属性" class="headerlink" title="4 length 属性"></a>4 length 属性</h3><p>length属性返回字符串的长度，该属性也是无法改变的。但是不会报错。</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p><p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。</p><p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p><p>每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即<strong>2个字节</strong>。</p><p>但是，UTF-16 有两种长度。对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。</p><p>JavaScript 对 UTF-16 的支持是<strong>不完整</strong>的，由于历史原因，只支持两字节的字符，不支持四字节的字符。</p><p>总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是<strong>不正确</strong>的。</p><h3 id="Base64-转码"><a href="#Base64-转码" class="headerlink" title="Base64 转码"></a>Base64 转码</h3><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p><p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p><p>JavaScript 原生提供两个 Base64 相关的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.38.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两个方法不适合非 ASCII 码的字符，会报错。</p><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.41.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>键名</strong><br>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。</p><p>如果键名是数值，会被自动转为字符串。</p><p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.45.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果属性的值还是一个对象，就形成了链式引用。</p><p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p><p>属性可以动态创建，不必在对象声明时就指定。</p><h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向<strong>同一个内存地址</strong>。修改其中一个变量，会影响到其他所有变量。</p><p>其中任何一个变量添加属性，另一个变量都可以读写该属性。</p><p>如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><p>这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p><h3 id="表达式还是语句"><a href="#表达式还是语句" class="headerlink" title="表达式还是语句"></a>表达式还是语句</h3><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p><p>V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好还是在大括号前加上圆括号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.54.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h3><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-12%20%E4%B8%8B%E5%8D%8810.55.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>注意</strong>，如果使用方括号运算符，键名必须放在<strong>引号</strong>里面，否则会被当作变量处理。</p><p>数字键可以不加引号，因为会自动转成字符串。</p><p><strong>注意</strong>，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p><h3 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h3><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p><p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p><h3 id="查看所有属性"><a href="#查看所有属性" class="headerlink" title="查看所有属性"></a>查看所有属性</h3><p>查看一个对象本身的所有属性，可以使用Object.keys方法。</p><h3 id="delete-命令"><a href="#delete-命令" class="headerlink" title="delete 命令"></a>delete 命令</h3><p>delete命令用于删除对象的属性，删除成功后返回true。delete A[属性名]；。</p><p><strong>注意</strong>，删除一个不存在的属性，delete不报错，而且返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。</p><p>只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。</p><p><strong>注意</strong>，delete命令只能删除对象本身的属性，无法删除继承的属性。即为即使delete返回true，该属性依然可能读取到值。</p><h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。</p><p>in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。</p><h3 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h3><p>for…in循环有两个使用注意点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8810.57.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果继承的属性是可遍历的，那么就会被for…in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for…in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.02.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.07.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.07.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。</p><p>因此，建议不要使用with语句，可以考虑用一个临时变量代替with。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h3><p>数组用方括号表示。任何类型的数据，都可以放入数组。</p><h3 id="2-数组本质"><a href="#2-数组本质" class="headerlink" title="2 数组本质"></a>2 数组本质</h3><p>本质上，数组属于一种特殊的对象。数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。<br>JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p><h3 id="3-length属性"><a href="#3-length属性" class="headerlink" title="3 length属性"></a>3 length属性</h3><p>清空数组的一个有效方法，就是将length属性设为0。<br>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p><h3 id="4-in运算符"><a href="#4-in运算符" class="headerlink" title="4 in运算符"></a>4 in运算符</h3><p>检查某个键名是否存在的运算符in，适用于对象，也适用于数组。</p><h3 id="5-for…in-循环和数组的遍历"><a href="#5-for…in-循环和数组的遍历" class="headerlink" title="5 for…in 循环和数组的遍历"></a>5 for…in 循环和数组的遍历</h3><p>for…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p><p>但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。所以，不推荐使用for…in遍历数组。<br>数组的遍历可以考虑使用for循环或while循环。</p><p>数组的forEach方法，也可以用来遍历数组。</p><h3 id="6-数组的空位"><a href="#6-数组的空位" class="headerlink" title="6 数组的空位"></a>6 数组的空位</h3><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。<br>数组的空位不影响length属性。数组最后一个成员后面有一个逗号，这不影响length属性的值。<br>数组的空位是可以读取的，返回undefined。<br>使用delete命令删除一个数组成员，会形成空位，并且<strong>不会影响length属性</strong>。</p><h3 id="7-类似数组的对象"><a href="#7-类似数组的对象" class="headerlink" title="7 类似数组的对象"></a>7 类似数组的对象</h3><p>如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p><p>“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。</p><p>“类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。</p><p>典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。</p><p>数组的slice方法可以将“类似数组的对象”变成真正的数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-11%20%E4%B8%8B%E5%8D%885.14.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。</p><p>字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。</p><p><strong>注意</strong>，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>JavaScript 有三种声明函数的方法。</p><h4 id="function-命令"><a href="#function-命令" class="headerlink" title="function 命令"></a>function 命令</h4><p>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.15.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>除了用function命令声明函数，还可以采用变量赋值的写法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.16.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这种写法将一个匿名函数赋值给变量。</p><p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体<strong>外部无效</strong>。</p><p>这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。</p><p><strong>注意</strong>，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。</p><h4 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function 构造函数"></a>Function 构造函数</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.22.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p><p>这种声明函数的方式非常不直观，<strong>几乎无人使用</strong>。</p><h3 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h3><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p><h3 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h3><h3 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h3><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p><p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p><h3 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h3><p>JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8A%E5%8D%8811.32.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用<strong>赋值语句</strong>定义函数，JavaScript 就会<strong>报错</strong>。</p><h3 id="不能在条件语句中声明函数"><a href="#不能在条件语句中声明函数" class="headerlink" title="不能在条件语句中声明函数"></a>不能在条件语句中声明函数</h3><p>根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。</p><p>但是，实际情况是各家浏览器往往并不报错，能够运行。</p><p>但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。</p><p>要达到在条件语句中定义函数的目的，只有使用函数表达式。</p><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><h4 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h4><p>函数的name属性返回函数的名字。</p><p>如果是通过变量赋值定义的函数，那么name属性返回变量名。</p><p>只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。</p><p>name属性的一个用处，就是获取参数函数的名字。</p><h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><p>函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p><p>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>函数的toString方法返回一个字符串，内容是函数的源码。</p><p>函数内部的注释也可以返回。</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p><p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。</p><p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p><h4 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h4><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p><h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%883.44.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p><h4 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h4><p>函数参数不是必需的，Javascript 允许省略参数。</p><p>运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。</p><p><strong>注意</strong>，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p><h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p><p>如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p><p><strong>注意</strong>，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p><p>重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。</p><h3 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h3><p>如果有同名的参数，则取最后出现的那个值。</p><h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p><p>rguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p><p>正常模式下，arguments对象可以在运行时修改。</p><p>严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。</p><p>通过arguments对象的length属性，可以判断函数调用时到底带几个参数。</p><h4 id="与数组的关系"><a href="#与数组的关系" class="headerlink" title="与数组的关系"></a>与数组的关系</h4><p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</p><h4 id="callee属性"><a href="#callee属性" class="headerlink" title="callee属性"></a>callee属性</h4><p>arguments对象带有一个callee属性，返回它所对应的原函数。</p><p>可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p><h3 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p><p>出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%884.45.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p><p>闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%884.49.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p><p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p><p><strong>注意</strong>，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><h3 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%884.55.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p><h3 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h3><p>eval命令的作用是，将字符串当作语句执行。</p><p>eval的命令字符串不会得到 JavaScript 引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><p>JavaScript 允许非数值的相加。如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。</p><p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%885.49.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h3><p>如果运算子是对象，必须先转成原始类型的值，然后再相加。</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%885.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>余数运算符运算结果的正负号由第一个运算子的正负号决定。</p><p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%885.56.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p><h4 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h4><p>字符串按照字典顺序进行比较。</p><p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</p><h4 id="非字符串的比较"><a href="#非字符串的比较" class="headerlink" title="非字符串的比较"></a>非字符串的比较</h4><p>两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。</p><p>字符串和布尔值都会先转成数值，再进行比较。</p><p>特殊情况，即任何值（包括NaN本身）与NaN比较，返回的都是false。</p><p><strong>对象</strong></p><h4 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h4><p>JavaScript 提供两种相等运算符：==和===。</p><p>简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p><p>需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。</p><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。使用===</p><p>空对象、空数组、空函数的值，都存放在不同的内存地址。</p><p><strong>注意</strong>，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</p><p><strong>undefined和null</strong><br>undefined和null与自身严格相等。</p><p>由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。</p><h4 id="严格不相等运算符"><a href="#严格不相等运算符" class="headerlink" title="严格不相等运算符"></a>严格不相等运算符</h4><p>严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。</p><h4 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h4><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</p><p>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%886.58.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p><p>因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。</p><h4 id="不相等运算符"><a href="#不相等运算符" class="headerlink" title="不相等运算符"></a>不相等运算符</h4><p>相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。</p><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.01.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="！"><a href="#！" class="headerlink" title="！"></a>！</h4><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.02.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。</p><h4 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><h4 id=""><a href="#" class="headerlink" title="||"></a>||</h4><h4 id="（-）"><a href="#（-）" class="headerlink" title="（?:）"></a>（?:）</h4><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.05.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p><p>左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方（最高位即符号位不参与移动）。</p><p>右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）。</p><p>带符号位的右移运算符（&gt;&gt;&gt;）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。</p><h4 id="开关作用"><a href="#开关作用" class="headerlink" title="开关作用"></a>开关作用</h4><p>掩码</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><h4 id="void运算符"><a href="#void运算符" class="headerlink" title="void运算符"></a>void运算符</h4><p>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</p><p>这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%887.11.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。</p><p>记住所有运算符的优先级，是非常难的，也是没有必要的。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。</p><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>使用Number函数，可以将任意类型的值转化成数值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.20.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。</p><p>parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。</p><p>Number方法的参数是对象时，将返回NaN，<strong>除非是包含单个数值的数组</strong>。</p><p>第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。<br>第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。<br>第三步，如果toString方法返回的是对象，就报错。</p><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>String函数可以将任意类型的值转化成字符串，转换规则如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.29.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p><p>String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.30.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p>Boolean函数可以将任意类型的值转为布尔值。</p><p>它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8810.33.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。</p><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>自动转换是以强制转换为基础的。</p><p>以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p><p>第一种情况，不同类型的数据互相运算。</p><p>第二种情况，对非布尔值类型的数据求布尔值。</p><p>第三种情况，对非数值类型的值使用一元运算符（即+和-）。</p><p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。</p><p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</p><h3 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h3><h3 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h3><p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p><p>这种自动转换很容易出错。期望求导个整数值结果得到个字符串。</p><h3 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h3><p>除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p><p><strong>注意</strong>：null转为数值时为0，而undefined转为数值时为NaN。</p><p>一元运算符也会把运算子转成数值。</p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><h3 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h3><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8811.11.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h3><p>Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。</p><h4 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h4><p>SyntaxError对象是解析代码时发生的语法错误。</p><h4 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h4><p>ReferenceError对象是引用一个不存在的变量时发生的错误。</p><p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</p><h4 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h4><p>RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p><h4 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h4><p>TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</p><h4 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h4><p>URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p><h4 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h4><p>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p><h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><h3 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h3><p>throw语句的作用是手动中断程序执行，抛出一个错误。</p><p>实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p><p>对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p><h3 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h3><p>一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。</p><p>如果你不确定某些代码是否会报错，就可以把它们放在try…catch代码块之中，便于进一步对错误进行处理。</p><p>catch代码块之中，还可以再抛出错误，甚至使用嵌套的try…catch结构。</p><p>为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8811.23.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h3><p>try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。</p><p>return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。</p><p><img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-13%20%E4%B8%8B%E5%8D%8811.31.52.png" alt=""></p><p>由于没有catch语句块，所以错误没有捕获。执行finally代码块以后，程序就中断在错误抛出的地方。</p><p>try…catch…finally这三者之间的执行顺序。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.11.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生</p><p>finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略</p><p>所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。</p><h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。</p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。</p><p>Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。</p><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。</p><p>建议总是使用大括号表示区块。</p><p>JavaScript 要使用起首的大括号跟在关键字的后面，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。</p><p><strong>因此，表示区块起首的大括号，不要另起一行。</strong></p><h3 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h3><p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。</p><p>建议可以用空格，区分这两种不同的括号。</p><h3 id="行尾的分号"><a href="#行尾的分号" class="headerlink" title="行尾的分号"></a>行尾的分号</h3><h4 id="不使用分号的情况"><a href="#不使用分号的情况" class="headerlink" title="不使用分号的情况"></a>不使用分号的情况</h4><h5 id="for和while循环"><a href="#for和while循环" class="headerlink" title="for和while循环"></a>for和while循环</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.22.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，do…while循环是有分号的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.23.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="分支语句：if，switch，try"><a href="#分支语句：if，switch，try" class="headerlink" title="分支语句：if，switch，try"></a>分支语句：if，switch，try</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.23.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="函数的声明语句"><a href="#函数的声明语句" class="headerlink" title="函数的声明语句"></a>函数的声明语句</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.24.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>注意</strong>，函数表达式仍然要使用分号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.25.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。</p><h4 id="分号的自动添加"><a href="#分号的自动添加" class="headerlink" title="分号的自动添加"></a>分号的自动添加</h4><p>所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。</p><p>麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。</p><p>如果continue、break、return和throw这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果return语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。</p><p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。</p><p>不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。</p><p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。</p><p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p><p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如UPPER_CASE。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>JavaScript 会自动将变量声明”提升“（hoist）到代码块（block）的头部。</p><p>为了避免可能出现的问题，最好把变量声明都放在代码块的头部。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15290450111426/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-14%20%E4%B8%8A%E5%8D%8810.31.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</p><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>with可以减少代码的书写，但是会造成混淆。</p><p>因此，不要使用with语句。</p><h3 id="相等和严格相等"><a href="#相等和严格相等" class="headerlink" title="相等和严格相等"></a>相等和严格相等</h3><p>相等运算符会自动转换变量类型，造成很多意想不到的情况。</p><p>建议不要使用相等运算符（==），只使用严格相等运算符（===）。</p><h3 id="语句的合并"><a href="#语句的合并" class="headerlink" title="语句的合并"></a>语句的合并</h3><p>建议不要将不同目的的语句，合并成一行。</p><h3 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h3><p>自增（++）和自减（–）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的++运算符都可以用+= 1代替。</p><p>建议自增（++）和自减（–）运算符尽量使用+=和-=代替。</p><h3 id="switch…case结构"><a href="#switch…case结构" class="headerlink" title="switch…case结构"></a>switch…case结构</h3><p>switch…case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。这样不仅容易忘记，还会造成代码的冗长。</p><p>建议switch…case结构可以用对象结构代替。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;h3 id=&quot;1-语句&quot;&gt;&lt;a href=&quot;#1-语句&quot; class=&quot;headerlink&quot; title=&quot;1 语句&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS标准参考教程 1 导论</title>
    <link href="https://github.com/zdkswd/2018/08/11/JS%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20%E5%AF%BC%E8%AE%BA/"/>
    <id>https://github.com/zdkswd/2018/08/11/JS标准参考教程 导论/</id>
    <published>2018-08-11T08:58:56.000Z</published>
    <updated>2018-08-11T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS标准参考教程-1-导论"><a href="#JS标准参考教程-1-导论" class="headerlink" title="JS标准参考教程 1 导论"></a>JS标准参考教程 1 导论</h1><h2 id="什么是JS"><a href="#什么是JS" class="headerlink" title="什么是JS"></a>什么是JS</h2><p>JavaScript 是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p><p>目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p><p>JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。<br>    •    浏览器控制类：操作浏览器<br>    •    DOM 类：操作网页的各种元素<br>    •    Web 类：实现互联网的各种功能</p><p>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</p><p>此书是针对<strong>浏览器</strong>的js</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS标准参考教程-1-导论&quot;&gt;&lt;a href=&quot;#JS标准参考教程-1-导论&quot; class=&quot;headerlink&quot; title=&quot;JS标准参考教程 1 导论&quot;&gt;&lt;/a&gt;JS标准参考教程 1 导论&lt;/h1&gt;&lt;h2 id=&quot;什么是JS&quot;&gt;&lt;a href=&quot;#什么是J
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/zdkswd/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序剖析 运行机制</title>
    <link href="https://github.com/zdkswd/2018/08/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%89%96%E6%9E%90-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/zdkswd/2018/08/11/微信小程序剖析-运行机制/</id>
    <published>2018-08-11T02:02:43.000Z</published>
    <updated>2018-08-11T03:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解压应用"><a href="#解压应用" class="headerlink" title="解压应用"></a>解压应用</h2><p>简单的说明一下：</p><ol><li>app 目录下放置了app的代码</li><li>modified_modules 即一些修改后的模块</li><li>node_modules 地球人都知道</li><li>package.json 配置了NW相关的内容</li></ol><p>在modified_modules目录下有两个子模块：</p><ol><li>anyproxy，从名字就可以看起来这是一个代理模块</li><li>weinre，远程调试工具</li></ol><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>这是一个NodeWebkit封装的Web应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node-webkit能做什么？</span><br><span class="line">用Web技术（Node.JS，JavaScript，HTML5）开发桌面应用程序。Node.js是一个Javascript运行环境(runtime environment)。实质是对Chrome V8引擎进行了封装。</span><br><span class="line"></span><br><span class="line">Node.js使用Module模块去划分不同的功能，以简化应用的开发。Modules模块有点像C++语言中的类库。每一个Node.js的类库都包含了十分丰富的各类函数，比如http模块就包含了和http功能相关的很多函数，可以帮助开发者很容易地对比如http,tcp/udp等进行操作，还可以很容易的创建http和tcp/udp的服务器。</span><br></pre></td></tr></table></figure><p>在package.json中的”main”: “app/html/index.html”,即定义了这个APP的入口是这个index.html，而不是别的文件。</p><p>这是一个React应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套。</span><br></pre></td></tr></table></figure><p>其中的编辑环境是基于Monaco。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monaco editor是微软开源的一款web版代码编辑器。它支持智能提示，代码高亮，代码格式化。</span><br></pre></td></tr></table></figure></p><h2 id="WeAPP运行机制"><a href="#WeAPP运行机制" class="headerlink" title="WeAPP运行机制"></a>WeAPP运行机制</h2><p>wxml： html，wxss ： css。对应的有几个不同的transform:</p><ol><li>transWxmlToJs</li><li>transWxssToCss</li><li>transConfigToPf</li><li>transWxmlToHtml</li><li>transManager</li></ol><p>PF指代的是PageFrame的意思，pageFrame有一个对应的模板文件。</p><p>名为wcc以及一个名为wcsc的工具。wcc用于转换wxml中的自定义tag为virtual_dom。wcsc转换wxss为css</p><p>可以理解为微信小应用有点类似于 Virtual Dom + WebView，毕竟上面有个WAWebView文件 ，还有一个webviewSDK文件 。</p><p>当然无论是React + WebView，或者Vue + WebView都不重要，现在有了 WA + WebView</p><p>在本地写的WeApp都会被提交到微信服务器，然后打包，上传到服务器，交给CDN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</span><br></pre></td></tr></table></figure><p>上传的过程大致如下：</p><ol><li>APP会被打包成以日期命名 + .wx文件。</li><li>IDE会检测包的大小，并提示：代码包大小为 xx kb，超过限制 xx kb，请删除文件后重试。这个xx好像是1024，所以APP的大小是1M。</li><li>APP将会上传。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解压应用&quot;&gt;&lt;a href=&quot;#解压应用&quot; class=&quot;headerlink&quot; title=&quot;解压应用&quot;&gt;&lt;/a&gt;解压应用&lt;/h2&gt;&lt;p&gt;简单的说明一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;app 目录下放置了app的代码&lt;/li&gt;
&lt;li&gt;modified_modul
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="微信小程序" scheme="https://github.com/zdkswd/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信应用号开发基础教程</title>
    <link href="https://github.com/zdkswd/2018/08/10/%E5%BE%AE%E4%BF%A1%E5%BA%94%E7%94%A8%E5%8F%B7%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/08/10/微信应用号开发基础教程/</id>
    <published>2018-08-10T03:14:13.000Z</published>
    <updated>2018-08-10T03:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="获取微信小程序的AppID"><a href="#获取微信小程序的AppID" class="headerlink" title="获取微信小程序的AppID"></a>获取微信小程序的AppID</h3><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p><p>app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API</p><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p><p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p><h3 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h3><p>微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p><p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。</p><p>index.wxml 是页面的结构文件。</p><p>index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p><p>index.wxss 是页面的样式表。页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p><p>index.json 是页面的配置文件。<br>页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p><h3 id="手机预览"><a href="#手机预览" class="headerlink" title="手机预览"></a>手机预览</h3><h2 id="第一章-准备工作"><a href="#第一章-准备工作" class="headerlink" title="第一章 准备工作"></a>第一章 准备工作</h2><h2 id="第二章-项目架构"><a href="#第二章-项目架构" class="headerlink" title="第二章 项目架构"></a>第二章 项目架构</h2><p>从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。</p><p><strong>生命周期</strong>：<br>顺序是 App Launch–&gt;App Show–&gt;onload–&gt;onShow–&gt;onReady。</p><p>首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。</p><p><strong>路由</strong>：<br>微信在路由方面经过很好的封装，也提供三个跳转方法。</p><ol><li>wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。</li><li>wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。</li><li>wx.navigateBack()：关闭当前页面，回退前一页面。</li></ol><p><strong>组件</strong>：<br>微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。</p><p><strong>其它</strong>：<br>任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的rem.js也是不支持的。</p><p>此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。</p><p>注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。</p><p>建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。</p><p>编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。</p><p>使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。</p><p>「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：</p><blockquote><p>@import “wxss/index.CSS“</p></blockquote><p>注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。</p><p>「Js」文件需要在「app.json」文件的「”page”」里预先配置好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;获取微信小程序的AppID&quot;&gt;&lt;a href=&quot;#获取微信小程序的AppID&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="微信小程序" scheme="https://github.com/zdkswd/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》4 数值计算</title>
    <link href="https://github.com/zdkswd/2018/08/03/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B4%20%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/"/>
    <id>https://github.com/zdkswd/2018/08/03/《深度学习》4 数值计算/</id>
    <published>2018-08-03T01:47:12.000Z</published>
    <updated>2018-08-10T03:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上溢和下溢"><a href="#上溢和下溢" class="headerlink" title="上溢和下溢"></a>上溢和下溢</h2><p>连续数学在数字计算机上的根本困难是,我们需要通过有限数量的位模式来表示无限多的实数。这意味着我们在计算机中表示实数时,几乎总会引入一些近似误差。</p><p>种极具毁灭性的舍人误差是<strong>下溢</strong>( underflow)。当接近零的数被四舍五入为零时发生下溢。</p><p>另一个极具破坏力的数值错误形式是<strong>上溢</strong>( overfow)。当大量级的数被近似为+∞或-∞时发生上溢。进一步的运算通常会导致这些无限值变为非数字。</p><p>必须对上溢和下溢进行数值稳定的一个例子是<strong>softmax函数</strong>。</p><h2 id="病态条件"><a href="#病态条件" class="headerlink" title="病态条件"></a>病态条件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8A%E5%8D%8811.29.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是最大和最小特征值的模之比1 。当该数很大时，矩阵求逆对输入的误差特别敏感。 </p><p>这种敏感性是矩阵本身的固有特性，而不是矩阵求逆期间舍入误差的结果。 </p><h2 id="基于梯度的优化方法"><a href="#基于梯度的优化方法" class="headerlink" title="基于梯度的优化方法"></a>基于梯度的优化方法</h2><p>大多数深度学习算法都涉及某种形式的优化。优化指的是改变 x 以最小化或最 大化某个函数 f(x) 的任务。我们通常以最小化 f(x) 指代大多数最优化问题。最大化可经由最小化算法最小化−f(x) 来实现。 </p><p>我们把要最小化或最大化的函数称为 <strong>目标函数</strong>(objective function)或 <strong>准则</strong> (criterion)。当我们对其进行最小化时，我们也把它称为 <strong>代价函数</strong>(cost function)、 <strong>损失函数</strong>(loss function)或 <strong>误差函数</strong>(error function)。 </p><p><img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8A%E5%8D%8811.34.48.png" alt=""></p><p>有些临界点既不是最小点也不是最大点。这些点被称为 <strong>鞍点</strong>(saddle point)。 </p><p><strong>最速下降法</strong>(method of steepest descent) 或 <strong>梯度下降</strong>(gradient descent)。 </p><p><img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8A%E5%8D%8811.39.22.png" alt=""></p><p>其中 ε 为 学习率(learning rate)。</p><h3 id="梯度之上-Jacobian-和-Hessian-矩阵"><a href="#梯度之上-Jacobian-和-Hessian-矩阵" class="headerlink" title="梯度之上:Jacobian 和 Hessian 矩阵"></a>梯度之上:Jacobian 和 Hessian 矩阵</h3><p>有时我们需要计算输入和输出都为向量的函数的所有偏导数。包含所有这样的偏导数的矩阵被称为 <strong>Jacobian</strong> 矩阵。 雅可比矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.13.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当我们的函数具有多维输入时，二阶导数也有很多。我们可以将这些导数合并 成一个矩阵，称为 <strong>Hessian</strong> 矩阵。 黑塞矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.22.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.27.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Hessian 等价于梯度的 Jacobian 矩阵。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.30.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.35.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当 Hessian 的条件数很差时，梯度下降法也会表现得很差。 </p><p>病态条件也导致很难选择合适的步长。步长必须足够小，以免冲过最小而向具有较强正曲率的方向上升。这通常意味着步长太小，以致于在其他较小曲率的方向上进展不明显。 </p><p><img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%884.47.21.png" alt=""><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-02%20%E4%B8%8B%E5%8D%885.08.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>牛顿法，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-03%20%E4%B8%8A%E5%8D%889.06.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>仅使用梯度信息的优化算法被称为<strong>一阶优化算法</strong>(first-order optimization al- gorithms)，如梯度下降。使用 Hessian 矩阵的优化算法被称为<strong>二阶最优化算法</strong>(second-order optimization algorithms)(Nocedal and Wright, 2006)，如牛顿法。 </p><p>在深度学习的背景下，限制函数满足<strong>Lipschitz 连续</strong>(Lipschitz continuous)或 其导数Lipschitz连续可以获得一些保证。直觉上，利普希茨连续函数限制了函数改变的速度，符合利普希茨条件的函数的斜率，必小于一个称为利普希茨常数的实数（该常数依函数而定）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15331735691500/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-03%20%E4%B8%8A%E5%8D%889.17.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>最成功的特定优化领域或许是 凸优化(Convex optimization)。凸优化通过更强 的限制提供更多的保证。凸优化算法只对凸函数适用，即 Hessian 处处半正定的函 数。因为这些函数没有鞍点而且其所有局部极小点必然是全局最小点，所以表现很 好。然而，深度学习中的大多数问题都难以表示成凸优化的形式。凸优化仅用作一 些深度学习算法的子程序。凸优化中的分析思路对证明深度学习算法的收敛性非常 有用，然而一般来说，深度学习背景下凸优化的重要性大大减少。 </p><h2 id="约束优化"><a href="#约束优化" class="headerlink" title="约束优化"></a>约束优化</h2><p>在 x 的某些集合 S 中找 f(x) 的最大值或最小值。这被称 为 约束优化(constrained optimization)。在约束优化术语中，集合 S 内的点 x 被称为可行(feasible)点。 </p><p>我们常常希望找到在某种意义上小的解。针对这种情况下的常见方法是强加一 个范数约束，如 ||x|| ≤ 1。 </p><p><strong>Karush–Kuhn–Tucker</strong>(KKT)方法是针对约束优化非常通用的解决方案。KKT 方法是 <strong>Lagrange 乘子法</strong>(只允许等式约束)的推广。</p><p>我们可以使用一组简单的性质来描述约束优化问题的最优点。这些性质称 为 Karush–Kuhn–Tucker(KKT)条件 (Karush, 1939; Kuhn and Tucker, 1951)。 这些是确定一个点是最优点的必要条件，但不一定是充分条件。这些条件是:</p><ul><li>广义 Lagrangian 的梯度为零。</li><li>所有关于 x 和 KKT 乘子的约束都满足。</li><li>不等式约束显示的 ‘‘互补松弛性’’. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;上溢和下溢&quot;&gt;&lt;a href=&quot;#上溢和下溢&quot; class=&quot;headerlink&quot; title=&quot;上溢和下溢&quot;&gt;&lt;/a&gt;上溢和下溢&lt;/h2&gt;&lt;p&gt;连续数学在数字计算机上的根本困难是,我们需要通过有限数量的位模式来表示无限多的实数。这意味着我们在计算机中表示实数时
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》3 概率与信息论</title>
    <link href="https://github.com/zdkswd/2018/08/01/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B3%20%E6%A6%82%E7%8E%87%E4%B8%8E%E4%BF%A1%E6%81%AF%E8%AE%BA/"/>
    <id>https://github.com/zdkswd/2018/08/01/《深度学习》3 概率与信息论/</id>
    <published>2018-08-01T09:20:12.000Z</published>
    <updated>2018-08-10T03:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用概率"><a href="#为什么要使用概率" class="headerlink" title="为什么要使用概率"></a>为什么要使用概率</h2><p>在医生诊断病人的例子中,我们用概率来表示一种信任度( degree of belief),其中1表示非常肯定病人患有流感,而0表示非常肯定病人没有流感。前面那种概率,直接与事件发生的频率相联系,被称为<strong>频率派概率</strong>( frequentist probability);而后者,涉及到确定性水平,被称为<strong>贝叶斯概率</strong>( Bayesian probability)。</p><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p><strong>随机变量</strong>( random variable)是可以随机地取不同值的变量。</p><p>随机变量可以是离散的或者连续的。离散随机变量拥有有限或者可数无限多的状态。注意这些状态不一定非要是整数;它们也可能只是一些被命名的状态而没有数值。连续随机变量伴随着实数值。</p><h2 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h2><h3 id="离散型变量和概率质量函数"><a href="#离散型变量和概率质量函数" class="headerlink" title="离散型变量和概率质量函数"></a>离散型变量和概率质量函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%887.20.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也有翻译成概率分布律的</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%887.22.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%887.23.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="连续型变量和概率密度函数"><a href="#连续型变量和概率密度函数" class="headerlink" title="连续型变量和概率密度函数"></a>连续型变量和概率密度函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8810.55.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8810.56.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="边缘概率"><a href="#边缘概率" class="headerlink" title="边缘概率"></a>边缘概率</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8810.58.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.00.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.00.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="条件概率的链式法则"><a href="#条件概率的链式法则" class="headerlink" title="条件概率的链式法则"></a>条件概率的链式法则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.02.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="独立性和条件独立性"><a href="#独立性和条件独立性" class="headerlink" title="独立性和条件独立性"></a>独立性和条件独立性</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.05.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果关于x和y的条件概率分布对于z的每一个值都可以写成乘积的形式那么这两个随机变量x和y在给定随机变量z时是条件独立的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.07.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="期望、方差和协方差"><a href="#期望、方差和协方差" class="headerlink" title="期望、方差和协方差"></a>期望、方差和协方差</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.10.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.13.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.18.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>协方差的绝对值如果很大则意味着变量值变化很大并且它们同时距离各自的均值很远。如果协方差是正的,那么两个变量都倾向于同时取得相对较大的值。如果协方差是负的,那么其中一个变量倾向于取得相对较大的值的同时,另一个变量倾向于取得相对较小的值,反之亦然。其他的衡量指标如<strong>相关系数</strong>( correlation)将每个变量的贡献归一化,为了只衡量变量的相关性而不受各个变量尺度大小的影响。</p><p>协方差和相关性是有联系的,但实际上是不同的概念。它们是有联系的,因为两个变量如果相互独立那么它们的协方差为零,如果两个变量的协方差不为零那么它们一定是相关的。然而,独立性又是和协方差完全不同的性质。两个变量如果协方差为零,它们之间一定没有线性关系。独立性比零协方差的要求更强,因为独立性还排除了非线性的关系。两个变量相互依赖但具有零协方差是可能的。</p><h2 id="常用概率分布"><a href="#常用概率分布" class="headerlink" title="常用概率分布"></a>常用概率分布</h2><h3 id="Bernoulli分布（01分布）"><a href="#Bernoulli分布（01分布）" class="headerlink" title="Bernoulli分布（01分布）"></a>Bernoulli分布（01分布）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8A%E5%8D%8811.26.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Multinoulli分布"><a href="#Multinoulli分布" class="headerlink" title="Multinoulli分布"></a>Multinoulli分布</h3><p>就是多项分布。</p><h3 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h3><p>即为正态分布。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="指数分布和-Laplace分布"><a href="#指数分布和-Laplace分布" class="headerlink" title="指数分布和 Laplace分布"></a>指数分布和 Laplace分布</h3><h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331064341410.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331064440953.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.54.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.54.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="拉普拉斯分布"><a href="#拉普拉斯分布" class="headerlink" title="拉普拉斯分布"></a>拉普拉斯分布</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%882.56.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331065959408.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Dirac分布和经验分布"><a href="#Dirac分布和经验分布" class="headerlink" title="Dirac分布和经验分布"></a>Dirac分布和经验分布</h3><h4 id="Dirac分布"><a href="#Dirac分布" class="headerlink" title="Dirac分布"></a>Dirac分布</h4><p>狄拉克δ函数是一个广义函数，在物理学中常用其表示质点、点电荷等理想模型的密度分布，该函数在除了零以外的点取值都等于零，而其在整个定义域上的积分等于1。</p><p>狄拉克δ函数在概念上，它是这么一个“函数”：在除了零以外的点函数值都等于零，而其在整个定义域上的积分等于1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/15331067947005.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="经验分布"><a href="#经验分布" class="headerlink" title="经验分布"></a>经验分布</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.08.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="分布的混合"><a href="#分布的混合" class="headerlink" title="分布的混合"></a>分布的混合</h3><p>通过组合一些简单的概率分布来定义新的概率分布也是很常见的。一种通用的组合方法是构造<strong>混合分布</strong>( mixture distribution)。混合分布由一些组件( component)<br>分布构成。</p><p>混合模型是组合简单概率分布来生成更丰富的分布的一种简单策略。</p><p>混合模型使我们能够一瞥以后会用到的一个非常重要的概念—<strong>潜变量</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.15.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="常用函数的有用性质"><a href="#常用函数的有用性质" class="headerlink" title="常用函数的有用性质"></a>常用函数的有用性质</h2><h3 id="logistic-sigmoid函数"><a href="#logistic-sigmoid函数" class="headerlink" title="logistic sigmoid函数"></a>logistic sigmoid函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.18.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.18.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="softplus函数"><a href="#softplus函数" class="headerlink" title="softplus函数"></a>softplus函数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.52.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.52.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.52.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.53.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.54.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="贝叶斯规则"><a href="#贝叶斯规则" class="headerlink" title="贝叶斯规则"></a>贝叶斯规则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%883.55.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="连续型变量的技术细节"><a href="#连续型变量的技术细节" class="headerlink" title="连续型变量的技术细节"></a>连续型变量的技术细节</h2><p>连续型随机变量和概率密度函数的深入理解需要用到数学分支<strong>测度论</strong>(Ineasure heory)的相关内容来扩展概率论。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.01.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.02.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.04.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.04.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h2><p>信息论是应用数学的一个分支,主要研究的是对一个信号包含信息的多少进行量化。在机器学习中,我们也可以把信息论应用于连续型变量。</p><p>信息论的基本想法是一个不太可能的事件居然发生了,要比一个非常可能的事件发生,能提供更多的信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.16.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.19.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.22.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也记作H(P)。换言之,一个分布的香农熵是指遵循这个分布的事件所产生的期望信息总量。当x是连续的,香农熵被称为<strong>微分熵</strong>( differential entropy)。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.33.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.49.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>又称为<strong>相对熵</strong>，是用来度量使用基于Q的编码来编码来自P的样本平均所需的额外的比特个数。典型情况下，P表示数据的真实分布，Q表示数据的理论分布，模型分布，或P的近似分布。</p><p>是描述两个概率分布P和Q差异的一种方法。它是非对称的，这意味着D(P||Q) ≠ D(Q||P)。特别的，在信息论中，D(P||Q)表示当用概率分布Q来拟合真实分布P时，产生的信息损耗，其中P表示真实分布，Q表示P的拟合分布。</p><p>有人将KL散度称为KL距离，但事实上，KL散度并不满足距离的概念，因为：(1)KL散度不是对称的；(2)KL散度不满足三角不等式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.55.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%884.59.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="结构化概率模型"><a href="#结构化概率模型" class="headerlink" title="结构化概率模型"></a>结构化概率模型</h2><p>机器学习的算法经常会涉及到在非常多的随机变量上的概率分布。通常，这些概率分布涉及到的直接相互作用都是介于非常少的变量之间的。使用单个函数来描述整个联合概率分布是非常低效的 (无论是计算上还是统计上)。 </p><p>我们可以把概率分布分解成许多因子的乘积形式，而不是使用单一的函数来表 示概率分布。例如，假设我们有三个随机变量 a, b 和 c，并且a影响b的取值，b影响c的取值，但是 a 和 c 在给定 b 时是条件独立的。我们可以把全部三个变量的概 率分布重新表示为两个变量的概率分布的连乘形式:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%885.09.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>这种分解可以极大地减少用来描述一个分布的参数数量。每个因子使用的参数 数目是它的变量数目的指数倍。 </p><p>我们可以用图来描述这种分解。把它称为<strong>结构化概率模型</strong>(structured probabilistic model)或者<strong>图模型</strong>(graphical model)。 </p><p>有两种主要的结构化概率模型:有向的和无向的。两种图模型都使用图 G，其中 图的每个节点对应着一个随机变量，连接两个随机变量的边意味着概率分布可以表 示成这两个随机变量之间的直接作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%885.13.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15330351447482/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-01%20%E4%B8%8B%E5%8D%885.18.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要使用概率&quot;&gt;&lt;a href=&quot;#为什么要使用概率&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用概率&quot;&gt;&lt;/a&gt;为什么要使用概率&lt;/h2&gt;&lt;p&gt;在医生诊断病人的例子中,我们用概率来表示一种信任度( degree of belief),其
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》2 线性代数</title>
    <link href="https://github.com/zdkswd/2018/07/31/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B2%20%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/07/31/《深度学习》2 线性代数/</id>
    <published>2018-07-31T09:41:12.000Z</published>
    <updated>2018-08-10T03:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标量、向量、矩阵和张量"><a href="#标量、向量、矩阵和张量" class="headerlink" title="标量、向量、矩阵和张量"></a>标量、向量、矩阵和张量</h2><ul><li><strong>标量</strong>( scalar)一个标量就是一个单独的数,它不同于线性代数中研究的其他大部分对象(通常是多个数的数组)。我们用斜体表示标量。标量通常被赋予小写的变量名称。当我们介绍标量时,会明确它们是哪种类型的数。比如,在定义实数标量时,我们可能会说“令s∈R表示一条线的斜率”;在定义自然数标量时,我们可能会说“令n∈N表示元素的数目”。</li><li><strong>向量</strong>( vector):一个向量是一列数。这些数是有序排列的。通过次序中的索引,我们可以确定每个单独的数。通常我们赋予向量粗体的小写变量名称,比如<strong>x</strong>。向量中的元素可以通过带脚标的斜体表示。向量<strong>x</strong>的第一个元素是x1,第二个元素是x2,等等。我们也会注明存储在向量中的元素是什么类型的。如果每个元素都属于R,并且该向量有n个元素,那么该向量属于实数集R的n次笛卡尔乘积构成的集合,记为<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.20.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>。当需要明确表示向量中的元素时,我们会将元素排列成一个方括号包围的纵列:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.22.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们可以把向量看作空间中的点,每个元素是不同坐标轴上的坐标。有时我们需要索引向量中的一些元素。在这种情况下,我们定义一个包含这些元素索引的集合,然后将该集合写在脚标处。比如,指定x1,和,我们定义集合S={1,3,6},然后写作xs。我们用符号一表示集合的补集中的索引。比如<strong>x</strong>-1表示<strong>x</strong>中除x1外的所有元素,<strong>x-s</strong>表示<strong>x</strong>中除x1,x3,x6外所有元素构成的向量。</p><ul><li><strong>矩阵</strong>( matrix):矩阵是一个二维数组,其中的每一个元素被两个索引(而非一个)所确定。我们通常会赋予矩阵粗体的大写变量名称,比如<strong>A（斜体）</strong>。如果一个实数矩阵高度为m,宽度为n,那么我们说<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.37.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>。我们在表示矩阵中的元素时,通常以不加粗的斜体形式使用其名称,索引用逗号间隔。比如,A1，1表示A左上的元素,Am，n表示A右下的元素。我们通过用“：”表示水平坐标,以表示垂直坐标i中的所有元素。比如,Ai,:表示<strong>A</strong>中垂直坐标i上的一横排元素。这也被称为A的第i行(row)。同样地,A:,i表示A的第i列column)。当我们需要明确表示矩阵中的元素时,我们将它们写在用方括号括起来的数组中:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.40.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>有时我们需要矩阵值表达式的索引,而不是单个元素。在这种情况下,我们在表达式后面接下标,但不必将矩阵的变量名称小写化。比如<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.44.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>表示函数f作用在A上输出的矩阵的第i行第j列元素。</li><li><strong>张量</strong>( tensor):在某些情况下,我们会讨论坐标超过两维的数组。一般地个数组中的元素分布在若干维坐标的规则网格中,我们称之为张量。我们使用字体<strong>A（不是斜体）</strong>来表示张量“A”。张量A中坐标为(i,j,k)的元素记作Ai,j,k。</li><li><strong>转置</strong>( transpose)是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像这条从左上角到右下角的对角线被称为主对角线( main diagonal)。我们将矩阵A的转置表示为AT,定义如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.52.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>向量可以看作只有一列的矩阵。对应地,向量的转置可以看作是只有一行的矩阵。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8810.55.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>。标量可以看作是只有一个元素的矩阵。因此,标量的转置等于它本身,a=aT。<br>转置的运算性质<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【】只是记法</span><br></pre></td></tr></table></figure><p> <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.10.22.png" alt=""><br>在深度学习中,我们也使用一些不那么常规的符号。我们允许矩阵和向量相加,产生另一个矩阵:<strong>C</strong>=<strong>A</strong>+<strong>b</strong>,其中<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.13.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>。换言之,向量b和矩阵A的每一行相加。这个简写方法使我们无需在加法操作前定义一个将向量b复制到每一行而生成的矩阵。这种隐式地复制向量b到很多位置的方式,被称为<strong>广播</strong>( broadcasting )。</p><h2 id="矩阵和向量相乘"><a href="#矩阵和向量相乘" class="headerlink" title="矩阵和向量相乘"></a>矩阵和向量相乘</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.18.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.20.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="单位矩阵和逆矩阵"><a href="#单位矩阵和逆矩阵" class="headerlink" title="单位矩阵和逆矩阵"></a>单位矩阵和逆矩阵</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.23.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.24.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="线性相关和生成子空间"><a href="#线性相关和生成子空间" class="headerlink" title="线性相关和生成子空间"></a>线性相关和生成子空间</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.39.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.40.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还有一种看法是以列向量为新的参考系，看在参考系下要表示的向量的坐标。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.46.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不等式n≥m仅是方程对每一点都有解的必要条件。这不是一个充分条件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.31.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.39.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇异值行列式为0</span><br></pre></td></tr></table></figure></p><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>有时我们需要衡量一个向量的大小。在机器学习中,我们经常使用被称为<strong>范数</strong>（norm)的函数衡量向量大小。形式上,<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.41.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>范数定义如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.41.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>范数(包括<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.55.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>范数)是将向量映射到非负值的函数。直观上来说,向量<strong>x</strong>的范数衡量从原点到点<strong>x</strong>的距离。更严格地说,范数是满足下列性质的任意函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.44.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当p=2时,<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.51.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>范数被称为欧几里得范数( Euclidean norm)。它表示从原点出发到向量c确定的点的欧几里得距离。L2范数在机器学习中出现地十分频繁,经常简化表示为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.52.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>,略去了下标2。平方L2范数也经常用来衡量向量的大小,可以简单地通过点积<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.52.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>计算。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%886.56.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.00.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.01.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>另外一个经常在机器学习中出现的范数是L∞范数,也被称为最大范数（max norm)这个范数表示向量中具有最大幅值的元素的绝对值:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.03.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.03.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">弗罗贝尼乌斯范数</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.05.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="特殊类型的矩阵和向量"><a href="#特殊类型的矩阵和向量" class="headerlink" title="特殊类型的矩阵和向量"></a>特殊类型的矩阵和向量</h2><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.07.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="对称"><a href="#对称" class="headerlink" title="对称"></a>对称</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.08.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%887.12.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8B%E5%8D%889.52.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h2><p><strong>特征分解</strong>( eigendecomposition)是使用最广的矩阵分解之一,即我们将矩阵分解成一组特征向量和特征值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.00.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.06.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.06.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.13.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.16.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">矩阵A乘以x表示，对向量x进行一次转换（旋转或拉伸)（是一种线性转换），而该转换的效果为常数c乘以向量x（即只进行拉伸）。</span><br></pre></td></tr></table></figure></p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>我们探讨了如何将矩阵分解成特征向量和特征值。还有另一种分解矩阵的方法,被称为<strong>奇异值分解</strong>( singular value decomposition,SVD),将矩阵分解为奇异向量( singular vector)和奇异值( singular value)。通过奇异值分解,我们会得到一些与特征分解相同类型的信息。然而,<strong>奇异值分解有更广泛的应用</strong>。<strong>每个实数矩阵都有一个奇异值分解,但不一定都有特征分解</strong>。例如,非方阵的矩阵没有特征分解,这时我们只能使用奇异值分解。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.23.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%8812.23.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Moore-Penrose伪逆"><a href="#Moore-Penrose伪逆" class="headerlink" title="Moore-Penrose伪逆"></a>Moore-Penrose伪逆</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.13.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.19.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="迹运算"><a href="#迹运算" class="headerlink" title="迹运算"></a>迹运算</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.21.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-31%20%E4%B8%8B%E5%8D%885.26.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>另一个有用的事实是标量在迹运算后仍然是它自己:a=Tr(a)。</p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>行列式,记作det(A),是一个将方阵A映射到实数的函数。行列式等于矩阵特征值的乘积。行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或者缩了多少。如果行列式是0,那么空间至少沿着某一维完全收缩了,使其失去了所有的体积。如果行列式是1,那么这个转换保持空间体积不变。</p><h2 id="实例-主成分分析"><a href="#实例-主成分分析" class="headerlink" title="实例:主成分分析"></a>实例:主成分分析</h2><p><strong>主成分分析</strong>( principal components analysis,PCA)是一个简单的机器学习算法,可以通过基础的线性代数知识推导。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标量、向量、矩阵和张量&quot;&gt;&lt;a href=&quot;#标量、向量、矩阵和张量&quot; class=&quot;headerlink&quot; title=&quot;标量、向量、矩阵和张量&quot;&gt;&lt;/a&gt;标量、向量、矩阵和张量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标量&lt;/strong&gt;( scalar)
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习》 1 引言</title>
    <link href="https://github.com/zdkswd/2018/07/29/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%201%20%E5%BC%95%E8%A8%80/"/>
    <id>https://github.com/zdkswd/2018/07/29/《深度学习》 1 引言/</id>
    <published>2018-07-29T10:55:12.000Z</published>
    <updated>2018-08-10T03:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>讽刺的是,抽象和形式化的任务对人类而言是最困难的脑力任务之一,但对计算机而言却属于最容易的。计算机早就能够打败人类最好的象棋选手,但直到最近计算机才在识别对象或语音任务中达到人类平均水平。一个人的日常生活需要关于世界的巨量知识。很多这方面的知识是主观的、直观的,因此很难通过形式化的方式表达清楚。计算机需要获取同样的知识才能表现出智能。人工智能的一个关键挑战就是如何将这些非形式化的知识传达给计算机。</p><p>些人工智能项目力求将关于世界的知识用形式化的语言进行硬编码(hard code)。计算机可以使用逻辑推理规则来自动地理解这些形式化语言中的声明。这就是众所周知的人工智能的知识库( knowledge base)方法。然而,这些项目最终都没有取得重大的成功。其中最著名的项目是 Cyc(Lenat and Guha,1989)Cyc包括一个推断引擎和一个使用CycL语言描述的声明数据库。这些声明是由人类监督者输入的。这是一个笨拙的过程。人们设法设计出足够复杂的形式化规则来精确地描述世界。例如,Cyc不能理解一个关于名为rred的人在早上剃须的故事( Linde,1992)。它的推理引擎检测到故事中的不一致性:它知道人体的构成不包含电气零件,但由于Fred正拿着一个电动剃须刀,它认为实体“正在剃须的Fred”(“ Fred While Shaving”)含有电气部件。因此它产生了这样的疑问—Fred在刮胡子的时候是否仍然是一个人。；）</p><p>依靠硬编码的知识体系面对的困难表明,<strong>AI系统需要具备自己获取知识的能力即从原始数据中提取模式的能力</strong>。这种能力被称为<strong>机器学习</strong>( machine learning)引入机器学习使计算机能够解决涉及现实世界知识的问题，并能作出看似主观的决策。比如,一个被称为<strong>逻辑回归</strong>( logistic regression)的简单机器学习算法可以决定是否建议剖腹产(Mor- Yosef et al,1990)。而同样是简单机器学习算法的<strong>朴素贝叶斯</strong>( naive Bayes)则可以区分垃圾电子邮件和合法电子邮件</p><p>这些简单的机器学习算法的性能在很大程度上依赖于给定数据的<strong>表示</strong>( repre-sentation)。</p><p>许多人工智能任务都可以通过以下方式解决:先提取一个合适的<strong>特征集</strong>,然后将这些特征提供给简单的机器学习算法。例如,对于通过声音鉴别说话者的任务来说,一个有用的特征是对其声道大小的估计。这个特征为判断说话者是男性、女性还是儿童提供了有力线索。</p><p>然而,对于许多任务来说,我们很难知道应该提取哪些特征。例如,假设我们想编写一个程序来检测照片中的车。我们知道,汽车有轮子,所以我们可能会想用车轮的存在与否作为特征。不幸的是,我们难以准确地根据像素值来描述车轮看上去像什么。虽然车轮具有简单的几何形状,但它的图像可能会因场景而异,如落在车轮上的阴影、太阳照亮的车轮的金属零件、汽车的挡泥板或者遮挡的车轮一部分的前景物体等等。</p><p>解决这个问题的途径之一是使用机器学习来发掘表示本身,而不仅仅把表示映射到输出。这种方法我们称之为<strong>表示学习</strong>( representation learning)。学习到的表<br>示往往比手动设计的表示表现得更好。并且它们只需最少的人工干预,就能让AI系统迅速适应新的任务。表示学习算法只需几分钟就可以为简单的任务发现一个很好的特征集,对于复杂任务则需要几小时到几个月。手动为一个复杂的任务设计特征需要耗费大量的人工时间和精力;甚至需要花费整个社群研究人员几十年的时间。</p><p>表示学习算法的典型例子是<strong>自编码器</strong>( autoencoder)。自编码器由一个<strong>编码器</strong>( encoder)函数和一个<strong>解码器</strong>( decoder)函数组合而成。编码器函数将输入数据转换为一种不同的表示,而解码器函数则将这个新的表示转换到原来的形式。我们期望当输人数据经过编码器和解码器之后尽可能多地保留信息,同时希望新的表示有各种好的特性,这也是自编码器的训练目标。为了实现不同的特性,我们可以设计不同形式的自编码器。</p><p>当设计特征或设计用于学习特征的算法时,我们的目标通常是分离出能解释观察数据的<strong>变差因素</strong>( factors of variation)。在此背景下,“因素”这个词仅指代影响的不同来源;因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反,它们可能是现实世界中观察不到的物体或者不可观测的力,但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因,它们还可能以概念的形式存在于人类的思维中。它们可以被看作数据的概念或者抽象,帮助我们了解这些数据的丰富多样性。当分析语音记录时,变差因素包括说话者的年龄、性别、他们的口音和他们正在说的词语。当分析汽车的图像时,变差因素包括汽车的位置、它的颜色、太阳的角度和亮度。</p><p>显然,从原始数据中提取如此高层次、抽象的特征是非常困难的。许多诸如说话口音这样的变差因素,只能通过对数据进行复杂的、接近人类水平的理解来辨识。这几乎与获得原问题的表示一样困难,因此,乍一看,表示学习似乎并不能帮助我们。</p><p><strong>深度学习</strong>( deep learning)通过其他较简单的表示来表达复杂表示,解决了表示学习中的核心问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%885.55.44.png" alt="屏幕快照 2018-07-29 下午5.55.44" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午5.55.44</div>            </figure></p><p>如何通过组合较简单的概念(例如转角和轮廓,它们转而由边线定义)来表示图像中人的概念。深度学习模型的典型例子是前馈深度网络或<strong>多层感知机</strong>( multilayer perceptron,MLP)。多层感知机仅仅是一个将一组输人值映射到输出值的数学函数该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</p><p>学习数据的正确表示的想法是解释深度学习的一个视角。<strong>另一个视角</strong>是深度促使计算机学习一个多步骤的计算机程序。每一层表示都可以被认为是并行执行另组指令之后计算机的存储器状态。更深的网络可以按顺序执行更多的指令。顺序指令提供了极大的能力,因为后面的指令可以参考早期指令的结果。从这个角度上看在某层激活函数里,并非所有信息都蕴涵着解释输入的变差因素。表示还存储着状态信息,用于帮助程序理解输人。这里的状态信息类似于传统计算机程序中的计数器或指针。它与具体的输人内容无关,但有助于模型组织其处理过程。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.03.19.png" alt="屏幕快照 2018-07-29 下午6.03.19" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.03.19</div>            </figure></p><p>由于不同的人选择不同的最小元素集来构建相应的图,因此就像计算机程序的长度不存在单一的正确值一样,架构的深度也不存在单一的正确值。另外,也不存在模型多么深才能被修饰为“深”的共识。但相比传统机器学习,深度学习研究的模型涉及更多学到功能或学到概念的组合,这点毋庸置疑。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.07.58.png" alt="屏幕快照 2018-07-29 下午6.07.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.07.58</div>            </figure></p><h2 id="本书面向的读者"><a href="#本书面向的读者" class="headerlink" title="本书面向的读者"></a>本书面向的读者</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.09.31.png" alt="屏幕快照 2018-07-29 下午6.09.31" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.09.31</div>            </figure><h2 id="深度学习的历史趋势"><a href="#深度学习的历史趋势" class="headerlink" title="深度学习的历史趋势"></a>深度学习的历史趋势</h2><h3 id="神经网络的众多名称和命运变迁"><a href="#神经网络的众多名称和命运变迁" class="headerlink" title="神经网络的众多名称和命运变迁"></a>神经网络的众多名称和命运变迁</h3><p>20世纪40年代到60年代深度学习的雏形出现在控制论( cybernetics)中。</p><p>尽管有些机器学习的神经网络有时被用来理解大脑功能( Hinton and shallice,1991),但它们一般都没有被设计成生物功能的真实模型。</p><p>现在,神经科学被视为深度学习研究的一个重要灵感来源,但它已不再是该领域的主要指导。</p><p>媒体报道经常强调深度学习与大脑的相似性。的确,深度学习研究者比其他器学习领域(如核方法或贝叶斯统计)的研究者更可能地引用大脑作为影响,但是大家不应该认为深度学习在尝试模拟大脑。</p><p>深度学习领域主要关注如何构建计算机系统,从而成功解决需要智能才能解决的任务,而计算神经科学领域主要关注构建大脑如何进行真实工作的比较精确的模型。</p><p>在20世纪80年代,神经网络研究的第二次浪潮在很大程度上是伴随一个被称为<strong>联结主义</strong>( connectionism)或并行分布处理( parallel distributed processing)潮流而出现的( Rumelhart et al,1986d; McClelland et al,1995)。</p><p><strong>联结主义</strong>的中心思想是,当网络将大量简单的计算单元连接在一起时可以实现智能行为。这种见解同样适用于生物神经系统中的神经元,因为它和计算模型中隐藏单元起着类似的作用。</p><p>其中一个概念是<strong>分布式表示</strong>( distributed representation)( Hinton et al,1986)其思想是:系统的每一个输入都应该由多个特征表示,并且每一个特征都应该参与到多个可能输人的表示。例如,假设我们有一个能够识别红色、绿色、或蓝色的汽车、卡车和鸟类的视觉系统,表示这些输人的其中一个方法是将九个可能的组合:红<br>卡车,红汽车,红鸟,绿卡车等等使用单独的神经元或隐藏单元激活。这需要九个不同的神经元,并且每个神经必须独立地学习颜色和对象身份的概念。改善这种情况的方法之一是使用<strong>分布式表示</strong>,即用三个神经元描述颜色,三个神经元描述对象身份。这仅仅需要6个神经元而不是9个,并且描述红色的神经元能够从汽车、卡车和鸟类的图像中学习红色,而不仅仅是从一个特定类别的图像中学习。分布式表示的概念是本书的<strong>核心</strong>。</p><p>联结主义潮流的另一个重要成就是<strong>反向传播</strong>在训练具有内部表示的深度神经网络中的成功使用以及反向传播算法的普及( Rumelhart et al,1986c; LeCun,1987)。这个算法虽然曾黯然失色不再流行,但截至写书之时,它仍是训练深度模型的主导方法。</p><p>在20世纪90年代,研究人员在使用神经网络进行序列建模的方面取得了重要进展。 Hochreiter(191b)和 Bengio et al.(1994a)指出了对长序列进行建模的些根本性数学难题, Hochreiter and schmidhuber(1997)引入<strong>长短期记忆</strong>( long short-term memory,LSTM)网络来解决这些难题。如今,LSTM在许多序列建模任务中广泛应用,包括 Google的许多自然语言处理任务。</p><p>神经网络研究的第三次浪潮始于2006年的突破。Geoffrey Hinton表明名为深度信念网络的神经网络可以使用一种称为贪婪逐层预训练的策略来有效地训练。</p><p>神经网络研究的这一次浪潮普及了“深度学习”这一术语的使用,强调研究者现在有能力训练以前不可能训练的比较深的神经网络,并着力于深度的理论重要。此时,深度神经网络已经优于与之竞争的基于其他机器学习技术以及手工设计功能的AI系统。</p><p>尽管深度学习的研究重点在这一段时间内发生了巨大变化。第三次浪潮已开始着眼于新的无监督学习技术和深度模型在小数据集的泛化能力,但目前更多的兴趣点仍是比较传统的监督学习算法和深度模型充分利用大型标注数据集的能力。</p><h3 id="与日俱增的数据量"><a href="#与日俱增的数据量" class="headerlink" title="与日俱增的数据量"></a>与日俱增的数据量</h3><p>“大数据”时代使机器学习更加容易。截至2016年,一个粗略的经验法则是,监督深度学习算法在每类给定约5000个标注样本情况下一般将达到可以接受的性能,当至少有1000万个标注样本的数据集用于训练时,它将达到或超过人类表现。此外,在更小的数据集上获得成功是一个重要的研究领域,为此我们应特别侧重于如何通过无监督或半监督学习充分利用大量的未标注样本。</p><h3 id="与日俱增的模型规模"><a href="#与日俱增的模型规模" class="headerlink" title="与日俱增的模型规模"></a>与日俱增的模型规模</h3><p>20世纪80年代,神经网络只能取得相对较小的成功,而现在神经网络非常成功的另一个重要原因是我们现在拥有的计算资源可以运行更大的模型。联结主义的主要见解之一是,当动物的许多神经元一起工作时会变得聪明。单独神经元或小集合的神经元不是特别有用。</p><p>就神经元的总数目而言,直到最近神经网络都是惊人的小。自从隐藏单元引人以来,人工神经网络的规模大约每2.4年扩大一倍。这种增长是由更大内存、更快的计算机和更大的可用数据集驱动的。更大的网络能够在更复杂的任务中实现更高的精度。这种趋势看起来将持续数十年。除非有能力迅速扩展的新技术,否则至少要到21世纪50年代,人工神经网络将才能具备与人脑相同数量级的神经元。生物神经元表示的功能可能比目前的人工神经元所表示的更复杂。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.47.54.png" alt="屏幕快照 2018-07-29 下午6.47.54" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.47.54</div>            </figure><br>现在看来,其神经元比一个水蛭还少的神经网络不能解决复杂的人工智能问题是不足为奇的。即使现在的网络,从计算系统角度来看它可能相当大的,但实际上它比相对原始的脊椎动物如青蛙的神经系统还要小。</p><p>由于更快的CPU、通用GPU的出现更快的网络连接和更好的分布式计算的软件基础设施,模型规模随着时间的推移不断增加是深度学习历史中最重要的趋势之一。人们普遍预计这种趋势将很好地持续到未来。</p><h3 id="与日俱增的精度、复杂度和对现实世界的冲击"><a href="#与日俱增的精度、复杂度和对现实世界的冲击" class="headerlink" title="与日俱增的精度、复杂度和对现实世界的冲击"></a>与日俱增的精度、复杂度和对现实世界的冲击</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15327808185326/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%886.51.21.png" alt="屏幕快照 2018-07-29 下午6.51.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-29 下午6.51.21</div>            </figure><p>深度学习的另一个最大的成就是其在强化学习( reinforcement learning)领域的扩展。在强化学习中,一个自主的智能体必须在没有人类操作者指导的情况下,通过试错来学习执行任务。 DeepMind表明,基于深度学习的强化学习系统能够学会玩并在多种任务中可与人类匹敌Mnih et al.,2015)。深度学习也显著改善了机器人强化学习的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;讽刺的是,抽象和形式化的任务对人类而言是最困难的脑力任务之一,但对计算机而言却属于最容易的。计算机早就能够打败人类最好的象棋选手,但直到最近
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://github.com/zdkswd/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 14 函数式编程</title>
    <link href="https://github.com/zdkswd/2018/07/26/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2014%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/07/26/松本行弘的程序世界 14 函数式编程/</id>
    <published>2018-07-26T13:00:32.000Z</published>
    <updated>2018-07-27T03:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-14-函数式编程"><a href="#松本行弘的程序世界-14-函数式编程" class="headerlink" title="松本行弘的程序世界 14 函数式编程"></a>松本行弘的程序世界 14 函数式编程</h1><h2 id="新范型–函数式编程"><a href="#新范型–函数式编程" class="headerlink" title="新范型–函数式编程"></a>新范型–函数式编程</h2><p>函数式编程是全部使用函数来编写程序代码的编程方法。这是可以与一般的结构化编程及面向对象编程相提并论的编程方法。</p><p>以函数为中心的函数式编程具有特征：</p><ol><li>函数本身也作为数据来处理（第一级函数）</li><li>以函数为参数的高阶函数</li><li>参数相同即可保证结果相同的引用透明性。</li><li>为实现引用透明性，禁止产生副作用的处理。</li></ol><p>函数式编程的最大优点在于，程序可以按照数学的形式以及声明的形式来编写。</p><p>结构式编程是在改变变量值的同时进行计算，所以一直注意着，这个变量的值是什么，并据此来预想计算过程。</p><p>采用函数式编程方式并不改变变量的值。并不包含状态或者动作等信息，仅仅是对想要做什么加以描述，这样不容易出错。</p><p>这种不是描述动作而是描述性质的编程方式称为<strong>声明式编程</strong>。声明式描述是函数式编程的一大优点。</p><h3 id="具有多种函数式性质的Lisp"><a href="#具有多种函数式性质的Lisp" class="headerlink" title="具有多种函数式性质的Lisp"></a>具有多种函数式性质的Lisp</h3><p>之前，Lisp被认为是函数式编程的代表。Lisp具备函数式语言的很多性质。</p><p>Lisp最大的特征是S式记法。S式是括号很多的Lisp的记法。S式无与伦比的优点是它彻底的统一性。对Lisp而言，不管什么都可以同一成单一形式。</p><p>第二个重要之处在于链这种数据结构。Lisp语言本名是List Processor（链表处理器），从侧面说明了链的重要性。链是一种构成树结构数据的通用数据结构，构成数据结构的节点分别包含两个引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8A%E5%8D%8810.02.29.png" alt="屏幕快照 2018-07-25 上午10.02.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 上午10.02.29</div>            </figure></p><p>总之，Lisp具备了函数编程语言的基本特征。但是Lisp不直接支持多数纯粹的函数式编程语言所拥有的副作用如回避以及延迟计算等功能。对变量的赋值没有任何限制。且编程风格为很多很多括号。比较难适应。</p><p>近年来，由于像Haskell这样的彻底的函数式编程语言的兴起，Lisp作为函数式编程语言在人们心中的印象越来越淡薄。</p><h3 id="彻底的函数式编程语言Haskell"><a href="#彻底的函数式编程语言Haskell" class="headerlink" title="彻底的函数式编程语言Haskell"></a>彻底的函数式编程语言Haskell</h3><p>Haskell可以说是纯粹的函数式编程语言。<br>Haskell语言特征：</p><ol><li>没有副作用</li><li>高阶函数</li><li>函数部分应用</li><li>延迟计算(非正式)</li><li>静态多态类型系统</li><li>型推论</li><li>链内包表达式</li><li>用对齐来表示块</li></ol><h4 id="没有副作用"><a href="#没有副作用" class="headerlink" title="没有副作用"></a>没有副作用</h4><p>Haskell程序基本没有副作用，不但不能改变变量的值，就连链的元素也是不能改变的。因此，只要参数不变，函数的返回值也就总是一样的。相同输入总能返回相同结果，这种可重复性对测试程序非常有利。这种重复性也称为引用透明性。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>Haskell高阶函数把函数本身作为数据来处理。比如，Haskell中没有循环控制结构，循环都是用递归调用或者高阶函数来实现的。</p><h4 id="延迟计算：不必要的处理就不做"><a href="#延迟计算：不必要的处理就不做" class="headerlink" title="延迟计算：不必要的处理就不做"></a>延迟计算：不必要的处理就不做</h4><p>必要时才进行处理。</p><h3 id="灵活的“静态多态性”类型系统"><a href="#灵活的“静态多态性”类型系统" class="headerlink" title="灵活的“静态多态性”类型系统"></a>灵活的“静态多态性”类型系统</h3><p>与没有类型的Ruby不同，Haskell是在编译时确定所有变量类型的静态类型语言。但实际上Haskell程序基本上没有必要给出变量的类型。这是因为聪明的Haskell语言处理系统会推测变量的类型。</p><p>Haskell利用多态性的类型系统和系统推测，在维持着接近于duck typing灵活性的同时，也使编译时的完全类型检查成为可能。</p><h3 id="近代函数式语言之父OCaml"><a href="#近代函数式语言之父OCaml" class="headerlink" title="近代函数式语言之父OCaml"></a>近代函数式语言之父OCaml</h3><p>OCaml也是具有代表性的函数式编程语言之一。它比Haskell还古老，说它是近代函数式语言之父也毫不为过。</p><p>与Haskell相比，OCaml具有如下不同：</p><ol><li>没有副作用</li><li>没有延迟计算</li><li>具有强力的模块系统</li></ol><p>虽然不像Haskell那样自然地做到延迟计算，但换来的好处是，程序内容与实际处理关系接近，使人容易理解程序的执行过程。</p><h3 id="强于并行计算的Erlang"><a href="#强于并行计算的Erlang" class="headerlink" title="强于并行计算的Erlang"></a>强于并行计算的Erlang</h3><p>作为函数式编程语言，二郎的特点</p><ol><li>受Prolog影响</li><li>专用于并行计算</li></ol><h3 id="用Ruby进行函数式编程"><a href="#用Ruby进行函数式编程" class="headerlink" title="用Ruby进行函数式编程"></a>用Ruby进行函数式编程</h3><p>Ruby中有几个能进行函数式编程的工具</p><h4 id="Proc对象（lambda）"><a href="#Proc对象（lambda）" class="headerlink" title="Proc对象（lambda）"></a>Proc对象（lambda）</h4><p>Ruby中唯一与函数直接对应的是Proc对象。</p><h4 id="程序块"><a href="#程序块" class="headerlink" title="程序块"></a>程序块</h4><p>以程序块为参数的方法等价于函数型语言的高阶函数。灵活运用以程序块为参数的方法，就可以实现函数式编程的高阶函数的技巧。</p><h4 id="枚举器"><a href="#枚举器" class="headerlink" title="枚举器"></a>枚举器</h4><p>Ruby中没有延迟计算，但用枚举器对数组和列表进行循环，可以实现类似于延迟计算的处理。</p><h4 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h4><p>所谓避免副作用，就是对生成的对象，尽量少去改变其状态。</p><h3 id="用枚举器来实现延迟计算"><a href="#用枚举器来实现延迟计算" class="headerlink" title="用枚举器来实现延迟计算"></a>用枚举器来实现延迟计算</h3><p>从Ruby1.8.7开始，很多以块为参数的方法在参数不是块的时候，就会返回枚举器。</p><p>枚举器就是把循环用对象来表达的一种方法。</p><p>使用这样的枚举器可以实现与Haskell类似的延迟计算。</p><h2 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h2><h3 id="在商业中利用Ruby"><a href="#在商业中利用Ruby" class="headerlink" title="在商业中利用Ruby"></a>在商业中利用Ruby</h3><h3 id="使用Ruby自动生成代码"><a href="#使用Ruby自动生成代码" class="headerlink" title="使用Ruby自动生成代码"></a>使用Ruby自动生成代码</h3><p>编程中的代码重复是非常恶劣的。发现了代码重复，就应该考虑在合理的代价范围内避免代码重复的方法。</p><h3 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h3><p>为了在构建程序的时候，自动生成省略部分，我们只需要定义make的规则、在构建程序的过程中调用代码生成工具。</p><h3 id="代码生成的应用"><a href="#代码生成的应用" class="headerlink" title="代码生成的应用"></a>代码生成的应用</h3><h4 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h4><p>从数据结构定义自动生成数据库的访问例程（包括SQL）。</p><h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><p>大多数依赖于数据库的Web应用程序，常常需要对表的各项目进行增删改查操作。</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>代码生成对单元测试也很有效果。只要有数据和测试条件，就可以开始单元测试。</p><h4 id="客户界面"><a href="#客户界面" class="headerlink" title="客户界面"></a>客户界面</h4><h4 id="文档化"><a href="#文档化" class="headerlink" title="文档化"></a>文档化</h4><p>代码生成也适合与文档化。对于自动生成的类，由人工记入档案是纯粹的浪费。按照JavaDoc的形式，在生成代码的程序里写好相应的文档，应该是个聪明的办法。</p><h3 id="代码生成的效果"><a href="#代码生成的效果" class="headerlink" title="代码生成的效果"></a>代码生成的效果</h3><p>代码生成有如下好处：</p><ol><li>改进质量。</li><li>确保一致性</li><li>集中知识。</li><li>增加用于设计的时间。</li><li>独立于程序实现的设计判断</li></ol><h3 id="编写代码生成器"><a href="#编写代码生成器" class="headerlink" title="编写代码生成器"></a>编写代码生成器</h3><p>对代码生成最有帮助的工具要数eRuby。Ruby本身也拥有优越的文本处理功能。使用eRuby以比较自然地形式编写模板的同时，还可以灵活运用Ruby的处理能力。</p><h3 id="也可以使用XML"><a href="#也可以使用XML" class="headerlink" title="也可以使用XML"></a>也可以使用XML</h3><p>幸运的是，Ruby拥有解释XML的标准库REXML。REXML提供操作XML的功能。</p><h3 id="在EJB中使用代码生成"><a href="#在EJB中使用代码生成" class="headerlink" title="在EJB中使用代码生成"></a>在EJB中使用代码生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分</span><br></pre></td></tr></table></figure><h2 id="内存管理与垃圾收集"><a href="#内存管理与垃圾收集" class="headerlink" title="内存管理与垃圾收集"></a>内存管理与垃圾收集</h2><p>垃圾收集（GC）是一种管理程序使用的内存区域的方法。使用具有垃圾收集功能的编程语言或处理程序的话，程序中不需要编写内存管理的代码，即不用编写代码来释放使用过的内存区域。</p><h3 id="内存管理的困难"><a href="#内存管理的困难" class="headerlink" title="内存管理的困难"></a>内存管理的困难</h3><p>在垃圾收集普及之前，内存区域的取得和释放完全是程序员的责任。随着程序的执行，会使用一些内存区域作为作业区。为记忆对象、字符串和数组等个别信息，都需要使用内存区域。没有垃圾收集的语言一般都提供有API，利用这些API，可以再需要时向操作系统申请并取得内存，使用过之后再把内存区域返回给操作系统。</p><h4 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h4><p>如果把还在使用中的内存区域错误调用free予以释放的话，就会发生悬挂指针的现象。程序再去访问该区域时就可能会出错。在引用该区域内容时，多数场合会读取到被破坏的数据，或是在更新该领域数据的时候，会置换成预想之外的数据。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>另一方面，如果忘记了把申请的内存区域返还给操作系统的话，就会发生内存泄漏。这时候因为使用过的内存区域越来越多，程序占有的内存就会逐渐增加。特别是长时间启动，连续提供服务的常驻内存型程序，容易发生内存泄漏，导致系统停止等重大问题。</p><h4 id="二重释放"><a href="#二重释放" class="headerlink" title="二重释放"></a>二重释放</h4><p>对已经释放过的内存区域再次调用free的情况也时有发生。这称为二重释放。这会带来malloc和free内部使用的数据区域不一致的问题。</p><p>内存泄漏问题只有在内存占用量超过预想的时候才会显露，而悬挂指针问题不会发生在释放使用内存的时刻，而是要到访问释放过的内存区域才会出现。程序员往往会在看起来完全没有问题的地方突然遭遇意想不到的错误。</p><h3 id="垃圾收集亮相之前"><a href="#垃圾收集亮相之前" class="headerlink" title="垃圾收集亮相之前"></a>垃圾收集亮相之前</h3><p>应该管理的内存区域越来越多，内存释放时刻的管理也就越来越难，这是产生内存问题的原因。</p><p>关于垃圾收集，有以下这些先入为主的观念。</p><h4 id="垃圾收集慢"><a href="#垃圾收集慢" class="headerlink" title="垃圾收集慢"></a>垃圾收集慢</h4><p>有研究表明，在某些条件下，垃圾收集比手工管理内存还更快。</p><h4 id="垃圾收集可靠性低"><a href="#垃圾收集可靠性低" class="headerlink" title="垃圾收集可靠性低"></a>垃圾收集可靠性低</h4><p>在Java之后诞生的编程语言，不管是否受到Lisp的影响，几乎都毫无例外的拥有垃圾收集的功能。垃圾收集从诞生之日起，经历了40多年的发展，终于成为大家认可的一项特性了。</p><h3 id="评价垃圾收集的两个指标"><a href="#评价垃圾收集的两个指标" class="headerlink" title="评价垃圾收集的两个指标"></a>评价垃圾收集的两个指标</h3><p>假如存在无线内存的计算机的话，就没有必要进行垃圾收集。</p><p>垃圾收集的性能可以由两个指标来测定：</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量是垃圾收集处理在程序全部执行时间中所占的比例。比例越小越好，比例大的话，程序整体的性能就会低下。</p><h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>暂停时间是一次垃圾收集处理所中断的时间。暂停时间过长的话，处理的中断时间就会变得很显眼，程序反应就会变慢。</p><p>垃圾收集每次所花的时间会因垃圾收集执行时对象的总数而变化，暂停时间有两种，一是把垃圾收集时间求平均值得到平均暂停时间，二是程序执行中最长的垃圾收集时间所代表的最大暂停时间。</p><p>那些实时性要求高的程序，就很重视最大暂停时间。像批处理这样非对话的处理强调吞吐量要高，而重视反应速度的嵌入式或者GUI程序就强调暂停时间要短。</p><p>Java运行环境中实现由多种垃圾收集算法，可以根据程序的性质来切换合适的垃圾收集算法。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>基本上是以下4类，还有几种变形：</p><ol><li>引用计数方式</li><li>标记和扫除方式</li><li>标记和紧缩方式</li><li>复制方式</li></ol><h3 id="引用计数方式"><a href="#引用计数方式" class="headerlink" title="引用计数方式"></a>引用计数方式</h3><p>引用计数方式在垃圾收集算法中具有最简单最容易实现的特征。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.25.46.png" alt="屏幕快照 2018-07-25 下午5.25.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.25.46</div>            </figure><br>引用计数器最大的优点就是容易实现。这种方式得到广泛的使用。暂停时间短也是它的优点。</p><p>最大的缺点是不能释放有循环引用关系的对象群。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.28.21.png" alt="屏幕快照 2018-07-25 下午5.28.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.28.21</div>            </figure><br>与生俱来的缺点，因为在引用增减的时候有必要同时正确维护引用计数器的增减，忘了这一点就会带来悬挂指针或内存泄露问题。</p><p>最后一个缺点是，引用计数器的管理与并行处理不相容。如果多个进程同时增减一个引用计数器的话，就会发生引用计数器的值不一致的现象。为避免这一个问题，需要在操作引用计数器的时候进行排他处理，但在频繁发生引用操作的同时进行排他处理的话，会带来巨大的时间开销。</p><p>总之，这种原理简单实现也简单的引用计数器方式，缺点很多，最近已经不怎么用了。</p><p>采用引用计数器方式的主要语言处理系统有Perl和Python。为了回避循环引用的问题，它们都组合了其他垃圾收集方式。这些语言基本上以引用计数器方式来进行垃圾收集，只有在极个别的情况下，才通过别的垃圾收集算法来处理引用计数器不能回收的对象。</p><h3 id="标记和扫除方式"><a href="#标记和扫除方式" class="headerlink" title="标记和扫除方式"></a>标记和扫除方式</h3><p>标记和扫除方式也是古老的垃圾收集算法。<br>标记和扫除方式从有可能成为对象引用元的变数（根）开始，给被引用的对象加上标记，表明其“活着”。然后再给标记对象所引用的对象还有其再引用的对象，也都递归地加上引用标记。</p><p>这样从根开始不管是直接还是间接，只要把所有引用的对象都加上标记的话，那么没有标记的对象就是没有被引用的，也就是“已经死了”。然后在所有的对象中找出没有标记的对象，把它们作为垃圾扫除出去。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.50.20.png" alt="屏幕快照 2018-07-25 下午5.50.20" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.50.20</div>            </figure><br>此法虽然古老，但是非常优秀，现在也还被多种处理系统所采用。</p><p>但是当对象数目较多时，性能容易恶化。在标记的时候要访问生存的所有对象，在回收时按顺序访问所有的对象，找出”已经死了“的对象。在寻找垃圾和扫除过程中，基本不能进行其他处理，垃圾收集时间长的话，会影响到本来的处理工作。</p><h3 id="标记和紧缩方式"><a href="#标记和紧缩方式" class="headerlink" title="标记和紧缩方式"></a>标记和紧缩方式</h3><p>标记和紧缩方式是标记和扫除的变形。标记处理是一样的，后阶段有所不同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.01.29.png" alt="屏幕快照 2018-07-26 下午12.01.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.01.29</div>            </figure><br>标记和紧缩方式最大的特征也是他的优越之处，是把空间集中起来（紧缩）。紧缩的结果是把没有释放而活下来的对象都集中到一个地方。这样，内存访问就集中到一个局部区域，这可以提高缓存功能的效率。对象的分配也只是把指针移动一下就完成了，降低了对象分配的开销。</p><p>缺点是，把生存着的对象全部复制的紧缩开销，容易比标记和扫除方式中执行的开销还要大。因为对象被移动位置了。</p><p>一部分Lisp处理系统采用的是标记和紧缩方式，Java处理系统（作为多个垃圾收集算法中的一个）也有标记和紧缩方式。</p><h3 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h3><p>像标记和扫除方式、标记和紧缩方式这样“标记之后释放死了的对象”的算法，标记时间与活着的对象数成比例，扫除时间与总对象数成比例。所以在分配有很多的对象，其中几乎所有对象都要被释放的场合，扫除的开销会变高，在性能方面很不利。</p><p>复制方式与标记和扫除方式一样，从根开始扫描所有的对象，但他不仅仅是加标记，还执行复制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.11.58.png" alt="屏幕快照 2018-07-26 下午12.11.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.11.58</div>            </figure><br>复制方式把内存空间分成旧空间和新空间两大块，总是在旧空间中分配对象。旧空间爆满时，从根开始扫描对象，把对象复制到新空间。这时，复制后的引用也要随之更新。</p><p>递归的执行从旧空间到新空间的复制，结束时就会把所有活着的对象都移动到新空间。不再被引用的对象都遗留到旧空间，旧空间就可以整个弃之不用，就避免了扫除的开销，从此再把新空间作为旧空间再进行同样的处理。</p><p>最大的优点是，垃圾回收的开销只和活着的对象数成比例。对象分配的开销也低。还有“局部性”的优点。复制方式按顺序把引用的对象复制到新空间，关系近的对象会被分配到相近的内存空间，称为局部性。关系近的对象被访问的可能性也高。计算机因为有缓存，内存空间相接近的访问可能具有较好的性能，局部性高的程序具有提高性能的优势。</p><p>缺点：复制方式要复制所有活着的对象，几乎具有和标记和紧缩方式一样的缺点。</p><h3 id="多种多样的垃圾收集算法"><a href="#多种多样的垃圾收集算法" class="headerlink" title="多种多样的垃圾收集算法"></a>多种多样的垃圾收集算法</h3><p>把基本算法组合起来的技术，几个具有代表性的：</p><ol><li>分代垃圾收集</li><li>保守垃圾收集</li><li>增量垃圾收集</li><li>并行垃圾收集</li><li>位图标志</li></ol><p>这些技术的组合也是有可能的。</p><h3 id="分代垃圾收集"><a href="#分代垃圾收集" class="headerlink" title="分代垃圾收集"></a>分代垃圾收集</h3><p>分代垃圾收集的基本思想是利用程序和对象的性质。一般程序都有这样一个性质，几乎所有的对象都在比较短的时间里变成垃圾，存活时间超过一定程度的对象总是拥有更长的寿命。</p><p>因为这一性质，就可以重点对分配之后的年轻对象进行扫描，这样就不用扫描全部对象就可能高效率地回收垃圾。</p><p>分代垃圾收集把对象的内存空间分成两个，新代和旧代，也有分成3个的。</p><p>只扫描新代区域的回收称为轻垃圾收集，但没有检查旧代区域对新代的引用，被引用的对象可能误判死亡，就会带来内存问题。</p><p>解决这一问题的方法是，监视对象的更新。在旧代区域引用新代区域的同时，就把这一引用的记录例程以及对象的更新场所全都记录下来，这个检查例程叫做<strong>写屏障</strong>，记录旧代区域对新代区域的引用叫<strong>记录集</strong>。</p><p>以所有区域对象的垃圾收集称为全垃圾收集或重垃圾收集。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.33.58.png" alt="屏幕快照 2018-07-26 下午12.33.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.33.58</div>            </figure><br>分代垃圾收集减少了扫描对象的个数，有缩短平均暂停时间的效果。但是，因为要执行全垃圾收集，最大暂停时间不会得到明显的改善。</p><p>最近几乎所有的Java都实现有分代垃圾收集。另外，函数型语言OCaml也采用了分代垃圾收集。</p><h3 id="保守垃圾收集"><a href="#保守垃圾收集" class="headerlink" title="保守垃圾收集"></a>保守垃圾收集</h3><p>像C这种本来没有垃圾收集的语言，编译之后没有保留区别整数和指针的信息，因为CPU对两者不加区分，所以也就没这个必要。通常，垃圾收集的实现需要明确区分引用（指针），而C和C++没有这样的功能，在这样的环境下实现垃圾收集的技巧之一称为保守垃圾收集。</p><p>其基本思想就是如果碰巧有整数的值与引用相同的话，该对象就有可能被引用，就当它是活着的。保守就是倾向于安全的意思。与此相对，能够明确区别所用的环境下的垃圾收集称为精确垃圾收集。</p><p>因为倾向于安全一面，保守垃圾收集在C或者C++这样没有垃圾收集功能的语言中也可以得到实现，这是它的优点。但是，本来应该回收的对象却在意料之外保留下来不能回收，这是它的缺点。以及，它不能喝复制垃圾收集这样需要移动的垃圾收集算法组合使用。</p><p><strong>Ruby采用的是保守垃圾收集。</strong>局部变量可以按照通常语言的访问路径来处理，系统堆栈部分是当做指针数组来扫描的。Ruby大部分是用C编写的，因为有了保守垃圾收集，C库的实现变得非常简单。实际上，Python和Perl因为采用的是引用计数器，C例程内部的引用数管理非常复杂，偶然忘记增减就会发生内存问题。但是，用C编写Ruby扩展库时，基本上不用操心内存管理，好处十分明显。</p><p>Boehm GC为C和C++增加了垃圾收集功能。Boehm GC也同时实现了分代垃圾收集。Boehm GC不仅用于C和C++，在Scheme处理系统Gauche等多种语言处理系统中，也作为垃圾收集功能得到广泛的应用。</p><h3 id="增量垃圾收集"><a href="#增量垃圾收集" class="headerlink" title="增量垃圾收集"></a>增量垃圾收集</h3><p>在实时性要求高的程序中，垃圾收集带来的中断时间必须是可预测的。为保证实时性，不需要等垃圾收集完全执行结束，而是要把垃圾收集细分正许多细小的片段，每次执行一点，这叫增量垃圾收集。</p><p>增量垃圾收集在垃圾收集处理过程中程序也在同时执行，引用有可能会改变。结果是垃圾收集的一致性不能得到保证。增量垃圾收集为避免这样的问题，采用了与保守垃圾收集相同的写屏蔽操作。</p><p>嵌入式处理系统采用的是增量垃圾收集。有名的Io和Lua都实现了增量垃圾收集。</p><h3 id="并行垃圾收集"><a href="#并行垃圾收集" class="headerlink" title="并行垃圾收集"></a>并行垃圾收集</h3><p>在多核环境下，灵活运用线程可以最大限度地发挥多个CPU的能力。并行垃圾收集就是要最大限度利用多个CPU的能力。</p><p>并行垃圾收集基本原理与增量垃圾收集大致是一样的，都是利用写屏蔽来维护当前状态的信息。有的并行垃圾收集的实现生成垃圾收集专用线程，把垃圾收集设计成总是与普通处理并行执行。</p><h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><p>以Linux为首的UNIX系列操作系统在使用fork系统调用复制过程时，内存空间并不进行复制而是直接共享。通过写时复制来提高性能。</p><p>垃圾收集与这一功能兼容性不好，给引用对象那个设置标记的方式会因设置标记而复制包含该对象的内存页。复制方式也同样会产生大量写内存操作。</p><p>位图标记是在利用标记的垃圾收集中消减操作系统内存页复制的方法。它不在对象里设置被引用的标记，而是利用外部位图区域（管理用内存区域）来保存引用标记。</p><p>只有标记用的位图部分会发生内存页复制，从而避免了复制没有实际更新的对象所在的内存页。</p><p>Ruby的垃圾收集也有了实现位图标记的补丁。</p><h2 id="用C语言来扩展Ruby"><a href="#用C语言来扩展Ruby" class="headerlink" title="用C语言来扩展Ruby"></a>用C语言来扩展Ruby</h2><p><strong>Ruby是解释型语言，即Ruby程序是由Ruby解释器的程序来解释执行的。</strong></p><p>提起解释器，大家会觉得它是逐行读取程序并执行，实际上Ruby解释器是把要执行的程序全部读进来，首先变换成更有效率的内部表现形式。解释器对其内部表现加以分析来执行程序。</p><p>解释型语言的特点，马上可以执行，开发周期非常快。至于C、C++、Java这样的编译语言，首先要把程序变换成计算机可以直接执行的形式再从头执行。</p><p>在执行程序过程中，编译型语言不再需要对原来程序进行解释和变换，速度很快。但是开发周期较长。</p><h3 id="开发与执行速度的取舍"><a href="#开发与执行速度的取舍" class="headerlink" title="开发与执行速度的取舍"></a>开发与执行速度的取舍</h3><p>这两种类型的语言要做取舍。Ruby的设计方针是开发效率优于执行效率，选择解释型的实现也是必然。</p><p>Ruby解释器是由C语言开发的，采用C语言开发理由：</p><ol><li>C语言作者拿手</li><li>C语言运行系统调用，速度高</li><li>用面向对象语言来实现别的面向对象语言的话，容易混淆对象的概念。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%885.36.05.png" alt="屏幕快照 2018-07-26 下午5.36.05" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午5.36.05</div>            </figure><p><strong>引擎</strong>是解释内部表现，并实际上执行程序的部分。1.9版本的引擎解释的字节码，可以说是近似于虚拟计算机的机器语言。所以1.9版本的引擎也可以成为VM。</p><p><strong>引擎</strong>在解释内部表现是，需要其他组件的帮助。内存和对象的管理，变量访问和方法调用的实现等，都要依靠底层称为<strong>运行库</strong>的组件来完成。<strong>运行库</strong>提供底层强有力的支持，是程序执行时不可或缺的部分。</p><p>Ruby利用的各种类是<strong>类库</strong>提供的。Ruby的这一部分也是用C编写的。像Ruby这样的解释型语言，因为是经过C编写的引擎来间接执行程序，与一般的编译语言相比，执行速度明显慢得多（100 倍或者 1000 倍）。但是，实际上程序的执行时间大部分都花在 C 編写的类库方法内部，因此在执行速度上很少会产生那么巨大的差距。</p><h3 id="扩展库"><a href="#扩展库" class="headerlink" title="扩展库"></a>扩展库</h3><p>扩展库是指利用Ruby运行库的API,用C定义的类库。Ruby的API使用C几乎可以实现Ruby所有的功能。使用这些API可以很简单地实现如下的功能：</p><ol><li>定义类</li><li>定义方法</li><li>访问实例变量</li><li>调用方法</li><li>调用块</li></ol><p>特意花时间用C来实现扩展库的理由主要有以下两点。</p><ol><li>想要比Ruby执行速度快</li><li>想使用C可以利用的库。</li></ol><p>前面已经说过,Ruby是解释型语言,它的执行速度不如像C这样的编译型语言。如果是绝对需要改善速度的程序,用C扩展库来实现其中成为瓶颈的部分的话,有可能显著改善程序的<br>执行速度。</p><p>UNX系列操作系统的大多数功能都是通过C可以访问的库来提供的。Ruby要想利用这些功能的话,就需要有一种从Ruby调用C的API的方法,这最简单的方法就是利用扩展库。</p><h3 id="扩展库的编译"><a href="#扩展库的编译" class="headerlink" title="扩展库的编译"></a>扩展库的编译</h3><p>首先按照以上的顺序编写源代码。若C程序的文件名后<br>约定为c的话,后续步骤会自动识别出来C程序文件。</p><p>为生成编译所需要的文件,需要准备必要的<br>Ruby文件。这个文件通常命名为 extconf.rb<br>minitab的 extconf.rb的内容如图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%887.09.31.png" alt="屏幕快照 2018-07-26 下午7.09.31" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午7.09.31</div>            </figure></p><p>extons,xb是由以下几个部分构成的:</p><ol><li>调用 require’mkmf’;   </li><li>用have_1 ibrary和 hava header检<br>查必要的库和头文件是否存在；  </li><li>用 create makefile来生成必要的<br>Makefile. create makefile的参数<br>是库的名字。</li></ol><p>照图14-34执行 extconfrb,就可以生成<br>Makefi1e。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%887.13.48.png" alt="屏幕快照 2018-07-26 下午7.13.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午7.13.48</div>            </figure></p><p>用make命令来编译,尔后可以用 make insta11命令来安装编译后的库。</p><h3 id="扩展库之外的工具"><a href="#扩展库之外的工具" class="headerlink" title="扩展库之外的工具"></a>扩展库之外的工具</h3><h4 id="RubyInline"><a href="#RubyInline" class="headerlink" title="RubyInline"></a>RubyInline</h4><p>Rubylnline可以在Ruby的源代码中直接嵌入C的程序。不用每次准备 exton,rb文件,也不需要明确的编译步骤,非常便利,但它也有不少约束,比如在执行环境中需要有编译器,与外部库的链接也有些麻烦等。</p><h4 id="dl"><a href="#dl" class="headerlink" title="dl"></a>dl</h4><p>有了d1,仅用Ruby也能实现与 minitab同样动作的库。把图1435的程序保存成 inial,rb文件,没有扩展库也可以使用 minitab。al的优点是在没有安装编译器和头文件的环境下也可以运行。</p><h4 id="ffi"><a href="#ffi" class="headerlink" title="ffi"></a>ffi</h4><p>关于Ruby的扩展,ffi库受到关注。ffi是 foreign function interface的缩写,它也提供在Ruby水平上的与外部函数的直接接口,这个目的与d1几乎是一样的。ffi可以从 Ruby Gems得到。ffi的特征是使用lb更有效率地调用外部函数,Ruby、 Rubinius和 GRubby都可以使用<br>同样的API。</p><h2 id="为什么要开源"><a href="#为什么要开源" class="headerlink" title="为什么要开源"></a>为什么要开源</h2><h3 id="自由软件的思想"><a href="#自由软件的思想" class="headerlink" title="自由软件的思想"></a>自由软件的思想</h3><p>为保证执行的自由,必须能够将软件免费拿到手。出于学习和研究的目的,也必须能够自由地得到源代码。还有,为了修改程序错误,或者为适合自己的目的而进行改造,那就不单单<br>是阅读源代码,还要允许改变源代码。把自己认为好的软件推荐给别人,或者把自己进行的修改或改善与他人共享的话,就需要有再发布的自由。</p><h3 id="自由软件的历史"><a href="#自由软件的历史" class="headerlink" title="自由软件的历史"></a>自由软件的历史</h3><p>曾几何时,在计算机的黎明期,软件完全是硬件的附属物。买了计算机,附带操作系统等源代码,根本就不是什么稀罕的事。那时,或者在更早一些的时候,甚至有这样的情况,从生<br>产厂家买来的计算机连操作系统也没有,需要用户自己来开发各种软件。买了同样计算机的用户互相交换自己开发的软件,互助合作。虽然不够精致,但与如今开源软件的情况很有些相似之处。</p><h3 id="Emacs事件的发生"><a href="#Emacs事件的发生" class="headerlink" title="Emacs事件的发生"></a>Emacs事件的发生</h3><p>但是,戈斯林把 Gosmacs的专利卖给了 Unipress公司,斯托曼就不能够在 Gosmacs的基础上开发新的 Emacs了。结果,斯托曼从零开始开发了自己的UNIX版的Emacs。</p><p>他们的最终目标是，创造一个从上到下完全自由的操作系统环境。</p><h3 id="开源的诞生"><a href="#开源的诞生" class="headerlink" title="开源的诞生"></a>开源的诞生</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%888.52.32.png" alt="屏幕快照 2018-07-26 下午8.52.32" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午8.52.32</div>            </figure><h3 id="OSS许可证"><a href="#OSS许可证" class="headerlink" title="OSS许可证"></a>OSS许可证</h3><h4 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h4><p>GPL( GNU General Public license)应该可以说是自由软件许可证的鼻祖,它具有如下特征:</p><ol><li>没有保证;</li><li>表示版权;</li><li>保持同样的许可证</li></ol><p>GPL特征中最重要的是保持同样的许可证,也就是说,在对GPL许可证的软件进行修改或复制的情况下,必须保持其原来的GPL许可证。<br>这意味着再利用GPL软件的源代码而开发的软件的许可证也必须是GPL。批判GPL的人把这称为感染性。赞同GPL的人们称之为版权保留,因为这一性质意味着版权的保留。</p><h4 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h4><h4 id="BSD许可证"><a href="#BSD许可证" class="headerlink" title="BSD许可证"></a>BSD许可证</h4><h4 id="APL和CPL"><a href="#APL和CPL" class="headerlink" title="APL和CPL"></a>APL和CPL</h4><h3 id="开源的背景"><a href="#开源的背景" class="headerlink" title="开源的背景"></a>开源的背景</h3><p>在科学领域,共享知识和信息本来是非常普通的事情。即使不用看站在巨人的肩膀上的牛顿的例子,把知识作为论文(免费)公开,利用前人的成绩进行新的研究是再理所当然不过的。</p><p>软件,特别是商业软件,一旦作为商品来经营的话,就容易忘记这样一点,与论文的内容一样,软件也不过是信息的一种,也应该适用同样的原则。科学家致力于研究,大学或研究机构对科学家给予支持,这种体制对软件也有可能成立。实际上,大学或研究机构支援软件开发的例子相当多。</p><p>但是,谈到近年来开源的普及和发展,计算机的普及和因特网的发展则功不可没。过去如果要想开发髙质量软件的话,需要购买价格髙昂的计算机,召集大量的技术人员。现在一般家庭里的计算机都完全能够开发软件,通过网络进行合作开发的事情也屡见不鲜。个人出于兴趣而编程也已经能够达到相当高的水平了。</p><p>软件的复杂化和商品化也是开源的背景之一,不容忽视。软件所覆盖的领域越来越广,软件也越来越复杂。过去1万行左右的程序就实现了的操作系统,如今变成了超过600万行的巨大软件。</p><h3 id="企业关注开源的理由"><a href="#企业关注开源的理由" class="headerlink" title="企业关注开源的理由"></a>企业关注开源的理由</h3><p>从1998年以来,开始出现了盈利企业为自己的利益而开发开<br>源软件的事例。一旦认识到无法自己来开发所有软件之后,企业只自己开发最具竞争力的小部分核心软件,而让大家共同来开发其他软件,结果对大家都有好处,企业关注开源正是这种冷静的分析考量的结果。</p><p>参与开源的人们也各有各的想法。有因经营考虑而参加的企业,有为软件自由而参加的程序员,有因上级命令而参加的公司职员,各种各样,千差万别。但是,开源有可能为个人和全人类带来幸福,如果能继续下去形成良性循环的话,那真是再好不过了。</p><h3 id="Ruby与开源"><a href="#Ruby与开源" class="headerlink" title="Ruby与开源"></a>Ruby与开源</h3><p>Ruby从一开始就是开源软件。Ruby在1995年初次公开的时候,开源这个单词还没有诞生,也许应该称为自由软件。</p><h3 id="选择许可证的方法"><a href="#选择许可证的方法" class="headerlink" title="选择许可证的方法"></a>选择许可证的方法</h3><p>许可证与技术无关,而是有关法律和合同的工作,这不是技术人员的工作,而是属于律师的工作范围。对于软件开发人员来说,这决不是一件令人感兴趣的工作,有人甚至会想:“哪用得着这些东西呢?”</p><p>如果使用你的许可证的软件的所有代码都完全是由你自己写出来的话,这几乎不成为什么问题。只要发布新的许可证版本,问题就解决了但是,如果其中包含了其他人写的补丁的话,软件就不再是你一个人的了,在法律上写补丁的人是共同拥有版权的。</p><p>FSF作为软件自由的拥护者,强烈推行版权保留。另一方面,不怎么在乎版权保留的开发人员好像更多一些。如果你希望版权保留的话,几乎就只能选择GPL。</p><p>如果你的软件是作为库来使用的话,那么LGPL则是个不错的选择。如果对库适用GPL许可证的话,那事实上就只能为GPL软件所用,采用限制较为宽松的LGPL的话,有可能使你的软件得到更为广泛的使用。但是,LGPL有不方便、难于理解以及没有得到充分考察等缺点,在不太强烈希望版权保留的时候,最好不要选择它。</p><p>对于不太在乎版权保留的人来说,可以选择GPL以外的许可证。这里的要点是,该软件是否需要与其他软件进行链接。如果预想到将来可能以某种方式与GPL许可证的软件链接在一起的话,那么与GPL的互换性就变得很重要。拥有插件功能的软件或库特别要注意这一点。作为与GPL不相矛盾的许可证,有修正BSD许可证和MIT许可证等。</p><p>另一个应该考虑的要点是,与相关软件和许可证是否一致。比如 Eclipse插件就应该选择Eclipse许可证(即使不与GPL互换)。另外,PHP关联软件选择与PHP一致的许可证也是安全的。用Ruby编写的软件与Ruby本身的许可证本来是相互独立的,但好像也大都选择Rby许可证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-14-函数式编程&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-14-函数式编程&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 14 函数式编程&quot;&gt;&lt;/a&gt;松本行弘的程序世界 14 函数式编程&lt;/h1&gt;&lt;h2 id=&quot;新
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 13 关于数据的持久化</title>
    <link href="https://github.com/zdkswd/2018/07/24/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2013%20%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2018/07/24/松本行弘的程序世界 13 关于数据的持久化/</id>
    <published>2018-07-24T02:00:32.000Z</published>
    <updated>2018-08-10T16:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-13-关于数据的持久化"><a href="#松本行弘的程序世界-13-关于数据的持久化" class="headerlink" title="松本行弘的程序世界 13 关于数据的持久化"></a>松本行弘的程序世界 13 关于数据的持久化</h1><h2 id="持久化数据的方法"><a href="#持久化数据的方法" class="headerlink" title="持久化数据的方法"></a>持久化数据的方法</h2><h3 id="保存文本"><a href="#保存文本" class="headerlink" title="保存文本"></a>保存文本</h3><h3 id="变换成文本的Marshal"><a href="#变换成文本的Marshal" class="headerlink" title="变换成文本的Marshal"></a>变换成文本的Marshal</h3><p>将对象按一定的方式变换成文本，就可以保存到文件中去。这样的对象文本化就称为serialize(序列化)，或是marshal(封送处理)。</p><h3 id="使用Marshal模块"><a href="#使用Marshal模块" class="headerlink" title="使用Marshal模块"></a>使用Marshal模块</h3><p>标准Ruby中，嵌入了marshal功能，这就是Marshal模块。<br>Marshal模块中提供了几乎能将全部Ruby对象变为字节串的方法dump，以及将字节串恢复成原对象（的复制）的load方法。<br>对象可以简单地保存到文件里。</p><h3 id="复制有两种方式"><a href="#复制有两种方式" class="headerlink" title="复制有两种方式"></a>复制有两种方式</h3><p>使用Marshal可以完成对象的深复制。<br>复制对象的时候，通常使用clone方法。这种情况下，只复制直接对象，引用的对象不复制。称为浅复制。<br>深复制连同引用对象也一起进行递归复制。</p><h3 id="仔细看Marshal的格式"><a href="#仔细看Marshal的格式" class="headerlink" title="仔细看Marshal的格式"></a>仔细看Marshal的格式</h3><p>Marshal用二进制形式将对象文本化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15323139335047/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.07.00.png" alt="屏幕快照 2018-07-23 上午11.07.00" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-23 上午11.07.00</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15323139335047/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.09.40.png" alt="屏幕快照 2018-07-23 上午11.09.40" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-23 上午11.09.40</div>            </figure></p><h3 id="不能保存的3类对象"><a href="#不能保存的3类对象" class="headerlink" title="不能保存的3类对象"></a>不能保存的3类对象</h3><p>Marshal在实现上有限制。以下3类对象不能保存：</p><ol><li>定义了特异方法的对象。</li><li>输入、输出或是套接字等不能超越进程保存的对象。</li><li>在扩充库中定义，Ruby不知道保存方法的对象。 </li></ol><p>但是即使不能封送处理，若不是像输入输出那种从原理上不可能的情况，单纯是不知道封送处理方法的话，重新教一遍也就行了。</p><h3 id="制作面向对象数据库"><a href="#制作面向对象数据库" class="headerlink" title="制作面向对象数据库"></a>制作面向对象数据库</h3><p>使用Marshal保存对象，使对象具有了持久性。所以，Marshal也可应用于面向对象数据库。<br>PStore库是Marshal的一个用例。Marshal虽然只是将数据变换成字符串，PStore却利用了这一点，简单地实现了面向对象数据库。<br>PStore有三个特征：使用Marshal，可以原封不动地保存任意的Ruby对象；具有容易使用的接口；有事务处理（transaction）。<br>PStore也有缺点，它不适合一下子将数据全部读入内存的大规模数据库。但几百字节的小规模数据库，应该没问题。</p><h3 id="试用PStore"><a href="#试用PStore" class="headerlink" title="试用PStore"></a>试用PStore</h3><h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><h4 id="开始事务处理"><a href="#开始事务处理" class="headerlink" title="开始事务处理"></a>开始事务处理</h4><h4 id="对象的登录和取得"><a href="#对象的登录和取得" class="headerlink" title="对象的登录和取得"></a>对象的登录和取得</h4><h4 id="事务处理的终止"><a href="#事务处理的终止" class="headerlink" title="事务处理的终止"></a>事务处理的终止</h4><p>简单说明一下事务处理的步骤：</p><ol><li>用flock将数据文件加锁。</li><li>用Marshal从数据文件中读取数据</li><li>执行（事务处理）块</li><li>块的执行成功，Marshal将数据写入数据文件</li><li>块的执行失败，什么也不做。</li></ol><h3 id="变换为文本的YAML"><a href="#变换为文本的YAML" class="headerlink" title="变换为文本的YAML"></a>变换为文本的YAML</h3><p>Marshal的变换结果是二进制文件，内容不容易看懂。有些场合及时效率低一些，也需要能够以更容易看懂的形式输出。能够满足要求的是YAML。使用文本形式，不依赖平台的体系结构，是一种对人而言易读易编辑的序列化格式。</p><p>有以下几个特征：记述简洁；结果容易读懂；使用缩进的层次表现；数据表现是专用的，不必烦恼标签的名称问题。</p><p>YMAL可以活用在Ruby on Rails的配置文件等各种各样的领域。YMAL是在Perl中开发的，但正式的支持，Ruby是第一个。</p><h3 id="用YAML制作数据库"><a href="#用YAML制作数据库" class="headerlink" title="用YAML制作数据库"></a>用YAML制作数据库</h3><p>类似于PStore的东西，YAML：：Store，其与PStore的互换性非常高，只要把名字换一换，面向PStore的程序在YAML：：Store也能运行。</p><p>他俩的区别：</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>很显然，一个YAML，一个Marshal。</p><h4 id="数据量"><a href="#数据量" class="headerlink" title="数据量"></a>数据量</h4><p>Marshal比YAML紧凑的多，Marshal牺牲了易读性而实现了良好性能。</p><h4 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h4><p>性能优良不光是容量的问题。使用Marshal的PStore比YAML：：Store速度高，在这一点上，也是数据量越大，两者的差异就越显著。</p><h2 id="对象的保存"><a href="#对象的保存" class="headerlink" title="对象的保存"></a>对象的保存</h2><p>对象持久化库Madeleine，利用直接持久化对象的设计模式Object Prevalence。</p><p>Madeleine是Object Prevalence在Ruby中的实现，应称为PStore的发展形式。</p><p>PStore只是对象单纯由Marshal输出而来，Madeleine则与应用程序相协调，实现了高可靠性和高性能的持久化。</p><h3 id="高速的Object-Prevalence"><a href="#高速的Object-Prevalence" class="headerlink" title="高速的Object Prevalence"></a>高速的Object Prevalence</h3><p>所谓Prevalence，是一种实现应用程序持久化和进程间共享数据的设计模式。高性能的秘密在于直接访问内存中的数据。Object Prevalence将处理的数据保存在正在执行的应用程序的内存中，检索等操作不通过SQL而是直接进行，节省了与数据库副武器的通信成本，引用当然就会很高速。</p><p>但是，只有是同一进程，才能引用内存中的数据，进程一结束，数据马上消失。从持久化角度有必要解决这一问题。</p><p>Object Prevalence用日志记录（journaling）和快照（snapshot）来解决这一问题。Object Prevalence中，数据更新时不是直接更新对象，而是创建称为command的对象，采用的是一种非常间接的方法，在用command更新对象时，内存中的对象更新的同时，所有的更新内容也会写到称为日志（journal log）的外部文件中。</p><p>长此下去日志越来越大，所以要将现在数据状态写到称为快照的文件中。有了快照，老日志就不需要了，可在适当的时机删除。</p><p>有了最新的快照和最新的日志，可以完全恢复现在对象的状态。程序启动，按三步骤恢复内存的数据。及时有多个进程，只要写入日志的信息是完整的，就可以共享对象的状态。</p><ol><li>如果不存在快照，就初始化应用程序数据。</li><li>如果存在快照，就读入其中最新的一个。</li><li>如果还存在日志，也将其读入，并用其中最新的一个更新应用程序数据。</li></ol><h3 id="Object-Prevalence的问题点"><a href="#Object-Prevalence的问题点" class="headerlink" title="Object Prevalence的问题点"></a>Object Prevalence的问题点</h3><p><strong>Object Prevalence通过使用日志记录和快照实现了对象的持久化和进程间共享。</strong>Object Prevalence将所有数据都保存到内存中，随着数据量的增大，内存的消耗也在增大。</p><p>关系数据库中，不引用的数据放在文件中，必要的内存量就不用那么多了。</p><p>Object Prevalence有为了数据更新而具有的特殊结构，更新持久化数据时需要经由command对象。</p><h3 id="使用Madeleine"><a href="#使用Madeleine" class="headerlink" title="使用Madeleine"></a>使用Madeleine</h3><h3 id="访问时刻信息"><a href="#访问时刻信息" class="headerlink" title="访问时刻信息"></a>访问时刻信息</h3><h3 id="让Madeleine更容易使用"><a href="#让Madeleine更容易使用" class="headerlink" title="让Madeleine更容易使用"></a>让Madeleine更容易使用</h3><p>Madeleine既保持简洁性，又能让对象持久化，但是最大的缺点是在每次更新应用程序时必须生成command对象。</p><h3 id="Madeleine的实用例Instiki"><a href="#Madeleine的实用例Instiki" class="headerlink" title="Madeleine的实用例Instiki"></a>Madeleine的实用例Instiki</h3><p>Madeleine没有得到广泛应用，除了知道的人少，还因为数据全保存在内存中，就必须十分留意数据的大小。</p><p>Madeleine有一个很大的缺点，就是没有考虑多个进程同时更新数据的情况。</p><h2 id="关于XML的考察"><a href="#关于XML的考察" class="headerlink" title="关于XML的考察"></a>关于XML的考察</h2><h3 id="XML的祖先是SGML"><a href="#XML的祖先是SGML" class="headerlink" title="XML的祖先是SGML"></a>XML的祖先是SGML</h3><p>SGML是将文档电子化的一种格式。由三部分组成：表示数据本身的Instance，表示数据结构的DTD，以及SGML声明。</p><p>由于SGML太复杂，处理成本太高，为了表现网页，将SGML特化为HTML，随之诞生的是XML。</p><p>XML不像HTML那样是为了特定目的的标记语言，它一开始就是为了通用目的而设计的。为了让XML在没有DTD来定义语法或提供schema信息的情况下，也能够解析，人们对其语法进行了简化。</p><h3 id="XML是树结构的数据表现"><a href="#XML是树结构的数据表现" class="headerlink" title="XML是树结构的数据表现"></a>XML是树结构的数据表现</h3><p>XML基本上是纯文本，以类似于HTML的标签嵌套方式实现树结构。XML是继承了SGML的通用标记语言，其与SGML最大的区别是其基本语法固定，不依赖于DTD那样的外部信息也能解析。</p><p>即使没有标签的概要信息也能解析的语法称为良构的（well-formed）,这是XML的一大特征。</p><h3 id="优点在于纯文本"><a href="#优点在于纯文本" class="headerlink" title="优点在于纯文本"></a>优点在于纯文本</h3><p>最大的优点在于XML基本上是纯文本的，表示结构的信息附加在标签里。</p><p>第二个优点是不易发生字符编码的问题。XML规定，在没有明确指定的情况下，字符编码均使用Unicode。</p><p>第三个优点是得益于良构的性质，在没有数据结构的情况下也能解析XML数据。这样就可以不考虑目的，而用共同的工具来处理XML数据。</p><p>第四个优点在于，XML与其解析工具不依赖于特定的语言，比如Java生成的XML数据在Ruby中的解析也很简单。解析XML的API，像DOM和SAX都超越语言提供了几乎共通的性质，所以不同语言也可以进行同样的操作。</p><p>最后一个有点是，人们也很容易理解。</p><p>总之，XML作为各种数据交换格式的框架，具有优良的性质。作为格式的格式，也就是元格式，是很优秀的。</p><h3 id="缺点在于冗长"><a href="#缺点在于冗长" class="headerlink" title="缺点在于冗长"></a>缺点在于冗长</h3><p>最大的缺点是效率低下。XML是以纯文本出现的，标签信息反复出现，显得冗长。与表示相同信息的二进制数据相比，XML数据的容量要大得多，与其他文本表现方式相比（YAML，JSON）也显得冗长。</p><p>效率低下不光体现在数据大小上，解析XML的效率也不怎么高。与二进制文件相比，XML文件的解析因为含有大量字符串处理，而容易变得很慢。</p><p>作为文本的标记语言而诞生的XML，用其表现有一定结构的数据到底好不好还是个疑问。如果只是用于表现构造数据，比XML更有效率的格式还有很多。而且XML原则上只能表现树结构的数据。</p><p>总结，XML作为出于通用目的的数据格式，效率很低，所谓很多优点，如果场合不对，也没多大意义。适才适用，XML也要分情况适当使用。</p><h3 id="不适合重视效率的处理"><a href="#不适合重视效率的处理" class="headerlink" title="不适合重视效率的处理"></a>不适合重视效率的处理</h3><p>对于重视通信量和速度的情况都不适合，此时应使用专用的协议或是效率更高的格式。</p><p>像配置文件那样靠人直接编辑的数据也不推荐XML。配置文件中，需要用到XML的树结构数据地方很少，随着要素数增加，就会很难读，用YMAL和JSON才更合适。</p><p>XML适合的场合：</p><ol><li>人一般不直接接触</li><li>复杂性不成问题</li><li>效率不成为问题</li><li>跨平台</li></ol><h3 id="适合于信息交换的格式"><a href="#适合于信息交换的格式" class="headerlink" title="适合于信息交换的格式"></a>适合于信息交换的格式</h3><p>利用XML的元格式性质，以XML为基础的格式的例子。</p><ol><li>RSS。Web网站更新信息。</li><li>Atom。RSS的代替。</li><li>ebXML。电子商务数据交换。</li><li>SVG。向量-图像表示。</li><li>SMIL。 多媒体及内容控制。</li></ol><p>以上这些都具有XML的性质，可以用XML处理工具简单地解析。制作数据格式时，最麻烦的就是制作处理这种格式的软件。所以，XML与XML处理库的存在是很可贵的。</p><p>另外，XML数据库中，问题不在于数据是不是实际以纯文本XML来表现，而在于XML能够表现的树结构能够自由自在地操作。即，不是带标签的纯文本，而是由带属性、带内容的节点所构成的树结构本身才是最重要的。关系数据库的表只能表示间接数据，如果是树结构，可以直接操作直接表现的数据。</p><h3 id="XML的解析"><a href="#XML的解析" class="headerlink" title="XML的解析"></a>XML的解析</h3><p>XML的解析方法有好几种。</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>DOM是文档对象模型的缩写，是对读取了XML数据的树结构进行操作的库。</p><h4 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h4><p>Simple API for XML,与将数据全部读入内存的DOM不同，通常，SAX以数据流的形式读入XML，以事件驱动进行处理。SAX中，没必要将数据全部读入，这样往往处理效率更高，所以适合于将XML变换为其他形式的处理，反过来说，不适合于对树结构进行随机访问等用途。</p><h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>XPath是用于指定XML树的一部分的书写格式。使用XPath，可以用节点名、属性名或是属性值等来选择特定的节点（群）。</p><h3 id="XML处理库REXML"><a href="#XML处理库REXML" class="headerlink" title="XML处理库REXML"></a>XML处理库REXML</h3><p>REXML是Ruby标准附属的XML处理库。REXML是具有DOM、SAX、SAX2以及XML Pull Parser等多照片那个功能的库。全部用Ruby实现，所以速度表现不怎么优秀。在特别重视效率的情况下，有必要用libxml等别的XML处理库。</p><h3 id="XML的代替"><a href="#XML的代替" class="headerlink" title="XML的代替"></a>XML的代替</h3><h4 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h4><p>JSON是把JavaScript的对象记法作为表现格式来使用。</p><p>将JSON数据原封不动地作为JavaScript去执行，就可以得到数据表现所对应的对象。但是JSON数据从外部读取的情况较多，实际上作为JavaScript直接执行容易引起安全上的问题，即使效率稍稍低一些，也应当使用解析JSON的库。</p><p>Ruby支持JSON。</p><h4 id="YAML（YMAL-ain’t-Markup-Language）"><a href="#YAML（YMAL-ain’t-Markup-Language）" class="headerlink" title="YAML（YMAL ain’t Markup Language）"></a>YAML（YMAL ain’t Markup Language）</h4><p>YAML是作为XML的对立面而诞生的，具有以下特征。完全放弃标记性记述，专注于数据表现；以缩进为基础表现数据结构；不要标签；可以对应各种语言。文件后缀为.yml</p><p>在用作数据表现及配置文件时，具有易读和不易变复杂等优点。实际上，YAML在Ruby on Rails中广泛用于配置文件。</p><p>另一方面，YAML到底是数据表现语言，没有相当于schema的东西，不适合于带结构的文本表现及元数据格式。</p><p>活用记号和缩进的YMAL比JSON更简洁，正如其名，YMAL不是标记语言，需要使用标记语言时还是XML合适。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAML是JSON的超集，采用空格来作为结构，JSON则是括号，一般YAML解析速度高于JSON，但对于某些东西定义的复杂性高于JSON，速度差别不大时可考虑用JSON。</span><br></pre></td></tr></table></figure></p><h4 id="Binary-XML"><a href="#Binary-XML" class="headerlink" title="Binary XML"></a>Binary XML</h4><p>与通常的XML有等价意义，但效率更高，采用二进制表现的是Binary XML。但现在还没有Binary XML的标准规格。</p><h4 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h4><p>Protocol Buffer使用一种“数据描述语言”来定义数据结构，然后从这个定义生成一个库，将原始数据变为二进制表现（序列化）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">持久数据的重要性</span><br><span class="line">如果不是有了像纸和刻了文字的石头等经久不烂而且可以读出的媒介，将来人类文明说不定会遇到失去重要信息的危险。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-13-关于数据的持久化&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-13-关于数据的持久化&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 13 关于数据的持久化&quot;&gt;&lt;/a&gt;松本行弘的程序世界 13 关于数据的持久化&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 12 关于时间的处理</title>
    <link href="https://github.com/zdkswd/2018/07/23/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2012%20%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/23/松本行弘的程序世界 12 关于时间的处理/</id>
    <published>2018-07-23T13:53:32.000Z</published>
    <updated>2018-07-23T13:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-12-关于时间的处理"><a href="#松本行弘的程序世界-12-关于时间的处理" class="headerlink" title="松本行弘的程序世界 12 关于时间的处理"></a>松本行弘的程序世界 12 关于时间的处理</h1><h2 id="用程序处理时刻与时间"><a href="#用程序处理时刻与时间" class="headerlink" title="用程序处理时刻与时间"></a>用程序处理时刻与时间</h2><h3 id="时差与时区"><a href="#时差与时区" class="headerlink" title="时差与时区"></a>时差与时区</h3><h3 id="世界协调时间"><a href="#世界协调时间" class="headerlink" title="世界协调时间"></a>世界协调时间</h3><h3 id="夏令时"><a href="#夏令时" class="headerlink" title="夏令时"></a>夏令时</h3><p>一定时期内时钟拨快一小时。</p><h3 id="改历"><a href="#改历" class="headerlink" title="改历"></a>改历</h3><h3 id="日期与时间的类"><a href="#日期与时间的类" class="headerlink" title="日期与时间的类"></a>日期与时间的类</h3><h4 id="Time类"><a href="#Time类" class="headerlink" title="Time类"></a>Time类</h4><p>表示日常所用时间的类。</p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>表示不含时刻的日期的类。</p><h4 id="DateTime类"><a href="#DateTime类" class="headerlink" title="DateTime类"></a>DateTime类</h4><p>Date类附加上时间信息的类。能表示时间，而且没有范围限制，功能上最强。</p><h3 id="2038年问题"><a href="#2038年问题" class="headerlink" title="2038年问题"></a>2038年问题</h3><p>不仅限UNIX，很多操作系统都是以过去某个时点开始所经过的时间来表示时刻的。在UNIX中，过去某个时点指1970年1月1日零点。<br>问题是计算机能够处理的整数大小有限，界限是2038年1月19日3时14分7秒。</p><h3 id="DateTime类-1"><a href="#DateTime类-1" class="headerlink" title="DateTime类"></a>DateTime类</h3><p>相对于epoch（某个时点）开始的秒数来管理Time类，DateTime类是以日期为基础计算的Date类，附加上时刻信息而生成的。</p><h3 id="Time与DateTime的相互变换"><a href="#Time与DateTime的相互变换" class="headerlink" title="Time与DateTime的相互变换"></a>Time与DateTime的相互变换</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-12-关于时间的处理&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-12-关于时间的处理&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 12 关于时间的处理&quot;&gt;&lt;/a&gt;松本行弘的程序世界 12 关于时间的处理&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 11 程序安全性</title>
    <link href="https://github.com/zdkswd/2018/07/21/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2011%20%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>https://github.com/zdkswd/2018/07/21/松本行弘的程序世界 11 程序安全性/</id>
    <published>2018-07-21T13:28:32.000Z</published>
    <updated>2018-07-21T13:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-11-程序安全性"><a href="#松本行弘的程序世界-11-程序安全性" class="headerlink" title="松本行弘的程序世界 11 程序安全性"></a>松本行弘的程序世界 11 程序安全性</h1><h2 id="程序的漏洞与攻击方法"><a href="#程序的漏洞与攻击方法" class="headerlink" title="程序的漏洞与攻击方法"></a>程序的漏洞与攻击方法</h2><h3 id="四种软件漏洞"><a href="#四种软件漏洞" class="headerlink" title="四种软件漏洞"></a>四种软件漏洞</h3><ol><li>dos攻击</li><li>信息泄露</li><li>权限夺取</li><li>权限升格</li></ol><p>DOS攻击，即拒绝服务攻击，指妨碍软件正常运行（服务的执行）的网络攻击手段。能够引起软件异常终止的程序错误，全部都是引发DOS攻击的安全性程序错误。<br>分为软件漏洞与外部DOS攻击。<br>信息泄露指不愿公开的信息被公开了。</p><h3 id="因权限被窃取而成为重大问题"><a href="#因权限被窃取而成为重大问题" class="headerlink" title="因权限被窃取而成为重大问题"></a>因权限被窃取而成为重大问题</h3><h3 id="安全问题的根源"><a href="#安全问题的根源" class="headerlink" title="安全问题的根源"></a>安全问题的根源</h3><p>在于运行软件的人（权限所有者）和利用软件的人是不同的。<br>安全问题有三种</p><ol><li>恶意软件<br>指在程序本身植入了恶意代码。</li><li>setuid/setgid<br>指执行的程序以所有者权限进行动作。setuid的缺点已经变得比优点更突出，现在几乎不用了。</li><li>服务器</li></ol><h3 id="“守护神”引起的问题"><a href="#“守护神”引起的问题" class="headerlink" title="“守护神”引起的问题"></a>“守护神”引起的问题</h3><p>服务这里指的是为了提供服务而常驻型的软件，又为后台服务(daemon),即守护神的意思。<br>后台服务基本上都是受理经由socket而来的请求。执行它所提供的服务，将结果经socket返回。几乎所有的情况，发出请求者和执行权限者都是不同的。这种软件若有了漏洞，会引起DOS问题和权限夺取问题。</p><h3 id="多样化的攻击手段"><a href="#多样化的攻击手段" class="headerlink" title="多样化的攻击手段"></a>多样化的攻击手段</h3><p>代表性的有：</p><ol><li>缓冲区溢出</li><li>整数溢出</li><li>跨站点脚本攻击（XSS）</li><li>SQL注入</li><li>跨站点伪造请求（CSRF）</li></ol><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>指向固定的缓冲区输入了比假定长度要长很多的数据，使程序异常终止。或者是更改堆栈的跳转地址劫持程序。<br>使用C那种连数组长度都不检查的语言，可以说肯定会产生问题。幸亏，像Ruby这样的高级语言，语言处理系统自动分配内存，可以不使用固定长的缓冲区。使用更高级的语言，可以从缓冲区溢出问题中解放出来。但由于速度上的考虑，还会开发C语言的CGI及Daemon程序，应多加注意。</p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>整数溢出与缓冲区溢出相似，但它是更难被发现的问题。<br>c等很多语言，整数只能表示一定范围的数，超过范围，就会发生溢出，也不发出警告就将数值舍入。这个问题通过使用Ruby这样的高级语言可以解决，内存分配不是由用户直接进行，内部分配都要经过严格检查。所以，只要使用Ruby，与整数溢出就不沾边。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是对外部的输入检查不充分时所产生的典型问题。<br>从外部的输入不能原封不动填到SQL语句中去，因为填入的文字可能含有对SQL语句有某种意义的文字。</p><h3 id="Shell注入"><a href="#Shell注入" class="headerlink" title="Shell注入"></a>Shell注入</h3><p>Shell注入与SQL注入原理相同。<br>从外部的输入，如果不进行检查就不能传递给system等危险的函数。<br>为了从一定程度上检查出这类问题，Ruby和Perl中有“污染检查”功能。给外部输入的数据加上“污染记号”，禁止对字符串进行危险操作。</p><h3 id="跨站点脚本攻击"><a href="#跨站点脚本攻击" class="headerlink" title="跨站点脚本攻击"></a>跨站点脚本攻击</h3><p>跨站点脚本攻击与SQL注入和Shell注入一样，也是因为将输入值原封不动地放在输出值内而引起的问题。<br>如用户输入中含有HTML标签。而且HTML可能夹杂JavaScript。</p><h3 id="跨站点伪造请求"><a href="#跨站点伪造请求" class="headerlink" title="跨站点伪造请求"></a>跨站点伪造请求</h3><p>跨站点伪造请求（CSRF）是Web应用程序固有的攻击手段。<br>构成Web应用程序的每一页由两部分构成，一个来自网路浏览器的HTTP请求，一个是HTTP服务器的响应。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.11.22.png" alt="屏幕快照 2018-07-21 下午7.11.22" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.11.22</div>            </figure></p><h3 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h3><h2 id="用异常进行错误处理"><a href="#用异常进行错误处理" class="headerlink" title="用异常进行错误处理"></a>用异常进行错误处理</h2><h3 id="异常的历史"><a href="#异常的历史" class="headerlink" title="异常的历史"></a>异常的历史</h3><h3 id="Java的受控异常"><a href="#Java的受控异常" class="headerlink" title="Java的受控异常"></a>Java的受控异常</h3><p>采用受控异常的，Java是第一个。</p><h3 id="Icon的面向目标判断"><a href="#Icon的面向目标判断" class="headerlink" title="Icon的面向目标判断"></a>Icon的面向目标判断</h3><p>Ruby在设计之初，也曾认真考虑过采用像Icon式的真伪值判断，结果还是采用了nil和false以外的值全是真值的这种正统方式。</p><h3 id="Ruby的异常"><a href="#Ruby的异常" class="headerlink" title="Ruby的异常"></a>Ruby的异常</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.30.12.png" alt="屏幕快照 2018-07-21 下午7.30.12" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.30.12</div>            </figure><h3 id="异常发生"><a href="#异常发生" class="headerlink" title="异常发生"></a>异常发生</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.33.32.png" alt="屏幕快照 2018-07-21 下午7.33.32" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.33.32</div>            </figure><h3 id="异常处理的设计方针"><a href="#异常处理的设计方针" class="headerlink" title="异常处理的设计方针"></a>异常处理的设计方针</h3><p>方法的执行应当“异常安全”，即执行时及时发生了异常也不会发生异常情况：</p><ul><li>因为发生了异常，留下了不完全的数据结构</li><li>因为发生了异常，数据库里进了垃圾</li><li>因为发生了异常，程序异常终止</li></ul><h3 id="异常发生的设计原则"><a href="#异常发生的设计原则" class="headerlink" title="异常发生的设计原则"></a>异常发生的设计原则</h3><p>假设发生的情况与既有的异常类明显不同，需要制作一个新的异常。此时考虑：</p><ul><li>名称：应该给新的类起一个什么样的名字</li><li>父类：新的类应该属于哪一个异常类的子类</li><li>生成方法：应该如何初始化新的类实例</li></ul><p>产生异常的两个原则：1异步异常，基本原则是不要使用异步异常。2.文档化，有必要清楚详细的写成文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-11-程序安全性&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-11-程序安全性&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 11 程序安全性&quot;&gt;&lt;/a&gt;松本行弘的程序世界 11 程序安全性&lt;/h1&gt;&lt;h2 id=&quot;程
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 10 高速执行和并行处理</title>
    <link href="https://github.com/zdkswd/2018/07/20/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2010%20%E9%AB%98%E9%80%9F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/</id>
    <published>2018-07-20T09:58:32.000Z</published>
    <updated>2018-07-20T10:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-10-高速执行和并行处理"><a href="#松本行弘的程序世界-10-高速执行和并行处理" class="headerlink" title="松本行弘的程序世界 10 高速执行和并行处理"></a>松本行弘的程序世界 10 高速执行和并行处理</h1><h2 id="让程序高速执行（前篇）"><a href="#让程序高速执行（前篇）" class="headerlink" title="让程序高速执行（前篇）"></a>让程序高速执行（前篇）</h2><h3 id="是不是越快越好"><a href="#是不是越快越好" class="headerlink" title="是不是越快越好"></a>是不是越快越好</h3><p>并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。</p><h3 id="高速执行的乐趣与效率"><a href="#高速执行的乐趣与效率" class="headerlink" title="高速执行的乐趣与效率"></a>高速执行的乐趣与效率</h3><p>在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。</p><h3 id="以数据为基础做出判断"><a href="#以数据为基础做出判断" class="headerlink" title="以数据为基础做出判断"></a>以数据为基础做出判断</h3><h3 id="改善系统调用"><a href="#改善系统调用" class="headerlink" title="改善系统调用"></a>改善系统调用</h3><p>排序处理任务重时，典型的对策是使用施瓦茨变换。</p><h3 id="数据可靠吗"><a href="#数据可靠吗" class="headerlink" title="数据可靠吗"></a>数据可靠吗</h3><p>误差</p><h3 id="只需改善瓶颈"><a href="#只需改善瓶颈" class="headerlink" title="只需改善瓶颈"></a>只需改善瓶颈</h3><p>性能优化中，“因为是排序，所以就用施瓦茨变换”这种条件反射式的对策并非总管用。为了合理提高速度，确立恰当的策略是很必要的。<br>帕累托法则又称80/20法则，即80%的数值是由20%的构成要素产生的。由帕累托法则可知，有20%的努力可以达到巨大回报，而有80%的努力得不到多少回报。在得不到回报的地方，不管怎么努力都是徒劳的。<br>Donald Knuth也提到，通常一半以上的执行时间都耗费在程序中不到4%的部分。<br>这些耗费了大半以上执行时间的部分称为瓶颈。<br>判定瓶颈，可以用profiler这一工具。</p><h3 id="profiler本身成了累赘"><a href="#profiler本身成了累赘" class="headerlink" title="profiler本身成了累赘"></a>profiler本身成了累赘</h3><p>不确定性原理是指测定行为本身对被测对象产生了影响，从原理上可以说不可能正确知道对象的状态。但是知道实际状态的大体倾向。</p><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>选择合适的算法，这是性能改善的第一考虑因素，要记住这条铁则。</p><h3 id="理解O记法"><a href="#理解O记法" class="headerlink" title="理解O记法"></a>理解O记法</h3><p>如何从效率方面判定一个算法的好坏呢。一个方法就是O记法，表示某种算法对于变量（比如使用的元素个数）如何变化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8A%E5%8D%8811.05.39.png" alt="屏幕快照 2018-07-20 上午11.05.39" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 上午11.05.39</div>            </figure></p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><h3 id="调查算法的性能"><a href="#调查算法的性能" class="headerlink" title="调查算法的性能"></a>调查算法的性能</h3><p>Ruby提供进行算法性能比较时用的benchmark程序。</p><h3 id="高速执行的悲哀"><a href="#高速执行的悲哀" class="headerlink" title="高速执行的悲哀"></a>高速执行的悲哀</h3><h4 id="徒劳无益的努力"><a href="#徒劳无益的努力" class="headerlink" title="徒劳无益的努力"></a>徒劳无益的努力</h4><p>很容易在瓶颈无关的地方花费太多徒劳无益的努力。</p><h4 id="改良绊住了手脚"><a href="#改良绊住了手脚" class="headerlink" title="改良绊住了手脚"></a>改良绊住了手脚</h4><p>sort_by所依据的施瓦茨变换，是用时间和空间的交换来消减计算量的方法。sort_by方法与sort方法相比，占用了多达三倍以上的内存。所以，模块内的处理本来不是很重，如果一味地占用内存反而可能会变慢。<br>性能优化，光有理论还不行，如果不实际做的话就不知道到底什么是正确的。</p><h4 id="算法选择的圈套"><a href="#算法选择的圈套" class="headerlink" title="算法选择的圈套"></a>算法选择的圈套</h4><p>在进行性能优化时，不改变原来程序的执行时一个大原则。</p><h3 id="性能优化的格言"><a href="#性能优化的格言" class="headerlink" title="性能优化的格言"></a>性能优化的格言</h3><p><strong>过早的优化是万恶之源。</strong></p><p><strong>优化有两条准则。</strong><br><strong>1.别做优化</strong><br><strong>2.（仅适用于专家）先不要做优化</strong></p><hr><p><strong>过早的优化是万恶之源</strong><br>代码优化的好处多多，但是这并不意味着所有的代码都需要进行优化，有时过度的优化反而适得其反——费时、费力、不讨好。<br>“现代计算机科学的鼻祖”Donald Knuth曾说过“过早的优化是万恶之源”，因为：让正确的程序更快，要比让快速的程序正确容易得多。<br>在项目开发中，总是有程序员浪费宝贵的时间去改进那些不需要改进的代码，而没有通过所做的改进增加价值。在对项目进行优化时，究竟哪些地方应该优化，应该如何优化，哪些不应该优化呢？你需要先来了解一下本文所说的这7件事。<br>1.究竟要优化什么？<br>在优化工作开始的时候，你还尚未明确优化内容和目的，那么你很容易陷入误区。在一开始，你就应该清楚地了解你要达到的效果，以及其他优化相关的各种问题。这些目标需要明确指出（至少精通技术的项目经理可以理解和表达它），接下来，在整个优化过程中，你需要坚持这些目标。<br>在实际的项目开发中，经常会存在各种各样的变数。可能一开始时要优化这一方面，随后你可能会发现需要优化另一方面。这种情况下，你需要清晰地了解这些变化，并确保团队中的每个人都明白目标已经发生了变化。<br>2.选择一个正确的优化指标<br>选择正确的指标，是优化的一个重要组成部分，你需要按照这些指标来测量优化工作的进展情况。如果指标选择不恰当，或者完全错误，你所做的努力有可能白费了。<br>即使指标正确，也必须有一些辨别。在某些情况下，将最多的努力投入到运行消耗时间最多的那部分代码中，这是实用的策略。但也要记住，Unix/Linux内核的大部分时间花费在了空循环上。<br>需要注意的是，如果你轻易选择了一个很容易达到的指标，这作用不大，因为没有真正解决问题。你有必要选择一个更复杂的、更接近你的目标的指标。<br>3.优化在刀刃上<br>这是有效优化的关键。找到项目中与你的目标（性能、资源或其他）相背的地方，并将你的努力和时间用在那里。<br>举一个典型的例子，一个Web项目速度比较慢，开发者在优化时将大部分精力放在了数据库优化上，最终发现真正的问题是网络连接慢。<br>另外，不要分心于容易实现的问题。这些问题尽管很容易解决，但可能不是必要的，或与你的目标不相符。容易优化并不意味着值得你花费工夫。<br>4.优化层次越高越好<br>在一般情况下，优化的层次越高，就会越有效。根据这个标准，最好的优化是找到一个更有效的算法。<br>举个例子，在一个软件开发项目中，有一个重要的应用程序性能较差，于是开发团队开始着手优化，但性能并没有提升太多，之后，项目人员交替，新的开发人员在检查代码时发现，性能问题的核心是由于在表中使用了冒泡排序算法，导致成千上万项的增加。<br>尽管如此，高层次的优化也不是“银弹”。一些基本技术，如将所有东西移到循环语句外，也可以产生一些优化的效果。通常情况下，大量低层次的优化可以产生等同于一个高层次优化的效果。<br>还需要注意的是，高层次优化，会减少一些代码块，那么你之前对这些代码块所做的优化就没有任何意义了，因此，刚开始就应该考虑高层次的优化。<br>5.不要过早优化<br>在项目早期就进行优化，会导致你的代码难以阅读，或者会影响运行。另一方面，在项目后期，你可能会发现之前所做的优化没有起到任何作用，白白浪费了时间和精力。<br>正确的方式是，你应该将项目开发和优化当作两个独立的步骤来做。<br>6.依赖性能分析，而不是直觉<br>你往往会认为你已经知道哪里需要优化，这是不可取的，尤其是在复杂的软件系统中，性能分析数据应该是第一位的，最后才是直觉。<br>优化的一个有效的策略是，你要根据所做工作对优化效果的影响来进行排序。在开始工作之前找到影响最大的“路障”，然后再处理小的“路障”。<br>7.优化不是万金油<br>优化最重要的规则之一是，你无法优化一切，甚至无法同时优化两个问题。比如，优化了速度，可能会增加资源利用；优化了存储的利用率，可能会使其他地方放慢。你需要权衡一下，哪个更符合你的优化目标。</p><hr><h2 id="让程序高速执行（后篇）"><a href="#让程序高速执行（后篇）" class="headerlink" title="让程序高速执行（后篇）"></a>让程序高速执行（后篇）</h2><p>例题是曼德勃罗集合的计算程序，指复平面上满足以下条件的复素数的集合：经过某种反复迭代运算以后，其值不会发散到无限大。</p><h3 id="确认程序概要"><a href="#确认程序概要" class="headerlink" title="确认程序概要"></a>确认程序概要</h3><h3 id="发现瓶颈"><a href="#发现瓶颈" class="headerlink" title="发现瓶颈"></a>发现瓶颈</h3><p>使用profiler</p><h3 id="使用更好地profiler"><a href="#使用更好地profiler" class="headerlink" title="使用更好地profiler"></a>使用更好地profiler</h3><p>ruby-prof程序通过使用扩展库可以实现高速profile</p><h3 id="高速优化之一：消减对象"><a href="#高速优化之一：消减对象" class="headerlink" title="高速优化之一：消减对象"></a>高速优化之一：消减对象</h3><p>Ruby高速优化的规则。</p><h4 id="减少对象"><a href="#减少对象" class="headerlink" title="减少对象"></a>减少对象</h4><p>高级面向对象语言中对象的生成要花费一定的时间，减少对象，除了会降低生成成本外，还有别的好处。<br>Ruby中不在使用的对象，由被称作垃圾收集的处理自动进行回收。垃圾收集处理需要检查对象的引用关系，任何地方都不再引用的对象会被判定为已经不再使用了。当对象的数量很多时，判断成本就要增大。</p><h4 id="减少方法调用"><a href="#减少方法调用" class="headerlink" title="减少方法调用"></a>减少方法调用</h4><p>方法调用中，存在多态性这一面向对象的本质特征，先要评价参数，判定对象种类，然后选出一个合适的方法，再讲控制交给该方法，这是一个缓慢的处理过程。<br>为了避开方法调用，尽可能不用Ruby中实现的方法。Ruby中实现的方法，几乎所有的情况都是调用其他方法来实现的。也就是说，只要使用了一次Ruby中实现的方法，就会有多余的方法调用发生。</p><h3 id="高速优化之二：利用立即值"><a href="#高速优化之二：利用立即值" class="headerlink" title="高速优化之二：利用立即值"></a>高速优化之二：利用立即值</h3><p>Ruby中有几类对象并不实际分配内存，而是用引用本身来表示，这种值称为立即值。<br>现在的Ruby中，小的整数（±2    ^30以内）、真假值、nil和符号名等都是立即值。<br>立即值既然不生成对象，就不用担心对象的生成成本，而且也不用垃圾收集处理，所以它具有特别理想的特性。</p><h3 id="高速优化之三：利用C语言"><a href="#高速优化之三：利用C语言" class="headerlink" title="高速优化之三：利用C语言"></a>高速优化之三：利用C语言</h3><p>Ruby是解释性语言，单纯计算的循环不是很快。如果将处理交给编译器，就可以变得很快。</p><h3 id="高速优化之四：采用合适的数据结构"><a href="#高速优化之四：采用合适的数据结构" class="headerlink" title="高速优化之四：采用合适的数据结构"></a>高速优化之四：采用合适的数据结构</h3><h3 id="全部以C语言计算"><a href="#全部以C语言计算" class="headerlink" title="全部以C语言计算"></a>全部以C语言计算</h3><h3 id="还存在其他技巧"><a href="#还存在其他技巧" class="headerlink" title="还存在其他技巧"></a>还存在其他技巧</h3><p>还有以空间换时间。</p><h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><p>与进程不同，同一进程的线程可以共享内存空间，所以，不同的线程能够引用同一对象。不需要经过将数据变为字节流再进行通信这样麻烦的处理，就能交换信息。</p><h3 id="生成线程"><a href="#生成线程" class="headerlink" title="生成线程"></a>生成线程</h3><h3 id="线程的执行状态"><a href="#线程的执行状态" class="headerlink" title="线程的执行状态"></a>线程的执行状态</h3><p>Ruby的线程有四种状态。<br>run：执行中<br>stop：停止中<br>to_kill:终止处理中<br>killed:终止<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%881.55.11.png" alt="屏幕快照 2018-07-20 下午1.55.11" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午1.55.11</div>            </figure></p><h3 id="传递值给线程的方法"><a href="#传递值给线程的方法" class="headerlink" title="传递值给线程的方法"></a>传递值给线程的方法</h3><h3 id="信息共享所产生的问题"><a href="#信息共享所产生的问题" class="headerlink" title="信息共享所产生的问题"></a>信息共享所产生的问题</h3><ol><li>数据完整性丧失</li><li>死锁</li></ol><p><strong>与其说是线程的问题，不如说是并行处理本身的问题。</strong></p><h3 id="数据完整性的丧失"><a href="#数据完整性的丧失" class="headerlink" title="数据完整性的丧失"></a>数据完整性的丧失</h3><p>原子操作</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>哲学家进餐问题</p><h3 id="用锁来实现对资源的独占"><a href="#用锁来实现对资源的独占" class="headerlink" title="用锁来实现对资源的独占"></a>用锁来实现对资源的独占</h3><p>Ruby Mutex类，互斥锁。<br>Java中，方法定义声明为synchronize,该方法被调用时自动加锁。</p><h3 id="二级互斥"><a href="#二级互斥" class="headerlink" title="二级互斥"></a>二级互斥</h3><p>很遗憾，锁的问题并不全是Mutex所能覆盖的单纯事例。如数据库中，对数据的访问需要以下多种互斥控制。</p><ol><li>可以同时引用</li><li>禁止同时更新</li><li>禁止更新中引用</li><li>禁止引用中更新</li></ol><p>引用与更新这种两个层次的互斥（二级互斥），在文件读取时也经常会发生。</p><hr><p><strong>数据库锁总结</strong></p><p>数据库锁出现的原因是为了处理并发问题，因为数据库是一个多用户共享的资源，当出现并发的时候，就会导致出现各种各样奇怪的问题，就像程序代码一样，出现多线程并发的时候，如果不做特殊控制的话，就会出现意外的事情，比如“脏“数据、修改丢失等问题。所以数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制，所以数据库锁是跟并发控制和事务联系在一起的。</p><p>平时会经常看到或者听到数据库锁有“共享锁”，“排它锁”，“互斥锁”，“写锁”，“读锁”，“悲观锁”，“乐观锁”，“行级锁”，“表级锁”，“页级锁”等，同时我们还会常看到“丢失修改“，”不可重复读“，”读脏数据“这三个术语，他们究竟是什么关系以及怎么理解呢，下面就来介绍一下他们。</p><p>先说事务的特性，要想成为事务，必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；一致性指的是事务的执行结果必须是使数据库从一个一致性状态变大另一个一致性状态，一致性和原子性是密切相关的；隔离性指的是一个事务执行不能被其他事务干扰；持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。</p><p>先说悲观锁和乐观锁吧。并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。乐观锁就比较简单了，就是不做控制，这只是一部分人对于并发所持有的一种态度而已。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁和共享锁，其中排它锁又称为写锁，共享锁又称为读锁。</p><p>共享锁和排它锁是具体的锁，是数据库机制上的锁，存在以下关系：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%882.17.40.png" alt="屏幕快照 2018-07-20 下午2.17.40" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午2.17.40</div>            </figure></p><p>(x表示是排它锁(Exclusive)，s表示共享锁(Share)，Y表示yes，N表示no）</p><p>上图表示可以共存的锁，如，第二行表示，一个事务T1给某数据加了X锁，则事务T2就不能再给那数据加X锁了，同时也不能再加S锁了，只有到T1事务提交完成之后，才可以。默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁。<br>另外，并发操作会导致数据的不一致性，主要包括“丢失数据”，“不可重复读”，“读脏数据等。还有就是，并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防，预防的方法有：1一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；2顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。另外，系统如何判断出现死锁呢，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁，诊断和判断死锁有两种方法，一是超时法，二是等待图法。超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。</p><p>最后，说下行级锁和表级锁。锁包括行级锁和表级锁<br>行级锁是一种排他锁，防止其他事务修改此行。</p><hr><h3 id="用队列协调线程"><a href="#用队列协调线程" class="headerlink" title="用队列协调线程"></a>用队列协调线程</h3><p>使用锁对资源进行互斥控制，是线程间保证协调的一种机制。除了锁以外，为了保证协调，还有别的方法。<br>问题的根源在于多个进程访问同一资源，为了实现无共享，给每个资源准备一个管理用的线程，各线程间只能交换某些限定的信息。<br>线程间信息交换的方法有代表性的有信息存储，信道及队列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.05.36.png" alt="屏幕快照 2018-07-20 下午3.05.36" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.05.36</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的生产者消费者问题并不是典型的生成者消费者问题，而是做出了一定的限制，即生产速度小于消费速度。不锁buffer,仅做信息传递的通道来进行说明。</span><br></pre></td></tr></table></figure><p>队列也可以用于解决资源的竞争。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.08.13.png" alt="屏幕快照 2018-07-20 下午3.08.13" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.08.13</div>            </figure></p><h3 id="锁模型与队列模型的比较"><a href="#锁模型与队列模型的比较" class="headerlink" title="锁模型与队列模型的比较"></a>锁模型与队列模型的比较</h3><h4 id="锁模型"><a href="#锁模型" class="headerlink" title="锁模型"></a>锁模型</h4><p>如果竞争足够少，多数情况下能保持较高性能，对于资源的竞争，不能忘记加锁，要做到完美无缺较难。</p><h4 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h4><p>在竞争少的时候，其性能比不上锁模型，比锁模型更容易贯彻，会因线程增多而带来性能低下的恶果。</p><h2 id="前景可期的并行编程技术，Actor"><a href="#前景可期的并行编程技术，Actor" class="headerlink" title="前景可期的并行编程技术，Actor"></a>前景可期的并行编程技术，Actor</h2><p>并行编程，要求有更高的抽象度和对人类而言更简单的编程模型。Actor（参与者模式）或许就是答案。</p><h3 id="何谓Actor"><a href="#何谓Actor" class="headerlink" title="何谓Actor"></a>何谓Actor</h3><p>所谓Actor，是（仅）通过消息（message）进行通信的实体。<br>与面向对象语言中对象的区别。向对象发送消息（方法调用），调用开始后，会一直等到返回结果，是一种同步方式。面向Actor发送消息，仅仅是发送消息而不返回结果，是一种异步方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步(Synchronous)和异步(Asynchronous)</span><br><span class="line">1.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</span><br><span class="line">2.异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。</span><br></pre></td></tr></table></figure></p><p>Actor由于仅仅通过消息进行信息交换，所以不能直接共享同一个值，信息传达要多花些代价。<br>Actor由于没有消息以外的信息传递手段，所以不用担心Actor之间的资源竞争。发送给Actor的消息都配送到各个Actor所拥有的邮箱里。多个消息同时到达时竞争由内嵌到系统中的排除机制来处理。<br>Actor的一大优点是安全，更大的优点是易懂。Actor根据消息进行处理，必要的化会向其他Actor传递消息，或向Actor返回消息。<br>这与现实世界中人与人之间相处没有多大的差别。现实世界中，别人在想什么你不知道，想要求什么时，需要通过某种手段传递“消息”。<br>理论上要到达最高性能，一般认为线程更优秀。但如果不注意使用线程的话，会出现与时机相关的很麻烦的问题。在计算机性能日益提高的今天，与理论上最高性能的可能性相比，Actor的安全性和易懂性更引人注目。</p><h3 id="操作Actor的三种处理系统"><a href="#操作Actor的三种处理系统" class="headerlink" title="操作Actor的三种处理系统"></a>操作Actor的三种处理系统</h3><p>Actor Model的函数型语言Erlang。<br>Erlang是只允许单一赋值的函数型语言，即一旦赋值，变量的值就不再改变。</p><h3 id="Erlang的程序"><a href="#Erlang的程序" class="headerlink" title="Erlang的程序"></a>Erlang的程序</h3><h3 id="pingpong处理的开始"><a href="#pingpong处理的开始" class="headerlink" title="pingpong处理的开始"></a>pingpong处理的开始</h3><h3 id="启动pingpong程序"><a href="#启动pingpong程序" class="headerlink" title="启动pingpong程序"></a>启动pingpong程序</h3><h3 id="Erlang的错误处理"><a href="#Erlang的错误处理" class="headerlink" title="Erlang的错误处理"></a>Erlang的错误处理</h3><p>Erlang中通过发送消息来通知异常终止。收到消息的process（actor）料理死去的process后事。<br>有了这种机制，使得Erlang适合构造抗障碍性强的系统。</p><h3 id="Erlang的使用场所"><a href="#Erlang的使用场所" class="headerlink" title="Erlang的使用场所"></a>Erlang的使用场所</h3><p>Erlang在通常的文本处理汇总并不怎么快。Erlang的好处在于其扩展性。对于多个处理并列执行的情况，分割成合适的Erlang process，能够发挥多CPU的威力。<br>同样的多任务分割虽然用操作系统的进程或线程也能实现，但Erlang的process与操作系统的进程或线程相比，能够轻量实现（1个process最小只耗费300字节），即使有大量process也不必顾虑、更进一步说，Erlang设计思想不用process连基本处理都不能实现，process分割在某种意义上可以说是强制的。</p><p>适合现代服务器端程序。</p><h3 id="面向Ruby的库“Revactor”"><a href="#面向Ruby的库“Revactor”" class="headerlink" title="面向Ruby的库“Revactor”"></a>面向Ruby的库“Revactor”</h3><p>Revactor的目的是为Ruby提供Erlang式的编程。<br>其优点是可以同时体验Ruby和Erlang的好处。但是Revactor中Actor的实现不是靠线程而是靠Fiber。Erlang的目的在于最大限度地利用多核CPU，而Revactor并不适合这种目的。<br>Revactor的最大优点，是能够在等待文件输入输出时，将程序的停止控制在最小程度。</p><h3 id="另一个库Dramatis"><a href="#另一个库Dramatis" class="headerlink" title="另一个库Dramatis"></a>另一个库Dramatis</h3><p>Dramatis是Ruby中另一个Actor库。函数型语言Erlang不支持面向对象功能。用Ruby这样的面向对象语言来实现Actor的时候，即使用普通对象来实现Actor，也不可避免地会出现把方法调用和发送消息这两种类似概念混在一起的情况。Dramatis库就是解答这种“概念混淆”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-10-高速执行和并行处理&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-10-高速执行和并行处理&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 10 高速执行和并行处理&quot;&gt;&lt;/a&gt;松本行弘的程序世界 10 高速执行和并行
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
