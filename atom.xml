<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2018-07-26T13:09:06.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/zdkswd/2018/07/25/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2014%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/07/25/松本行弘的程序世界 14 函数式编程/</id>
    <published>2018-07-25T01:35:29.000Z</published>
    <updated>2018-07-26T13:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-14-函数式编程"><a href="#松本行弘的程序世界-14-函数式编程" class="headerlink" title="松本行弘的程序世界 14 函数式编程"></a>松本行弘的程序世界 14 函数式编程</h1><h2 id="新范型–函数式编程"><a href="#新范型–函数式编程" class="headerlink" title="新范型–函数式编程"></a>新范型–函数式编程</h2><p>函数式编程是全部使用函数来编写程序代码的编程方法。这是可以与一般的结构化编程及面向对象编程相提并论的编程方法。</p><p>以函数为中心的函数式编程具有特征：</p><ol><li>函数本身也作为数据来处理（第一级函数）</li><li>以函数为参数的高阶函数</li><li>参数相同即可保证结果相同的引用透明性。</li><li>为实现引用透明性，禁止产生副作用的处理。</li></ol><p>函数式编程的最大优点在于，程序可以按照数学的形式以及声明的形式来编写。</p><p>结构式编程是在改变变量值的同时进行计算，所以一直注意着，这个变量的值是什么，并据此来预想计算过程。</p><p>采用函数式编程方式并不改变变量的值。并不包含状态或者动作等信息，仅仅是对想要做什么加以描述，这样不容易出错。</p><p>这种不是描述动作而是描述性质的编程方式称为<strong>声明式编程</strong>。声明式描述是函数式编程的一大优点。</p><h3 id="具有多种函数式性质的Lisp"><a href="#具有多种函数式性质的Lisp" class="headerlink" title="具有多种函数式性质的Lisp"></a>具有多种函数式性质的Lisp</h3><p>之前，Lisp被认为是函数式编程的代表。Lisp具备函数式语言的很多性质。</p><p>Lisp最大的特征是S式记法。S式是括号很多的Lisp的记法。S式无与伦比的优点是它彻底的统一性。对Lisp而言，不管什么都可以同一成单一形式。</p><p>第二个重要之处在于链这种数据结构。Lisp语言本名是List Processor（链表处理器），从侧面说明了链的重要性。链是一种构成树结构数据的通用数据结构，构成数据结构的节点分别包含两个引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8A%E5%8D%8810.02.29.png" alt="屏幕快照 2018-07-25 上午10.02.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 上午10.02.29</div>            </figure></p><p>总之，Lisp具备了函数编程语言的基本特征。但是Lisp不直接支持多数纯粹的函数式编程语言所拥有的副作用如回避以及延迟计算等功能。对变量的赋值没有任何限制。且编程风格为很多很多括号。比较难适应。</p><p>近年来，由于像Haskell这样的彻底的函数式编程语言的兴起，Lisp作为函数式编程语言在人们心中的印象越来越淡薄。</p><h3 id="彻底的函数式编程语言Haskell"><a href="#彻底的函数式编程语言Haskell" class="headerlink" title="彻底的函数式编程语言Haskell"></a>彻底的函数式编程语言Haskell</h3><p>Haskell可以说是纯粹的函数式编程语言。<br>Haskell语言特征：</p><ol><li>没有副作用</li><li>高阶函数</li><li>函数部分应用</li><li>延迟计算(非正式)</li><li>静态多态类型系统</li><li>型推论</li><li>链内包表达式</li><li>用对齐来表示块</li></ol><h4 id="没有副作用"><a href="#没有副作用" class="headerlink" title="没有副作用"></a>没有副作用</h4><p>Haskell程序基本没有副作用，不但不能改变变量的值，就连链的元素也是不能改变的。因此，只要参数不变，函数的返回值也就总是一样的。相同输入总能返回相同结果，这种可重复性对测试程序非常有利。这种重复性也称为引用透明性。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>Haskell高阶函数把函数本身作为数据来处理。比如，Haskell中没有循环控制结构，循环都是用递归调用或者高阶函数来实现的。</p><h4 id="延迟计算：不必要的处理就不做"><a href="#延迟计算：不必要的处理就不做" class="headerlink" title="延迟计算：不必要的处理就不做"></a>延迟计算：不必要的处理就不做</h4><p>必要时才进行处理。</p><h3 id="灵活的“静态多态性”类型系统"><a href="#灵活的“静态多态性”类型系统" class="headerlink" title="灵活的“静态多态性”类型系统"></a>灵活的“静态多态性”类型系统</h3><p>与没有类型的Ruby不同，Haskell是在编译时确定所有变量类型的静态类型语言。但实际上Haskell程序基本上没有必要给出变量的类型。这是因为聪明的Haskell语言处理系统会推测变量的类型。</p><p>Haskell利用多态性的类型系统和系统推测，在维持着接近于duck typing灵活性的同时，也使编译时的完全类型检查成为可能。</p><h3 id="近代函数式语言之父OCaml"><a href="#近代函数式语言之父OCaml" class="headerlink" title="近代函数式语言之父OCaml"></a>近代函数式语言之父OCaml</h3><p>OCaml也是具有代表性的函数式编程语言之一。它比Haskell还古老，说它是近代函数式语言之父也毫不为过。</p><p>与Haskell相比，OCaml具有如下不同：</p><ol><li>没有副作用</li><li>没有延迟计算</li><li>具有强力的模块系统</li></ol><p>虽然不像Haskell那样自然地做到延迟计算，但换来的好处是，程序内容与实际处理关系接近，使人容易理解程序的执行过程。</p><h3 id="强于并行计算的Erlang"><a href="#强于并行计算的Erlang" class="headerlink" title="强于并行计算的Erlang"></a>强于并行计算的Erlang</h3><p>作为函数式编程语言，二郎的特点</p><ol><li>受Prolog影响</li><li>专用于并行计算</li></ol><h3 id="用Ruby进行函数式编程"><a href="#用Ruby进行函数式编程" class="headerlink" title="用Ruby进行函数式编程"></a>用Ruby进行函数式编程</h3><p>Ruby中有几个能进行函数式编程的工具</p><h4 id="Proc对象（lambda）"><a href="#Proc对象（lambda）" class="headerlink" title="Proc对象（lambda）"></a>Proc对象（lambda）</h4><p>Ruby中唯一与函数直接对应的是Proc对象。</p><h4 id="程序块"><a href="#程序块" class="headerlink" title="程序块"></a>程序块</h4><p>以程序块为参数的方法等价于函数型语言的高阶函数。灵活运用以程序块为参数的方法，就可以实现函数式编程的高阶函数的技巧。</p><h4 id="枚举器"><a href="#枚举器" class="headerlink" title="枚举器"></a>枚举器</h4><p>Ruby中没有延迟计算，但用枚举器对数组和列表进行循环，可以实现类似于延迟计算的处理。</p><h4 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h4><p>所谓避免副作用，就是对生成的对象，尽量少去改变其状态。</p><h3 id="用枚举器来实现延迟计算"><a href="#用枚举器来实现延迟计算" class="headerlink" title="用枚举器来实现延迟计算"></a>用枚举器来实现延迟计算</h3><p>从Ruby1.8.7开始，很多以块为参数的方法在参数不是块的时候，就会返回枚举器。</p><p>枚举器就是把循环用对象来表达的一种方法。</p><p>使用这样的枚举器可以实现与Haskell类似的延迟计算。</p><h2 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h2><h3 id="在商业中利用Ruby"><a href="#在商业中利用Ruby" class="headerlink" title="在商业中利用Ruby"></a>在商业中利用Ruby</h3><h3 id="使用Ruby自动生成代码"><a href="#使用Ruby自动生成代码" class="headerlink" title="使用Ruby自动生成代码"></a>使用Ruby自动生成代码</h3><p>编程中的代码重复是非常恶劣的。发现了代码重复，就应该考虑在合理的代价范围内避免代码重复的方法。</p><h3 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h3><p>为了在构建程序的时候，自动生成省略部分，我们只需要定义make的规则、在构建程序的过程中调用代码生成工具。</p><h3 id="代码生成的应用"><a href="#代码生成的应用" class="headerlink" title="代码生成的应用"></a>代码生成的应用</h3><h4 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h4><p>从数据结构定义自动生成数据库的访问例程（包括SQL）。</p><h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><p>大多数依赖于数据库的Web应用程序，常常需要对表的各项目进行增删改查操作。</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>代码生成对单元测试也很有效果。只要有数据和测试条件，就可以开始单元测试。</p><h4 id="客户界面"><a href="#客户界面" class="headerlink" title="客户界面"></a>客户界面</h4><h4 id="文档化"><a href="#文档化" class="headerlink" title="文档化"></a>文档化</h4><p>代码生成也适合与文档化。对于自动生成的类，由人工记入档案是纯粹的浪费。按照JavaDoc的形式，在生成代码的程序里写好相应的文档，应该是个聪明的办法。</p><h3 id="代码生成的效果"><a href="#代码生成的效果" class="headerlink" title="代码生成的效果"></a>代码生成的效果</h3><p>代码生成有如下好处：</p><ol><li>改进质量。</li><li>确保一致性</li><li>集中知识。</li><li>增加用于设计的时间。</li><li>独立于程序实现的设计判断</li></ol><h3 id="编写代码生成器"><a href="#编写代码生成器" class="headerlink" title="编写代码生成器"></a>编写代码生成器</h3><p>对代码生成最有帮助的工具要数eRuby。Ruby本身也拥有优越的文本处理功能。使用eRuby以比较自然地形式编写模板的同时，还可以灵活运用Ruby的处理能力。</p><h3 id="也可以使用XML"><a href="#也可以使用XML" class="headerlink" title="也可以使用XML"></a>也可以使用XML</h3><p>幸运的是，Ruby拥有解释XML的标准库REXML。REXML提供操作XML的功能。</p><h3 id="在EJB中使用代码生成"><a href="#在EJB中使用代码生成" class="headerlink" title="在EJB中使用代码生成"></a>在EJB中使用代码生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分</span><br></pre></td></tr></table></figure><h2 id="内存管理与垃圾收集"><a href="#内存管理与垃圾收集" class="headerlink" title="内存管理与垃圾收集"></a>内存管理与垃圾收集</h2><p>垃圾收集（GC）是一种管理程序使用的内存区域的方法。使用具有垃圾收集功能的编程语言或处理程序的话，程序中不需要编写内存管理的代码，即不用编写代码来释放使用过的内存区域。</p><h3 id="内存管理的困难"><a href="#内存管理的困难" class="headerlink" title="内存管理的困难"></a>内存管理的困难</h3><p>在垃圾收集普及之前，内存区域的取得和释放完全是程序员的责任。随着程序的执行，会使用一些内存区域作为作业区。为记忆对象、字符串和数组等个别信息，都需要使用内存区域。没有垃圾收集的语言一般都提供有API，利用这些API，可以再需要时向操作系统申请并取得内存，使用过之后再把内存区域返回给操作系统。</p><h4 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h4><p>如果把还在使用中的内存区域错误调用free予以释放的话，就会发生悬挂指针的现象。程序再去访问该区域时就可能会出错。在引用该区域内容时，多数场合会读取到被破坏的数据，或是在更新该领域数据的时候，会置换成预想之外的数据。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>另一方面，如果忘记了把申请的内存区域返还给操作系统的话，就会发生内存泄漏。这时候因为使用过的内存区域越来越多，程序占有的内存就会逐渐增加。特别是长时间启动，连续提供服务的常驻内存型程序，容易发生内存泄漏，导致系统停止等重大问题。</p><h4 id="二重释放"><a href="#二重释放" class="headerlink" title="二重释放"></a>二重释放</h4><p>对已经释放过的内存区域再次调用free的情况也时有发生。这称为二重释放。这会带来malloc和free内部使用的数据区域不一致的问题。</p><p>内存泄漏问题只有在内存占用量超过预想的时候才会显露，而悬挂指针问题不会发生在释放使用内存的时刻，而是要到访问释放过的内存区域才会出现。程序员往往会在看起来完全没有问题的地方突然遭遇意想不到的错误。</p><h3 id="垃圾收集亮相之前"><a href="#垃圾收集亮相之前" class="headerlink" title="垃圾收集亮相之前"></a>垃圾收集亮相之前</h3><p>应该管理的内存区域越来越多，内存释放时刻的管理也就越来越难，这是产生内存问题的原因。</p><p>关于垃圾收集，有以下这些先入为主的观念。</p><h4 id="垃圾收集慢"><a href="#垃圾收集慢" class="headerlink" title="垃圾收集慢"></a>垃圾收集慢</h4><p>有研究表明，在某些条件下，垃圾收集比手工管理内存还更快。</p><h4 id="垃圾收集可靠性低"><a href="#垃圾收集可靠性低" class="headerlink" title="垃圾收集可靠性低"></a>垃圾收集可靠性低</h4><p>在Java之后诞生的编程语言，不管是否受到Lisp的影响，几乎都毫无例外的拥有垃圾收集的功能。垃圾收集从诞生之日起，经历了40多年的发展，终于成为大家认可的一项特性了。</p><h3 id="评价垃圾收集的两个指标"><a href="#评价垃圾收集的两个指标" class="headerlink" title="评价垃圾收集的两个指标"></a>评价垃圾收集的两个指标</h3><p>假如存在无线内存的计算机的话，就没有必要进行垃圾收集。</p><p>垃圾收集的性能可以由两个指标来测定：</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量是垃圾收集处理在程序全部执行时间中所占的比例。比例越小越好，比例大的话，程序整体的性能就会低下。</p><h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>暂停时间是一次垃圾收集处理所中断的时间。暂停时间过长的话，处理的中断时间就会变得很显眼，程序反应就会变慢。</p><p>垃圾收集每次所花的时间会因垃圾收集执行时对象的总数而变化，暂停时间有两种，一是把垃圾收集时间求平均值得到平均暂停时间，二是程序执行中最长的垃圾收集时间所代表的最大暂停时间。</p><p>那些实时性要求高的程序，就很重视最大暂停时间。像批处理这样非对话的处理强调吞吐量要高，而重视反应速度的嵌入式或者GUI程序就强调暂停时间要短。</p><p>Java运行环境中实现由多种垃圾收集算法，可以根据程序的性质来切换合适的垃圾收集算法。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>基本上是以下4类，还有几种变形：</p><ol><li>引用计数方式</li><li>标记和扫除方式</li><li>标记和紧缩方式</li><li>复制方式</li></ol><h3 id="引用计数方式"><a href="#引用计数方式" class="headerlink" title="引用计数方式"></a>引用计数方式</h3><p>引用计数方式在垃圾收集算法中具有最简单最容易实现的特征。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.25.46.png" alt="屏幕快照 2018-07-25 下午5.25.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.25.46</div>            </figure><br>引用计数器最大的优点就是容易实现。这种方式得到广泛的使用。暂停时间短也是它的优点。</p><p>最大的缺点是不能释放有循环引用关系的对象群。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.28.21.png" alt="屏幕快照 2018-07-25 下午5.28.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.28.21</div>            </figure><br>与生俱来的缺点，因为在引用增减的时候有必要同时正确维护引用计数器的增减，忘了这一点就会带来悬挂指针或内存泄露问题。</p><p>最后一个缺点是，引用计数器的管理与并行处理不相容。如果多个进程同时增减一个引用计数器的话，就会发生引用计数器的值不一致的现象。为避免这一个问题，需要在操作引用计数器的时候进行排他处理，但在频繁发生引用操作的同时进行排他处理的话，会带来巨大的时间开销。</p><p>总之，这种原理简单实现也简单的引用计数器方式，缺点很多，最近已经不怎么用了。</p><p>采用引用计数器方式的主要语言处理系统有Perl和Python。为了回避循环引用的问题，它们都组合了其他垃圾收集方式。这些语言基本上以引用计数器方式来进行垃圾收集，只有在极个别的情况下，才通过别的垃圾收集算法来处理引用计数器不能回收的对象。</p><h3 id="标记和扫除方式"><a href="#标记和扫除方式" class="headerlink" title="标记和扫除方式"></a>标记和扫除方式</h3><p>标记和扫除方式也是古老的垃圾收集算法。<br>标记和扫除方式从有可能成为对象引用元的变数（根）开始，给被引用的对象加上标记，表明其“活着”。然后再给标记对象所引用的对象还有其再引用的对象，也都递归地加上引用标记。</p><p>这样从根开始不管是直接还是间接，只要把所有引用的对象都加上标记的话，那么没有标记的对象就是没有被引用的，也就是“已经死了”。然后在所有的对象中找出没有标记的对象，把它们作为垃圾扫除出去。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-25%20%E4%B8%8B%E5%8D%885.50.20.png" alt="屏幕快照 2018-07-25 下午5.50.20" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-25 下午5.50.20</div>            </figure><br>此法虽然古老，但是非常优秀，现在也还被多种处理系统所采用。</p><p>但是当对象数目较多时，性能容易恶化。在标记的时候要访问生存的所有对象，在回收时按顺序访问所有的对象，找出”已经死了“的对象。在寻找垃圾和扫除过程中，基本不能进行其他处理，垃圾收集时间长的话，会影响到本来的处理工作。</p><h3 id="标记和紧缩方式"><a href="#标记和紧缩方式" class="headerlink" title="标记和紧缩方式"></a>标记和紧缩方式</h3><p>标记和紧缩方式是标记和扫除的变形。标记处理是一样的，后阶段有所不同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.01.29.png" alt="屏幕快照 2018-07-26 下午12.01.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.01.29</div>            </figure><br>标记和紧缩方式最大的特征也是他的优越之处，是把空间集中起来（紧缩）。紧缩的结果是把没有释放而活下来的对象都集中到一个地方。这样，内存访问就集中到一个局部区域，这可以提高缓存功能的效率。对象的分配也只是把指针移动一下就完成了，降低了对象分配的开销。</p><p>缺点是，把生存着的对象全部复制的紧缩开销，容易比标记和扫除方式中执行的开销还要大。因为对象被移动位置了。</p><p>一部分Lisp处理系统采用的是标记和紧缩方式，Java处理系统（作为多个垃圾收集算法中的一个）也有标记和紧缩方式。</p><h3 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h3><p>像标记和扫除方式、标记和紧缩方式这样“标记之后释放死了的对象”的算法，标记时间与活着的对象数成比例，扫除时间与总对象数成比例。所以在分配有很多的对象，其中几乎所有对象都要被释放的场合，扫除的开销会变高，在性能方面很不利。</p><p>复制方式与标记和扫除方式一样，从根开始扫描所有的对象，但他不仅仅是加标记，还执行复制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.11.58.png" alt="屏幕快照 2018-07-26 下午12.11.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.11.58</div>            </figure><br>复制方式把内存空间分成旧空间和新空间两大块，总是在旧空间中分配对象。旧空间爆满时，从根开始扫描对象，把对象复制到新空间。这时，复制后的引用也要随之更新。</p><p>递归的执行从旧空间到新空间的复制，结束时就会把所有活着的对象都移动到新空间。不再被引用的对象都遗留到旧空间，旧空间就可以整个弃之不用，就避免了扫除的开销，从此再把新空间作为旧空间再进行同样的处理。</p><p>最大的优点是，垃圾回收的开销只和活着的对象数成比例。对象分配的开销也低。还有“局部性”的优点。复制方式按顺序把引用的对象复制到新空间，关系近的对象会被分配到相近的内存空间，称为局部性。关系近的对象被访问的可能性也高。计算机因为有缓存，内存空间相接近的访问可能具有较好的性能，局部性高的程序具有提高性能的优势。</p><p>缺点：复制方式要复制所有活着的对象，几乎具有和标记和紧缩方式一样的缺点。</p><h3 id="多种多样的垃圾收集算法"><a href="#多种多样的垃圾收集算法" class="headerlink" title="多种多样的垃圾收集算法"></a>多种多样的垃圾收集算法</h3><p>把基本算法组合起来的技术，几个具有代表性的：</p><ol><li>分代垃圾收集</li><li>保守垃圾收集</li><li>增量垃圾收集</li><li>并行垃圾收集</li><li>位图标志</li></ol><p>这些技术的组合也是有可能的。</p><h3 id="分代垃圾收集"><a href="#分代垃圾收集" class="headerlink" title="分代垃圾收集"></a>分代垃圾收集</h3><p>分代垃圾收集的基本思想是利用程序和对象的性质。一般程序都有这样一个性质，几乎所有的对象都在比较短的时间里变成垃圾，存活时间超过一定程度的对象总是拥有更长的寿命。</p><p>因为这一性质，就可以重点对分配之后的年轻对象进行扫描，这样就不用扫描全部对象就可能高效率地回收垃圾。</p><p>分代垃圾收集把对象的内存空间分成两个，新代和旧代，也有分成3个的。</p><p>只扫描新代区域的回收称为轻垃圾收集，但没有检查旧代区域对新代的引用，被引用的对象可能误判死亡，就会带来内存问题。</p><p>解决这一问题的方法是，监视对象的更新。在旧代区域引用新代区域的同时，就把这一引用的记录例程以及对象的更新场所全都记录下来，这个检查例程叫做<strong>写屏障</strong>，记录旧代区域对新代区域的引用叫<strong>记录集</strong>。</p><p>以所有区域对象的垃圾收集称为全垃圾收集或重垃圾收集。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%8812.33.58.png" alt="屏幕快照 2018-07-26 下午12.33.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午12.33.58</div>            </figure><br>分代垃圾收集减少了扫描对象的个数，有缩短平均暂停时间的效果。但是，因为要执行全垃圾收集，最大暂停时间不会得到明显的改善。</p><p>最近几乎所有的Java都实现有分代垃圾收集。另外，函数型语言OCaml也采用了分代垃圾收集。</p><h3 id="保守垃圾收集"><a href="#保守垃圾收集" class="headerlink" title="保守垃圾收集"></a>保守垃圾收集</h3><p>像C这种本来没有垃圾收集的语言，编译之后没有保留区别整数和指针的信息，因为CPU对两者不加区分，所以也就没这个必要。通常，垃圾收集的实现需要明确区分引用（指针），而C和C++没有这样的功能，在这样的环境下实现垃圾收集的技巧之一称为保守垃圾收集。</p><p>其基本思想就是如果碰巧有整数的值与引用相同的话，该对象就有可能被引用，就当它是活着的。保守就是倾向于安全的意思。与此相对，能够明确区别所用的环境下的垃圾收集称为精确垃圾收集。</p><p>因为倾向于安全一面，保守垃圾收集在C或者C++这样没有垃圾收集功能的语言中也可以得到实现，这是它的优点。但是，本来应该回收的对象却在意料之外保留下来不能回收，这是它的缺点。以及，它不能喝复制垃圾收集这样需要移动的垃圾收集算法组合使用。</p><p><strong>Ruby采用的是保守垃圾收集。</strong>局部变量可以按照通常语言的访问路径来处理，系统堆栈部分是当做指针数组来扫描的。Ruby大部分是用C编写的，因为有了保守垃圾收集，C库的实现变得非常简单。实际上，Python和Perl因为采用的是引用计数器，C例程内部的引用数管理非常复杂，偶然忘记增减就会发生内存问题。但是，用C编写Ruby扩展库时，基本上不用操心内存管理，好处十分明显。</p><p>Boehm GC为C和C++增加了垃圾收集功能。Boehm GC也同时实现了分代垃圾收集。Boehm GC不仅用于C和C++，在Scheme处理系统Gauche等多种语言处理系统中，也作为垃圾收集功能得到广泛的应用。</p><h3 id="增量垃圾收集"><a href="#增量垃圾收集" class="headerlink" title="增量垃圾收集"></a>增量垃圾收集</h3><p>在实时性要求高的程序中，垃圾收集带来的中断时间必须是可预测的。为保证实时性，不需要等垃圾收集完全执行结束，而是要把垃圾收集细分正许多细小的片段，每次执行一点，这叫增量垃圾收集。</p><p>增量垃圾收集在垃圾收集处理过程中程序也在同时执行，引用有可能会改变。结果是垃圾收集的一致性不能得到保证。增量垃圾收集为避免这样的问题，采用了与保守垃圾收集相同的写屏蔽操作。</p><p>嵌入式处理系统采用的是增量垃圾收集。有名的Io和Lua都实现了增量垃圾收集。</p><h3 id="并行垃圾收集"><a href="#并行垃圾收集" class="headerlink" title="并行垃圾收集"></a>并行垃圾收集</h3><p>在多核环境下，灵活运用线程可以最大限度地发挥多个CPU的能力。并行垃圾收集就是要最大限度利用多个CPU的能力。</p><p>并行垃圾收集基本原理与增量垃圾收集大致是一样的，都是利用写屏蔽来维护当前状态的信息。有的并行垃圾收集的实现生成垃圾收集专用线程，把垃圾收集设计成总是与普通处理并行执行。</p><h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><p>以Linux为首的UNIX系列操作系统在使用fork系统调用复制过程时，内存空间并不进行复制而是直接共享。通过写时复制来提高性能。</p><p>垃圾收集与这一功能兼容性不好，给引用对象那个设置标记的方式会因设置标记而复制包含该对象的内存页。复制方式也同样会产生大量写内存操作。</p><p>位图标记是在利用标记的垃圾收集中消减操作系统内存页复制的方法。它不在对象里设置被引用的标记，而是利用外部位图区域（管理用内存区域）来保存引用标记。</p><p>只有标记用的位图部分会发生内存页复制，从而避免了复制没有实际更新的对象所在的内存页。</p><p>Ruby的垃圾收集也有了实现位图标记的补丁。</p><h2 id="用C语言来扩展Ruby"><a href="#用C语言来扩展Ruby" class="headerlink" title="用C语言来扩展Ruby"></a>用C语言来扩展Ruby</h2><p><strong>Ruby是解释型语言，即Ruby程序是由Ruby解释器的程序来解释执行的。</strong></p><p>提起解释器，大家会觉得它是逐行读取程序并执行，实际上Ruby解释器是把要执行的程序全部读进来，首先变换成更有效率的内部表现形式。解释器对其内部表现加以分析来执行程序。</p><p>解释型语言的特点，马上可以执行，开发周期非常快。至于C、C++、Java这样的编译语言，首先要把程序变换成计算机可以直接执行的形式再从头执行。</p><p>在执行程序过程中，编译型语言不再需要对原来程序进行解释和变换，速度很快。但是开发周期较长。</p><h3 id="开发与执行速度的取舍"><a href="#开发与执行速度的取舍" class="headerlink" title="开发与执行速度的取舍"></a>开发与执行速度的取舍</h3><p>这两种类型的语言要做取舍。Ruby的设计方针是开发效率优于执行效率，选择解释型的实现也是必然。</p><p>Ruby解释器是由C语言开发的，采用C语言开发理由：</p><ol><li>C语言作者拿手</li><li>C语言运行系统调用，速度高</li><li>用面向对象语言来实现别的面向对象语言的话，容易混淆对象的概念。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%885.36.05.png" alt="屏幕快照 2018-07-26 下午5.36.05" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午5.36.05</div>            </figure><p><strong>引擎</strong>是解释内部表现，并实际上执行程序的部分。1.9版本的引擎解释的字节码，可以说是近似于虚拟计算机的机器语言。所以1.9版本的引擎也可以成为VM。</p><p><strong>引擎</strong>在解释内部表现是，需要其他组件的帮助。内存和对象的管理，变量访问和方法调用的实现等，都要依靠底层称为<strong>运行库</strong>的组件来完成。<strong>运行库</strong>提供底层强有力的支持，是程序执行时不可或缺的部分。</p><p>Ruby利用的各种类是<strong>类库</strong>提供的。Ruby的这一部分也是用C编写的。像Ruby这样的解释型语言，因为是经过C编写的引擎来间接执行程序，与一般的编译语言相比，执行速度明显慢得多（100 倍或者 1000 倍）。但是，实际上程序的执行时间大部分都花在 C 編写的类库方法内部，因此在执行速度上很少会产生那么巨大的差距。</p><h3 id="扩展库"><a href="#扩展库" class="headerlink" title="扩展库"></a>扩展库</h3><p>扩展库是指利用Ruby运行库的API,用C定义的类库。Ruby的API使用C几乎可以实现Ruby所有的功能。使用这些API可以很简单地实现如下的功能：</p><ol><li>定义类</li><li>定义方法</li><li>访问实例变量</li><li>调用方法</li><li>调用块</li></ol><p>特意花时间用C来实现扩展库的理由主要有以下两点。</p><ol><li>想要比Ruby执行速度快</li><li>想使用C可以利用的库。</li></ol><p>前面已经说过,Ruby是解释型语言,它的执行速度不如像C这样的编译型语言。如果是绝对需要改善速度的程序,用C扩展库来实现其中成为瓶颈的部分的话,有可能显著改善程序的<br>执行速度。</p><p>UNX系列操作系统的大多数功能都是通过C可以访问的库来提供的。Ruby要想利用这些功能的话,就需要有一种从Ruby调用C的API的方法,这最简单的方法就是利用扩展库。</p><h3 id="扩展库的编译"><a href="#扩展库的编译" class="headerlink" title="扩展库的编译"></a>扩展库的编译</h3><p>首先按照以上的顺序编写源代码。若C程序的文件名后<br>约定为c的话,后续步骤会自动识别出来C程序文件。</p><p>为生成编译所需要的文件,需要准备必要的<br>Ruby文件。这个文件通常命名为 extconf.rb<br>minitab的 extconf.rb的内容如图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%887.09.31.png" alt="屏幕快照 2018-07-26 下午7.09.31" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午7.09.31</div>            </figure></p><p>extons,xb是由以下几个部分构成的:</p><ol><li>调用 require’mkmf’;   </li><li>用have_1 ibrary和 hava header检<br>查必要的库和头文件是否存在；  </li><li>用 create makefile来生成必要的<br>Makefile. create makefile的参数<br>是库的名字。</li></ol><p>照图14-34执行 extconfrb,就可以生成<br>Makefi1e。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%887.13.48.png" alt="屏幕快照 2018-07-26 下午7.13.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午7.13.48</div>            </figure></p><p>用make命令来编译,尔后可以用 make insta11命令来安装编译后的库。</p><h3 id="扩展库之外的工具"><a href="#扩展库之外的工具" class="headerlink" title="扩展库之外的工具"></a>扩展库之外的工具</h3><h4 id="RubyInline"><a href="#RubyInline" class="headerlink" title="RubyInline"></a>RubyInline</h4><p>Rubylnline可以在Ruby的源代码中直接嵌入C的程序。不用每次准备 exton,rb文件,也不需要明确的编译步骤,非常便利,但它也有不少约束,比如在执行环境中需要有编译器,与外部库的链接也有些麻烦等。</p><h4 id="dl"><a href="#dl" class="headerlink" title="dl"></a>dl</h4><p>有了d1,仅用Ruby也能实现与 minitab同样动作的库。把图1435的程序保存成 inial,rb文件,没有扩展库也可以使用 minitab。al的优点是在没有安装编译器和头文件的环境下也可以运行。</p><h4 id="ffi"><a href="#ffi" class="headerlink" title="ffi"></a>ffi</h4><p>关于Ruby的扩展,ffi库受到关注。ffi是 foreign function interface的缩写,它也提供在Ruby水平上的与外部函数的直接接口,这个目的与d1几乎是一样的。ffi可以从 Ruby Gems得到。ffi的特征是使用lb更有效率地调用外部函数,Ruby、 Rubinius和 GRubby都可以使用<br>同样的API。</p><h2 id="为什么要开源"><a href="#为什么要开源" class="headerlink" title="为什么要开源"></a>为什么要开源</h2><h3 id="自由软件的思想"><a href="#自由软件的思想" class="headerlink" title="自由软件的思想"></a>自由软件的思想</h3><p>为保证执行的自由,必须能够将软件免费拿到手。出于学习和研究的目的,也必须能够自由地得到源代码。还有,为了修改程序错误,或者为适合自己的目的而进行改造,那就不单单<br>是阅读源代码,还要允许改变源代码。把自己认为好的软件推荐给别人,或者把自己进行的修改或改善与他人共享的话,就需要有再发布的自由。</p><h3 id="自由软件的历史"><a href="#自由软件的历史" class="headerlink" title="自由软件的历史"></a>自由软件的历史</h3><p>曾几何时,在计算机的黎明期,软件完全是硬件的附属物。买了计算机,附带操作系统等源代码,根本就不是什么稀罕的事。那时,或者在更早一些的时候,甚至有这样的情况,从生<br>产厂家买来的计算机连操作系统也没有,需要用户自己来开发各种软件。买了同样计算机的用户互相交换自己开发的软件,互助合作。虽然不够精致,但与如今开源软件的情况很有些相似之处。</p><h3 id="Emacs事件的发生"><a href="#Emacs事件的发生" class="headerlink" title="Emacs事件的发生"></a>Emacs事件的发生</h3><p>但是,戈斯林把 Gosmacs的专利卖给了 Unipress公司,斯托曼就不能够在 Gosmacs的基础上开发新的 Emacs了。结果,斯托曼从零开始开发了自己的UNIX版的Emacs。</p><p>他们的最终目标是，创造一个从上到下完全自由的操作系统环境。</p><h3 id="开源的诞生"><a href="#开源的诞生" class="headerlink" title="开源的诞生"></a>开源的诞生</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15324825297704/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%20%E4%B8%8B%E5%8D%888.52.32.png" alt="屏幕快照 2018-07-26 下午8.52.32" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-26 下午8.52.32</div>            </figure><h3 id="OSS许可证"><a href="#OSS许可证" class="headerlink" title="OSS许可证"></a>OSS许可证</h3><h4 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h4><p>GPL( GNU General Public license)应该可以说是自由软件许可证的鼻祖,它具有如下特征:</p><ol><li>没有保证;</li><li>表示版权;</li><li>保持同样的许可证</li></ol><p>GPL特征中最重要的是保持同样的许可证,也就是说,在对GPL许可证的软件进行修改或复制的情况下,必须保持其原来的GPL许可证。<br>这意味着再利用GPL软件的源代码而开发的软件的许可证也必须是GPL。批判GPL的人把这称为感染性。赞同GPL的人们称之为版权保留,因为这一性质意味着版权的保留。</p><h4 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h4><h4 id="BSD许可证"><a href="#BSD许可证" class="headerlink" title="BSD许可证"></a>BSD许可证</h4><h4 id="APL和CPL"><a href="#APL和CPL" class="headerlink" title="APL和CPL"></a>APL和CPL</h4><h3 id="开源的背景"><a href="#开源的背景" class="headerlink" title="开源的背景"></a>开源的背景</h3><p>在科学领域,共享知识和信息本来是非常普通的事情。即使不用看站在巨人的肩膀上的牛顿的例子,把知识作为论文(免费)公开,利用前人的成绩进行新的研究是再理所当然不过的。</p><p>软件,特别是商业软件,一旦作为商品来经营的话,就容易忘记这样一点,与论文的内容一样,软件也不过是信息的一种,也应该适用同样的原则。科学家致力于研究,大学或研究机构对科学家给予支持,这种体制对软件也有可能成立。实际上,大学或研究机构支援软件开发的例子相当多。</p><p>但是,谈到近年来开源的普及和发展,计算机的普及和因特网的发展则功不可没。过去如果要想开发髙质量软件的话,需要购买价格髙昂的计算机,召集大量的技术人员。现在一般家庭里的计算机都完全能够开发软件,通过网络进行合作开发的事情也屡见不鲜。个人出于兴趣而编程也已经能够达到相当高的水平了。</p><p>软件的复杂化和商品化也是开源的背景之一,不容忽视。软件所覆盖的领域越来越广,软件也越来越复杂。过去1万行左右的程序就实现了的操作系统,如今变成了超过600万行的巨大软件。</p><h3 id="企业关注开源的理由"><a href="#企业关注开源的理由" class="headerlink" title="企业关注开源的理由"></a>企业关注开源的理由</h3><p>从1998年以来,开始出现了盈利企业为自己的利益而开发开<br>源软件的事例。一旦认识到无法自己来开发所有软件之后,企业只自己开发最具竞争力的小部分核心软件,而让大家共同来开发其他软件,结果对大家都有好处,企业关注开源正是这种冷静的分析考量的结果。</p><p>参与开源的人们也各有各的想法。有因经营考虑而参加的企业,有为软件自由而参加的程序员,有因上级命令而参加的公司职员,各种各样,千差万别。但是,开源有可能为个人和全人类带来幸福,如果能继续下去形成良性循环的话,那真是再好不过了。</p><h3 id="Ruby与开源"><a href="#Ruby与开源" class="headerlink" title="Ruby与开源"></a>Ruby与开源</h3><p>Ruby从一开始就是开源软件。Ruby在1995年初次公开的时候,开源这个单词还没有诞生,也许应该称为自由软件。</p><h3 id="选择许可证的方法"><a href="#选择许可证的方法" class="headerlink" title="选择许可证的方法"></a>选择许可证的方法</h3><p>许可证与技术无关,而是有关法律和合同的工作,这不是技术人员的工作,而是属于律师的工作范围。对于软件开发人员来说,这决不是一件令人感兴趣的工作,有人甚至会想:“哪用得着这些东西呢?”</p><p>如果使用你的许可证的软件的所有代码都完全是由你自己写出来的话,这几乎不成为什么问题。只要发布新的许可证版本,问题就解决了但是,如果其中包含了其他人写的补丁的话,软件就不再是你一个人的了,在法律上写补丁的人是共同拥有版权的。</p><p>FSF作为软件自由的拥护者,强烈推行版权保留。另一方面,不怎么在乎版权保留的开发人员好像更多一些。如果你希望版权保留的话,几乎就只能选择GPL。</p><p>如果你的软件是作为库来使用的话,那么LGPL则是个不错的选择。如果对库适用GPL许可证的话,那事实上就只能为GPL软件所用,采用限制较为宽松的LGPL的话,有可能使你的软件得到更为广泛的使用。但是,LGPL有不方便、难于理解以及没有得到充分考察等缺点,在不太强烈希望版权保留的时候,最好不要选择它。</p><p>对于不太在乎版权保留的人来说,可以选择GPL以外的许可证。这里的要点是,该软件是否需要与其他软件进行链接。如果预想到将来可能以某种方式与GPL许可证的软件链接在一起的话,那么与GPL的互换性就变得很重要。拥有插件功能的软件或库特别要注意这一点。作为与GPL不相矛盾的许可证,有修正BSD许可证和MIT许可证等。</p><p>另一个应该考虑的要点是,与相关软件和许可证是否一致。比如 Eclipse插件就应该选择Eclipse许可证(即使不与GPL互换)。另外,PHP关联软件选择与PHP一致的许可证也是安全的。用Ruby编写的软件与Ruby本身的许可证本来是相互独立的,但好像也大都选择Rby许可证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-14-函数式编程&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-14-函数式编程&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 14 函数式编程&quot;&gt;&lt;/a&gt;松本行弘的程序世界 14 函数式编程&lt;/h1&gt;&lt;h2 id=&quot;新
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 13 关于数据的持久化</title>
    <link href="https://github.com/zdkswd/2018/07/24/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2013%20%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://github.com/zdkswd/2018/07/24/松本行弘的程序世界 13 关于数据的持久化/</id>
    <published>2018-07-24T02:00:32.000Z</published>
    <updated>2018-07-25T02:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-13-关于数据的持久化"><a href="#松本行弘的程序世界-13-关于数据的持久化" class="headerlink" title="松本行弘的程序世界 13 关于数据的持久化"></a>松本行弘的程序世界 13 关于数据的持久化</h1><h2 id="持久化数据的方法"><a href="#持久化数据的方法" class="headerlink" title="持久化数据的方法"></a>持久化数据的方法</h2><h3 id="保存文本"><a href="#保存文本" class="headerlink" title="保存文本"></a>保存文本</h3><h3 id="变换成文本的Marshal"><a href="#变换成文本的Marshal" class="headerlink" title="变换成文本的Marshal"></a>变换成文本的Marshal</h3><p>将对象按一定的方式变换成文本，就可以保存到文件中去。这样的对象文本化就称为serialize(序列化)，或是marshal(封送处理)。</p><h3 id="使用Marshal模块"><a href="#使用Marshal模块" class="headerlink" title="使用Marshal模块"></a>使用Marshal模块</h3><p>标准Ruby中，嵌入了marshal功能，这就是Marshal模块。<br>Marshal模块中提供了几乎能将全部Ruby对象变为字节串的方法dump，以及将字节串恢复成原对象（的复制）的load方法。<br>对象可以简单地保存到文件里。</p><h3 id="复制有两种方式"><a href="#复制有两种方式" class="headerlink" title="复制有两种方式"></a>复制有两种方式</h3><p>使用Marshal可以完成对象的深复制。<br>复制对象的时候，通常使用clone方法。这种情况下，只复制直接对象，引用的对象不复制。称为浅复制。<br>深复制连同引用对象也一起进行递归复制。</p><h3 id="仔细看Marshal的格式"><a href="#仔细看Marshal的格式" class="headerlink" title="仔细看Marshal的格式"></a>仔细看Marshal的格式</h3><p>Marshal用二进制形式将对象文本化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15323139335047/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.07.00.png" alt="屏幕快照 2018-07-23 上午11.07.00" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-23 上午11.07.00</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15323139335047/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.09.40.png" alt="屏幕快照 2018-07-23 上午11.09.40" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-23 上午11.09.40</div>            </figure></p><h3 id="不能保存的3类对象"><a href="#不能保存的3类对象" class="headerlink" title="不能保存的3类对象"></a>不能保存的3类对象</h3><p>Marshal在实现上有限制。以下3类对象不能保存：</p><ol><li>定义了特异方法的对象。</li><li>输入、输出或是套接字等不能超越进程保存的对象。</li><li>在扩充库中定义，Ruby不知道保存方法的对象。 </li></ol><p>但是即使不能封送处理，若不是像输入输出那种从原理上不可能的情况，单纯是不知道封送处理方法的话，重新教一遍也就行了。</p><h3 id="制作面向对象数据库"><a href="#制作面向对象数据库" class="headerlink" title="制作面向对象数据库"></a>制作面向对象数据库</h3><p>使用Marshal保存对象，使对象具有了持久性。所以，Marshal也可应用于面向对象数据库。<br>PStore库是Marshal的一个用例。Marshal虽然只是将数据变换成字符串，PStore却利用了这一点，简单地实现了面向对象数据库。<br>PStore有三个特征：使用Marshal，可以原封不动地保存任意的Ruby对象；具有容易使用的接口；有事务处理（transaction）。<br>PStore也有缺点，它不适合一下子将数据全部读入内存的大规模数据库。但几百字节的小规模数据库，应该没问题。</p><h3 id="试用PStore"><a href="#试用PStore" class="headerlink" title="试用PStore"></a>试用PStore</h3><h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><h4 id="开始事务处理"><a href="#开始事务处理" class="headerlink" title="开始事务处理"></a>开始事务处理</h4><h4 id="对象的登录和取得"><a href="#对象的登录和取得" class="headerlink" title="对象的登录和取得"></a>对象的登录和取得</h4><h4 id="事务处理的终止"><a href="#事务处理的终止" class="headerlink" title="事务处理的终止"></a>事务处理的终止</h4><p>简单说明一下事务处理的步骤：</p><ol><li>用flock将数据文件加锁。</li><li>用Marshal从数据文件中读取数据</li><li>执行（事务处理）块</li><li>块的执行成功，Marshal将数据写入数据文件</li><li>块的执行失败，什么也不做。</li></ol><h3 id="变换为文本的YAML"><a href="#变换为文本的YAML" class="headerlink" title="变换为文本的YAML"></a>变换为文本的YAML</h3><p>Marshal的变换结果是二进制文件，内容不容易看懂。有些场合及时效率低一些，也需要能够以更容易看懂的形式输出。能够满足要求的是YAML。使用文本形式，不依赖平台的体系结构，是一种对人而言易读易编辑的序列化格式。</p><p>有以下几个特征：记述简洁；结果容易读懂；使用缩进的层次表现；数据表现是专用的，不必烦恼标签的名称问题。</p><p>YMAL可以活用在Ruby on Rails的配置文件等各种各样的领域。YMAL是在Perl中开发的，但正式的支持，Ruby是第一个。</p><h3 id="用YAML制作数据库"><a href="#用YAML制作数据库" class="headerlink" title="用YAML制作数据库"></a>用YAML制作数据库</h3><p>类似于PStore的东西，YAML：：Store，其与PStore的互换性非常高，只要把名字换一换，面向PStore的程序在YAML：：Store也能运行。</p><p>他俩的区别：</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>很显然，一个YAML，一个Marshal。</p><h4 id="数据量"><a href="#数据量" class="headerlink" title="数据量"></a>数据量</h4><p>Marshal比YAML紧凑的多，Marshal牺牲了易读性而实现了良好性能。</p><h4 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h4><p>性能优良不光是容量的问题。使用Marshal的PStore比YAML：：Store速度高，在这一点上，也是数据量越大，两者的差异就越显著。</p><h2 id="对象的保存"><a href="#对象的保存" class="headerlink" title="对象的保存"></a>对象的保存</h2><p>对象持久化库Madeleine，利用直接持久化对象的设计模式Object Prevalence。</p><p>Madeleine是Object Prevalence在Ruby中的实现，应称为PStore的发展形式。</p><p>PStore只是对象单纯由Marshal输出而来，Madeleine则与应用程序相协调，实现了高可靠性和高性能的持久化。</p><h3 id="高速的Object-Prevalence"><a href="#高速的Object-Prevalence" class="headerlink" title="高速的Object Prevalence"></a>高速的Object Prevalence</h3><p>所谓Prevalence，是一种实现应用程序持久化和进程间共享数据的设计模式。高性能的秘密在于直接访问内存中的数据。Object Prevalence将处理的数据保存在正在执行的应用程序的内存中，检索等操作不通过SQL而是直接进行，节省了与数据库副武器的通信成本，引用当然就会很高速。</p><p>但是，只有是同一进程，才能引用内存中的数据，进程一结束，数据马上消失。从持久化角度有必要解决这一问题。</p><p>Object Prevalence用日志记录（journaling）和快照（snapshot）来解决这一问题。Object Prevalence中，数据更新时不是直接更新对象，而是创建称为command的对象，采用的是一种非常间接的方法，在用command更新对象时，内存中的对象更新的同时，所有的更新内容也会写到称为日志（journal log）的外部文件中。</p><p>长此下去日志越来越大，所以要将现在数据状态写到称为快照的文件中。有了快照，老日志就不需要了，可在适当的时机删除。</p><p>有了最新的快照和最新的日志，可以完全恢复现在对象的状态。程序启动，按三步骤恢复内存的数据。及时有多个进程，只要写入日志的信息是完整的，就可以共享对象的状态。</p><ol><li>如果不存在快照，就初始化应用程序数据。</li><li>如果存在快照，就读入其中最新的一个。</li><li>如果还存在日志，也将其读入，并用其中最新的一个更新应用程序数据。</li></ol><h3 id="Object-Prevalence的问题点"><a href="#Object-Prevalence的问题点" class="headerlink" title="Object Prevalence的问题点"></a>Object Prevalence的问题点</h3><p><strong>Object Prevalence通过使用日志记录和快照实现了对象的持久化和进程间共享。</strong>Object Prevalence将所有数据都保存到内存中，随着数据量的增大，内存的消耗也在增大。</p><p>关系数据库中，不引用的数据放在文件中，必要的内存量就不用那么多了。</p><p>Object Prevalence有为了数据更新而具有的特殊结构，更新持久化数据时需要经由command对象。</p><h3 id="使用Madeleine"><a href="#使用Madeleine" class="headerlink" title="使用Madeleine"></a>使用Madeleine</h3><h3 id="访问时刻信息"><a href="#访问时刻信息" class="headerlink" title="访问时刻信息"></a>访问时刻信息</h3><h3 id="让Madeleine更容易使用"><a href="#让Madeleine更容易使用" class="headerlink" title="让Madeleine更容易使用"></a>让Madeleine更容易使用</h3><p>Madeleine既保持简洁性，又能让对象持久化，但是最大的缺点是在每次更新应用程序时必须生成command对象。</p><h3 id="Madeleine的实用例Instiki"><a href="#Madeleine的实用例Instiki" class="headerlink" title="Madeleine的实用例Instiki"></a>Madeleine的实用例Instiki</h3><p>Madeleine没有得到广泛应用，除了知道的人少，还因为数据全保存在内存中，就必须十分留意数据的大小。</p><p>Madeleine有一个很大的缺点，就是没有考虑多个进程同时更新数据的情况。</p><h2 id="关于XML的考察"><a href="#关于XML的考察" class="headerlink" title="关于XML的考察"></a>关于XML的考察</h2><h3 id="XML的祖先是SGML"><a href="#XML的祖先是SGML" class="headerlink" title="XML的祖先是SGML"></a>XML的祖先是SGML</h3><p>SGML是将文档电子化的一种格式。由三部分组成：表示数据本身的Instance，表示数据结构的DTD，以及SGML声明。</p><p>由于SGML太复杂，处理成本太高，为了表现网页，将SGML特化为HTML，随之诞生的是XML。</p><p>XML不像HTML那样是为了特定目的的标记语言，它一开始就是为了通用目的而设计的。为了让XML在没有DTD来定义语法或提供schema信息的情况下，也能够解析，人们对其语法进行了简化。</p><h3 id="XML是树结构的数据表现"><a href="#XML是树结构的数据表现" class="headerlink" title="XML是树结构的数据表现"></a>XML是树结构的数据表现</h3><p>XML基本上是纯文本，以类似于HTML的标签嵌套方式实现树结构。XML是继承了SGML的通用标记语言，其与SGML最大的区别是其基本语法固定，不依赖于DTD那样的外部信息也能解析。</p><p>即使没有标签的概要信息也能解析的语法称为良构的（well-formed）,这是XML的一大特征。</p><h3 id="优点在于纯文本"><a href="#优点在于纯文本" class="headerlink" title="优点在于纯文本"></a>优点在于纯文本</h3><p>最大的优点在于XML基本上是纯文本的，表示结构的信息附加在标签里。</p><p>第二个优点是不易发生字符编码的问题。XML规定，在没有明确指定的情况下，字符编码均使用Unicode。</p><p>第三个优点是得益于良构的性质，在没有数据结构的情况下也能解析XML数据。这样就可以不考虑目的，而用共同的工具来处理XML数据。</p><p>第四个优点在于，XML与其解析工具不依赖于特定的语言，比如Java生成的XML数据在Ruby中的解析也很简单。解析XML的API，像DOM和SAX都超越语言提供了几乎共通的性质，所以不同语言也可以进行同样的操作。</p><p>最后一个有点是，人们也很容易理解。</p><p>总之，XML作为各种数据交换格式的框架，具有优良的性质。作为格式的格式，也就是元格式，是很优秀的。</p><h3 id="缺点在于冗长"><a href="#缺点在于冗长" class="headerlink" title="缺点在于冗长"></a>缺点在于冗长</h3><p>最大的缺点是效率低下。XML是以纯文本出现的，标签信息反复出现，显得冗长。与表示相同信息的二进制数据相比，XML数据的容量要大得多，与其他文本表现方式相比（YAML，JSON）也显得冗长。</p><p>效率低下不光体现在数据大小上，解析XML的效率也不怎么高。与二进制文件相比，XML文件的解析因为含有大量字符串处理，而容易变得很慢。</p><p>作为文本的标记语言而诞生的XML，用其表现有一定结构的数据到底好不好还是个疑问。如果只是用于表现构造数据，比XML更有效率的格式还有很多。而且XML原则上只能表现树结构的数据。</p><p>总结，XML作为出于通用目的的数据格式，效率很低，所谓很多优点，如果场合不对，也没多大意义。适才适用，XML也要分情况适当使用。</p><h3 id="不适合重视效率的处理"><a href="#不适合重视效率的处理" class="headerlink" title="不适合重视效率的处理"></a>不适合重视效率的处理</h3><p>对于重视通信量和速度的情况都不适合，此时应使用专用的协议或是效率更高的格式。</p><p>像配置文件那样靠人直接编辑的数据也不推荐XML。配置文件中，需要用到XML的树结构数据地方很少，随着要素数增加，就会很难读，用YMAL和JSON才更合适。</p><p>XML适合的场合：</p><ol><li>人一般不直接接触</li><li>复杂性不成问题</li><li>效率不成为问题</li><li>跨平台</li></ol><h3 id="适合于信息交换的格式"><a href="#适合于信息交换的格式" class="headerlink" title="适合于信息交换的格式"></a>适合于信息交换的格式</h3><p>利用XML的元格式性质，以XML为基础的格式的例子。</p><ol><li>RSS。Web网站更新信息。</li><li>Atom。RSS的代替。</li><li>ebXML。电子商务数据交换。</li><li>SVG。向量-图像表示。</li><li>SMIL。 多媒体及内容控制。</li></ol><p>以上这些都具有XML的性质，可以用XML处理工具简单地解析。制作数据格式时，最麻烦的就是制作处理这种格式的软件。所以，XML与XML处理库的存在是很可贵的。</p><p>另外，XML数据库中，问题不在于数据是不是实际以纯文本XML来表现，而在于XML能够表现的树结构能够自由自在地操作。即，不是带标签的纯文本，而是由带属性、带内容的节点所构成的树结构本身才是最重要的。关系数据库的表只能表示间接数据，如果是树结构，可以直接操作直接表现的数据。</p><h3 id="XML的解析"><a href="#XML的解析" class="headerlink" title="XML的解析"></a>XML的解析</h3><p>XML的解析方法有好几种。</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>DOM是文档对象模型的缩写，是对读取了XML数据的树结构进行操作的库。</p><h4 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h4><p>Simple API for XML,与将数据全部读入内存的DOM不同，通常，SAX以数据流的形式读入XML，以事件驱动进行处理。SAX中，没必要将数据全部读入，这样往往处理效率更高，所以适合于将XML变换为其他形式的处理，反过来说，不适合于对树结构进行随机访问等用途。</p><h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>XPath是用于指定XML树的一部分的书写格式。使用XPath，可以用节点名、属性名或是属性值等来选择特定的节点（群）。</p><h3 id="XML处理库REXML"><a href="#XML处理库REXML" class="headerlink" title="XML处理库REXML"></a>XML处理库REXML</h3><p>REXML是Ruby标准附属的XML处理库。REXML是具有DOM、SAX、SAX2以及XML Pull Parser等多照片那个功能的库。全部用Ruby实现，所以速度表现不怎么优秀。在特别重视效率的情况下，有必要用libxml等别的XML处理库。</p><h3 id="XML的代替"><a href="#XML的代替" class="headerlink" title="XML的代替"></a>XML的代替</h3><h4 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h4><p>JSON是把JavaScript的对象记法作为表现格式来使用。</p><p>将JSON数据原封不动地作为JavaScript去执行，就可以得到数据表现所对应的对象。但是JSON数据从外部读取的情况较多，实际上作为JavaScript直接执行容易引起安全上的问题，即使效率稍稍低一些，也应当使用解析JSON的库。</p><p>Ruby支持JSON。</p><h4 id="YMAL（YMAL-ain’t-Markup-Language）"><a href="#YMAL（YMAL-ain’t-Markup-Language）" class="headerlink" title="YMAL（YMAL ain’t Markup Language）"></a>YMAL（YMAL ain’t Markup Language）</h4><p>YMAL是作为XML的对立面而诞生的，具有以下特征。完全放弃标记性记述，专注于数据表现；以缩进为基础表现数据结构；不要标签；可以对应各种语言。</p><p>在用作数据表现及配置文件时，具有易读和不易变复杂等优点。实际上，YAML在Ruby on Rails中广泛用于配置文件。</p><p>另一方面，YAML到底是数据表现语言，没有相当于schema的东西，不适合于带结构的文本表现及元数据格式。</p><p>活用记号和缩进的YMAL比JSON更简洁，正如其名，YMAL不是标记语言，需要使用标记语言时还是XML合适。</p><h4 id="Binary-XML"><a href="#Binary-XML" class="headerlink" title="Binary XML"></a>Binary XML</h4><p>与通常的XML有等价意义，但效率更高，采用二进制表现的是Binary XML。但现在还没有Binary XML的标准规格。</p><h4 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h4><p>Protocol Buffer使用一种“数据描述语言”来定义数据结构，然后从这个定义生成一个库，将原始数据变为二进制表现（序列化）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">持久数据的重要性</span><br><span class="line">如果不是有了像纸和刻了文字的石头等经久不烂而且可以读出的媒介，将来人类文明说不定会遇到失去重要信息的危险。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-13-关于数据的持久化&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-13-关于数据的持久化&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 13 关于数据的持久化&quot;&gt;&lt;/a&gt;松本行弘的程序世界 13 关于数据的持久化&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 12 关于时间的处理</title>
    <link href="https://github.com/zdkswd/2018/07/23/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2012%20%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/23/松本行弘的程序世界 12 关于时间的处理/</id>
    <published>2018-07-23T13:53:32.000Z</published>
    <updated>2018-07-23T13:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-12-关于时间的处理"><a href="#松本行弘的程序世界-12-关于时间的处理" class="headerlink" title="松本行弘的程序世界 12 关于时间的处理"></a>松本行弘的程序世界 12 关于时间的处理</h1><h2 id="用程序处理时刻与时间"><a href="#用程序处理时刻与时间" class="headerlink" title="用程序处理时刻与时间"></a>用程序处理时刻与时间</h2><h3 id="时差与时区"><a href="#时差与时区" class="headerlink" title="时差与时区"></a>时差与时区</h3><h3 id="世界协调时间"><a href="#世界协调时间" class="headerlink" title="世界协调时间"></a>世界协调时间</h3><h3 id="夏令时"><a href="#夏令时" class="headerlink" title="夏令时"></a>夏令时</h3><p>一定时期内时钟拨快一小时。</p><h3 id="改历"><a href="#改历" class="headerlink" title="改历"></a>改历</h3><h3 id="日期与时间的类"><a href="#日期与时间的类" class="headerlink" title="日期与时间的类"></a>日期与时间的类</h3><h4 id="Time类"><a href="#Time类" class="headerlink" title="Time类"></a>Time类</h4><p>表示日常所用时间的类。</p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>表示不含时刻的日期的类。</p><h4 id="DateTime类"><a href="#DateTime类" class="headerlink" title="DateTime类"></a>DateTime类</h4><p>Date类附加上时间信息的类。能表示时间，而且没有范围限制，功能上最强。</p><h3 id="2038年问题"><a href="#2038年问题" class="headerlink" title="2038年问题"></a>2038年问题</h3><p>不仅限UNIX，很多操作系统都是以过去某个时点开始所经过的时间来表示时刻的。在UNIX中，过去某个时点指1970年1月1日零点。<br>问题是计算机能够处理的整数大小有限，界限是2038年1月19日3时14分7秒。</p><h3 id="DateTime类-1"><a href="#DateTime类-1" class="headerlink" title="DateTime类"></a>DateTime类</h3><p>相对于epoch（某个时点）开始的秒数来管理Time类，DateTime类是以日期为基础计算的Date类，附加上时刻信息而生成的。</p><h3 id="Time与DateTime的相互变换"><a href="#Time与DateTime的相互变换" class="headerlink" title="Time与DateTime的相互变换"></a>Time与DateTime的相互变换</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-12-关于时间的处理&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-12-关于时间的处理&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 12 关于时间的处理&quot;&gt;&lt;/a&gt;松本行弘的程序世界 12 关于时间的处理&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 11 程序安全性</title>
    <link href="https://github.com/zdkswd/2018/07/21/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2011%20%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>https://github.com/zdkswd/2018/07/21/松本行弘的程序世界 11 程序安全性/</id>
    <published>2018-07-21T13:28:32.000Z</published>
    <updated>2018-07-21T13:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-11-程序安全性"><a href="#松本行弘的程序世界-11-程序安全性" class="headerlink" title="松本行弘的程序世界 11 程序安全性"></a>松本行弘的程序世界 11 程序安全性</h1><h2 id="程序的漏洞与攻击方法"><a href="#程序的漏洞与攻击方法" class="headerlink" title="程序的漏洞与攻击方法"></a>程序的漏洞与攻击方法</h2><h3 id="四种软件漏洞"><a href="#四种软件漏洞" class="headerlink" title="四种软件漏洞"></a>四种软件漏洞</h3><ol><li>dos攻击</li><li>信息泄露</li><li>权限夺取</li><li>权限升格</li></ol><p>DOS攻击，即拒绝服务攻击，指妨碍软件正常运行（服务的执行）的网络攻击手段。能够引起软件异常终止的程序错误，全部都是引发DOS攻击的安全性程序错误。<br>分为软件漏洞与外部DOS攻击。<br>信息泄露指不愿公开的信息被公开了。</p><h3 id="因权限被窃取而成为重大问题"><a href="#因权限被窃取而成为重大问题" class="headerlink" title="因权限被窃取而成为重大问题"></a>因权限被窃取而成为重大问题</h3><h3 id="安全问题的根源"><a href="#安全问题的根源" class="headerlink" title="安全问题的根源"></a>安全问题的根源</h3><p>在于运行软件的人（权限所有者）和利用软件的人是不同的。<br>安全问题有三种</p><ol><li>恶意软件<br>指在程序本身植入了恶意代码。</li><li>setuid/setgid<br>指执行的程序以所有者权限进行动作。setuid的缺点已经变得比优点更突出，现在几乎不用了。</li><li>服务器</li></ol><h3 id="“守护神”引起的问题"><a href="#“守护神”引起的问题" class="headerlink" title="“守护神”引起的问题"></a>“守护神”引起的问题</h3><p>服务这里指的是为了提供服务而常驻型的软件，又为后台服务(daemon),即守护神的意思。<br>后台服务基本上都是受理经由socket而来的请求。执行它所提供的服务，将结果经socket返回。几乎所有的情况，发出请求者和执行权限者都是不同的。这种软件若有了漏洞，会引起DOS问题和权限夺取问题。</p><h3 id="多样化的攻击手段"><a href="#多样化的攻击手段" class="headerlink" title="多样化的攻击手段"></a>多样化的攻击手段</h3><p>代表性的有：</p><ol><li>缓冲区溢出</li><li>整数溢出</li><li>跨站点脚本攻击（XSS）</li><li>SQL注入</li><li>跨站点伪造请求（CSRF）</li></ol><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>指向固定的缓冲区输入了比假定长度要长很多的数据，使程序异常终止。或者是更改堆栈的跳转地址劫持程序。<br>使用C那种连数组长度都不检查的语言，可以说肯定会产生问题。幸亏，像Ruby这样的高级语言，语言处理系统自动分配内存，可以不使用固定长的缓冲区。使用更高级的语言，可以从缓冲区溢出问题中解放出来。但由于速度上的考虑，还会开发C语言的CGI及Daemon程序，应多加注意。</p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>整数溢出与缓冲区溢出相似，但它是更难被发现的问题。<br>c等很多语言，整数只能表示一定范围的数，超过范围，就会发生溢出，也不发出警告就将数值舍入。这个问题通过使用Ruby这样的高级语言可以解决，内存分配不是由用户直接进行，内部分配都要经过严格检查。所以，只要使用Ruby，与整数溢出就不沾边。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是对外部的输入检查不充分时所产生的典型问题。<br>从外部的输入不能原封不动填到SQL语句中去，因为填入的文字可能含有对SQL语句有某种意义的文字。</p><h3 id="Shell注入"><a href="#Shell注入" class="headerlink" title="Shell注入"></a>Shell注入</h3><p>Shell注入与SQL注入原理相同。<br>从外部的输入，如果不进行检查就不能传递给system等危险的函数。<br>为了从一定程度上检查出这类问题，Ruby和Perl中有“污染检查”功能。给外部输入的数据加上“污染记号”，禁止对字符串进行危险操作。</p><h3 id="跨站点脚本攻击"><a href="#跨站点脚本攻击" class="headerlink" title="跨站点脚本攻击"></a>跨站点脚本攻击</h3><p>跨站点脚本攻击与SQL注入和Shell注入一样，也是因为将输入值原封不动地放在输出值内而引起的问题。<br>如用户输入中含有HTML标签。而且HTML可能夹杂JavaScript。</p><h3 id="跨站点伪造请求"><a href="#跨站点伪造请求" class="headerlink" title="跨站点伪造请求"></a>跨站点伪造请求</h3><p>跨站点伪造请求（CSRF）是Web应用程序固有的攻击手段。<br>构成Web应用程序的每一页由两部分构成，一个来自网路浏览器的HTTP请求，一个是HTTP服务器的响应。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.11.22.png" alt="屏幕快照 2018-07-21 下午7.11.22" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.11.22</div>            </figure></p><h3 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h3><h2 id="用异常进行错误处理"><a href="#用异常进行错误处理" class="headerlink" title="用异常进行错误处理"></a>用异常进行错误处理</h2><h3 id="异常的历史"><a href="#异常的历史" class="headerlink" title="异常的历史"></a>异常的历史</h3><h3 id="Java的受控异常"><a href="#Java的受控异常" class="headerlink" title="Java的受控异常"></a>Java的受控异常</h3><p>采用受控异常的，Java是第一个。</p><h3 id="Icon的面向目标判断"><a href="#Icon的面向目标判断" class="headerlink" title="Icon的面向目标判断"></a>Icon的面向目标判断</h3><p>Ruby在设计之初，也曾认真考虑过采用像Icon式的真伪值判断，结果还是采用了nil和false以外的值全是真值的这种正统方式。</p><h3 id="Ruby的异常"><a href="#Ruby的异常" class="headerlink" title="Ruby的异常"></a>Ruby的异常</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.30.12.png" alt="屏幕快照 2018-07-21 下午7.30.12" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.30.12</div>            </figure><h3 id="异常发生"><a href="#异常发生" class="headerlink" title="异常发生"></a>异常发生</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15320811324762/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-21%20%E4%B8%8B%E5%8D%887.33.32.png" alt="屏幕快照 2018-07-21 下午7.33.32" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-21 下午7.33.32</div>            </figure><h3 id="异常处理的设计方针"><a href="#异常处理的设计方针" class="headerlink" title="异常处理的设计方针"></a>异常处理的设计方针</h3><p>方法的执行应当“异常安全”，即执行时及时发生了异常也不会发生异常情况：</p><ul><li>因为发生了异常，留下了不完全的数据结构</li><li>因为发生了异常，数据库里进了垃圾</li><li>因为发生了异常，程序异常终止</li></ul><h3 id="异常发生的设计原则"><a href="#异常发生的设计原则" class="headerlink" title="异常发生的设计原则"></a>异常发生的设计原则</h3><p>假设发生的情况与既有的异常类明显不同，需要制作一个新的异常。此时考虑：</p><ul><li>名称：应该给新的类起一个什么样的名字</li><li>父类：新的类应该属于哪一个异常类的子类</li><li>生成方法：应该如何初始化新的类实例</li></ul><p>产生异常的两个原则：1异步异常，基本原则是不要使用异步异常。2.文档化，有必要清楚详细的写成文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-11-程序安全性&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-11-程序安全性&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 11 程序安全性&quot;&gt;&lt;/a&gt;松本行弘的程序世界 11 程序安全性&lt;/h1&gt;&lt;h2 id=&quot;程
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 10 高速执行和并行处理</title>
    <link href="https://github.com/zdkswd/2018/07/20/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%2010%20%E9%AB%98%E9%80%9F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/</id>
    <published>2018-07-20T09:58:32.000Z</published>
    <updated>2018-07-20T10:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-10-高速执行和并行处理"><a href="#松本行弘的程序世界-10-高速执行和并行处理" class="headerlink" title="松本行弘的程序世界 10 高速执行和并行处理"></a>松本行弘的程序世界 10 高速执行和并行处理</h1><h2 id="让程序高速执行（前篇）"><a href="#让程序高速执行（前篇）" class="headerlink" title="让程序高速执行（前篇）"></a>让程序高速执行（前篇）</h2><h3 id="是不是越快越好"><a href="#是不是越快越好" class="headerlink" title="是不是越快越好"></a>是不是越快越好</h3><p>并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。</p><h3 id="高速执行的乐趣与效率"><a href="#高速执行的乐趣与效率" class="headerlink" title="高速执行的乐趣与效率"></a>高速执行的乐趣与效率</h3><p>在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。</p><h3 id="以数据为基础做出判断"><a href="#以数据为基础做出判断" class="headerlink" title="以数据为基础做出判断"></a>以数据为基础做出判断</h3><h3 id="改善系统调用"><a href="#改善系统调用" class="headerlink" title="改善系统调用"></a>改善系统调用</h3><p>排序处理任务重时，典型的对策是使用施瓦茨变换。</p><h3 id="数据可靠吗"><a href="#数据可靠吗" class="headerlink" title="数据可靠吗"></a>数据可靠吗</h3><p>误差</p><h3 id="只需改善瓶颈"><a href="#只需改善瓶颈" class="headerlink" title="只需改善瓶颈"></a>只需改善瓶颈</h3><p>性能优化中，“因为是排序，所以就用施瓦茨变换”这种条件反射式的对策并非总管用。为了合理提高速度，确立恰当的策略是很必要的。<br>帕累托法则又称80/20法则，即80%的数值是由20%的构成要素产生的。由帕累托法则可知，有20%的努力可以达到巨大回报，而有80%的努力得不到多少回报。在得不到回报的地方，不管怎么努力都是徒劳的。<br>Donald Knuth也提到，通常一半以上的执行时间都耗费在程序中不到4%的部分。<br>这些耗费了大半以上执行时间的部分称为瓶颈。<br>判定瓶颈，可以用profiler这一工具。</p><h3 id="profiler本身成了累赘"><a href="#profiler本身成了累赘" class="headerlink" title="profiler本身成了累赘"></a>profiler本身成了累赘</h3><p>不确定性原理是指测定行为本身对被测对象产生了影响，从原理上可以说不可能正确知道对象的状态。但是知道实际状态的大体倾向。</p><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>选择合适的算法，这是性能改善的第一考虑因素，要记住这条铁则。</p><h3 id="理解O记法"><a href="#理解O记法" class="headerlink" title="理解O记法"></a>理解O记法</h3><p>如何从效率方面判定一个算法的好坏呢。一个方法就是O记法，表示某种算法对于变量（比如使用的元素个数）如何变化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8A%E5%8D%8811.05.39.png" alt="屏幕快照 2018-07-20 上午11.05.39" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 上午11.05.39</div>            </figure></p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><h3 id="调查算法的性能"><a href="#调查算法的性能" class="headerlink" title="调查算法的性能"></a>调查算法的性能</h3><p>Ruby提供进行算法性能比较时用的benchmark程序。</p><h3 id="高速执行的悲哀"><a href="#高速执行的悲哀" class="headerlink" title="高速执行的悲哀"></a>高速执行的悲哀</h3><h4 id="徒劳无益的努力"><a href="#徒劳无益的努力" class="headerlink" title="徒劳无益的努力"></a>徒劳无益的努力</h4><p>很容易在瓶颈无关的地方花费太多徒劳无益的努力。</p><h4 id="改良绊住了手脚"><a href="#改良绊住了手脚" class="headerlink" title="改良绊住了手脚"></a>改良绊住了手脚</h4><p>sort_by所依据的施瓦茨变换，是用时间和空间的交换来消减计算量的方法。sort_by方法与sort方法相比，占用了多达三倍以上的内存。所以，模块内的处理本来不是很重，如果一味地占用内存反而可能会变慢。<br>性能优化，光有理论还不行，如果不实际做的话就不知道到底什么是正确的。</p><h4 id="算法选择的圈套"><a href="#算法选择的圈套" class="headerlink" title="算法选择的圈套"></a>算法选择的圈套</h4><p>在进行性能优化时，不改变原来程序的执行时一个大原则。</p><h3 id="性能优化的格言"><a href="#性能优化的格言" class="headerlink" title="性能优化的格言"></a>性能优化的格言</h3><p><strong>过早的优化是万恶之源。</strong></p><p><strong>优化有两条准则。</strong><br><strong>1.别做优化</strong><br><strong>2.（仅适用于专家）先不要做优化</strong></p><hr><p><strong>过早的优化是万恶之源</strong><br>代码优化的好处多多，但是这并不意味着所有的代码都需要进行优化，有时过度的优化反而适得其反——费时、费力、不讨好。<br>“现代计算机科学的鼻祖”Donald Knuth曾说过“过早的优化是万恶之源”，因为：让正确的程序更快，要比让快速的程序正确容易得多。<br>在项目开发中，总是有程序员浪费宝贵的时间去改进那些不需要改进的代码，而没有通过所做的改进增加价值。在对项目进行优化时，究竟哪些地方应该优化，应该如何优化，哪些不应该优化呢？你需要先来了解一下本文所说的这7件事。<br>1.究竟要优化什么？<br>在优化工作开始的时候，你还尚未明确优化内容和目的，那么你很容易陷入误区。在一开始，你就应该清楚地了解你要达到的效果，以及其他优化相关的各种问题。这些目标需要明确指出（至少精通技术的项目经理可以理解和表达它），接下来，在整个优化过程中，你需要坚持这些目标。<br>在实际的项目开发中，经常会存在各种各样的变数。可能一开始时要优化这一方面，随后你可能会发现需要优化另一方面。这种情况下，你需要清晰地了解这些变化，并确保团队中的每个人都明白目标已经发生了变化。<br>2.选择一个正确的优化指标<br>选择正确的指标，是优化的一个重要组成部分，你需要按照这些指标来测量优化工作的进展情况。如果指标选择不恰当，或者完全错误，你所做的努力有可能白费了。<br>即使指标正确，也必须有一些辨别。在某些情况下，将最多的努力投入到运行消耗时间最多的那部分代码中，这是实用的策略。但也要记住，Unix/Linux内核的大部分时间花费在了空循环上。<br>需要注意的是，如果你轻易选择了一个很容易达到的指标，这作用不大，因为没有真正解决问题。你有必要选择一个更复杂的、更接近你的目标的指标。<br>3.优化在刀刃上<br>这是有效优化的关键。找到项目中与你的目标（性能、资源或其他）相背的地方，并将你的努力和时间用在那里。<br>举一个典型的例子，一个Web项目速度比较慢，开发者在优化时将大部分精力放在了数据库优化上，最终发现真正的问题是网络连接慢。<br>另外，不要分心于容易实现的问题。这些问题尽管很容易解决，但可能不是必要的，或与你的目标不相符。容易优化并不意味着值得你花费工夫。<br>4.优化层次越高越好<br>在一般情况下，优化的层次越高，就会越有效。根据这个标准，最好的优化是找到一个更有效的算法。<br>举个例子，在一个软件开发项目中，有一个重要的应用程序性能较差，于是开发团队开始着手优化，但性能并没有提升太多，之后，项目人员交替，新的开发人员在检查代码时发现，性能问题的核心是由于在表中使用了冒泡排序算法，导致成千上万项的增加。<br>尽管如此，高层次的优化也不是“银弹”。一些基本技术，如将所有东西移到循环语句外，也可以产生一些优化的效果。通常情况下，大量低层次的优化可以产生等同于一个高层次优化的效果。<br>还需要注意的是，高层次优化，会减少一些代码块，那么你之前对这些代码块所做的优化就没有任何意义了，因此，刚开始就应该考虑高层次的优化。<br>5.不要过早优化<br>在项目早期就进行优化，会导致你的代码难以阅读，或者会影响运行。另一方面，在项目后期，你可能会发现之前所做的优化没有起到任何作用，白白浪费了时间和精力。<br>正确的方式是，你应该将项目开发和优化当作两个独立的步骤来做。<br>6.依赖性能分析，而不是直觉<br>你往往会认为你已经知道哪里需要优化，这是不可取的，尤其是在复杂的软件系统中，性能分析数据应该是第一位的，最后才是直觉。<br>优化的一个有效的策略是，你要根据所做工作对优化效果的影响来进行排序。在开始工作之前找到影响最大的“路障”，然后再处理小的“路障”。<br>7.优化不是万金油<br>优化最重要的规则之一是，你无法优化一切，甚至无法同时优化两个问题。比如，优化了速度，可能会增加资源利用；优化了存储的利用率，可能会使其他地方放慢。你需要权衡一下，哪个更符合你的优化目标。</p><hr><h2 id="让程序高速执行（后篇）"><a href="#让程序高速执行（后篇）" class="headerlink" title="让程序高速执行（后篇）"></a>让程序高速执行（后篇）</h2><p>例题是曼德勃罗集合的计算程序，指复平面上满足以下条件的复素数的集合：经过某种反复迭代运算以后，其值不会发散到无限大。</p><h3 id="确认程序概要"><a href="#确认程序概要" class="headerlink" title="确认程序概要"></a>确认程序概要</h3><h3 id="发现瓶颈"><a href="#发现瓶颈" class="headerlink" title="发现瓶颈"></a>发现瓶颈</h3><p>使用profiler</p><h3 id="使用更好地profiler"><a href="#使用更好地profiler" class="headerlink" title="使用更好地profiler"></a>使用更好地profiler</h3><p>ruby-prof程序通过使用扩展库可以实现高速profile</p><h3 id="高速优化之一：消减对象"><a href="#高速优化之一：消减对象" class="headerlink" title="高速优化之一：消减对象"></a>高速优化之一：消减对象</h3><p>Ruby高速优化的规则。</p><h4 id="减少对象"><a href="#减少对象" class="headerlink" title="减少对象"></a>减少对象</h4><p>高级面向对象语言中对象的生成要花费一定的时间，减少对象，除了会降低生成成本外，还有别的好处。<br>Ruby中不在使用的对象，由被称作垃圾收集的处理自动进行回收。垃圾收集处理需要检查对象的引用关系，任何地方都不再引用的对象会被判定为已经不再使用了。当对象的数量很多时，判断成本就要增大。</p><h4 id="减少方法调用"><a href="#减少方法调用" class="headerlink" title="减少方法调用"></a>减少方法调用</h4><p>方法调用中，存在多态性这一面向对象的本质特征，先要评价参数，判定对象种类，然后选出一个合适的方法，再讲控制交给该方法，这是一个缓慢的处理过程。<br>为了避开方法调用，尽可能不用Ruby中实现的方法。Ruby中实现的方法，几乎所有的情况都是调用其他方法来实现的。也就是说，只要使用了一次Ruby中实现的方法，就会有多余的方法调用发生。</p><h3 id="高速优化之二：利用立即值"><a href="#高速优化之二：利用立即值" class="headerlink" title="高速优化之二：利用立即值"></a>高速优化之二：利用立即值</h3><p>Ruby中有几类对象并不实际分配内存，而是用引用本身来表示，这种值称为立即值。<br>现在的Ruby中，小的整数（±2    ^30以内）、真假值、nil和符号名等都是立即值。<br>立即值既然不生成对象，就不用担心对象的生成成本，而且也不用垃圾收集处理，所以它具有特别理想的特性。</p><h3 id="高速优化之三：利用C语言"><a href="#高速优化之三：利用C语言" class="headerlink" title="高速优化之三：利用C语言"></a>高速优化之三：利用C语言</h3><p>Ruby是解释性语言，单纯计算的循环不是很快。如果将处理交给编译器，就可以变得很快。</p><h3 id="高速优化之四：采用合适的数据结构"><a href="#高速优化之四：采用合适的数据结构" class="headerlink" title="高速优化之四：采用合适的数据结构"></a>高速优化之四：采用合适的数据结构</h3><h3 id="全部以C语言计算"><a href="#全部以C语言计算" class="headerlink" title="全部以C语言计算"></a>全部以C语言计算</h3><h3 id="还存在其他技巧"><a href="#还存在其他技巧" class="headerlink" title="还存在其他技巧"></a>还存在其他技巧</h3><p>还有以空间换时间。</p><h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><p>与进程不同，同一进程的线程可以共享内存空间，所以，不同的线程能够引用同一对象。不需要经过将数据变为字节流再进行通信这样麻烦的处理，就能交换信息。</p><h3 id="生成线程"><a href="#生成线程" class="headerlink" title="生成线程"></a>生成线程</h3><h3 id="线程的执行状态"><a href="#线程的执行状态" class="headerlink" title="线程的执行状态"></a>线程的执行状态</h3><p>Ruby的线程有四种状态。<br>run：执行中<br>stop：停止中<br>to_kill:终止处理中<br>killed:终止<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%881.55.11.png" alt="屏幕快照 2018-07-20 下午1.55.11" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午1.55.11</div>            </figure></p><h3 id="传递值给线程的方法"><a href="#传递值给线程的方法" class="headerlink" title="传递值给线程的方法"></a>传递值给线程的方法</h3><h3 id="信息共享所产生的问题"><a href="#信息共享所产生的问题" class="headerlink" title="信息共享所产生的问题"></a>信息共享所产生的问题</h3><ol><li>数据完整性丧失</li><li>死锁</li></ol><p><strong>与其说是线程的问题，不如说是并行处理本身的问题。</strong></p><h3 id="数据完整性的丧失"><a href="#数据完整性的丧失" class="headerlink" title="数据完整性的丧失"></a>数据完整性的丧失</h3><p>原子操作</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>哲学家进餐问题</p><h3 id="用锁来实现对资源的独占"><a href="#用锁来实现对资源的独占" class="headerlink" title="用锁来实现对资源的独占"></a>用锁来实现对资源的独占</h3><p>Ruby Mutex类，互斥锁。<br>Java中，方法定义声明为synchronize,该方法被调用时自动加锁。</p><h3 id="二级互斥"><a href="#二级互斥" class="headerlink" title="二级互斥"></a>二级互斥</h3><p>很遗憾，锁的问题并不全是Mutex所能覆盖的单纯事例。如数据库中，对数据的访问需要以下多种互斥控制。</p><ol><li>可以同时引用</li><li>禁止同时更新</li><li>禁止更新中引用</li><li>禁止引用中更新</li></ol><p>引用与更新这种两个层次的互斥（二级互斥），在文件读取时也经常会发生。</p><hr><p><strong>数据库锁总结</strong></p><p>数据库锁出现的原因是为了处理并发问题，因为数据库是一个多用户共享的资源，当出现并发的时候，就会导致出现各种各样奇怪的问题，就像程序代码一样，出现多线程并发的时候，如果不做特殊控制的话，就会出现意外的事情，比如“脏“数据、修改丢失等问题。所以数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制，所以数据库锁是跟并发控制和事务联系在一起的。</p><p>平时会经常看到或者听到数据库锁有“共享锁”，“排它锁”，“互斥锁”，“写锁”，“读锁”，“悲观锁”，“乐观锁”，“行级锁”，“表级锁”，“页级锁”等，同时我们还会常看到“丢失修改“，”不可重复读“，”读脏数据“这三个术语，他们究竟是什么关系以及怎么理解呢，下面就来介绍一下他们。</p><p>先说事务的特性，要想成为事务，必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；一致性指的是事务的执行结果必须是使数据库从一个一致性状态变大另一个一致性状态，一致性和原子性是密切相关的；隔离性指的是一个事务执行不能被其他事务干扰；持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。</p><p>先说悲观锁和乐观锁吧。并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。乐观锁就比较简单了，就是不做控制，这只是一部分人对于并发所持有的一种态度而已。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁和共享锁，其中排它锁又称为写锁，共享锁又称为读锁。</p><p>共享锁和排它锁是具体的锁，是数据库机制上的锁，存在以下关系：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%882.17.40.png" alt="屏幕快照 2018-07-20 下午2.17.40" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午2.17.40</div>            </figure></p><p>(x表示是排它锁(Exclusive)，s表示共享锁(Share)，Y表示yes，N表示no）</p><p>上图表示可以共存的锁，如，第二行表示，一个事务T1给某数据加了X锁，则事务T2就不能再给那数据加X锁了，同时也不能再加S锁了，只有到T1事务提交完成之后，才可以。默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁。<br>另外，并发操作会导致数据的不一致性，主要包括“丢失数据”，“不可重复读”，“读脏数据等。还有就是，并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防，预防的方法有：1一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；2顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。另外，系统如何判断出现死锁呢，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁，诊断和判断死锁有两种方法，一是超时法，二是等待图法。超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。</p><p>最后，说下行级锁和表级锁。锁包括行级锁和表级锁<br>行级锁是一种排他锁，防止其他事务修改此行。</p><hr><h3 id="用队列协调线程"><a href="#用队列协调线程" class="headerlink" title="用队列协调线程"></a>用队列协调线程</h3><p>使用锁对资源进行互斥控制，是线程间保证协调的一种机制。除了锁以外，为了保证协调，还有别的方法。<br>问题的根源在于多个进程访问同一资源，为了实现无共享，给每个资源准备一个管理用的线程，各线程间只能交换某些限定的信息。<br>线程间信息交换的方法有代表性的有信息存储，信道及队列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.05.36.png" alt="屏幕快照 2018-07-20 下午3.05.36" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.05.36</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的生产者消费者问题并不是典型的生成者消费者问题，而是做出了一定的限制，即生产速度小于消费速度。不锁buffer,仅做信息传递的通道来进行说明。</span><br></pre></td></tr></table></figure><p>队列也可以用于解决资源的竞争。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15319061395029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%883.08.13.png" alt="屏幕快照 2018-07-20 下午3.08.13" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-20 下午3.08.13</div>            </figure></p><h3 id="锁模型与队列模型的比较"><a href="#锁模型与队列模型的比较" class="headerlink" title="锁模型与队列模型的比较"></a>锁模型与队列模型的比较</h3><h4 id="锁模型"><a href="#锁模型" class="headerlink" title="锁模型"></a>锁模型</h4><p>如果竞争足够少，多数情况下能保持较高性能，对于资源的竞争，不能忘记加锁，要做到完美无缺较难。</p><h4 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h4><p>在竞争少的时候，其性能比不上锁模型，比锁模型更容易贯彻，会因线程增多而带来性能低下的恶果。</p><h2 id="前景可期的并行编程技术，Actor"><a href="#前景可期的并行编程技术，Actor" class="headerlink" title="前景可期的并行编程技术，Actor"></a>前景可期的并行编程技术，Actor</h2><p>并行编程，要求有更高的抽象度和对人类而言更简单的编程模型。Actor（参与者模式）或许就是答案。</p><h3 id="何谓Actor"><a href="#何谓Actor" class="headerlink" title="何谓Actor"></a>何谓Actor</h3><p>所谓Actor，是（仅）通过消息（message）进行通信的实体。<br>与面向对象语言中对象的区别。向对象发送消息（方法调用），调用开始后，会一直等到返回结果，是一种同步方式。面向Actor发送消息，仅仅是发送消息而不返回结果，是一种异步方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步(Synchronous)和异步(Asynchronous)</span><br><span class="line">1.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</span><br><span class="line">2.异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。</span><br></pre></td></tr></table></figure></p><p>Actor由于仅仅通过消息进行信息交换，所以不能直接共享同一个值，信息传达要多花些代价。<br>Actor由于没有消息以外的信息传递手段，所以不用担心Actor之间的资源竞争。发送给Actor的消息都配送到各个Actor所拥有的邮箱里。多个消息同时到达时竞争由内嵌到系统中的排除机制来处理。<br>Actor的一大优点是安全，更大的优点是易懂。Actor根据消息进行处理，必要的化会向其他Actor传递消息，或向Actor返回消息。<br>这与现实世界中人与人之间相处没有多大的差别。现实世界中，别人在想什么你不知道，想要求什么时，需要通过某种手段传递“消息”。<br>理论上要到达最高性能，一般认为线程更优秀。但如果不注意使用线程的话，会出现与时机相关的很麻烦的问题。在计算机性能日益提高的今天，与理论上最高性能的可能性相比，Actor的安全性和易懂性更引人注目。</p><h3 id="操作Actor的三种处理系统"><a href="#操作Actor的三种处理系统" class="headerlink" title="操作Actor的三种处理系统"></a>操作Actor的三种处理系统</h3><p>Actor Model的函数型语言Erlang。<br>Erlang是只允许单一赋值的函数型语言，即一旦赋值，变量的值就不再改变。</p><h3 id="Erlang的程序"><a href="#Erlang的程序" class="headerlink" title="Erlang的程序"></a>Erlang的程序</h3><h3 id="pingpong处理的开始"><a href="#pingpong处理的开始" class="headerlink" title="pingpong处理的开始"></a>pingpong处理的开始</h3><h3 id="启动pingpong程序"><a href="#启动pingpong程序" class="headerlink" title="启动pingpong程序"></a>启动pingpong程序</h3><h3 id="Erlang的错误处理"><a href="#Erlang的错误处理" class="headerlink" title="Erlang的错误处理"></a>Erlang的错误处理</h3><p>Erlang中通过发送消息来通知异常终止。收到消息的process（actor）料理死去的process后事。<br>有了这种机制，使得Erlang适合构造抗障碍性强的系统。</p><h3 id="Erlang的使用场所"><a href="#Erlang的使用场所" class="headerlink" title="Erlang的使用场所"></a>Erlang的使用场所</h3><p>Erlang在通常的文本处理汇总并不怎么快。Erlang的好处在于其扩展性。对于多个处理并列执行的情况，分割成合适的Erlang process，能够发挥多CPU的威力。<br>同样的多任务分割虽然用操作系统的进程或线程也能实现，但Erlang的process与操作系统的进程或线程相比，能够轻量实现（1个process最小只耗费300字节），即使有大量process也不必顾虑、更进一步说，Erlang设计思想不用process连基本处理都不能实现，process分割在某种意义上可以说是强制的。</p><p>适合现代服务器端程序。</p><h3 id="面向Ruby的库“Revactor”"><a href="#面向Ruby的库“Revactor”" class="headerlink" title="面向Ruby的库“Revactor”"></a>面向Ruby的库“Revactor”</h3><p>Revactor的目的是为Ruby提供Erlang式的编程。<br>其优点是可以同时体验Ruby和Erlang的好处。但是Revactor中Actor的实现不是靠线程而是靠Fiber。Erlang的目的在于最大限度地利用多核CPU，而Revactor并不适合这种目的。<br>Revactor的最大优点，是能够在等待文件输入输出时，将程序的停止控制在最小程度。</p><h3 id="另一个库Dramatis"><a href="#另一个库Dramatis" class="headerlink" title="另一个库Dramatis"></a>另一个库Dramatis</h3><p>Dramatis是Ruby中另一个Actor库。函数型语言Erlang不支持面向对象功能。用Ruby这样的面向对象语言来实现Actor的时候，即使用普通对象来实现Actor，也不可避免地会出现把方法调用和发送消息这两种类似概念混在一起的情况。Dramatis库就是解答这种“概念混淆”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-10-高速执行和并行处理&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-10-高速执行和并行处理&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 10 高速执行和并行处理&quot;&gt;&lt;/a&gt;松本行弘的程序世界 10 高速执行和并行
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 3 Android控件架构与自定义控件详解</title>
    <link href="https://github.com/zdkswd/2018/07/18/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%203%20Android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/zdkswd/2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/</id>
    <published>2018-07-18T07:27:32.000Z</published>
    <updated>2018-07-18T09:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-3-Android控件架构与自定义控件详解"><a href="#Android群英传-3-Android控件架构与自定义控件详解" class="headerlink" title="Android群英传 3 Android控件架构与自定义控件详解"></a>Android群英传 3 Android控件架构与自定义控件详解</h1><h2 id="Android控件架构"><a href="#Android控件架构" class="headerlink" title="Android控件架构"></a>Android控件架构</h2><p>控件大致被分为两类，即ViewGroup控件与View控件。<br>通过ViewGroup，整个界面的控件形成了一个树形结构控件树。上层控件负责下层子控件的测量与绘制，并传递交互事件。findViewById（）方法，就是在控件树以数<strong>深度优先</strong>来遍历查找对应的元素。<br>每颗控件树的顶部，都有一个ViewParent对象，为整棵树的控制核心，所有的交互管理事件都由它统一调度和分配，从而可以对整个视图进行整体控制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.31.03.png" alt="屏幕快照 2018-07-17 下午2.31.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.31.03</div>            </figure><br>通常，在Activity中使用setContentView（）方法来设置一个布局，在调用该方法后，布局内容才真正的显示出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.36.21.png" alt="屏幕快照 2018-07-17 下午2.36.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.36.21</div>            </figure><br>每个Activity都包含一个Window对象，由PhoneWindow来实现。PhoneWindow将一个DecorView设置为整个应用窗口的根View。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通用方法。DecorView将要显示的具体方法呈现在PhoneWindow上，这里面的所有View的监听事件通过<strong>WindowManageService</strong>来进行验收，并通过Activity对象来回调相应的onClickListener。<br>在显示上，它将屏幕分为两部分，TitleView和ContentView。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%882.45.14.png" alt="屏幕快照 2018-07-17 下午2.45.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午2.45.14</div>            </figure><br>其中ViewGroup会根据对应参数设置不同的布局，如最常用的布局。而如果用户通过设置requestWindowFeature(Window.FEATURE_NO_TITLE)来设置全屏显示，视图树中的布局就只有Content了，这就解释了为什么调用requestWindowFeature()方法一定要在调用setContentView()方法之前才能生效的原因。<br>在代码中，当程序在onCreate（）方法中调用setContentView（）方法后，ActivityManagerService会回调onResume（）方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。</p><h2 id="View的测量"><a href="#View的测量" class="headerlink" title="View的测量"></a>View的测量</h2><p>系统在绘制View前，必须对View进行测量，即告诉系统该画一个多大的View，在onMeasure（）方法中进行。<br>通过系统提供的设计精悍功能强大的类<strong>MeasureSpec</strong>类来测量View。MeasureSpec为32位int值，高2位位测量的模式，低30位为测量的大小，在计算中使用位运算是为了提高并优化效率。<br>测量模式为3种：</p><ol><li>EXACTLY<br>即精确值模式，当我们将控件的layout_width或layout_height属性指定为具体数值时，或指定为match_parent属性时（占据父View的大小），系统使用的是EXACTLY模式。</li><li>AT_MOST<br>即最大值模式，当控件的layout_width或layout_height属性指定为wrap_content时，控件大小一般岁总监的子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。</li><li>UNSPECIFID<br>不指定大小测量模式，View想多大就多大，通常情况下在绘制自定义View时才会使用。</li></ol><p>View类默认的onMeasure（）方法只支持EXACTLY模式，所以如果自定义控件时不重写onMeasure方法的话，就只能使用EXACTLY模式。控件可以响应你指定的具体宽高值或是match_parent属性。而如果要让自定义View支持<strong>wrap_content</strong>属性，那么就必须重写onMeasure（）方法来指定wrap_content时的大小，如果不重写，就不知道该使用默认多大的尺寸，因此，就会默认填充整个父布局，所以重写onMeasure（）方法的目的，就是为了能够给View一个wrap_content属性下的默认大小。</p><h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>测量好一个View后，我们就可以重写onDraw（）方法，在Canvas对象上来绘制所需要的图形。<br>当创建一个Canvas对象时，需要传进去一个bitmap对象。这个bitmap用来存储所有绘制在Canvas上的像素信息。调用所有的Canvas.drawXXX方法都发生在这个bitmap上。</p><p>##ViewGroup的测量<br>ViewGroup会去管理子View，就有负责子View的显示大小。当ViewGroup大小为wrap_content时，就需要对子View进行遍历，以获得所有子View的大小，从而决定自己的大小。其他模式则会通过具体的指定值来设置自身的大小。<br>ViewGroup在测量时通过遍历所有的子View，从而调用View的Measure方法来获得每一个子View的测量结果。<br>当子View测量完毕时，就需要将子View放到合适的位置，这个过程就是View的Layout过程。ViewGroup在执行Layout过程时，同样是使用遍历来调用子View的Layout方法，并制定其具体显示的位置从而来决定其布局位置。<br>在定义ViewGroup时，通常会重写onLayout方法来控制其子View显示位置的逻辑。同样，如果要支持wrap_content属性，必须重写onMeasure。</p><h2 id="ViewGroup的绘制"><a href="#ViewGroup的绘制" class="headerlink" title="ViewGroup的绘制"></a>ViewGroup的绘制</h2><p>ViewGroup通常不需要绘制，如果不是指定了ViewGroup的背景颜色，ViewGroup的onDraw方法都不会被调用，但是，ViewGroup会使用dispatchDraw()方法来绘制其子View，其过程同样是通过遍历所有的子View，并调用子View绘制方法来完成绘制。</p><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><p>在自定义View时，我们通常会去重写onDraw()来绘制View的显示内容，如果该View还需要使用wrap_content属性，那么还必须重写onMeasure()方法。另外，通过自定义attrs属性，还可以设置新的属性配置值。<br>在View中通常有以下一些比较重要的回调方法。</p><ul><li>onFinishInflate():从XML加载组件后回调。</li><li>onSizeChanged():组件大小改变时回调。</li><li>onMeasure():回调该方法来进行测量。</li><li>onLayout():回调该方法来确定显示的位置。</li><li>onTouchEvent():监听到触摸事件时回调。</li></ul><p>通常有以下方法来实现自定义的控件。</p><ul><li>对现有控件进行扩展。 </li><li>通过组合来实现新的控件。</li><li>重写View来实现全新的控件。 </li></ul><h3 id="对现有控件进行扩展"><a href="#对现有控件进行扩展" class="headerlink" title="对现有控件进行扩展"></a>对现有控件进行扩展</h3><p>可以再onDraw()方法中对原生控件行为进行扩展。<br>程序调用super.onDraw(canvas)方法来实现原生控件的功能。</p><h3 id="创建复合控件"><a href="#创建复合控件" class="headerlink" title="创建复合控件"></a>创建复合控件</h3><p>创建复合控件可以很好地创建出具有重用功能的控件集合。这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，再给它添加指定功能的控件，从而组合成新的复合控件。通过这种方式创建的控件，我们一般会给它指定一些可配置的属性，让它具有更强的扩展性。</p><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><p>为一个View提供可自定义的属性非常简单，只需要在res资源目录的values目录下创建一个attrs.xml的属性定义文件，并在该文件中通过代码定义相应的属性即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.04.48.png" alt="屏幕快照 2018-07-17 下午5.04.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.04.48</div>            </figure></p><p>在代码中通过&lt; declare-styleable&gt;标签声明了使用自定义属性，通过name属性来确定引用的名称。通过&lt; attr&gt;标签来声明具体的自定义属性。通过format属性来指定属性的类型。<br>在确定好属性后，就可以创建一个自定义控件，让它继承自ViewGroup，从而组合一些需要的控件。在构造方法中，通过TypedArray对象的getString()和getColor()等方法，就可以获取这些定义的属性值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.11.26.png" alt="屏幕快照 2018-07-17 下午5.11.26" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.11.26</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.12.42.png" alt="屏幕快照 2018-07-17 下午5.12.42" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.12.42</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.13.03.png" alt="屏幕快照 2018-07-17 下午5.13.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.13.03</div>            </figure><p>当获取完所有的属性值后，需要调用TypedArray的recyle方法来完成资源的回收。</p><h4 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h4><p>通过动态添加控件的方式，使用addView（）方法将控件加入到模板中，并给它们设置前面所获取到的具体的属性值，如文字颜色、大小等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.16.29.png" alt="屏幕快照 2018-07-17 下午5.16.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.16.29</div>            </figure></p><p>定义接口<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.21.03.png" alt="屏幕快照 2018-07-17 下午5.21.03" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.21.03</div>            </figure></p><p>暴露接口给调用者<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.25.21.png" alt="屏幕快照 2018-07-17 下午5.25.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.25.21</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.25.46.png" alt="屏幕快照 2018-07-17 下午5.25.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.25.46</div>            </figure><p>实现接口回调<br>在调用者的代码中，调用者需要实现这样一个接口，并完成接口中的方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.28.58.png" alt="屏幕快照 2018-07-17 下午5.28.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.28.58</div>            </figure></p><p>除了通过接口回调的方式来动态的控制UI模板，同样可以使用公共方法来动态地修改UI模板中的UI。这样可以进一步提高模板的可定制性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.31.54.png" alt="屏幕快照 2018-07-17 下午5.31.54" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.31.54</div>            </figure></p><h4 id="引用UI模板"><a href="#引用UI模板" class="headerlink" title="引用UI模板"></a>引用UI模板</h4><p>在需要使用的地方引用UI模板，在引用前，需要指定第三方控件的命名空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.33.56.png" alt="屏幕快照 2018-07-17 下午5.33.56" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.33.56</div>            </figure><br>这行代码就是在指定引用的命名空间xmlns，即xml namespace。这里指定了名字空间为“android”，因此在接下来使用系统属性时，才可以使用“android:”来引用Android的系统属性。如果要使用自定义的属性，就需要创建自己的名字空间。在Android Studio中，第三方的控件都使用如下代码来引入名字空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.39.45.png" alt="屏幕快照 2018-07-17 下午5.39.45" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.39.45</div>            </figure><br>这里我们将引入的第三方控件的名字空间取名为custom，之后再xml文件中使用自定义的属性时，就可以通过这个名字空间来引用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-17%20%E4%B8%8B%E5%8D%885.41.56.png" alt="屏幕快照 2018-07-17 下午5.41.56" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-17 下午5.41.56</div>            </figure><br>使用自定义的View与系统原生的View的最大区别就是在申明控件时，需要指定完整的包名，而在引用自定义的属性时，需要使用自定义的xmls名字。<br>再更进一步，将这个UI模板写到一个布局文件中，在其他的布局文中，直接通过&lt; include&gt;标签来引用这个UI模板的View。</p><h3 id="重写View来实现全新的控件"><a href="#重写View来实现全新的控件" class="headerlink" title="重写View来实现全新的控件"></a>重写View来实现全新的控件</h3><p>当Android系统原生的控件无法满足我们的需求时，我们就可以完全创建一个新的自定义View来实现需要的功能。通常需要继承View类，重写onDraw，onMeasure来实现绘制逻辑，同时重写onTouchEvent等触控时间来实现交互逻辑。还可以像实现组合控件那样，通过引入自定义属性，丰富自定义View的可定制性。</p><h4 id="弧线展示图"><a href="#弧线展示图" class="headerlink" title="弧线展示图"></a>弧线展示图</h4><h4 id="音频条形图"><a href="#音频条形图" class="headerlink" title="音频条形图"></a>音频条形图</h4><h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><p>重写onMeasure来对子View进行测量，重写onLayout确定子View的位置，重写onTouchEvent增加响应事件。</p><h2 id="事件拦截机制分析"><a href="#事件拦截机制分析" class="headerlink" title="事件拦截机制分析"></a>事件拦截机制分析</h2><p>Android为触摸事件封装了一个类MotionEvent，里面封装了触摸点的坐标，点击事件的类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.08.26.png" alt="屏幕快照 2018-07-18 下午3.08.26" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.08.26</div>            </figure><br>对于ViewGroup重写了三个方法：<br><strong>dispatchTouchEvent</strong><br><strong>onInterceptTouchEvent</strong><br><strong>onTouchEvent</strong><br>对于View来说，重写了两个方法：<br><strong>onTouchEvent</strong><br><strong>dispatchTouchEvent</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.12.38.png" alt="屏幕快照 2018-07-18 下午3.12.38" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.12.38</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.12.47.png" alt="屏幕快照 2018-07-18 下午3.12.47" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.12.47</div>            </figure><br><strong>dispatchTouchEvent</strong>基本不用动。<br>事件拦截的核心方法是<strong>onInterceptTouchEvent</strong>返回值：True，拦截，不继续；False，不拦截，继续流程。<br>事件处理<strong>onTouchEvent</strong>返回值：True，处理了，不用给上级汇报了，上级不会继续处理了；False，给上级处理。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15318086345666/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-18%20%E4%B8%8B%E5%8D%883.20.48.png" alt="屏幕快照 2018-07-18 下午3.20.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-18 下午3.20.48</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-3-Android控件架构与自定义控件详解&quot;&gt;&lt;a href=&quot;#Android群英传-3-Android控件架构与自定义控件详解&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 3 Android控件架构与自定义
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 2 Android开发工具新接触</title>
    <link href="https://github.com/zdkswd/2018/07/14/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%202%20Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%96%B0%E6%8E%A5%E8%A7%A6/"/>
    <id>https://github.com/zdkswd/2018/07/14/Android群英传 2 Android开发工具新接触/</id>
    <published>2018-07-14T04:18:32.000Z</published>
    <updated>2018-07-14T04:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-2-Android开发工具新接触"><a href="#Android群英传-2-Android开发工具新接触" class="headerlink" title="Android群英传 2 Android开发工具新接触"></a>Android群英传 2 Android开发工具新接触</h1><h2 id="Android开发IDE介绍"><a href="#Android开发IDE介绍" class="headerlink" title="Android开发IDE介绍"></a>Android开发IDE介绍</h2><h2 id="ADB命令使用技巧"><a href="#ADB命令使用技巧" class="headerlink" title="ADB命令使用技巧"></a>ADB命令使用技巧</h2><p>ADB–Android Debug Bridge，借助此工具，我们可以用电脑来操作手机。</p><h3 id="ADB基础"><a href="#ADB基础" class="headerlink" title="ADB基础"></a>ADB基础</h3><p>ADB工具位于SDK的platform-tools目录下。<br>手机助手也是使用ADB来实现它的功能。<br>手机端需要开发者模式，USB Debug。</p><h4 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h4><p>可以使用Linux Shell命令。</p><h4 id="android-list-targets"><a href="#android-list-targets" class="headerlink" title="android list targets"></a>android list targets</h4><p>显示系统中全部Android平台</p><h4 id="adb-install-r-程序-apk"><a href="#adb-install-r-程序-apk" class="headerlink" title="adb install -r 程序.apk"></a>adb install -r 程序.apk</h4><p>安装apk程序之install</p><h4 id="abd-push-lt-local-gt-lt-remote-gt"><a href="#abd-push-lt-local-gt-lt-remote-gt" class="headerlink" title="abd push &lt; local&gt; &lt; remote&gt;"></a>abd push &lt; local&gt; &lt; remote&gt;</h4><p>安装apk程序之push<br>两者都可以安装上APK，但是install是安装到data/data目录中，作为普通的用户应用程序。push则不是安装命令，是将文件写入手机的存储系统，所以，只要拥有相应的权限，就可以把任何Apk放到任何目录中，甚至是System目录下成为一个系统应用程序。</p><h4 id="abd-push-lt-local-gt-lt-remote-gt-1"><a href="#abd-push-lt-local-gt-lt-remote-gt-1" class="headerlink" title="abd push &lt; local&gt; &lt; remote&gt;"></a>abd push &lt; local&gt; &lt; remote&gt;</h4><p>向手机写入文件</p><h4 id="abd-pull-lt-local-gt-lt-remote-gt"><a href="#abd-pull-lt-local-gt-lt-remote-gt" class="headerlink" title="abd pull &lt; local&gt; &lt; remote&gt;"></a>abd pull &lt; local&gt; &lt; remote&gt;</h4><p>从手机获取文件。<br>这些东西在Android Device Monitor工具都可以直接使用。</p><h4 id="通过Logcat来查看Log"><a href="#通过Logcat来查看Log" class="headerlink" title="通过Logcat来查看Log"></a>通过Logcat来查看Log</h4><h4 id="删除应用"><a href="#删除应用" class="headerlink" title="删除应用"></a>删除应用</h4><h4 id="查看系统盘符"><a href="#查看系统盘符" class="headerlink" title="查看系统盘符"></a>查看系统盘符</h4><h4 id="输出所有已经安装的应用"><a href="#输出所有已经安装的应用" class="headerlink" title="输出所有已经安装的应用"></a>输出所有已经安装的应用</h4><h4 id="模拟按键输入"><a href="#模拟按键输入" class="headerlink" title="模拟按键输入"></a>模拟按键输入</h4><h4 id="模拟滑动输入"><a href="#模拟滑动输入" class="headerlink" title="模拟滑动输入"></a>模拟滑动输入</h4><h4 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h4><h4 id="Package管理信息"><a href="#Package管理信息" class="headerlink" title="Package管理信息"></a>Package管理信息</h4><h4 id="AM管理信息"><a href="#AM管理信息" class="headerlink" title="AM管理信息"></a>AM管理信息</h4><h4 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h4><h4 id="重新启动"><a href="#重新启动" class="headerlink" title="重新启动"></a>重新启动</h4><h3 id="ADB命令来源"><a href="#ADB命令来源" class="headerlink" title="ADB命令来源"></a>ADB命令来源</h3><h2 id="模拟器使用与配置"><a href="#模拟器使用与配置" class="headerlink" title="模拟器使用与配置"></a>模拟器使用与配置</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-2-Android开发工具新接触&quot;&gt;&lt;a href=&quot;#Android群英传-2-Android开发工具新接触&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 2 Android开发工具新接触&quot;&gt;&lt;/a&gt;Andro
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传 1 Android体系与系统架构</title>
    <link href="https://github.com/zdkswd/2018/07/14/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0%201%20Android%E4%BD%93%E7%B3%BB%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>https://github.com/zdkswd/2018/07/14/Android群英传 1 Android体系与系统架构/</id>
    <published>2018-07-14T03:01:32.000Z</published>
    <updated>2018-07-14T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android群英传-1-Android体系与系统架构"><a href="#Android群英传-1-Android体系与系统架构" class="headerlink" title="Android群英传 1 Android体系与系统架构"></a>Android群英传 1 Android体系与系统架构</h1><h2 id="Google生态系统"><a href="#Google生态系统" class="headerlink" title="Google生态系统"></a>Google生态系统</h2><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15315306518029/2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d.jpg" alt="2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d" title="">                </div>                <div class="image-caption">2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d</div>            </figure><p>这些层次结构即是相互独立的，又是相互关联的。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux层(仅为Linux内核)，Android最底层最核心的部分。显示内核版本，就是显示所用的Linux<strong>内核</strong>的版本。Linux层包含了Android系统的核心服务，包括硬件驱动，进程管理，安全系统等等。</p><h3 id="Dalvik与ART"><a href="#Dalvik与ART" class="headerlink" title="Dalvik与ART"></a>Dalvik与ART</h3><p>Dalvik包含了一整套Android运行环境虚拟机，每个App都会分配Dalvik虚拟机来保证互相之间不受干扰，并保持独立，特点是在运行时编译。<br>在Android 5.x开始，ART模式已经取代了Dalvik，ART是安装时进行编译，在运行时就不用编译了。</p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>见上图</p><h3 id="Standard-libraries"><a href="#Standard-libraries" class="headerlink" title="Standard libraries"></a>Standard libraries</h3><p>见上图</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>不管是使用NDK开发还是Java开发的App，都有Android Manifest文件、Dalvik Classes、Resource Bundle这些东西。</p><h2 id="Android-App组件架构"><a href="#Android-App组件架构" class="headerlink" title="Android App组件架构"></a>Android App组件架构</h2><p>即四大组件：Activity、BroadCastReciever、ContentProvider和Service。它们是组成一个Android App的最基本元素。</p><h3 id="Android四大组件如何协同工作"><a href="#Android四大组件如何协同工作" class="headerlink" title="Android四大组件如何协同工作"></a>Android四大组件如何协同工作</h3><p>Activity作为人机交互的第一界面，负责向用户展示和处理结果，信息的来源可以是通过资源获取，也可以是通过Content Provider来获取其他应用的信息，或是Service从后台计算，下载，处理后的结果，也可以是通过BroadCast Reciever获取到广播信息。同时，Android系统还提供了一个信使Intent，作为信息传递的载体。组件与组件之间通过Intent来通信、传递信息、交换数据，正是通过这样一种方式，四大组件形成了各自独立而又紧密联系的关系。</p><h3 id="应用运行上下文对象"><a href="#应用运行上下文对象" class="headerlink" title="应用运行上下文对象"></a>应用运行上下文对象</h3><p>Android系统上下文对象即Context，Activity、Service、Application都是继承自Context。<br>Android应用程序会在几个时间点创建应用上下文Context。</p><ol><li>创建Application</li><li>创建Activity</li><li>创建Service</li></ol><p>创建Context的时机就是在创建Context的实现类时。</p><h2 id="Android系统源代码目录与系统目录"><a href="#Android系统源代码目录与系统目录" class="headerlink" title="Android系统源代码目录与系统目录"></a>Android系统源代码目录与系统目录</h2><p>Android系统源代码目录包含了Android系统所有的源代码，从底层驱动到上层应用，Android系统对所有文件都进行了详细管理。在手机中，Android系统的目录和源代码目录不是一一对应的，与源代码编译后，与打包生成的Image文件的结构相同。</p><h3 id="Android系统源代码目录"><a href="#Android系统源代码目录" class="headerlink" title="Android系统源代码目录"></a>Android系统源代码目录</h3><p>看完Android源代码，要懂C、懂脚本、懂Java。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15315306518029/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-14%20%E4%B8%8A%E5%8D%8810.18.18.png" alt="屏幕快照 2018-07-14 上午10.18.18" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-14 上午10.18.18</div>            </figure><br>应注意，不是所有的源代码结构都是这样。只有AOSP的Android项目才是这样的结构，有些芯片厂家如MTK目录结构就不同。<br>Android源码采用Makefile编译。<br>像Android这样的大型项目，它的源代码不计其数，不同的功能，模块，按类型分别放置在不同的目录中，这些模块通常会有Makefile文件进行管理。它定义了一系列的规则来指定模块，哪些文件需要编译，以及这些文件该按照怎演的顺序去编译。甚至可以配置更复杂的功能操作，比如定义编译规则，打包规则，Makefile就像一个shell脚本，不仅可以使用自己的语法，也能调用操作系统的命令。<br>Android系统源代码目录每个目录中还会包含更多的目录，而它的每一个最小的功能单位的目录下，都会有一个Makefile文件，这样每一级向上，通过一个个Makefile文件，就把整个源代码有条不紊的联系在一起了。</p><h3 id="Android系统目录"><a href="#Android系统目录" class="headerlink" title="Android系统目录"></a>Android系统目录</h3><p>通过ADB连上手机，通过Linux的ls命令查看Android系统的根目录。其中/system和/data是开发者非常关心的两个目录。</p><h4 id="system-app"><a href="#system-app" class="headerlink" title="/system/app/"></a>/system/app/</h4><p>这里面放的是一些系统的App</p><h4 id="system-bin"><a href="#system-bin" class="headerlink" title="/system/bin/"></a>/system/bin/</h4><p>这里面主要放的是Linux自带的组件</p><h4 id="system-build-prop"><a href="#system-build-prop" class="headerlink" title="/system/build.prop"></a>/system/build.prop</h4><p>这里记录的是系统的属性信息。</p><h4 id="system-fonts"><a href="#system-fonts" class="headerlink" title="/system/fonts/"></a>/system/fonts/</h4><p>系统字体存放的目录root后可下载TTF格式字体替代原字体。</p><h4 id="system-framework"><a href="#system-framework" class="headerlink" title="/system/framework/"></a>/system/framework/</h4><p>系统的核心文件，架构层。</p><h4 id="system-lib"><a href="#system-lib" class="headerlink" title="/system/lib/"></a>/system/lib/</h4><p>存放几乎所有的共享库（.so）文件。</p><h4 id="system-media"><a href="#system-media" class="headerlink" title="/system/media/"></a>/system/media/</h4><p>该目录用来保存系统提示音、系统铃声。</p><h4 id="system-usr"><a href="#system-usr" class="headerlink" title="/system/usr/"></a>/system/usr/</h4><p>该目录用来保存用户的配置文件，如键盘布局、共享、时区文件等。</p><h4 id="data-app"><a href="#data-app" class="headerlink" title="/data/app/"></a>/data/app/</h4><p>data目录包含了用户大部分数据信息。app目录下包含了用户安装的App或者升级的App。</p><h4 id="data-data"><a href="#data-data" class="headerlink" title="/data/data/"></a>/data/data/</h4><p>这个目录应该是开发者访问最多的目录了，这里包含了App的数据信息，文件信息、数据库信息等，以包名的方式来区分各个应用。</p><h4 id="data-system"><a href="#data-system" class="headerlink" title="/data/system/"></a>/data/system/</h4><p>这个目录包含了手机的各项系统信息。</p><h4 id="data-misc"><a href="#data-misc" class="headerlink" title="/data/misc/"></a>/data/misc/</h4><p>这个目录保存了大部分的WiFi、VPN信息。</p><h3 id="Android-App文件目录"><a href="#Android-App文件目录" class="headerlink" title="Android App文件目录"></a>Android App文件目录</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android群英传-1-Android体系与系统架构&quot;&gt;&lt;a href=&quot;#Android群英传-1-Android体系与系统架构&quot; class=&quot;headerlink&quot; title=&quot;Android群英传 1 Android体系与系统架构&quot;&gt;&lt;/a&gt;Andro
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 9 整数和浮点小数</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%209%20%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E5%B0%8F%E6%95%B0/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 9 整数和浮点小数/</id>
    <published>2018-07-12T09:41:32.000Z</published>
    <updated>2018-07-12T09:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-9-整数和浮点小数"><a href="#松本行弘的程序世界-9-整数和浮点小数" class="headerlink" title="松本行弘的程序世界 9 整数和浮点小数"></a>松本行弘的程序世界 9 整数和浮点小数</h1><h2 id="深奥的整数世界"><a href="#深奥的整数世界" class="headerlink" title="深奥的整数世界"></a>深奥的整数世界</h2><h3 id="整数是有范围的"><a href="#整数是有范围的" class="headerlink" title="整数是有范围的"></a>整数是有范围的</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%884.23.38.png" alt="屏幕快照 2018-07-12 下午4.23.38" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午4.23.38</div>            </figure><h3 id="尝试位运算"><a href="#尝试位运算" class="headerlink" title="尝试位运算"></a>尝试位运算</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%884.24.58.png" alt="屏幕快照 2018-07-12 下午4.24.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午4.24.58</div>            </figure><h3 id="操作特定的位"><a href="#操作特定的位" class="headerlink" title="操作特定的位"></a>操作特定的位</h3><p>位运算组合起来，可以对存储在计算机中的各位进行自由操作。<br>操作二进制位就等于操作计算机的数据。<br>基本的位处理操作有4种。</p><ol><li>取出特定位的状态</li><li>特定位置位（设为1）</li><li>特定位清零（设为0）</li><li>特定位反转</li></ol><p>将操作限制在特定位的数为掩码。</p><h3 id="表示负数的办法"><a href="#表示负数的办法" class="headerlink" title="表示负数的办法"></a>表示负数的办法</h3><ol><li>开头一位做符号位</li><li>将整数的各位反转（1的补数）</li></ol><h3 id="Ruby的整数"><a href="#Ruby的整数" class="headerlink" title="Ruby的整数"></a>Ruby的整数</h3><p>Ruby的整数有两种，一种是范围有限制的整数Fixnum（32位CPU是31位，64位CPU是63位），另一种是范围没有限制（超过内存容量除外）的整数Bignum，根据计算结果自动变换。</p><h3 id="挑战公开密钥方式"><a href="#挑战公开密钥方式" class="headerlink" title="挑战公开密钥方式"></a>挑战公开密钥方式</h3><p>RSA加密的强度（解读的困难程度），就归因于素因数分解的难度。</p><h2 id="扑朔迷离的浮点小数世界"><a href="#扑朔迷离的浮点小数世界" class="headerlink" title="扑朔迷离的浮点小数世界"></a>扑朔迷离的浮点小数世界</h2><h3 id="计算机对小数的处理"><a href="#计算机对小数的处理" class="headerlink" title="计算机对小数的处理"></a>计算机对小数的处理</h3><h3 id="固定小数点数不易使用"><a href="#固定小数点数不易使用" class="headerlink" title="固定小数点数不易使用"></a>固定小数点数不易使用</h3><p>浮点数，就是小数点的位置可以移动。</p><h3 id="科学计数法也有问题"><a href="#科学计数法也有问题" class="headerlink" title="科学计数法也有问题"></a>科学计数法也有问题</h3><p>计算机中广泛使用的小数表示方法是科学计数法。科学计数法是指将有效数字和指数组合起来表示小数（实数）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%885.01.23.png" alt="屏幕快照 2018-07-12 下午5.01.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午5.01.23</div>            </figure><p><strong>IEEE754规定，尾数部分的首位始终归一化为1，所以首位始终省略，实质有效数字为53位。</strong></p><h3 id="小数不能完全表示"><a href="#小数不能完全表示" class="headerlink" title="小数不能完全表示"></a>小数不能完全表示</h3><ol><li>计算机中的数的表示有长度（位数）限制。</li><li>计算机中数的表示是二进制。</li></ol><h4 id="浮点数是有限的"><a href="#浮点数是有限的" class="headerlink" title="浮点数是有限的"></a>浮点数是有限的</h4><h4 id="浮点数有误差"><a href="#浮点数有误差" class="headerlink" title="浮点数有误差"></a>浮点数有误差</h4><h4 id="对于浮点小数，结合法不成立"><a href="#对于浮点小数，结合法不成立" class="headerlink" title="对于浮点小数，结合法不成立"></a>对于浮点小数，结合法不成立</h4><h3 id="有不能比较的时候"><a href="#有不能比较的时候" class="headerlink" title="有不能比较的时候"></a>有不能比较的时候</h3><p>对于浮点数进行比较运算，只有两个数在内部表示是完全相同的情况下才判定为相等。作为铁则，两个浮点数不能用==进行比较运算。如果有进行比较的必要，判断条件中的两个数的差要足够小。根据操作系统的不同，对于浮点数，足够小的值e有不同的定义。</p><h3 id="误差积累"><a href="#误差积累" class="headerlink" title="误差积累"></a>误差积累</h3><p>减少运算次数。</p><h3 id="不是数的特别“数”"><a href="#不是数的特别“数”" class="headerlink" title="不是数的特别“数”"></a>不是数的特别“数”</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313834829764/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8B%E5%8D%885.13.14.png" alt="屏幕快照 2018-07-12 下午5.13.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 下午5.13.14</div>            </figure><p>无限大Inf，零0，非数NaN</p><h3 id="计算误差有多种"><a href="#计算误差有多种" class="headerlink" title="计算误差有多种"></a>计算误差有多种</h3><h4 id="舍入误差"><a href="#舍入误差" class="headerlink" title="舍入误差"></a>舍入误差</h4><h4 id="最大值溢出与最小值溢出"><a href="#最大值溢出与最小值溢出" class="headerlink" title="最大值溢出与最小值溢出"></a>最大值溢出与最小值溢出</h4><h4 id="信息丢失"><a href="#信息丢失" class="headerlink" title="信息丢失"></a>信息丢失</h4><h4 id="位数脱落"><a href="#位数脱落" class="headerlink" title="位数脱落"></a>位数脱落</h4><h4 id="截止误差"><a href="#截止误差" class="headerlink" title="截止误差"></a>截止误差</h4><h3 id="误差导致的严重问题"><a href="#误差导致的严重问题" class="headerlink" title="误差导致的严重问题"></a>误差导致的严重问题</h3><h3 id="BigDecimal是什么"><a href="#BigDecimal是什么" class="headerlink" title="BigDecimal是什么"></a>BigDecimal是什么</h3><p>浮点数运算的陷阱可以归结为：1. 能够表示的精度有限</p><ol start="2"><li>以二进制来表示</li></ol><p>Ruby提供了BigDecimal类，有以下3个特点：</p><ol><li>与Bignum一样，有效数字自动扩展</li><li>以十进制计算</li><li>以C语言记述，比内嵌的浮点数类（Float）要慢</li></ol><h3 id="能够表示分数的Rational类"><a href="#能够表示分数的Rational类" class="headerlink" title="能够表示分数的Rational类"></a>能够表示分数的Rational类</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-9-整数和浮点小数&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-9-整数和浮点小数&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 9 整数和浮点小数&quot;&gt;&lt;/a&gt;松本行弘的程序世界 9 整数和浮点小数&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 8 正则表达式</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%208%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 8 正则表达式/</id>
    <published>2018-07-12T04:41:32.000Z</published>
    <updated>2018-07-12T04:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-8-正则表达式"><a href="#松本行弘的程序世界-8-正则表达式" class="headerlink" title="松本行弘的程序世界 8 正则表达式"></a>松本行弘的程序世界 8 正则表达式</h1><h2 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h2><h3 id="检索“像那样的东西”"><a href="#检索“像那样的东西”" class="headerlink" title="检索“像那样的东西”"></a>检索“像那样的东西”</h3><h3 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h3><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>除了表中所示的元字符以外的普通字符，都与该字符自身相匹配。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.28.08.png" alt="屏幕快照 2018-07-12 上午10.28.08" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.28.08</div>            </figure></p><h4 id="字符集合"><a href="#字符集合" class="headerlink" title="字符集合"></a>字符集合</h4><p>用括号（【】）括起来的部分为字符集合。与括号内所含的每一个字符都匹配。比如，【abcde】能与小写字母abcde中的任何一个相匹配。<br>字符集合中，用中划线（-）来指定范围。所以，【abcde】可以用【a-e】来代替。<br>字符集合中，第一个字符是【\^】时，表示取反。就是说，不与括号（【】）中的字符相匹配。</p><h4 id="任意一个字符"><a href="#任意一个字符" class="headerlink" title="任意一个字符"></a>任意一个字符</h4><p>表示任意一个字符读得模式是“.”。除了匹配换行符。</p><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.42.59.png" alt="屏幕快照 2018-07-12 上午10.42.59" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.42.59</div>            </figure><h4 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h4><p>贪婪：寻找符合的最长的，遍历完再回溯，<br>懒惰：寻找第一个符合的。</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>将模式绑定起来的功能称为分组。（ma）+</p><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>|</p><h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>指定位置而不是字符来进行匹配。称为锚点（anchor）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8810.53.24.png" alt="屏幕快照 2018-07-12 上午10.53.24" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午10.53.24</div>            </figure></p><h3 id="三个陷阱"><a href="#三个陷阱" class="headerlink" title="三个陷阱"></a>三个陷阱</h3><h4 id="记号多、密度高的表达式"><a href="#记号多、密度高的表达式" class="headerlink" title="记号多、密度高的表达式"></a>记号多、密度高的表达式</h4><p>为应对这一问题，出现了扩展正则表达式。</p><h4 id="0次以上的重复"><a href="#0次以上的重复" class="headerlink" title="0次以上的重复"></a>0次以上的重复</h4><h4 id="贪婪型匹配"><a href="#贪婪型匹配" class="headerlink" title="贪婪型匹配"></a>贪婪型匹配</h4><h3 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h3><p>面向对象语言Ruby中，所有数据都是对象。正则表达式也是对象。<br><strong>Ruby程序中正则表达式对象写成/.*/的样子。</strong><br>正则表达式对象可以用正则表达式类方法生成。程序中由组合字符串生成正则表达式时，使用类方法更自然。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>Ruby正则表达式末尾斜杠的后面，可以为这个正则表达式添加选项。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.34.28.png" alt="屏幕快照 2018-07-12 上午11.34.28" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.34.28</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.35.23.png" alt="屏幕快照 2018-07-12 上午11.35.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.35.23</div>            </figure></p><h3 id="正则表达式匹配的方法"><a href="#正则表达式匹配的方法" class="headerlink" title="正则表达式匹配的方法"></a>正则表达式匹配的方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.37.23.png" alt="屏幕快照 2018-07-12 上午11.37.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.37.23</div>            </figure><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>Ruby中有源于Perl的特殊变量。以$开头的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.41.33.png" alt="屏幕快照 2018-07-12 上午11.41.33" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.41.33</div>            </figure></p><h3 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15313622372722/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-12%20%E4%B8%8A%E5%8D%8811.43.29.png" alt="屏幕快照 2018-07-12 上午11.43.29" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-12 上午11.43.29</div>            </figure><h3 id="split的本质"><a href="#split的本质" class="headerlink" title="split的本质"></a>split的本质</h3><p>分割字符串的方法split,与正则表达式组合起来能实现很多功能。</p><h3 id="字符串的扫描"><a href="#字符串的扫描" class="headerlink" title="字符串的扫描"></a>字符串的扫描</h3><h3 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h3><p>想要置换与字符串模式匹配的部分，可以用置换方法。</p><h2 id="正则表达式的应用实例与“鬼车”"><a href="#正则表达式的应用实例与“鬼车”" class="headerlink" title="正则表达式的应用实例与“鬼车”"></a>正则表达式的应用实例与“鬼车”</h2><p>正则表达式是表达字符串模式的一种微型语言。正则表达式由字符本身、字符模式、锚点以及重复等组合而成。</p><h3 id="解析日志文件的方法"><a href="#解析日志文件的方法" class="headerlink" title="解析日志文件的方法"></a>解析日志文件的方法</h3><h3 id="避免使用-的方法"><a href="#避免使用-的方法" class="headerlink" title="避免使用$的方法"></a>避免使用$的方法</h3><p>记号$不美观。Ruby中，以match方法替代=~运算符，就可以在程序中不使用这些记号了。</p><h3 id="从邮件中取出日期的方法"><a href="#从邮件中取出日期的方法" class="headerlink" title="从邮件中取出日期的方法"></a>从邮件中取出日期的方法</h3><h3 id="典型拼写错误的检索方法"><a href="#典型拼写错误的检索方法" class="headerlink" title="典型拼写错误的检索方法"></a>典型拼写错误的检索方法</h3><h3 id="Ruby1-9的新功能“鬼车”"><a href="#Ruby1-9的新功能“鬼车”" class="headerlink" title="Ruby1.9的新功能“鬼车”"></a>Ruby1.9的新功能“鬼车”</h3><p>“鬼车”新正则表达式库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DSL</span><br><span class="line">Domain Specific Language,意为面向特定领域的编程语言。</span><br><span class="line">DSL分内部DSL和外部DSL。</span><br><span class="line">内部DSL，就是往既有的语言中加入特定领域的词汇，使之DSL化。如软件编译工具Rake中表达依存关系的内部DSL。</span><br><span class="line">make是一个同样目的的工具，它使用Makefile来表达依存关系。Rake可以利用Ruby的编程功能、方法定义、条件分歧和循环等，不管关系有多复杂，都可以编程对应。</span><br><span class="line">外部DSL，不是扩展现有的语言，而是面向特定目的，如SQL就是DSL的代表性例子。正则表达式也可以称作是以实现模式匹配为目的的外部DSL。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-8-正则表达式&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-8-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 8 正则表达式&quot;&gt;&lt;/a&gt;松本行弘的程序世界 8 正则表达式&lt;/h1&gt;&lt;h2 id=&quot;正则表达式
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 7 文字编码</title>
    <link href="https://github.com/zdkswd/2018/07/12/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%207%20%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81/"/>
    <id>https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 7 文字编码/</id>
    <published>2018-07-12T02:00:32.000Z</published>
    <updated>2018-07-12T02:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-7-文字编码"><a href="#松本行弘的程序世界-7-文字编码" class="headerlink" title="松本行弘的程序世界 7 文字编码"></a>松本行弘的程序世界 7 文字编码</h1><h2 id="文字编码的种类"><a href="#文字编码的种类" class="headerlink" title="文字编码的种类"></a>文字编码的种类</h2><h3 id="早期的文字编码"><a href="#早期的文字编码" class="headerlink" title="早期的文字编码"></a>早期的文字编码</h3><h3 id="纸带与文字的表现"><a href="#纸带与文字的表现" class="headerlink" title="纸带与文字的表现"></a>纸带与文字的表现</h3><h3 id="文字是什么"><a href="#文字是什么" class="headerlink" title="文字是什么"></a>文字是什么</h3><h3 id="走向英语以外的语言（欧洲篇）"><a href="#走向英语以外的语言（欧洲篇）" class="headerlink" title="走向英语以外的语言（欧洲篇）"></a>走向英语以外的语言（欧洲篇）</h3><h3 id="英语以外得到语言（亚洲篇）"><a href="#英语以外得到语言（亚洲篇）" class="headerlink" title="英语以外得到语言（亚洲篇）"></a>英语以外得到语言（亚洲篇）</h3><h3 id="Unicode的问世"><a href="#Unicode的问世" class="headerlink" title="Unicode的问世"></a>Unicode的问世</h3><h3 id="统一编码成16位的汉字统合"><a href="#统一编码成16位的汉字统合" class="headerlink" title="统一编码成16位的汉字统合"></a>统一编码成16位的汉字统合</h3><h3 id="Unicode的两个问题"><a href="#Unicode的两个问题" class="headerlink" title="Unicode的两个问题"></a>Unicode的两个问题</h3><p>选择16位文字的Unicode有两大副作用。一是字节顺序的问题，一是NUL文字问题。<br>字节顺序就是低八位先放还是高八位先放的问题。<br>传统C语言处理的字符串，一般有一个终端文字NUL（‘\0’）。但是作为16位文字的字符串，中途会出现NUL文字。所以，C语言中处理字符串的传统函数不能用于16位文字的字符串。<br>像java那样的语言，一开始就是以16位文字为前提而设计的，所以没什么问题。但以C语言处理16位文字的时候，需要全新的api。</p><h3 id="Unicode的文字集"><a href="#Unicode的文字集" class="headerlink" title="Unicode的文字集"></a>Unicode的文字集</h3><p>现在，Unicode放弃了16位方式，而用21位来表示一个文字，现在Unicode能够表示4111个文字，肯定够用了。</p><h3 id="文字表示的不确定性"><a href="#文字表示的不确定性" class="headerlink" title="文字表示的不确定性"></a>文字表示的不确定性</h3><h3 id="Unicode的字符编码方式"><a href="#Unicode的字符编码方式" class="headerlink" title="Unicode的字符编码方式"></a>Unicode的字符编码方式</h3><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8以一定式样的字节组合来表示Unicode中的21位文字。对于内部程序处理字符串非常方便，另外没有字节顺序问题，在外部处理时也很有用。<br>缺点：消费过多内存，几乎所有的汉字都要占用3个字节。<br>构成文字的字节数是可变的，随机访问任意文字，代价与字符串长度成正比。<br>但是随着计算机内存的容量和性能提高，这些缺点也无所谓了。</p><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>Unicode中能以16位表示的空间就以16位表示，超过16位就以两个16位码组合来表示。到现在缺点已经很突出了，从今以后没必要采用这种字符编码方式了。</p><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>固定长，可以随机访问，但存在字节顺序的问题。<br>因为4字节，没什么人气。</p><h2 id="程序中的文字处理"><a href="#程序中的文字处理" class="headerlink" title="程序中的文字处理"></a>程序中的文字处理</h2><h3 id="文字编码有多个意思"><a href="#文字编码有多个意思" class="headerlink" title="文字编码有多个意思"></a>文字编码有多个意思</h3><h3 id="只能处理文字集中包含的文字"><a href="#只能处理文字集中包含的文字" class="headerlink" title="只能处理文字集中包含的文字"></a>只能处理文字集中包含的文字</h3><h3 id="纷繁复杂的文字编码方式"><a href="#纷繁复杂的文字编码方式" class="headerlink" title="纷繁复杂的文字编码方式"></a>纷繁复杂的文字编码方式</h3><h3 id="影响力渐微的Shift-JIS与EUC-JP"><a href="#影响力渐微的Shift-JIS与EUC-JP" class="headerlink" title="影响力渐微的Shift_JIS与EUC-JP"></a>影响力渐微的Shift_JIS与EUC-JP</h3><h3 id="Unicode有多种字符编码方式"><a href="#Unicode有多种字符编码方式" class="headerlink" title="Unicode有多种字符编码方式"></a>Unicode有多种字符编码方式</h3><h3 id="为什么会发生乱码"><a href="#为什么会发生乱码" class="headerlink" title="为什么会发生乱码"></a>为什么会发生乱码</h3><h3 id="字符编码方式错误"><a href="#字符编码方式错误" class="headerlink" title="字符编码方式错误"></a>字符编码方式错误</h3><h3 id="没有字体"><a href="#没有字体" class="headerlink" title="没有字体"></a>没有字体</h3><h3 id="变换为内部码时出错"><a href="#变换为内部码时出错" class="headerlink" title="变换为内部码时出错"></a>变换为内部码时出错</h3><h3 id="发生不完全变换"><a href="#发生不完全变换" class="headerlink" title="发生不完全变换"></a>发生不完全变换</h3><h3 id="文字集的不同"><a href="#文字集的不同" class="headerlink" title="文字集的不同"></a>文字集的不同</h3><h3 id="字节顺序错误"><a href="#字节顺序错误" class="headerlink" title="字节顺序错误"></a>字节顺序错误</h3><p>像UTF-16，UTF-32这种基本数据单位大于一个字节的编码方式，存放数据时字节该以什么顺序摆放，有两大流派，一个是big endian,一个是little endian。所以同样是UTF-16格式（UTF-32也一样）根据字节顺序不同就会有两种。<br>UTF-8就不会。</p><h3 id="从编程语言的角度处理文字"><a href="#从编程语言的角度处理文字" class="headerlink" title="从编程语言的角度处理文字"></a>从编程语言的角度处理文字</h3><p>编程语言处理文本数据的方法，有UCS方式和CSI方式两种。</p><h3 id="以变换为前提的UCS方式"><a href="#以变换为前提的UCS方式" class="headerlink" title="以变换为前提的UCS方式"></a>以变换为前提的UCS方式</h3><p>UCS（泛用字符集），是指程序中所处理的共同文字集（及字符编码方式）。输入输出时，编程语言将文本数据变成UCS，内部对文本数据进行统一处理。优点：</p><ol><li>原理简单，容易实现</li><li>除变换外，处理成本低</li><li>实际成果多</li></ol><p>缺点：</p><ol><li>发生不必要的变换</li><li>变换存在模糊部分</li><li>有外字及机种依存文字的问题</li><li>UCS中不包含的文字绝对不能处理</li></ol><h3 id="原封不动处理的CSI方式"><a href="#原封不动处理的CSI方式" class="headerlink" title="原封不动处理的CSI方式"></a>原封不动处理的CSI方式</h3><p>CSI（Character Set Independent，字符集独立），是指不对各种文字集（及编码方式）进行任何变换，原封不动地进行处理。相对于UCS的内部只有一种编码方式的处理方式，CSI中对各种编码方式原封不动地处理。<br>CSI是优点多，自由度高的方式。</p><ol><li>不发生不必要的变换</li><li>不发生变换所带来的问题</li><li>不易发生外字的问题。</li><li>理论上不存在不能处理的文字</li><li>根据需要，可以处理应用程序独立的文字集</li></ol><p>缺点：</p><ol><li>字符串的处理容易变得复杂化</li><li>预计处理性能会变低</li><li>实际成果少</li></ol><p>实际上，现在存在的多种编程语言中，采用CSI方式的几乎没有。</p><h3 id="使用UTF-16的Java"><a href="#使用UTF-16的Java" class="headerlink" title="使用UTF-16的Java"></a>使用UTF-16的Java</h3><p>Java采用UCS方式，内部字符编码选用UTF-16<br>制作Java时，Unicode仅限于16位。java没选择可变长的UTF-8，而选择UTF-16，因而产生了这样的悲剧。说是时机的恶作剧也罢，真是太可惜了。</p><h3 id="使用UTF-8的Perl"><a href="#使用UTF-8的Perl" class="headerlink" title="使用UTF-8的Perl"></a>使用UTF-8的Perl</h3><p>Perl也使用UCS方式，内部编码方式采用UTF-8。</p><h3 id="用UTF-16的Python"><a href="#用UTF-16的Python" class="headerlink" title="用UTF-16的Python"></a>用UTF-16的Python</h3><p>UCS，UTF-16</p><h3 id="采用CSI方式的Ruby1-8"><a href="#采用CSI方式的Ruby1-8" class="headerlink" title="采用CSI方式的Ruby1.8"></a>采用CSI方式的Ruby1.8</h3><h3 id="强化了功能的Ruby1-9"><a href="#强化了功能的Ruby1-9" class="headerlink" title="强化了功能的Ruby1.9"></a>强化了功能的Ruby1.9</h3><h3 id="是UCS还是CSI"><a href="#是UCS还是CSI" class="headerlink" title="是UCS还是CSI"></a>是UCS还是CSI</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-7-文字编码&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-7-文字编码&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 7 文字编码&quot;&gt;&lt;/a&gt;松本行弘的程序世界 7 文字编码&lt;/h1&gt;&lt;h2 id=&quot;文字编码的种类&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 6 Ruby On Rails</title>
    <link href="https://github.com/zdkswd/2018/07/11/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%206%20Ruby%20On%20Rails/"/>
    <id>https://github.com/zdkswd/2018/07/11/松本行弘的程序世界 6 Ruby On Rails/</id>
    <published>2018-07-11T04:00:32.000Z</published>
    <updated>2018-07-11T03:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-6-Ruby-On-Rails"><a href="#松本行弘的程序世界-6-Ruby-On-Rails" class="headerlink" title="松本行弘的程序世界 6 Ruby On Rails"></a>松本行弘的程序世界 6 Ruby On Rails</h1><h2 id="MVC和Ruby-On-Rails"><a href="#MVC和Ruby-On-Rails" class="headerlink" title="MVC和Ruby On Rails"></a>MVC和Ruby On Rails</h2><p>MVC是设计GUI程序的设计模式之一。大部分设计模式仅决定程序某一部分的构成，而MVC决定了应用程序的整体部分，有时候也被成为架构模式。</p><h3 id="模型、视图和控制的作用"><a href="#模型、视图和控制的作用" class="headerlink" title="模型、视图和控制的作用"></a>模型、视图和控制的作用</h3><p>模型：是表现窗口中表示内容（信息）的对象。模型代表的只是信息（名字、数值等抽象的信息），它不能包含如何来显示这些信息的信息。<br>视图：代表将模型中包含的信息在窗口中进行表示的对象。视图知道要表现的模型的信息，而模型一般不知道要表示自己的视图信息。<br>控制：是从用户端接受输入，对视图和模型进行操作的对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.26.46.png" alt="屏幕快照 2018-07-11 上午9.26.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.26.46</div>            </figure></p><h3 id="用秒表的例子来学习MVC模式"><a href="#用秒表的例子来学习MVC模式" class="headerlink" title="用秒表的例子来学习MVC模式"></a>用秒表的例子来学习MVC模式</h3><h3 id="生成视图和控制部分"><a href="#生成视图和控制部分" class="headerlink" title="生成视图和控制部分"></a>生成视图和控制部分</h3><h3 id="GUI工具箱与MVC"><a href="#GUI工具箱与MVC" class="headerlink" title="GUI工具箱与MVC"></a>GUI工具箱与MVC</h3><h3 id="同时使用工具箱和MVC"><a href="#同时使用工具箱和MVC" class="headerlink" title="同时使用工具箱和MVC"></a>同时使用工具箱和MVC</h3><h3 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h3><p>优点：</p><h4 id="可以更换界面"><a href="#可以更换界面" class="headerlink" title="可以更换界面"></a>可以更换界面</h4><h4 id="一个模型对应多个视图"><a href="#一个模型对应多个视图" class="headerlink" title="一个模型对应多个视图"></a>一个模型对应多个视图</h4><h4 id="多个视图可以同时响应"><a href="#多个视图可以同时响应" class="headerlink" title="多个视图可以同时响应"></a>多个视图可以同时响应</h4><h4 id="容易测试"><a href="#容易测试" class="headerlink" title="容易测试"></a>容易测试</h4><p>缺点：</p><h4 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h4><h4 id="强关联性"><a href="#强关联性" class="headerlink" title="强关联性"></a>强关联性</h4><p>对模型对象进行了功能追加这样的变更后，相应地也必须对视图和控制进行变更。</p><h3 id="Web应用中的MVC"><a href="#Web应用中的MVC" class="headerlink" title="Web应用中的MVC"></a>Web应用中的MVC</h3><p>Web应用基本是HTTP。HTTP的一次处理经过了一下过程：<br>（1）Web浏览器对应于用户的操作，向Web服务器发出HTTP请求。<br>（2）Web服务器根据请求，准备好发送到Web浏览器的数据。<br>（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。</p><p>利用MVC来描述：<br>（1）Web浏览器发送过来的HTTP请求通过Web服务器传给控制部分。Web应用框架的分配器把请求传递给合适的控制部分。<br>（2）控制部分操作的模型和请求的信息相对应，同时制定显示使用的视图。视图从模型启动，一边引用模型一边准备发送给Web浏览器的数据。<br>（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.54.09.png" alt="屏幕快照 2018-07-11 上午9.54.09" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.54.09</div>            </figure><p>Ruby on Rails上的MVC各部分功能稍有不同。Rails中的模型相当于数据库层，视图指显示用的模板，控制器指控制用的类（包含了应用逻辑）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%889.56.48.png" alt="屏幕快照 2018-07-11 上午9.56.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午9.56.48</div>            </figure></p><h2 id="开放类和猴子补丁"><a href="#开放类和猴子补丁" class="headerlink" title="开放类和猴子补丁"></a>开放类和猴子补丁</h2><p>猴子补丁，即在动态语言中，不改变源代码而对功能进行追加和变更。<br>现在灵活使用开放类，变更和追加方法全部称为猴子补丁。</p><h3 id="开放类"><a href="#开放类" class="headerlink" title="开放类"></a>开放类</h3><p>Ruby的类的特征是所谓的开放类，相对于其他语言，特别容易打猴子补丁。<br>Ruby中，可以把String类、Array类等基本的数据类型及所有的类都作为开放类处理，可以自由地追加功能。</p><h3 id="猴子补丁的目的"><a href="#猴子补丁的目的" class="headerlink" title="猴子补丁的目的"></a>猴子补丁的目的</h3><h4 id="功能追加"><a href="#功能追加" class="headerlink" title="功能追加"></a>功能追加</h4><p>利用开放类可以给已有的类追加功能。</p><h4 id="功能变更"><a href="#功能变更" class="headerlink" title="功能变更"></a>功能变更</h4><h4 id="修改程序错误"><a href="#修改程序错误" class="headerlink" title="修改程序错误"></a>修改程序错误</h4><p>因为重新定义了有程序错误或有副作用的方法，不用修改原来那部分的代码就可以解决问题。这也是本来的猴子补丁的目的。</p><h4 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h4><p>有时间想在每个方法调用的同时增加一些其他处理。这种伴随方法调用而进行的处理称为“钩子”（hook），钩子的追加也可以用猴子补丁来实现。</p><h4 id="缓存（cache）"><a href="#缓存（cache）" class="headerlink" title="缓存（cache）"></a>缓存（cache）</h4><h3 id="猴子补丁的技巧"><a href="#猴子补丁的技巧" class="headerlink" title="猴子补丁的技巧"></a>猴子补丁的技巧</h3><p>可以吧Ruby提供的对方法、类和模块进行操作的功能运用到打猴子补丁上。最基本的功能就是给已有的方法改名或取消。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15312716241699/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-11%20%E4%B8%8A%E5%8D%8810.58.20.png" alt="屏幕快照 2018-07-11 上午10.58.20" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-11 上午10.58.20</div>            </figure></p><h4 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h4><p>undef有把方法取消定义的功能。用undef不仅可以取消本类中的方法，也可以取消父类中定义的方法。</p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><h3 id="灵活使用开放类的库"><a href="#灵活使用开放类的库" class="headerlink" title="灵活使用开放类的库"></a>灵活使用开放类的库</h3><p>jcode库可以不使用正则表达式，利用开放类的功能，使得字符串的方法可以处理多字节文字。</p><h3 id="猴子补丁的几点问题"><a href="#猴子补丁的几点问题" class="headerlink" title="猴子补丁的几点问题"></a>猴子补丁的几点问题</h3><p>若要正确使用开放类，安全地打猴子补丁，需遵守：</p><ol><li>基本上只是追加功能<br>对类追加新方法不会让已有的程序无法执行。使用开放类时，主要做不容易导致问题的功能追加会更保险。做功能追加时，如果发生名称重复会造成麻烦，在选择追加的方法名时需要慎重。</li><li>进行功能变更时要慎重，尽可能小规模</li><li>小心相互作用</li></ol><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>猴子补丁能够不改变源代码进行动态修改，这种灵活性是显示动态语言柔软性和扩展性的好例子。实现猴子补丁的Ruby开放类有时功能过强，可能会引起问题。<br>其他语言中用更易控制的形式也能实现猴子补丁。</p><h3 id="Ruby-on-Rails和开放类"><a href="#Ruby-on-Rails和开放类" class="headerlink" title="Ruby on Rails和开放类"></a>Ruby on Rails和开放类</h3><p>Rails构成部分之一ActiveSupport库。ActiveSupport利用Ruby的开放类功能，对Ruby标准提供的类大胆地追加了功能。</p><h3 id="ActiveSupport带来的扩展"><a href="#ActiveSupport带来的扩展" class="headerlink" title="ActiveSupport带来的扩展"></a>ActiveSupport带来的扩展</h3><ol><li>时间</li><li>字节单位系列</li><li>复数形和序数</li></ol><h3 id="大规模开发和Ruby"><a href="#大规模开发和Ruby" class="headerlink" title="大规模开发和Ruby"></a>大规模开发和Ruby</h3><h4 id="编译时不作类型检查"><a href="#编译时不作类型检查" class="headerlink" title="编译时不作类型检查"></a>编译时不作类型检查</h4><p>Ruby在执行时作类型检查，大规模程序为了保证可靠性一定会有严格的测试程序，如果作了严格的测试，在编译时作类型检查的优点就不像所说的那么重要了。</p><h4 id="没有包"><a href="#没有包" class="headerlink" title="没有包"></a>没有包</h4><p>Java对于构成库的类和文件有独立的包，要想具备某种功能，必须明确地进行import操作。而Ruby是不具备这种功能的。所以，库定义的类和模块名是全局的，从任何地方都可以引用。因此，可以说名称重复的危险性很大。</p><h4 id="存在开放类"><a href="#存在开放类" class="headerlink" title="存在开放类"></a>存在开放类</h4><p>各自独立的库发生互相矛盾的变更时，问题不能简单解决。这也可能在大规模开发时引发问题。</p><h3 id="信赖性模型"><a href="#信赖性模型" class="headerlink" title="信赖性模型"></a>信赖性模型</h3><p>在某种类型的大规模开发中，Ruby的性质会造成问题，或者说造成问题时解决起来不像其他语言那么容易，这种现象是现实中可能存在的。如果认为这些是问题的话，可能不使用Ruby会更好。但是，到现在为止我们看到的情况表明，会发生那种问题的大规模开发本来就绝不是好的开发状况。首先要做的，是把项目的信赖关系改善到可以使用Ruby的程度。就算是最后也没有使用Ruby，这也是应该先做到的事情。</p><h3 id="猴子补丁的未来"><a href="#猴子补丁的未来" class="headerlink" title="猴子补丁的未来"></a>猴子补丁的未来</h3><p>猴子补丁虽然有一定的危险性，但有利有弊，它也提供了方便性、扩展性和灵活性。开放类和利用它的猴子补丁，将来也可能会被更安全的、由1特定目的而特制的功能群而替代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-6-Ruby-On-Rails&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-6-Ruby-On-Rails&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 6 Ruby On Rails&quot;&gt;&lt;/a&gt;松本行弘的程序世界 6
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 5 Ajax</title>
    <link href="https://github.com/zdkswd/2018/07/10/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%205%20Ajax/"/>
    <id>https://github.com/zdkswd/2018/07/10/松本行弘的程序世界 5 Ajax/</id>
    <published>2018-07-10T09:25:32.000Z</published>
    <updated>2018-07-10T09:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-5-Ajax"><a href="#松本行弘的程序世界-5-Ajax" class="headerlink" title="松本行弘的程序世界 5 Ajax"></a>松本行弘的程序世界 5 Ajax</h1><h2 id="Ajax和JavaScript（前篇）"><a href="#Ajax和JavaScript（前篇）" class="headerlink" title="Ajax和JavaScript（前篇）"></a>Ajax和JavaScript（前篇）</h2><p>Ajax（Asynchronous JavaScript and XML）,含义是异步JavaScript及XML。<br>Ajax不算是一个新技术，只是既有技术的组合。</p><h3 id="通信及异步页面更新"><a href="#通信及异步页面更新" class="headerlink" title="通信及异步页面更新"></a>通信及异步页面更新</h3><p>Ajax的最大特点是进行异步操作，异步意味着Web浏览器的通信和页面更新是互相独立的。<br>以前的Web应用程序，每按下一个按钮就开始显示下一个页面，在页面完整呈现之前，用户只能等待，无法进行其他操作，使用Ajax技术的页面是在后台和HTTP服务器进行通信，设计优良的Web应用程序，在客户和服务器通信的过程中也可以让用户进行操作，而不需要等待。Ajax的最大优点是改善了应用程序的操控性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8A%E5%8D%888.52.52.png" alt="屏幕快照 2018-07-10 上午8.52.52" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 上午8.52.52</div>            </figure><br>Ajax技术中，对于用户进行的操作，基本是由JavaScript在Web浏览器中进行响应。尽在数据必须从服务器获取的情况下，才在后台进行异步通信。在通信过程中，用户也可以继续对Web浏览器进行操作。和服务器通信得到的结果由DHTML对当前的页面进行部分更新而现实出来。</p><h3 id="技术要素之一：JavaScript"><a href="#技术要素之一：JavaScript" class="headerlink" title="技术要素之一：JavaScript"></a>技术要素之一：JavaScript</h3><p>支撑Ajax的三个主要技术：JavaScript、XML及DHTML。<br>JavaScript是几乎所有Web浏览器处理系统都支撑的一种编程语言。因此，它被称为世界上最普及的编程语言。<br>JavaScript可以简单的嵌入到表示网页的HTML中去，利用JavaScript可以做出<strong>完全不用和服务器进行通信</strong>的网页。</p><h3 id="技术要素之二：XML"><a href="#技术要素之二：XML" class="headerlink" title="技术要素之二：XML"></a>技术要素之二：XML</h3><p>XML（eXtensible Markup Language）,和SGML、HTML类似，使用标签（tag）对数据进行标识说明的一种语言。<br>XML已经成为了数据表示、配置各种文件及其他多种场合下广泛使用的一种格式。<br>Ajax的名字中部分包括了XML，是因为当初大部分使用Ajax技术的应用程序都使用了XML数据，以及用JavaScript进行异步通信的对象的名字是XMLHTTPRequest。当然不用XML的XMLHTTPRequest的通信也是存在的，使用Ajax技术的Web应用进行通信的数据格式也是多种多样的，比如有普通文本格式以及YAML，JSON。</p><h3 id="XML以外的数据表示形式"><a href="#XML以外的数据表示形式" class="headerlink" title="XML以外的数据表示形式"></a>XML以外的数据表示形式</h3><p>YAML（YAML Ain’t Markup Language）看出它不是标记语言。YAML只是表示数据的语言，目的仅仅是表示数据。特点有：</p><ol><li>记述简洁</li><li>容易理解</li><li>专注于表示数据，不用费心考虑给标签起名字。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8A%E5%8D%889.30.23.png" alt="屏幕快照 2018-07-10 上午9.30.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 上午9.30.23</div>            </figure></li></ol><p>和YMAL相提并论的是JSON（JavaScript Object Notation）意思是JavaScript对象表示法。是直接把JavaScript表示对象的程序拿来记述数据。JSON是合法的JavaScript程序，作为JavaScript实现可以生成对象。<br>JSON可以表现下面6种数据类型：数值（整数及浮点小数）、字符串、布尔值（真、假）、数组、对象（键和值的表）和null。<br>YAML通过扩展可以表示各种形式的数据。相比较，JSON就简单太多了，但也够用了。</p><h3 id="技术要素之三：DHTML"><a href="#技术要素之三：DHTML" class="headerlink" title="技术要素之三：DHTML"></a>技术要素之三：DHTML</h3><p>DHTML，动态HTML，顾名思义，可以动态地对HTML进行引用、修改和更新。更具体的说，是利用装载在网页中的JavaScript，使用DOM（文档对象模型）对网页数据进行操作。使用DOM可以进行下述处理：</p><ol><li>取得页面中特定标签中的数据；</li><li>修改标签的数据（文字、属性等）</li><li>在页面中添加标签；</li><li>设定事件处理程序<h3 id="JavaScript技术基础"><a href="#JavaScript技术基础" class="headerlink" title="JavaScript技术基础"></a>JavaScript技术基础</h3>JavaScript是以对象为基础的语言，所有的数据都可以作为“对象”进行统一处理。不过，它不具备“类”这样的所谓普通面向对象语言所提供的功能，即使去除JavaScript面向对象的编程功能，它也可以作为普通的结构化编程语言来使用。<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4>JavaScript的基本语法和C、Java类似。最大的不同是，JavaScript不指定变量类型。<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4>JavaScript的特点之一是把函数作为对象进行处理。C也是将函数作为对象处理，但JavaScript的不同之处在于函数对象有闭包（closure），可以使用函数外面的局部变量。<strong>闭包功能称为了JavaScript面向对象功能的基础。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闭包是Ruby中块变为对象后的结果。它的优点是，只要闭包还存在，就能访问闭包内的变量。</span><br></pre></td></tr></table></figure></li></ol><h3 id="原型模式的面向对象编程语言"><a href="#原型模式的面向对象编程语言" class="headerlink" title="原型模式的面向对象编程语言"></a>原型模式的面向对象编程语言</h3><p>如果具有原型模式的面向对象功能的话，就可以最大限度地消减语言本身的固有功能。这非常适合于JavaScript这样的语言。<br>以类为中心的传统面向对象编程，是以类为基础生成新对象。类和对象的关系可以类比成铸模和铸件的关系。而原型模式的面向对象编程语言没有类这样一个概念。<br>需要生成新的对象时，只要给对象追加属性。设置函数对象作为属性的话，就成为方法。当访问对象中不存在的属性时，JavaScript会去搜索该对象prototype属性所指向的对象。<br>JavaScript利用这个功能，使用“委派”而非“继承”来实现面向对象编程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">委派是指，把对于某个对象的调用传送到另一个对象上。</span><br></pre></td></tr></table></figure></p><p>JavaScript的方式过于简单反而使记述太过复杂。</p><h3 id="使用prototype-js库"><a href="#使用prototype-js库" class="headerlink" title="使用prototype.js库"></a>使用prototype.js库</h3><p>为了克服JavaScript记述过于繁杂的缺点，JavaScript提供了进行功能扩展的一些库。如prototype.js库<br>prototype.js受到了Ruby的影响，实际上Ruby on Rails中标准地附加了prototype.js库，使用得很广泛。</p><h3 id="prototype-js的功能"><a href="#prototype-js的功能" class="headerlink" title="prototype.js的功能"></a>prototype.js的功能</h3><h4 id="Ajax功能"><a href="#Ajax功能" class="headerlink" title="Ajax功能"></a>Ajax功能</h4><p>prototype.js支持XMLHttpRequest对象，可以对HTML进行异步更新。<br>实际上不同Web浏览器获取XMLHttpRequest对象的方法也是不同的。Ajax.Request帮我们屏蔽了与代码移植相关的问题。</p><h4 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h4><p>它是Ruby的Enumerable模块在JavaScript中的实现。</p><h4 id="其他扩展功能"><a href="#其他扩展功能" class="headerlink" title="其他扩展功能"></a>其他扩展功能</h4><p>如使用Object.extend()给对象追加功能。</p><h2 id="Ajax和JavaScript-后篇"><a href="#Ajax和JavaScript-后篇" class="headerlink" title="Ajax和JavaScript(后篇)"></a>Ajax和JavaScript(后篇)</h2><p>像Ajax有3个特点：</p><ol><li>没有Web页面跳转</li><li>通过异步通信实现快速反应</li><li>实现了动画和拖拽等单独使用HTML格式无法表现的用户界面<br>构成DHTML基础的JavaScript是一个速度不怎么快的语言。某种技术在开发出来之后经过相当长一段时间才得到普及，此类例子并不少见。<h3 id="巧妙使用DHTML"><a href="#巧妙使用DHTML" class="headerlink" title="巧妙使用DHTML"></a>巧妙使用DHTML</h3>DHTML被称为Ajax的本质技术。顾名思义，可以动态访问、更新HTML。具体就是利用嵌入网页的JavaScript，使用DOM操作页面数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM是操作HTML和XML的规范。特点是把HTML和XML作为树结构进行处理。</span><br></pre></td></tr></table></figure></li></ol><p>HTML被读取后，生成树结构。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8B%E5%8D%884.39.14.png" alt="屏幕快照 2018-07-10 下午4.39.14" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 下午4.39.14</div>            </figure><br>使用JavaScript对树结构进行操作就是DHTML的本质。因此JavaScript提供的W3C DOM API有如下功能：</p><ol><li>获取documnent节点</li><li>获取和更新标签数据（包括文字、类型以及属性等）</li><li>追加documnent节点</li><li>设定时间处理程序（event handler）</li></ol><h3 id="获取documnent节点"><a href="#获取documnent节点" class="headerlink" title="获取documnent节点"></a>获取documnent节点</h3><blockquote><p>getElementById(name)<br>getElementsByTagName(name)</p></blockquote><h3 id="获取和更新标签数据"><a href="#获取和更新标签数据" class="headerlink" title="获取和更新标签数据"></a>获取和更新标签数据</h3><p>获取节点对象后，通过调用对象的方法，读写对象的属性等就能够获取和更新标签数据。</p><h3 id="设定事件处理程序"><a href="#设定事件处理程序" class="headerlink" title="设定事件处理程序"></a>设定事件处理程序</h3><p>两种办法：</p><ol><li>指定标签属性。如设置为a标签的onclick属性值来指定事件处理程序。</li><li>把方法设为JavaScript对象的属性。如<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15311832913375/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-10%20%E4%B8%8B%E5%8D%884.49.48.png" alt="屏幕快照 2018-07-10 下午4.49.48" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-10 下午4.49.48</div>            </figure></li></ol><h3 id="追加标签节点"><a href="#追加标签节点" class="headerlink" title="追加标签节点"></a>追加标签节点</h3><p>用appendChild方法可以为节点对象追加节点，消除节点用removeChild方法。</p><h3 id="本地HTML应用"><a href="#本地HTML应用" class="headerlink" title="本地HTML应用"></a>本地HTML应用</h3><h3 id="和服务器间的通信"><a href="#和服务器间的通信" class="headerlink" title="和服务器间的通信"></a>和服务器间的通信</h3><p>使用DHTML之后，对于较简单的应用，在客户端就能够实现。但是，客户端无法保存数据，所以保存和获取数据时需要和服务器进行通信。<br>Ajax是利用XMLHTTPRequest对象来进行异步通信，不需要网页跳转，在后台就可以进行通信。</p><h3 id="使用Prototype-js的优点"><a href="#使用Prototype-js的优点" class="headerlink" title="使用Prototype.js的优点"></a>使用Prototype.js的优点</h3><p>不需要麻烦的记述。</p><h3 id="在服务器上保存数据"><a href="#在服务器上保存数据" class="headerlink" title="在服务器上保存数据"></a>在服务器上保存数据</h3><h3 id="Web应用的脆弱性"><a href="#Web应用的脆弱性" class="headerlink" title="Web应用的脆弱性"></a>Web应用的脆弱性</h3><p>如XSS（跨站点脚本问题）</p><h3 id="使用JavaScript的感觉"><a href="#使用JavaScript的感觉" class="headerlink" title="使用JavaScript的感觉"></a>使用JavaScript的感觉</h3><h4 id="作为动态语言名副其实"><a href="#作为动态语言名副其实" class="headerlink" title="作为动态语言名副其实"></a>作为动态语言名副其实</h4><h4 id="DHTML比想象的更有趣"><a href="#DHTML比想象的更有趣" class="headerlink" title="DHTML比想象的更有趣"></a>DHTML比想象的更有趣</h4><h4 id="Prototype-js也不错"><a href="#Prototype-js也不错" class="headerlink" title="Prototype.js也不错"></a>Prototype.js也不错</h4><h4 id="调试比较麻烦"><a href="#调试比较麻烦" class="headerlink" title="调试比较麻烦"></a>调试比较麻烦</h4><p>JavaScript理就算有程序错误，Web浏览器也不会显示任何信息。想要确认程序的状态，只能多次使用alert()。<br>Firefox提供了Firebug的扩展功能，对于JavaScript的调试非常有用。</p><h4 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h4><p>Ajax开发最难的一点就是Web浏览器间JavaScript的兼容性问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名字的重要性</span><br><span class="line">起了一个合适的名字本身意味着功能设计的正确。反过来，起了不好的名字说明设计者自己也没有完全理解应完成什么样的功能。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-5-Ajax&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-5-Ajax&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 5 Ajax&quot;&gt;&lt;/a&gt;松本行弘的程序世界 5 Ajax&lt;/h1&gt;&lt;h2 id=&quot;Ajax和Java
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 4 设计模式</title>
    <link href="https://github.com/zdkswd/2018/07/09/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%204%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 4 设计模式/</id>
    <published>2018-07-09T10:21:32.000Z</published>
    <updated>2018-07-20T11:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-4-设计模式"><a href="#松本行弘的程序世界-4-设计模式" class="headerlink" title="松本行弘的程序世界 4 设计模式"></a>松本行弘的程序世界 4 设计模式</h1><h2 id="设计模式（1）"><a href="#设计模式（1）" class="headerlink" title="设计模式（1）"></a>设计模式（1）</h2><h3 id="设计模式的价值和意义"><a href="#设计模式的价值和意义" class="headerlink" title="设计模式的价值和意义"></a>设计模式的价值和意义</h3><p>Gamma他们并没有发现新的模式，总结出来的23种设计模式也是软件开发中早就存在并反复使用的模式，因此并不能说是Gamma他们的首创。但即使是这样，设计模式有了名字，人们就可以认识到它的存在，并对之进行讨论。这种不能用语言表达的知识称为内隐知识。给这些在软件中经常反复出现的模式命名，使得这些本来只有经验丰富的程序员才能认识到的软件设计模式能被广泛认识和讨论。</p><h3 id="设计模式是程序抽象化的延伸"><a href="#设计模式是程序抽象化的延伸" class="headerlink" title="设计模式是程序抽象化的延伸"></a>设计模式是程序抽象化的延伸</h3><p>一旦有了设计模式，只要把过去优秀的人们考虑出来的模式拿来应用一下。</p><h3 id="Ruby中的设计模式"><a href="#Ruby中的设计模式" class="headerlink" title="Ruby中的设计模式"></a>Ruby中的设计模式</h3><h3 id="Singleton模式"><a href="#Singleton模式" class="headerlink" title="Singleton模式"></a>Singleton模式</h3><p>单件模式。用来保证某个类的实例只有一个。<br>Ruby实现Singleton模式的方法有几个</p><ol><li>使用singleton库的方法<br>Ruby以库的形式实现了Singleton模式。使用Singleton库，在任意类中include Singleton模块，那个类就变成Singleton模式的对象。</li><li>使用类或模块<br>C++和java是不能把类作为对象使用的，与之不同的是，smalltalk或Ruby能把类也作为对象来处理。因此，在类或模块中定义一个方法就可以实现Singleton模式。</li><li>把一般的对象作为Singleton来使用<br>为了把一个类的对象限制为只有一个，并不一定要对对象的一般生产方法进行限制。可以生成一个一般的对象，然后不要在生产更多个对象了。</li><li>使用对象和特异方法<br>Ruby可以在对象生成以后再增加新的方法。</li></ol><h3 id="Proxy模式"><a href="#Proxy模式" class="headerlink" title="Proxy模式"></a>Proxy模式</h3><p>Proxy（代理）模式是为某个对象提供代理对象的模式。<br>在不知道是否真正需要一个生成代价很大的对象时可能造成很大浪费，但不生成又什么都做不了。</p><h3 id="Iterator模式"><a href="#Iterator模式" class="headerlink" title="Iterator模式"></a>Iterator模式</h3><p>Iterator（迭代器）模式提供按顺序访问集合对象中各元素的方法。即使不知道对象的内部构造，也可以按顺序访问其中的每个元素。<br>Iterator模式是为集合对象另外准备用来控制循环处理的对象，就像C++或java一样，我们称这个循环控制对象为Iyerator，也称为游标。</p><h3 id="外部与内部，哪一个更好"><a href="#外部与内部，哪一个更好" class="headerlink" title="外部与内部，哪一个更好"></a>外部与内部，哪一个更好</h3><p>它们都有方便的一面，也都有不方便的另一面。</p><h3 id="内部迭代器的缺陷"><a href="#内部迭代器的缺陷" class="headerlink" title="内部迭代器的缺陷"></a>内部迭代器的缺陷</h3><p>内部迭代器不能同时进行多个循环，也就无法实现按顺序比较两个集合元素的处理。</p><h3 id="外部迭代器的缺陷"><a href="#外部迭代器的缺陷" class="headerlink" title="外部迭代器的缺陷"></a>外部迭代器的缺陷</h3><p>外部迭代器的缺陷在于迭代器对象需要引用集合对象的内部信息，为了按顺序访问集合对象的各个元素，迭代器需要访问集合的内部构造，破坏了隐藏集合内部构造的封装性原则。</p><h2 id="设计模式（2）"><a href="#设计模式（2）" class="headerlink" title="设计模式（2）"></a>设计模式（2）</h2><h3 id="模式与动态语言的关系"><a href="#模式与动态语言的关系" class="headerlink" title="模式与动态语言的关系"></a>模式与动态语言的关系</h3><p>《设计模式》一书中介绍了23个设计模式。这些设计模式可分为3大类：（1）有关生成的模式（5个），有关构造的模式（7个）以及有关行为的模式（11个）。Singleton为（1），Proxy为（2），Iterayor为（3）。</p><h3 id="重复使用既存对象的Protoype模式"><a href="#重复使用既存对象的Protoype模式" class="headerlink" title="重复使用既存对象的Protoype模式"></a>重复使用既存对象的Protoype模式</h3><p>Protoype（原型）模式明确一个实例作为要生成对象的种类原型，通过复制该实例来生成新的对象。<br>在需要新种类对象时，首先复制一个既存的对象，给复制的对象直接增加方法或实例变量等功能，生成最初的第一个新种类对象。最初一个也并不特别，只是偶尔被用来复制而已。<br>相对于类模式编程，原型模式的编程构成元素比较少，具有简单实现面向对象功能设计的倾向，JavaScript的面向对象就是原型模式。io语言也是。</p><h3 id="亲身体验IO语言"><a href="#亲身体验IO语言" class="headerlink" title="亲身体验IO语言"></a>亲身体验IO语言</h3><h3 id="Ruby中的原型"><a href="#Ruby中的原型" class="headerlink" title="Ruby中的原型"></a>Ruby中的原型</h3><p>基本上讲Ruby是类模式的语言，但也拥有支持原型模式编程功能。</p><ol><li>复制对象的clone方法</li><li>给个别对象增加方法的特意方法功能</li><li>给个别对象增加一组功能的extend方法</li></ol><p>静态语言中没有原型编程，因为不可能给复制的对象增加新方法。</p><h3 id="编写抽象算法的Template-Method模式"><a href="#编写抽象算法的Template-Method模式" class="headerlink" title="编写抽象算法的Template Method模式"></a>编写抽象算法的Template Method模式</h3><h3 id="用Ruby来尝试Template-Method"><a href="#用Ruby来尝试Template-Method" class="headerlink" title="用Ruby来尝试Template Method"></a>用Ruby来尝试Template Method</h3><p>Ruby的类库中最大限度灵活运用Template Method模式的部分，应该是Enumerable模块和Comparable模块了。</p><h3 id="动态语言与Template-Method模式"><a href="#动态语言与Template-Method模式" class="headerlink" title="动态语言与Template Method模式"></a>动态语言与Template Method模式</h3><p>Template Method模式的这种优秀性质与语言是不是静态没有关系。</p><h3 id="避免高度依赖性的Observer模式"><a href="#避免高度依赖性的Observer模式" class="headerlink" title="避免高度依赖性的Observer模式"></a>避免高度依赖性的Observer模式</h3><p>Observer（观察者）模式是当某个对象的状态发生变化时，依存于该状态的全部对象都自动得到通知，而且为了让它们都得到通知，定义了对象间一对多的依存关系。<br>这是控制类与类之间依存关系的一种模式。<br>高度依赖性会导致组成程序的零件过大，避免高度依赖性的Observer模式，构成观察者模式的有两个对象，一个称谓Observer（观察者）接受变更通知；另一个称为Subject（对象）或Observable（被观察者），发出变更通知。<br>被观察者让人得到被动的印象，在实际处理中，被观察者会发出通知“我已经变化了哦”。</p><h3 id="Observable模块"><a href="#Observable模块" class="headerlink" title="Observable模块"></a>Observable模块</h3><p>Ruby中为实现Observer模式提供了名为observer的库。observer库提供observer模块。</p><h3 id="Observer模式与动态语言"><a href="#Observer模式与动态语言" class="headerlink" title="Observer模式与动态语言"></a>Observer模式与动态语言</h3><p>由于Ruby的动态性质，Observer库具有以下几方面的灵活性。</p><ol><li>观察者类不必是特定类的子类。</li><li>观察者类不必实现特定的接口（本来在Ruby中也没有接口）</li><li>观察者类的更新方法名可以自由决定</li><li>观察者类更新方法的参数可以自由决定</li><li>被观察者类不必是特定类的子类</li><li>对被观察者类的要求，只是将Observable模块包括进来。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说到事件监听模式,很容易将它和观察者模式联系在一起。</span><br><span class="line">实质上这两者完成同类型的工作。依个人理解，事件监听模式更像是观察者模式的进阶。</span><br><span class="line">事件监听机制就是对观察者模式进行了进一步抽象，节省了代码量。</span><br></pre></td></tr></table></figure><h2 id="设计模式（3）"><a href="#设计模式（3）" class="headerlink" title="设计模式（3）"></a>设计模式（3）</h2><h3 id="软件开发的悲剧"><a href="#软件开发的悲剧" class="headerlink" title="软件开发的悲剧"></a>软件开发的悲剧</h3><ol><li>复杂性</li><li>变化性</li></ol><p>软件的规模越大，各个部分之间的牵连越复杂，更改也就越难。<br>在软件开发过程中，需求变更几乎是不可避免的。</p><h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p><strong>对模块扩展必须开放，对修改必须封闭。</strong><br>为了应对将来的需要，扩展必须是开放的，但是即使某一模块的内部结构改变了，对外接口也应当是不变的。简称OCP。</p><h3 id="面向对象的情况"><a href="#面向对象的情况" class="headerlink" title="面向对象的情况"></a>面向对象的情况</h3><p>既要开放，又要封闭，看似互相矛盾，但是<strong>面向对象编程语言能够很彻底地消除这个矛盾。</strong></p><h3 id="非面向对象的情况"><a href="#非面向对象的情况" class="headerlink" title="非面向对象的情况"></a>非面向对象的情况</h3><p>非面向对象则很难处理好。<br><strong>面向对象的精髓在于对OCP的实践。至于把对象看做物体理解起来比较容易，能够建立现实世界的模型等，不过是锦上添花。</strong></p><h3 id="OCP与Template-Method模式"><a href="#OCP与Template-Method模式" class="headerlink" title="OCP与Template Method模式"></a>OCP与Template Method模式</h3><p>虽说使用面向对象语言的功能，可以实现OCP，但是只是说有这种可能性，并不是说什么时候都能实现。当然，虽然使用了面向对象语言，却做成了一个糟糕的设计，这种情况也是屡见不鲜。<br>分类中很多设计模式之所以优秀是因为经得起OCP所要求的变化。<br>Template Method模式，是满足OCP的基本手段。其他的设计模式都是利用多个类的关联来实现的，而Template Method模式则仅仅使用了继承，基本上无非是实现了一个抽象类。</p><h3 id="Observer模式"><a href="#Observer模式" class="headerlink" title="Observer模式"></a>Observer模式</h3><p>Observer模式是满足OCP的。<br>DRY也好，OCP也好，都不过是原则，根据具体情况，要做适当的选择，如果代码没有再利用的打算，也没有扩展功能的打算，也就没有必要生搬硬套设计模式。使用前有必要先做判断。</p><h3 id="使用Strategy模式"><a href="#使用Strategy模式" class="headerlink" title="使用Strategy模式"></a>使用Strategy模式</h3><p>Strategy（策略）模式是定义算法的集合，将各算法封装，使它们能够交换。利用Strategy模式，算法和利用这些算法的客户程序可以分别独立进行修改而不互相影响。<br>Strategy模式就是将容易变化的处理归纳为独立的对象，然后使它们能够互相交换，使用方法与将容易变化的处理交给子类的Template Method模式相类似。两个模式最大的区别在于，Strategy模式是独立的对象，能够动态交换处理逻辑。</p><h3 id="Strategy模式与OCP"><a href="#Strategy模式与OCP" class="headerlink" title="Strategy模式与OCP"></a>Strategy模式与OCP</h3><p>Strategy模式完全满足OCP。<br>世上很多设计模式，为了能应对将来可能的修改，都是按照OCP的要求来设计的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-4-设计模式&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-4-设计模式&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 4 设计模式&quot;&gt;&lt;/a&gt;松本行弘的程序世界 4 设计模式&lt;/h1&gt;&lt;h2 id=&quot;设计模式（1）&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 3 程序块</title>
    <link href="https://github.com/zdkswd/2018/07/09/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%203%20%E7%A8%8B%E5%BA%8F%E5%9D%97/"/>
    <id>https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 3 程序块/</id>
    <published>2018-07-09T02:21:32.000Z</published>
    <updated>2018-07-11T02:11:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-3-程序块"><a href="#松本行弘的程序世界-3-程序块" class="headerlink" title="松本行弘的程序世界 3 程序块"></a>松本行弘的程序世界 3 程序块</h1><h2 id="程序块的威力"><a href="#程序块的威力" class="headerlink" title="程序块的威力"></a>程序块的威力</h2><p>Ruby的特色功能之一——程序块。Ruby的程序块是指在方法调用时可以追加的代码块。</p><h3 id="把函数作为参数的高阶函数"><a href="#把函数作为参数的高阶函数" class="headerlink" title="把函数作为参数的高阶函数"></a>把函数作为参数的高阶函数</h3><p>高阶函数是指以函数作为参数的函数。<br>为了实现高阶函数，编程语言中必须把函数和方法作为数据来处理。</p><h3 id="C语言高阶函数的局限"><a href="#C语言高阶函数的局限" class="headerlink" title="C语言高阶函数的局限"></a>C语言高阶函数的局限</h3><p>在C语言中，实现函数间的信息传递只有两种方法：要么明确地传递参数，要么使用全局变量，没有其他方法。<br>如果使用全局变量来传递信息，就搞不清楚什么时候、谁在引用或者更新这一变量。除了全局变量之外，没有别的办法在函数间共享信息，这是C语言的局限。</p><h3 id="可以保存外部环境的闭包"><a href="#可以保存外部环境的闭包" class="headerlink" title="可以保存外部环境的闭包"></a>可以保存外部环境的闭包</h3><p>Ruby中，增加了引用函数外部变量的功能。<br>与C语言指针的例子比较，Ruby具有以下两个易于使用的优点：</p><ol><li>可以再使用时定义；</li><li>可以引用外部的局部变量。</li></ol><p>java的匿名类和C语言的函数指针也能实现同样的功能，但是没有那么简洁。<br>在块中可以引用外部局部变量的方法，这说明不只是简单的程序代码，而且把外部“环境”也包括进来，像这样的块叫做闭包。通常的局部变量在方法执行结束时就不存在了，但如果被包括进了闭包，闭包存在期间，局部变量也会一直存在。</p><h3 id="块的两种使用方法"><a href="#块的两种使用方法" class="headerlink" title="块的两种使用方法"></a>块的两种使用方法</h3><p>Ruby的块是可以追加给调用方法的代码块，块自身不是对象（对象化后的块是闭包）。参数传递的方法和普通函数不同。<br>在被调用的方法中有两种方式来使用传递过来的块。一种是用“块参数”的方式明确声明接受块作为参数，另一种是使用<strong>yield</strong>这个Ruby的保留词。<br>块作为参数具有三个优点：</p><ol><li>明确表示了块处理</li><li>块和对象一样被统一处理</li><li>检查参数是否为nil就可以判断出是否传递了块参数。</li></ol><p>另外，yield具有下面两个优点：</p><ol><li>没有用到闭包，执行速度少快</li><li>错误提示信息比较容易理解</li></ol><h3 id="最终来看，块到底是什么"><a href="#最终来看，块到底是什么" class="headerlink" title="最终来看，块到底是什么"></a>最终来看，块到底是什么</h3><p>Ruby的块具有以下三个特点：</p><ol><li>代码块可以作为参数传递给方法</li><li>在被调用的方法中可以执行传递过来的代码块，执行后程序的控制权返还给方法。</li><li>块中最后执行的算式的值是块的值，这个值可以返回给方法。</li></ol><p>块也可以被看做只是高阶函数的一种特殊形式的语法。虽然只是稍作改进，但Ruby中块的各种灵活应用的方法还是让人赞叹不已。</p><h3 id="块在循环处理中的应用"><a href="#块在循环处理中的应用" class="headerlink" title="块在循环处理中的应用"></a>块在循环处理中的应用</h3><p>最典型的用法是，在逐个处理集合对象的元素的方法中使用块。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-06%20%E4%B8%8A%E5%8D%8811.19.23.png" alt="屏幕快照 2018-07-06 上午11.19.23" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-06 上午11.19.23</div>            </figure></p><p>Ruby中几乎所有的容器类都有each这个方法。使用这个方法可以循环处理容器类中的所有元素。<br>也可以用for语句来实现each方法。<br>本来，Ruby就是为了要实现循环功能才导入了块。所以，在以前的文档中把具有块的方法称为迭代器（iterator）。iterate就是循环、迭代的意思。但是，如今块的应用范围比当初所能想到的要广泛的多，和循环没有关系的处理中也大量的用到块。所以现在仍把块称为迭代器就很不恰当了。</p><h3 id="内部迭代器和外部迭代器"><a href="#内部迭代器和外部迭代器" class="headerlink" title="内部迭代器和外部迭代器"></a>内部迭代器和外部迭代器</h3><p>像Ruby块这样，把对各个元素的处理逻辑传送给容器类的方法，然后在方法中对容器类中每个元素调用指定的处理逻辑，这种迭代方式称为内部迭代器的方式。<br>与之对应，C++和java中所谓的迭代器，是用别的类对象来循环处理容器中的元素，这种循环处理的方式称为外部迭代器方式。在外部迭代器方式中，把顺序取出容器中元素对象称为迭代器，也称为游标。<br>内部迭代器不用额外生成类，使用和实现都很简单，但是，对于不支持闭包的编程语言，想要拥有循环外部的信息就要费些功夫。外部迭代器可以简单地处理从多个容器中逐个取出数据进行并行处理。<br>从设计模式来看，内部迭代器是访问者模式，外部迭代器是迭代器模式。</p><h3 id="在排序和比较大小中的应用"><a href="#在排序和比较大小中的应用" class="headerlink" title="在排序和比较大小中的应用"></a>在排序和比较大小中的应用</h3><h3 id="用块保证程序的后处理"><a href="#用块保证程序的后处理" class="headerlink" title="用块保证程序的后处理"></a>用块保证程序的后处理</h3><h3 id="用块实现新的控制结构"><a href="#用块实现新的控制结构" class="headerlink" title="用块实现新的控制结构"></a>用块实现新的控制结构</h3><p>用块的话，不需要改变文法，就可以控制结构的定义。</p><h3 id="在回调中使用块"><a href="#在回调中使用块" class="headerlink" title="在回调中使用块"></a>在回调中使用块</h3><h3 id="块处理的特别理由"><a href="#块处理的特别理由" class="headerlink" title="块处理的特别理由"></a>块处理的特别理由</h3><p>ruby的块具有以下特点：</p><ol><li>在普通参数以外，另外被传送；</li><li>块不是对象（lambda方法可以作闭包对象化）。</li></ol><p>其他具有闭包功能的编程语言，比如Lisp和Smalltalk，它们没有这样的区别，总是把闭包作为对象来处理。Ruby作了改进，因为：</p><ol><li>减少对象的生成数。初期Ruby生成闭包对象的代价很高，所以尽量避免了闭包对象的生成。即使是真正必要的对象，也尽量延迟到必要的时候才生成。</li><li>外观上的理由。</li></ol><p>调用方法时只能用一个块，是Ruby中的一个限制，但实际情况中也几乎没有必要使用多个块。</p><h2 id="用块做循环"><a href="#用块做循环" class="headerlink" title="用块做循环"></a>用块做循环</h2><p>Ruby的块本来就是在循环的抽象化过程中诞生的。现在除了循环以外，在其他一些场合也得到广泛应用，但这并未有改变其实现循环的初衷。</p><h3 id="块是处理的集合"><a href="#块是处理的集合" class="headerlink" title="块是处理的集合"></a>块是处理的集合</h3><p>循环是程序的基本元素。从结构化编程的原理来说，所有算法都是有顺序、分支和循环的组合来实现的。可以说处理好了循环，也就处理好了程序。<br>Ruby也用while循环，但是循环还有其他更为深奥的表现形式。<br>Ruby中有until语句。<br>块是处理的集合。Ruby中，在方法调用的最后，可以附加上块。<br>Ruby的简洁性不只体现在程序简短，更重要的是体现在对本质问题的处理，使程序更为灵活。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%20%E4%B8%8A%E5%8D%889.00.34.png" alt="屏幕快照 2018-07-09 上午9.00.34" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-09 上午9.00.34</div>            </figure><br>第二行大括号中的部分是块，这行程序是作为参数来调用数组的each方法。<br>用Ruby实现这种循环非常简单，知识在块调用的地方用yield来指定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%20%E4%B8%8A%E5%8D%889.08.46.png" alt="屏幕快照 2018-07-09 上午9.08.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-09 上午9.08.46</div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个方法的定义，在方法内部有yield的出现；在方法的调用处会有程序块的出现。</span><br></pre></td></tr></table></figure></p><p>也可以用do-end来定义块。大括号和do-end基本是一样的。但是，在块是多行时。用do-end结构统一性更好一些。</p><ol><li>块是一行的时候用大括号，是多行的时候用do-end;</li><li>块作为表达式的一部分，给方法返回值时用大括号，块作为处理语句或程序流程控制时用do-end。<br>大括号的优先级更高。</li></ol><p><strong>在省略括号调用方法时，一定要注意块的结合优先顺序。</strong></p><h3 id="块应用范围的扩展"><a href="#块应用范围的扩展" class="headerlink" title="块应用范围的扩展"></a>块应用范围的扩展</h3><p>当时块主要使用在循环里。<br>在Ruby中不必特别的结构，在任意的方法中都可以使用块，所以不仅仅在循环中，块在各种各样的领域中都得到了应用。</p><h3 id="高阶函数和块本质一样"><a href="#高阶函数和块本质一样" class="headerlink" title="高阶函数和块本质一样"></a>高阶函数和块本质一样</h3><p>编程语言要实现高阶函数，就必须把函数或者方法作为数据来处理。反之，具有这样功能的编程语言就可以利用高阶函数。<br>可以把块看做高阶函数调用，只能有一个函数参数。<br>事实上，在高阶函数中94%都只有一个函数参数，有两个以上函数参数是极少的。Ruby以更易于使用的形式，把只有一个函数参数的情形在语法上加以特殊处理，导入了块功能。</p><h3 id="用Enumerable来利用块"><a href="#用Enumerable来利用块" class="headerlink" title="用Enumerable来利用块"></a>用Enumerable来利用块</h3><p>把块应用于循环抽象化的，最典型的应该是Enumerable模块。Enumerable模块以each方法为基础，定义了each方法的类提供了多种功能。如果继承（Mix-in）了这个模块，就可以很方便地利用它的各种功能。<br>Enumberable的意思是可数的。它是对数组等各种集合元素做循环处理的方法的集成。可大致分为：</p><ol><li>循环</li><li>指定条件</li><li>排序、比较大小</li></ol><h3 id="Enumerable的局限"><a href="#Enumerable的局限" class="headerlink" title="Enumerable的局限"></a>Enumerable的局限</h3><ol><li>循环都依赖each方法，而且不能并行执行。</li><li>Enumerable可以用each方法简单的实现循环，反过来也是一个局限。</li></ol><h2 id="精通集合的使用"><a href="#精通集合的使用" class="headerlink" title="精通集合的使用"></a>精通集合的使用</h2><h3 id="使用Ruby的数组"><a href="#使用Ruby的数组" class="headerlink" title="使用Ruby的数组"></a>使用Ruby的数组</h3><p>在动态语言ruby中，集合可以混合存在各种类型的对象，所以可以定义复杂得数组。</p><h3 id="修改指定范围的元素的内容"><a href="#修改指定范围的元素的内容" class="headerlink" title="修改指定范围的元素的内容"></a>修改指定范围的元素的内容</h3><p>和C语言、java语言相比，ruby的数组具有以下特点。</p><ol><li>Ruby的数组是对象，可以调用各种方法。</li><li>用【】访问数组实际上是方法调用。【】是方法名，里面的值是参数。</li><li>变更数组元素实际上也是方法调用。【】=是方法名，里面和右边的值是参数。</li></ol><h3 id="Ruby中的哈希处理"><a href="#Ruby中的哈希处理" class="headerlink" title="Ruby中的哈希处理"></a>Ruby中的哈希处理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308432341402/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%20%E4%B8%8A%E5%8D%889.55.21.png" alt="屏幕快照 2018-07-09 上午9.55.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-09 上午9.55.21</div>            </figure><h3 id="支持循环的Enumerable"><a href="#支持循环的Enumerable" class="headerlink" title="支持循环的Enumerable"></a>支持循环的Enumerable</h3><p>Ruby中提供的方法可以更好地发挥集合的作用。<br>Ruby中，集合的功能都定义在Enumerable这个Mix-in中了。从另一个角度来说，只要把Enumerable模块通过Mix-in继承进来，就可以使用集合对象的大量方法了。</p><h3 id="用于循环的each方法"><a href="#用于循环的each方法" class="headerlink" title="用于循环的each方法"></a>用于循环的each方法</h3><p>在Enumerable中没有定义each方法，反之，Enumerable中所有方法都是在内部调用each方法实现的。</p><h3 id="使用inject、zip和grep"><a href="#使用inject、zip和grep" class="headerlink" title="使用inject、zip和grep"></a>使用inject、zip和grep</h3><p>inject是用块吧各个元素结合起来。<br>zip是从多个集合并行取得元素的方法。<br>grep方法可以对集合中的元素进行模式匹配。</p><h3 id="用来指定条件的select方法"><a href="#用来指定条件的select方法" class="headerlink" title="用来指定条件的select方法"></a>用来指定条件的select方法</h3><p>对集合的各个元素进行块处理的是循环类型的方法。和它相对的，对各个元素进行块处理，用快处理的结果作为下个处理的判定条件的是条件指定型方法。<br>条件指定型方法中最常用的是select方法。select方法把快处理结果为真的元素存放在数组中返回。</p><h3 id="排序与比较大小"><a href="#排序与比较大小" class="headerlink" title="排序与比较大小"></a>排序与比较大小</h3><h3 id="在类中包括（include）Enumerable模块"><a href="#在类中包括（include）Enumerable模块" class="headerlink" title="在类中包括（include）Enumerable模块"></a>在类中包括（include）Enumerable模块</h3><h3 id="列表内包表达式和块的区别"><a href="#列表内包表达式和块的区别" class="headerlink" title="列表内包表达式和块的区别"></a>列表内包表达式和块的区别</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-3-程序块&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-3-程序块&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 3 程序块&quot;&gt;&lt;/a&gt;松本行弘的程序世界 3 程序块&lt;/h1&gt;&lt;h2 id=&quot;程序块的威力&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>艺术的力量 卡拉瓦乔</title>
    <link href="https://github.com/zdkswd/2018/07/06/%E8%89%BA%E6%9C%AF%E7%9A%84%E5%8A%9B%E9%87%8F%20%E5%8D%A1%E6%8B%89%E7%93%A6%E4%B9%94/"/>
    <id>https://github.com/zdkswd/2018/07/06/艺术的力量 卡拉瓦乔/</id>
    <published>2018-07-06T09:56:20.000Z</published>
    <updated>2018-07-06T09:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="艺术的力量-卡拉瓦乔"><a href="#艺术的力量-卡拉瓦乔" class="headerlink" title="艺术的力量 卡拉瓦乔"></a>艺术的力量 卡拉瓦乔</h1><p>这个天才，是个恶人<br>教堂寻寻觅觅及卡拉瓦乔生来注定要做的，就是在罪人的生命中找到超凡入圣之处。<br>卡拉瓦乔笔下的主角不是圣人，而是罪人。<br>这名画家，对穷苦信徒的处境感身受<br>他艺术的力量来自于真实的力量，其中包括了对自身真相的觉醒。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308705069360.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>青年音乐家 1595</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308687397847.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>自比酒神的自画像</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308699610387.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>赌博</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308687531515.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>圣母之死</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308701803968.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>圣母玛利亚</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308685944948.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>男孩与水果篮</p><p>有人说他是艺术天才，也有人说他是血性魔鬼，他的一生可以说就是一部历险记。<br>卡拉瓦乔出生在米兰，家庭状况还阔以，爸妈在当时有点名气和地位。在卡拉瓦乔5岁的时候发生了一场瘟疫，为了躲避瘟疫，他们全家搬离了米兰。<br>但不幸还是发生了，他的爸爸和爷爷都感染了这种瘟疫，并在同一天去世了，生活的重担就都落到他妈妈一个人身上，那时候的卡拉瓦乔才6岁。<br>等到他卡拉瓦乔13岁时候，妈妈也离开了这个世界，于是他就成了孤儿。<br>也就是在妈妈去世那一年，卡拉瓦乔开始跟着意大利画家西蒙·彼得扎诺学画画，一画就是四年，期间他也看了很多大师的作品，比如达芬奇的最后的晚餐啥的，增加了对艺术的了解。<br>画家靠自己是很难的，因为你要搞商业你就无心创作，毕竟一个人的精力有限，所以需要钱的帮助，就是一定资金上的支持…卡拉瓦乔的命就很好。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308703755249.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>多疑的thomas</p><p> <img src="/img/media/15308499185596/15308692736469.jpg" alt=""><br>召唤使徒马太</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308696988306.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>马太的殉难</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15308499185596/15308698384972.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>手提歌利亚头的大卫</p><p>画中的男子手里提的，正是卡拉瓦乔的头。</p><p>意大利画家卡拉瓦乔，作为一个被通缉的画家，常年过着颠沛流离的逃亡生活。<br>罪行满满的卡拉瓦乔最终想回到那个让他登上巅峰的罗马，但是他在那里杀过人啊，所以他决定画一幅画讨掌权者的欢心…… </p><p><img src="/img/media/15308499185596/15308707756929.jpg" alt=""><br>被斩首的施洗约翰</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;艺术的力量-卡拉瓦乔&quot;&gt;&lt;a href=&quot;#艺术的力量-卡拉瓦乔&quot; class=&quot;headerlink&quot; title=&quot;艺术的力量 卡拉瓦乔&quot;&gt;&lt;/a&gt;艺术的力量 卡拉瓦乔&lt;/h1&gt;&lt;p&gt;这个天才，是个恶人&lt;br&gt;教堂寻寻觅觅及卡拉瓦乔生来注定要做的，就是在罪人的
      
    
    </summary>
    
      <category term="纪录片" scheme="https://github.com/zdkswd/categories/%E7%BA%AA%E5%BD%95%E7%89%87/"/>
    
    
      <category term="艺术" scheme="https://github.com/zdkswd/tags/%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界 2 面向对象</title>
    <link href="https://github.com/zdkswd/2018/07/05/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%202%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/</id>
    <published>2018-07-05T14:14:32.000Z</published>
    <updated>2018-07-25T02:33:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界-2-面向对象"><a href="#松本行弘的程序世界-2-面向对象" class="headerlink" title="松本行弘的程序世界 2 面向对象"></a>松本行弘的程序世界 2 面向对象</h1><h2 id="编程和面向对象的关系"><a href="#编程和面向对象的关系" class="headerlink" title="编程和面向对象的关系"></a>编程和面向对象的关系</h2><p>计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。</p><h3 id="颠倒的构造"><a href="#颠倒的构造" class="headerlink" title="颠倒的构造"></a>颠倒的构造</h3><p>程序员要夺得主动权。</p><h3 id="主宰计算机的武器"><a href="#主宰计算机的武器" class="headerlink" title="主宰计算机的武器"></a>主宰计算机的武器</h3><p>为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。</p><h3 id="怎样写程序"><a href="#怎样写程序" class="headerlink" title="怎样写程序"></a>怎样写程序</h3><p>编程风格 算法 数据结构 设计模式 开发方法</p><h3 id="面向对象的编程方法"><a href="#面向对象的编程方法" class="headerlink" title="面向对象的编程方法"></a>面向对象的编程方法</h3><p>smalltalk为面向对象编程语言之母。</p><h3 id="面向对象的难点"><a href="#面向对象的难点" class="headerlink" title="面向对象的难点"></a>面向对象的难点</h3><p>面向对象编程语言中最重要的技术是“多态性”。</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态就是可以把不同种类的东西当做相同的东西处理。<br>操作对象是三个箱子，分别是盖着盖子的箱子、加了锁的箱子、系着彩带的箱子。在编程中，“打开箱子”的命令，称之为消息；打开不同箱子的具体操作，称之为方法。</p><h3 id="具体的程序"><a href="#具体的程序" class="headerlink" title="具体的程序"></a>具体的程序</h3><p>调用box_open这个方法，根据参数（箱子的种类）的不同做相应的处理。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.11.02.png" alt="屏幕快照 2018-07-04 上午8.11.02" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-04 上午8.11.02</div>            </figure></p><p>但是如果增加种类代码就要重写，修改的地方越来越多，追加箱子的种类就会变得非常困难。<br>修改程序，实现真正的多态。“.”可以理解为“给前面的式子的值发送一个open消息”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8A%E5%8D%888.14.46.png" alt="屏幕快照 2018-07-04 上午8.14.46" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-04 上午8.14.46</div>            </figure></p><h3 id="多态性的优点"><a href="#多态性的优点" class="headerlink" title="多态性的优点"></a>多态性的优点</h3><p>首先，各种数据可以统一地处理。关注要处理什么，而不是怎么处理。<br>其次，根据对象选择方法，程序内部不会冲突。减轻程序员的负担。<br>再次，新数据简单的追加可以实现，不需要改动以前程序，具备了扩展性。</p><h2 id="数据抽象和继承"><a href="#数据抽象和继承" class="headerlink" title="数据抽象和继承"></a>数据抽象和继承</h2><p>面向对象编程的三原则：<strong>多态性</strong>，<strong>数据抽象</strong>，<strong>继承</strong>。别称：多态性：动态绑定，数据抽象：信息隐藏或封装。</p><h3 id="面向对象的历史"><a href="#面向对象的历史" class="headerlink" title="面向对象的历史"></a>面向对象的历史</h3><h4 id="simula的“发明”"><a href="#simula的“发明”" class="headerlink" title="simula的“发明”"></a>simula的“发明”</h4><p>面向对象编程思想起源于瑞典20世纪60年代后期发展起来的模拟编程语言Simula。以前，表示模拟对象的数据和实际的模拟方法是互相独立的，需要分别管理。</p><h4 id="Smalltalk的发展"><a href="#Smalltalk的发展" class="headerlink" title="Smalltalk的发展"></a>Smalltalk的发展</h4><p>smalltalke的开发宗旨是“让儿童也可以使用”，吸收了Simula的面向对象思想，且独居一格。不仅如此，还有一个很好的图形用户界面。使得世人开始了解面向对象编程的概念。</p><h4 id="Lisp的发展"><a href="#Lisp的发展" class="headerlink" title="Lisp的发展"></a>Lisp的发展</h4><p>许多重要的面向对象的概念都是从Lisp的面向对象功能中诞生的。</p><h4 id="和c语言的相遇"><a href="#和c语言的相遇" class="headerlink" title="和c语言的相遇"></a>和c语言的相遇</h4><p>C++是直接受到了simula语言的影响而没有受到smalltalk多大影响。</p><h4 id="Java的诞生"><a href="#Java的诞生" class="headerlink" title="Java的诞生"></a>Java的诞生</h4><p>java语言放弃了和C语言的兼容性，并增加了Lisp语言中一些好的功能。此外，通过Java虚拟机（JVM），java程序可以不用重新编译而在所有操作系统中运行。<br>Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p><h3 id="复杂性是面向对象的敌人"><a href="#复杂性是面向对象的敌人" class="headerlink" title="复杂性是面向对象的敌人"></a>复杂性是面向对象的敌人</h3><p>软件开发的最大敌人是复杂性。人类的大脑无法做台复杂得处理，记忆力和理解力也是有限的。<br>在计算机性能这么高的今天，人们为了找到迅速开发大规模复杂软件的方法，哪怕牺牲一些性能也在所不辞。</p><h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><p>如果不考虑黑盒内部的处理，系统复杂性就可以降低到人类的可控范围内。针对程序控制流的复杂问题，结构化编程采用看限制和抽象化的武器解决问题。</p><h3 id="数据抽象化"><a href="#数据抽象化" class="headerlink" title="数据抽象化"></a>数据抽象化</h3><p>数据抽象是数据和处理方法结合。对数据内容的处理和操作，必须通过实先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。<br>比如说栈。<br>有了数据抽象，程序处理的数据就不再是单纯的数值或者文字这些概念性的东西，而变成了人脑容易想象的具体事物。而代码的“抽象化”则是把想象的过程“具体化”了。</p><h3 id="雏形"><a href="#雏形" class="headerlink" title="雏形"></a>雏形</h3><p>同样的对象大量存在时，为避免重复，可以采用两种方法管理对象。</p><ol><li>原型。用原始对象的副本来作为新的相同的对象，JS用的原型。</li><li>模板，称为类。<br>跟原型不同，面向对象编程语言的类和对象有明显区别。对象又称作实例。</li></ol><h3 id="找出相似的部分来继承"><a href="#找出相似的部分来继承" class="headerlink" title="找出相似的部分来继承"></a>找出相似的部分来继承</h3><p>类的增多会用到很多性质相似的类。这就违背了我们的DRY（Don’t Repeat Yourself）原则。把这些相似的部分汇总到一起就好了。<br>继承就是这种方法。子类继承父类所有方法，如有需要可以增加新的方法，也可以重写父类方法。<br>Ruby跟多数编程语言一样，一个子类只能有一个父类，即单一继承，C++、Lisp等编程语言中，一个子类可以有多个父类，这称为“多重继承”。</p><h2 id="多重继承的缺点"><a href="#多重继承的缺点" class="headerlink" title="多重继承的缺点"></a>多重继承的缺点</h2><p>继承的原本目的实际上是逐步细化。所以为解决抽出类中相似部分的问题并不完全准确。</p><h3 id="为什么需要多继承"><a href="#为什么需要多继承" class="headerlink" title="为什么需要多继承"></a>为什么需要多继承</h3><p>一个程序员也可能是一个作家。</p><h3 id="多重继承和单一继承不可分离"><a href="#多重继承和单一继承不可分离" class="headerlink" title="多重继承和单一继承不可分离"></a>多重继承和单一继承不可分离</h3><p>单一继承的特点：</p><ol><li>继承关系单纯，有利有弊</li></ol><p>多重继承的特点：</p><ol><li>很自然的做到了单一继承的扩展。</li><li>可以继承多个类的功能。<br>单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系变得复杂。这是多重继承的一个缺点。</li></ol><h3 id="goto语句和多重继承比较相似"><a href="#goto语句和多重继承比较相似" class="headerlink" title="goto语句和多重继承比较相似"></a>goto语句和多重继承比较相似</h3><p>多重继承导致的问题：</p><ol><li>结构复杂化</li><li>优先顺序模糊</li><li>功能冲突</li></ol><h3 id="解决多重继承的问题"><a href="#解决多重继承的问题" class="headerlink" title="解决多重继承的问题"></a>解决多重继承的问题</h3><p>继承作为抽象化的手段，是需要实现多重继承功能的，如果一个类只允许抽出一个功能，那么限制就太多了。<br>受限制的多重继承，这个解决或改善多重继承问题的方法出现了，它在Java中被称为接口（interface）,在Lisp或Ruby中是Mix-in。</p><h3 id="静态语言与动态语言的区别"><a href="#静态语言与动态语言的区别" class="headerlink" title="静态语言与动态语言的区别"></a>静态语言与动态语言的区别</h3><p>编程语言可以分为静态语言和动态语言两种。像Java这样规定变量和算式类型的语言称为静态语言。<br>在静态语言中，不能给变量赋不同类型的值，会导致编译错误，不通过执行就可以发现类型不匹配是静态语言的一个优点。<br>如果只能给一个变量赋值同类对象，就不可能根据对象的类自动选择合适的处理方式（多态性）。</p><h3 id="静态语言的特点"><a href="#静态语言的特点" class="headerlink" title="静态语言的特点"></a>静态语言的特点</h3><p>当给一个类变量赋值时，既可以用这个类的对象来赋值，也可以用这个类的子类对象来赋值。这样就可以实现多态性。<br>但是这时，如果定义了父类变量，赋值子类对象，变量不能调用子类特有的方法。</p><h3 id="动态语言的特点"><a href="#动态语言的特点" class="headerlink" title="动态语言的特点"></a>动态语言的特点</h3><p>动态语言允许调用没有继承关系的方法。静态语言中只能调用有继承关系的方法，数组、哈希表和字符串都能调用的方法，只能是在它们共同的父类（恐怕是Object）中定义。<br>在静态语言中，如果要调用类层次中平行类的方法，那么必须要有一个可以表现这些对象的类型。如果没有这个类型，可调用的方法是十分有限的。由此我们看到静态语言中某种形式的多重继承是不可少的。</p><h3 id="静态语言与动态语言的比较"><a href="#静态语言与动态语言的比较" class="headerlink" title="静态语言与动态语言的比较"></a>静态语言与动态语言的比较</h3><p>静态语言即使不通过执行也可以检查出类型是否匹配。但是逐个来定义算式和变量的类型又会使程序变得冗长。只有包含继承关系的类才会具有多态性。<br>对于动态语言来说，静态语言显得限制过多，灵活性差。程序中有没有错误只有执行了才会知道。程序中没有类型定义，这样程序会变得很简洁。只要方法名一样，这些对象可以以相同的方式去处理。这样生产效率会大大提高，这种宽松的编程机制称为Duck Typing（鸭子类型检测）</p><h3 id="继承的两种含义"><a href="#继承的两种含义" class="headerlink" title="继承的两种含义"></a>继承的两种含义</h3><p>继承包括两种含义，一种是“<strong>类都有哪些方法</strong>”，也就是说这个类都支持些什么操作，即规格的继承。<br>另一种是“<strong>类中都用了什么数据结构什么算法</strong>”，也就是实现的继承。<br>静态语言中这两者的区别很重要，动态语言中区别规格的继承和实现的继承意义不大。即使没有继承关系，方法也可以自由地调用。<br>java对两者有很明确的区分，实现的继承用extends来继承父类，规格的继承用implements来指定接口。<br>类是用来指定对象实现的，而接口只是指定对象的外观（都有哪些方法）。类的继承是单一的，implements可以指定多个接口。接口对实现没有任何限制，也就是说，接口可以由跟实现的继承没有任何关系的类来实现。</p><h3 id="接口的缺点"><a href="#接口的缺点" class="headerlink" title="接口的缺点"></a>接口的缺点</h3><p>为了解决多重继承的问题，人们允许了规格的多重继承，但是还是不允许实现多重继承。</p><h3 id="继承实现的方法"><a href="#继承实现的方法" class="headerlink" title="继承实现的方法"></a>继承实现的方法</h3><p>和静态语言Java不同，动态语言本来就没有继承规格这种概念。动态语言需要解决的就是实现的多重继承。<br>Lisp、Perl和Python都提供了多重继承功能，这样就不存在单一继承的问题了。</p><h3 id="从多重继承变形而来的Mix-in"><a href="#从多重继承变形而来的Mix-in" class="headerlink" title="从多重继承变形而来的Mix-in"></a>从多重继承变形而来的Mix-in</h3><p>Mix-in是降低多重继承复杂性的一个技术，最初是在Lisp中开始使用的。按以下规则来限制多重继承：</p><ol><li>通常的继承用单一继承</li><li>第二个以及两个以上的父类必须是Mix-in的抽象类。</li></ol><p>Mix-in类是具有以下特征的抽象类。</p><ol><li>不能单独生成实例</li><li>不能继承普通类</li></ol><h3 id="积极支持Mix-in的Ruby"><a href="#积极支持Mix-in的Ruby" class="headerlink" title="积极支持Mix-in的Ruby"></a>积极支持Mix-in的Ruby</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-04%20%E4%B8%8B%E5%8D%885.39.58.png" alt="屏幕快照 2018-07-04 下午5.39.58" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-04 下午5.39.58</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我理解的接口的作用：接口是一种协议，满足同一接口实际上是告诉计算机你们是满足了同一样协议，你们是有关系的，java以这种方式间接实现了多态。当然可以实现多个接口，抽象为不同的“种类”，这样就相当于某种意义上的”多继承“。</span><br><span class="line"></span><br><span class="line">InterA a;</span><br><span class="line">　　a= new B();</span><br><span class="line">　　a.fun();</span><br><span class="line">　　a = new C();</span><br><span class="line">　　a.fun();</span><br><span class="line">　　bc都实现a的接口</span><br></pre></td></tr></table></figure><h2 id="两个误解"><a href="#两个误解" class="headerlink" title="两个误解"></a>两个误解</h2><ol><li>对象是对现实世界中具体物体的反应，继承是对物体分类的反应。（误）</li><li>多重继承是不好的。Mix-in不错。（误）</li></ol><p>澄清：如果多继承用的不好就会出问题，Mix-in只不过是实现多重继承的一个技巧而已。</p><h3 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a>面向对象的编程</h3><p>不管过去怎样，现在面向对象最好的理解是，面向对象编程是结构化编程的延伸。<br>随着软件的复杂化，开发越来越复杂，Dijkstra提倡把程序控制限制为（1）顺序（2）循环（3）分支 使得程序变得简单且容易理解。<strong>面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上对数据的结构化。</strong><br>面向对象编程，封装（黑盒）和多态（减少分支处理）是提高生产率的技术。<br><strong>结构化编程通过整理数据流，提高程序的生成效率和可维护性。同样，面向对象编程通过对数据结构的整理，提高了程序的生产效率和可维护性。</strong></p><h3 id="对象的模板-类"><a href="#对象的模板-类" class="headerlink" title="对象的模板=类"></a>对象的模板=类</h3><p>类是吧数据黑盒化的工具，由于对类内部的操作都是通过类的方法来实现的，所以内部数据结构即使在以后发生变化，对外部也没有影响。</p><h3 id="利用模板的手段-继承"><a href="#利用模板的手段-继承" class="headerlink" title="利用模板的手段=继承"></a>利用模板的手段=继承</h3><p>类是模块，继承就是利用模块的方法。传统的面向对象编程语言是一下子把规格和实现都继承下来，在最近，有的是把这两种继承分开了。比如java里的接口就是规格继承。</p><h3 id="多重继承不好吗"><a href="#多重继承不好吗" class="headerlink" title="多重继承不好吗"></a>多重继承不好吗</h3><p>单一继承的类之间的关系是很单纯的树结构。但是对于多重继承而言，类之间的关系却是复杂得网状结构。<br><strong>静态语言中可以实现多态性只是局限于拥有共通父类的对象。</strong><br>为了解决这个问题，静态面向对象编程语言的代表<strong>C++支持多重继承</strong>。java也可以通过接口来支持规格的多重继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**静态类型语言**: 是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型，某些具有类型推导能力的现代语言可能能够部分减轻这个要求. </span><br><span class="line">**动态类型语言**: 是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 </span><br><span class="line">**强类型语言**: 是一旦变量的类型被确定，就不能转化的语言。实际上所谓的貌似转化，都是通过中间变量来达到，原本的变量的类型肯定是没有变化的。 </span><br><span class="line">**弱类型语言**: 则反之，一个变量的类型是由其应用上下文确定的。比如语言直接支持字符串和整数可以直接用 + 号搞定。当然，在支持运算符重载的强类型语言中也能通过外部实现的方式在形式上做到这一点，不过这个是完全不一样的内涵</span><br></pre></td></tr></table></figure></p><h3 id="动态编程语言也需要多重继承"><a href="#动态编程语言也需要多重继承" class="headerlink" title="动态编程语言也需要多重继承"></a>动态编程语言也需要多重继承</h3><p>动态编程语言没有类型检查，从这方面来说没有理由用多重继承，但是动态编程语言肯定需要多重继承。<br>实现共享可以通过多个对象的组合（composition）和委托（delegate）来做到。</p><h3 id="驯服多重继承的方法"><a href="#驯服多重继承的方法" class="headerlink" title="驯服多重继承的方法"></a>驯服多重继承的方法</h3><p>多重继承可能引发的问题：</p><ol><li>类关系复杂化</li><li>继承功能名字重复<br>最初的问题是因为类关系从简单的树结构变成了复杂的网状结构。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%889.18.30.png" alt="屏幕快照 2018-07-05 上午9.18.30" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 上午9.18.30</div>            </figure></li></ol><p>父类的优先级并不明确，多重继承设计的一个有效的技巧是Mix-in。用Mix-in做多继承设计时，从第2个父类开始的类要满足以下条件。</p><ol><li>不能单独生成实例的抽象类。</li><li>不能继承Mix-in以外的类。</li></ol><p><strong>抽象类和接口的对比</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.41.50.png" alt="屏幕快照 2018-07-05 上午10.41.50" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 上午10.41.50</div>            </figure></p><p>mix-in的例子<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8A%E5%8D%8810.44.57.png" alt="屏幕快照 2018-07-05 上午10.44.57" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 上午10.44.57</div>            </figure></p><p><strong>通过对功能的分离，多重继承就可以由单一继承加上Mix-in类来实现。</strong>利用Mix-in就可以同时享有单一继承的单纯性和多重继承的共有性。</p><p>对于名字重复问题（如函数名），多重继承编程语言都有自己的应对方法，大致分为以下3种：</p><ol><li>给父类定义优先级</li><li>把重复的名字替换掉</li><li>指定使用类的名字</li></ol><h3 id="ruby中多重继承的实现方法"><a href="#ruby中多重继承的实现方法" class="headerlink" title="ruby中多重继承的实现方法"></a>ruby中多重继承的实现方法</h3><p>Mix-in</p><h3 id="java实现多重继承的方法"><a href="#java实现多重继承的方法" class="headerlink" title="java实现多重继承的方法"></a>java实现多重继承的方法</h3><p>接口。。</p><h2 id="Duck-Typing诞生之前"><a href="#Duck-Typing诞生之前" class="headerlink" title="Duck Typing诞生之前"></a>Duck Typing诞生之前</h2><p>静态是指程序执行之前，从代码中就可以知道一切。程序静态的部分包括变量、方法的名称和类型以及控制程序的结构等等。<br>相对于静态，动态是指在程序执行之前有些地方是不知道的。程序动态的部分包括变量的值、执行时间和使用的内存等等。<br>通常情况下、程序本来就是不被执行就不知道结果的，所以在一定程度上说程序都具有动态特性。因此，严格说静态和动态之间的界限是很微妙的。</p><h3 id="为什么需要类型"><a href="#为什么需要类型" class="headerlink" title="为什么需要类型"></a>为什么需要类型</h3><h3 id="动态的类型是从Lisp中诞生的"><a href="#动态的类型是从Lisp中诞生的" class="headerlink" title="动态的类型是从Lisp中诞生的"></a>动态的类型是从Lisp中诞生的</h3><h3 id="动态类型在面向对象中发展起来了"><a href="#动态类型在面向对象中发展起来了" class="headerlink" title="动态类型在面向对象中发展起来了"></a>动态类型在面向对象中发展起来了</h3><p>对象保存着有关自己种类的信息，某个变量可以用各种类型的数据来赋值，这两点是多态这一面向对象重要特性的必要条件。</p><h3 id="动态类型和静态类型的邂逅"><a href="#动态类型和静态类型的邂逅" class="headerlink" title="动态类型和静态类型的邂逅"></a>动态类型和静态类型的邂逅</h3><p>20世纪80年代，面向对象编程语言主流是包含动态数据类型的语言，但是在21世纪的今天，使用最广泛的面向对象编程语言是具有静态类型的java和c++。<br>受simula很大影响的c++引入了子类对象可以看成是父类对象这个原则，对象也采用了静态类型。<br>根据这个原则，在编译时就可以知道变量或算式的类型，又可以根据执行时的数据类型自动选择合适的处理，从而同时具备了静态类型的优点和动态类型的多态性。</p><h3 id="静态类型的优点"><a href="#静态类型的优点" class="headerlink" title="静态类型的优点"></a>静态类型的优点</h3><ol><li>最大的优点是在编译时能够发现不匹配的错误。</li><li>如果明确指定了数据类型，在编译时可以用到的信息就很多，利用这种信息可以在编译时对程序做优化，提高程序执行速度。</li><li>在读程序时提高理解度，IDE也可以自动补充。</li></ol><p>问题：</p><ol><li>不指定类型就写不了程序，数据类型只是一些辅助信息，并不是程序本质。有的类型声明仅仅是为了满足编译器的要求。程序规模也因为数据类型的定义而变大。</li><li>灵活性问题。静态类型本身限制了给某个变量只能赋值某种类型的对象，这种限制可能成为妨碍将来变化的枷锁。 <h3 id="动态类型的优点"><a href="#动态类型的优点" class="headerlink" title="动态类型的优点"></a>动态类型的优点</h3></li><li>源代码简洁，提高生产力。</li><li>会不会更难以理解，更突出程序处理的实质，程序函数相差几十倍并不少见，理解起来反而简单。</li><li>会不会运行更缓慢，同样的处理，在大多数情况下，静态类型编程语言运行得要快些。这是因为动态类型程序执行时要做类型检查。另外，静态类型的编程语言大都是通过编译把程序源代码转换成可以直接执行的形式，而动态类型的编程语言大多是边解释源代码（转换成内部形式）边执行，这种编译型处理和解释型处理的区别也是影响程序执行速度的愿意之一。</li><li>灵活，灵活性的关键是Duck Typing。</li><li>最大的缺点是不执行就检测不出错误。  </li></ol><h3 id="只关心行为的Duck-Typing"><a href="#只关心行为的Duck-Typing" class="headerlink" title="只关心行为的Duck Typing"></a>只关心行为的Duck Typing</h3><p>If it walks like a duck and quacks like a duck,it must be a duck.（走起路来像鸭子，叫起来也像鸭子，那么他就是鸭子）。<br>根本不考虑一个对象属于什么类，只关心它有什么样的行为（它有哪些方法）。<br><strong>动态语言用Duck Typing的概念设计时需要遵循的原则最低限度是避免明确的类型检查。</strong></p><h3 id="避免明确的类型检查"><a href="#避免明确的类型检查" class="headerlink" title="避免明确的类型检查"></a>避免明确的类型检查</h3><h3 id="克服动态类型的缺点"><a href="#克服动态类型的缺点" class="headerlink" title="克服动态类型的缺点"></a>克服动态类型的缺点</h3><ol><li>执行时才能发现可以用完备的单元测试来解决，如果能严格实行完备的单元测试的话，即使没有编译时的错误检查，程序的可靠性也不会降低。</li><li>读程序时可用到的线索少这一点可以通过完整的文档来解决。可以在源代码中同时写文档，减轻维护文档的负担。</li><li>运行速度慢，随着计算机性能的提升已经不再重要，现在的程序开发中，程序的灵活性和生产力更为重要。</li></ol><h3 id="动态编程语言"><a href="#动态编程语言" class="headerlink" title="动态编程语言"></a>动态编程语言</h3><p>现在我们对程序开发生产力的要求越来越高，也就是说，要在更短的时间内开发出更多的功能。<br>尽快着手开发，快速应对需求变更的开发方式变得越来越重要。<br>在这种快速开发模式中，Duck Typing所代表的执行时的灵活性就非常有用。Ruby、Python、Perl和PHP等优秀的动态类型编程语言，因为它们在执行时所具有的灵活性而越来越受到人们的关注。</p><h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><p>元编程是对程序进行编程的意思。</p><h3 id="元编程-1"><a href="#元编程-1" class="headerlink" title="元编程"></a>元编程</h3><p>利用元编程可以动态生成类的方法，而且重要的是你可以自己编写生成过程，不支持元编程的编程语言实现这样的功能是很麻烦的，要么需要扩展语言的语法，要么用宏定义等预处理方法来实现。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>元编程的反射（reflection）,在编程语言中它是指在程序执行时取出程序的信息或者改变程序的信息。<br>Ruby彻底实现了对程序的动态操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/15306617644212/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-05%20%E4%B8%8B%E5%8D%887.10.21.png" alt="屏幕快照 2018-07-05 下午7.10.21" title="">                </div>                <div class="image-caption">屏幕快照 2018-07-05 下午7.10.21</div>            </figure><h3 id="元编程的例子"><a href="#元编程的例子" class="headerlink" title="元编程的例子"></a>元编程的例子</h3><p>Ruby使用Delegator这个库实现了委托功能，调用对象d的方法时可以转变为调用a的方法。我们还可以给这个对象增加特意方法来改变它的部分行为，这就大大扩展了它的应用范围。</p><h3 id="使用反射功能"><a href="#使用反射功能" class="headerlink" title="使用反射功能"></a>使用反射功能</h3><h3 id="分布式Ruby的实现"><a href="#分布式Ruby的实现" class="headerlink" title="分布式Ruby的实现"></a>分布式Ruby的实现</h3><p>Delegator将被调用的方法直接委派到其他对象，这一功能在很多领域都有应用。如dRuby。<br>dRuby是通过网络来调用方法的库。dRuby可以生成服务器上存在的远程对象（Proxy），Proxy的方法调用可以通过网络执行。<br>调用的方法在服务器上的远程对象中执行，执行结果可以通过网络返回。这和java的RMI(Remote Method Invocation)功能比较相似。但是，利用Ruby的元编程功能，不用明确定义接口，也可以通过网络调用任一对象的方法。<br>C++和Java的远程调用是用IDL（Interface Definition Language）等语言来定义接口的，自动生成的存根（stub）必须编译和连接。和这些相比，Ruby的元编程更简单。</p><h3 id="数据库的应用"><a href="#数据库的应用" class="headerlink" title="数据库的应用"></a>数据库的应用</h3><p>在数据库领域，元编程也很有用。<br>web应用程序框架Ruby on Rails(也称为Rails或RoR)中也应用了元编程。具体地说是在与数据库关联的类库（ActiveRecord）中，利用元编程简单的把数据记录定义为对象。<br>由于元编程功能让我们可以获取类名，在执行时增加方法。元编程的功能使得Rails被称赞为生产效率高的Web应用程序框架。</p><h3 id="输出xml"><a href="#输出xml" class="headerlink" title="输出xml"></a>输出xml</h3><p>手工写XML是很麻烦的，利用Ruby块功能则可以很方便的处理。</p><h3 id="元编程和小编程语言"><a href="#元编程和小编程语言" class="headerlink" title="元编程和小编程语言"></a>元编程和小编程语言</h3><p>元编程功能可以运用到DSL领域，DSL是针对特定领域强化了功能的小规模编程语言。通过DSL用户可以强化应用程序的功能或者定制一些功能。</p><h3 id="声明的实现"><a href="#声明的实现" class="headerlink" title="声明的实现"></a>声明的实现</h3><p>Ruby的方法可以读取或改变程序自身的状态，利用普通的方法调用，可以实现其他编程语言中声明所完成的工作。</p><h3 id="上下文相关的实现"><a href="#上下文相关的实现" class="headerlink" title="上下文相关的实现"></a>上下文相关的实现</h3><p>instance_eval方法接受块作为参数，把调用对象置换成self来执行块。</p><h3 id="单位的实现"><a href="#单位的实现" class="headerlink" title="单位的实现"></a>单位的实现</h3><h3 id="词汇的实现"><a href="#词汇的实现" class="headerlink" title="词汇的实现"></a>词汇的实现</h3><p>针对特定领域，如果用Ruby来定义需要的类和方法，那么就可以认为Ruby是这个领域的专用语言。这些类和方法可以称为这个领域的词汇。</p><h3 id="层次数据的实现"><a href="#层次数据的实现" class="headerlink" title="层次数据的实现"></a>层次数据的实现</h3><h3 id="适合DSL的语言，不适合DSL的语言"><a href="#适合DSL的语言，不适合DSL的语言" class="headerlink" title="适合DSL的语言，不适合DSL的语言"></a>适合DSL的语言，不适合DSL的语言</h3><p>Ruby是非常适合DSL的语言。<br>首先定义好DSL用的小语言，然后编译成C++、java等目标语言。编译器经常用到Ruby这种具有优秀文本处理的语言。<br>另一种实现DSL方法的例子是解释器。比如开发应用程序时从设计到实现是很复杂的，可以利用固定的语法和类库函数来读取程序。具体方法是用XML、DOM等XML处理类库来解释小语言语法。这是Java应用程序的配置文件曹勇XML的原因之一。通过XML文件，不用每次编译Java程序就可以改变配置，定制程序的行为。<br>这种用法可以把XML称为Java界的DSL，或是Java应用程序的脚本语言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。</span><br><span class="line">早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是--解释运行--而非编译。虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界-2-面向对象&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界-2-面向对象&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界 2 面向对象&quot;&gt;&lt;/a&gt;松本行弘的程序世界 2 面向对象&lt;/h1&gt;&lt;h2 id=&quot;编程和面向对象的关
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>周海宏音乐鉴赏 一 打开你的耳朵</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E5%91%A8%E6%B5%B7%E5%AE%8F%E9%9F%B3%E4%B9%90%E9%89%B4%E8%B5%8F%20%E4%B8%80%20%E6%89%93%E5%BC%80%E4%BD%A0%E7%9A%84%E8%80%B3%E6%9C%B5/"/>
    <id>https://github.com/zdkswd/2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/</id>
    <published>2018-07-04T14:28:13.000Z</published>
    <updated>2018-07-04T14:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="周海宏音乐鉴赏-一-打开你的耳朵"><a href="#周海宏音乐鉴赏-一-打开你的耳朵" class="headerlink" title="周海宏音乐鉴赏 一 打开你的耳朵"></a>周海宏音乐鉴赏 一 打开你的耳朵</h1><h2 id="1-1音乐鉴赏的误区"><a href="#1-1音乐鉴赏的误区" class="headerlink" title="1.1音乐鉴赏的误区"></a>1.1音乐鉴赏的误区</h2><p>音乐中包含各种内容的表现，说不出来是什么是因为你“听不懂”.<br>专业学生也”听不懂“。<br>音乐两个基本属性<br>1 没有视觉性<br>2 没有语义性<br>“听不懂”–说不出音乐表现的是什么并非听者欣赏水平差，因为音乐不能直接传达视觉性与语义性的内容。</p><p>在音乐的欣赏中<br>-不一定非要听出明确的视觉性、语义性内容。<br>-不一定非要用文学化、美术化的内容去解说音乐。</p><p>在音乐中追求明确的概念性、视觉性内容，用文学化与美术化的方式欣赏音乐是一个误区。</p><p><strong>音乐何须“懂”。</strong></p><h2 id="1-2音乐的艺术本质"><a href="#1-2音乐的艺术本质" class="headerlink" title="1.2音乐的艺术本质"></a>1.2音乐的艺术本质</h2><p>音乐是动态的。<br>音乐是情绪的艺术。<br>1 纯听觉感受<br>2 情绪的感受<br>动态纪实细腻地描摹内心的感受。</p><h2 id="1-3-音乐审美的基本概念"><a href="#1-3-音乐审美的基本概念" class="headerlink" title="1.3 音乐审美的基本概念"></a>1.3 音乐审美的基本概念</h2><p>幸福人生最重要的是丰富多彩，真正的欣赏音乐，就去听最伟大的音乐。<br>世界是这么龌龊这么黑暗，可悲的不是世界这么龌龊这么黑暗，而是不知道世界还有光明。<br>音乐是人类精神的避难所。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;周海宏音乐鉴赏-一-打开你的耳朵&quot;&gt;&lt;a href=&quot;#周海宏音乐鉴赏-一-打开你的耳朵&quot; class=&quot;headerlink&quot; title=&quot;周海宏音乐鉴赏 一 打开你的耳朵&quot;&gt;&lt;/a&gt;周海宏音乐鉴赏 一 打开你的耳朵&lt;/h1&gt;&lt;h2 id=&quot;1-1音乐鉴赏的误
      
    
    </summary>
    
      <category term="听课笔记" scheme="https://github.com/zdkswd/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="音乐鉴赏" scheme="https://github.com/zdkswd/tags/%E9%9F%B3%E4%B9%90%E9%89%B4%E8%B5%8F/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界1 我为什么开发Ruby</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C1%20%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91Ruby/"/>
    <id>https://github.com/zdkswd/2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/</id>
    <published>2018-07-04T10:38:32.000Z</published>
    <updated>2018-07-04T10:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界1-我为什么开发Ruby"><a href="#松本行弘的程序世界1-我为什么开发Ruby" class="headerlink" title="松本行弘的程序世界1 我为什么开发Ruby"></a>松本行弘的程序世界1 我为什么开发Ruby</h1><h2 id="编程语言的重要性"><a href="#编程语言的重要性" class="headerlink" title="编程语言的重要性"></a>编程语言的重要性</h2><p>程序员由于使用的编程语言不同，思考方法和编写出的代码都会受到很大的影响。</p><h2 id="Ruby的原则"><a href="#Ruby的原则" class="headerlink" title="Ruby的原则"></a>Ruby的原则</h2><ol><li>简洁性</li><li>扩展性</li><li>稳定性<h2 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h2>随着编程语言的演进，程序员已经可以更简单、更抽象地编程了。面向对象的方法没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序运行开销。现在由于计算机性能大大提高，只要可以提高软件的开发效率，浪费一些计算机资源也无所谓了。<br>ruby的目标是成为开发效率高、能直接运行的伪码式编程语言。省去了不必要的声明。<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2>Ruby看重的不是明哲保身，而是如何最大限度的发挥程序员自身的能力。<br>编程的历史就是因为想当然而失败的历史，ruby对整数范围不做任何限定，尽最大努力排除“想当然”。<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2>虽然ruby非常重视扩展性，但明知道LISP风格的宏能带来巨大的扩展性，仍没有使用。<h2 id="一切皆因兴趣"><a href="#一切皆因兴趣" class="headerlink" title="一切皆因兴趣"></a>一切皆因兴趣</h2></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界1-我为什么开发Ruby&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界1-我为什么开发Ruby&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界1 我为什么开发Ruby&quot;&gt;&lt;/a&gt;松本行弘的程序世界1 我为什么开发Ruby&lt;/
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>松本行弘的程序世界0 说在前面</title>
    <link href="https://github.com/zdkswd/2018/07/04/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C0%20%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>https://github.com/zdkswd/2018/07/04/松本行弘的程序世界0 说在前面/</id>
    <published>2018-07-04T10:35:32.000Z</published>
    <updated>2018-07-04T10:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="松本行弘的程序世界0-说在前面"><a href="#松本行弘的程序世界0-说在前面" class="headerlink" title="松本行弘的程序世界0 说在前面"></a>松本行弘的程序世界0 说在前面</h1><h2 id="vczh如何设计一门语言（一）"><a href="#vczh如何设计一门语言（一）" class="headerlink" title="vczh如何设计一门语言（一）"></a>vczh如何设计一门语言（一）</h2><p>好的语言，除了库写起来又容易又好用以外，还有两个重要的特点：容易学，容易分析。关于容易学这一点，其实不是说，你随便看一看就能学会，而是说，只要你掌握了门道，很多未知的特性你都可以猜中。这就有一个语法的<strong>一致性问题</strong>在里面了。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ruby code for fun<br>这本书是松本行弘从一个编程语言设计者的角度去看待各种各样的流行编程语言，分析它们有哪些特点以及ruby编程语言如何进行取舍。ruby本身大量参考了一个更古老而著名的面向对象编程方法的开山鼻祖smalltalk以及偷师函数式编程语言鼻祖LISP。程序员社区有种说法：任何现代编程语言都脱胎于smalltalk于LISP。看看Ruby设计师是怎么设计Ruby语言的，则可以高屋建瓴的理解一些主流的编程语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;松本行弘的程序世界0-说在前面&quot;&gt;&lt;a href=&quot;#松本行弘的程序世界0-说在前面&quot; class=&quot;headerlink&quot; title=&quot;松本行弘的程序世界0 说在前面&quot;&gt;&lt;/a&gt;松本行弘的程序世界0 说在前面&lt;/h1&gt;&lt;h2 id=&quot;vczh如何设计一门语言（
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="电子书笔记" scheme="https://github.com/zdkswd/tags/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="程序语言" scheme="https://github.com/zdkswd/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
