<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2019-02-25T08:31:26.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百面机器学习 逻辑回归</title>
    <link href="https://github.com/zdkswd/2019/02/25/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>https://github.com/zdkswd/2019/02/25/百面机器学习  逻辑回归/</id>
    <published>2019-02-25T08:31:47.000Z</published>
    <updated>2019-02-25T08:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百面机器学习-逻辑回归"><a href="#百面机器学习-逻辑回归" class="headerlink" title="百面机器学习  逻辑回归"></a>百面机器学习  逻辑回归</h1><p>逻辑回归可以说是机器学习领域最基础也是最常用的模型，逻辑回归的原理推导以及扩展应用几乎是算法工程师的必备技能。</p><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>问：逻辑回归相比于线性回归，有何异同？</p><p>答：逻辑回归，乍一听名字和数学中的线性回归异派同源，但本质却是大相径庭。</p><p>首先，逻辑回归处理的是分类问题，线性回归处理的是回归问题，这是这两者最本质的区别。逻辑回归中，因变量取值是一个二元分布，模型学习得出的是E[y|x;θ]，即给定自变量和超参数后，得到因变量的期望，并基于此期望来处理预测分类问题。</p><p>分类和回归是如今机器学习中两个不同的任务，而属于分类算法的逻辑回归，其命名有一定的历史原因。</p><p>将逻辑回归的公式进行整理，我们可以得到<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/WechatIMG4.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中p=P(y=1|x)，也就是将给定输入x预测为正样本的概率。如果把一个事件的几率定义为该事件发生的概率与该事件不发生的概率的比值 p / 1-p，那么逻辑回归可以看做是对于“y=1|x”这一事件的对数几率的线性回归，于是“逻辑回归”这一称谓也就延续下来了。</p><p>在关于逻辑回归的讨论中，我们均认为y是因变量，而非p / 1-p ，这便引出逻辑回归与线性回归<strong>最大的区别</strong>。即逻辑回归中的因变量为离散的，而线性回归中的因变量是连续的。并且在自变量x与超参数θ确定的情况下，逻辑回归可以看作广义线性模型在因变量y服从二元分布时的一个特殊情况；而使用最小二乘法求解线性回归时，我们认为因变量y服从正态分布。</p><p><strong>相同之处</strong>：首先二者都使用了极大似然估计来对训练样本进行建模。线性回归使用最小二乘法，实际上就是在自变量x与超参数θ确定，因变量y服从正态分布的假设下，使用极大似然估计的一个化简；而逻辑回归中通过对似然函数的学习，得到最佳参数θ。另外，二者在求解超参数过程中，都可以使用梯度下降的方法，这也是监督学习中一个常见的相似之处。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>问：当使用逻辑回归处理多标签的分类问题时，有哪些常见做法，分别应用于哪些场景，它们之间又有着怎样的关系？</p><p>答：使用哪一种方法来处理多分类的问题取决于具体问题的定义。首先，如果一个样本只对应于一个标签，我们可以假设每个样本属于不同标签的概率服从于几何分布，使用多项逻辑回归（Softmax Regression）来进行分类。多项逻辑回归实际上是二分类逻辑回归在多标签分类下的一种扩展。</p><p>当存在样本可能属于多个标签的情况时，我们可以训练k个二分类的逻辑回归分类器。第i个分类器用以区分每个样本是否可以归为第i类，训练该分类器时，需要把标签重新整理为“第i类标签”与“非第i类标签”两类。通过这样的办法，我们就解决了每个样本可能拥有多个标签的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;百面机器学习-逻辑回归&quot;&gt;&lt;a href=&quot;#百面机器学习-逻辑回归&quot; class=&quot;headerlink&quot; title=&quot;百面机器学习  逻辑回归&quot;&gt;&lt;/a&gt;百面机器学习  逻辑回归&lt;/h1&gt;&lt;p&gt;逻辑回归可以说是机器学习领域最基础也是最常用的模型，逻辑回归的原
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost</title>
    <link href="https://github.com/zdkswd/2019/02/25/XGBoost/"/>
    <id>https://github.com/zdkswd/2019/02/25/XGBoost/</id>
    <published>2019-02-25T05:56:47.000Z</published>
    <updated>2019-02-25T06:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><p>参考<a href="https://mp.weixin.qq.com/s/AnENu0i3i5CdUQkZscMKgQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AnENu0i3i5CdUQkZscMKgQ</a><br>XGBoost是boosting算法的其中一种。Boosting算法的思想是将许多弱分类器集成在一起形成一个强分类器。因为XGBoost是一种提升树模型，所以它是将许多树模型集成在一起，形成一个很强的分类器。而所用到的树模型则是CART回归树模型。讲解其原理前，先讲解一下CART回归树。</p><h2 id="CART回归树"><a href="#CART回归树" class="headerlink" title="CART回归树"></a>CART回归树</h2><p>CART回归树是假设树为二叉树，通过不断将特征进行分裂。比如当前树结点是基于第j个特征值进行分裂的，设该特征值小于s的样本划分为左子树，大于s的样本划分为右子树。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.23.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.23.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此，当我们为了求解最优的切分特征j和最优的切分点s，就转化为求解这么一个目标函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.28.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。</p><h2 id="XGBoost算法思想"><a href="#XGBoost算法思想" class="headerlink" title="XGBoost算法思想"></a>XGBoost算法思想</h2><p>该算法思想就是不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差。当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数，最后只需要将每棵树对应的分数加起来就是该样本的预测值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.29.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注：w_q(x)为叶子节点q的分数，f(x)为其中一棵回归树</p><p>如下图例子，训练出了2棵决策树，小孩的预测分数就是两棵树中小孩所落到的结点的分数相加。爷爷的预测分数同理。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.30.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="XGBoost原理"><a href="#XGBoost原理" class="headerlink" title="XGBoost原理"></a>XGBoost原理</h2><p>XGBoost目标函数定义为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.31.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>目标函数由两部分构成，第一部分用来衡量预测分数和真实分数的差距，另一部分则是正则化项。正则化项同样包含两部分，T表示叶子结点的个数，w表示叶子节点的分数。γ可以控制叶子结点的个数，λ可以控制叶子节点的分数不会过大，防止过拟合。yi即为真实值，yi hat为预测值。</p><p>正如上文所说，新生成的树是要拟合上次预测的残差的，即当生成t棵树后，预测分数可以写成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.36.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>同时，可以将目标函数改写成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.39.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>很明显，我们接下来就是要去找到一个f_t能够最小化目标函数。XGBoost的想法是利用其在f_t=0处的泰勒二阶展开近似它。所以，目标函数近似为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/20160421102838944.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.49.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中g_i为一阶导数，h_i为二阶导数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8A%E5%8D%8810.54.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于前t-1棵树的预测分数与y的残差对目标函数优化不影响，可以直接去掉。简化目标函数为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8B%E5%8D%8812.15.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上式是将每个样本的损失函数值加起来，我们知道，每个样本都最终会落到一个叶子结点中，所以我们可以将所以同一个叶子结点的样本重组起来，过程如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8B%E5%8D%8812.21.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此通过上式的改写，我们可以将目标函数改写成关于叶子结点分数w的一个一元二次函数，求解最优的w和目标函数值就变得很简单了，直接使用顶点公式即可。因此，最优的w和目标函数公式为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8B%E5%8D%8812.28.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="分裂结点算法"><a href="#分裂结点算法" class="headerlink" title="分裂结点算法"></a>分裂结点算法</h2><p>在上面的推导中，我们知道了如果我们一棵树的结构确定了，如何求得每个叶子结点的分数。但我们还没介绍如何确定树结构，即每次特征分裂怎么寻找最佳特征，怎么寻找最佳分裂点。</p><p>正如上文说到，基于空间切分去构造一颗决策树是一个NP难问题，我们不可能去遍历所有树结构，因此，XGBoost使用了和CART回归树一样的想法，利用贪婪算法，遍历所有特征的所有特征划分点，不同的是使用上式目标函数值作为评价函数。具体做法就是对比分裂后的目标函数值与单子叶子节点的目标函数增益，同时为了限制树生长过深，还加了个阈值，只有当增益大于该阈值才进行分裂。</p><p>同时可以设置树的最大深度、当样本权重和小于设定阈值时停止生长去防止过拟合。</p><h2 id="Shrinkage-and-Column-Subsampling"><a href="#Shrinkage-and-Column-Subsampling" class="headerlink" title="Shrinkage and Column Subsampling"></a>Shrinkage and Column Subsampling</h2><p>XGBoost还提出了两种防止过拟合的方法：Shrinkage and Column Subsampling。</p><p>Shrinkage方法就是在每次迭代中对树的每个叶子结点的分数乘上一个缩减权重η，这可以使得每一棵树的影响力不会太大，留下更大的空间给后面生成的树去优化模型。Column Subsampling类似于随机森林中的选取部分特征进行建树。其可分为两种，一种是按层随机采样，在对同一层内每个结点分裂之前，先随机选择一部分特征，然后只需要遍历这部分的特征，来确定最优的分割点。另一种是随机选择特征，建树前随机选择一部分特征然后分裂就只遍历这些特征。一般情况下前者效果更好。</p><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><p>对于连续型特征值，当样本数量非常大，该特征取值过多时，遍历所有取值会花费很多时间，且容易过拟合。因此XGBoost思想是对特征进行分桶，即找到l个划分点，将位于相邻分位点之间的样本分在一个桶中。在遍历该特征的时候，只需要遍历各个分位点，从而计算最优划分。从算法伪代码中该流程还可以分为两种，全局的近似是在新生成一棵树之前就对各个特征计算分位点并划分样本，之后在每次分裂过程中都采用近似划分，而局部近似就是在具体的某一次分裂节点的过程中采用近似算法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8B%E5%8D%881.01.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="针对稀疏矩阵的算法（缺失值处理）"><a href="#针对稀疏矩阵的算法（缺失值处理）" class="headerlink" title="针对稀疏矩阵的算法（缺失值处理）"></a>针对稀疏矩阵的算法（缺失值处理）</h2><p>当样本的第i个特征值缺失时，无法利用该特征进行划分时，XGBoost的想法是将该样本分别划分到左结点和右结点，然后计算其增益，哪个大就划分到哪边。</p><h2 id="XGBoost的优点"><a href="#XGBoost的优点" class="headerlink" title="XGBoost的优点"></a>XGBoost的优点</h2><p>之所以XGBoost可以成为机器学习的大杀器，广泛用于数据科学竞赛和工业界，是因为它有许多优点：</p><ol><li>使用许多策略去防止过拟合，如：正则化项、Shrinkage and Column Subsampling等。</li><li>目标函数优化利用了损失函数关于待求函数的二阶导数</li><li>支持并行化，这是XGBoost的闪光点，虽然树与树之间是串行关系，但是同层级节点可并行。具体的对于某个节点，节点内选择最佳分裂点，候选分裂点计算增益用多线程并行。训练速度快。</li><li>添加了对稀疏数据的处理。</li><li>交叉验证，early stop，当预测结果已经很好的时候可以提前停止建树，加快训练速度。</li><li>支持设置样本权重，该权重体现在一阶导数g和二阶导数h，通过调整权重可以去更加关注一些样本。</li></ol><h1 id="百面机器学习的补充-XGBoost的构建过程"><a href="#百面机器学习的补充-XGBoost的构建过程" class="headerlink" title="百面机器学习的补充  XGBoost的构建过程"></a>百面机器学习的补充  XGBoost的构建过程</h1><p>假设决策树的结构已知，通过令损失函数相对于wj的导数为0可以求出在最小化损失函数的情况下各个叶子节点上的预测值<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8B%E5%8D%881.15.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然而从所有的树结构中寻找最优树结构是一个NP-hard问题，因此在实际中往往采用贪心法来构建一个次优的树结构，基本思想是从根结点开始，每次对一个叶子节点进行分裂，针对每一种可能的分裂，根据特定的准则选取最优的分裂。XGBoost有特定的准则来选取最优分裂。</p><p>将预测值带入到损失函数中可求得损失函数的最小值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/XGBoost/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-25%20%E4%B8%8B%E5%8D%881.27.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>容易计算出分裂前后损失函数的差值。XGBoost采用最大化这个差值作为准则来进行决策树的构建，通过遍历所有特征的所有取值，寻找使得损失函数前后相差最大时对应的分裂方式。此外，由于损失函数前后存在差值一定为正的限制，此时y起到了一定的预剪枝效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XGBoost&quot;&gt;&lt;a href=&quot;#XGBoost&quot; class=&quot;headerlink&quot; title=&quot;XGBoost&quot;&gt;&lt;/a&gt;XGBoost&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;https://mp.weixin.qq.com/s/AnENu0i3i5Cd
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>百面机器学习 集成学习</title>
    <link href="https://github.com/zdkswd/2019/02/23/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/zdkswd/2019/02/23/百面机器学习 集成学习/</id>
    <published>2019-02-23T12:46:47.000Z</published>
    <updated>2019-02-23T12:47:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成学习有几种？有何异同？"><a href="#集成学习有几种？有何异同？" class="headerlink" title="集成学习有几种？有何异同？"></a>集成学习有几种？有何异同？</h1><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>Boosting方法训练基分类器时采用串行的方式，各个基分类器之间有依赖。</p><p>它的基本思想是将基分类器层层叠加，在每一层训练时，对前一层基分类器分错的样本给予更高的权重，测试时，根据各层分类器的结果的加权得到最终结果。</p><p>Boosting的过程很类似于人类学习的过程，我们学习新知识的过程往往是迭代的，第一遍学习时，我们会记住一部分知识，但往往也会犯一些错误，对于这些错误，我们的印象会很深。第二遍学习时，就会针对犯过错误的知识加强学习，以减少类似的错误发生。不断循环往复，直到犯错误的次数减少到很低的程度。</p><p>Boosting的主要思想：迭代式学习。</p><p>AdaBoost，GBDT，XGBoost都属于Boosting思想。</p><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>Bagging与Boosting的串行训练方式不同，Bagging方法在训练过程中，各基分类器之间无强依赖，可以进行并行训练。其中很著名的算法之一就是基于决策树基分类器的随机森林。为了让基分类器之间相互独立，将训练集分为若干子集（当训练样本数量较少时，子集之间可能有交叠）。Bagging方法更像是一个集体决策的过程，每个个体都进行单独学习，学习的内容可以相同，也可以不同，也可以部分重叠。但由于个体之间存在差异性，最终做出的判断不会完全一致。在最终做决策时，每个个体单独做出判断，再通过投票的方式做出最后的集体决策。</p><p>Bagging主要思想：集体投票决策</p><p>从消除基分类器的偏差和方差的角度来理解Boosting和Bagging方法的差异。基分类器又称为弱分类器，基分类器的错误率要大于集成分类器，是偏差与方差两种错误之和。偏差主要是由于分类器的表达能力有限导致的系统性错误，表现在训练误差不收敛。方差是由于分类器对于样本分布过于敏感，导致在训练样本数较少时，产生过拟合。</p><p>用训练集的子集训练出来的决策边界很曲折，有过拟合的趋向。集成之后的模型的决策边界就比各个独立的模型平滑了，这是由于集成的加权投票方法，减小了方差。</p><h1 id="集成学习的步骤和例子"><a href="#集成学习的步骤和例子" class="headerlink" title="集成学习的步骤和例子"></a>集成学习的步骤和例子</h1><p>虽然集成学习的具体算法和策略各不相同，但都共享同样的基本步骤。</p><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>问：集成学习有哪些基本步骤？请举几个集成学习的例子</p><p>答：集成学习一般分为3个步骤。</p><ol><li>找到误差相互独立的基分类器。</li><li>训练基分类器</li><li>合并基分类器的结果</li></ol><p>合并基分类器的方法有voting和stacking两种。前者是用投票的方式，将获得最多选票的结果作为最终的结果。后者是用串行的方式，把前一个基分类器的结果输出到下一个分类器，将所有基分类器的输出结果相加（或者使用更复杂的算法融合，比如把各基分类器的输出作为特征，使用逻辑回归作为融合模型进行最后的结果预测）作为最终的输出。</p><p>以AdaBoost为例看到Boosting思想，对分类正确的样本降低了权重，对分类错误的样本升高或者保持权重不变。在最后进行模型融合的过程中，也根据错误率对基分类器进行加权融合。错误率低的分类器拥有更大的话语权。</p><p>另一个非常流行的模型是梯度提升决策树（GBDT），其核心思想是，每一颗树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。</p><p>以视频网站的用户画像为例，为了将广告定向投放给指定年龄的用户，视频网站需要对每个用户的年龄做出预测。在这个问题中，每个样本是一个已知性别年龄的用户，而特征则包括这个人访问的时长，时段，观看的视频的类型等。</p><p>例如用户A的真实年龄是25岁，但第一棵决策树的预测年龄是22岁，差了3岁，即残差是3，那么第二颗树我们把A的年龄设为3岁去学习，如果第二颗树能把A分到3岁的叶子节点，那两颗树的结果相加就可以得到A的真实年龄，如果第二棵树的结论是5岁，则A仍然存在-2岁的残差，第三棵树里A的年龄就变成-2岁，继续学。这里使用残差继续学习。</p><h1 id="基分类器"><a href="#基分类器" class="headerlink" title="基分类器"></a>基分类器</h1><p>基分类器的选择是集成学习主要步骤中的第一步，也是非常重要的一步，到底选择什么样的基分类器，为什么很多集成学习模型都选择决策树作为基分类器，这些都是需要明确的问题，做到知其然知其所以然。</p><h2 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h2><p>问：常用的基分类器是什么？</p><p>答：最常用的基分类器是决策树。有三个原因</p><ol><li>决策树可以较为方便地将样本的权重整合到训练过程中，而不需要使用过采样的方法来调整样本权重。</li><li>决策树的表达能力和泛化能力，可以通过调节树的层数来做折中。</li><li>数据样本的扰动对于决策树的影响较大，因此不同子样本集合生成的决策树基分类器随机性较大，这样的不稳定学习器更适合作为基分类器。此外，在决策树节点分裂时，随机选择一个特征子集，从中找出最优分裂属性，很好地引入了随机性。</li></ol><p>除了决策树外，神经网络模型也适合作为基分类器，主要由于神经网络模型也比较不稳定，而且还可以通过调整神经元数量，连接方式，网络层数，初始权值等方式引入随机性。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>问：可否将随机森林中的基分类器，由决策树替换为线性分类器或K-近邻？请解释为什么？</p><p>答：随机森林属于Bagging类的集成学习。Bagging的主要好处是集成后的分类器的方差比基分类器的方差小。Bagging所采用的基分类器，最好是本身对样本分布较为敏感的（即所谓不稳定的分类器），这样Bagging才能有用武之地。线性分类器或K-近邻都是较为稳定的分类器，本身方差就不大，所以以它们为基分类器使用Bagging并不能在原有基分类器的基础上获得更好的表现，甚至可能因为Bagging的采样，而导致它们在训练中更难收敛，从而增大了集成分类器的偏差。</p><h1 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h1><p>我们经常用过拟合，欠拟合来定性的描述模型是否很好地解决了特定的问题。从定量的角度来说，可以用模型的偏差（Bias）与方差（Variance）来描述模型的性能。集成学习往往能够“神奇”地提升弱分类器的性能。可以从偏差与方差的角度去解释着背后的机理。</p><h2 id="问题1-2"><a href="#问题1-2" class="headerlink" title="问题1"></a>问题1</h2><p>问：什么是偏差和方差？</p><p>答：在有监督学习中，模型泛化误差来源于两个方面-偏差和方差。</p><p>偏差指的是由所有采样得到的大小为m的训练数据集训练出的所有模型的输出的平均值和真实模型输出之间的偏差。<strong>偏差通常是由于我们对学习算法做了错误的假设所导致的</strong>，比如真实模型是某个二次函数，但我们假设模型是一次函数。由偏差带来的误差通常在训练误差上就能体现出来。</p><p>方差指的是由所有采样得到的大小为m的训练数据集训练出的所有模型输出的方差。<strong>方差通常是由于模型的复杂度相对于训练样本数m过高导致的</strong>，比如一共有100个训练样本，而我们假设模型是阶数不大于200的多项式函数。由方差带来的误差通常体现在测试误差相对于训练误差的增量上。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/20180401130516184.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h2><p>问：如何从减小方差和偏差的角度解释Boosting和Bagging的原理？</p><p>答：简单回答就是，Bagging能够提高弱分类器性能的原因是降低了方差，Boosting能够提升弱分类器性能的原因是降低了偏差。</p><p>首先，Bagging是Bootstrap Aggregating的简称，意思是再抽样，然后在每个样本上训练出来的模型取平均。假设有n个随机变量，方差记为ρ方，在随机变量完全独立的情况下，n个随机变量的方差为ρ方 / n，也就是方差减小到了原来的1 / n。记得在数理统计中提到过这么回事。</p><p>再从模型的角度理解这个问题，对n个独立不相关的模型的预测结果取平均，方差是原来单个模型的1/ n。这个描述不甚严谨，但原理已经讲得很清楚了。当然，模型之间不可能完全独立。为了追求模型的独立性，诸多Bagging的方法做了不同的改进。比如在随机森林算法中，每次选取节点分裂属性时，会随机抽取一个属性子集，而不是从所有属性中选取最优属性，这就是为了避免弱分类器之间过强的相关性。通过训练集的重采样也能够带来弱分类器之间的一定独立性，从而降低Bagging后模型的方差。</p><p>再看Boosting，大家应该还记得Boosting的训练过程。在训练好一个弱分类器后，我们需要计算弱分类器的错误或者残差，作为下一个分类器的输入。这个过程本身就是在不断减小损失函数，来使模型不断逼近靶心，使得模型偏差不断降低。但Boosting的过程并不会显著降低方差，这是因为Boosting的训练过程使得各弱分类器之间是强相关的，缺乏独立性，所以不会对降低方差有作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/606386-20180722194316424-288674381.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不难看出，方差和偏差是相辅相成，矛盾又统一的，二者并不能完全独立的存在。对于给定的学习任务和训练数据集，我们需要对模型的复杂度做合理的假设。如果模型复杂度过低，虽然方差很小，但是偏差会很高，如果模型复杂度高，虽然偏差降低了，但是方差会很高。所以需要综合考虑偏差和方差选择合适复杂度的模型进行训练。</p><h1 id="梯度提升决策树的基本原理"><a href="#梯度提升决策树的基本原理" class="headerlink" title="梯度提升决策树的基本原理"></a>梯度提升决策树的基本原理</h1><p>GBDT非常好的体现了从错误中学习的理念，基于决策树预测的残差进行迭代的学习。GBDT几乎是算法工程师的必备技能。</p><h2 id="问题1-3"><a href="#问题1-3" class="headerlink" title="问题1"></a>问题1</h2><p>问：GBDT的基本原理是什么？</p><p>答：相比于Bagging中各个弱分类器可以独立地进行训练，Boosting中的弱分类器需要依次生成。在每一轮迭代中，基于已生成的弱分类器集合（即当前模型）的预测结果，新的弱分类器会重点关注那些还没有被正确预测的样本。</p><p>Gradient Boosting是Boosting中的一大类算法，其基本思想是根据当前模型损失函数的负梯度信息来训练新加入的弱分类器，然后将训练好的弱分类器以累加的形式结合到现有模型中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/20180128125923199.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>算法1描述了Gradient Boosting算法的基本流程，在每一轮迭代中，首先计算出当前模型在所有样本上的负梯度，然后以该值为目标训练一个新的弱分类器进行拟合并计算出该弱分类器的权重，最终实现对模型的更新。</p><p>采用决策树作为弱分类器的Gradient Boosting算法被称为GBDT，有时又被称为MART（Multiple Additive Regression Tree）。GBDT中使用的决策树通常为CART。</p><p>用一个很简单的例子来解释GBDT训练的过程。模型任务是预测一个人的年龄，训练集有ABCD 4个人，他们的年龄分别是14，16，24，26，特征包括了购物金额，上网时长，上网历史等。下面开始训练第一棵树，训练的过程和传统的决策树相同，简单起见，我们只进行一次分枝。训练好第一棵树后，求得每个样本预测值与真实值之间的残差。可以看到A，B，C，D的残差分别是-1，1，-1，1。这时我们就用每个样本的残差训练下一棵树，直到残差收敛到某个阈值以下，或者树的总数达到某个上限为止。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/WechatIMG2.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于GBDT是利用残差训练的，在预测的过程中，我们也需要把所有树的预测值加起来，得到最终的预测结果。</p><p>GBDT使用梯度提升作为训练方法，而在逻辑回归或者神经网络的训练过程中往往采用梯度下降（Gradient Descent）作为训练方法，两者有什么联系与区别吗？</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>问：梯度提升和梯度下降的区别和联系是什么？</p><p>答： 两者都是在每一轮迭代中，利用损失函数相对于模型的负梯度方向的信息来对当前模型进行更新，只不过在梯度下降中，模型是以参数化形式表示，从而模型的更新等价于参数的更新。在梯度提升中，模型并不需要进行参数化表示，而是直接定义在函数空间中，从而大大扩展了可以使用的模型种类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/WechatIMG3.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>问：GBDT的优点和局限性有哪些？</p><p>答：优点：</p><ol><li>预测阶段计算速度快，树与树之间可并行化计算。</li><li>在分布稠密的数据集上，泛化能力和表达能力都很好，这使得GBDT在Kaggle的众多竞赛中，经常名列前茅。</li><li>采用决策树作为弱分类器使得GBDT模型具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系，并且也不需要对数据进行特殊的预处理如归一化等。</li></ol><p>局限性：</p><ol><li>GBDT在高维稀疏的数据集上，表现不如支持向量机或者神经网络。</li><li>GBDT在处理文本分类特征问题上，相对其他模型的优势不如它在处理数值特征时明显。</li><li>训练过程需要串行训练，只能在决策树内部采用一些局部并行的手段提高训练速度。</li></ol><h2 id="自己的一些思考"><a href="#自己的一些思考" class="headerlink" title="自己的一些思考"></a>自己的一些思考</h2><p>在GBDT中每棵树不是分类树，是回归树，对于上面的例子来说，回归树的每一个节点都会得一个预测值，这个预测值一般为该节点中所有样本的均值。然后我们分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差。最小化均方差就是每个样本的（真实值-预测值）^2 的总和 / N，均方差越小，说明错的越不离谱，那均方差最小时使用的那个特征就是分枝应选择的最佳特征。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/v2-a7a81cfe1abe8bfb5e5839d90ad1c0d8_b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>提升树其实即使不断迭代、不断构造回归树进行决策，而且每一个回归的样本数据均来自上一个回归树所产生的残差。残差就是真实值 - 预测值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/v2-a7dbc7661bf3e3e3ed98b446f4aab0e4_b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>提升树的过程如下：<br>1.计算第一个节点的均值：20<br>2.穷举每个特征进行首次分枝，选取均方差最小的那个特征作为首次分枝依据，<br>3.计算每个节点的均值：15，25<br>4.计算每个节点的中每个样本的残差-1，1，-1，1<br>5.以残差为训练样本进行下一轮回归树的训练……..<br>6.累加每棵回归树的结论，得出最终的预测值。</p><p>梯度提升决策树，它和提升树的主要区别在于梯度提升决策树是利用最速下降的近似方法，即利用损失函数的负梯度在当前模型的值，作为回归问题中提升树算法的残差的近似值来拟合一个回归树。梯度提升背后的主要思想是合并许多简单的模型，比如深度较小的树，每棵树只能对部分数据做出好的预测。因此，添加的树越来越多，可以不断迭代提高性能。</p><p>关于损失函数：对于回归算法，最常见的损失函数是均方差，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-23%20%E4%B8%8B%E5%8D%888.01.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="XGBoost与GBDT的联系和区别"><a href="#XGBoost与GBDT的联系和区别" class="headerlink" title="XGBoost与GBDT的联系和区别"></a>XGBoost与GBDT的联系和区别</h1><h2 id="问题1-4"><a href="#问题1-4" class="headerlink" title="问题1"></a>问题1</h2><p>问：XGBoost与GBDT的联系和区别有哪些？</p><p>答：原始的GBDT算法基于经验损失函数来构造新的决策树，只是在决策树构建完成后再剪枝，而XGBoost在决策树构建阶段就加入了正则项。</p><p>除了算法上与传统的GBDT有一些不同外，XGBoost还在工程实现上做了大量的优化。总的来说，两者之间的区别和联系可以总结成以下几个方面。</p><ol><li>GBDT是机器学习算法，XGBoost是该算法的工程实现。</li><li>在使用CART作为基分类器时，XGBoost显式地加入了正则项来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力。</li><li>GBDT在模型训练时只使用了代价函数的一阶导数信息，XGBoost对代价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数。</li><li>传统的GBDT采用CART作为基分类器，XGBoost支持多种类型的基分类器，比如线性分类器。</li><li>传统的GBDT在每轮迭代时使用全部的数据，XGBoost则采用了与随机森林相似的策略，支持对数据进行采样。</li><li>传统的GBDT没有设计对缺失值进行处理，XGBoost能够自动学习出缺失值的处理策略。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成学习有几种？有何异同？&quot;&gt;&lt;a href=&quot;#集成学习有几种？有何异同？&quot; class=&quot;headerlink&quot; title=&quot;集成学习有几种？有何异同？&quot;&gt;&lt;/a&gt;集成学习有几种？有何异同？&lt;/h1&gt;&lt;h2 id=&quot;Boosting&quot;&gt;&lt;a href=&quot;#B
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="机器学习" scheme="https://github.com/zdkswd/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy</title>
    <link href="https://github.com/zdkswd/2019/02/08/Scrapy/"/>
    <id>https://github.com/zdkswd/2019/02/08/Scrapy/</id>
    <published>2019-02-08T12:50:32.000Z</published>
    <updated>2019-02-08T12:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>pip install scrapy  </p></blockquote><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>首先创建一个新的Scrapy项目。</p><blockquote><p>scrapy startproject tutorial  </p></blockquote><p>创建的tutorial 目录：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%885.31.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这些文件是：<br>scrapy.cfg: 项目的配置文件<br>tutorial/ : 该项目的python模块。之后您将在此加入代码。<br>tutorial/ items.py: 项目中的item文件.<br>tutorial/ pipelines.py: 项目中的pipelines文件.<br>tutorial/ settings.py: 项目的设置文件.<br>tutorial/ spiders /: 放置spider代码的目录.</p><h1 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h1><ol><li>创建一个Scrapy项目；</li><li>定义提取的Item；</li><li>编写爬取网站的 spider 并提取 Item；</li><li>编写 Item Pipeline 来存储提取到的Item(即数据)。<h1 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h1>Item 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。</li></ol><p>可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field 的类属性来定义一个Item。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%885.43.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过定义item， 可以很方便的使用Scrapy的其他方法。而这些方法需要知道item的定义。</p><h1 id="编写第一个爬虫-Spider"><a href="#编写第一个爬虫-Spider" class="headerlink" title="编写第一个爬虫(Spider)"></a>编写第一个爬虫(Spider)</h1><p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。</p><p>其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。</p><p>为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:</p><ol><li>name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。</li><li>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li><li>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li></ol><p>以下为我们的第一个Spider代码，保存在 tutorial/spiders 目录下的 dmoz_spider.py 文件中:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%885.50.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>进入项目的根目录，执行下列命令启动spider</p><blockquote><p>scrapy crawl dmoz  </p></blockquote><h2 id="刚才发生了什么"><a href="#刚才发生了什么" class="headerlink" title="刚才发生了什么"></a>刚才发生了什么</h2><p>Scrapy为Spider的 start_urls 属性中的每个URL创建了 scrapy.Request 对象，并将 parse 方法作为回调函数(callback)赋值给了Request。</p><p>Request对象经过调度，执行生成 scrapy.http.Response 对象并送回给spider parse() 方法。</p><h1 id="提取Item"><a href="#提取Item" class="headerlink" title="提取Item"></a>提取Item</h1><h2 id="Selectors选择器简介"><a href="#Selectors选择器简介" class="headerlink" title="Selectors选择器简介"></a>Selectors选择器简介</h2><p>从网页中提取数据有很多方法。Scrapy使用了一种基于 XPath 和 CSS 表达式机制: Scrapy Selectors 。 </p><p>这里给出XPath表达式的例子及对应的含义:<br>/ html/ head/ title: 选择HTML文档中 <head> 标签内的 <title> 元素<br>/ html/ head/ title/ text(): 选择上面提到的 <title> 元素的文字<br>/ / td: 选择所有的 <td> 元素<br>/ / div[@class=”mine”]: 选择所有具有 class=”mine” 属性的 div 元素</td></title></title></head></p><p>为了配合XPath，Scrapy除了提供了 Selector 之外，还提供了方法来避免每次从response中提取数据时生成selector的麻烦。</p><p>Selector有四个基本的方法：<br>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。<br>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表.<br>extract(): 序列化该节点为unicode字符串并返回list。<br>re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。</p><p>进入项目的根目录，启动shell：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%886.42.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>shell的类似输出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%886.44.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当shell载入后，您将得到一个包含response数据的本地 response 变量。输入 response.body 将输出response的包体， 输出 response.headers 可以看到response的包头。</p><p>更为重要的是，当输入 response.selector 时， 您将获取到一个可以用于查询返回数据的selector(选择器)， 以及映射到 response.selector.xpath() 、 response.selector.css() 的 快捷方法(shortcut): response.xpath() 和 response.css() 。</p><p>同时，shell根据response提前初始化了变量 sel 。该selector根据response的类型自动选择最合适的分析规则(XML vs HTML)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%886.45.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h2><p>在我们的spider中加入这段代码:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%886.47.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="使用Item"><a href="#使用Item" class="headerlink" title="使用Item"></a>使用Item</h2><p>Item 对象是自定义的python字典。 您可以使用标准的字典语法来获取到其每个字段的值。(字段即是我们之前用Field赋值的属性):<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%886.56.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一般来说，Spider将会将爬取到的数据以 Item 对象返回。所以为了将爬取的数据返回，我们最终的代码将是:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%886.56.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在对dmoz.org进行爬取将会产生 DmozItem 对象:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%886.59.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="保存爬取到的数据"><a href="#保存爬取到的数据" class="headerlink" title="保存爬取到的数据"></a>保存爬取到的数据</h1><p>最简单存储爬取的数据是使用<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%887.26.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>该命令将采用 JSON 格式对爬取的数据进行序列化，生成 items.json 文件。</p><p>小规模的项目中，这种存储方式已经足够。 如果需要对爬取到的item做更多更为复杂的操作，您可以编写 Item Pipeline 。 </p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p><a href="https://github.com/Jack-Cherish/python-spider/tree/master/cartoon">https://github.com/Jack-Cherish/python-spider/tree/master/cartoon</a></p><h1 id="scrapy进行分布式爬虫"><a href="#scrapy进行分布式爬虫" class="headerlink" title="scrapy进行分布式爬虫"></a>scrapy进行分布式爬虫</h1><h2 id="分布式爬虫原理"><a href="#分布式爬虫原理" class="headerlink" title="分布式爬虫原理"></a>分布式爬虫原理</h2><p>scrapy的单机架构：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/4155986-5fa2c59efa050ac4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，scrapy单机模式，通过一个scrapy引擎通过一个调度器，将Requests队列中的request请求发给下载器，进行页面的爬取。多台主机协作的关键是共享一个爬取队列。</p><p>分布式爬虫的关键是共享一个requests队列，维护该队列的主机称为master，而从机则负责数据的抓取，数据处理和数据存储，所以分布式爬虫架构如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Scrapy/4155986-52592bfa491e1573.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>选用Redis队列进行存储，Redis是一种高效的非关系型数据库，以key-value的形式存储，结构灵活，它是内存中的数据结构存储系统，处理速度快，性能好，同时，提供了队列，集合等多种存储结构，方便队列维护。</p><p>另外一个问题，如何去重？这个的意思就是如何避免多台主机访问的request都不同，即让Reques队列中的请求都是不同的，那么就需要用到Redis提供的队列结构。Redis提供集合数据结构，在Redis集合中存储每个Request的指纹，在向Request队列中加入Request时首先验证指纹是否存在。如果存在，则不加入，如果不存在，则加入。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>目前已经有专门的python库实现了分布式架构。Scrapy-Redis库改写了Scrapy的调度器，队列等组件，可以方便的实现Scrapy分布式架构。</p><p>Scrapy-Redis链接：<a href="https://github.com/rolando/scrapy-redis">https://github.com/rolando/scrapy-redis</a></p><p>由于暂时只有单机环境，所以接下来：<br><a href="https://www.cnblogs.com/hd-zg/p/6960955.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">scrapy进行分布式爬虫 - thinker1017 - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scrapy&quot;&gt;&lt;a href=&quot;#Scrapy&quot; class=&quot;headerlink&quot; title=&quot;Scrapy&quot;&gt;&lt;/a&gt;Scrapy&lt;/h1&gt;&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
      <category term="爬虫" scheme="https://github.com/zdkswd/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>让爬虫程序更像人类用户的行为</title>
    <link href="https://github.com/zdkswd/2019/02/08/%E8%AE%A9%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%83%8F%E4%BA%BA%E7%B1%BB%E7%94%A8%E6%88%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/"/>
    <id>https://github.com/zdkswd/2019/02/08/让爬虫程序更像人类用户的行为/</id>
    <published>2019-02-08T06:27:32.000Z</published>
    <updated>2019-02-08T06:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="让爬虫程序更像人类用户的行为"><a href="#让爬虫程序更像人类用户的行为" class="headerlink" title="让爬虫程序更像人类用户的行为"></a>让爬虫程序更像人类用户的行为</h1><p><a href="https://blog.csdn.net/c406495762/article/details/72793480" target="_blank" rel="noopener">Python3网络爬虫(十一)：爬虫黑科技之让你的爬虫程序更像人类用户的行为(代理IP池等) - Jack-Cui - CSDN博客</a></p><h1 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h1><p>一些简单的方法让爬虫更像人类访问用户。</p><h2 id="构造合理的HTTP请求头"><a href="#构造合理的HTTP请求头" class="headerlink" title="构造合理的HTTP请求头"></a>构造合理的HTTP请求头</h2><h2 id="设置Cookie的学问"><a href="#设置Cookie的学问" class="headerlink" title="设置Cookie的学问"></a>设置Cookie的学问</h2><p>虽然 cookie 是一把双刃剑，但正确地处理 cookie 可以避免许多采集问题。网站会用 cookie 跟踪你的访问过程，如果发现了爬虫异常行为就会中断你的访问，比如特别快速地填写表单，或者浏览大量页面。虽然这些行为可以通过关闭并重新连接或者改变 IP 地址来伪装，但是如果 cookie 暴露了你的身份，再多努力也是白费。</p><p>在采集一些网站时 cookie 是不可或缺的。要在一个网站上持续保持登录状态，需要在多个页面中保存一个 cookie。有些网站不要求在每次登录时都获得一个新 cookie，只要保存一个旧的“已登录”的 cookie 就可以访问。</p><p> Cookie信息，也可以更具实际情况填写。不过requests已经封装好了很多操作，自动管理cookie，session保持连接。我们可以先访问某个目标网站，建立一个session连接之后，获取cookie。代码如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A9%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%83%8F%E4%BA%BA%E7%B1%BB%E7%94%A8%E6%88%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%8812.54.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用 requests.Session 会话对象让你能够跨请求保持某些参数，它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。</p><p>因为 requests 模块不能执行 JavaScript，所以它不能处理很多新式的跟踪软件生成的 cookie，比如 Google Analytics，只有当客户端脚本执行后才设置 cookie（或者在用户浏览页面时基于网页事件产生 cookie，比如点击按钮）。要处理这些动作，需要用 Selenium 和 PhantomJS 包。</p><p>PhantomJS 是一个“无头”（headless）浏览器。它会把网站加载到内存并执行页面上的 JavaScript，但不会向用户展示网页的图形界面。将 Selenium 和 PhantomJS 结合在一起，就可以运行一个非常强大的网络爬虫了，可以处理 cookie、JavaScript、headers，以及任何你需要做的事情。</p><p>还可以调用 delete_cookie()、add_cookie() 和 delete_all_cookies() 方法来处理 cookie。另外，还可以保存 cookie 以备其他网络爬虫使用。</p><p>通过Selenium和PhantomJS，我们可以很好的处理一些需要事件执行后才能获得的cookie。</p><h2 id="正常的访问速度"><a href="#正常的访问速度" class="headerlink" title="正常的访问速度"></a>正常的访问速度</h2><p>有一些防护措施完备的网站可能会阻止你快速地提交表单，或者快速地与网站进行交互。即使没有这些安全措施，用一个比普通人快很多的速度从一个网站下载大量信息也可能让自己被网站封杀。</p><p>因此，虽然多进程程序可能是一个快速加载页面的好办法——在一个进程中处理数据，另一个进程中加载页面——但是这对编写好的爬虫来说是恐怖的策略。还是应该尽量保证一次加载页面加载且数据请求最小化。如果条件允许，尽量为每个页面访问增加一点儿时间间隔，即使你要增加两行代码：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A9%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%83%8F%E4%BA%BA%E7%B1%BB%E7%94%A8%E6%88%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%881.07.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>合理控制速度是你不应该破坏的规则。过度消耗别人的服务器资源会让你置身于非法境地，更严重的是这么做可能会把一个小型网站拖垮甚至下线。拖垮网站是不道德的，是彻头彻尾的错误。所以请控制采集速度！</p><h2 id="注意隐含输入字段"><a href="#注意隐含输入字段" class="headerlink" title="注意隐含输入字段"></a>注意隐含输入字段</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A9%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%83%8F%E4%BA%BA%E7%B1%BB%E7%94%A8%E6%88%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/20170528154851498.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>用隐含字段阻止网络数据采集的方式主要有两种。</p><p>第一种是表单页面上的一个字段可以用服务器生成的随机变量表示。如果提交时这个值不在表单处理页面上，服务器就有理由认为这个提交不是从原始表单页面上提交的，而是由一个网络机器人直接提交到表单处理页面的。绕开这个问题的最佳方法就是，首先采集表单所在页面上生成的随机变量，然后再提交到表单处理页面。</p><p>第二种方式是“蜜罐”（honey pot）。如果表单里包含一个具有普通名称的隐含字段（设置蜜罐圈套），比如“用户名”（username）或“邮箱地址”（email address），设计不太好的网络机器人往往不管这个字段是不是对用户可见，直接填写这个字段并向服务器提交，这样就会中服务器的蜜罐圈套。服务器会把所有隐含字段的真实值（或者与表单提交页面的默认值不同的值）都忽略，而且填写隐含字段的访问用户也可能被网站封杀。</p><p>总之，有时检查表单所在的页面十分必要，看看有没有遗漏或弄错一些服务器预先设定好的隐含字段（蜜罐圈套）。如果你看到一些隐含字段，通常带有较大的随机字符串变量，那么很可能网络服务器会在表单提交的时候检查它们。另外，还有其他一些检查，用来保证这些当前生成的表单变量只被使用一次或是最近生成的（这样可以避免变量被简单地存储到一个程序中反复使用）。</p><h2 id="爬虫如何避开蜜罐"><a href="#爬虫如何避开蜜罐" class="headerlink" title="爬虫如何避开蜜罐"></a>爬虫如何避开蜜罐</h2><p>虽然在进行网络数据采集时用 CSS 属性区分有用信息和无用信息会很容易（比如，通过读取 id和 class 标签获取信息），但这么做有时也会出问题。如果网络表单的一个字段通过 CSS 设置成对用户不可见，那么可以认为普通用户访问网站的时候不能填写这个字段，因为它没有显示在浏览器上。如果这个字段被填写了，就可能是机器人干的，因此这个提交会失效。</p><p>这种手段不仅可以应用在网站的表单上，还可以应用在链接、图片、文件，以及一些可以被机器人读取，但普通用户在浏览器上却看不到的任何内容上面。访问者如果访问了网站上的一个“隐含”内容，就会触发服务器脚本封杀这个用户的 IP 地址，把这个用户踢出网站，或者采取其他措施禁止这个用户接入网站。实际上，许多商业模式就是在干这些事情。</p><p>通常元素可以通过三种不同的方式对用户进行隐藏。</p><ol><li>第一个链接是通过简单的 CSS 属性设置 display:none 进行隐藏；</li><li>电话号码字段 name=”phone” 是一个隐含的输入字段；</li><li>邮箱地址字段 name=”email” 是将元素向右移动 50 000 像素（应该会超出电脑显示器的边界）并隐藏滚动条。</li></ol><p>因为 Selenium 可以获取访问页面的内容，所以它可以区分页面上的可见元素与隐含元素。通过 is_displayed() 可以判断元素在页面上是否可见。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A9%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%83%8F%E4%BA%BA%E7%B1%BB%E7%94%A8%E6%88%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-08%20%E4%B8%8B%E5%8D%881.41.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="创建自己的代理IP池"><a href="#创建自己的代理IP池" class="headerlink" title="创建自己的代理IP池"></a>创建自己的代理IP池</h2><p>启用远程平台的人通常有两个目的：对更大计算能力和灵活性的需求，以及对可变 IP 地址的需求。</p><p>有一些网站会设置访问阈值，也就是说，如果一个IP访问速度超过这个阈值，那么网站就会认为，这是一个爬虫程序，而不是用户行为。为了避免远程服务器封锁IP，或者想加快爬取速度，一个可行的方法就是使用代理IP，我们需要做的就是创建一个自己的代理IP池。</p><p>思路：通过免费IP代理网站爬取IP，构建一个容量为100的代理IP池。从代理IP池中随机选取IP，在使用IP之前，检查IP是否可用。如果可用，使用该IP访问目标页面，如果不可用，舍弃该IP。当代理IP池中IP的数量小于20的时候，更新整个代理IP池，即重新从免费IP代理网站爬取IP，构建一个新的容量为100的代理IP池。</p><h1 id="检查列表"><a href="#检查列表" class="headerlink" title="检查列表"></a>检查列表</h1><p>如果一直被网站封杀找不到原因，可以从以下方面来检查。</p><h2 id="检查-JavaScript"><a href="#检查-JavaScript" class="headerlink" title="检查 JavaScript"></a>检查 JavaScript</h2><p>如果你从网络服务器收到的页面是空白的，缺少信息，或其遇到他不符合你预期的情况（或者不是你在浏览器上看到的内容），有可能是因为网站创建页面的 JavaScript 执行有问题。</p><h2 id="检查正常浏览器提交的参数"><a href="#检查正常浏览器提交的参数" class="headerlink" title="检查正常浏览器提交的参数"></a>检查正常浏览器提交的参数</h2><p>如果你准备向网站提交表单或发出 POST 请求，记得检查一下页面的内容，看看你想提交的每个字段是不是都已经填好，而且格式也正确。用 Chrome 浏览器的网络面板（快捷键 F12 打开开发者控制台，然后点击“Network”即可看到）查看发送到网站的 POST 命令，确认你的每个参数都是正确的。</p><h2 id="是否有合法的-Cookie？"><a href="#是否有合法的-Cookie？" class="headerlink" title="是否有合法的 Cookie？"></a>是否有合法的 Cookie？</h2><p>如果你已经登录网站却不能保持登录状态，或者网站上出现了其他的“登录状态”异常，请检查你的 cookie。确认在加载每个页面时 cookie 都被正确调用，而且你的 cookie 在每次发起请求时都发送到了网站上。</p><h2 id="IP-被封禁"><a href="#IP-被封禁" class="headerlink" title="IP 被封禁"></a>IP 被封禁</h2><p>如果你在客户端遇到了 HTTP 错误，尤其是 403 禁止访问错误，这可能说明网站已经把你的 IP 当作机器人了，不再接受你的任何请求。你要么等待你的 IP 地址从网站黑名单里移除，要么就换个 IP 地址。如果你确定自己并没有被封杀，那么再检查下面的内容： </p><ol><li>确认你的爬虫在网站上的速度不是特别快。快速采集是一种恶习，会对网管的服务器造成沉重的负担，还会让你陷入违法境地，也是 IP 被网站列入黑名单的首要原因。给你的爬虫增加延迟，让它们在夜深人静的时候运行。切记：匆匆忙忙写程序或收集数据都是拙劣项目管理的表现；应该提前做好计划，避免临阵慌乱。</li><li>还有一件必须做的事情：修改你的请求头！有些网站会封杀任何声称自己是爬虫的访问者。如果你不确定请求头的值怎样才算合适，就用你自己浏览器的请求头吧。</li><li>确认你没有点击或访问任何人类用户通常不能点击或接入的信息。</li><li>如果你用了一大堆复杂的手段才接入网站，考虑联系一下网管吧，告诉他们你的目的。试试发邮件到 webmaster@&lt; 域名 &gt; 或 admin@&lt; 域名 &gt;，请求网管允许你使用爬虫采集数据。管理员也是人嘛！</li></ol><p>使用免费的代理IP也是有局限的，就是不稳定。更好的方法是，花钱买一个可以动态切换IP的阿里云服务器，这样IP就可以无限动态变化了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;让爬虫程序更像人类用户的行为&quot;&gt;&lt;a href=&quot;#让爬虫程序更像人类用户的行为&quot; class=&quot;headerlink&quot; title=&quot;让爬虫程序更像人类用户的行为&quot;&gt;&lt;/a&gt;让爬虫程序更像人类用户的行为&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
      <category term="爬虫" scheme="https://github.com/zdkswd/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>再议Python数据可视化技术</title>
    <link href="https://github.com/zdkswd/2019/02/08/%E5%86%8D%E8%AE%AEPython%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <id>https://github.com/zdkswd/2019/02/08/再议Python数据可视化技术/</id>
    <published>2019-02-08T03:28:56.000Z</published>
    <updated>2019-02-08T03:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再议Python数据可视化技术"><a href="#再议Python数据可视化技术" class="headerlink" title="再议Python数据可视化技术"></a>再议Python数据可视化技术</h1><h1 id="可视化视图分类"><a href="#可视化视图分类" class="headerlink" title="可视化视图分类"></a>可视化视图分类</h1><p>可视化视图可分为4类，比较，联系，构成和分布。</p><ol><li>比较：比较数据间各类别的关系，或者是它们随着时间的变化趋势，比如折线图。</li><li>联系：查看两个或两个以上变量的关系，比如散点图。</li><li>构成：每个部分占整体的百分比，或者是随着时间的百分比变化，比如饼图。</li><li>分布：关注单个变量，或者多个变量的分布情况，比如直方图。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%8D%E8%AE%AEPython%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%80%E6%9C%AF/4673a17085302cfe9177f8ee687ac675.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%86%8D%E8%AE%AEPython%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%80%E6%9C%AF/8ed2addb00a4329dd63bba669f427fd2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;再议Python数据可视化技术&quot;&gt;&lt;a href=&quot;#再议Python数据可视化技术&quot; class=&quot;headerlink&quot; title=&quot;再议Python数据可视化技术&quot;&gt;&lt;/a&gt;再议Python数据可视化技术&lt;/h1&gt;&lt;h1 id=&quot;可视化视图分类&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析小总结</title>
    <link href="https://github.com/zdkswd/2019/02/07/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/zdkswd/2019/02/07/数据分析小总结/</id>
    <published>2019-02-07T13:58:56.000Z</published>
    <updated>2019-02-07T14:00:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据分析小总结"><a href="#数据分析小总结" class="headerlink" title="数据分析小总结"></a>数据分析小总结</h1><h1 id="数据挖掘的十大算法"><a href="#数据挖掘的十大算法" class="headerlink" title="数据挖掘的十大算法"></a>数据挖掘的十大算法</h1><h2 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h2><p>C4.5，朴素贝叶斯（Naive Bayes），SVM，KNN，Adaboost，CART</p><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p>K-Means，EM</p><h2 id="关连分析"><a href="#关连分析" class="headerlink" title="关连分析"></a>关连分析</h2><p>Apriori<br> [‘eɪprɪ’ɔ:rɪ] 先验的<br>Aprion是一种挖掘关联规则( association rules)的算法,它通过挖掘频繁项集( frequent item sets)来揭示物品之间的关联关系,被广泛应用到商业挖掘和网络安全等领域中。频繁项集是指经常岀现在一起的物品的集合,关联规则暗示着两种物品之间可能存在很强的关系。</p><h2 id="连接分析"><a href="#连接分析" class="headerlink" title="连接分析"></a>连接分析</h2><p>PageRank<br>PageRank起源于论文影响力的计算方式,如果一篇文论被引入的次数越多,就代表这篇论文的影响力越强。同样 PageRank被 Google创造性地应用到了网页权重的计算中:当一个页面链岀的页面越多,说明这个页面的“参考文献”越多,当这个页面被链入的频率越高,说明这个页面被引用的次数越高。基于这个原理,我们可以得到网站的权重划分。</p><h1 id="Numpy之再回首"><a href="#Numpy之再回首" class="headerlink" title="Numpy之再回首"></a>Numpy之再回首</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/7ba74ca7776ac29a5dc94c272d72ff66.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="使用NumPy让Python科学计算更高效"><a href="#使用NumPy让Python科学计算更高效" class="headerlink" title="使用NumPy让Python科学计算更高效"></a>使用NumPy让Python科学计算更高效</h2><p>列表list的元素在系统内存中是分散存储的,而 NumPy数组存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素,不像列表list还需要对內存地址进行査找,从而节省了计算资源。由之前的NumPy博客可得知详情。<br><a href="https://zdkswd.github.io/2018/10/28/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">Python数据科学手册 NumPy入门 | ZDK’s blog</a><br>然而一旦确定下来numpy数组后，就不能在增加元素了。</p><p>另外在内存访问模式中,缓存会直接把字节块从RAM加载到CPU寄存器中。因为数据连续的存储在内存中, NumPy直接利用现代CPU的矢量化指令计算,加载寄存器中的多个连续浮点数。</p><p>NumPy中的矩阵计算可以采用多线程的方式,充分利用多核CPU计算资源,大大提升了计算效率。python因为有GIL锁，因此多线程也只能使用一个处理器，但是numpy是例外，因为numpy内部是用C写的，不经过python解释器，因此它本身的矩阵运算(array operations)都可以使用多核。</p><p>除了使用 NumPy外,你还需要一些技巧来提升内存和提高计算资源的利用率。一个重要的规则就是:<strong>避免采用隐式拷贝,而是采用就地操作的方式</strong>。举个例子,如果我想让一个数值x是原来的两倍,可以直接写成x <em> =2,而不要写成y=x </em> 2。这样速度能快2倍甚至更多。</p><p>NumPy里有两个重要的对象：ndarray（N-dimensional array object）解决了多维数组问题。ufunc（universal function object）则是解决对数组进行处理的函数。</p><h3 id="ndarray对象"><a href="#ndarray对象" class="headerlink" title="ndarray对象"></a>ndarray对象</h3><p>axis为0是跨行（纵向），axis为1是跨列（横向）。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%885.15.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%885.15.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>如果想统计一个班级里面学生的姓名，年龄，以及语文数学英语成绩，可以用数组的下标来代表不同的字段，但是这样不显性，可以自己定义一个数据结构。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%885.34.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%885.34.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意在定义数组时，用array中指定了结构数组的类型dtype=persontype</p><h3 id="ufunc运算"><a href="#ufunc运算" class="headerlink" title="ufunc运算"></a>ufunc运算</h3><p>它能对数组中<strong>每个元素</strong>进行函数操作，NumPy中很多ufunc函数计算速度非常快，因为都是采用C语言实现的。</p><h3 id="连续数组的创建"><a href="#连续数组的创建" class="headerlink" title="连续数组的创建"></a>连续数组的创建</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%885.56.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>np. arange和np.linspace起到的作用是一样的,都是创建等差数组。这两个数组的结果x1,x2都是[1 3 5 7 9]。结果相同,但是创建的方式是不同的。</p><p>arange（）类似内置函数 range（）,通过指定<strong>初始值、终值、步长</strong>来创建等差数列的一维数组,默认是不包括终值的。</p><p>linspace是 linear space的缩写,代表线性等分向量的含义。 linspace（）通过指定<strong>初始值，终值、元素个数</strong>来创建等差数列的一维数组,默认是包括终值的。</p><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%886.22.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%886.22.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>取余函数里，既可以用remainder，也可以用mod，结果是一样的。</p><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p>统计数组矩阵的最大值函数amax（），最小值函数amin（）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%886.55.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%886.56.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>统计最大值与最小值之差ptp（）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%886.59.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%886.59.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="统计数组的百分位数percentile（）"><a href="#统计数组的百分位数percentile（）" class="headerlink" title="统计数组的百分位数percentile（）"></a>统计数组的百分位数percentile（）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.00.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.01.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>percentile（）代表着第p个百分位数,这里p的取值范围是0-100,如果p=0,那么就是求最小值,如果p=50就是求平均值,如果p=100就是求最大值。同样你也可以求得在axs=0和axis=1两个轴上的p%的百分位数。</p><h3 id="统计数组中的中位数median（），平均数mean（）"><a href="#统计数组中的中位数median（），平均数mean（）" class="headerlink" title="统计数组中的中位数median（），平均数mean（）"></a>统计数组中的中位数median（），平均数mean（）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.03.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.03.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="统计数组中的加权平均值average（）"><a href="#统计数组中的加权平均值average（）" class="headerlink" title="统计数组中的加权平均值average（）"></a>统计数组中的加权平均值average（）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.05.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.06.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="统计数组中的标准差std（），方差var（）"><a href="#统计数组中的标准差std（），方差var（）" class="headerlink" title="统计数组中的标准差std（），方差var（）"></a>统计数组中的标准差std（），方差var（）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.09.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.09.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="NumPy排序"><a href="#NumPy排序" class="headerlink" title="NumPy排序"></a>NumPy排序</h3><p>这些排序算法在NumPy中实现起来其实非常简单,一条语句就可以搞定。这里你可以使用sort函数,sort(a,axis=-1,kind= quicksort, order=None),默认情况下使用的是快速排序;在kind里,可以指定 quicksort、 mergesort、 heapsort分别表示快速排序、合并排序、堆排序。同样axis默认是-1,即沿着数组的最后一个轴迸行排序,也可以取不同的axis轴,或者axis=None代表采用扁平化的方式作为一个向量进行排序。另外 <strong>order</strong>字段对于结构化的数组可以指定按照某个字段进行排序。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.18.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.19.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>统计全班的成绩<br>假设一个团队里有5名学员,成绩如下表所示。你可以用 NumPy统计下这些人在语文、英语、数学中的平均成绩、最小成绩、最大成绩、方差、标准差。然后把这些人的总成绩排序,得出名次进行成绩输出。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-06%20%E4%B8%8B%E5%8D%887.21.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><a href="https://github.com/zdkswd/PythonCode/blob/master/%E7%BB%9F%E8%AE%A1%E5%85%A8%E7%8F%AD%E7%9A%84%E6%88%90%E7%BB%A9.py">PythonCode/统计全班的成绩.py at master · zdkswd/PythonCode · GitHub</a></p><h1 id="Pandas之再回首"><a href="#Pandas之再回首" class="headerlink" title="Pandas之再回首"></a>Pandas之再回首</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/74884960677548b08acdc919c13460cd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在NumPy中数据结构是围绕ndarray展开的，在Pandas中，核心数据结构是Series和DataFrame。Pandas的基础是NumPy。</p><h2 id="数据结构：Series和DataFrame"><a href="#数据结构：Series和DataFrame" class="headerlink" title="数据结构：Series和DataFrame"></a>数据结构：Series和DataFrame</h2><p><strong>Series是个定长的字典序列</strong>，说是定长是因为在存储时，相当于两个ndarray，这也是和字典结构最大的不同，因为在字典结构中元素的个数是不固定的。</p><p>Series有两个基本属性，Index和values。在Series结构中，index默认是0，1，2递增的整数序列，当然也可以自己来指定索引，index=[‘a’, ‘b’, ‘c’, ‘d’]。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8810.47.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8810.47.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>还可以用字典方式来创建Series。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8810.52.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8810.52.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="DataFrame类型数据结构类似数据库表"><a href="#DataFrame类型数据结构类似数据库表" class="headerlink" title="DataFrame类型数据结构类似数据库表"></a>DataFrame类型数据结构类似数据库表</h3><p>数据库表<br>DataFrame是由相同索引的Series组成的字典类型。</p><blockquote><p>import pandas as pd<br>from pandas import Series, DataFrame<br>data = {‘Chinese’: [66, 95, 93, 90,80],’English’: [65, 85, 92, 88, 90],’Math’: [30, 98, 96, 77, 90]}<br>df1= DataFrame(data)<br>df2 = DataFrame(data, index=[‘ZhangFei’, ‘GuanYu’, ‘ZhaoYun’, ‘HuangZhong’, ‘DianWei’], columns=[‘English’, ‘Math’, ‘Chinese’])<br>print df1<br>print df2  </p></blockquote><p>df1的输出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8811.39.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>df2的输出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8811.40.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="数据导入和输出"><a href="#数据导入和输出" class="headerlink" title="数据导入和输出"></a>数据导入和输出</h3><p>xlsx,csv</p><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>数据清洗是数据准备中必不可少的环节，Pandas也为我们提供了数据清洗的工具。</p><h3 id="删除DataFrame中不必要的行或列"><a href="#删除DataFrame中不必要的行或列" class="headerlink" title="删除DataFrame中不必要的行或列"></a>删除DataFrame中不必要的行或列</h3><p>Pandas中drop（）方法来删除我们不想要的列或行。<br>将语文这列删掉<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8811.49.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将张飞这行删掉<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8811.49.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="重命名列名columns，让列表名更容易识别"><a href="#重命名列名columns，让列表名更容易识别" class="headerlink" title="重命名列名columns，让列表名更容易识别"></a>重命名列名columns，让列表名更容易识别</h3><p>例如把列名Chinese改为YuWen，English改为YingYu。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8811.51.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="去重复的值"><a href="#去重复的值" class="headerlink" title="去重复的值"></a>去重复的值</h3><p>数据采集可能存在重复的行,这时只要使用 drop_duplicates就会自动把重复的行去掉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8811.52.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="格式问题"><a href="#格式问题" class="headerlink" title="格式问题"></a>格式问题</h3><h4 id="更改数据格式"><a href="#更改数据格式" class="headerlink" title="更改数据格式"></a>更改数据格式</h4><p>这是个比较常用的操作,因为很多时候数据格式不规范,我们可以使用 astype函数来规范数据格式,比如我们把 Chinese字段的值改成str类型,或者int64可以这么写。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8A%E5%8D%8811.55.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="数据间的空格"><a href="#数据间的空格" class="headerlink" title="数据间的空格"></a>数据间的空格</h4><p>有时候我们先把格式转成了str类型,是为了方便对数据进行操作,这时想要删除数据间的空格,我们就可以使用strip函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%8812.06.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>想要删除特殊符号，同样可以使用strip函数，比如删除美元符号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%8812.18.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%8812.19.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="查找空值"><a href="#查找空值" class="headerlink" title="查找空值"></a>查找空值</h4><p>数据量大的情况下，有些字段存在空值NaN的可能，这时需要Pandas中的isnull函数进行查找。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%8812.21.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果想看哪些地方存在空值NaN，可以针对数据表df进行df.isnull()<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/5b52bca4eb6f00d51f72dcc5c6ce2afe.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果想要知道哪列存在空值，可以使用df.isnull().any()<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/89cb71afc4f54a11ce1d4d05cd46bb03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="使用apply函数对数据进行清洗"><a href="#使用apply函数对数据进行清洗" class="headerlink" title="使用apply函数对数据进行清洗"></a>使用apply函数对数据进行清洗</h2><p>apply是Pandas中<strong>自由度非常高的函数</strong>，使用频率也非常高。<br>比如想对name列的数值都进行大写转化：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%8812.59.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以定义个函数，在apply中进行使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%881.00.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还可以定义更复杂的函数<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%881.07.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中axis=1代表按照列为轴进行操作,axis=0代表按照行为轴进行操作,args是传递的两个参数,即n=2,m=3,在plus函数中使用到了n和m,从而生成新的df。</p><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>在数据清洗后，就要对数据进行统计了。Pandas和NumPy一样都有常用的统计函数，如果遇到空值NaN，会自动排除。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/343ba98c1322dc0c013e07c87b157a00.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.39.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/e4a7a208a11d60dbcda6f3dbaff9a583.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="数据表合并"><a href="#数据表合并" class="headerlink" title="数据表合并"></a>数据表合并</h2><p>创建两个DataFrame。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.41.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用的是merge（）函数，有五种形式。</p><h3 id="基于指定列进行连接"><a href="#基于指定列进行连接" class="headerlink" title="基于指定列进行连接"></a>基于指定列进行连接</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.42.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/220ce1ea19c8f6f2668d3a8122989c2f.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="inner内连接"><a href="#inner内连接" class="headerlink" title="inner内连接"></a>inner内连接</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.44.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/220ce1ea19c8f6f2668d3a8122989c2f%202.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="left左连接"><a href="#left左连接" class="headerlink" title="left左连接"></a>left左连接</h3><p>左连接是第一个DataFrame为主进行连接，第二个DataFrame作为补充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.46.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/9091a7406d5aa7a2980328d587fb42ac.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="right右连接"><a href="#right右连接" class="headerlink" title="right右连接"></a>right右连接</h3><p>右连接是以第二个DataFrame为主进行的连接，第一个DataFrame作为补充。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.47.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/10f9f22f66f3745381d85d760f857baf.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="outer外连接"><a href="#outer外连接" class="headerlink" title="outer外连接"></a>outer外连接</h3><p>外连接相当于求两个DataFrame的并集。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.48.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/6737f6d4d66af0d75734cd140b5d198c.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="用SQL方式打开Pandas"><a href="#用SQL方式打开Pandas" class="headerlink" title="用SQL方式打开Pandas"></a>用SQL方式打开Pandas</h2><p>pandasql。<br>pandas中的主要函数是sqdf,它接收两个参数:一个SQL查询语句,还有一组环境变量globals（）或 locals（）。这样我们就可以在 Python里,直接用SQL语句中对 Data Frame进行操作,举个例子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.50.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行结果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.51.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中lambda是用来定义一个匿名函数的。具体形式为：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-07%20%E4%B8%8B%E5%8D%889.53.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>argument_list 是参数列表，expression是关于参数的表达式，会根据expression表达式计算结果进行输出返回。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据分析小总结&quot;&gt;&lt;a href=&quot;#数据分析小总结&quot; class=&quot;headerlink&quot; title=&quot;数据分析小总结&quot;&gt;&lt;/a&gt;数据分析小总结&lt;/h1&gt;&lt;h1 id=&quot;数据挖掘的十大算法&quot;&gt;&lt;a href=&quot;#数据挖掘的十大算法&quot; class=&quot;header
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行</title>
    <link href="https://github.com/zdkswd/2019/02/05/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://github.com/zdkswd/2019/02/05/Linux命令行/</id>
    <published>2019-02-05T11:33:32.000Z</published>
    <updated>2019-02-05T13:20:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux命令行"><a href="#Linux命令行" class="headerlink" title="Linux命令行"></a>Linux命令行</h1><p>为了更好的使用实验室的服务器，特此来进行总结。</p><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>在当前终端运行一个脚本时，该终端会不占用而无法进行其他工作。比如在训练模型是想要查看GPU的使用情况，或者断开与远程服务器的连接但保持训练的进行。这时我们就需要借助 tmux 这个工具。tmux 是一个终端选择器（terminal multiplexer），它可以让用户在一个终端窗口中控制多个终端。对于连接远程服务器的工作有很大的帮助。</p><blockquote><pre><code>$ tmux                      # create a new terminal session  </code></pre></blockquote><p>在创建了新的 terminal session 之后，窗口会显示新的终端界面。想要退出新的终端界面，则可以在使用 ctrl+b 前缀之后再按 d （表示detached），这样就返回最初的终端。现在可以查看一共创建过多少个 terminal session：</p><blockquote><pre><code>$ tmux ls                   # list all terminal sessions  </code></pre></blockquote><p>键入以上的命令之后就可以看到下面的一段显示。</p><blockquote><p>0: 1 windows (created Mon Apr  2 17:19:35 2018) [100x34]<br>1: 1 windows (created Mon Apr  2 19:01:14 2018) [100x34]  </p></blockquote><p>每一行就是一个 terminal session， 最前面的就是它们的索引。我们可以通过这些索引来进入我们想要的 session。</p><blockquote><p>$ tmux attach -t 0  </p></blockquote><p>这样就可以进入上面编号为0的 session 查看程序的执行进度或者执行其他操作。运用 tmux 能够保证进程在断开与服务器连接之后依然正常运行。</p><h2 id="GPU使用"><a href="#GPU使用" class="headerlink" title="GPU使用"></a>GPU使用</h2><blockquote><p>nvidia-smi 可以查看GPU使用情况<br>export CUDA_VISIBLE_DEVICES=0 指定可用的GPU资源，防止占用所有GPU<br>的显存  </p></blockquote><h2 id="远程查看server端的log"><a href="#远程查看server端的log" class="headerlink" title="远程查看server端的log"></a>远程查看server端的log</h2><p>tensorboard的log输出的位置。</p><blockquote><p>$ tensorboard –log path_to_log_files  </p></blockquote><p>然后在本地的浏览器中输入server的地址再加上port的编号即可。</p><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>在SSH远程连接被断开或者关闭的时候，系统里面的下载程序还能继续运行。<br>解决方法：<br>1.安装screen<br>实验室服务器已安装此步跳过。<br>2 创建screen会话，自定义screen虚拟终端的名称，test可以改为想要的名称</p><blockquote><p>screen -S  test</p></blockquote><p>3 查看之前的会话虚拟终端</p><blockquote><p>screen -r test</p></blockquote><p>查看所有screen会话</p><blockquote><p>screen -ls</p></blockquote><p>保存当前的screen会话<br>按键盘上的ctrl＋a，然后再按d</p><p>退出screen</p><blockquote><p>exit</p></blockquote><p>删除会话</p><blockquote><p>screen -wipe test</p></blockquote><h2 id="Linux查看物理CPU个数、核数、逻辑CPU个数"><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a>Linux查看物理CPU个数、核数、逻辑CPU个数</h2><p>查看物理CPU个数</p><blockquote><p>cat /proc/cpuinfo| grep “physical id”| sort| uniq| wc -l</p></blockquote><p>查看每个物理CPU中core的个数(即核数)</p><blockquote><p>cat /proc/cpuinfo| grep “cpu cores”| uniq</p></blockquote><p>查看逻辑CPU的个数</p><blockquote><p>cat /proc/cpuinfo| grep “processor”| wc -l</p></blockquote><p>查看CPU信息（型号）</p><blockquote><p>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</p></blockquote><p>注，根据之前博客中提到的，/proc目录本身是一个虚拟文件系统，放置的数据都是在内存当中，例如系统核心，进程信息，周边设备的状态及网络状态。这个目录下的数据都在内存当中。</p><p>物理cpu个数、核数、逻辑cpu数的概念<br><strong>物理cpu数</strong>：主板上实际插入的cpu数量，可以数不重复的 physical id 有几个（physical id）。<br><strong>cpu核数</strong>：单块CPU上面能处理数据的芯片组的数量，如双核、四核等。（cpu cores）<br><strong>逻辑cpu数</strong>：一般情况下，逻辑cpu=物理CPU个数×每颗核数，如果不相等的话，则表示服务器的CPU支持超线程技术（HT：简单来说，它可使处理器中的1 颗内核如2 颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能，此时逻辑cpu=物理CPU个数×每颗核数x2）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux命令行&quot;&gt;&lt;a href=&quot;#Linux命令行&quot; class=&quot;headerlink&quot; title=&quot;Linux命令行&quot;&gt;&lt;/a&gt;Linux命令行&lt;/h1&gt;&lt;p&gt;为了更好的使用实验室的服务器，特此来进行总结。&lt;/p&gt;
&lt;h2 id=&quot;后台运行&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥 Linux账号管理</title>
    <link href="https://github.com/zdkswd/2019/02/04/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://github.com/zdkswd/2019/02/04/鸟哥 Linux账号管理/</id>
    <published>2019-02-04T11:25:32.000Z</published>
    <updated>2019-02-04T11:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸟哥-Linux账号管理"><a href="#鸟哥-Linux账号管理" class="headerlink" title="鸟哥 Linux账号管理"></a>鸟哥 Linux账号管理</h1><h2 id="Linux的账号与群组"><a href="#Linux的账号与群组" class="headerlink" title="Linux的账号与群组"></a>Linux的账号与群组</h2><h3 id="使用者识别码：UID与GID"><a href="#使用者识别码：UID与GID" class="headerlink" title="使用者识别码：UID与GID"></a>使用者识别码：UID与GID</h3><p>当登录Linux主机时，输入的是账号，Linux 主机并不会直接认识你的帐号，他仅认识 ID，帐号只是为了让人们容易记忆而已，ID 与帐号的 对应就在 / etc /passwd 当中。</p><p>每个登陆的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称 UID)、一个是群组 ID (Group ID ，简称 GID)。 </p><p>文件是利用UID与GID来判别拥有者与群组。每一个文件都会有所谓的拥有者ID与拥有群组ID，当要显示文件属性时，系统会依据 / etc / passwd 与  / etc /group 的内容， 找到 UID / GID 对应的帐号与群组名称再显示出来。</p><h3 id="使用者账号"><a href="#使用者账号" class="headerlink" title="使用者账号"></a>使用者账号</h3><p>Linux 系统上面的使用者需要登陆主机以取得 shell工作环境，通过网络要使用ssh。输入账号密码后，系统做了工作：</p><ol><li>先找寻 / etc / passwd里面是否有你输入的帐号，如果没有则跳出，如果有的话则将该帐号对应的 UID 与 GID (在 / etc / group 中) 读出来，另外，该帐号的主文件夹与 shell 设置也一并读出。</li><li>来则是核对密码表啦!这时Linux会进入 / etc / shadow里面找出对应的帐号与UID，然后核对一下你刚刚输入的密码与里头的密码是否相符。</li><li>一切都OK的话，就进入Shell控管的阶段 。</li></ol><p>/ etc / passwd 文件结构<br>这个文件的构造是这样的:每一行都代表一个帐号，有几行就代表有几个帐号在你的系统中! 不过需要特别留意的是，里头很多帐号本来就是系统正常运行所必须要的，我们可以简称他为系统帐号， 例如 bin, daemon, adm, nobody 等等，这些帐号请不要随意的杀掉。</p><p>shadow中存储的密码单向运算。</p><p>遗忘密码</p><ol><li>一般用户的密码忘记了:这个最容易解决，请系统管理员帮忙， 他会重新设置好你的密码而不需要知道你的旧密码!利用 root 的身份使用 passwd 指令来处理即可。 </li><li>root密码忘记了，就比较麻烦了，但是可以使用各种可行的方法开机进入Linux再去修改。</li></ol><h3 id="关于群组：有效与初始群组，groups，newgrp"><a href="#关于群组：有效与初始群组，groups，newgrp" class="headerlink" title="关于群组：有效与初始群组，groups，newgrp"></a>关于群组：有效与初始群组，groups，newgrp</h3><p>/ etc / group文件结构<br>这个文件就是在记录GID与群组名称的对应。</p><h4 id="有效群组（effective-group）与初始群组（initial-group）"><a href="#有效群组（effective-group）与初始群组（initial-group）" class="headerlink" title="有效群组（effective group）与初始群组（initial group）"></a>有效群组（effective group）与初始群组（initial group）</h4><p>每个使用者在他的passwd第四栏有所谓的GID，就是所谓的初始群组（initial group），也就是当使用者一登陆系统，立刻就拥有这个群组的相关权限。</p><h4 id="groups有效与支持群组的观察"><a href="#groups有效与支持群组的观察" class="headerlink" title="groups有效与支持群组的观察"></a>groups有效与支持群组的观察</h4><p>知道所有的支持群组：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.42.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在这个输出的讯息中，可知道 dmtsai 这个用户同时属于 dmtsai, wheel 及 users 这三个群组，而且，第一个输出的群组即为有效群组 (effective group) 。 通常有效群组的作用在新建文件，确定新建文件所在的群组。</p><h4 id="newgrp：有效群组的切换"><a href="#newgrp：有效群组的切换" class="headerlink" title="newgrp：有效群组的切换"></a>newgrp：有效群组的切换</h4><p>newgrp 是有限制的，那就是你想要 切换的群组必须是你已经有支持的群组。举例来说， dmtsai 可以在 dmtsai / wheel / users 这三 个群组间切换有效群组，但是 dmtsai 无法切换有效群组成为 sshd 。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.48.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.51.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>加入一个群组有两个方式，一是通过系统管理员 (root) 利用 <strong>usermod</strong> 帮你加入，如果 root 太忙了而且你的系统有设置群组管理员，那么还可以通过群组管理员以 <strong>gpasswd</strong> 加入他所管理的群组中 。</p><p>/ etc / gshadow<br>以系统管理员的角度来说，这个 gshadow 最大的功能就是创建群组管理员。root 可能平时太忙碌，所以当有使 用者想要加入某些群组时， root 或许会没有空管理。此时如果能够创建群组管理员的话，那 么该群组管理员就能够将那个帐号加入自己管理的群组中! 可以免去 root 的忙碌啦!不过， 由于目前有类似 sudo 之类的工具， 所以这个群组管理员的功能已经很少使用了。 </p><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel"><a href="#新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel" class="headerlink" title="新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel"></a>新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel</h3><p>创建一个可用的账号需要账号与密码两个数据，账号可以用useradd来新建使用者，密码则使用passwd。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%885.29.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>系统会进行的操作：</p><ol><li>在 / etc / passwd 里面创建一行与帐号相关的数据，包括创建 UID / GID / 主文件夹等 。</li><li>在 / etc / shadow 里面将此帐号的密码相关参数填入，但是尚未有密码。</li><li>在 / etc / group 里面加入一个与帐号名称一模一样的群组名称。</li><li>在 / home 下面创建一个与帐号同名的目录作为使用者主文件夹，且权限为 700。</li></ol><p>由于在 / etc / shadow内仅会有密码参数而不会有加密过的密码数据，因此我们在创建使用者帐 号时， 还需要使用“ passwd 帐号 ”来给 密码才算是完成了使用者创建的流程。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%885.53.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>以上是root来设置用户的权限。用户还可以自己来更改自己的密码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%885.55.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用chage来进行更详细的密码参数显示功能。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.38.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>usermod<br>在使用useradd后，可以利用usermod来对某些地方进行细部修改。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.51.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>userdel<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.52.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>删除使用者的相关数据。</p><h3 id="使用者功能"><a href="#使用者功能" class="headerlink" title="使用者功能"></a>使用者功能</h3><p>一般身份使用者使用的指令。</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id 这个指令则可以查询某人或自己的相关 UID / GID 等等的信息 。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.58.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>就是change shell的简写。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.01.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="新增与移除群组"><a href="#新增与移除群组" class="headerlink" title="新增与移除群组"></a>新增与移除群组</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.03.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>跟 usermod 类似的，这个指令仅是在进行 group 相关参数的修改而已。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.04.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.05.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="gpasswd群组管理员功能"><a href="#gpasswd群组管理员功能" class="headerlink" title="gpasswd群组管理员功能"></a>gpasswd群组管理员功能</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.06.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="主机的细部权限规划：ACL的使用"><a href="#主机的细部权限规划：ACL的使用" class="headerlink" title="主机的细部权限规划：ACL的使用"></a>主机的细部权限规划：ACL的使用</h2><h3 id="什么是ACL与如何支持启动ACL"><a href="#什么是ACL与如何支持启动ACL" class="headerlink" title="什么是ACL与如何支持启动ACL"></a>什么是ACL与如何支持启动ACL</h3><p>ACL即Access Control List，传统的 Linux 权限只能针对一个用户、一个群组及非此群组的其他人设置权限而已，无法针对单一用户或个人来设计权限。而 ACL 就是为了要改变这个问题 。</p><h3 id="ACL的设置技巧：getfacl，setfacl"><a href="#ACL的设置技巧：getfacl，setfacl" class="headerlink" title="ACL的设置技巧：getfacl，setfacl"></a>ACL的设置技巧：getfacl，setfacl</h3><h2 id="使用者身份切换"><a href="#使用者身份切换" class="headerlink" title="使用者身份切换"></a>使用者身份切换</h2><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>su 是最简单的身份切换指令了，可以进行任何身份的切换。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.19.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>su 需要了解新切换的使用者密码 (常常是需要 root 的密码)， sudo 的执行则仅需要 自己的密码即可! 甚至可以设置不需要密码即可执行 sudo 。由于 sudo可以让你以其他用 户的身份执行指令 (通常是使用 root 的身份来执行指令)，因此并非所有人都能够执行 sudo ， 而是仅有规范到 _etc_sudoers 内的用户才能够执行 sudo 这个指令。</p><p>一般用户能够具有 sudo 的使用权，就是管理员事先审核通过后，才开放sudo 的使用权的!因此，除非是信任用户，否则一般用户默认是不能操作 sudo的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.21.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;鸟哥-Linux账号管理&quot;&gt;&lt;a href=&quot;#鸟哥-Linux账号管理&quot; class=&quot;headerlink&quot; title=&quot;鸟哥 Linux账号管理&quot;&gt;&lt;/a&gt;鸟哥 Linux账号管理&lt;/h1&gt;&lt;h2 id=&quot;Linux的账号与群组&quot;&gt;&lt;a href=&quot;#Li
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>廖雪峰SQL</title>
    <link href="https://github.com/zdkswd/2019/02/03/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/"/>
    <id>https://github.com/zdkswd/2019/02/03/廖雪峰SQL/</id>
    <published>2019-02-03T05:22:32.000Z</published>
    <updated>2019-02-03T05:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>NoSQL数据库，也就是非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等，它们都不是关系数据库。有很多人鼓吹现代Web程序已经无需关系数据库了，只需要使用NoSQL就可以。但事实上，SQL数据库从始至终从未被取代过。今天，SQL数据库仍然承担了各种应用程序的核心数据存储，而NoSQL数据库作为SQL数据库的补充，两者不再是二选一的问题，而是主从关系。所以，无论使用哪种编程语言，无论是Web开发、游戏开发还是手机开发，掌握SQL，是所有软件开发人员所必须的。</p><p>数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心。</p><p>数据库按照数据结构来组织，存储和管理数据，数据库一共有三种模型。层次模型，网状模型，关系模型。关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表。</p><p>随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。因为相比层次模型和网状模型，关系模型理解和使用起来最简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8A%E5%8D%8811.01.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。</p><p>数据类型<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8A%E5%8D%8811.02.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>表中列举了最常用的数据类型。很多数据类型还有别名，例如，REAL又可以写成FLOAT(24)。还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。</p><p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。</p><p><strong>主流关系数据库</strong><br>目前主流关系数据库分为：</p><ol><li>商用数据库，例如：Oracle，SQL Server，DB2等；</li><li>开源数据库，例如：MySQL，PostgreSQL等；</li><li>桌面数据库，以微软Access为代表，适合桌面应用程序使用；</li><li>嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。</li></ol><p><strong>SQL</strong><br>SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。</p><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。本文做出约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p><p><strong>MySQL</strong><br>MySQL是目前应用最广泛的开源关系数据库。MySQL经过几次收购就变成了Oracle旗下的产品。和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ol><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ol><p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</p><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。</p><p>由于MySQL是开源的，所以还有其衍生版本。</p><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。</p><p><strong>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</strong></p><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p>在关系数据库中，关系是通过<strong>主键</strong>和<strong>外键</strong>来维护的。</p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<strong>主键</strong>。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键</strong>。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有：</p><ol><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8A%E5%8D%8811.24.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>id_num和id_type这两列作为联合主键。<strong>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</strong></p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为<strong>外键</strong>。<br>students表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.53.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>classes表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.54.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.57.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为<strong>外键</strong>。外键并不是通过列名实现的，而是通过定义外键约束实现的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.59.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。</p><p><strong>由于外键约束会降低数据库的性能</strong>，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过ALTER TABLE实现的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.02.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN …实现的。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：<br>teacher表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.10.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>classes表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.10.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>中间表teacher_class关联两个一对多关系：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.11.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过中间表，我们就定义了一个“多对多”关系。</p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，students表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表contacts，我们就可以得到一个“一对一”关系：这里一对一的前提是student_id不重复。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.21.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>既然是一对一关系，那为啥不给students表增加一个mobile列，来合二为一。</p><p>如果业务允许，完全可以把两个表合为一个表。一对一关系准确地说，是contacts表一对一对应students表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于students表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.25.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要经常根据score列进行查询，就可以对score列创建索引：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.26.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.27.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.31.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过UNIQUE关键字我们就添加了一个唯一索引。也可以只对某一列添加一个唯一约束而不创建唯一索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.32.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种情况下，name列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>假设表名是students，要查询students表的所有行，我们用如下SQL语句：</p><blockquote><p>SELECT * FROM students;  </p></blockquote><p>使用SELECT <em> FROM students时，SELECT是关键字，表示将要执行一个查询，</em> 表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。该SQL将查询出students表的所有数据。注意：查询结果也是一个<strong>二维表</strong>，它包含列名和每一行的数据。</p><p>不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。</p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><blockquote><p>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;  </p></blockquote><p>条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><ol><li>根据score列的数据判断：score &gt;= 80</li><li>根据gender列的数据判断：gender = ‘M’，注意gender列存储的是字符串，需要用单引号括起来。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.44.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>除了AND以外，还有NOT以及OR。如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。</p><h3 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.46.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>%表示0个到多个，_ 表示1个。</p><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM …，让结果集仅包含指定列。这种操作称为投影查询。例如，从students表中返回id、score和name这三列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.52.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。</p><p>使用SELECT 列1, 列2, 列3 FROM …时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM …。</p><p>例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.53.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>投影查询同样可以接WHERE条件，实现复杂的查询。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上ORDER BY子句。例如按照成绩从低到高进行排序：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.04.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.04.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。</p><p>如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.06.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT <m> OFFSET <n>子句实现。我们先把所有学生按照成绩从高到低进行排序，把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.10.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：类似的，查询第3页的时候，OFFSET应该设定为6:由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”。</n></m></p><p>OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。<br>OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。</p><p>在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。使用LIMIT <m> OFFSET <n>分页时，随着N越来越大，查询效率也会越来越低。</n></m></p><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.16.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>COUNT( <em> )表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT( </em> )。</p><p>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.16.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>COUNT(*)和COUNT(id)实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.17.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>除了COUNT()函数外，SQL还提供了如下聚合函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.19.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。</p><p>要统计男生的平均成绩，我们用下面的聚合查询：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.19.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而MAX()、MIN()、MAX()和MIN()会返回NULL。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.25.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。</p><p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.27.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.27.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>聚合查询的列中，只能放入分组的列。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.34.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.34.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM &lt;表1&gt; &lt;表2&gt;。</p><p>同时从students表和classes表的“乘积”，即查询数据，可以这么写：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.39.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。</p><p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。<strong>使用多表查询可以获取M x N行记录；多表查询的结果集可能非常巨大，要小心使用。</strong></p><p>查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理</p><p>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.41.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.43.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。</p><p>多表查询也是可以添加WHERE条件的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.44.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p><p>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。</p><p>连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.48.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用FROM &lt;表1&gt;的语法；</li><li>再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；</li><li>然后确定连接条件，使用ON &lt;条件…&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；</li><li>可选：加上WHERE子句、ORDER BY等子句。</li></ol><p>使用别名不是必须的，但可以更好地简化查询语句。有内连接（INNER JOIN）就有外连接（OUTER JOIN）。</p><p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><p>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。</p><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</p><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一列，并添加class_id=5，由于classes表并不存在id=5的列，所以，LEFT OUTER JOIN的结果会增加一列，对应的class_name是NULL。</p><p>inner join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>left outer join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l%202.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>right outer join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l%203.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>full outer join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l%204.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p>插入数据基本语法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.54.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.54.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果一个字段有默认值，那么在INSERT语句中也可以不出现。</p><p>要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) …，但是对应的VALUES就得变成(80, ‘M’, ‘大牛’, 2)。</p><p>还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(…)包含的一组值：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.55.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>更新数据库表中的记录，我们就必须使用UPDATE语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.57.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>例如，我们想更新students表id=1的记录的name和score这两个字段，先写出UPDATE students SET name=’大牛’, score=66，然后在WHERE子句中写出需要更新的行的筛选条件id=1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.58.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.59.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.59.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。要特别小心的是，UPDATE语句可以没有WHERE条件，这时，整个表的所有记录都会被更新。</strong></p><p><strong>所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。</strong></p><p>在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>删除数据库表中的记录，我们可以使用DELETE语句。<br>基本语法是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.03.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.04.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.04.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。<strong>要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据。</strong></p><p>整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。</p><p>在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。</p><h1 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h1><h2 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h2><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.12.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。</p><h2 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h2><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO … ON DUPLICATE KEY UPDATE …语句：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.12.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。</p><h2 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h2><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO …语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.16.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.18.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>新创建的表结构和SELECT使用的表结构完全一致。</p><h2 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h2><p>如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表statistics，记录各班的平均成绩：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.22.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以用一条语句写入各班的平均成绩：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.24.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.25.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<strong>事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p>数据库事务有ACID这4个特性。</p><ol><li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ol><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<strong>隐式事务</strong>。</p><p>要手动把多条SQL语句作为一个事务执行，使用<strong>BEGIN</strong>开启一个事务，使用<strong>COMMIT</strong>提交一个事务，这种事务被称为<strong>显式事务</strong>，例如，把上述的转账操作作为一个显式事务：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.28.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。</p><p><strong>COMMIT</strong>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<strong>COMMIT</strong>语句执行失败了，整个事务也会失败。</p><p>有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.31.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.34.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h2><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.38.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>事务B两次读到的数据不一致。</p><h2 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h2><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>表中数据现在为Alice。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.43.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h2><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.56.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。</p><p>Repeatable Read下在同一个事务内的查询都是与事务开始时刻一致，所以在B事务过程中是不会读到期间A中insert的值的。</p><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><h2 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h2><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;NoSQL数据库，也就是非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等，它们都不是关系数据库。有很多人鼓吹现代W
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="SQL" scheme="https://github.com/zdkswd/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Shell Scripts</title>
    <link href="https://github.com/zdkswd/2019/01/30/Shell%20Scripts/"/>
    <id>https://github.com/zdkswd/2019/01/30/Shell Scripts/</id>
    <published>2019-01-30T10:06:32.000Z</published>
    <updated>2019-02-05T11:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell-Scripts"><a href="#Shell-Scripts" class="headerlink" title="Shell Scripts"></a>Shell Scripts</h1><h2 id="什么是Shell-scripts"><a href="#什么是Shell-scripts" class="headerlink" title="什么是Shell scripts"></a>什么是Shell scripts</h2><p>shell script是利用shell的功能所写的一个程序，这个程序使用纯文本文件，将一些shell的语法与指令（含外部指令）写在里面，搭配正则表达式，管线命令与数据流重导向等功能，以达到我们所想要的处理目的。</p><h3 id="干嘛学习shell-scripts"><a href="#干嘛学习shell-scripts" class="headerlink" title="干嘛学习shell scripts"></a>干嘛学习shell scripts</h3><h4 id="自动化管理的重要依据"><a href="#自动化管理的重要依据" class="headerlink" title="自动化管理的重要依据"></a>自动化管理的重要依据</h4><h4 id="追踪与管理系统的重要工作"><a href="#追踪与管理系统的重要工作" class="headerlink" title="追踪与管理系统的重要工作"></a>追踪与管理系统的重要工作</h4><p>系统服务启动接口所在的目录下所有文件都是scripts，包括开机（booting）过程也都是利用shell script来帮忙搜寻系统的相关设置数据，然后再代入各个服务的设置参数。</p><h4 id="简单入侵侦测功能"><a href="#简单入侵侦测功能" class="headerlink" title="简单入侵侦测功能"></a>简单入侵侦测功能</h4><h4 id="连续指令单一化"><a href="#连续指令单一化" class="headerlink" title="连续指令单一化"></a>连续指令单一化</h4><h4 id="简易的数据处理"><a href="#简易的数据处理" class="headerlink" title="简易的数据处理"></a>简易的数据处理</h4><h4 id="跨平台支持与学习历程较短"><a href="#跨平台支持与学习历程较短" class="headerlink" title="跨平台支持与学习历程较短"></a>跨平台支持与学习历程较短</h4><h3 id="第一支script的撰写与执行"><a href="#第一支script的撰写与执行" class="headerlink" title="第一支script的撰写与执行"></a>第一支script的撰写与执行</h3><p>shell script其实就是纯文本文件，可以编辑这个文件，然后让这个文件一次执行多个指令。</p><ol><li>指令的执行是从上而下、从左而右的分析与执行。</li><li>指令、选项与参数间的多个空白都会被忽略掉。</li><li>空白行也将被忽略掉，并且[tab]按键所推开的空白同样视为空白键。</li><li>如果读取到一个Enter符号 (CR) ，就尝试开始执行该行 (或该串) 命令。</li><li>至于如果一行的内容太多，则可以使用“ [Enter]”来延伸至下一行。</li><li>#可做为注解!任何加在 #后面的数据将全部被视为注解文字而被忽略!</li></ol><p>假设编写好的文件名为shell.sh。执行方法有。</p><ol><li>直接指令下达：shell.sh文件必须具备可读与可执行（rx）的权限。无论如何到达shell.sh的目录，然后直接输入shell.sh就能执行。</li><li>以bash程序来执行，通过bash shell.sh或sh shell.sh来执行。</li></ol><h4 id="撰写第一支script"><a href="#撰写第一支script" class="headerlink" title="撰写第一支script"></a>撰写第一支script</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Shell%20Scripts/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-30%20%E4%B8%8B%E5%8D%884.17.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>第一行# ! / bin / bash在宣告这个script使用的shell名称:因为我们使用的是bash，所以，必须要以“ # ! / bin / bash”来宣告这个文件内的语法使用bash的语法!那么当这个程序被执行时，他就能够载入bash的相关环境配置文件(一般来说就是non-login shell的~/.bashrc)，并且执行bash来使我们下面的指令能够执行!这很重要的! (在很多状况中，如果没有设置好这一行，那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么shell 来执行啊! )</li><li>程序内容的说明: 整个script当中，除了第一行的“ # !”是用来宣告shell的之外，其他的 # 都是“注解”用途! 所以上面的程序当中，第二行以下就是用来说明整个程序的基本数据。一般来说，建议你一定要养成说明该script的:1.内容与功能;2.版本信息; 3.作者与联络方式;4.创建日期;5.历史纪录等等。这将有助于未来程序的改写与debug。</li><li>执行成果告知(定义回传值)，可以利用exit这个指令来让程序中断，并且回传一个数值给系统。利用exit n（n是数字）的功能，可以自订错误讯息，让程序变得更加smart。</li></ol><h3 id="撰写shell-script的良好习惯创建"><a href="#撰写shell-script的良好习惯创建" class="headerlink" title="撰写shell script的良好习惯创建"></a>撰写shell script的良好习惯创建</h3><p>在每个script的文件开始处记录好：</p><ol><li>script的功能</li><li>script的版本信息</li><li>script的作者与联络方式</li><li>script的版权宣告方式</li><li>script的历史记录</li><li>script内教特殊的指令，使用绝对路径的方式来下达</li><li>script运行时需要的环境变量预先宣告与设置</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shell-Scripts&quot;&gt;&lt;a href=&quot;#Shell-Scripts&quot; class=&quot;headerlink&quot; title=&quot;Shell Scripts&quot;&gt;&lt;/a&gt;Shell Scripts&lt;/h1&gt;&lt;h2 id=&quot;什么是Shell-scripts&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH</title>
    <link href="https://github.com/zdkswd/2019/01/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/"/>
    <id>https://github.com/zdkswd/2019/01/28/认识与学习BASH/</id>
    <published>2019-01-28T12:55:32.000Z</published>
    <updated>2019-01-28T13:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识与学习BASH"><a href="#认识与学习BASH" class="headerlink" title="认识与学习BASH"></a>认识与学习BASH</h1><h2 id="认识BASH这个Shell"><a href="#认识BASH这个Shell" class="headerlink" title="认识BASH这个Shell"></a>认识BASH这个Shell</h2><h3 id="硬件，核心与Shell"><a href="#硬件，核心与Shell" class="headerlink" title="硬件，核心与Shell"></a>硬件，核心与Shell</h3><p>必须通过shell将我们输入指令与内核沟通，好让内核可以控制硬件来正确无误的工作。操作系统其实是一组软件，这组软件在控制整个硬件与管理系统的活动监测，操作系统管理的就是整个硬件功能。使用者通过应用程序来指挥内核让内核达成我们所需要的硬件任务。壳程序的功能知识提供使用者操作系统的一个接口，因此需要可以调用其他软件，就是很多其他的指令，我们可以通过壳程序（就是命令行界面）来操作这些应用程序，让这些应用程序调用核心来运行所需的工作。只要能够操作应用程序的接口都能称为壳程序，狭义的壳程序指的是命令行包括bash，广义的壳程序包括图形接口软件。</p><h3 id="为何要学命令行shell"><a href="#为何要学命令行shell" class="headerlink" title="为何要学命令行shell"></a>为何要学命令行shell</h3><h4 id="命令行shell：大家都一样"><a href="#命令行shell：大家都一样" class="headerlink" title="命令行shell：大家都一样"></a>命令行shell：大家都一样</h4><p>几乎各家distribution使用的bash都是一样的。</p><h4 id="远端管理：命令行就是比较快"><a href="#远端管理：命令行就是比较快" class="headerlink" title="远端管理：命令行就是比较快"></a>远端管理：命令行就是比较快</h4><p>Linux的管理常常需要通过远端连线，而连线时命令行的传速度一定比较快，而且不容易出现断线或者是信息外流的问题。</p><h4 id="Linux的任督二脉：shell"><a href="#Linux的任督二脉：shell" class="headerlink" title="Linux的任督二脉：shell"></a>Linux的任督二脉：shell</h4><h3 id="系统的合法shell与-etc-shells功能"><a href="#系统的合法shell与-etc-shells功能" class="headerlink" title="系统的合法shell与/etc/shells功能"></a>系统的合法shell与/etc/shells功能</h3><p>shell有众多版本，Linux的叫bash，也是基于GNU架构下发展出来的。shell还包括sh，csh。在/ etc / shells这个文件中至少就有几个可以用的shells。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8B%E5%8D%889.36.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们系统合法的shell要写入/ etc / shells这个文件，系统某些服务在运行过程中，会去检查使用者能够使用的shells，检查的文件就是 / etc / shells这个文件。</p><h3 id="Bash-shell的功能"><a href="#Bash-shell的功能" class="headerlink" title="Bash shell的功能"></a>Bash shell的功能</h3><p>bash是Linux distributions的标准shell。bash主要相容于sh。bash的主要优点：</p><h4 id="命令编修能力（history）"><a href="#命令编修能力（history）" class="headerlink" title="命令编修能力（history）"></a>命令编修能力（history）</h4><p>bash可以使用上下键找到前后一个输入的指令，在很多distribution中，默认的指令记忆功能可以达到1000个，指令记录放在主文件夹内的.bash_history中，不过~/ .bash_history记录的是前一次登录以前所执行的指令，这一次登录的指令都被暂存在内存中，当成功登出系统后，指令记忆才会记录到.bash_history中。</p><h4 id="命令与文件补全功能（【tab】键的好处）"><a href="#命令与文件补全功能（【tab】键的好处）" class="headerlink" title="命令与文件补全功能（【tab】键的好处）"></a>命令与文件补全功能（【tab】键的好处）</h4><h4 id="命令别名设置功能：（alias）"><a href="#命令别名设置功能：（alias）" class="headerlink" title="命令别名设置功能：（alias）"></a>命令别名设置功能：（alias）</h4><p>在命令行输入alias就可以知道目前的命令别名有哪些了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%888.52.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>就可以用alias来替代ls -al命令了。</p><h4 id="工作控制，前景背景控制（job-control-foreground-background）"><a href="#工作控制，前景背景控制（job-control-foreground-background）" class="headerlink" title="工作控制，前景背景控制（job control,foreground,background）"></a>工作控制，前景背景控制（job control,foreground,background）</h4><h4 id="程序化脚本（shell-scripts）"><a href="#程序化脚本（shell-scripts）" class="headerlink" title="程序化脚本（shell scripts）"></a>程序化脚本（shell scripts）</h4><p>将管理系统需要下达的连续指令写成一个文件，该文件可以通过对谈互动式的方式来进行主机的侦测工作，也可以借由shell提供的环境变量及相关指令来进行设计。</p><h4 id="万用字符（wildcard）"><a href="#万用字符（wildcard）" class="headerlink" title="万用字符（wildcard）"></a>万用字符（wildcard）</h4><p>bash还支持许多的万用字符来帮助使用者查询与指令下达，比如想知道有多少以X为开头的文件，就可使用 X * 来查看。</p><h3 id="查询指令是否是Bash-shell的内置命令：type"><a href="#查询指令是否是Bash-shell的内置命令：type" class="headerlink" title="查询指令是否是Bash shell的内置命令：type"></a>查询指令是否是Bash shell的内置命令：type</h3><p>通过type指令来知道指令是来自于外部指令（其他非bash所提供的指令）或是内置在bash当中的指令。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.14.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="指令的下达与快速编辑按钮"><a href="#指令的下达与快速编辑按钮" class="headerlink" title="指令的下达与快速编辑按钮"></a>指令的下达与快速编辑按钮</h3><p>使用反斜杠加回车键，可以进行多行的输入。</p><h2 id="Shell的变量功能"><a href="#Shell的变量功能" class="headerlink" title="Shell的变量功能"></a>Shell的变量功能</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><h4 id="变量的可变性与方便性"><a href="#变量的可变性与方便性" class="headerlink" title="变量的可变性与方便性"></a>变量的可变性与方便性</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.43.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>小写的mail是指令，大写的MAIL是变量名称。</p><h4 id="影响bash环境操作的变量"><a href="#影响bash环境操作的变量" class="headerlink" title="影响bash环境操作的变量"></a>影响bash环境操作的变量</h4><p>系统通过PATH这个变量里面的内容记录的路径顺序来搜寻指令。环境变量如PATH，HOME，MAIL，SHELL等等，都是很重要的，为了区别与自订变量的不同，环境变量通常以大写字符表示。</p><h4 id="脚本程序设计（shell-script）的好帮手"><a href="#脚本程序设计（shell-script）的好帮手" class="headerlink" title="脚本程序设计（shell script）的好帮手"></a>脚本程序设计（shell script）的好帮手</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.49.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="变量的取用与设置：echo，变量设置规则，unset"><a href="#变量的取用与设置：echo，变量设置规则，unset" class="headerlink" title="变量的取用与设置：echo，变量设置规则，unset"></a>变量的取用与设置：echo，变量设置规则，unset</h3><h4 id="变量的取用：echo"><a href="#变量的取用：echo" class="headerlink" title="变量的取用：echo"></a>变量的取用：echo</h4><p>变量前面要加上$符号才行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.59.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>设置和修改变量内容，用等号连接变量与他的内容就好了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.02.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当一个变量名称尚未被设置时，默认的内容是空，变量在设置时也要符合一些规则，否则设置失败。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.09.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.11.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>子程序就是在目前这个shell的情况下，去启用另一个新的shell，新的shell就是子程序，在一般状态下，父程序的自订变量是无法在子程序中使用的，但是通过export将变量变成环境变量后，就能够在子程序下面应用了。</p><h3 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h3><h4 id="用env观察环境变量与常见环境变量说明"><a href="#用env观察环境变量与常见环境变量说明" class="headerlink" title="用env观察环境变量与常见环境变量说明"></a>用env观察环境变量与常见环境变量说明</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.46.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>MAIL当我们使用mail这个指令收信时，系统会去读取的邮件信箱文件（mailbox）。</p><h4 id="用set观察所有变量（含环境变量与自订变量）"><a href="#用set观察所有变量（含环境变量与自订变量）" class="headerlink" title="用set观察所有变量（含环境变量与自订变量）"></a>用set观察所有变量（含环境变量与自订变量）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.51.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="影响显示结果的语系变量（locale）"><a href="#影响显示结果的语系变量（locale）" class="headerlink" title="影响显示结果的语系变量（locale）"></a>影响显示结果的语系变量（locale）</h3><p>利用locale指令查询Linux支持了多少语系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.15.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.15.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="变量键盘读取，数组与声明：read，array，declare"><a href="#变量键盘读取，数组与声明：read，array，declare" class="headerlink" title="变量键盘读取，数组与声明：read，array，declare"></a>变量键盘读取，数组与声明：read，array，declare</h3><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>要读取来自键盘输入的变量，就是用read这个指令。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.23.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="declare，typeset"><a href="#declare，typeset" class="headerlink" title="declare，typeset"></a>declare，typeset</h4><p>declare与typeset是一样都是声明变量的类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.24.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>变量的默认类型是字符串，所以若是不指定变量类型，则1+2为一个字符串而不是计算式，bash环境中的数值计算默认最多能达到整数形态，所以1 / 3结果是0。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.29.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="array变量类型"><a href="#array变量类型" class="headerlink" title="array变量类型"></a>array变量类型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.31.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.30.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.31.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="与文件系统及程序的限制关系：ulimit"><a href="#与文件系统及程序的限制关系：ulimit" class="headerlink" title="与文件系统及程序的限制关系：ulimit"></a>与文件系统及程序的限制关系：ulimit</h3><p>由于Linux主机是多用户多任务操作系统，防止资源超过限制，bash可以限制使用者的某些系统资源，包括可以打开的文件数量，可以使用的CPU时间，可以使用的内存总量。用ulimit来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.34.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一般身份使用者如果以ulimit设置了-f的文件大小，那么只能继续减小文件的大小，不能增加文件的大小。</p><h3 id="变量内容的删除，取代与替换（optional）"><a href="#变量内容的删除，取代与替换（optional）" class="headerlink" title="变量内容的删除，取代与替换（optional）"></a>变量内容的删除，取代与替换（optional）</h3><h4 id="变量内容的删除与取代"><a href="#变量内容的删除与取代" class="headerlink" title="变量内容的删除与取代"></a>变量内容的删除与取代</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.59.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%8812.03.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="变量的测试与内容替换"><a href="#变量的测试与内容替换" class="headerlink" title="变量的测试与内容替换"></a>变量的测试与内容替换</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%8812.06.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="headerlink" title="命令别名与历史命令"></a>命令别名与历史命令</h2><h3 id="命令别名设置：alias，unalias"><a href="#命令别名设置：alias，unalias" class="headerlink" title="命令别名设置：alias，unalias"></a>命令别名设置：alias，unalias</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.22.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="历史命令：history"><a href="#历史命令：history" class="headerlink" title="历史命令：history"></a>历史命令：history</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.24.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当以bash登陆Linux主机之后，系统会主动由主文件夹的~ / .bash_history读取以前曾经下过的指令，记录的条数与bash的HISTFILESIZE这个变量设置值有关。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.35.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Bash-Shell的操作环境"><a href="#Bash-Shell的操作环境" class="headerlink" title="Bash Shell的操作环境"></a>Bash Shell的操作环境</h2><h3 id="路径与指令搜寻顺序"><a href="#路径与指令搜寻顺序" class="headerlink" title="路径与指令搜寻顺序"></a>路径与指令搜寻顺序</h3><p>指令运行的顺序：</p><ol><li>以相对/ 绝对路径执行指令，例如/ bin / ls 或 . / ls。</li><li>由alias找到该指令来执行。</li><li>由bash内置的（builtin）指令来执行。</li><li>通过$PATH这个变量的顺序搜寻到的第一个指令来执行。</li></ol><h3 id="bash的进站与欢迎讯息：-etc-issue-etc-motd"><a href="#bash的进站与欢迎讯息：-etc-issue-etc-motd" class="headerlink" title="bash的进站与欢迎讯息：/ etc / issue,/ etc / motd"></a>bash的进站与欢迎讯息：/ etc / issue,/ etc / motd</h3><p>登陆时的提示字串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.46.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>登陆后取得一些讯息，可以将讯息加入到/ etc / motd中，一定要root的身份才能修改。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.48.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="bash的环境配置文件"><a href="#bash的环境配置文件" class="headerlink" title="bash的环境配置文件"></a>bash的环境配置文件</h3><h4 id="login与non-login-shell"><a href="#login与non-login-shell" class="headerlink" title="login与non-login shell"></a>login与non-login shell</h4><p>区别在于取得bash用不用登陆（login）。这两个取得bash的情况中，读取的配置文件数据并不一致。<br>login shell会读取下列文件：</p><ol><li>/ etc / profile:这是系统整体的设置，最好不要修改这个文件。</li><li>~ / .bash_profile 或 ~ / .bash_login 或 ~ / .profile :属于使用者个人设置，要改自己的数据，就写入这里。</li></ol><p>non-login shell仅会读取：~ / .bashrc 而已。</p><h3 id="终端机的环境设置：stty，set"><a href="#终端机的环境设置：stty，set" class="headerlink" title="终端机的环境设置：stty，set"></a>终端机的环境设置：stty，set</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.26.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>bash默认组合键。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.27.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="万用字符与特殊符号"><a href="#万用字符与特殊符号" class="headerlink" title="万用字符与特殊符号"></a>万用字符与特殊符号</h3><p>万用字符：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.28.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>特殊符号：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h2><p>数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，给它传输到其他的地方，例如文件或者是设备，在Linux文字模式下很重要，尤其是如果想要将某些数据存储下来。</p><h3 id="什么是数据流重导向"><a href="#什么是数据流重导向" class="headerlink" title="什么是数据流重导向"></a>什么是数据流重导向</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.46.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="命令执行的判断依据：；，-amp-amp-，‖"><a href="#命令执行的判断依据：；，-amp-amp-，‖" class="headerlink" title="命令执行的判断依据：；，&amp;&amp;，‖"></a>命令执行的判断依据：；，&amp;&amp;，‖</h3><h2 id="管线命令（pipe）"><a href="#管线命令（pipe）" class="headerlink" title="管线命令（pipe）"></a>管线命令（pipe）</h2><p>管线命令使用的是“|”界定符号，管线命令与连续下达命令式不一样的。管线命令“|”仅能处理经由前面一个指令传来的正确信息，也就是standard output信息，对于stdandard error并没有直接处理的能力。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.06.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ol><li>管线命令仅会处理standard output，对于standard error output会予以忽略</li><li>管线命令必须能够接受来自前一个指令的数据成为standard input继续处理才行。</li></ol><h3 id="选取命令：cut，grep"><a href="#选取命令：cut，grep" class="headerlink" title="选取命令：cut，grep"></a>选取命令：cut，grep</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.11.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>cut主要用途是在于将同一行里面的数据进行分解。</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep是分析一行讯息，若当中有我们所需要的信息，就将该行拿出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.17.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="排序命令：sort，wc，uniq"><a href="#排序命令：sort，wc，uniq" class="headerlink" title="排序命令：sort，wc，uniq"></a>排序命令：sort，wc，uniq</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.18.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>想要将重复的数据仅列出一个显示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.21.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>wc指令可以帮我们计算输出讯息的整体数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.22.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="双向重导向：tee"><a href="#双向重导向：tee" class="headerlink" title="双向重导向：tee"></a>双向重导向：tee</h3><h3 id="字符转换命令：tr，col，join，paste，expand"><a href="#字符转换命令：tr，col，join，paste，expand" class="headerlink" title="字符转换命令：tr，col，join，paste，expand"></a>字符转换命令：tr，col，join，paste，expand</h3><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr可以用来删除一段讯息中文字，或者是进行文字讯息的替换。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.36.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.37.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>col键可以用来简单的处理将tab按键取代为空格键。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.42.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>相对于join要对比两个文件的数据相关性，paste就是直接将两行粘在一起，中间以tab隔开。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.45.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h4><h3 id="分区命令：split"><a href="#分区命令：split" class="headerlink" title="分区命令：split"></a>分区命令：split</h3><p>如果有文件太大，找split就对了，可以将一个大文件依据文件大小或行数来分区，就可以将大文件分区为小文件了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.47.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="参数代换：xargs"><a href="#参数代换：xargs" class="headerlink" title="参数代换：xargs"></a>参数代换：xargs</h3><h3 id="关于减号-的用途"><a href="#关于减号-的用途" class="headerlink" title="关于减号-的用途"></a>关于减号-的用途</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识与学习BASH&quot;&gt;&lt;a href=&quot;#认识与学习BASH&quot; class=&quot;headerlink&quot; title=&quot;认识与学习BASH&quot;&gt;&lt;/a&gt;认识与学习BASH&lt;/h1&gt;&lt;h2 id=&quot;认识BASH这个Shell&quot;&gt;&lt;a href=&quot;#认识BASH这个Shel
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="https://github.com/zdkswd/2019/01/27/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://github.com/zdkswd/2019/01/27/vim程序编辑器/</id>
    <published>2019-01-27T02:19:32.000Z</published>
    <updated>2019-01-27T02:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim程序编辑器"><a href="#vim程序编辑器" class="headerlink" title="vim程序编辑器"></a>vim程序编辑器</h1><p>在所有的Linux distributions上都会有一套文书编辑器，即vi，vim是进阶版的vi，vim可以用不同颜色显示文字内容，还可以进行shell script，C program等程序编辑功能，可以将vim视为一种程序编辑器。</p><h2 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h2><p>在Linux的世界中，绝大部分的配置文件都是以ASCII的纯文本形态存在的，因此利用简单的文字编辑软件就能够修改设置了。</p><h3 id="为何要学vim"><a href="#为何要学vim" class="headerlink" title="为何要学vim"></a>为何要学vim</h3><ol><li>所有的Unⅸ Like系统都会内置ⅵ文书编辑器，其他的文书编辑器则不一定会存在。</li><li>很多个别软件的编辑借口都会主动调用vi</li><li>vim具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</li><li>因为程序简单，编辑速度相当快速。</li></ol><p>重点是第二点，因为有太多的Linux上面的指令都默认使用vi作为数据编辑的接口，所以必须一定要学会vi，否则很多指令根本无法操作。</p><p>简单来说vi是老式的文本处理器，不过功能已经很齐全了，但是还是有可以进步的地方，vim则可以说是程序开发者的一项很好用的工具。</p><h2 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h2><h3 id="一般指令模式（command-mode）"><a href="#一般指令模式（command-mode）" class="headerlink" title="一般指令模式（command mode）"></a>一般指令模式（command mode）</h3><p>以ⅵ打开一个文件就直接进入一般指令模式了(这是默认的模式，也简称为一般模式)。在这个模式中，可以使用“上下左右”按键来移动光标，可以使用“删除字符”或”删除整列”来处理文件内容,也可以使用“复制,粘贴”来处理你的文件数据。</p><h3 id="编辑模式（insert-mode）"><a href="#编辑模式（insert-mode）" class="headerlink" title="编辑模式（insert mode）"></a>编辑模式（insert mode）</h3><p>在一般指令模式中可以进行删除丶复制丶贴上等等的动作’但是却无法编辑文件内容的!要等到你按下i,l,o,O,a,A,r,R等任何一个字母之后才会进入编辑模式。注意了!通常在Linux中按下这些按键时,在画面的左下方会出现” INSERT或REPLACE”的字样,此时才可以进行编辑。而如釆要回到一般指令模式时，则必须要按下”Esc”这个按键即可退岀编辑模式。</p><h3 id="命令行命令模式（command-line-mode）"><a href="#命令行命令模式（command-line-mode）" class="headerlink" title="命令行命令模式（command-line mode）"></a>命令行命令模式（command-line mode）</h3><p>在一般模式中，输入：/?三个中的任何一个按钮，就可以将光标移动到最下面的那一列。在这个模式中可以提供你搜寻数据的动作，而读取、存盘、大量取代字符、离开vi、显示行号等等则是在此模式中达成的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.19.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="简易执行范例"><a href="#简易执行范例" class="headerlink" title="简易执行范例"></a>简易执行范例</h3><h4 id="使用vi-filename进入一般指令模式"><a href="#使用vi-filename进入一般指令模式" class="headerlink" title="使用vi filename进入一般指令模式"></a>使用vi filename进入一般指令模式</h4><h4 id="按下i进入编辑模式，开始编辑文字"><a href="#按下i进入编辑模式，开始编辑文字" class="headerlink" title="按下i进入编辑模式，开始编辑文字"></a>按下i进入编辑模式，开始编辑文字</h4><h4 id="按下esc按钮回到一般指令模式"><a href="#按下esc按钮回到一般指令模式" class="headerlink" title="按下esc按钮回到一般指令模式"></a>按下esc按钮回到一般指令模式</h4><h4 id="进入命令行界面，文件存储并离开vi环境"><a href="#进入命令行界面，文件存储并离开vi环境" class="headerlink" title="进入命令行界面，文件存储并离开vi环境"></a>进入命令行界面，文件存储并离开vi环境</h4><p>存盘（write）并离开（quit）的指令很简单，输入<strong>：wq</strong>（冒号要输入）即可存盘离开。（注意，按下后该光标就会移动到最后面一列）。如果文件权限不对，可能无法写入，此时可以使用强制写入，使用<strong>：wq！</strong>（冒号要输入）多加一个惊叹号。</p><h3 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h3><p>编辑模式与命令行界面之间并不能切换。</p><h4 id="一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代"><a href="#一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代" class="headerlink" title="一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代"></a>一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.56.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.57.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.58.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="一般指令模式切换到编辑模式的可用的按钮说明"><a href="#一般指令模式切换到编辑模式的可用的按钮说明" class="headerlink" title="一般指令模式切换到编辑模式的可用的按钮说明"></a>一般指令模式切换到编辑模式的可用的按钮说明</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8B%E5%8D%8812.02.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="一般指令切换到命令行界面可用按钮说明"><a href="#一般指令切换到命令行界面可用按钮说明" class="headerlink" title="一般指令切换到命令行界面可用按钮说明"></a>一般指令切换到命令行界面可用按钮说明</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8B%E5%8D%8812.04.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="vim的暂存盘，救援恢复与打开时的警告讯息"><a href="#vim的暂存盘，救援恢复与打开时的警告讯息" class="headerlink" title="vim的暂存盘，救援恢复与打开时的警告讯息"></a>vim的暂存盘，救援恢复与打开时的警告讯息</h3><p>vim是通过暂存盘来进行救援恢复的。当使用vim编辑时，vim会在同一目录下再创建一个名为.filename.swap的文件。对文件做的动作会被记录到swp当中，如果系统由于某些原因断掉，编辑的文件还没有储存，swp就能发挥救援作用。</p><h2 id="vim的额外功能"><a href="#vim的额外功能" class="headerlink" title="vim的额外功能"></a>vim的额外功能</h2><p>目前大部分的distribution都以vim取代vi了。vim还可以直接进行debug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debug和release的区别</span><br><span class="line">Debug：调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。</span><br><span class="line">Release：发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。</span><br></pre></td></tr></table></figure></p><h3 id="区块选择（Visual-Block）"><a href="#区块选择（Visual-Block）" class="headerlink" title="区块选择（Visual Block）"></a>区块选择（Visual Block）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.03.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><p>可以使用vim后面同时接好几个文件同时打开。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.04.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>利用多文件编辑的功能’可以让你很快速的就将需要的数据复制到正确的文件内。当然这个功能也可以利用窗口接口来达到，那就是多窗口功能。</p><h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><p>vim也可以实现分区窗口的功能。在命令行界面输入<strong>:sp {filename}</strong>即可，filename可有可无，如果想要在新窗口启动另一个文件，就加入文件名，否则仅输入<strong>:sp</strong>，出现的是同一个文件在两个窗口间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.25.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="vim的补全功能"><a href="#vim的补全功能" class="headerlink" title="vim的补全功能"></a>vim的补全功能</h3><p>程序编辑器都可以进行语法检验以及根据输入来挑字进行补全。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.29.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>先输入前者再输入后者。</p><h3 id="vim环境设置与记录：-vimrc，-viminfo"><a href="#vim环境设置与记录：-vimrc，-viminfo" class="headerlink" title="vim环境设置与记录： ~/.vimrc，~/.viminfo"></a>vim环境设置与记录： ~/.vimrc，~/.viminfo</h3><p>以vim软件来搜寻一个文件内部的字串时，字串会被反白。再次vim编辑这个文件时，泛白的情况还是存在的。当重复编辑同一个文件第二次进入该文件时，光标还在上次离开的那一列上头。这是因为vim会主动的将做过的行为记录下来，记录的文件就是：~/.viminfo，该文件是自动生成的，不必自行创建，在vim里所做过的动作都可以在这个文件内部查询到。vim的环境参数有很多，如果想要知道目前的设置值，可以在一般指令模式时输入<strong>：set all</strong>来查阅。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%889.02.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>每次使用vim都要重新设置一次各个参数值貌似不太合理，所以可以通过配置文件直接规定习惯的vim操作环境。整体的vim设置一般放在/ etc / vimrc 这个文件，不过不建议修改，可以修改 ~ / .vimrc这个文件（默认不存在，要手动创建）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%889.06.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="vim常用指令示意图"><a href="#vim常用指令示意图" class="headerlink" title="vim常用指令示意图"></a>vim常用指令示意图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%889.07.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="vim使用注意事项"><a href="#vim使用注意事项" class="headerlink" title="vim使用注意事项"></a>vim使用注意事项</h2><h3 id="中文编码问题"><a href="#中文编码问题" class="headerlink" title="中文编码问题"></a>中文编码问题</h3><h3 id="DOS与Linux的断行字符"><a href="#DOS与Linux的断行字符" class="headerlink" title="DOS与Linux的断行字符"></a>DOS与Linux的断行字符</h3><h3 id="语系编码转换"><a href="#语系编码转换" class="headerlink" title="语系编码转换"></a>语系编码转换</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim程序编辑器&quot;&gt;&lt;a href=&quot;#vim程序编辑器&quot; class=&quot;headerlink&quot; title=&quot;vim程序编辑器&quot;&gt;&lt;/a&gt;vim程序编辑器&lt;/h1&gt;&lt;p&gt;在所有的Linux distributions上都会有一套文书编辑器，即vi，vim是进阶版
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥Linux Linux文件、目录与磁盘格式</title>
    <link href="https://github.com/zdkswd/2019/01/25/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2019/01/25/鸟哥Linux Linux文件、目录与磁盘格式/</id>
    <published>2019-01-25T08:27:32.000Z</published>
    <updated>2019-01-25T08:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-Linux文件权限与目录配置"><a href="#第五章-Linux文件权限与目录配置" class="headerlink" title="第五章 Linux文件权限与目录配置"></a>第五章 Linux文件权限与目录配置</h1><p>Linux最优秀的地方之一就在于他的多用户多任务环境。而为了让各个使用者具有较保密的文件数据，因此文件的权限管理就变的很重要了。Linux一般将文件可存取的身份分为三个类别，分别是owner\/ group \/ others，且三种身份各有read \/ write \/execute等权限。</p><h2 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h2><h3 id="文件拥有者"><a href="#文件拥有者" class="headerlink" title="文件拥有者"></a>文件拥有者</h3><p>Linux是个多用户多任务的系统，因此可能常常会有多人同时使用这部主机来进行工作。考虑到每个人的隐私权与喜好的工作环境，文件拥有者就相当重要。可以设置适当的权限，让一些隐私的文件只有自己才能访问。</p><h3 id="群组概念"><a href="#群组概念" class="headerlink" title="群组概念"></a>群组概念</h3><p>经由简易的文件权限设置，就能限制非自己团队（亦即群组）的其他人不能够阅览内容，也可以让自己团队成员可以修改我所创建的文件。同时自己还有私人隐密文件，仍然可以设置让自己团队成员也看不到自己的文件数据。</p><h3 id="其他人的概念"><a href="#其他人的概念" class="headerlink" title="其他人的概念"></a>其他人的概念</h3><p>就是不属于群组的其他人喽。</p><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>想访问谁就访问谁。</p><h3 id="Linux使用者身份与群组记录的文件"><a href="#Linux使用者身份与群组记录的文件" class="headerlink" title="Linux使用者身份与群组记录的文件"></a>Linux使用者身份与群组记录的文件</h3><p>在我们Linux系统当中，默认的情况下，所有的系统上的帐号与一般身份使用者，还有那个root的相关信息，都是记录在\/ etc\/ passwd这个文件内的。至于个人的密码则是记录在\/ etc \/ shadow这个文件下。此外，Linux所有的群组名称都纪录在\/ etc \/ group内!这三个文件可以说是Linux系统里面帐号、密码、群组信息的集中地。</p><h2 id="Linux文件权限概念"><a href="#Linux文件权限概念" class="headerlink" title="Linux文件权限概念"></a>Linux文件权限概念</h2><h3 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h3><p>先登录系统，使用su - 切换身份成为root，下达ls -al。 ls是list的意思，重点在显示文件的文件名与相关属性。选项“-al”则表示列出所有的文件详细的权限与属性（包含隐藏文件，就是第一个字符为“.”的文件）。不建议直接使用root登录系统，建议使用su - 来切换身份，离开su - 则使用exit回到登录时的身份即可。运行结果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%889.26.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%889.27.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="档案类型"><a href="#档案类型" class="headerlink" title="档案类型"></a>档案类型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%889.28.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="i-node"><a href="#i-node" class="headerlink" title="i-node"></a>i-node</h4><p>每个文件都会将他的权限与属性记录到文件系统的i-node中，我们使用的目录树是使用文件名来记录，因此每个文件名就会链接到一个i-node，这个属性记录的，就是有多少不同的文件名连接到同一个i-node号码。</p><h4 id="容量大小"><a href="#容量大小" class="headerlink" title="容量大小"></a>容量大小</h4><p>默认单位为Bytes。</p><h3 id="如何改变文件属性与权限"><a href="#如何改变文件属性与权限" class="headerlink" title="如何改变文件属性与权限"></a>如何改变文件属性与权限</h3><h4 id="改变所属群组，chgrp"><a href="#改变所属群组，chgrp" class="headerlink" title="改变所属群组，chgrp"></a>改变所属群组，chgrp</h4><p>要被改变的群组名称必须要在\/ etc \/group文件中存在才行，否则就会显示错误。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.30.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="改变文件拥有者，chown"><a href="#改变文件拥有者，chown" class="headerlink" title="改变文件拥有者，chown"></a>改变文件拥有者，chown</h4><p>使用者必须是已经存在系统中的账号，也就是在\/ etc \/ passwd这个文件中有记录的使用者名称才能改变。chown还可以顺便直接修改群组的名称，如果要连目录下的所有次目录或文件同时更改文件拥有者的话，直接加上-R选项即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.29.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于复制行为（cp）会复制执行者的属性和权限，把自己的文件复制给使用者，那他仍然无法修改。所以就有必要将这个文件的拥有者与群组修改一下。</p><h4 id="改变权限，chmod"><a href="#改变权限，chmod" class="headerlink" title="改变权限，chmod"></a>改变权限，chmod</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.37.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>等我们设置权限变更时，该文件的权限数字就是770啦，变更权限的指令chmod的语法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.38.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.39.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也可以使用符号类型改变文件权限。<br>user（u）具有可读、可写、可执行的权限。<br>group与others（g/o）具有可读与执行的权限。<br>a代表上面三个身份<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.50.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.48.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.52.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.52.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="目录与文件之权限意义"><a href="#目录与文件之权限意义" class="headerlink" title="目录与文件之权限意义"></a>目录与文件之权限意义</h3><p>文件是实际含有数据的地方，包括一般文本文件、数据库内容档、二进制可执行文件(binary program)等等。因此，权限对于文件来说，他的意义是这样的:</p><ol><li>r(read):可读取此一文件的实际内容，如读取文本文件的文字内容。</li><li>w(write):可以编辑、新增或者是修改该文件的内容（但不含删除该文件);</li><li>x(eXecute):该文件具有可以被系统执行的权限。</li></ol><p>可执行x，在Windows下是借由扩展名来判断的，例如.exe,.bat,.com等等，但是在Linux下，我们的文件是否能被执行，则是由是否具有x这个权限来决定的，跟文件名没有绝对的关系。对一个文件具有w权限时，可以具有写入、编辑、新增、修改文件的内容的权限，但并不具备删除该文件本身的权限。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%881.38.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Linux文件种类与扩展名"><a href="#Linux文件种类与扩展名" class="headerlink" title="Linux文件种类与扩展名"></a>Linux文件种类与扩展名</h3><h4 id="正规文件（regular-file）"><a href="#正规文件（regular-file）" class="headerlink" title="正规文件（regular file）"></a>正规文件（regular file）</h4><p>第一个字符为【-】。又大略分为：</p><ol><li>纯文本文件（ASCII）</li><li>二进制档（binary）</li><li>数据格式文件（data）<h4 id="目录-directory"><a href="#目录-directory" class="headerlink" title="目录(directory)"></a>目录(directory)</h4>第一个属性为[d]。<h4 id="链接文件（link）"><a href="#链接文件（link）" class="headerlink" title="链接文件（link）"></a>链接文件（link）</h4>就是类似Windows系统下的捷径，第一个属性为[l]。<h4 id="设备与设备文件"><a href="#设备与设备文件" class="headerlink" title="设备与设备文件"></a>设备与设备文件</h4>与系统周边及存储相关的一些文件，通常都集中在/dev这个目录下。</li><li>区块（block）设备文件：就是一些储存数据，以提供系统随机存取的周边设备，比如硬盘,可查看/ dev / sda，会发现第一个属性为[b]。</li><li>字符(character)设备文件:即一些序列的周边设备，如键盘鼠标，特点是一次性读取不能够截断输出。如不可能让鼠标调到另一个画面，而是连续滑到另一个地方，第一个属性为[c]。</li><li>数据接口文件(sockets):这类文件通常被用在网络上的数据承接，我们可以启动一个程序来监听用户端的要求，而用户端就可以通过这个socket来进行数据的沟通了。第一个属性为【s】，最常在\/ run或\/ tmp这些目录中看到这种文件类型。</li><li>数据输送档(FIFO,pipe):FIFO也是一种特殊的文件类型，主要目的在解决多个程序同时存取一个文件所造成的错误问题。FIFO是first-in-first-out的缩写。第一个属性为[p]。</li></ol><p>Linux链接文件就可以简单的视为文件或目录的快捷方式。x只是代表这个文件具有可以执行的权限，并不一定能执行成功，还得看文件的内容。Linux系统的文件名只是了解该文件可能的用途而已，真正的执行与否仍需权限的规范才行。</p><p>Linux文件长度的限制。单一文件或目录最大容许文件名为255Bytes，以一个ASCII英文占用一个Bytes来说，则可达255个字符长度，若是以每个中文字2Bytes来说，最大文件名就是在128个中文字符。Linux文件是相当长的文件名，我们希望Linux文件名称可以一看就知道该文件在干嘛，所以文件名通常是很长很长。文件名最好可以避免一些特殊字符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%882.41.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h2><h3 id="Linux目录配置的依据—FHS"><a href="#Linux目录配置的依据—FHS" class="headerlink" title="Linux目录配置的依据—FHS"></a>Linux目录配置的依据—FHS</h3><p>Linux目录配置的标准Filesystem Hierachy Standard(FHS)。</p><p>根据FHS[2]的标准文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下，所以他们希望独立的软件开发商、操作系统制作者 、以及想要维护 系统的使用者，都能够遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%882.54.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上表右移。</p><p>FHS针对目录树架构仅定义了三层目录。</p><ol><li>\/ (root,根目录)：与开机系统有关。</li><li>\/ usr (unix software resource):与软件安装/ 执行有关。</li><li>/var(variable):与系统运行过程有关。<h4 id="根目录（-）的意义与内容"><a href="#根目录（-）的意义与内容" class="headerlink" title="根目录（/）的意义与内容"></a>根目录（/）的意义与内容</h4>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/ 还原 / 系统修复等动作有关。由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函数库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区内，因为越大的分区你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议:根目录所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但性能较佳，根目录所在的文件系统也较不容易发生问题。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.26.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.26.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="usr的意义与内容"><a href="#usr的意义与内容" class="headerlink" title="usr的意义与内容"></a>usr的意义与内容</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%882.58.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.41.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="var的意义与内容"><a href="#var的意义与内容" class="headerlink" title="var的意义与内容"></a>var的意义与内容</h4>如果_usr是安装时会占用较大硬盘容量的目录，那么_var就是在系统运行后才会渐渐占用硬盘容量的目录。因为Ivar目录主要针对常态性变动的文件，包括高速缓存 (cache)、登录文件(log file)以及某些软件运行所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.44.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.01.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.01.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Linux文件与目录管理"><a href="#Linux文件与目录管理" class="headerlink" title="Linux文件与目录管理"></a>Linux文件与目录管理</h1><h2 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h2><h3 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.20.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="cd（change-directory-变换目录）"><a href="#cd（change-directory-变换目录）" class="headerlink" title="cd（change directory,变换目录）"></a>cd（change directory,变换目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.22.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="pwd（显示目前所在的目录）"><a href="#pwd（显示目前所在的目录）" class="headerlink" title="pwd（显示目前所在的目录）"></a>pwd（显示目前所在的目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.33.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><strong>pwd是Print Working Directory的缩写，也就是显示目前所在目录的指令。</strong><h4 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir(创建新目录)"></a>mkdir(创建新目录)</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.36.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="rmdir（删除“空”的目录）"><a href="#rmdir（删除“空”的目录）" class="headerlink" title="rmdir（删除“空”的目录）"></a>rmdir（删除“空”的目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.48.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>如果想要删除旧有的目录时，就使用rmdir，例如将刚刚创建的test杀掉，使用“rmdir test”即可。<strong>目录需要一层一层的删除才行，而且被删除的目录里面必定不能存在其他的目录或文件!这也是所谓的空的目录(empty directory)的意思</strong>。如果要将所有目录下的东西都杀掉，这个时候就必须使用“rm -r test”。不过，还是使用rmdir比较不危险，你也可以尝试以-p的选项加入，来删除上层的目录。<h3 id="关于可执行文件路径的变量：-PATH"><a href="#关于可执行文件路径的变量：-PATH" class="headerlink" title="关于可执行文件路径的变量：$PATH"></a>关于可执行文件路径的变量：$PATH</h3>当我们在执行一个指令的时候，如”Is”，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为Is的可可执行文件，如果在PATH定义的目 录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行。</li></ol><p>echo有显示、印出的意思，而PATH前面的$表示后面接的是变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.58.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>PATH(一定是大写)这个变量的内容是由一堆目录所组成的，每个目录中由冒号来隔开，每个目录是有顺序之分的。</p><ol><li>不同身份使用者默认的PATH不同，默认能够随意执行的指令也不同（如root与dmtsai）；</li><li>PATH是可以修改的；</li><li>使用绝对路径或是相对路径直接指定某个指令的文件名来执行会比搜寻PATH来的正确；</li><li>指令应该放置到正确的目录下执行才会比较方便；</li><li>本目录（.）最好不要放到PATH中。</li></ol><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="文件与目录的检视-ls"><a href="#文件与目录的检视-ls" class="headerlink" title="文件与目录的检视 ls"></a>文件与目录的检视 ls</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%888.34.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%888.54.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="复制，删除与移动：cp-rm-mv"><a href="#复制，删除与移动：cp-rm-mv" class="headerlink" title="复制，删除与移动：cp,rm,mv"></a>复制，删除与移动：cp,rm,mv</h3><h4 id="cp（复制文件或目录）"><a href="#cp（复制文件或目录）" class="headerlink" title="cp（复制文件或目录）"></a>cp（复制文件或目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%888.58.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>复制（cp）这个指令是非常重要的，不同身份者执行这个指令会有不同的结果产生，尤其是-a-p选项对于不同身份差别非常大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.05.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在默认中，cp的来源文件与目的文件的权限是不同的，目的文件的拥有者通常会是指令操作者本身。由于这个特性，我们在进行备份时，某些需要特别注意的特殊权限文件，例如密码档以及配置文件就不能直接以cp复制，而必须加-a<br>或者是-p等等可以完整复制文件权限的选项才行。如果想要复制文件给其他的使用者，也必须要注意到文件的权限（包含读写执行以及文件拥有者等等）否则其他人还是无法针对你给予的文件进行修订动作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.22.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>-l -s都会创建所谓的链接文件（link file）,但是这两种链接文件却有不一样的情况， -s是符号链接， -l是实体链接。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.28.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在复制时，需要清楚的了解到</p><ol><li>是否完整的保留来源文件信息</li><li>来源文件是否为链接文件</li><li>来源文件是否为特殊文件，例如FIFO，socket</li><li>来源文件是否为目录</li></ol><h4 id="rm（移除文件或目录）"><a href="#rm（移除文件或目录）" class="headerlink" title="rm（移除文件或目录）"></a>rm（移除文件或目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.41.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是移除的指令(remove) ， 要注意的是，通常在Linux系统下，为了怕文件被root误杀，所以很多distributions都已经默认加入i这个选项了!而如果要连目录下的东西都一起杀掉的话，例如子目录里面还有子目录时，那就要使用一这个选项了!不过，使用”rm-r”这个指令之前，请千万注意了，因为该目录或文件“肯定”会被root杀掉!因为系统不会再次询问你是否要砍掉呦!所以那是个超级严重的指令下达呦!得特别注意!不过，如果你确定该目录不要了，那么使用rm-r来循环杀掉是不错的方式!</p><h4 id="mv（移动文件与目录，或更名）"><a href="#mv（移动文件与目录，或更名）" class="headerlink" title="mv（移动文件与目录，或更名）"></a>mv（移动文件与目录，或更名）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.47.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是搬运（move）的意思，当要移动文件或目录时这个指令就很重要了，还有一个用途就是更改文件名，这是Linux才有的指令，还有个rename指令可以用来更改大量文件的文件名。</p><h3 id="取得路径的文件名称与目录名称"><a href="#取得路径的文件名称与目录名称" class="headerlink" title="取得路径的文件名称与目录名称"></a>取得路径的文件名称与目录名称</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.01.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>basename与dirname的用途。</p><h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><ol><li>cat由第一行开始显示文件内容</li><li>tac从最后一行开始显示，可以看出tac是cat的倒着写</li><li>nl显示的时候，顺便输出行号</li><li>more一页一页的显示文件内容</li><li>less与more类似，但是比more更好的是可以往前翻页</li><li>head只看头几行</li><li>tail只看尾巴几行</li><li>od以二进制的方式读取文件内容</li></ol><h3 id="直接检视文件内容"><a href="#直接检视文件内容" class="headerlink" title="直接检视文件内容"></a>直接检视文件内容</h3><h4 id="cat（concatenate）"><a href="#cat（concatenate）" class="headerlink" title="cat（concatenate）"></a>cat（concatenate）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.09.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="数据选择"><a href="#数据选择" class="headerlink" title="数据选择"></a>数据选择</h3><h4 id="head（取出前面几行）"><a href="#head（取出前面几行）" class="headerlink" title="head（取出前面几行）"></a>head（取出前面几行）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.23.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="tail（取出后面几行）"><a href="#tail（取出后面几行）" class="headerlink" title="tail（取出后面几行）"></a>tail（取出后面几行）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.25.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="非纯文本文件od"><a href="#非纯文本文件od" class="headerlink" title="非纯文本文件od"></a>非纯文本文件od</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.28.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="修改文件时间或创建新文件：touch"><a href="#修改文件时间或创建新文件：touch" class="headerlink" title="修改文件时间或创建新文件：touch"></a>修改文件时间或创建新文件：touch</h3><ol><li>modification time(mtime):当该文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限。</li><li>status time（ctime）：当该文件的状态改变时就会更新这个时间，比如权限与属性被改变了，就会更新这个时间。</li><li>access time（atime）：当该文件的内容被取用时就会更新这个读取时间。如使用cat去读取，就会更新该文件的atime。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.50.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><h3 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：umask</h3><p>umask就是指定目前使用者在创建文件或目录时候的权限默认值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8811.53.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h3><h4 id="chattr（设置文件隐藏属性）"><a href="#chattr（设置文件隐藏属性）" class="headerlink" title="chattr（设置文件隐藏属性）"></a>chattr（设置文件隐藏属性）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8811.59.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这些指令是很重要的，尤其是在系统数据安全上面。</p><h4 id="lsattr（显示文件隐藏属性）"><a href="#lsattr（显示文件隐藏属性）" class="headerlink" title="lsattr（显示文件隐藏属性）"></a>lsattr（显示文件隐藏属性）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8812.00.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用chattr设置后，可以使用lsattr来查阅隐藏的属性。</p><h3 id="文件特殊权限：SUID，SGID，SBIT"><a href="#文件特殊权限：SUID，SGID，SBIT" class="headerlink" title="文件特殊权限：SUID，SGID，SBIT"></a>文件特殊权限：SUID，SGID，SBIT</h3><h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><p>当s这个标志出现在文件拥有者的x权限上时，如- rwsr - xr - x就称为Set UID，简称为SUID。SUID的限制与功能：</p><ol><li>SUID权限仅对二进制程序有效</li><li>执行者对于该程序需要有x的可执行权限</li><li>本权限仅在执行该程序的过程中有效</li><li>执行者将具有该程序拥有者的权限。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8810.35.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>SUID仅可以用在binary program上，不能用在shell script上，这是因为shell script知识将很多binary可执行文件加进来执行而已。所以SUID的权限部分，还是得看shell script调用进来的程序设置，SUID对于目录也是无效的。</p><h4 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h4><p>与SUID不同的是，SGID可以针对文件或目录来设置。对于文件，SGID有如下的功能：</p><ol><li>SGID对二进制程序有用</li><li>程序执行着对于该程序来说，需具备x的权限</li><li>执行者在执行的过程中将会获得该程序群组的支持!</li></ol><h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><p>SBIT目前只针对目录有效，对于文件已经没有效果了。SBIT对于目录的作用是：</p><ol><li>当使用者对于此目录具有w,x权限，亦即具有写入的权限时。</li><li>当使用者在该目录下创建文件或目录时，仅有自己与root才有权力删除该文件。</li></ol><h3 id="观察文件类型：file"><a href="#观察文件类型：file" class="headerlink" title="观察文件类型：file"></a>观察文件类型：file</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8810.46.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h2><h3 id="指令文件名的搜寻"><a href="#指令文件名的搜寻" class="headerlink" title="指令文件名的搜寻"></a>指令文件名的搜寻</h3><h4 id="which（寻找可执行文件）"><a href="#which（寻找可执行文件）" class="headerlink" title="which（寻找可执行文件）"></a>which（寻找可执行文件）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8810.53.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个指令是根据”PAT}这个环境变量所规范的路径’去搜寻“可执行文件”的文件名。</p><h3 id="文件文件名的搜寻"><a href="#文件文件名的搜寻" class="headerlink" title="文件文件名的搜寻"></a>文件文件名的搜寻</h3><h4 id="whereis（由一些特定的目录中寻找文件文件名）"><a href="#whereis（由一些特定的目录中寻找文件文件名）" class="headerlink" title="whereis（由一些特定的目录中寻找文件文件名）"></a>whereis（由一些特定的目录中寻找文件文件名）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.15.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>find是很强大的搜寻指令，但时间花费很大，因为find是直接搜寻硬盘。whereis只招几个特定的目录，并没有全系统去查询。whereis主要针对的是/ bin / sbin下面的可执行文件，以及/ usr / share / man下面的man page文件跟几个比较特定的目录来处理。</p><h4 id="locate、updatedb"><a href="#locate、updatedb" class="headerlink" title="locate、updatedb"></a>locate、updatedb</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.19.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用locate 来寻找数据的时候特别的快，这是因为locate寻找的数据是由“已创建的数据库/ var / lib / mlocate /  “里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据，当然是很快速的。但是有限制条件，他是由数据库来搜寻的，而数据库每天执行一次，若在数据库更新之前搜寻文件则搜寻不到。</p><h4 id="updatedb"><a href="#updatedb" class="headerlink" title="updatedb"></a>updatedb</h4><p>根据 / etc / updatedb.conf的设置去搜寻系统硬盘内的文件名，并更新/ rar / lib / mlocate内的数据库文件。</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>依据 / var / lib / mlocate内的数据库记载,找出使用者输入的关键字文件名。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.31.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.33.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.35.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Linux磁盘与文件系统管理"><a href="#Linux磁盘与文件系统管理" class="headerlink" title="Linux磁盘与文件系统管理"></a>Linux磁盘与文件系统管理</h1><h2 id="认识Linux文件系统"><a href="#认识Linux文件系统" class="headerlink" title="认识Linux文件系统"></a>认识Linux文件系统</h2><h3 id="磁盘组成与分区"><a href="#磁盘组成与分区" class="headerlink" title="磁盘组成与分区"></a>磁盘组成与分区</h3><h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><p>每种操作系统能够使用的文件系统并不相同。举例来说，windows 98以前的微软操作系统主要利用的文件系统是FAT (或FAT16) ， windows 2000以后的版本有所谓的NTFS文件系统，至于Linux的正统文件系统则为Ext2 (Linux second extended file system, ext2fs)这一个。此外，在默认的情况下,windows 操作系统是不会认识Linux的Ext2的。</p><p>文件系统是如何运行与操作系统的文件数据有关。较新的操作系统的文件数据<br>除了文件实际内容外，通常含有非常多的属性，例如Linux操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到inode中，至于实际数据则放置到data block区块中。另外，还有一个超级区块 (superblock)会记录整个文件系统的整体信息 ，包括inode与block的总量、使用量、剩余量等。</p><p>每个inode与block都有编号，至于这三个数据的意义可以简略说明如下:</p><ol><li>superblock :记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等;</li><li>inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码;</li><li>block :实际记录文件的内容，若文件太大时，会占用多个block。</li></ol><p>由于每个 inode与 block都有编号而每个文件都会占用一个 inode, inode内有文件数据置的 block号码。因此我们可以知道的是,如果能够找到文件的 inode的话那么自然会知道这个文件所放置数据的 block号码,当然也就能够读出该文件的实际数据了。这是个比较有效率的作法，因此我们的磁盘就能够在短时间内读取出全部的数据,读写的性能比较好。文件系统先格式化出inode与block的区块。inode中记录了4个区块的位置，此乃索引式文件系统。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8811.40.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还有一种文件系统比如FAT格式，就是我们惯用的U盘，这种格式是没有inode存在的所以是顺序读取的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8811.42.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Linux的EXT2文件系统（inode）"><a href="#Linux的EXT2文件系统（inode）" class="headerlink" title="Linux的EXT2文件系统（inode）"></a>Linux的EXT2文件系统（inode）</h3><p>inode的内容在记录文件的权展与相关属性,至于bock区块则是在记录文件的实际内容。而且文件系统一开始就将 inode与 block规划好了,除非重新格式化<br>(或者利用 resize2is等指令变更文件系统大小),否则 inode与 block固定后就不再变动但是如果仔细考虑一下,如果我的文件系统高达数百GB时,那么将所有的 inode与 block通通放置在一起将是很不智的决定,因为 inode与 block的数量太庞大,不容易管理。</p><p>为此Ext2文件系统在格式化的时候基本上是区分为多个区块群组，每个区块群组都有独立的inode，block，superblock系统。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8811.56.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在整体的规划当中，文件系统最前面有一个开机扇区 ( boot sector)，这个开机扇区可以安装开机管理程序，这是个非常重要的设计，因为如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗磁盘唯一的MBR，这样也才能够制作出多重开机的环境啊。</p><h4 id="data-block-数据区块"><a href="#data-block-数据区块" class="headerlink" title="data block(数据区块)"></a>data block(数据区块)</h4><p>由于block大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大但以文件大小并不相同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8B%E5%8D%8812.00.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>block基本限制如下：</p><ol><li>原则上，block的大小与数量在格式化完就不能再改变了（除非重新格式化）</li><li>每个block内最多只能够放置一个文件的数据;</li><li>承上，如果文件大于block的大小，则一个文件会占用多个block数量;</li><li>承上，若文件小于block ，则该block的剩余容量就不能够再被使用了(磁盘空间会浪费)</li></ol><p>block大小选择所造成的不同问题。选在大的block在存取大量小文件时可能造成浪费。选小的block在存取大文件时索引的数量更多，可能导致文件系统不良的读写性能。事实上，现在的磁盘容量都太大了，所以大家都只会选在4K的block大小。</p><h4 id="inode-table（inode表格）"><a href="#inode-table（inode表格）" class="headerlink" title="inode table（inode表格）"></a>inode table（inode表格）</h4><p>inode记录的文件数据至少有下面这些：</p><ol><li>该文件的存取模式(read / write / excute)</li><li>该文件的拥有者与群组(owner / group)</li><li>该文件的容量。</li><li>该文件创建或状态改变的时间( ctime)</li><li>最近一次的读取时间( atime)</li><li>最近修改的时间( mtime)</li><li>定义文件特性的旗标(fag),如 SetUID</li><li>该文件真正内容的指向（pointer）</li></ol><p>inode的数量与大小也是在格式化时就已经固定了。</p><ol><li>每个 inode大小均固定为128 Bytes(新的ext4与xfs可设置到256 Bytes）；</li><li>每个文件都仅会占用一个 inode而已;</li><li>承上,因此文件系统能够创建的文件数量与 inode的数量有关;</li><li>系统读取文件时需要先找到 inode,并分析 inode所记录的权限与使用者是否符合,若符合才能够开始实际读取 block的内容。</li></ol><p>inode要记录的数据非常多，偏偏又只有128Bytes，而inode记录一个block要花掉4Byte，所以有一个巧妙的办法。将inode记录block号码的区域定义为12个直接1个间接一个双间接一个三间接记录区。直接就是直接可以通过号码来取得block，间接就是再拿一个block来当作记录block号码的记录区，如果文件太大，就会使用间接的block来记录号码。</p><h4 id="superblock（超级区块）"><a href="#superblock（超级区块）" class="headerlink" title="superblock（超级区块）"></a>superblock（超级区块）</h4><p>superblock是记录整个filesystem相关信息的地方，没有superblock就没有filesystem了。记录的信息有：</p><ol><li>block与inode的总量</li><li>未使用与已使用的inode，block数量</li><li>block与inode的大小</li><li>filesystem的挂载时间，最近一次写入数据的时间，最近一次检验磁盘的时间等文件系统的相关信息。</li><li>一个valid bit数值，若此文件系统已被挂载，则valid bit为0，若未被挂载，则valid bit为1。</li></ol><p>superblock是非常重要的，因为文件系统的基本信息都在，如果superblock死掉了，文件系统要花费很多时间去挽救。一般来说，superblock的大小为1024Bytes，一个文件系统应该仅有一个superblock，除了第一个block group内会含有superblock后续的block group不一定含有superblock。若含有superblock也是为第一个block group内的superblock做备份。</p><h4 id="Filesystem-Description-文件系统描述说明"><a href="#Filesystem-Description-文件系统描述说明" class="headerlink" title="Filesystem Description(文件系统描述说明)"></a>Filesystem Description(文件系统描述说明)</h4><p>这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段(superblock, bitmap, inodemap, data block) 分别介于哪一个block号码之间。</p><h4 id="block-bitmap（区块对照表）"><a href="#block-bitmap（区块对照表）" class="headerlink" title="block bitmap（区块对照表）"></a>block bitmap（区块对照表）</h4><p>记录使用与未使用block的号码。</p><h4 id="inode-bitmap（inode对照表）"><a href="#inode-bitmap（inode对照表）" class="headerlink" title="inode bitmap（inode对照表）"></a>inode bitmap（inode对照表）</h4><p>inode bitmap则是记录使用与未使用的inode号码。</p><h4 id="dumpe2fs"><a href="#dumpe2fs" class="headerlink" title="dumpe2fs"></a>dumpe2fs</h4><h3 id="与目录树的关系"><a href="#与目录树的关系" class="headerlink" title="与目录树的关系"></a>与目录树的关系</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>在Linux下的文件系统创建一个目录，文件系统会分配一个inode与至少一块block给该目录。其中inode与至少一块block给该目录。其中inode记录该目录的相关权限与属性，并可记录分配到的那块block号码。而block则是记录在这个目录下的文件名与该文件名占用的inode号码数据。也就是说目录所占用的block内容在记录如下的信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8B%E5%8D%886.32.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在目录下面的文件数如果太多而导致一个block无法容纳的下所有的文件名与inode对照表，Linux会给予该目录多一个block来继续记录相关的数据。</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h4 id="目录树读取"><a href="#目录树读取" class="headerlink" title="目录树读取"></a>目录树读取</h4><p>inode本身并不记录文件名，文件名的记录是在目录的block当中。当我们要读取某个文件时，就务必会经过目录的inode与block然后才能找到那个待读取文件的inode号码，最终才会督导正确的文件的block内的数据。</p><p>由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的inode号码，挂载点实际上就是linux中的磁盘文件系统的入口目录。此时就能够得到根目录的inode内容，并依据该inode读取根目录的block内的文件名数据，再一层一层的往下读到正确的文件名。比如读取/ etc / passwd这个文件时的过程。</p><ol><li>/ 的inode :通过挂载点的信息找到inode号码为128的根目录inode，且inode规范的权限让我们可以读取该block的内容(有r与x)。</li><li>/ 的block: 经过上个步骤取得block的号码，并找到该内容有etc/ 目录的inode号码( 33595521)。</li><li>etc/ 的inode :读取33595521号inode得知dmtsai具有r与x的权限，因此可以读取etc/ 的block内容;</li><li>etc/ 的block :经过上个步骤取得block号码，并找到该内容有passwd文件的inode号码 ( 36628004)</li><li>passwd的inode : 读取36628004号inode得知dmtsai具有r的权限，因此可以读取passwd的block内容;</li><li>passwd的block :最后将该block内容的数据读出来。</li></ol><h3 id="EXT2-EXT3-EXT4文件的存取与日志式文件系统的功能"><a href="#EXT2-EXT3-EXT4文件的存取与日志式文件系统的功能" class="headerlink" title="EXT2/ EXT3/ EXT4文件的存取与日志式文件系统的功能"></a>EXT2/ EXT3/ EXT4文件的存取与日志式文件系统的功能</h3><p>若是想要新增一个文件，文件系统的行为是。</p><ol><li>先确定使用者对于欲新增文件的目录是否具有w与x的权限，若有的话才能新增;</li><li>根据inode bitmap找到没有使用的inode号码，并将新文件的权限/ 属性写入。</li><li>根据block bitmap找到没有使用中的block号码，并将实际的数据写入block中，且更新inode的block指向数据;</li><li>将刚刚写入的inode与block数据同步更新inode bitmap与block bitmap，并更新superblock的内容。</li></ol><p>一般来说，我们将inode table与data block称为数据存放区域，至于其他例如superblock、block bitmap与inode bitmap等区段就被称为metadata (中介数据)，因为superblock,inode bitmap及block bitmap的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据，因此才被称为中介数据的啦。</p><h4 id="数据的不一致（inconsistent）状态"><a href="#数据的不一致（inconsistent）状态" class="headerlink" title="数据的不一致（inconsistent）状态"></a>数据的不一致（inconsistent）状态</h4><p>由于不知名的原因可能导致metadata的内容与实际数据存放区产生不一致（inconsistent）的情况。传统的解决方法会在开机时皆有superblock当中记录的valid bit与filesystem state等状态来判断是否强制进行数据一致性的检查。这样的检查是很费时的。非常麻烦，造成了后来日志式文件系统的兴起。</p><h4 id="日志式文件系统（Journaling-filesystem）"><a href="#日志式文件系统（Journaling-filesystem）" class="headerlink" title="日志式文件系统（Journaling filesystem）"></a>日志式文件系统（Journaling filesystem）</h4><p>为了避免文件系统不一致的发生，在filesystem中规划一个区块，该区块专门记录写入或修订文件的步骤，就可以简化一致性检查的步骤。</p><ol><li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息;</li><li>实际写入：开始写入文件的权限与数据，开始更新metadata的数据。</li><li>结束：完成数据与metadata的更新后，在日志记录块当中完成该文件的记录。</li></ol><p>万一数据的纪录过程当中发生了问题，那么我们的系统只要去检查日志记录区块，就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块filesystem去检查，这样就可以达到快速修复filesystem的能力。</p><h3 id="Linux文件系统的运行"><a href="#Linux文件系统的运行" class="headerlink" title="Linux文件系统的运行"></a>Linux文件系统的运行</h3><p>编辑一个好大的文件，在编辑的过程中又频繁的要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多， 因此你会常常耗在等待磁盘的写入/读取上，很没效率。为解决效率问题，Linux使用的方式是通过一个非同步处理（asynchronously）的方式。</p><p>当系统载入一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被设置为干净(clean) 的。但如果内存中的文件数据被更改过了(例如你用nano去编辑过这个文件)，此时该内存中的数据会被设置为脏的 (Dirty) 。此时所有的动作都还在内存中执行，并没有写入到磁盘中!系统会不定时的将内存中设置为”Dirty”的数据写回磁盘，以保持磁盘与内存数据的一致性。</p><p>内存的速度要比磁盘快的多,因此如果能够将常用的文件放置到内存当中，就会增加系统性能。因此我们Linux系统上面文件系统与内存有非常大的关系。</p><ol><li>系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读/ 写;</li><li>承上，因此Linux的实体内存最后都会被用光!这是正常的情况!可加速系统性能;</li><li>可以手动使用sync来强迫内存中设置为Dirty的文件回写到磁盘中;</li><li>若正常关机时，关机指令会主动调用sync来将内存的数据回写入磁盘内;</li><li>但若不正常关机(如跳电、死机或其他不明原因)，由于数据尚未回写到磁盘内, 因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁(非磁盘损毁)。</li></ol><h3 id="挂载点的意义（mount-point）"><a href="#挂载点的意义（mount-point）" class="headerlink" title="挂载点的意义（mount point）"></a>挂载点的意义（mount point）</h3><p>将文件系统与目录树结合的动作我们称为<strong>挂载</strong>。重点是挂载点一定是目录，该目录为进入该文件系统的入口，因此并不是有任何文件系统都能使用的，必须挂载到目录树的某个目录后，才能够使用该文件系统。</p><h3 id="其他Linux支持的文件系统与VFS"><a href="#其他Linux支持的文件系统与VFS" class="headerlink" title="其他Linux支持的文件系统与VFS"></a>其他Linux支持的文件系统与VFS</h3><p>Linux的标准文件系统是ext2，且还有增加了日志功能的ext3/ext4，事实上，Linux还有支持很多文件系统格式的，尤其是最近这几年推出了好几种速度很快的日志式文件系统，包括SGI的XFS文件系统， 可以适用更小型文件的Reiserfs 文件系统，以及Windows的FAT文件系统等等，都能够被Linux所支持。</p><h4 id="Linux-VFS（Virtual-Filesystem-Switch）"><a href="#Linux-VFS（Virtual-Filesystem-Switch）" class="headerlink" title="Linux VFS（Virtual Filesystem Switch）"></a>Linux VFS（Virtual Filesystem Switch）</h4><p>Linux的系统都是通过一个名为Virtual Filesystem Switch 的核心功能去读取filesystem的。也就是说， 整个Linux 认识的filesystem 其实都是VFS在进行<br>管理，我们使用者并不需要知道每个partition上头的filesystem是什么。VFS会主动的帮我们做好读取的动作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8A%E5%8D%889.46.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="XFS文件系统简介"><a href="#XFS文件系统简介" class="headerlink" title="XFS文件系统简介"></a>XFS文件系统简介</h3><p>EXT家族当前较伤脑筋的地方：支持度最广，但格式化超慢。基本上xfs就是一个日志式文件系统。xfs文件系统在数据的分布上主要规划为三个部分，一个是数据区，一个文件系统活动登录区，以及一个实时运行区。</p><h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><h3 id="磁盘与目录的容量"><a href="#磁盘与目录的容量" class="headerlink" title="磁盘与目录的容量"></a>磁盘与目录的容量</h3><h4 id="df-列出文件系统的整体磁盘使用量"><a href="#df-列出文件系统的整体磁盘使用量" class="headerlink" title="df:列出文件系统的整体磁盘使用量"></a>df:列出文件系统的整体磁盘使用量</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8A%E5%8D%8810.30.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>Filesystem：代表该文件系统是在哪个partition，所以列出设备名称。</li><li>1k-blocks :说明下面的数字单位是1KB，可利用-h或-m来改变容量。</li><li>Used:顾名思义，就是使用掉的磁盘空间。</li><li>Available :也就是剩下的磁盘空间大小。</li><li>Use% :就是磁盘的使用率。</li><li>Mounted on：就是磁盘挂载的目录所在（挂载点）。</li></ol><p>由于df主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在Superblock内的信息，所以这个指令显示结果的速度非常的快速。</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%881.45.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>与df不一样的是，du这个指令其实会到文件系统去搜寻所有的文件数据，所以上述指令运行会执行一小段时间。</p><h3 id="实体链接与符号链接：ln"><a href="#实体链接与符号链接：ln" class="headerlink" title="实体链接与符号链接：ln"></a>实体链接与符号链接：ln</h3><h4 id="Hard-Link（实体链接，硬式链接或实际链接）"><a href="#Hard-Link（实体链接，硬式链接或实际链接）" class="headerlink" title="Hard Link（实体链接，硬式链接或实际链接）"></a>Hard Link（实体链接，硬式链接或实际链接）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.02.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>hard link只是在某个目录下新增一笔文件名链接到某inode号码的关联记录而已。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%881.55.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>hard link的限制：</p><ol><li>不能跨Filesystem。</li><li>不能link目录。链接到目录时，链接的数据需要连同被链接目录下面的所有数据都创建链接。</li></ol><h4 id="Sysbolic-Link（符号链接，亦是捷径）"><a href="#Sysbolic-Link（符号链接，亦是捷径）" class="headerlink" title="Sysbolic Link（符号链接，亦是捷径）"></a>Sysbolic Link（符号链接，亦是捷径）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.03.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Sysbolic link就是在创建一个独立的文件，而这个文件会让数据的读取指向他link的那个文件的文件名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.04.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>hard link比较安全。但hard link的限制太多了，包括无法做目录的link，用途上还是比较受限的，反而是Symbolic Link的使用较广。</p><p>删除动作，如删除/ etc / crontab文件，删除动作只是将 / etc目录下关于crontab的关连数据拿掉而已，crontab所在的inode与block其实都没有被变动。</p><h2 id="磁盘的分区，格式化，检验与挂载"><a href="#磁盘的分区，格式化，检验与挂载" class="headerlink" title="磁盘的分区，格式化，检验与挂载"></a>磁盘的分区，格式化，检验与挂载</h2><p>若是想在系统中新增一个磁盘，需要：</p><ol><li>对磁盘进行分区，以创建可用的partition。</li><li>对该partition进行格式化 (format)， 以创建系统可用的filesystem</li><li>若想要仔细一点，则可对刚刚创建好的filesystem进行检验。</li><li>在Linux系统上，需要创建挂载点 (亦即是目录) ，并将他挂载上来。</li></ol><h3 id="观察磁盘分区状态"><a href="#观察磁盘分区状态" class="headerlink" title="观察磁盘分区状态"></a>观察磁盘分区状态</h3><h4 id="lsblk列出系统上所有磁盘列表"><a href="#lsblk列出系统上所有磁盘列表" class="headerlink" title="lsblk列出系统上所有磁盘列表"></a>lsblk列出系统上所有磁盘列表</h4><p>Isblk可以看成” list block device”的缩写， 就是列出所有储存设备的意思。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.23.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="blikid列出设备的UUID等参数"><a href="#blikid列出设备的UUID等参数" class="headerlink" title="blikid列出设备的UUID等参数"></a>blikid列出设备的UUID等参数</h4><p>UUID是全域单一识别码（universally unique identifier），Linux会将系统内所有设备都给予一个独一无二的识别码。这个识别码就可以拿来作为挂载或是使用这个设备、文件系统之用了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.24.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="parted列出磁盘的分区表类型与分区信息"><a href="#parted列出磁盘的分区表类型与分区信息" class="headerlink" title="parted列出磁盘的分区表类型与分区信息"></a>parted列出磁盘的分区表类型与分区信息</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.28.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="磁盘分区：gdisk-fdisk"><a href="#磁盘分区：gdisk-fdisk" class="headerlink" title="磁盘分区：gdisk/ fdisk"></a>磁盘分区：gdisk/ fdisk</h3><h4 id="用gdisk新增分区"><a href="#用gdisk新增分区" class="headerlink" title="用gdisk新增分区"></a>用gdisk新增分区</h4><h4 id="partprobe更新Linux核心的分区表信息"><a href="#partprobe更新Linux核心的分区表信息" class="headerlink" title="partprobe更新Linux核心的分区表信息"></a>partprobe更新Linux核心的分区表信息</h4><h4 id="用gdisk删除一个分区"><a href="#用gdisk删除一个分区" class="headerlink" title="用gdisk删除一个分区"></a>用gdisk删除一个分区</h4><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><h3 id="文件系统挂载与卸载"><a href="#文件系统挂载与卸载" class="headerlink" title="文件系统挂载与卸载"></a>文件系统挂载与卸载</h3><h3 id="磁盘、文件系统参数修订"><a href="#磁盘、文件系统参数修订" class="headerlink" title="磁盘、文件系统参数修订"></a>磁盘、文件系统参数修订</h3><h4 id="mknod"><a href="#mknod" class="headerlink" title="mknod"></a>mknod</h4><h4 id="xfs-admin修改XFS文件系统的UUID与Label-name"><a href="#xfs-admin修改XFS文件系统的UUID与Label-name" class="headerlink" title="xfs-admin修改XFS文件系统的UUID与Label name"></a>xfs-admin修改XFS文件系统的UUID与Label name</h4><h2 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h2><h3 id="开机挂载-etc-fstab及-etc-mtab"><a href="#开机挂载-etc-fstab及-etc-mtab" class="headerlink" title="开机挂载/etc/fstab及/etc/mtab"></a>开机挂载/etc/fstab及/etc/mtab</h3><h3 id="特殊设备loop挂载"><a href="#特殊设备loop挂载" class="headerlink" title="特殊设备loop挂载"></a>特殊设备loop挂载</h3><h2 id="内存交换空间（swap）之创建"><a href="#内存交换空间（swap）之创建" class="headerlink" title="内存交换空间（swap）之创建"></a>内存交换空间（swap）之创建</h2><p>如果硬件的配备资源足够的话’那么swap应该不会被我们的系统所使用到swaρ会被利用到的时刻通常就是实体内存不足的情况。目前在个人使用上内存已经足够大，不用设置swap也不会有太大的问题，但是服务器就不一定了，由于不知道何时会有大量来自网络的请求，因此最好还是能够预留一些swap来缓冲一下系统的内存用量。有备无患。</p><h3 id="使用实体分区创建swap"><a href="#使用实体分区创建swap" class="headerlink" title="使用实体分区创建swap"></a>使用实体分区创建swap</h3><ol><li>分区:先使用gdik在你的磁盘中分区出一个分区给系统作为swap。由于Linux的gdisk默认会将分区的ID设置为 Linux的文件系统，所以你可能还得要设置一下system ID就是了。</li><li>格式化∶利用创建swap格式的” mkswap设备文件名”就能够格式化该分区成为swap格式。</li><li>使用:最后将该swap设备启动,方法为:” swapon设备文件名”。</li><li>观察:最终通过free与 swapon-s这个指令来观察一下内存的用量。</li></ol><h3 id="使用文件创建swap"><a href="#使用文件创建swap" class="headerlink" title="使用文件创建swap"></a>使用文件创建swap</h3><h1 id="文件与文件系统的压缩，打包与备份"><a href="#文件与文件系统的压缩，打包与备份" class="headerlink" title="文件与文件系统的压缩，打包与备份"></a>文件与文件系统的压缩，打包与备份</h1><h2 id="压缩文件的用途与技术"><a href="#压缩文件的用途与技术" class="headerlink" title="压缩文件的用途与技术"></a>压缩文件的用途与技术</h2><h2 id="Linux系统常见的压缩指令"><a href="#Linux系统常见的压缩指令" class="headerlink" title="Linux系统常见的压缩指令"></a>Linux系统常见的压缩指令</h2><p>虽然Linux文件的属性基本上是与文件名没有绝对关系的，为了帮助人类，适当的扩展名还是必要的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%883.51.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%884.20.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="bzip2，bzcat-bzmore-bzless-bzgrep"><a href="#bzip2，bzcat-bzmore-bzless-bzgrep" class="headerlink" title="bzip2，bzcat,bzmore,bzless,bzgrep"></a>bzip2，bzcat,bzmore,bzless,bzgrep</h3><p>gzip是为了取代 compress并提供更好的压缩比而成立的,那么bzip2则是为了取代gzip并提供更佳的压缩比而来的。</p><h3 id="xz-xzcat-xzmore-xzless-xzgrep"><a href="#xz-xzcat-xzmore-xzless-xzgrep" class="headerlink" title="xz,xzcat,xzmore,xzless,xzgrep"></a>xz,xzcat,xzmore,xzless,xzgrep</h3><p>xz的压缩比好很多，但是xz最大的问题就是时间花太久了。运算时间要比gzip久很多。</p><h2 id="打包指令：tar"><a href="#打包指令：tar" class="headerlink" title="打包指令：tar"></a>打包指令：tar</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%884.24.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章-Linux文件权限与目录配置&quot;&gt;&lt;a href=&quot;#第五章-Linux文件权限与目录配置&quot; class=&quot;headerlink&quot; title=&quot;第五章 Linux文件权限与目录配置&quot;&gt;&lt;/a&gt;第五章 Linux文件权限与目录配置&lt;/h1&gt;&lt;p&gt;Linux最
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥Linux基础   Linux的规划与安装</title>
    <link href="https://github.com/zdkswd/2019/01/20/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://github.com/zdkswd/2019/01/20/鸟哥Linux基础   Linux的规划与安装/</id>
    <published>2019-01-20T12:25:32.000Z</published>
    <updated>2019-01-21T10:55:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第零章、计算机概论"><a href="#第零章、计算机概论" class="headerlink" title="第零章、计算机概论"></a>第零章、计算机概论</h1><p>CPU实际要处理的数据完全来自于内存（不管是程序还是一般文件数据）。<br>CPU架构<br>精简指令集RISC，如ARM架构。目前世界上使用范围最广的CPU就是ARM架构。<br>复杂指令集CISC。AMD，Intel x86。</p><h1 id="第一章、Linux是什么与如何学习"><a href="#第一章、Linux是什么与如何学习" class="headerlink" title="第一章、Linux是什么与如何学习"></a>第一章、Linux是什么与如何学习</h1><p>早期的Linux是针对386开发的。Linux提供了一个完整的操作系统当中最底层的硬件控制与资源管理的完整架构，这个架构是沿袭Unix良好的传统来的，所以相当的稳定而功能强大！</p><p>Linux参考了标准的POSIX规范。POSIX是可携式操作系统接口的缩写，重点在规范核心与应用程序之间的接口，这是由美国电器与电子工程师学会（IEEE）所发布的一项标准。</p><p>Linux其实就是一个操作系统最底层的核心及其提供的核心工具。它是GNU GPL授权模式，所以任何人均可取得源代码与可执行这个核心程序，并且可以修改。此外，因为Linux参考POSIX设计规范，于是相容于Unix操作系统，亦可称为Unix Like的一种。</p><p>Linux distributions就是Kernel+Softwares+Tools+可完整安装程序。一般称为可完整安装套件或Linux发布商套件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-18%20%E4%B8%8A%E5%8D%889.33.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于Linux核心是由工程师写得，由源代码安装到x86计算机上面成为可以执行的binary文件这个过程不是人人都会的，所以早期确实只有工程师对Linux感兴趣。一直到一些社群与商业公司将Linux核心配合自由软件，并提供完整的安装程序且制成光盘，对于一般人来说，Linux才越来越有吸引力。</p><p>每个distributions差异性并不大，主要是套件管理方式上的区分为dpkg和RPM。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-18%20%E4%B8%8A%E5%8D%889.42.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>到底是要买商业版还是社群版的Linux distribution呢?如果是要装在个人计算机上面做为桌面电脑用的， 建议使用社群版，包括Fedora, Ubuntu, OpenSuSE等等。如果是用在服务器上面的， 建议使用商业版本，包括Red Hat, SuSE等。这是因为社群版通常开发者会加入最新的软件，这些软件可能会有一些bug存在。至于商业版则是经过一段时间的磨合后，才将稳定的软件放进去。</p><p>Linux的运用场景<br>企业环境的利用：<br><strong>网络服务器:</strong><br>这是Linux当前最热门的应用了!承袭了Unix高稳定性的良好传统，Linux.上面的网络功能特别的稳定与强大!此外，由于GNU计划与Linux的GPL授权模式，让很多优秀的软件都在Linux上面发展，且这些在Linux上面的服务器软件几乎都是自由软件!因此，做为一部网络服务器，例如WWW, Mail Server, File Server等等， Linux绝对是上上之选!当然，这也是Linux的强项!由于Linux server的需求强烈，因此许多硬件厂商推出产品时，还得要特别说明有支持的Linux distributions呢!</p><p><strong>关键任务的应用（金融数据库、大型企业网管环境）</strong><br>由于个人计算机的性能大幅提升且价格便宜，所以金融业与大型企业的环境为了要精实自己机房的机器设备，因此很多企业渐渐的走向Intel相容的x86主机环境。而这些企业所使用的软件大多使用Unix操作系统平台的软件，总不能连过去发展的软件都一口气全部换掉吧!所以，这个时候符合Unix操作系统标准并且可以在x86.上运行的Linux就渐渐崭露头角了!</p><p><strong>学术机构的高性能运算任务：</strong><br>学术机构的研究常常需要自行开发软件，所以对于可作为开发环境的操作系统需求非常的迫切!举例来说，非常多技职体系的科技大学就很需要这方面的环境，好进行一些毕业专题的制作呢!又例如工程界流体力学的数值模式运算、娱乐事业的特效功能处理、软件开发者的工作平台等等。由于Linux的创造者本身就是个计算机性能癖，所以Linux有强大的运算能力;并且Linux具有支持度相当广泛的GCC编译软件，因此Linux在这方面的优势可是相当明显的!</p><p>个人使用：<br><strong>个人电脑：</strong><br>为了要强化桌面电脑的使用率，Linux与X Window System结合了!要注意的是，X Window System仅只是Linux上面的一套软件，而不是核心喔!所以即使X Window挂了，对Linux也可能不会有直接的影响。</p><p><strong>手持系统（PDA、手机）:</strong><br>Android就是Linux核心的一支，专门用来针对手机/平板这类ARM机器所设计的。</p><p><strong>嵌入式系统：</strong><br>包括路由器、防火墙、手机、IP分享器、交换器、机器人控制芯片、家电用品的微计算机控制器等等，都可以是Linux操作系统喔!</p><p>云端运用：<br><strong>云程序</strong><br><strong>端设备</strong></p><p>以服务器或者是嵌入式系统的应用来说，X Window是非必备的软件，因为服务器是要提供用户端来连线的，X Window通常会吃掉很多系统资源。</p><h1 id="第二章-主机规划与磁盘划分"><a href="#第二章-主机规划与磁盘划分" class="headerlink" title="第二章 主机规划与磁盘划分"></a>第二章 主机规划与磁盘划分</h1><p>并非所有的产品都会支持特定的操作系统，这牵涉到硬件开发商是否有意愿提供适当的驱动程序之故。因此，当我们想要购买或者是升级某些计算机元件时，应该要特别注意该硬件是否有针对您的操作系统提供适当的驱动程序，否则可能买了无法使用。</p><p>在Linux系统中，每个设备被当成一个文件来对待，几乎所有的硬件设备文件都在/dev这个目录内。</p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>整个磁盘的第一个扇区特别的重要，因为他记录了整个磁盘的重要信息。早期磁盘第一个扇区里面含有重要的信息称为MBR格式，但是由于磁盘的容量不断扩大，造成读写上的一些困扰，甚至有些大于2TB以上的磁盘分区已经让某些操作系统无法存取。因此后来又多了一个新的磁盘分区格式，称为GPT。</p><h3 id="MSDOS（MBR）与GPT"><a href="#MSDOS（MBR）与GPT" class="headerlink" title="MSDOS（MBR）与GPT"></a>MSDOS（MBR）与GPT</h3><p>MSDOS（MBR）分区表格式与限制：<br>早期的Linux系统为了相容于Windows的磁盘，因此使用的是支持Windows的<br>MBR (Master Boot Record,主要开机纪录区)的方式来处理开机管理程序与分区表!而开机管理程序纪录区与分区表则通通放在磁盘的第一个扇区，这个扇区通常是512Bytes的大小(旧的磁盘扇区都是512Bytes喔!)，所以说，第一个扇区512Bytes会有这两个数据:</p><ol><li>主要开机记录区（Masrer Boot Record,MBR）：可以安装开机管理程序的地方，有446Bytes</li><li>分区表（partition table）:记录整颗硬盘分区的状态，有64Bytes</li></ol><h3 id="Linux安装模式下，磁盘分区的选择（极重要）"><a href="#Linux安装模式下，磁盘分区的选择（极重要）" class="headerlink" title="Linux安装模式下，磁盘分区的选择（极重要）"></a>Linux安装模式下，磁盘分区的选择（极重要）</h3><h4 id="目录树结构"><a href="#目录树结构" class="headerlink" title="目录树结构"></a>目录树结构</h4><p>Linux内所有的数据都是以文件形态来呈现的，Linux系统最重要的地方就是在于目录树架构。就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%887.55.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所有的文件都是由根目录（_）衍生来的，当要取得mydata那个文件时，系统就由根目录开始找，最终的文件名为: _home_dmtsai_mydata的意思。</p><h4 id="文件系统与目录树的关系（挂载）"><a href="#文件系统与目录树的关系（挂载）" class="headerlink" title="文件系统与目录树的关系（挂载）"></a>文件系统与目录树的关系（挂载）</h4><p>挂载就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说，进入该目录就可以读取该分区的意思。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%888.11.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>假设硬盘分为两个分区 partition1是挂载到根目录,至于 partition2则是挂载到/ home这个目录。这也就是说当我的数据放置在 home 内的各次目录时,数据是放置到partition2的如果不是放在/home下面的目录,那么数据就会被放置到 partition1。</p><h4 id="至少两个分区"><a href="#至少两个分区" class="headerlink" title="至少两个分区"></a>至少两个分区</h4><p>但记住至少要有两个分区，一个swap分区，一个/分区。swap分区是linux暂时存储数据的交换分区，它主要是把主内存上暂时不用得数据存起来，在需要的时候再调进内存内，且作为swap使用的分区不用指定“mout point”（载入点），既然它作为交换分区，我们理所当然应给它指定大小，它至少要等于系统上实际内存的量，一般来说它的大小是内存的两倍，如果你是16mb的内存，那么swap分区的大小是32mb左右，以此类推。但必须还要注意一点，swap分区不要大于128mb，因为系统不需要太大的交换分区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第零章、计算机概论&quot;&gt;&lt;a href=&quot;#第零章、计算机概论&quot; class=&quot;headerlink&quot; title=&quot;第零章、计算机概论&quot;&gt;&lt;/a&gt;第零章、计算机概论&lt;/h1&gt;&lt;p&gt;CPU实际要处理的数据完全来自于内存（不管是程序还是一般文件数据）。&lt;br&gt;CPU架
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫 爬小说 爬图片 爬视频</title>
    <link href="https://github.com/zdkswd/2019/01/16/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>https://github.com/zdkswd/2019/01/16/网络爬虫/</id>
    <published>2019-01-16T12:15:32.000Z</published>
    <updated>2019-02-08T04:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><p>参考<a href="https://cuijiahua.com/blog/2017/10/spider_tutorial_1.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/10/spider_tutorial_1.html</a><br>网络爬虫的第一步就是根据URL，获取网页的HTML信息。在Python3中，可以使用urllib.request和requests进行网页爬取。</p><ol><li>urllib库是python内置的，无需我们额外安装，只要安装了Python就可以使用这个库。</li><li>requests库是第三方库，需要我们自己安装。</li></ol><p>requests库的基础方法如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%888.59.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests.get()方法，它用于向服务器发起GET请求。requests.get()方法就是从服务器得到、抓住数据，也就是获取数据。</p><h1 id="小说下载"><a href="#小说下载" class="headerlink" title="小说下载"></a>小说下载</h1><p>代码<a href="https://github.com/zdkswd/papapachong/tree/master/%E7%88%AC%E5%8F%96%E5%B0%8F%E8%AF%B4">papapachong/爬取小说 at master · zdkswd/papapachong · GitHub</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小说网站-笔趣看：</p><p>URL：http:<a href="http://www.biqukan.com/" target="_blank" rel="noopener">www.biqukan.com/</a><br>笔趣看是一个盗版小说网站，这里有很多起点中文网的小说，该网站小说的更新速度稍滞后于起点中文网正版小说的更新速度。并且该网站只支持在线浏览，不支持小说打包下载。因此，本次实战就是从该网站爬取并保存一本名为《一念永恒》的小说，该小说是耳根正在连载中的一部玄幻小说。PS：本实例仅为交流学习，支持耳根大大，请上起点中文网订阅。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>《一念永恒》小说的第一章内容，URL：<a href="http://www.biqukan.com/1_1094/5403177.html" target="_blank" rel="noopener">http://www.biqukan.com/1_1094/5403177.html</a></p><p>通过result=rq.get(url=target)<br>我们很轻松地获取了HTML信息。但是，很显然，很多信息是我们不想看到的，我们只想获得如右侧所示的正文内容，我们不关心div、br这些html标签。如何把正文内容从这些众多的html标签中提取出来呢？这就是本次实战的主要内容。</p><h2 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h2><p>爬虫的第一步，获取整个网页的HTML信息，我们已经完成。接下来就是爬虫的第二步，解析HTML信息，提取我们感兴趣的内容。对于本小节的实战，我们感兴趣的内容就是文章的正文。提取的方法有很多，例如使用正则表达式、Xpath、Beautiful Soup等。对于初学者而言，最容易理解，并且使用简单的方法就是使用Beautiful Soup提取感兴趣内容。</p><p>Beautiful Soup中文的官方文档。URL：<br><a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://beautifulsoup.readthedocs.io/zh_CN/latest/</a></p><p>仔细观察目标网站一番，我们会发现这样一个事实：class属性为showtxt的div标签，独一份！这个标签里面存放的内容，是我们关心的正文部分。</p><p>知道这个信息，我们就可以使用Beautiful Soup提取我们想要的内容了。<br>在解析html之前，我们需要创建一个Beautiful Soup对象。BeautifulSoup函数里的参数就是我们已经获得的html信息。然后我们使用find_all方法，获得html信息中所有class属性为showtxt的div标签。find_all方法的第一个参数是获取的标签名，第二个参数class_是标签的属性，为什么不是class，而带了一个下划线呢？因为python中class是关键字，为了防止冲突，这里使用class_表示标签的class属性。</p><p>为什么不是find_all(‘div’, id = ‘content’, class_ = ‘showtxt’)?这样其实也是可以的，属性是作为查询时候的约束条件，添加一个class_=’showtxt’条件，我们就已经能够准确匹配到我们想要的标签了，所以我们就不必再添加id这个属性了。</p><p>此时结果中有一些我们不想要的东西。比如div标签名，br标签，以及各种空格。怎么去除这些东西呢？</p><p>find_all匹配的返回的结果是一个列表。提取匹配结果后，使用text属性，提取文本内容，滤除br标签。随后使用replace方法，剔除空格，替换为回车进行分段。&nbsp;在html中是用来表示空格的。replace(‘\xa0’*8,’\n\n’)就是去掉下图的八个空格符号，并用回车代替。</p><p>可以看到，我们很自然的匹配到了所有正文内容，并进行了分段。我们已经顺利获得了一个章节的内容，要想下载正本小说，我们就要获取每个章节的链接。我们先分析下小说目录：</p><p>URL：http:<a href="http://www.biqukan.com/1_1094/" target="_blank" rel="noopener">www.biqukan.com/1_1094/</a></p><p>根据<a> 标签的href属性值获得每个章节的链接和名称。小说每章的链接放在了class属性为listmain的<div>标签下的<a>标签中。链接具体位置放在html-&gt;body-&gt;div-&gt;dl-&gt;dd-&gt;a的href属性中。先匹配class属性为listmain的<div>标签，再匹配<a>标签。</a></div></a></div></a></p><h1 id="爬取壁纸"><a href="#爬取壁纸" class="headerlink" title="爬取壁纸"></a>爬取壁纸</h1><p><a href="https://github.com/zdkswd/papapachong/tree/master/%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87">papapachong/爬取图片 at master · zdkswd/papapachong · GitHub</a></p><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>URL：https:unsplash.com/<br>网站的名字叫做Unsplash，免费高清壁纸分享网是一个坚持每天分享高清的摄影图片的站点，每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片可以作为桌面壁纸也可以应用于各种需要的环境。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ol><li>使用requeusts获取整个网页的HTML信息；</li><li>使用Beautiful Soup解析HTML信息，找到所有<img>标签，提取src属性，获取图片存放地址；</li><li>根据图片存放地址，下载图片。</li></ol><p>照此方法得不到<img>标签，而是\&lt;script>标签，因为这个网站的所有图片都是动态加载的！网站有静态网站和动态网站之分，上一个实战爬取的网站是静态网站，而这个网站是动态网站，动态加载有一部分的目的就是为了反爬虫。</p><p>动态网站使用动态加载常用的手段就是通过调用JavaScript来实现的。一个动态加载的网站可能使用很多JavaScript脚本，我们只要找到负责动态加载图片的JavaScript脚本。强大的抓包工具，它会帮助分析。这个强大的抓包工具就是Fiddler。但是Fiddler只在Windows上才能发挥完全的作用，所以我用的是一个跨平台的抓包工具Charles。</p><p>经过抓包发现，在如下数据包中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-23%20%E4%B8%8B%E5%8D%889.04.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>有json数据包<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-23%20%E4%B8%8B%E5%8D%889.08.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>id和下载图片有以下的关系<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-23%20%E4%B8%8B%E5%8D%889.04.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所以可以</p><ol><li>获取整个json数据</li><li>解析json数据</li></ol><p>如果直接获取会出现SSL认证的错误，SSL认证是指客户端到服务器端的认证。一个非常简单的解决这个认证错误的方法就是设置requests.get()方法的verify参数。这个参数默认设置为True，也就是执行认证。我们将其设置为False，绕过认证。</p><p>反爬虫的手段除了动态加载，还有一个反爬虫手段，那就是验证Request Headers。Requests Headers里有很多参数，有Accept、Accept-Encoding、Accept-Language、DPR、User-Agent、Viewport-Width、accept-version、Referer、x-unsplash-client、authorization、Connection、Host。</p><ol><li>User-Agent：这里面存放浏览器的信息。如果我们不设置这个参数，用Python程序直接发送GET请求，服务器接受到的User-Agent信息就会是一个包含python字样的User-Agent。如果后台设计者验证这个User-Agent参数是否合法，不让带Python字样的User-Agent访问，这样就起到了反爬虫的作用。这是一个最简单的，最常用的反爬虫手段。</li><li>Referer：这个参数也可以用于反爬虫，它表示这个请求是从哪发出的。可以看到我们通过浏览器访问网站，这个请求是从<a href="https://unsplash.com/，这个地址发出的。如果后台设计者，验证这个参数，对于不是从这个地址跳转过来的请求一律禁止访问，这样就也起到了反爬虫的作用。" target="_blank" rel="noopener">https://unsplash.com/，这个地址发出的。如果后台设计者，验证这个参数，对于不是从这个地址跳转过来的请求一律禁止访问，这样就也起到了反爬虫的作用。</a></li><li>authorization：这个参数是基于AAA模型中的身份验证信息允许访问一种资源的行为。在我们用浏览器访问的时候，服务器会为访问者分配这个用户ID。如果后台设计者，验证这个参数，对于没有用户ID的请求一律禁止访问，这样就又起到了反爬虫的作用。</li></ol><p>Unsplash是根据authorization参数进行反爬虫的。通过程序手动添加这个参数，然后再发送GET请求，就可以顺利访问了。即requests.get()方法，添加headers参数即可。</p><p>现在终于顺利获得json数据了，使用json.load()方法解析数据。解析json数据很简单，跟字典操作一样，就是字典套字典。json.load()里面的参数是原始的json格式的数据。</p><p>图片的ID已经获得了，再通过字符串处理一下，就生成了我们需要的图片下载请求地址。根据这个地址，我们就可以下载图片了。下载方式，使用直接写入文件的方法。</p><p>每次获取链接加一个1s延时，因为人在浏览页面的时候，翻页的动作不可能太快。我们要让我们的爬虫尽量友好一些。</p><p>下载速度还行，有的图片下载慢是因为图片太大。可以看到也打印了一些警报信息，这是因为没有进行SSL验证。</p><h1 id="爱奇艺VIP视频下载"><a href="#爱奇艺VIP视频下载" class="headerlink" title="爱奇艺VIP视频下载"></a>爱奇艺VIP视频下载</h1><p>现在失效了，只能手动抓包了<br><a href="https://github.com/zdkswd/papapachong/tree/master/%E7%88%AC%E5%8F%96%E8%A7%86%E9%A2%91">papapachong/爬取视频 at master · zdkswd/papapachong · GitHub</a><br><a href="http://www.wq114.org/" target="_blank" rel="noopener">vip视频解析,vip视频在线解析</a>有效的url解析网站。<br>解析格式：<a href="http://www.wq114.org/yun.php?url=" target="_blank" rel="noopener">www.wq114.org/yun.php?url=</a> [视频url]<br>利用网络爬虫进行抓包，可以将视频下载下来。</p><p>HTTP请求头Referer的作用：表示请求来源。</p><p>编写代码的时候注意一个问题，就是我们需要使用requests.session()保持我们的会话请求。简单理解就是，在初次访问服务器的时候，服务器会给你分配一个身份证明。我们需要拿着这个身份证去继续访问，如果没有这个身份证明，服务器就不会再让你访问。这也就是这个服务器的反爬虫手段，会验证用户的身份。</p><h1 id="selenium和xpath"><a href="#selenium和xpath" class="headerlink" title="selenium和xpath"></a>selenium和xpath</h1><p><a href="https://github.com/zdkswd/papapachong/tree/master/%E5%AE%89%E5%B1%85%E5%AE%A2">https://github.com/zdkswd/papapachong/tree/master/%E5%AE%89%E5%B1%85%E5%AE%A2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络爬虫&quot;&gt;&lt;a href=&quot;#网络爬虫&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫&quot;&gt;&lt;/a&gt;网络爬虫&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;https://cuijiahua.com/blog/2017/10/spider_tutorial_
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
      <category term="爬虫" scheme="https://github.com/zdkswd/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>SSH</title>
    <link href="https://github.com/zdkswd/2019/01/16/SSH/"/>
    <id>https://github.com/zdkswd/2019/01/16/SSH/</id>
    <published>2019-01-16T12:09:56.000Z</published>
    <updated>2019-01-16T12:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>参考<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p><h1 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h1><p>SSH是一种网络协议，用于计算机之间的加密登录。</p><p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p><p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p><p>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。本文只讨论SSH在Linux Shell中的用法。</p><h1 id="最基本的用法"><a href="#最基本的用法" class="headerlink" title="最基本的用法"></a>最基本的用法</h1><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.28.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果本地用户名与远程用户名一致，登录时可以省略用户名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.28.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.29.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面这条命令表示，ssh直接连接远程主机的2222端口。</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p><p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><p>SSH协议也有应对的方法。</p><h1 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h1><p>如果你是第一次登录对方主机，系统会出现下面的提示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.36.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p><p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.39.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>系统会出现一句提示，表示host主机已经得到认可。然后会要求输入密码。密码正确就可以登录了。</p><p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/ .ssh /known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p><p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/ etc / ssh /ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h1 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h1><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p><p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.00.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p><p>运行结束以后，在$HOME/ .ssh /目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p><p>这时再输入下面的命令，将公钥传送到远程主机host上面：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.50.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从此再登录，就不需要输入密码了。</p><p>如果还是不行，就打开远程主机的_etc_ssh/sshd_config这个文件，检查下面几行前面# 注释是否取掉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.58.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后，重启远程主机的ssh服务。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.58.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="公钥私钥补充"><a href="#公钥私钥补充" class="headerlink" title="公钥私钥补充"></a>公钥私钥补充</h1><p>如果只是单方面采用非对称性加密算法,其实有两种方式,用于不同用处。</p><p>第一种是签名,使用私钥加密,公钥解密,用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改.但是不用来保证内容不被他人获得。</p><p>第二种是加密,用公钥加密,私钥解密,用于向公钥所有者发布信息,这个信息可能被他人篡改,但是无法被他人获得。</p><p>如果甲想给乙发一个安全的保密的数据,那么应该甲乙各自有一个私钥,甲先用乙的公钥加密这段数据,再用自己的私钥加密这段加密后的数据.最后再发给乙,这样确保了内容即不会被读取,也不会被篡改。</p><h1 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h1><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。</p><p>SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>python requests库</title>
    <link href="https://github.com/zdkswd/2019/01/14/python%20requests%E5%BA%93/"/>
    <id>https://github.com/zdkswd/2019/01/14/python requests库/</id>
    <published>2019-01-14T04:03:56.000Z</published>
    <updated>2019-01-14T04:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="requests库的使用（廖雪峰）"><a href="#requests库的使用（廖雪峰）" class="headerlink" title="requests库的使用（廖雪峰）"></a>requests库的使用（廖雪峰）</h1><p>要通过GET访问一个页面，只需要几行代码：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%888.53.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于带参数的URL，传入一个dict作为params参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%888.56.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests自动检测编码，可以使用encoding属性查看：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.03.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.04.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.05.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要传入HTTP Header时，我们传入一个dict作为headers参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.07.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.08.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests默认使用application/x-www-form-urlencoded对POST数据编码。如果要传递JSON数据，可以直接传入json参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>类似的，上传文件需要更复杂的编码格式，但是requests把它简化成files参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.10.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在读取文件时，注意务必使用’rb’即二进制模式读取，这样获取的bytes长度才是文件的长度。</p><p>把post()方法替换为put()，delete()等，就可以以PUT或DELETE方式请求资源。</p><p>除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.14.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.15.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要在请求中传入Cookie，只需准备一个dict传入cookies参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.15.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最后，要指定超时，传入以秒为单位的timeout参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.16.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="requests的使用（博客）"><a href="#requests的使用（博客）" class="headerlink" title="requests的使用（博客）"></a>requests的使用（博客）</h1><p><a href="https://blog.csdn.net/WuZuoDingFeng/article/details/76156777" target="_blank" rel="noopener">https://blog.csdn.net/WuZuoDingFeng/article/details/76156777</a></p><h2 id="requests-get"><a href="#requests-get" class="headerlink" title="requests.get()"></a>requests.get()</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.16.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>参数说明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.18.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="requests-post"><a href="#requests-post" class="headerlink" title="requests.post()"></a>requests.post()</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.19.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>参数说明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.19.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="请求响应体说明"><a href="#请求响应体说明" class="headerlink" title="请求响应体说明"></a>请求响应体说明</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.28.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="requests-utils中的常用方法"><a href="#requests-utils中的常用方法" class="headerlink" title="requests.utils中的常用方法"></a>requests.utils中的常用方法</h2><ol><li>requests.utils.get_encodings_from_content(r.content): 返回原始数据编码;</li><li>requests.utils.dict_from_cookiejar(r.cookies): 将CookieJar转为字典;</li><li>requests.utils.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True): 将字典转为CookieJar;</li></ol><h2 id="开启会话，保持cookie"><a href="#开启会话，保持cookie" class="headerlink" title="开启会话，保持cookie"></a>开启会话，保持cookie</h2><blockquote><p>s = requests.Session()             # 开启会话<br>cookies = json.loads(result)                     # phantomjs获取的cookies json对象<br>cookie = {}<br>for k in cookies:<br>   cookie[k[‘name’]] = k[‘value’]               # 获取每个cookie中的name和value<br>s.cookies = requests.utils.cookiejar_from_dict(cookie, cookiejar=None,<br>overwrite=True)       # 将字典cookie转换为cookieJar,然后放在会话中<br>s.get(url…..)              # 此时每个请求都会带上cookie<br>……………………………………………………<br>s.cookies: cookiejar对象;<br>s.cookies.get_dict(): dict,cookie键值对;  </p></blockquote><h2 id="设置超时和最大尝试次数"><a href="#设置超时和最大尝试次数" class="headerlink" title="设置超时和最大尝试次数"></a>设置超时和最大尝试次数</h2><ol><li>timeout是get/post等的参数, 单位秒.</li><li>max_retries需要构建一个HTTPAdapter并设置其max_retries, 最后将该Adaptor加载给requests的Session对象. mount时的链接是前端最大匹配, 使用” http: ”和” https: ”可以分别对应两大类网址. 也可以更具体针对某网站.</li><li>注：max_retries适用于超时，并不适用于访问出错。</li><li>注：在会话中，请求url1所返回的cookies会自动保存，当访问url2的时候也会被自动带入。</li></ol><blockquote><p>requestsSession = requests.Session()                # 开启会话<br>requestsAdapterA = requests.adapters.HTTPAdapter(max_retries=3)     # 挂载适配器<br>requestsSession.mount(‘http: ‘, requestsAdapterA)    # 此会话中适用所有http请求<br>r = requestsSession.get(url , timeout=20)                  # 打开相应url并设置超时  </p></blockquote><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><blockquote><p>url = ‘<a href="http://httpbin.org/post&#39;" target="_blank" rel="noopener">http://httpbin.org/post&#39;</a><br>files = {‘file’: open(‘report.xls’, ‘rb’)}<br> #  files = {‘file’: (‘report.xls’, open(‘report.xls’, ‘rb’), ‘application/vnd.ms-excel’, {‘Expires’: ‘0’})}   # 显示的设置文件名、文件类型、文件头<br>r = requests.post(url, files=files)<br>r.text  </p></blockquote><h2 id="流式上传"><a href="#流式上传" class="headerlink" title="流式上传"></a>流式上传</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.49.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.49.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>get()或post()中的headers、cookies设置的值，将合并到Requests中去，所以传入 {} 也没关系；</li><li>图片、pdf等打开方式应该为 ‘wb’，写入的内容应该是 r.content；</li><li>若是响应头Content-Type中不含charset，则 r.text 默认为 ‘ISO-8859-1’；</li><li>若是timeout没有显示的设置，理论上requests请求永不超时。</li><li>在session中删除一个参数，直接设置其值为None；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;requests库的使用（廖雪峰）&quot;&gt;&lt;a href=&quot;#requests库的使用（廖雪峰）&quot; class=&quot;headerlink&quot; title=&quot;requests库的使用（廖雪峰）&quot;&gt;&lt;/a&gt;requests库的使用（廖雪峰）&lt;/h1&gt;&lt;p&gt;要通过GET访问一个
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发的MVC和MVP模式</title>
    <link href="https://github.com/zdkswd/2019/01/08/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%9A%84MVC%E5%92%8CMVP%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2019/01/08/安卓开发的MVC和MVP模式/</id>
    <published>2019-01-08T12:04:56.000Z</published>
    <updated>2019-01-08T12:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC和MVP示意图"><a href="#MVC和MVP示意图" class="headerlink" title="MVC和MVP示意图"></a>MVC和MVP示意图</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%9A%84MVC%E5%92%8CMVP%E6%A8%A1%E5%BC%8F/20170813105245063.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%9A%84MVC%E5%92%8CMVP%E6%A8%A1%E5%BC%8F/20170813013123472.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="MVP和MVC的区别"><a href="#MVP和MVC的区别" class="headerlink" title="MVP和MVC的区别"></a>MVP和MVC的区别</h1><ol><li><strong>Activity职责不同</strong>，Activity在MVP中是View层，在MVC中是Controller层，这是MVC和MVP很主要的一个区别，可以说Android从MVC转向MVP开发也主要是优化Activity的代码，避免Activity的代码臃肿庞大。</li><li><strong>View层不同</strong>，MVC的View层指的是XML布局文件或者是用Java自定义的View，MVP的View层是Activity或者Fragment。使用传统的MVC，其中的View，对应的是各种Layout布局文件，但是这些布局文件中并不像Web端那样强大，能做的事情非常有限。MVP的View层Activity在实际项目中，随着逻辑的复杂度越来越大，Activity臃肿的缺点仍然体现出来了，因为Activity中还是充满了大量与View层无关的代码，比如各种事件的处理派发，就如MVC中的那样View层和Controller代码耦合在一起无法自拔。</li><li><strong>控制层不同</strong>，MVC的控制层是Activity，或者是Fragment，Controller对应的是Activity，而Activity中却又具有操作UI的功能，我们在实际的项目中也会有很多UI操作在这一层，也做了很多View中应该做的事情，当然Controller层Activity中也包含Controller应该做的事情，比如各种事件的派发回调，而且在一层中我们会根据事件再去调用Model层操作数据，所以这种MVC的方式在实际项目中，Activity所在的Controller是非常重的，各层次之间的耦合情况也比较严重，不方便单元测试。MVP的控制层是Presenter，里面没有很多的实际东西，主要是做Model和View层的交互。</li><li><strong>关系链不同</strong>，MVP中Model层与View是没有关系的，彼此不会通讯和操作，Model与View的通讯都是Presenter层来传达的。但是在MVC中，Model层和View是曾在交互的。比如我们自定义的View控件里面肯定是要使用Model的数据的，View也要根据不同的Model数据做出不同的展现！这点尤其是体现在自定义的View中，自定义View需要设置数据，用户操作了自定义控件需要改变数据，View要操作Model怎么办？有人说把Controller传到自定义的View啊，现实是不可能没一个自定义View都去持有Controller的引用，其实在MVP中就不会这么尴尬，接口就可以完成。</li><li><strong>适用范围不同</strong>，在Android中，MVP和MVC都用自己的适用情况，使用MVP可以更好的解耦三大模块，模块之间比较清晰，也很方便使用MVP来组件化架构整体项目。但是MVC也是有用武之地的，在组件化的Module或者中间件我们可以使用MVC来做，Module或者中间件不会存在很复杂的View层，使用MVC可以更加方便我们实现功能。</li><li><strong>交互方式不同</strong>，MVP中通讯交互基本都是通过接口的，MVC中的通讯交互很多时候都是实打实的调用对象的方法，简单粗暴！</li><li><strong>实现方法不同</strong> ，MVC和MVP的Model几乎一样的，都是处理数据，只要不在Activity或者Fragment中请求数据，其他的所有控制都放在Activity或者Fragment中，这样写就基本是MVC的模式，这样写不麻烦，但是很容易把Activity写出上万行代码。用MVP的时候我们需要写很多View和Presenter接口来实现模块之间的通讯，会增加很多类。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MVC和MVP示意图&quot;&gt;&lt;a href=&quot;#MVC和MVP示意图&quot; class=&quot;headerlink&quot; title=&quot;MVC和MVP示意图&quot;&gt;&lt;/a&gt;MVC和MVP示意图&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
           
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C++内存格局 汇编语言</title>
    <link href="https://github.com/zdkswd/2019/01/05/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/"/>
    <id>https://github.com/zdkswd/2019/01/05/C++内存格局/</id>
    <published>2019-01-05T06:48:56.000Z</published>
    <updated>2019-01-05T06:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-内存格局"><a href="#C-内存格局" class="headerlink" title="C++内存格局"></a>C++内存格局</h1><p>C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/1097927-20180724163319830-302594590.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012204.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。</p><h2 id="汇编语言是什么"><a href="#汇编语言是什么" class="headerlink" title="汇编语言是什么"></a>汇编语言是什么</h2><p>CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。<strong>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</strong>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p><h2 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h2><p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p><p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p><p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p><p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><p>寄存器不依靠地址区分数据，而依靠<strong>名称</strong>。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p><h2 id="寄存器的种类"><a href="#寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。<br>EAX，EBX，ECX，EDX，EDI，ESI，EBP，ESP<br>8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址。</p><p>32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p><h2 id="内存模型：Heap"><a href="#内存模型：Heap" class="headerlink" title="内存模型：Heap"></a>内存模型：Heap</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012208.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012209.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h2 id="内存模型：Stack"><a href="#内存模型：Stack" class="headerlink" title="内存模型：Stack"></a>内存模型：Stack</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012210.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.21.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012211.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果函数内部调用了其他函数，会发生什么情况？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.22.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012215.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。</p><h2 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h2><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><p>一个简单的程序example.c。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.30.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>gcc 将这个程序转成汇编语言。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.30.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p>example.s经过简化以后，大概是下面的样子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.32.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。<br>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.33.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.03.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第二行也是一样，push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012216.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>第三行的call指令用来调用函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.04.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。下面就开始执行_add_a_and_b的代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.05.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p><h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>mov指令用于将一个值写入某个寄存器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.08.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。下一行代码也是干同样的事情。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。</p><h3 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h3><p>add指令用于将两个运算子相加，并将结果写入第一个运算子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.14.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="pop指令"><a href="#pop指令" class="headerlink" title="pop指令"></a>pop指令</h3><p>pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.16.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p><h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p>ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.17.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，该指令没有运算子。</p><p>随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.19.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最后，main函数运行结束，ret指令退出程序执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-内存格局&quot;&gt;&lt;a href=&quot;#C-内存格局&quot; class=&quot;headerlink&quot; title=&quot;C++内存格局&quot;&gt;&lt;/a&gt;C++内存格局&lt;/h1&gt;&lt;p&gt;C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
      <category term="汇编" scheme="https://github.com/zdkswd/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
