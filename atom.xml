<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZDK&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zdkswd/"/>
  <updated>2019-02-04T11:27:05.000Z</updated>
  <id>https://github.com/zdkswd/</id>
  
  <author>
    <name>ZDK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鸟哥 Linux账号管理</title>
    <link href="https://github.com/zdkswd/2019/02/04/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://github.com/zdkswd/2019/02/04/鸟哥 Linux账号管理/</id>
    <published>2019-02-04T11:25:32.000Z</published>
    <updated>2019-02-04T11:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸟哥-Linux账号管理"><a href="#鸟哥-Linux账号管理" class="headerlink" title="鸟哥 Linux账号管理"></a>鸟哥 Linux账号管理</h1><h2 id="Linux的账号与群组"><a href="#Linux的账号与群组" class="headerlink" title="Linux的账号与群组"></a>Linux的账号与群组</h2><h3 id="使用者识别码：UID与GID"><a href="#使用者识别码：UID与GID" class="headerlink" title="使用者识别码：UID与GID"></a>使用者识别码：UID与GID</h3><p>当登录Linux主机时，输入的是账号，Linux 主机并不会直接认识你的帐号，他仅认识 ID，帐号只是为了让人们容易记忆而已，ID 与帐号的 对应就在 / etc /passwd 当中。</p><p>每个登陆的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称 UID)、一个是群组 ID (Group ID ，简称 GID)。 </p><p>文件是利用UID与GID来判别拥有者与群组。每一个文件都会有所谓的拥有者ID与拥有群组ID，当要显示文件属性时，系统会依据 / etc / passwd 与  / etc /group 的内容， 找到 UID / GID 对应的帐号与群组名称再显示出来。</p><h3 id="使用者账号"><a href="#使用者账号" class="headerlink" title="使用者账号"></a>使用者账号</h3><p>Linux 系统上面的使用者需要登陆主机以取得 shell工作环境，通过网络要使用ssh。输入账号密码后，系统做了工作：</p><ol><li>先找寻 / etc / passwd里面是否有你输入的帐号，如果没有则跳出，如果有的话则将该帐号对应的 UID 与 GID (在 / etc / group 中) 读出来，另外，该帐号的主文件夹与 shell 设置也一并读出。</li><li>来则是核对密码表啦!这时Linux会进入 / etc / shadow里面找出对应的帐号与UID，然后核对一下你刚刚输入的密码与里头的密码是否相符。</li><li>一切都OK的话，就进入Shell控管的阶段 。</li></ol><p>/ etc / passwd 文件结构<br>这个文件的构造是这样的:每一行都代表一个帐号，有几行就代表有几个帐号在你的系统中! 不过需要特别留意的是，里头很多帐号本来就是系统正常运行所必须要的，我们可以简称他为系统帐号， 例如 bin, daemon, adm, nobody 等等，这些帐号请不要随意的杀掉。</p><p>shadow中存储的密码单向运算。</p><p>遗忘密码</p><ol><li>一般用户的密码忘记了:这个最容易解决，请系统管理员帮忙， 他会重新设置好你的密码而不需要知道你的旧密码!利用 root 的身份使用 passwd 指令来处理即可。 </li><li>root密码忘记了，就比较麻烦了，但是可以使用各种可行的方法开机进入Linux再去修改。</li></ol><h3 id="关于群组：有效与初始群组，groups，newgrp"><a href="#关于群组：有效与初始群组，groups，newgrp" class="headerlink" title="关于群组：有效与初始群组，groups，newgrp"></a>关于群组：有效与初始群组，groups，newgrp</h3><p>/ etc / group文件结构<br>这个文件就是在记录GID与群组名称的对应。</p><h4 id="有效群组（effective-group）与初始群组（initial-group）"><a href="#有效群组（effective-group）与初始群组（initial-group）" class="headerlink" title="有效群组（effective group）与初始群组（initial group）"></a>有效群组（effective group）与初始群组（initial group）</h4><p>每个使用者在他的passwd第四栏有所谓的GID，就是所谓的初始群组（initial group），也就是当使用者一登陆系统，立刻就拥有这个群组的相关权限。</p><h4 id="groups有效与支持群组的观察"><a href="#groups有效与支持群组的观察" class="headerlink" title="groups有效与支持群组的观察"></a>groups有效与支持群组的观察</h4><p>知道所有的支持群组：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.42.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在这个输出的讯息中，可知道 dmtsai 这个用户同时属于 dmtsai, wheel 及 users 这三个群组，而且，第一个输出的群组即为有效群组 (effective group) 。 通常有效群组的作用在新建文件，确定新建文件所在的群组。</p><h4 id="newgrp：有效群组的切换"><a href="#newgrp：有效群组的切换" class="headerlink" title="newgrp：有效群组的切换"></a>newgrp：有效群组的切换</h4><p>newgrp 是有限制的，那就是你想要 切换的群组必须是你已经有支持的群组。举例来说， dmtsai 可以在 dmtsai / wheel / users 这三 个群组间切换有效群组，但是 dmtsai 无法切换有效群组成为 sshd 。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.48.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.51.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>加入一个群组有两个方式，一是通过系统管理员 (root) 利用 <strong>usermod</strong> 帮你加入，如果 root 太忙了而且你的系统有设置群组管理员，那么还可以通过群组管理员以 <strong>gpasswd</strong> 加入他所管理的群组中 。</p><p>/ etc / gshadow<br>以系统管理员的角度来说，这个 gshadow 最大的功能就是创建群组管理员。root 可能平时太忙碌，所以当有使 用者想要加入某些群组时， root 或许会没有空管理。此时如果能够创建群组管理员的话，那 么该群组管理员就能够将那个帐号加入自己管理的群组中! 可以免去 root 的忙碌啦!不过， 由于目前有类似 sudo 之类的工具， 所以这个群组管理员的功能已经很少使用了。 </p><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel"><a href="#新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel" class="headerlink" title="新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel"></a>新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel</h3><p>创建一个可用的账号需要账号与密码两个数据，账号可以用useradd来新建使用者，密码则使用passwd。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%885.29.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>系统会进行的操作：</p><ol><li>在 / etc / passwd 里面创建一行与帐号相关的数据，包括创建 UID / GID / 主文件夹等 。</li><li>在 / etc / shadow 里面将此帐号的密码相关参数填入，但是尚未有密码。</li><li>在 / etc / group 里面加入一个与帐号名称一模一样的群组名称。</li><li>在 / home 下面创建一个与帐号同名的目录作为使用者主文件夹，且权限为 700。</li></ol><p>由于在 / etc / shadow内仅会有密码参数而不会有加密过的密码数据，因此我们在创建使用者帐 号时， 还需要使用“ passwd 帐号 ”来给 密码才算是完成了使用者创建的流程。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%885.53.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>以上是root来设置用户的权限。用户还可以自己来更改自己的密码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%885.55.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>使用chage来进行更详细的密码参数显示功能。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.38.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>usermod<br>在使用useradd后，可以利用usermod来对某些地方进行细部修改。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.51.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>userdel<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.52.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>删除使用者的相关数据。</p><h3 id="使用者功能"><a href="#使用者功能" class="headerlink" title="使用者功能"></a>使用者功能</h3><p>一般身份使用者使用的指令。</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id 这个指令则可以查询某人或自己的相关 UID / GID 等等的信息 。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%886.58.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>就是change shell的简写。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.01.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="新增与移除群组"><a href="#新增与移除群组" class="headerlink" title="新增与移除群组"></a>新增与移除群组</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.03.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>跟 usermod 类似的，这个指令仅是在进行 group 相关参数的修改而已。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.04.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.05.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="gpasswd群组管理员功能"><a href="#gpasswd群组管理员功能" class="headerlink" title="gpasswd群组管理员功能"></a>gpasswd群组管理员功能</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.06.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="主机的细部权限规划：ACL的使用"><a href="#主机的细部权限规划：ACL的使用" class="headerlink" title="主机的细部权限规划：ACL的使用"></a>主机的细部权限规划：ACL的使用</h2><h3 id="什么是ACL与如何支持启动ACL"><a href="#什么是ACL与如何支持启动ACL" class="headerlink" title="什么是ACL与如何支持启动ACL"></a>什么是ACL与如何支持启动ACL</h3><p>ACL即Access Control List，传统的 Linux 权限只能针对一个用户、一个群组及非此群组的其他人设置权限而已，无法针对单一用户或个人来设计权限。而 ACL 就是为了要改变这个问题 。</p><h3 id="ACL的设置技巧：getfacl，setfacl"><a href="#ACL的设置技巧：getfacl，setfacl" class="headerlink" title="ACL的设置技巧：getfacl，setfacl"></a>ACL的设置技巧：getfacl，setfacl</h3><h2 id="使用者身份切换"><a href="#使用者身份切换" class="headerlink" title="使用者身份切换"></a>使用者身份切换</h2><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>su 是最简单的身份切换指令了，可以进行任何身份的切换。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.19.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>su 需要了解新切换的使用者密码 (常常是需要 root 的密码)， sudo 的执行则仅需要 自己的密码即可! 甚至可以设置不需要密码即可执行 sudo 。由于 sudo可以让你以其他用 户的身份执行指令 (通常是使用 root 的身份来执行指令)，因此并非所有人都能够执行 sudo ， 而是仅有规范到 _etc_sudoers 内的用户才能够执行 sudo 这个指令。</p><p>一般用户能够具有 sudo 的使用权，就是管理员事先审核通过后，才开放sudo 的使用权的!因此，除非是信任用户，否则一般用户默认是不能操作 sudo的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5%20Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-04%20%E4%B8%8B%E5%8D%887.21.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;鸟哥-Linux账号管理&quot;&gt;&lt;a href=&quot;#鸟哥-Linux账号管理&quot; class=&quot;headerlink&quot; title=&quot;鸟哥 Linux账号管理&quot;&gt;&lt;/a&gt;鸟哥 Linux账号管理&lt;/h1&gt;&lt;h2 id=&quot;Linux的账号与群组&quot;&gt;&lt;a href=&quot;#Li
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>廖雪峰SQL</title>
    <link href="https://github.com/zdkswd/2019/02/03/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/"/>
    <id>https://github.com/zdkswd/2019/02/03/廖雪峰SQL/</id>
    <published>2019-02-03T05:22:32.000Z</published>
    <updated>2019-02-03T05:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>NoSQL数据库，也就是非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等，它们都不是关系数据库。有很多人鼓吹现代Web程序已经无需关系数据库了，只需要使用NoSQL就可以。但事实上，SQL数据库从始至终从未被取代过。今天，SQL数据库仍然承担了各种应用程序的核心数据存储，而NoSQL数据库作为SQL数据库的补充，两者不再是二选一的问题，而是主从关系。所以，无论使用哪种编程语言，无论是Web开发、游戏开发还是手机开发，掌握SQL，是所有软件开发人员所必须的。</p><p>数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心。</p><p>数据库按照数据结构来组织，存储和管理数据，数据库一共有三种模型。层次模型，网状模型，关系模型。关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表。</p><p>随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。因为相比层次模型和网状模型，关系模型理解和使用起来最简单。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8A%E5%8D%8811.01.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。</p><p>数据类型<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8A%E5%8D%8811.02.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>表中列举了最常用的数据类型。很多数据类型还有别名，例如，REAL又可以写成FLOAT(24)。还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。</p><p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。</p><p><strong>主流关系数据库</strong><br>目前主流关系数据库分为：</p><ol><li>商用数据库，例如：Oracle，SQL Server，DB2等；</li><li>开源数据库，例如：MySQL，PostgreSQL等；</li><li>桌面数据库，以微软Access为代表，适合桌面应用程序使用；</li><li>嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。</li></ol><p><strong>SQL</strong><br>SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。</p><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。本文做出约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p><p><strong>MySQL</strong><br>MySQL是目前应用最广泛的开源关系数据库。MySQL经过几次收购就变成了Oracle旗下的产品。和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ol><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ol><p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</p><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。</p><p>由于MySQL是开源的，所以还有其衍生版本。</p><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。</p><p><strong>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</strong></p><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p>在关系数据库中，关系是通过<strong>主键</strong>和<strong>外键</strong>来维护的。</p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<strong>主键</strong>。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键</strong>。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有：</p><ol><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8A%E5%8D%8811.24.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>id_num和id_type这两列作为联合主键。<strong>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</strong></p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为<strong>外键</strong>。<br>students表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.53.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>classes表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.54.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.57.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为<strong>外键</strong>。外键并不是通过列名实现的，而是通过定义外键约束实现的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%887.59.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。</p><p><strong>由于外键约束会降低数据库的性能</strong>，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过ALTER TABLE实现的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.02.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN …实现的。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：<br>teacher表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.10.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>classes表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.10.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>中间表teacher_class关联两个一对多关系：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.11.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>通过中间表，我们就定义了一个“多对多”关系。</p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，students表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表contacts，我们就可以得到一个“一对一”关系：这里一对一的前提是student_id不重复。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.21.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>既然是一对一关系，那为啥不给students表增加一个mobile列，来合二为一。</p><p>如果业务允许，完全可以把两个表合为一个表。一对一关系准确地说，是contacts表一对一对应students表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于students表：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.25.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要经常根据score列进行查询，就可以对score列创建索引：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.26.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.27.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.31.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过UNIQUE关键字我们就添加了一个唯一索引。也可以只对某一列添加一个唯一约束而不创建唯一索引。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.32.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种情况下，name列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>假设表名是students，要查询students表的所有行，我们用如下SQL语句：</p><blockquote><p>SELECT * FROM students;  </p></blockquote><p>使用SELECT <em> FROM students时，SELECT是关键字，表示将要执行一个查询，</em> 表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。该SQL将查询出students表的所有数据。注意：查询结果也是一个<strong>二维表</strong>，它包含列名和每一行的数据。</p><p>不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。</p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><blockquote><p>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;  </p></blockquote><p>条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><ol><li>根据score列的数据判断：score &gt;= 80</li><li>根据gender列的数据判断：gender = ‘M’，注意gender列存储的是字符串，需要用单引号括起来。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.44.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>除了AND以外，还有NOT以及OR。如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。</p><h3 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.46.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>%表示0个到多个，_ 表示1个。</p><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM …，让结果集仅包含指定列。这种操作称为投影查询。例如，从students表中返回id、score和name这三列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.52.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。</p><p>使用SELECT 列1, 列2, 列3 FROM …时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM …。</p><p>例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%888.53.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>投影查询同样可以接WHERE条件，实现复杂的查询。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上ORDER BY子句。例如按照成绩从低到高进行排序：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.04.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.04.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。</p><p>如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.06.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT <m> OFFSET <n>子句实现。我们先把所有学生按照成绩从高到低进行排序，把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.10.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：类似的，查询第3页的时候，OFFSET应该设定为6:由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”。</n></m></p><p>OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。<br>OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。</p><p>在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。使用LIMIT <m> OFFSET <n>分页时，随着N越来越大，查询效率也会越来越低。</n></m></p><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.16.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>COUNT( <em> )表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT( </em> )。</p><p>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.16.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>COUNT(*)和COUNT(id)实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.17.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>除了COUNT()函数外，SQL还提供了如下聚合函数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.19.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。</p><p>要统计男生的平均成绩，我们用下面的聚合查询：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.19.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而MAX()、MIN()、MAX()和MIN()会返回NULL。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.25.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。</p><p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.27.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.27.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>聚合查询的列中，只能放入分组的列。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.34.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.34.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM &lt;表1&gt; &lt;表2&gt;。</p><p>同时从students表和classes表的“乘积”，即查询数据，可以这么写：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.39.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。</p><p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。<strong>使用多表查询可以获取M x N行记录；多表查询的结果集可能非常巨大，要小心使用。</strong></p><p>查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理</p><p>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.41.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.43.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。</p><p>多表查询也是可以添加WHERE条件的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.44.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p><p>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。</p><p>连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-01%20%E4%B8%8B%E5%8D%889.48.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用FROM &lt;表1&gt;的语法；</li><li>再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；</li><li>然后确定连接条件，使用ON &lt;条件…&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；</li><li>可选：加上WHERE子句、ORDER BY等子句。</li></ol><p>使用别名不是必须的，但可以更好地简化查询语句。有内连接（INNER JOIN）就有外连接（OUTER JOIN）。</p><p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><p>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。</p><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</p><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一列，并添加class_id=5，由于classes表并不存在id=5的列，所以，LEFT OUTER JOIN的结果会增加一列，对应的class_name是NULL。</p><p>inner join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>left outer join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l%202.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>right outer join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l%203.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>full outer join<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/l%204.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p>插入数据基本语法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.54.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.54.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果一个字段有默认值，那么在INSERT语句中也可以不出现。</p><p>要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) …，但是对应的VALUES就得变成(80, ‘M’, ‘大牛’, 2)。</p><p>还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(…)包含的一组值：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.55.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>更新数据库表中的记录，我们就必须使用UPDATE语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.57.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>例如，我们想更新students表id=1的记录的name和score这两个字段，先写出UPDATE students SET name=’大牛’, score=66，然后在WHERE子句中写出需要更新的行的筛选条件id=1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.58.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.59.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8A%E5%8D%8811.59.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><strong>如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。要特别小心的是，UPDATE语句可以没有WHERE条件，这时，整个表的所有记录都会被更新。</strong></p><p><strong>所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。</strong></p><p>在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>删除数据库表中的记录，我们可以使用DELETE语句。<br>基本语法是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.03.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.04.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.04.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。<strong>要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据。</strong></p><p>整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。</p><p>在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。</p><h1 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h1><h2 id="插入或替换"><a href="#插入或替换" class="headerlink" title="插入或替换"></a>插入或替换</h2><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.12.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。</p><h2 id="插入或更新"><a href="#插入或更新" class="headerlink" title="插入或更新"></a>插入或更新</h2><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO … ON DUPLICATE KEY UPDATE …语句：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.12.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。</p><h2 id="插入或忽略"><a href="#插入或忽略" class="headerlink" title="插入或忽略"></a>插入或忽略</h2><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO …语句。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.16.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.18.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>新创建的表结构和SELECT使用的表结构完全一致。</p><h2 id="写入查询结果集"><a href="#写入查询结果集" class="headerlink" title="写入查询结果集"></a>写入查询结果集</h2><p>如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表statistics，记录各班的平均成绩：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.22.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以用一条语句写入各班的平均成绩：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.24.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.25.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<strong>事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p>数据库事务有ACID这4个特性。</p><ol><li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ol><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<strong>隐式事务</strong>。</p><p>要手动把多条SQL语句作为一个事务执行，使用<strong>BEGIN</strong>开启一个事务，使用<strong>COMMIT</strong>提交一个事务，这种事务被称为<strong>显式事务</strong>，例如，把上述的转账操作作为一个显式事务：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.28.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。</p><p><strong>COMMIT</strong>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<strong>COMMIT</strong>语句执行失败了，整个事务也会失败。</p><p>有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.31.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.34.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h2><p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.38.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>事务B两次读到的数据不一致。</p><h2 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h2><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>表中数据现在为Alice。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.43.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h2><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%BB%96%E9%9B%AA%E5%B3%B0SQL/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%8812.56.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。</p><p>Repeatable Read下在同一个事务内的查询都是与事务开始时刻一致，所以在B事务过程中是不会读到期间A中insert的值的。</p><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><h2 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h2><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;NoSQL数据库，也就是非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等，它们都不是关系数据库。有很多人鼓吹现代W
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="SQL" scheme="https://github.com/zdkswd/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Shell Scripts</title>
    <link href="https://github.com/zdkswd/2019/01/30/Shell%20Scripts/"/>
    <id>https://github.com/zdkswd/2019/01/30/Shell Scripts/</id>
    <published>2019-01-30T10:06:32.000Z</published>
    <updated>2019-01-30T10:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell-Scripts"><a href="#Shell-Scripts" class="headerlink" title="Shell Scripts"></a>Shell Scripts</h1><h2 id="什么是Shell-scripts"><a href="#什么是Shell-scripts" class="headerlink" title="什么是Shell scripts"></a>什么是Shell scripts</h2><p>shell script是利用shell的功能所写的一个程序，这个程序使用纯文本文件，将一些shell的语法与指令（含外部指令）写在里面，搭配正则表达式，管线命令与数据流重导向等功能，以达到我们所想要的处理目的。</p><h3 id="干嘛学习shell-scripts"><a href="#干嘛学习shell-scripts" class="headerlink" title="干嘛学习shell scripts"></a>干嘛学习shell scripts</h3><h4 id="自动化管理的重要依据"><a href="#自动化管理的重要依据" class="headerlink" title="自动化管理的重要依据"></a>自动化管理的重要依据</h4><h4 id="追踪与管理系统的重要工作"><a href="#追踪与管理系统的重要工作" class="headerlink" title="追踪与管理系统的重要工作"></a>追踪与管理系统的重要工作</h4><p>系统服务启动接口所在的目录下所有文件都是scripts，包括开机（booting）过程也都是利用shell script来帮忙搜寻系统的相关设置数据，然后再代入各个服务的设置参数。</p><h4 id="简单入侵侦测功能"><a href="#简单入侵侦测功能" class="headerlink" title="简单入侵侦测功能"></a>简单入侵侦测功能</h4><h4 id="连续指令单一化"><a href="#连续指令单一化" class="headerlink" title="连续指令单一化"></a>连续指令单一化</h4><h4 id="简易的数据处理"><a href="#简易的数据处理" class="headerlink" title="简易的数据处理"></a>简易的数据处理</h4><h4 id="跨平台支持与学习历程较短"><a href="#跨平台支持与学习历程较短" class="headerlink" title="跨平台支持与学习历程较短"></a>跨平台支持与学习历程较短</h4><h3 id="第一支script的撰写与执行"><a href="#第一支script的撰写与执行" class="headerlink" title="第一支script的撰写与执行"></a>第一支script的撰写与执行</h3><p>shell script其实就是纯文本文件，可以编辑这个文件，然后让这个文件一次执行多个指令。</p><ol><li>指令的执行是从上而下、从左而右的分析与执行。</li><li>指令、选项与参数间的多个空白都会被忽略掉。</li><li>空白行也将被忽略掉，并且[tab]按键所推开的空白同样视为空白键。</li><li>如果读取到一个Enter符号 (CR) ，就尝试开始执行该行 (或该串) 命令。</li><li>至于如果一行的内容太多，则可以使用“ [Enter]”来延伸至下一行。</li><li><h1 id="可做为注解-任何加在-后面的数据将全部被视为注解文字而被忽略"><a href="#可做为注解-任何加在-后面的数据将全部被视为注解文字而被忽略" class="headerlink" title="可做为注解!任何加在 # 后面的数据将全部被视为注解文字而被忽略!"></a>可做为注解!任何加在 # 后面的数据将全部被视为注解文字而被忽略!</h1></li></ol><p>假设编写好的文件名为shell.sh。执行方法有。</p><ol><li>直接指令下达：shell.sh文件必须具备可读与可执行（rx）的权限。无论如何到达shell.sh的目录，然后直接输入shell.sh就能执行。</li><li>以bash程序来执行，通过bash shell.sh或sh shell.sh来执行。</li></ol><h4 id="撰写第一支script"><a href="#撰写第一支script" class="headerlink" title="撰写第一支script"></a>撰写第一支script</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/Shell%20Scripts/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-30%20%E4%B8%8B%E5%8D%884.17.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>第一行# ! / bin / bash在宣告这个script使用的shell名称:因为我们使用的是bash，所以，必须要以“ # ! / bin / bash”来宣告这个文件内的语法使用bash的语法!那么当这个程序被执行时，他就能够载入bash的相关环境配置文件(一般来说就是non-login shell的~/.bashrc)，并且执行bash来使我们下面的指令能够执行!这很重要的! (在很多状况中，如果没有设置好这一行，那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么shell 来执行啊! )</li><li>程序内容的说明: 整个script当中，除了第一行的“ # !”是用来宣告shell的之外，其他的 # 都是“注解”用途! 所以上面的程序当中，第二行以下就是用来说明整个程序的基本数据。一般来说，建议你一定要养成说明该script的:1.内容与功能;2.版本信息; 3.作者与联络方式;4.创建日期;5.历史纪录等等。这将有助于未来程序的改写与debug。</li><li>执行成果告知(定义回传值)，可以利用exit这个指令来让程序中断，并且回传一个数值给系统。利用exit n（n是数字）的功能，可以自订错误讯息，让程序变得更加smart。</li></ol><h3 id="撰写shell-script的良好习惯创建"><a href="#撰写shell-script的良好习惯创建" class="headerlink" title="撰写shell script的良好习惯创建"></a>撰写shell script的良好习惯创建</h3><p>在每个script的文件开始处记录好：</p><ol><li>script的功能</li><li>script的版本信息</li><li>script的作者与联络方式</li><li>script的版权宣告方式</li><li>script的历史记录</li><li>script内教特殊的指令，使用绝对路径的方式来下达</li><li>script运行时需要的环境变量预先宣告与设置</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shell-Scripts&quot;&gt;&lt;a href=&quot;#Shell-Scripts&quot; class=&quot;headerlink&quot; title=&quot;Shell Scripts&quot;&gt;&lt;/a&gt;Shell Scripts&lt;/h1&gt;&lt;h2 id=&quot;什么是Shell-scripts&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH</title>
    <link href="https://github.com/zdkswd/2019/01/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/"/>
    <id>https://github.com/zdkswd/2019/01/28/认识与学习BASH/</id>
    <published>2019-01-28T12:55:32.000Z</published>
    <updated>2019-01-28T13:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识与学习BASH"><a href="#认识与学习BASH" class="headerlink" title="认识与学习BASH"></a>认识与学习BASH</h1><h2 id="认识BASH这个Shell"><a href="#认识BASH这个Shell" class="headerlink" title="认识BASH这个Shell"></a>认识BASH这个Shell</h2><h3 id="硬件，核心与Shell"><a href="#硬件，核心与Shell" class="headerlink" title="硬件，核心与Shell"></a>硬件，核心与Shell</h3><p>必须通过shell将我们输入指令与内核沟通，好让内核可以控制硬件来正确无误的工作。操作系统其实是一组软件，这组软件在控制整个硬件与管理系统的活动监测，操作系统管理的就是整个硬件功能。使用者通过应用程序来指挥内核让内核达成我们所需要的硬件任务。壳程序的功能知识提供使用者操作系统的一个接口，因此需要可以调用其他软件，就是很多其他的指令，我们可以通过壳程序（就是命令行界面）来操作这些应用程序，让这些应用程序调用核心来运行所需的工作。只要能够操作应用程序的接口都能称为壳程序，狭义的壳程序指的是命令行包括bash，广义的壳程序包括图形接口软件。</p><h3 id="为何要学命令行shell"><a href="#为何要学命令行shell" class="headerlink" title="为何要学命令行shell"></a>为何要学命令行shell</h3><h4 id="命令行shell：大家都一样"><a href="#命令行shell：大家都一样" class="headerlink" title="命令行shell：大家都一样"></a>命令行shell：大家都一样</h4><p>几乎各家distribution使用的bash都是一样的。</p><h4 id="远端管理：命令行就是比较快"><a href="#远端管理：命令行就是比较快" class="headerlink" title="远端管理：命令行就是比较快"></a>远端管理：命令行就是比较快</h4><p>Linux的管理常常需要通过远端连线，而连线时命令行的传速度一定比较快，而且不容易出现断线或者是信息外流的问题。</p><h4 id="Linux的任督二脉：shell"><a href="#Linux的任督二脉：shell" class="headerlink" title="Linux的任督二脉：shell"></a>Linux的任督二脉：shell</h4><h3 id="系统的合法shell与-etc-shells功能"><a href="#系统的合法shell与-etc-shells功能" class="headerlink" title="系统的合法shell与/etc/shells功能"></a>系统的合法shell与/etc/shells功能</h3><p>shell有众多版本，Linux的叫bash，也是基于GNU架构下发展出来的。shell还包括sh，csh。在/ etc / shells这个文件中至少就有几个可以用的shells。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8B%E5%8D%889.36.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们系统合法的shell要写入/ etc / shells这个文件，系统某些服务在运行过程中，会去检查使用者能够使用的shells，检查的文件就是 / etc / shells这个文件。</p><h3 id="Bash-shell的功能"><a href="#Bash-shell的功能" class="headerlink" title="Bash shell的功能"></a>Bash shell的功能</h3><p>bash是Linux distributions的标准shell。bash主要相容于sh。bash的主要优点：</p><h4 id="命令编修能力（history）"><a href="#命令编修能力（history）" class="headerlink" title="命令编修能力（history）"></a>命令编修能力（history）</h4><p>bash可以使用上下键找到前后一个输入的指令，在很多distribution中，默认的指令记忆功能可以达到1000个，指令记录放在主文件夹内的.bash_history中，不过~/ .bash_history记录的是前一次登录以前所执行的指令，这一次登录的指令都被暂存在内存中，当成功登出系统后，指令记忆才会记录到.bash_history中。</p><h4 id="命令与文件补全功能（【tab】键的好处）"><a href="#命令与文件补全功能（【tab】键的好处）" class="headerlink" title="命令与文件补全功能（【tab】键的好处）"></a>命令与文件补全功能（【tab】键的好处）</h4><h4 id="命令别名设置功能：（alias）"><a href="#命令别名设置功能：（alias）" class="headerlink" title="命令别名设置功能：（alias）"></a>命令别名设置功能：（alias）</h4><p>在命令行输入alias就可以知道目前的命令别名有哪些了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%888.52.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>就可以用alias来替代ls -al命令了。</p><h4 id="工作控制，前景背景控制（job-control-foreground-background）"><a href="#工作控制，前景背景控制（job-control-foreground-background）" class="headerlink" title="工作控制，前景背景控制（job control,foreground,background）"></a>工作控制，前景背景控制（job control,foreground,background）</h4><h4 id="程序化脚本（shell-scripts）"><a href="#程序化脚本（shell-scripts）" class="headerlink" title="程序化脚本（shell scripts）"></a>程序化脚本（shell scripts）</h4><p>将管理系统需要下达的连续指令写成一个文件，该文件可以通过对谈互动式的方式来进行主机的侦测工作，也可以借由shell提供的环境变量及相关指令来进行设计。</p><h4 id="万用字符（wildcard）"><a href="#万用字符（wildcard）" class="headerlink" title="万用字符（wildcard）"></a>万用字符（wildcard）</h4><p>bash还支持许多的万用字符来帮助使用者查询与指令下达，比如想知道有多少以X为开头的文件，就可使用 X * 来查看。</p><h3 id="查询指令是否是Bash-shell的内置命令：type"><a href="#查询指令是否是Bash-shell的内置命令：type" class="headerlink" title="查询指令是否是Bash shell的内置命令：type"></a>查询指令是否是Bash shell的内置命令：type</h3><p>通过type指令来知道指令是来自于外部指令（其他非bash所提供的指令）或是内置在bash当中的指令。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.14.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="指令的下达与快速编辑按钮"><a href="#指令的下达与快速编辑按钮" class="headerlink" title="指令的下达与快速编辑按钮"></a>指令的下达与快速编辑按钮</h3><p>使用反斜杠加回车键，可以进行多行的输入。</p><h2 id="Shell的变量功能"><a href="#Shell的变量功能" class="headerlink" title="Shell的变量功能"></a>Shell的变量功能</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><h4 id="变量的可变性与方便性"><a href="#变量的可变性与方便性" class="headerlink" title="变量的可变性与方便性"></a>变量的可变性与方便性</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.43.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>小写的mail是指令，大写的MAIL是变量名称。</p><h4 id="影响bash环境操作的变量"><a href="#影响bash环境操作的变量" class="headerlink" title="影响bash环境操作的变量"></a>影响bash环境操作的变量</h4><p>系统通过PATH这个变量里面的内容记录的路径顺序来搜寻指令。环境变量如PATH，HOME，MAIL，SHELL等等，都是很重要的，为了区别与自订变量的不同，环境变量通常以大写字符表示。</p><h4 id="脚本程序设计（shell-script）的好帮手"><a href="#脚本程序设计（shell-script）的好帮手" class="headerlink" title="脚本程序设计（shell script）的好帮手"></a>脚本程序设计（shell script）的好帮手</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.49.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="变量的取用与设置：echo，变量设置规则，unset"><a href="#变量的取用与设置：echo，变量设置规则，unset" class="headerlink" title="变量的取用与设置：echo，变量设置规则，unset"></a>变量的取用与设置：echo，变量设置规则，unset</h3><h4 id="变量的取用：echo"><a href="#变量的取用：echo" class="headerlink" title="变量的取用：echo"></a>变量的取用：echo</h4><p>变量前面要加上$符号才行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%889.59.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>设置和修改变量内容，用等号连接变量与他的内容就好了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.02.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当一个变量名称尚未被设置时，默认的内容是空，变量在设置时也要符合一些规则，否则设置失败。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.09.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.11.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>子程序就是在目前这个shell的情况下，去启用另一个新的shell，新的shell就是子程序，在一般状态下，父程序的自订变量是无法在子程序中使用的，但是通过export将变量变成环境变量后，就能够在子程序下面应用了。</p><h3 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h3><h4 id="用env观察环境变量与常见环境变量说明"><a href="#用env观察环境变量与常见环境变量说明" class="headerlink" title="用env观察环境变量与常见环境变量说明"></a>用env观察环境变量与常见环境变量说明</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.46.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>MAIL当我们使用mail这个指令收信时，系统会去读取的邮件信箱文件（mailbox）。</p><h4 id="用set观察所有变量（含环境变量与自订变量）"><a href="#用set观察所有变量（含环境变量与自订变量）" class="headerlink" title="用set观察所有变量（含环境变量与自订变量）"></a>用set观察所有变量（含环境变量与自订变量）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8810.51.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="影响显示结果的语系变量（locale）"><a href="#影响显示结果的语系变量（locale）" class="headerlink" title="影响显示结果的语系变量（locale）"></a>影响显示结果的语系变量（locale）</h3><p>利用locale指令查询Linux支持了多少语系。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.15.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.15.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="变量键盘读取，数组与声明：read，array，declare"><a href="#变量键盘读取，数组与声明：read，array，declare" class="headerlink" title="变量键盘读取，数组与声明：read，array，declare"></a>变量键盘读取，数组与声明：read，array，declare</h3><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>要读取来自键盘输入的变量，就是用read这个指令。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.23.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="declare，typeset"><a href="#declare，typeset" class="headerlink" title="declare，typeset"></a>declare，typeset</h4><p>declare与typeset是一样都是声明变量的类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.24.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>变量的默认类型是字符串，所以若是不指定变量类型，则1+2为一个字符串而不是计算式，bash环境中的数值计算默认最多能达到整数形态，所以1 / 3结果是0。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.29.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="array变量类型"><a href="#array变量类型" class="headerlink" title="array变量类型"></a>array变量类型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.31.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.30.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.31.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="与文件系统及程序的限制关系：ulimit"><a href="#与文件系统及程序的限制关系：ulimit" class="headerlink" title="与文件系统及程序的限制关系：ulimit"></a>与文件系统及程序的限制关系：ulimit</h3><p>由于Linux主机是多用户多任务操作系统，防止资源超过限制，bash可以限制使用者的某些系统资源，包括可以打开的文件数量，可以使用的CPU时间，可以使用的内存总量。用ulimit来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.34.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一般身份使用者如果以ulimit设置了-f的文件大小，那么只能继续减小文件的大小，不能增加文件的大小。</p><h3 id="变量内容的删除，取代与替换（optional）"><a href="#变量内容的删除，取代与替换（optional）" class="headerlink" title="变量内容的删除，取代与替换（optional）"></a>变量内容的删除，取代与替换（optional）</h3><h4 id="变量内容的删除与取代"><a href="#变量内容的删除与取代" class="headerlink" title="变量内容的删除与取代"></a>变量内容的删除与取代</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8A%E5%8D%8811.59.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%8812.03.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="变量的测试与内容替换"><a href="#变量的测试与内容替换" class="headerlink" title="变量的测试与内容替换"></a>变量的测试与内容替换</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%8812.06.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="headerlink" title="命令别名与历史命令"></a>命令别名与历史命令</h2><h3 id="命令别名设置：alias，unalias"><a href="#命令别名设置：alias，unalias" class="headerlink" title="命令别名设置：alias，unalias"></a>命令别名设置：alias，unalias</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.22.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="历史命令：history"><a href="#历史命令：history" class="headerlink" title="历史命令：history"></a>历史命令：history</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.24.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当以bash登陆Linux主机之后，系统会主动由主文件夹的~ / .bash_history读取以前曾经下过的指令，记录的条数与bash的HISTFILESIZE这个变量设置值有关。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.35.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Bash-Shell的操作环境"><a href="#Bash-Shell的操作环境" class="headerlink" title="Bash Shell的操作环境"></a>Bash Shell的操作环境</h2><h3 id="路径与指令搜寻顺序"><a href="#路径与指令搜寻顺序" class="headerlink" title="路径与指令搜寻顺序"></a>路径与指令搜寻顺序</h3><p>指令运行的顺序：</p><ol><li>以相对/ 绝对路径执行指令，例如/ bin / ls 或 . / ls。</li><li>由alias找到该指令来执行。</li><li>由bash内置的（builtin）指令来执行。</li><li>通过$PATH这个变量的顺序搜寻到的第一个指令来执行。</li></ol><h3 id="bash的进站与欢迎讯息：-etc-issue-etc-motd"><a href="#bash的进站与欢迎讯息：-etc-issue-etc-motd" class="headerlink" title="bash的进站与欢迎讯息：/ etc / issue,/ etc / motd"></a>bash的进站与欢迎讯息：/ etc / issue,/ etc / motd</h3><p>登陆时的提示字串。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.46.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>登陆后取得一些讯息，可以将讯息加入到/ etc / motd中，一定要root的身份才能修改。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%884.48.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="bash的环境配置文件"><a href="#bash的环境配置文件" class="headerlink" title="bash的环境配置文件"></a>bash的环境配置文件</h3><h4 id="login与non-login-shell"><a href="#login与non-login-shell" class="headerlink" title="login与non-login shell"></a>login与non-login shell</h4><p>区别在于取得bash用不用登陆（login）。这两个取得bash的情况中，读取的配置文件数据并不一致。<br>login shell会读取下列文件：</p><ol><li>/ etc / profile:这是系统整体的设置，最好不要修改这个文件。</li><li>~ / .bash_profile 或 ~ / .bash_login 或 ~ / .profile :属于使用者个人设置，要改自己的数据，就写入这里。</li></ol><p>non-login shell仅会读取：~ / .bashrc 而已。</p><h3 id="终端机的环境设置：stty，set"><a href="#终端机的环境设置：stty，set" class="headerlink" title="终端机的环境设置：stty，set"></a>终端机的环境设置：stty，set</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.26.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>bash默认组合键。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.27.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="万用字符与特殊符号"><a href="#万用字符与特殊符号" class="headerlink" title="万用字符与特殊符号"></a>万用字符与特殊符号</h3><p>万用字符：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.28.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>特殊符号：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.31.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h2><p>数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，给它传输到其他的地方，例如文件或者是设备，在Linux文字模式下很重要，尤其是如果想要将某些数据存储下来。</p><h3 id="什么是数据流重导向"><a href="#什么是数据流重导向" class="headerlink" title="什么是数据流重导向"></a>什么是数据流重导向</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%885.46.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="命令执行的判断依据：；，-amp-amp-，‖"><a href="#命令执行的判断依据：；，-amp-amp-，‖" class="headerlink" title="命令执行的判断依据：；，&amp;&amp;，‖"></a>命令执行的判断依据：；，&amp;&amp;，‖</h3><h2 id="管线命令（pipe）"><a href="#管线命令（pipe）" class="headerlink" title="管线命令（pipe）"></a>管线命令（pipe）</h2><p>管线命令使用的是“|”界定符号，管线命令与连续下达命令式不一样的。管线命令“|”仅能处理经由前面一个指令传来的正确信息，也就是standard output信息，对于stdandard error并没有直接处理的能力。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.06.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ol><li>管线命令仅会处理standard output，对于standard error output会予以忽略</li><li>管线命令必须能够接受来自前一个指令的数据成为standard input继续处理才行。</li></ol><h3 id="选取命令：cut，grep"><a href="#选取命令：cut，grep" class="headerlink" title="选取命令：cut，grep"></a>选取命令：cut，grep</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.11.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>cut主要用途是在于将同一行里面的数据进行分解。</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep是分析一行讯息，若当中有我们所需要的信息，就将该行拿出来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.17.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="排序命令：sort，wc，uniq"><a href="#排序命令：sort，wc，uniq" class="headerlink" title="排序命令：sort，wc，uniq"></a>排序命令：sort，wc，uniq</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.18.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>想要将重复的数据仅列出一个显示。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.21.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>wc指令可以帮我们计算输出讯息的整体数据。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.22.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="双向重导向：tee"><a href="#双向重导向：tee" class="headerlink" title="双向重导向：tee"></a>双向重导向：tee</h3><h3 id="字符转换命令：tr，col，join，paste，expand"><a href="#字符转换命令：tr，col，join，paste，expand" class="headerlink" title="字符转换命令：tr，col，join，paste，expand"></a>字符转换命令：tr，col，join，paste，expand</h3><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr可以用来删除一段讯息中文字，或者是进行文字讯息的替换。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.36.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.37.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>col键可以用来简单的处理将tab按键取代为空格键。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.42.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>相对于join要对比两个文件的数据相关性，paste就是直接将两行粘在一起，中间以tab隔开。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.45.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h4><h3 id="分区命令：split"><a href="#分区命令：split" class="headerlink" title="分区命令：split"></a>分区命令：split</h3><p>如果有文件太大，找split就对了，可以将一个大文件依据文件大小或行数来分区，就可以将大文件分区为小文件了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%20%E4%B8%8B%E5%8D%888.47.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="参数代换：xargs"><a href="#参数代换：xargs" class="headerlink" title="参数代换：xargs"></a>参数代换：xargs</h3><h3 id="关于减号-的用途"><a href="#关于减号-的用途" class="headerlink" title="关于减号-的用途"></a>关于减号-的用途</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识与学习BASH&quot;&gt;&lt;a href=&quot;#认识与学习BASH&quot; class=&quot;headerlink&quot; title=&quot;认识与学习BASH&quot;&gt;&lt;/a&gt;认识与学习BASH&lt;/h1&gt;&lt;h2 id=&quot;认识BASH这个Shell&quot;&gt;&lt;a href=&quot;#认识BASH这个Shel
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="https://github.com/zdkswd/2019/01/27/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://github.com/zdkswd/2019/01/27/vim程序编辑器/</id>
    <published>2019-01-27T02:19:32.000Z</published>
    <updated>2019-01-27T02:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim程序编辑器"><a href="#vim程序编辑器" class="headerlink" title="vim程序编辑器"></a>vim程序编辑器</h1><p>在所有的Linux distributions上都会有一套文书编辑器，即vi，vim是进阶版的vi，vim可以用不同颜色显示文字内容，还可以进行shell script，C program等程序编辑功能，可以将vim视为一种程序编辑器。</p><h2 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h2><p>在Linux的世界中，绝大部分的配置文件都是以ASCII的纯文本形态存在的，因此利用简单的文字编辑软件就能够修改设置了。</p><h3 id="为何要学vim"><a href="#为何要学vim" class="headerlink" title="为何要学vim"></a>为何要学vim</h3><ol><li>所有的Unⅸ Like系统都会内置ⅵ文书编辑器，其他的文书编辑器则不一定会存在。</li><li>很多个别软件的编辑借口都会主动调用vi</li><li>vim具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</li><li>因为程序简单，编辑速度相当快速。</li></ol><p>重点是第二点，因为有太多的Linux上面的指令都默认使用vi作为数据编辑的接口，所以必须一定要学会vi，否则很多指令根本无法操作。</p><p>简单来说vi是老式的文本处理器，不过功能已经很齐全了，但是还是有可以进步的地方，vim则可以说是程序开发者的一项很好用的工具。</p><h2 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h2><h3 id="一般指令模式（command-mode）"><a href="#一般指令模式（command-mode）" class="headerlink" title="一般指令模式（command mode）"></a>一般指令模式（command mode）</h3><p>以ⅵ打开一个文件就直接进入一般指令模式了(这是默认的模式，也简称为一般模式)。在这个模式中，可以使用“上下左右”按键来移动光标，可以使用“删除字符”或”删除整列”来处理文件内容,也可以使用“复制,粘贴”来处理你的文件数据。</p><h3 id="编辑模式（insert-mode）"><a href="#编辑模式（insert-mode）" class="headerlink" title="编辑模式（insert mode）"></a>编辑模式（insert mode）</h3><p>在一般指令模式中可以进行删除丶复制丶贴上等等的动作’但是却无法编辑文件内容的!要等到你按下i,l,o,O,a,A,r,R等任何一个字母之后才会进入编辑模式。注意了!通常在Linux中按下这些按键时,在画面的左下方会出现” INSERT或REPLACE”的字样,此时才可以进行编辑。而如釆要回到一般指令模式时，则必须要按下”Esc”这个按键即可退岀编辑模式。</p><h3 id="命令行命令模式（command-line-mode）"><a href="#命令行命令模式（command-line-mode）" class="headerlink" title="命令行命令模式（command-line mode）"></a>命令行命令模式（command-line mode）</h3><p>在一般模式中，输入：/?三个中的任何一个按钮，就可以将光标移动到最下面的那一列。在这个模式中可以提供你搜寻数据的动作，而读取、存盘、大量取代字符、离开vi、显示行号等等则是在此模式中达成的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.19.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="简易执行范例"><a href="#简易执行范例" class="headerlink" title="简易执行范例"></a>简易执行范例</h3><h4 id="使用vi-filename进入一般指令模式"><a href="#使用vi-filename进入一般指令模式" class="headerlink" title="使用vi filename进入一般指令模式"></a>使用vi filename进入一般指令模式</h4><h4 id="按下i进入编辑模式，开始编辑文字"><a href="#按下i进入编辑模式，开始编辑文字" class="headerlink" title="按下i进入编辑模式，开始编辑文字"></a>按下i进入编辑模式，开始编辑文字</h4><h4 id="按下esc按钮回到一般指令模式"><a href="#按下esc按钮回到一般指令模式" class="headerlink" title="按下esc按钮回到一般指令模式"></a>按下esc按钮回到一般指令模式</h4><h4 id="进入命令行界面，文件存储并离开vi环境"><a href="#进入命令行界面，文件存储并离开vi环境" class="headerlink" title="进入命令行界面，文件存储并离开vi环境"></a>进入命令行界面，文件存储并离开vi环境</h4><p>存盘（write）并离开（quit）的指令很简单，输入<strong>：wq</strong>（冒号要输入）即可存盘离开。（注意，按下后该光标就会移动到最后面一列）。如果文件权限不对，可能无法写入，此时可以使用强制写入，使用<strong>：wq！</strong>（冒号要输入）多加一个惊叹号。</p><h3 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h3><p>编辑模式与命令行界面之间并不能切换。</p><h4 id="一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代"><a href="#一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代" class="headerlink" title="一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代"></a>一般指令模式可用的按钮说明，光标移动，复制贴上，搜寻取代</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.56.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.57.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8A%E5%8D%8811.58.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="一般指令模式切换到编辑模式的可用的按钮说明"><a href="#一般指令模式切换到编辑模式的可用的按钮说明" class="headerlink" title="一般指令模式切换到编辑模式的可用的按钮说明"></a>一般指令模式切换到编辑模式的可用的按钮说明</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8B%E5%8D%8812.02.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="一般指令切换到命令行界面可用按钮说明"><a href="#一般指令切换到命令行界面可用按钮说明" class="headerlink" title="一般指令切换到命令行界面可用按钮说明"></a>一般指令切换到命令行界面可用按钮说明</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-26%20%E4%B8%8B%E5%8D%8812.04.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="vim的暂存盘，救援恢复与打开时的警告讯息"><a href="#vim的暂存盘，救援恢复与打开时的警告讯息" class="headerlink" title="vim的暂存盘，救援恢复与打开时的警告讯息"></a>vim的暂存盘，救援恢复与打开时的警告讯息</h3><p>vim是通过暂存盘来进行救援恢复的。当使用vim编辑时，vim会在同一目录下再创建一个名为.filename.swap的文件。对文件做的动作会被记录到swp当中，如果系统由于某些原因断掉，编辑的文件还没有储存，swp就能发挥救援作用。</p><h2 id="vim的额外功能"><a href="#vim的额外功能" class="headerlink" title="vim的额外功能"></a>vim的额外功能</h2><p>目前大部分的distribution都以vim取代vi了。vim还可以直接进行debug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debug和release的区别</span><br><span class="line">Debug：调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。</span><br><span class="line">Release：发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。</span><br></pre></td></tr></table></figure></p><h3 id="区块选择（Visual-Block）"><a href="#区块选择（Visual-Block）" class="headerlink" title="区块选择（Visual Block）"></a>区块选择（Visual Block）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.03.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><p>可以使用vim后面同时接好几个文件同时打开。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.04.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>利用多文件编辑的功能’可以让你很快速的就将需要的数据复制到正确的文件内。当然这个功能也可以利用窗口接口来达到，那就是多窗口功能。</p><h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><p>vim也可以实现分区窗口的功能。在命令行界面输入<strong>:sp {filename}</strong>即可，filename可有可无，如果想要在新窗口启动另一个文件，就加入文件名，否则仅输入<strong>:sp</strong>，出现的是同一个文件在两个窗口间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.25.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="vim的补全功能"><a href="#vim的补全功能" class="headerlink" title="vim的补全功能"></a>vim的补全功能</h3><p>程序编辑器都可以进行语法检验以及根据输入来挑字进行补全。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%888.29.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>先输入前者再输入后者。</p><h3 id="vim环境设置与记录：-vimrc，-viminfo"><a href="#vim环境设置与记录：-vimrc，-viminfo" class="headerlink" title="vim环境设置与记录： ~/.vimrc，~/.viminfo"></a>vim环境设置与记录： ~/.vimrc，~/.viminfo</h3><p>以vim软件来搜寻一个文件内部的字串时，字串会被反白。再次vim编辑这个文件时，泛白的情况还是存在的。当重复编辑同一个文件第二次进入该文件时，光标还在上次离开的那一列上头。这是因为vim会主动的将做过的行为记录下来，记录的文件就是：~/.viminfo，该文件是自动生成的，不必自行创建，在vim里所做过的动作都可以在这个文件内部查询到。vim的环境参数有很多，如果想要知道目前的设置值，可以在一般指令模式时输入<strong>：set all</strong>来查阅。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%889.02.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>每次使用vim都要重新设置一次各个参数值貌似不太合理，所以可以通过配置文件直接规定习惯的vim操作环境。整体的vim设置一般放在/ etc / vimrc 这个文件，不过不建议修改，可以修改 ~ / .vimrc这个文件（默认不存在，要手动创建）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%889.06.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="vim常用指令示意图"><a href="#vim常用指令示意图" class="headerlink" title="vim常用指令示意图"></a>vim常用指令示意图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-27%20%E4%B8%8A%E5%8D%889.07.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="vim使用注意事项"><a href="#vim使用注意事项" class="headerlink" title="vim使用注意事项"></a>vim使用注意事项</h2><h3 id="中文编码问题"><a href="#中文编码问题" class="headerlink" title="中文编码问题"></a>中文编码问题</h3><h3 id="DOS与Linux的断行字符"><a href="#DOS与Linux的断行字符" class="headerlink" title="DOS与Linux的断行字符"></a>DOS与Linux的断行字符</h3><h3 id="语系编码转换"><a href="#语系编码转换" class="headerlink" title="语系编码转换"></a>语系编码转换</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim程序编辑器&quot;&gt;&lt;a href=&quot;#vim程序编辑器&quot; class=&quot;headerlink&quot; title=&quot;vim程序编辑器&quot;&gt;&lt;/a&gt;vim程序编辑器&lt;/h1&gt;&lt;p&gt;在所有的Linux distributions上都会有一套文书编辑器，即vi，vim是进阶版
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥Linux Linux文件、目录与磁盘格式</title>
    <link href="https://github.com/zdkswd/2019/01/25/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2019/01/25/鸟哥Linux Linux文件、目录与磁盘格式/</id>
    <published>2019-01-25T08:27:32.000Z</published>
    <updated>2019-01-25T08:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-Linux文件权限与目录配置"><a href="#第五章-Linux文件权限与目录配置" class="headerlink" title="第五章 Linux文件权限与目录配置"></a>第五章 Linux文件权限与目录配置</h1><p>Linux最优秀的地方之一就在于他的多用户多任务环境。而为了让各个使用者具有较保密的文件数据，因此文件的权限管理就变的很重要了。Linux一般将文件可存取的身份分为三个类别，分别是owner\/ group \/ others，且三种身份各有read \/ write \/execute等权限。</p><h2 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h2><h3 id="文件拥有者"><a href="#文件拥有者" class="headerlink" title="文件拥有者"></a>文件拥有者</h3><p>Linux是个多用户多任务的系统，因此可能常常会有多人同时使用这部主机来进行工作。考虑到每个人的隐私权与喜好的工作环境，文件拥有者就相当重要。可以设置适当的权限，让一些隐私的文件只有自己才能访问。</p><h3 id="群组概念"><a href="#群组概念" class="headerlink" title="群组概念"></a>群组概念</h3><p>经由简易的文件权限设置，就能限制非自己团队（亦即群组）的其他人不能够阅览内容，也可以让自己团队成员可以修改我所创建的文件。同时自己还有私人隐密文件，仍然可以设置让自己团队成员也看不到自己的文件数据。</p><h3 id="其他人的概念"><a href="#其他人的概念" class="headerlink" title="其他人的概念"></a>其他人的概念</h3><p>就是不属于群组的其他人喽。</p><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>想访问谁就访问谁。</p><h3 id="Linux使用者身份与群组记录的文件"><a href="#Linux使用者身份与群组记录的文件" class="headerlink" title="Linux使用者身份与群组记录的文件"></a>Linux使用者身份与群组记录的文件</h3><p>在我们Linux系统当中，默认的情况下，所有的系统上的帐号与一般身份使用者，还有那个root的相关信息，都是记录在\/ etc\/ passwd这个文件内的。至于个人的密码则是记录在\/ etc \/ shadow这个文件下。此外，Linux所有的群组名称都纪录在\/ etc \/ group内!这三个文件可以说是Linux系统里面帐号、密码、群组信息的集中地。</p><h2 id="Linux文件权限概念"><a href="#Linux文件权限概念" class="headerlink" title="Linux文件权限概念"></a>Linux文件权限概念</h2><h3 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h3><p>先登录系统，使用su - 切换身份成为root，下达ls -al。 ls是list的意思，重点在显示文件的文件名与相关属性。选项“-al”则表示列出所有的文件详细的权限与属性（包含隐藏文件，就是第一个字符为“.”的文件）。不建议直接使用root登录系统，建议使用su - 来切换身份，离开su - 则使用exit回到登录时的身份即可。运行结果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%889.26.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%889.27.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="档案类型"><a href="#档案类型" class="headerlink" title="档案类型"></a>档案类型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%889.28.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="i-node"><a href="#i-node" class="headerlink" title="i-node"></a>i-node</h4><p>每个文件都会将他的权限与属性记录到文件系统的i-node中，我们使用的目录树是使用文件名来记录，因此每个文件名就会链接到一个i-node，这个属性记录的，就是有多少不同的文件名连接到同一个i-node号码。</p><h4 id="容量大小"><a href="#容量大小" class="headerlink" title="容量大小"></a>容量大小</h4><p>默认单位为Bytes。</p><h3 id="如何改变文件属性与权限"><a href="#如何改变文件属性与权限" class="headerlink" title="如何改变文件属性与权限"></a>如何改变文件属性与权限</h3><h4 id="改变所属群组，chgrp"><a href="#改变所属群组，chgrp" class="headerlink" title="改变所属群组，chgrp"></a>改变所属群组，chgrp</h4><p>要被改变的群组名称必须要在\/ etc \/group文件中存在才行，否则就会显示错误。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.30.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="改变文件拥有者，chown"><a href="#改变文件拥有者，chown" class="headerlink" title="改变文件拥有者，chown"></a>改变文件拥有者，chown</h4><p>使用者必须是已经存在系统中的账号，也就是在\/ etc \/ passwd这个文件中有记录的使用者名称才能改变。chown还可以顺便直接修改群组的名称，如果要连目录下的所有次目录或文件同时更改文件拥有者的话，直接加上-R选项即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.29.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于复制行为（cp）会复制执行者的属性和权限，把自己的文件复制给使用者，那他仍然无法修改。所以就有必要将这个文件的拥有者与群组修改一下。</p><h4 id="改变权限，chmod"><a href="#改变权限，chmod" class="headerlink" title="改变权限，chmod"></a>改变权限，chmod</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.37.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>等我们设置权限变更时，该文件的权限数字就是770啦，变更权限的指令chmod的语法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.38.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.39.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也可以使用符号类型改变文件权限。<br>user（u）具有可读、可写、可执行的权限。<br>group与others（g/o）具有可读与执行的权限。<br>a代表上面三个身份<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.50.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.48.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.52.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8A%E5%8D%8810.52.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="目录与文件之权限意义"><a href="#目录与文件之权限意义" class="headerlink" title="目录与文件之权限意义"></a>目录与文件之权限意义</h3><p>文件是实际含有数据的地方，包括一般文本文件、数据库内容档、二进制可执行文件(binary program)等等。因此，权限对于文件来说，他的意义是这样的:</p><ol><li>r(read):可读取此一文件的实际内容，如读取文本文件的文字内容。</li><li>w(write):可以编辑、新增或者是修改该文件的内容（但不含删除该文件);</li><li>x(eXecute):该文件具有可以被系统执行的权限。</li></ol><p>可执行x，在Windows下是借由扩展名来判断的，例如.exe,.bat,.com等等，但是在Linux下，我们的文件是否能被执行，则是由是否具有x这个权限来决定的，跟文件名没有绝对的关系。对一个文件具有w权限时，可以具有写入、编辑、新增、修改文件的内容的权限，但并不具备删除该文件本身的权限。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%881.38.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Linux文件种类与扩展名"><a href="#Linux文件种类与扩展名" class="headerlink" title="Linux文件种类与扩展名"></a>Linux文件种类与扩展名</h3><h4 id="正规文件（regular-file）"><a href="#正规文件（regular-file）" class="headerlink" title="正规文件（regular file）"></a>正规文件（regular file）</h4><p>第一个字符为【-】。又大略分为：</p><ol><li>纯文本文件（ASCII）</li><li>二进制档（binary）</li><li>数据格式文件（data）<h4 id="目录-directory"><a href="#目录-directory" class="headerlink" title="目录(directory)"></a>目录(directory)</h4>第一个属性为[d]。<h4 id="链接文件（link）"><a href="#链接文件（link）" class="headerlink" title="链接文件（link）"></a>链接文件（link）</h4>就是类似Windows系统下的捷径，第一个属性为[l]。<h4 id="设备与设备文件"><a href="#设备与设备文件" class="headerlink" title="设备与设备文件"></a>设备与设备文件</h4>与系统周边及存储相关的一些文件，通常都集中在/dev这个目录下。</li><li>区块（block）设备文件：就是一些储存数据，以提供系统随机存取的周边设备，比如硬盘,可查看/ dev / sda，会发现第一个属性为[b]。</li><li>字符(character)设备文件:即一些序列的周边设备，如键盘鼠标，特点是一次性读取不能够截断输出。如不可能让鼠标调到另一个画面，而是连续滑到另一个地方，第一个属性为[c]。</li><li>数据接口文件(sockets):这类文件通常被用在网络上的数据承接，我们可以启动一个程序来监听用户端的要求，而用户端就可以通过这个socket来进行数据的沟通了。第一个属性为【s】，最常在\/ run或\/ tmp这些目录中看到这种文件类型。</li><li>数据输送档(FIFO,pipe):FIFO也是一种特殊的文件类型，主要目的在解决多个程序同时存取一个文件所造成的错误问题。FIFO是first-in-first-out的缩写。第一个属性为[p]。</li></ol><p>Linux链接文件就可以简单的视为文件或目录的快捷方式。x只是代表这个文件具有可以执行的权限，并不一定能执行成功，还得看文件的内容。Linux系统的文件名只是了解该文件可能的用途而已，真正的执行与否仍需权限的规范才行。</p><p>Linux文件长度的限制。单一文件或目录最大容许文件名为255Bytes，以一个ASCII英文占用一个Bytes来说，则可达255个字符长度，若是以每个中文字2Bytes来说，最大文件名就是在128个中文字符。Linux文件是相当长的文件名，我们希望Linux文件名称可以一看就知道该文件在干嘛，所以文件名通常是很长很长。文件名最好可以避免一些特殊字符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%882.41.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h2><h3 id="Linux目录配置的依据—FHS"><a href="#Linux目录配置的依据—FHS" class="headerlink" title="Linux目录配置的依据—FHS"></a>Linux目录配置的依据—FHS</h3><p>Linux目录配置的标准Filesystem Hierachy Standard(FHS)。</p><p>根据FHS[2]的标准文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下，所以他们希望独立的软件开发商、操作系统制作者 、以及想要维护 系统的使用者，都能够遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%882.54.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上表右移。</p><p>FHS针对目录树架构仅定义了三层目录。</p><ol><li>\/ (root,根目录)：与开机系统有关。</li><li>\/ usr (unix software resource):与软件安装/ 执行有关。</li><li>/var(variable):与系统运行过程有关。<h4 id="根目录（-）的意义与内容"><a href="#根目录（-）的意义与内容" class="headerlink" title="根目录（/）的意义与内容"></a>根目录（/）的意义与内容</h4>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/ 还原 / 系统修复等动作有关。由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函数库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区内，因为越大的分区你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议:根目录所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但性能较佳，根目录所在的文件系统也较不容易发生问题。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.26.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.26.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="usr的意义与内容"><a href="#usr的意义与内容" class="headerlink" title="usr的意义与内容"></a>usr的意义与内容</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%882.58.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.41.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="var的意义与内容"><a href="#var的意义与内容" class="headerlink" title="var的意义与内容"></a>var的意义与内容</h4>如果_usr是安装时会占用较大硬盘容量的目录，那么_var就是在系统运行后才会渐渐占用硬盘容量的目录。因为Ivar目录主要针对常态性变动的文件，包括高速缓存 (cache)、登录文件(log file)以及某些软件运行所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%886.44.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.01.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.01.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Linux文件与目录管理"><a href="#Linux文件与目录管理" class="headerlink" title="Linux文件与目录管理"></a>Linux文件与目录管理</h1><h2 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h2><h3 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.20.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="cd（change-directory-变换目录）"><a href="#cd（change-directory-变换目录）" class="headerlink" title="cd（change directory,变换目录）"></a>cd（change directory,变换目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.22.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="pwd（显示目前所在的目录）"><a href="#pwd（显示目前所在的目录）" class="headerlink" title="pwd（显示目前所在的目录）"></a>pwd（显示目前所在的目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.33.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><strong>pwd是Print Working Directory的缩写，也就是显示目前所在目录的指令。</strong><h4 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir(创建新目录)"></a>mkdir(创建新目录)</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.36.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="rmdir（删除“空”的目录）"><a href="#rmdir（删除“空”的目录）" class="headerlink" title="rmdir（删除“空”的目录）"></a>rmdir（删除“空”的目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.48.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>如果想要删除旧有的目录时，就使用rmdir，例如将刚刚创建的test杀掉，使用“rmdir test”即可。<strong>目录需要一层一层的删除才行，而且被删除的目录里面必定不能存在其他的目录或文件!这也是所谓的空的目录(empty directory)的意思</strong>。如果要将所有目录下的东西都杀掉，这个时候就必须使用“rm -r test”。不过，还是使用rmdir比较不危险，你也可以尝试以-p的选项加入，来删除上层的目录。<h3 id="关于可执行文件路径的变量：-PATH"><a href="#关于可执行文件路径的变量：-PATH" class="headerlink" title="关于可执行文件路径的变量：$PATH"></a>关于可执行文件路径的变量：$PATH</h3>当我们在执行一个指令的时候，如”Is”，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为Is的可可执行文件，如果在PATH定义的目 录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行。</li></ol><p>echo有显示、印出的意思，而PATH前面的$表示后面接的是变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-21%20%E4%B8%8B%E5%8D%887.58.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>PATH(一定是大写)这个变量的内容是由一堆目录所组成的，每个目录中由冒号来隔开，每个目录是有顺序之分的。</p><ol><li>不同身份使用者默认的PATH不同，默认能够随意执行的指令也不同（如root与dmtsai）；</li><li>PATH是可以修改的；</li><li>使用绝对路径或是相对路径直接指定某个指令的文件名来执行会比搜寻PATH来的正确；</li><li>指令应该放置到正确的目录下执行才会比较方便；</li><li>本目录（.）最好不要放到PATH中。</li></ol><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="文件与目录的检视-ls"><a href="#文件与目录的检视-ls" class="headerlink" title="文件与目录的检视 ls"></a>文件与目录的检视 ls</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%888.34.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%888.54.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="复制，删除与移动：cp-rm-mv"><a href="#复制，删除与移动：cp-rm-mv" class="headerlink" title="复制，删除与移动：cp,rm,mv"></a>复制，删除与移动：cp,rm,mv</h3><h4 id="cp（复制文件或目录）"><a href="#cp（复制文件或目录）" class="headerlink" title="cp（复制文件或目录）"></a>cp（复制文件或目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%888.58.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>复制（cp）这个指令是非常重要的，不同身份者执行这个指令会有不同的结果产生，尤其是-a-p选项对于不同身份差别非常大。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.05.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在默认中，cp的来源文件与目的文件的权限是不同的，目的文件的拥有者通常会是指令操作者本身。由于这个特性，我们在进行备份时，某些需要特别注意的特殊权限文件，例如密码档以及配置文件就不能直接以cp复制，而必须加-a<br>或者是-p等等可以完整复制文件权限的选项才行。如果想要复制文件给其他的使用者，也必须要注意到文件的权限（包含读写执行以及文件拥有者等等）否则其他人还是无法针对你给予的文件进行修订动作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.22.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>-l -s都会创建所谓的链接文件（link file）,但是这两种链接文件却有不一样的情况， -s是符号链接， -l是实体链接。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.28.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在复制时，需要清楚的了解到</p><ol><li>是否完整的保留来源文件信息</li><li>来源文件是否为链接文件</li><li>来源文件是否为特殊文件，例如FIFO，socket</li><li>来源文件是否为目录</li></ol><h4 id="rm（移除文件或目录）"><a href="#rm（移除文件或目录）" class="headerlink" title="rm（移除文件或目录）"></a>rm（移除文件或目录）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.41.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是移除的指令(remove) ， 要注意的是，通常在Linux系统下，为了怕文件被root误杀，所以很多distributions都已经默认加入i这个选项了!而如果要连目录下的东西都一起杀掉的话，例如子目录里面还有子目录时，那就要使用一这个选项了!不过，使用”rm-r”这个指令之前，请千万注意了，因为该目录或文件“肯定”会被root杀掉!因为系统不会再次询问你是否要砍掉呦!所以那是个超级严重的指令下达呦!得特别注意!不过，如果你确定该目录不要了，那么使用rm-r来循环杀掉是不错的方式!</p><h4 id="mv（移动文件与目录，或更名）"><a href="#mv（移动文件与目录，或更名）" class="headerlink" title="mv（移动文件与目录，或更名）"></a>mv（移动文件与目录，或更名）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%889.47.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这是搬运（move）的意思，当要移动文件或目录时这个指令就很重要了，还有一个用途就是更改文件名，这是Linux才有的指令，还有个rename指令可以用来更改大量文件的文件名。</p><h3 id="取得路径的文件名称与目录名称"><a href="#取得路径的文件名称与目录名称" class="headerlink" title="取得路径的文件名称与目录名称"></a>取得路径的文件名称与目录名称</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.01.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>basename与dirname的用途。</p><h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><ol><li>cat由第一行开始显示文件内容</li><li>tac从最后一行开始显示，可以看出tac是cat的倒着写</li><li>nl显示的时候，顺便输出行号</li><li>more一页一页的显示文件内容</li><li>less与more类似，但是比more更好的是可以往前翻页</li><li>head只看头几行</li><li>tail只看尾巴几行</li><li>od以二进制的方式读取文件内容</li></ol><h3 id="直接检视文件内容"><a href="#直接检视文件内容" class="headerlink" title="直接检视文件内容"></a>直接检视文件内容</h3><h4 id="cat（concatenate）"><a href="#cat（concatenate）" class="headerlink" title="cat（concatenate）"></a>cat（concatenate）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.09.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="数据选择"><a href="#数据选择" class="headerlink" title="数据选择"></a>数据选择</h3><h4 id="head（取出前面几行）"><a href="#head（取出前面几行）" class="headerlink" title="head（取出前面几行）"></a>head（取出前面几行）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.23.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="tail（取出后面几行）"><a href="#tail（取出后面几行）" class="headerlink" title="tail（取出后面几行）"></a>tail（取出后面几行）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.25.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="非纯文本文件od"><a href="#非纯文本文件od" class="headerlink" title="非纯文本文件od"></a>非纯文本文件od</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.28.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="修改文件时间或创建新文件：touch"><a href="#修改文件时间或创建新文件：touch" class="headerlink" title="修改文件时间或创建新文件：touch"></a>修改文件时间或创建新文件：touch</h3><ol><li>modification time(mtime):当该文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限。</li><li>status time（ctime）：当该文件的状态改变时就会更新这个时间，比如权限与属性被改变了，就会更新这个时间。</li><li>access time（atime）：当该文件的内容被取用时就会更新这个读取时间。如使用cat去读取，就会更新该文件的atime。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8810.50.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><h3 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：umask</h3><p>umask就是指定目前使用者在创建文件或目录时候的权限默认值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8811.53.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h3><h4 id="chattr（设置文件隐藏属性）"><a href="#chattr（设置文件隐藏属性）" class="headerlink" title="chattr（设置文件隐藏属性）"></a>chattr（设置文件隐藏属性）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8A%E5%8D%8811.59.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这些指令是很重要的，尤其是在系统数据安全上面。</p><h4 id="lsattr（显示文件隐藏属性）"><a href="#lsattr（显示文件隐藏属性）" class="headerlink" title="lsattr（显示文件隐藏属性）"></a>lsattr（显示文件隐藏属性）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8812.00.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用chattr设置后，可以使用lsattr来查阅隐藏的属性。</p><h3 id="文件特殊权限：SUID，SGID，SBIT"><a href="#文件特殊权限：SUID，SGID，SBIT" class="headerlink" title="文件特殊权限：SUID，SGID，SBIT"></a>文件特殊权限：SUID，SGID，SBIT</h3><h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><p>当s这个标志出现在文件拥有者的x权限上时，如- rwsr - xr - x就称为Set UID，简称为SUID。SUID的限制与功能：</p><ol><li>SUID权限仅对二进制程序有效</li><li>执行者对于该程序需要有x的可执行权限</li><li>本权限仅在执行该程序的过程中有效</li><li>执行者将具有该程序拥有者的权限。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8810.35.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>SUID仅可以用在binary program上，不能用在shell script上，这是因为shell script知识将很多binary可执行文件加进来执行而已。所以SUID的权限部分，还是得看shell script调用进来的程序设置，SUID对于目录也是无效的。</p><h4 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h4><p>与SUID不同的是，SGID可以针对文件或目录来设置。对于文件，SGID有如下的功能：</p><ol><li>SGID对二进制程序有用</li><li>程序执行着对于该程序来说，需具备x的权限</li><li>执行者在执行的过程中将会获得该程序群组的支持!</li></ol><h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><p>SBIT目前只针对目录有效，对于文件已经没有效果了。SBIT对于目录的作用是：</p><ol><li>当使用者对于此目录具有w,x权限，亦即具有写入的权限时。</li><li>当使用者在该目录下创建文件或目录时，仅有自己与root才有权力删除该文件。</li></ol><h3 id="观察文件类型：file"><a href="#观察文件类型：file" class="headerlink" title="观察文件类型：file"></a>观察文件类型：file</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8810.46.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h2><h3 id="指令文件名的搜寻"><a href="#指令文件名的搜寻" class="headerlink" title="指令文件名的搜寻"></a>指令文件名的搜寻</h3><h4 id="which（寻找可执行文件）"><a href="#which（寻找可执行文件）" class="headerlink" title="which（寻找可执行文件）"></a>which（寻找可执行文件）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-23%20%E4%B8%8B%E5%8D%8810.53.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个指令是根据”PAT}这个环境变量所规范的路径’去搜寻“可执行文件”的文件名。</p><h3 id="文件文件名的搜寻"><a href="#文件文件名的搜寻" class="headerlink" title="文件文件名的搜寻"></a>文件文件名的搜寻</h3><h4 id="whereis（由一些特定的目录中寻找文件文件名）"><a href="#whereis（由一些特定的目录中寻找文件文件名）" class="headerlink" title="whereis（由一些特定的目录中寻找文件文件名）"></a>whereis（由一些特定的目录中寻找文件文件名）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.15.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>find是很强大的搜寻指令，但时间花费很大，因为find是直接搜寻硬盘。whereis只招几个特定的目录，并没有全系统去查询。whereis主要针对的是/ bin / sbin下面的可执行文件，以及/ usr / share / man下面的man page文件跟几个比较特定的目录来处理。</p><h4 id="locate、updatedb"><a href="#locate、updatedb" class="headerlink" title="locate、updatedb"></a>locate、updatedb</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.19.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用locate 来寻找数据的时候特别的快，这是因为locate寻找的数据是由“已创建的数据库/ var / lib / mlocate /  “里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据，当然是很快速的。但是有限制条件，他是由数据库来搜寻的，而数据库每天执行一次，若在数据库更新之前搜寻文件则搜寻不到。</p><h4 id="updatedb"><a href="#updatedb" class="headerlink" title="updatedb"></a>updatedb</h4><p>根据 / etc / updatedb.conf的设置去搜寻系统硬盘内的文件名，并更新/ rar / lib / mlocate内的数据库文件。</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>依据 / var / lib / mlocate内的数据库记载,找出使用者输入的关键字文件名。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.31.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.33.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8810.35.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Linux磁盘与文件系统管理"><a href="#Linux磁盘与文件系统管理" class="headerlink" title="Linux磁盘与文件系统管理"></a>Linux磁盘与文件系统管理</h1><h2 id="认识Linux文件系统"><a href="#认识Linux文件系统" class="headerlink" title="认识Linux文件系统"></a>认识Linux文件系统</h2><h3 id="磁盘组成与分区"><a href="#磁盘组成与分区" class="headerlink" title="磁盘组成与分区"></a>磁盘组成与分区</h3><h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><p>每种操作系统能够使用的文件系统并不相同。举例来说，windows 98以前的微软操作系统主要利用的文件系统是FAT (或FAT16) ， windows 2000以后的版本有所谓的NTFS文件系统，至于Linux的正统文件系统则为Ext2 (Linux second extended file system, ext2fs)这一个。此外，在默认的情况下,windows 操作系统是不会认识Linux的Ext2的。</p><p>文件系统是如何运行与操作系统的文件数据有关。较新的操作系统的文件数据<br>除了文件实际内容外，通常含有非常多的属性，例如Linux操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到inode中，至于实际数据则放置到data block区块中。另外，还有一个超级区块 (superblock)会记录整个文件系统的整体信息 ，包括inode与block的总量、使用量、剩余量等。</p><p>每个inode与block都有编号，至于这三个数据的意义可以简略说明如下:</p><ol><li>superblock :记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等;</li><li>inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码;</li><li>block :实际记录文件的内容，若文件太大时，会占用多个block。</li></ol><p>由于每个 inode与 block都有编号而每个文件都会占用一个 inode, inode内有文件数据置的 block号码。因此我们可以知道的是,如果能够找到文件的 inode的话那么自然会知道这个文件所放置数据的 block号码,当然也就能够读出该文件的实际数据了。这是个比较有效率的作法，因此我们的磁盘就能够在短时间内读取出全部的数据,读写的性能比较好。文件系统先格式化出inode与block的区块。inode中记录了4个区块的位置，此乃索引式文件系统。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8811.40.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还有一种文件系统比如FAT格式，就是我们惯用的U盘，这种格式是没有inode存在的所以是顺序读取的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8811.42.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="Linux的EXT2文件系统（inode）"><a href="#Linux的EXT2文件系统（inode）" class="headerlink" title="Linux的EXT2文件系统（inode）"></a>Linux的EXT2文件系统（inode）</h3><p>inode的内容在记录文件的权展与相关属性,至于bock区块则是在记录文件的实际内容。而且文件系统一开始就将 inode与 block规划好了,除非重新格式化<br>(或者利用 resize2is等指令变更文件系统大小),否则 inode与 block固定后就不再变动但是如果仔细考虑一下,如果我的文件系统高达数百GB时,那么将所有的 inode与 block通通放置在一起将是很不智的决定,因为 inode与 block的数量太庞大,不容易管理。</p><p>为此Ext2文件系统在格式化的时候基本上是区分为多个区块群组，每个区块群组都有独立的inode，block，superblock系统。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8A%E5%8D%8811.56.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在整体的规划当中，文件系统最前面有一个开机扇区 ( boot sector)，这个开机扇区可以安装开机管理程序，这是个非常重要的设计，因为如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗磁盘唯一的MBR，这样也才能够制作出多重开机的环境啊。</p><h4 id="data-block-数据区块"><a href="#data-block-数据区块" class="headerlink" title="data block(数据区块)"></a>data block(数据区块)</h4><p>由于block大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大但以文件大小并不相同。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8B%E5%8D%8812.00.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>block基本限制如下：</p><ol><li>原则上，block的大小与数量在格式化完就不能再改变了（除非重新格式化）</li><li>每个block内最多只能够放置一个文件的数据;</li><li>承上，如果文件大于block的大小，则一个文件会占用多个block数量;</li><li>承上，若文件小于block ，则该block的剩余容量就不能够再被使用了(磁盘空间会浪费)</li></ol><p>block大小选择所造成的不同问题。选在大的block在存取大量小文件时可能造成浪费。选小的block在存取大文件时索引的数量更多，可能导致文件系统不良的读写性能。事实上，现在的磁盘容量都太大了，所以大家都只会选在4K的block大小。</p><h4 id="inode-table（inode表格）"><a href="#inode-table（inode表格）" class="headerlink" title="inode table（inode表格）"></a>inode table（inode表格）</h4><p>inode记录的文件数据至少有下面这些：</p><ol><li>该文件的存取模式(read / write / excute)</li><li>该文件的拥有者与群组(owner / group)</li><li>该文件的容量。</li><li>该文件创建或状态改变的时间( ctime)</li><li>最近一次的读取时间( atime)</li><li>最近修改的时间( mtime)</li><li>定义文件特性的旗标(fag),如 SetUID</li><li>该文件真正内容的指向（pointer）</li></ol><p>inode的数量与大小也是在格式化时就已经固定了。</p><ol><li>每个 inode大小均固定为128 Bytes(新的ext4与xfs可设置到256 Bytes）；</li><li>每个文件都仅会占用一个 inode而已;</li><li>承上,因此文件系统能够创建的文件数量与 inode的数量有关;</li><li>系统读取文件时需要先找到 inode,并分析 inode所记录的权限与使用者是否符合,若符合才能够开始实际读取 block的内容。</li></ol><p>inode要记录的数据非常多，偏偏又只有128Bytes，而inode记录一个block要花掉4Byte，所以有一个巧妙的办法。将inode记录block号码的区域定义为12个直接1个间接一个双间接一个三间接记录区。直接就是直接可以通过号码来取得block，间接就是再拿一个block来当作记录block号码的记录区，如果文件太大，就会使用间接的block来记录号码。</p><h4 id="superblock（超级区块）"><a href="#superblock（超级区块）" class="headerlink" title="superblock（超级区块）"></a>superblock（超级区块）</h4><p>superblock是记录整个filesystem相关信息的地方，没有superblock就没有filesystem了。记录的信息有：</p><ol><li>block与inode的总量</li><li>未使用与已使用的inode，block数量</li><li>block与inode的大小</li><li>filesystem的挂载时间，最近一次写入数据的时间，最近一次检验磁盘的时间等文件系统的相关信息。</li><li>一个valid bit数值，若此文件系统已被挂载，则valid bit为0，若未被挂载，则valid bit为1。</li></ol><p>superblock是非常重要的，因为文件系统的基本信息都在，如果superblock死掉了，文件系统要花费很多时间去挽救。一般来说，superblock的大小为1024Bytes，一个文件系统应该仅有一个superblock，除了第一个block group内会含有superblock后续的block group不一定含有superblock。若含有superblock也是为第一个block group内的superblock做备份。</p><h4 id="Filesystem-Description-文件系统描述说明"><a href="#Filesystem-Description-文件系统描述说明" class="headerlink" title="Filesystem Description(文件系统描述说明)"></a>Filesystem Description(文件系统描述说明)</h4><p>这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段(superblock, bitmap, inodemap, data block) 分别介于哪一个block号码之间。</p><h4 id="block-bitmap（区块对照表）"><a href="#block-bitmap（区块对照表）" class="headerlink" title="block bitmap（区块对照表）"></a>block bitmap（区块对照表）</h4><p>记录使用与未使用block的号码。</p><h4 id="inode-bitmap（inode对照表）"><a href="#inode-bitmap（inode对照表）" class="headerlink" title="inode bitmap（inode对照表）"></a>inode bitmap（inode对照表）</h4><p>inode bitmap则是记录使用与未使用的inode号码。</p><h4 id="dumpe2fs"><a href="#dumpe2fs" class="headerlink" title="dumpe2fs"></a>dumpe2fs</h4><h3 id="与目录树的关系"><a href="#与目录树的关系" class="headerlink" title="与目录树的关系"></a>与目录树的关系</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>在Linux下的文件系统创建一个目录，文件系统会分配一个inode与至少一块block给该目录。其中inode与至少一块block给该目录。其中inode记录该目录的相关权限与属性，并可记录分配到的那块block号码。而block则是记录在这个目录下的文件名与该文件名占用的inode号码数据。也就是说目录所占用的block内容在记录如下的信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-24%20%E4%B8%8B%E5%8D%886.32.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在目录下面的文件数如果太多而导致一个block无法容纳的下所有的文件名与inode对照表，Linux会给予该目录多一个block来继续记录相关的数据。</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h4 id="目录树读取"><a href="#目录树读取" class="headerlink" title="目录树读取"></a>目录树读取</h4><p>inode本身并不记录文件名，文件名的记录是在目录的block当中。当我们要读取某个文件时，就务必会经过目录的inode与block然后才能找到那个待读取文件的inode号码，最终才会督导正确的文件的block内的数据。</p><p>由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的inode号码，挂载点实际上就是linux中的磁盘文件系统的入口目录。此时就能够得到根目录的inode内容，并依据该inode读取根目录的block内的文件名数据，再一层一层的往下读到正确的文件名。比如读取/ etc / passwd这个文件时的过程。</p><ol><li>/ 的inode :通过挂载点的信息找到inode号码为128的根目录inode，且inode规范的权限让我们可以读取该block的内容(有r与x)。</li><li>/ 的block: 经过上个步骤取得block的号码，并找到该内容有etc/ 目录的inode号码( 33595521)。</li><li>etc/ 的inode :读取33595521号inode得知dmtsai具有r与x的权限，因此可以读取etc/ 的block内容;</li><li>etc/ 的block :经过上个步骤取得block号码，并找到该内容有passwd文件的inode号码 ( 36628004)</li><li>passwd的inode : 读取36628004号inode得知dmtsai具有r的权限，因此可以读取passwd的block内容;</li><li>passwd的block :最后将该block内容的数据读出来。</li></ol><h3 id="EXT2-EXT3-EXT4文件的存取与日志式文件系统的功能"><a href="#EXT2-EXT3-EXT4文件的存取与日志式文件系统的功能" class="headerlink" title="EXT2/ EXT3/ EXT4文件的存取与日志式文件系统的功能"></a>EXT2/ EXT3/ EXT4文件的存取与日志式文件系统的功能</h3><p>若是想要新增一个文件，文件系统的行为是。</p><ol><li>先确定使用者对于欲新增文件的目录是否具有w与x的权限，若有的话才能新增;</li><li>根据inode bitmap找到没有使用的inode号码，并将新文件的权限/ 属性写入。</li><li>根据block bitmap找到没有使用中的block号码，并将实际的数据写入block中，且更新inode的block指向数据;</li><li>将刚刚写入的inode与block数据同步更新inode bitmap与block bitmap，并更新superblock的内容。</li></ol><p>一般来说，我们将inode table与data block称为数据存放区域，至于其他例如superblock、block bitmap与inode bitmap等区段就被称为metadata (中介数据)，因为superblock,inode bitmap及block bitmap的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据，因此才被称为中介数据的啦。</p><h4 id="数据的不一致（inconsistent）状态"><a href="#数据的不一致（inconsistent）状态" class="headerlink" title="数据的不一致（inconsistent）状态"></a>数据的不一致（inconsistent）状态</h4><p>由于不知名的原因可能导致metadata的内容与实际数据存放区产生不一致（inconsistent）的情况。传统的解决方法会在开机时皆有superblock当中记录的valid bit与filesystem state等状态来判断是否强制进行数据一致性的检查。这样的检查是很费时的。非常麻烦，造成了后来日志式文件系统的兴起。</p><h4 id="日志式文件系统（Journaling-filesystem）"><a href="#日志式文件系统（Journaling-filesystem）" class="headerlink" title="日志式文件系统（Journaling filesystem）"></a>日志式文件系统（Journaling filesystem）</h4><p>为了避免文件系统不一致的发生，在filesystem中规划一个区块，该区块专门记录写入或修订文件的步骤，就可以简化一致性检查的步骤。</p><ol><li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息;</li><li>实际写入：开始写入文件的权限与数据，开始更新metadata的数据。</li><li>结束：完成数据与metadata的更新后，在日志记录块当中完成该文件的记录。</li></ol><p>万一数据的纪录过程当中发生了问题，那么我们的系统只要去检查日志记录区块，就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块filesystem去检查，这样就可以达到快速修复filesystem的能力。</p><h3 id="Linux文件系统的运行"><a href="#Linux文件系统的运行" class="headerlink" title="Linux文件系统的运行"></a>Linux文件系统的运行</h3><p>编辑一个好大的文件，在编辑的过程中又频繁的要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多， 因此你会常常耗在等待磁盘的写入/读取上，很没效率。为解决效率问题，Linux使用的方式是通过一个非同步处理（asynchronously）的方式。</p><p>当系统载入一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被设置为干净(clean) 的。但如果内存中的文件数据被更改过了(例如你用nano去编辑过这个文件)，此时该内存中的数据会被设置为脏的 (Dirty) 。此时所有的动作都还在内存中执行，并没有写入到磁盘中!系统会不定时的将内存中设置为”Dirty”的数据写回磁盘，以保持磁盘与内存数据的一致性。</p><p>内存的速度要比磁盘快的多,因此如果能够将常用的文件放置到内存当中，就会增加系统性能。因此我们Linux系统上面文件系统与内存有非常大的关系。</p><ol><li>系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读/ 写;</li><li>承上，因此Linux的实体内存最后都会被用光!这是正常的情况!可加速系统性能;</li><li>可以手动使用sync来强迫内存中设置为Dirty的文件回写到磁盘中;</li><li>若正常关机时，关机指令会主动调用sync来将内存的数据回写入磁盘内;</li><li>但若不正常关机(如跳电、死机或其他不明原因)，由于数据尚未回写到磁盘内, 因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁(非磁盘损毁)。</li></ol><h3 id="挂载点的意义（mount-point）"><a href="#挂载点的意义（mount-point）" class="headerlink" title="挂载点的意义（mount point）"></a>挂载点的意义（mount point）</h3><p>将文件系统与目录树结合的动作我们称为<strong>挂载</strong>。重点是挂载点一定是目录，该目录为进入该文件系统的入口，因此并不是有任何文件系统都能使用的，必须挂载到目录树的某个目录后，才能够使用该文件系统。</p><h3 id="其他Linux支持的文件系统与VFS"><a href="#其他Linux支持的文件系统与VFS" class="headerlink" title="其他Linux支持的文件系统与VFS"></a>其他Linux支持的文件系统与VFS</h3><p>Linux的标准文件系统是ext2，且还有增加了日志功能的ext3/ext4，事实上，Linux还有支持很多文件系统格式的，尤其是最近这几年推出了好几种速度很快的日志式文件系统，包括SGI的XFS文件系统， 可以适用更小型文件的Reiserfs 文件系统，以及Windows的FAT文件系统等等，都能够被Linux所支持。</p><h4 id="Linux-VFS（Virtual-Filesystem-Switch）"><a href="#Linux-VFS（Virtual-Filesystem-Switch）" class="headerlink" title="Linux VFS（Virtual Filesystem Switch）"></a>Linux VFS（Virtual Filesystem Switch）</h4><p>Linux的系统都是通过一个名为Virtual Filesystem Switch 的核心功能去读取filesystem的。也就是说， 整个Linux 认识的filesystem 其实都是VFS在进行<br>管理，我们使用者并不需要知道每个partition上头的filesystem是什么。VFS会主动的帮我们做好读取的动作。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8A%E5%8D%889.46.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="XFS文件系统简介"><a href="#XFS文件系统简介" class="headerlink" title="XFS文件系统简介"></a>XFS文件系统简介</h3><p>EXT家族当前较伤脑筋的地方：支持度最广，但格式化超慢。基本上xfs就是一个日志式文件系统。xfs文件系统在数据的分布上主要规划为三个部分，一个是数据区，一个文件系统活动登录区，以及一个实时运行区。</p><h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><h3 id="磁盘与目录的容量"><a href="#磁盘与目录的容量" class="headerlink" title="磁盘与目录的容量"></a>磁盘与目录的容量</h3><h4 id="df-列出文件系统的整体磁盘使用量"><a href="#df-列出文件系统的整体磁盘使用量" class="headerlink" title="df:列出文件系统的整体磁盘使用量"></a>df:列出文件系统的整体磁盘使用量</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8A%E5%8D%8810.30.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>Filesystem：代表该文件系统是在哪个partition，所以列出设备名称。</li><li>1k-blocks :说明下面的数字单位是1KB，可利用-h或-m来改变容量。</li><li>Used:顾名思义，就是使用掉的磁盘空间。</li><li>Available :也就是剩下的磁盘空间大小。</li><li>Use% :就是磁盘的使用率。</li><li>Mounted on：就是磁盘挂载的目录所在（挂载点）。</li></ol><p>由于df主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在Superblock内的信息，所以这个指令显示结果的速度非常的快速。</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%881.45.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>与df不一样的是，du这个指令其实会到文件系统去搜寻所有的文件数据，所以上述指令运行会执行一小段时间。</p><h3 id="实体链接与符号链接：ln"><a href="#实体链接与符号链接：ln" class="headerlink" title="实体链接与符号链接：ln"></a>实体链接与符号链接：ln</h3><h4 id="Hard-Link（实体链接，硬式链接或实际链接）"><a href="#Hard-Link（实体链接，硬式链接或实际链接）" class="headerlink" title="Hard Link（实体链接，硬式链接或实际链接）"></a>Hard Link（实体链接，硬式链接或实际链接）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.02.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>hard link只是在某个目录下新增一笔文件名链接到某inode号码的关联记录而已。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%881.55.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>hard link的限制：</p><ol><li>不能跨Filesystem。</li><li>不能link目录。链接到目录时，链接的数据需要连同被链接目录下面的所有数据都创建链接。</li></ol><h4 id="Sysbolic-Link（符号链接，亦是捷径）"><a href="#Sysbolic-Link（符号链接，亦是捷径）" class="headerlink" title="Sysbolic Link（符号链接，亦是捷径）"></a>Sysbolic Link（符号链接，亦是捷径）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.03.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Sysbolic link就是在创建一个独立的文件，而这个文件会让数据的读取指向他link的那个文件的文件名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.04.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>hard link比较安全。但hard link的限制太多了，包括无法做目录的link，用途上还是比较受限的，反而是Symbolic Link的使用较广。</p><p>删除动作，如删除/ etc / crontab文件，删除动作只是将 / etc目录下关于crontab的关连数据拿掉而已，crontab所在的inode与block其实都没有被变动。</p><h2 id="磁盘的分区，格式化，检验与挂载"><a href="#磁盘的分区，格式化，检验与挂载" class="headerlink" title="磁盘的分区，格式化，检验与挂载"></a>磁盘的分区，格式化，检验与挂载</h2><p>若是想在系统中新增一个磁盘，需要：</p><ol><li>对磁盘进行分区，以创建可用的partition。</li><li>对该partition进行格式化 (format)， 以创建系统可用的filesystem</li><li>若想要仔细一点，则可对刚刚创建好的filesystem进行检验。</li><li>在Linux系统上，需要创建挂载点 (亦即是目录) ，并将他挂载上来。</li></ol><h3 id="观察磁盘分区状态"><a href="#观察磁盘分区状态" class="headerlink" title="观察磁盘分区状态"></a>观察磁盘分区状态</h3><h4 id="lsblk列出系统上所有磁盘列表"><a href="#lsblk列出系统上所有磁盘列表" class="headerlink" title="lsblk列出系统上所有磁盘列表"></a>lsblk列出系统上所有磁盘列表</h4><p>Isblk可以看成” list block device”的缩写， 就是列出所有储存设备的意思。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.23.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="blikid列出设备的UUID等参数"><a href="#blikid列出设备的UUID等参数" class="headerlink" title="blikid列出设备的UUID等参数"></a>blikid列出设备的UUID等参数</h4><p>UUID是全域单一识别码（universally unique identifier），Linux会将系统内所有设备都给予一个独一无二的识别码。这个识别码就可以拿来作为挂载或是使用这个设备、文件系统之用了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.24.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="parted列出磁盘的分区表类型与分区信息"><a href="#parted列出磁盘的分区表类型与分区信息" class="headerlink" title="parted列出磁盘的分区表类型与分区信息"></a>parted列出磁盘的分区表类型与分区信息</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%882.28.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="磁盘分区：gdisk-fdisk"><a href="#磁盘分区：gdisk-fdisk" class="headerlink" title="磁盘分区：gdisk/ fdisk"></a>磁盘分区：gdisk/ fdisk</h3><h4 id="用gdisk新增分区"><a href="#用gdisk新增分区" class="headerlink" title="用gdisk新增分区"></a>用gdisk新增分区</h4><h4 id="partprobe更新Linux核心的分区表信息"><a href="#partprobe更新Linux核心的分区表信息" class="headerlink" title="partprobe更新Linux核心的分区表信息"></a>partprobe更新Linux核心的分区表信息</h4><h4 id="用gdisk删除一个分区"><a href="#用gdisk删除一个分区" class="headerlink" title="用gdisk删除一个分区"></a>用gdisk删除一个分区</h4><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><h3 id="文件系统挂载与卸载"><a href="#文件系统挂载与卸载" class="headerlink" title="文件系统挂载与卸载"></a>文件系统挂载与卸载</h3><h3 id="磁盘、文件系统参数修订"><a href="#磁盘、文件系统参数修订" class="headerlink" title="磁盘、文件系统参数修订"></a>磁盘、文件系统参数修订</h3><h4 id="mknod"><a href="#mknod" class="headerlink" title="mknod"></a>mknod</h4><h4 id="xfs-admin修改XFS文件系统的UUID与Label-name"><a href="#xfs-admin修改XFS文件系统的UUID与Label-name" class="headerlink" title="xfs-admin修改XFS文件系统的UUID与Label name"></a>xfs-admin修改XFS文件系统的UUID与Label name</h4><h2 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h2><h3 id="开机挂载-etc-fstab及-etc-mtab"><a href="#开机挂载-etc-fstab及-etc-mtab" class="headerlink" title="开机挂载/etc/fstab及/etc/mtab"></a>开机挂载/etc/fstab及/etc/mtab</h3><h3 id="特殊设备loop挂载"><a href="#特殊设备loop挂载" class="headerlink" title="特殊设备loop挂载"></a>特殊设备loop挂载</h3><h2 id="内存交换空间（swap）之创建"><a href="#内存交换空间（swap）之创建" class="headerlink" title="内存交换空间（swap）之创建"></a>内存交换空间（swap）之创建</h2><p>如果硬件的配备资源足够的话’那么swap应该不会被我们的系统所使用到swaρ会被利用到的时刻通常就是实体内存不足的情况。目前在个人使用上内存已经足够大，不用设置swap也不会有太大的问题，但是服务器就不一定了，由于不知道何时会有大量来自网络的请求，因此最好还是能够预留一些swap来缓冲一下系统的内存用量。有备无患。</p><h3 id="使用实体分区创建swap"><a href="#使用实体分区创建swap" class="headerlink" title="使用实体分区创建swap"></a>使用实体分区创建swap</h3><ol><li>分区:先使用gdik在你的磁盘中分区出一个分区给系统作为swap。由于Linux的gdisk默认会将分区的ID设置为 Linux的文件系统，所以你可能还得要设置一下system ID就是了。</li><li>格式化∶利用创建swap格式的” mkswap设备文件名”就能够格式化该分区成为swap格式。</li><li>使用:最后将该swap设备启动,方法为:” swapon设备文件名”。</li><li>观察:最终通过free与 swapon-s这个指令来观察一下内存的用量。</li></ol><h3 id="使用文件创建swap"><a href="#使用文件创建swap" class="headerlink" title="使用文件创建swap"></a>使用文件创建swap</h3><h1 id="文件与文件系统的压缩，打包与备份"><a href="#文件与文件系统的压缩，打包与备份" class="headerlink" title="文件与文件系统的压缩，打包与备份"></a>文件与文件系统的压缩，打包与备份</h1><h2 id="压缩文件的用途与技术"><a href="#压缩文件的用途与技术" class="headerlink" title="压缩文件的用途与技术"></a>压缩文件的用途与技术</h2><h2 id="Linux系统常见的压缩指令"><a href="#Linux系统常见的压缩指令" class="headerlink" title="Linux系统常见的压缩指令"></a>Linux系统常见的压缩指令</h2><p>虽然Linux文件的属性基本上是与文件名没有绝对关系的，为了帮助人类，适当的扩展名还是必要的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%883.51.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%884.20.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="bzip2，bzcat-bzmore-bzless-bzgrep"><a href="#bzip2，bzcat-bzmore-bzless-bzgrep" class="headerlink" title="bzip2，bzcat,bzmore,bzless,bzgrep"></a>bzip2，bzcat,bzmore,bzless,bzgrep</h3><p>gzip是为了取代 compress并提供更好的压缩比而成立的,那么bzip2则是为了取代gzip并提供更佳的压缩比而来的。</p><h3 id="xz-xzcat-xzmore-xzless-xzgrep"><a href="#xz-xzcat-xzmore-xzless-xzgrep" class="headerlink" title="xz,xzcat,xzmore,xzless,xzgrep"></a>xz,xzcat,xzmore,xzless,xzgrep</h3><p>xz的压缩比好很多，但是xz最大的问题就是时间花太久了。运算时间要比gzip久很多。</p><h2 id="打包指令：tar"><a href="#打包指令：tar" class="headerlink" title="打包指令：tar"></a>打包指令：tar</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%20Linux%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E4%B8%8E%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-25%20%E4%B8%8B%E5%8D%884.24.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章-Linux文件权限与目录配置&quot;&gt;&lt;a href=&quot;#第五章-Linux文件权限与目录配置&quot; class=&quot;headerlink&quot; title=&quot;第五章 Linux文件权限与目录配置&quot;&gt;&lt;/a&gt;第五章 Linux文件权限与目录配置&lt;/h1&gt;&lt;p&gt;Linux最
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥Linux基础   Linux的规划与安装</title>
    <link href="https://github.com/zdkswd/2019/01/20/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://github.com/zdkswd/2019/01/20/鸟哥Linux基础   Linux的规划与安装/</id>
    <published>2019-01-20T12:25:32.000Z</published>
    <updated>2019-01-21T10:55:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第零章、计算机概论"><a href="#第零章、计算机概论" class="headerlink" title="第零章、计算机概论"></a>第零章、计算机概论</h1><p>CPU实际要处理的数据完全来自于内存（不管是程序还是一般文件数据）。<br>CPU架构<br>精简指令集RISC，如ARM架构。目前世界上使用范围最广的CPU就是ARM架构。<br>复杂指令集CISC。AMD，Intel x86。</p><h1 id="第一章、Linux是什么与如何学习"><a href="#第一章、Linux是什么与如何学习" class="headerlink" title="第一章、Linux是什么与如何学习"></a>第一章、Linux是什么与如何学习</h1><p>早期的Linux是针对386开发的。Linux提供了一个完整的操作系统当中最底层的硬件控制与资源管理的完整架构，这个架构是沿袭Unix良好的传统来的，所以相当的稳定而功能强大！</p><p>Linux参考了标准的POSIX规范。POSIX是可携式操作系统接口的缩写，重点在规范核心与应用程序之间的接口，这是由美国电器与电子工程师学会（IEEE）所发布的一项标准。</p><p>Linux其实就是一个操作系统最底层的核心及其提供的核心工具。它是GNU GPL授权模式，所以任何人均可取得源代码与可执行这个核心程序，并且可以修改。此外，因为Linux参考POSIX设计规范，于是相容于Unix操作系统，亦可称为Unix Like的一种。</p><p>Linux distributions就是Kernel+Softwares+Tools+可完整安装程序。一般称为可完整安装套件或Linux发布商套件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-18%20%E4%B8%8A%E5%8D%889.33.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>由于Linux核心是由工程师写得，由源代码安装到x86计算机上面成为可以执行的binary文件这个过程不是人人都会的，所以早期确实只有工程师对Linux感兴趣。一直到一些社群与商业公司将Linux核心配合自由软件，并提供完整的安装程序且制成光盘，对于一般人来说，Linux才越来越有吸引力。</p><p>每个distributions差异性并不大，主要是套件管理方式上的区分为dpkg和RPM。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-18%20%E4%B8%8A%E5%8D%889.42.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>到底是要买商业版还是社群版的Linux distribution呢?如果是要装在个人计算机上面做为桌面电脑用的， 建议使用社群版，包括Fedora, Ubuntu, OpenSuSE等等。如果是用在服务器上面的， 建议使用商业版本，包括Red Hat, SuSE等。这是因为社群版通常开发者会加入最新的软件，这些软件可能会有一些bug存在。至于商业版则是经过一段时间的磨合后，才将稳定的软件放进去。</p><p>Linux的运用场景<br>企业环境的利用：<br><strong>网络服务器:</strong><br>这是Linux当前最热门的应用了!承袭了Unix高稳定性的良好传统，Linux.上面的网络功能特别的稳定与强大!此外，由于GNU计划与Linux的GPL授权模式，让很多优秀的软件都在Linux上面发展，且这些在Linux上面的服务器软件几乎都是自由软件!因此，做为一部网络服务器，例如WWW, Mail Server, File Server等等， Linux绝对是上上之选!当然，这也是Linux的强项!由于Linux server的需求强烈，因此许多硬件厂商推出产品时，还得要特别说明有支持的Linux distributions呢!</p><p><strong>关键任务的应用（金融数据库、大型企业网管环境）</strong><br>由于个人计算机的性能大幅提升且价格便宜，所以金融业与大型企业的环境为了要精实自己机房的机器设备，因此很多企业渐渐的走向Intel相容的x86主机环境。而这些企业所使用的软件大多使用Unix操作系统平台的软件，总不能连过去发展的软件都一口气全部换掉吧!所以，这个时候符合Unix操作系统标准并且可以在x86.上运行的Linux就渐渐崭露头角了!</p><p><strong>学术机构的高性能运算任务：</strong><br>学术机构的研究常常需要自行开发软件，所以对于可作为开发环境的操作系统需求非常的迫切!举例来说，非常多技职体系的科技大学就很需要这方面的环境，好进行一些毕业专题的制作呢!又例如工程界流体力学的数值模式运算、娱乐事业的特效功能处理、软件开发者的工作平台等等。由于Linux的创造者本身就是个计算机性能癖，所以Linux有强大的运算能力;并且Linux具有支持度相当广泛的GCC编译软件，因此Linux在这方面的优势可是相当明显的!</p><p>个人使用：<br><strong>个人电脑：</strong><br>为了要强化桌面电脑的使用率，Linux与X Window System结合了!要注意的是，X Window System仅只是Linux上面的一套软件，而不是核心喔!所以即使X Window挂了，对Linux也可能不会有直接的影响。</p><p><strong>手持系统（PDA、手机）:</strong><br>Android就是Linux核心的一支，专门用来针对手机/平板这类ARM机器所设计的。</p><p><strong>嵌入式系统：</strong><br>包括路由器、防火墙、手机、IP分享器、交换器、机器人控制芯片、家电用品的微计算机控制器等等，都可以是Linux操作系统喔!</p><p>云端运用：<br><strong>云程序</strong><br><strong>端设备</strong></p><p>以服务器或者是嵌入式系统的应用来说，X Window是非必备的软件，因为服务器是要提供用户端来连线的，X Window通常会吃掉很多系统资源。</p><h1 id="第二章-主机规划与磁盘划分"><a href="#第二章-主机规划与磁盘划分" class="headerlink" title="第二章 主机规划与磁盘划分"></a>第二章 主机规划与磁盘划分</h1><p>并非所有的产品都会支持特定的操作系统，这牵涉到硬件开发商是否有意愿提供适当的驱动程序之故。因此，当我们想要购买或者是升级某些计算机元件时，应该要特别注意该硬件是否有针对您的操作系统提供适当的驱动程序，否则可能买了无法使用。</p><p>在Linux系统中，每个设备被当成一个文件来对待，几乎所有的硬件设备文件都在/dev这个目录内。</p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>整个磁盘的第一个扇区特别的重要，因为他记录了整个磁盘的重要信息。早期磁盘第一个扇区里面含有重要的信息称为MBR格式，但是由于磁盘的容量不断扩大，造成读写上的一些困扰，甚至有些大于2TB以上的磁盘分区已经让某些操作系统无法存取。因此后来又多了一个新的磁盘分区格式，称为GPT。</p><h3 id="MSDOS（MBR）与GPT"><a href="#MSDOS（MBR）与GPT" class="headerlink" title="MSDOS（MBR）与GPT"></a>MSDOS（MBR）与GPT</h3><p>MSDOS（MBR）分区表格式与限制：<br>早期的Linux系统为了相容于Windows的磁盘，因此使用的是支持Windows的<br>MBR (Master Boot Record,主要开机纪录区)的方式来处理开机管理程序与分区表!而开机管理程序纪录区与分区表则通通放在磁盘的第一个扇区，这个扇区通常是512Bytes的大小(旧的磁盘扇区都是512Bytes喔!)，所以说，第一个扇区512Bytes会有这两个数据:</p><ol><li>主要开机记录区（Masrer Boot Record,MBR）：可以安装开机管理程序的地方，有446Bytes</li><li>分区表（partition table）:记录整颗硬盘分区的状态，有64Bytes</li></ol><h3 id="Linux安装模式下，磁盘分区的选择（极重要）"><a href="#Linux安装模式下，磁盘分区的选择（极重要）" class="headerlink" title="Linux安装模式下，磁盘分区的选择（极重要）"></a>Linux安装模式下，磁盘分区的选择（极重要）</h3><h4 id="目录树结构"><a href="#目录树结构" class="headerlink" title="目录树结构"></a>目录树结构</h4><p>Linux内所有的数据都是以文件形态来呈现的，Linux系统最重要的地方就是在于目录树架构。就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%887.55.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所有的文件都是由根目录（_）衍生来的，当要取得mydata那个文件时，系统就由根目录开始找，最终的文件名为: _home_dmtsai_mydata的意思。</p><h4 id="文件系统与目录树的关系（挂载）"><a href="#文件系统与目录树的关系（挂载）" class="headerlink" title="文件系统与目录树的关系（挂载）"></a>文件系统与目录树的关系（挂载）</h4><p>挂载就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说，进入该目录就可以读取该分区的意思。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E9%B8%9F%E5%93%A5Linux%E5%9F%BA%E7%A1%80%20%20%20Linux%E7%9A%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%AE%89%E8%A3%85/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-20%20%E4%B8%8B%E5%8D%888.11.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>假设硬盘分为两个分区 partition1是挂载到根目录,至于 partition2则是挂载到/ home这个目录。这也就是说当我的数据放置在 home 内的各次目录时,数据是放置到partition2的如果不是放在/home下面的目录,那么数据就会被放置到 partition1。</p><h4 id="至少两个分区"><a href="#至少两个分区" class="headerlink" title="至少两个分区"></a>至少两个分区</h4><p>但记住至少要有两个分区，一个swap分区，一个/分区。swap分区是linux暂时存储数据的交换分区，它主要是把主内存上暂时不用得数据存起来，在需要的时候再调进内存内，且作为swap使用的分区不用指定“mout point”（载入点），既然它作为交换分区，我们理所当然应给它指定大小，它至少要等于系统上实际内存的量，一般来说它的大小是内存的两倍，如果你是16mb的内存，那么swap分区的大小是32mb左右，以此类推。但必须还要注意一点，swap分区不要大于128mb，因为系统不需要太大的交换分区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第零章、计算机概论&quot;&gt;&lt;a href=&quot;#第零章、计算机概论&quot; class=&quot;headerlink&quot; title=&quot;第零章、计算机概论&quot;&gt;&lt;/a&gt;第零章、计算机概论&lt;/h1&gt;&lt;p&gt;CPU实际要处理的数据完全来自于内存（不管是程序还是一般文件数据）。&lt;br&gt;CPU架
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://github.com/zdkswd/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://github.com/zdkswd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫 爬小说 爬图片 爬视频</title>
    <link href="https://github.com/zdkswd/2019/01/16/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>https://github.com/zdkswd/2019/01/16/网络爬虫/</id>
    <published>2019-01-16T12:15:32.000Z</published>
    <updated>2019-01-16T12:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><p>参考<a href="https://cuijiahua.com/blog/2017/10/spider_tutorial_1.html" target="_blank" rel="noopener">https://cuijiahua.com/blog/2017/10/spider_tutorial_1.html</a><br>网络爬虫的第一步就是根据URL，获取网页的HTML信息。在Python3中，可以使用urllib.request和requests进行网页爬取。</p><ol><li>urllib库是python内置的，无需我们额外安装，只要安装了Python就可以使用这个库。</li><li>requests库是第三方库，需要我们自己安装。</li></ol><p>requests库的基础方法如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%888.59.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests.get()方法，它用于向服务器发起GET请求。requests.get()方法就是从服务器得到、抓住数据，也就是获取数据。</p><h1 id="小说下载"><a href="#小说下载" class="headerlink" title="小说下载"></a>小说下载</h1><p>代码<a href="https://github.com/zdkswd/papapachong/tree/master/%E7%88%AC%E5%8F%96%E5%B0%8F%E8%AF%B4">papapachong/爬取小说 at master · zdkswd/papapachong · GitHub</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小说网站-笔趣看：</p><p>URL：http:<a href="http://www.biqukan.com/" target="_blank" rel="noopener">www.biqukan.com/</a><br>笔趣看是一个盗版小说网站，这里有很多起点中文网的小说，该网站小说的更新速度稍滞后于起点中文网正版小说的更新速度。并且该网站只支持在线浏览，不支持小说打包下载。因此，本次实战就是从该网站爬取并保存一本名为《一念永恒》的小说，该小说是耳根正在连载中的一部玄幻小说。PS：本实例仅为交流学习，支持耳根大大，请上起点中文网订阅。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>《一念永恒》小说的第一章内容，URL：<a href="http://www.biqukan.com/1_1094/5403177.html" target="_blank" rel="noopener">http://www.biqukan.com/1_1094/5403177.html</a></p><p>通过result=rq.get(url=target)<br>我们很轻松地获取了HTML信息。但是，很显然，很多信息是我们不想看到的，我们只想获得如右侧所示的正文内容，我们不关心div、br这些html标签。如何把正文内容从这些众多的html标签中提取出来呢？这就是本次实战的主要内容。</p><h2 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h2><p>爬虫的第一步，获取整个网页的HTML信息，我们已经完成。接下来就是爬虫的第二步，解析HTML信息，提取我们感兴趣的内容。对于本小节的实战，我们感兴趣的内容就是文章的正文。提取的方法有很多，例如使用正则表达式、Xpath、Beautiful Soup等。对于初学者而言，最容易理解，并且使用简单的方法就是使用Beautiful Soup提取感兴趣内容。</p><p>Beautiful Soup中文的官方文档。URL：<br><a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://beautifulsoup.readthedocs.io/zh_CN/latest/</a></p><p>仔细观察目标网站一番，我们会发现这样一个事实：class属性为showtxt的div标签，独一份！这个标签里面存放的内容，是我们关心的正文部分。</p><p>知道这个信息，我们就可以使用Beautiful Soup提取我们想要的内容了。<br>在解析html之前，我们需要创建一个Beautiful Soup对象。BeautifulSoup函数里的参数就是我们已经获得的html信息。然后我们使用find_all方法，获得html信息中所有class属性为showtxt的div标签。find_all方法的第一个参数是获取的标签名，第二个参数class_是标签的属性，为什么不是class，而带了一个下划线呢？因为python中class是关键字，为了防止冲突，这里使用class_表示标签的class属性。</p><p>为什么不是find_all(‘div’, id = ‘content’, class_ = ‘showtxt’)?这样其实也是可以的，属性是作为查询时候的约束条件，添加一个class_=’showtxt’条件，我们就已经能够准确匹配到我们想要的标签了，所以我们就不必再添加id这个属性了。</p><p>此时结果中有一些我们不想要的东西。比如div标签名，br标签，以及各种空格。怎么去除这些东西呢？</p><p>find_all匹配的返回的结果是一个列表。提取匹配结果后，使用text属性，提取文本内容，滤除br标签。随后使用replace方法，剔除空格，替换为回车进行分段。&nbsp;在html中是用来表示空格的。replace(‘\xa0’*8,’\n\n’)就是去掉下图的八个空格符号，并用回车代替。</p><p>可以看到，我们很自然的匹配到了所有正文内容，并进行了分段。我们已经顺利获得了一个章节的内容，要想下载正本小说，我们就要获取每个章节的链接。我们先分析下小说目录：</p><p>URL：http:<a href="http://www.biqukan.com/1_1094/" target="_blank" rel="noopener">www.biqukan.com/1_1094/</a></p><p>根据<a> 标签的href属性值获得每个章节的链接和名称。小说每章的链接放在了class属性为listmain的<div>标签下的<a>标签中。链接具体位置放在html-&gt;body-&gt;div-&gt;dl-&gt;dd-&gt;a的href属性中。先匹配class属性为listmain的<div>标签，再匹配<a>标签。</a></div></a></div></a></p><h1 id="爬取壁纸"><a href="#爬取壁纸" class="headerlink" title="爬取壁纸"></a>爬取壁纸</h1><p><a href="https://github.com/zdkswd/papapachong/tree/master/%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87">papapachong/爬取图片 at master · zdkswd/papapachong · GitHub</a></p><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>URL：https:unsplash.com/<br>网站的名字叫做Unsplash，免费高清壁纸分享网是一个坚持每天分享高清的摄影图片的站点，每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片可以作为桌面壁纸也可以应用于各种需要的环境。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ol><li>使用requeusts获取整个网页的HTML信息；</li><li>使用Beautiful Soup解析HTML信息，找到所有<img>标签，提取src属性，获取图片存放地址；</li><li>根据图片存放地址，下载图片。</li></ol><p>照此方法得不到<img>标签，而是\&lt;script>标签，因为这个网站的所有图片都是动态加载的！网站有静态网站和动态网站之分，上一个实战爬取的网站是静态网站，而这个网站是动态网站，动态加载有一部分的目的就是为了反爬虫。</p><p>动态网站使用动态加载常用的手段就是通过调用JavaScript来实现的。一个动态加载的网站可能使用很多JavaScript脚本，我们只要找到负责动态加载图片的JavaScript脚本。强大的抓包工具，它会帮助分析。这个强大的抓包工具就是Fiddler。但是Fiddler只在Windows上才能发挥完全的作用，所以我用的是一个跨平台的抓包工具Charles。</p><p>经过抓包发现，在如下数据包中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-23%20%E4%B8%8B%E5%8D%889.04.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>有json数据包<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-23%20%E4%B8%8B%E5%8D%889.08.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>id和下载图片有以下的关系<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-23%20%E4%B8%8B%E5%8D%889.04.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>所以可以</p><ol><li>获取整个json数据</li><li>解析json数据</li></ol><p>如果直接获取会出现SSL认证的错误，SSL认证是指客户端到服务器端的认证。一个非常简单的解决这个认证错误的方法就是设置requests.get()方法的verify参数。这个参数默认设置为True，也就是执行认证。我们将其设置为False，绕过认证。</p><p>反爬虫的手段除了动态加载，还有一个反爬虫手段，那就是验证Request Headers。Requests Headers里有很多参数，有Accept、Accept-Encoding、Accept-Language、DPR、User-Agent、Viewport-Width、accept-version、Referer、x-unsplash-client、authorization、Connection、Host。</p><ol><li>User-Agent：这里面存放浏览器的信息。如果我们不设置这个参数，用Python程序直接发送GET请求，服务器接受到的User-Agent信息就会是一个包含python字样的User-Agent。如果后台设计者验证这个User-Agent参数是否合法，不让带Python字样的User-Agent访问，这样就起到了反爬虫的作用。这是一个最简单的，最常用的反爬虫手段。</li><li>Referer：这个参数也可以用于反爬虫，它表示这个请求是从哪发出的。可以看到我们通过浏览器访问网站，这个请求是从<a href="https://unsplash.com/，这个地址发出的。如果后台设计者，验证这个参数，对于不是从这个地址跳转过来的请求一律禁止访问，这样就也起到了反爬虫的作用。" target="_blank" rel="noopener">https://unsplash.com/，这个地址发出的。如果后台设计者，验证这个参数，对于不是从这个地址跳转过来的请求一律禁止访问，这样就也起到了反爬虫的作用。</a></li><li>authorization：这个参数是基于AAA模型中的身份验证信息允许访问一种资源的行为。在我们用浏览器访问的时候，服务器会为访问者分配这个用户ID。如果后台设计者，验证这个参数，对于没有用户ID的请求一律禁止访问，这样就又起到了反爬虫的作用。</li></ol><p>Unsplash是根据authorization参数进行反爬虫的。通过程序手动添加这个参数，然后再发送GET请求，就可以顺利访问了。即requests.get()方法，添加headers参数即可。</p><p>现在终于顺利获得json数据了，使用json.load()方法解析数据。解析json数据很简单，跟字典操作一样，就是字典套字典。json.load()里面的参数是原始的json格式的数据。</p><p>图片的ID已经获得了，再通过字符串处理一下，就生成了我们需要的图片下载请求地址。根据这个地址，我们就可以下载图片了。下载方式，使用直接写入文件的方法。</p><p>每次获取链接加一个1s延时，因为人在浏览页面的时候，翻页的动作不可能太快。我们要让我们的爬虫尽量友好一些。</p><p>下载速度还行，有的图片下载慢是因为图片太大。可以看到也打印了一些警报信息，这是因为没有进行SSL验证。</p><h1 id="爱奇艺VIP视频下载"><a href="#爱奇艺VIP视频下载" class="headerlink" title="爱奇艺VIP视频下载"></a>爱奇艺VIP视频下载</h1><p>现在失效了，只能手动抓包了<br><a href="https://github.com/zdkswd/papapachong/tree/master/%E7%88%AC%E5%8F%96%E8%A7%86%E9%A2%91">papapachong/爬取视频 at master · zdkswd/papapachong · GitHub</a><br><a href="http://www.wq114.org/" target="_blank" rel="noopener">vip视频解析,vip视频在线解析</a>有效的url解析网站。<br>解析格式：<a href="http://www.wq114.org/yun.php?url=" target="_blank" rel="noopener">www.wq114.org/yun.php?url=</a> [视频url]<br>利用网络爬虫进行抓包，可以将视频下载下来。</p><p>HTTP请求头Referer的作用：表示请求来源。</p><p>编写代码的时候注意一个问题，就是我们需要使用requests.session()保持我们的会话请求。简单理解就是，在初次访问服务器的时候，服务器会给你分配一个身份证明。我们需要拿着这个身份证去继续访问，如果没有这个身份证明，服务器就不会再让你访问。这也就是这个服务器的反爬虫手段，会验证用户的身份。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络爬虫&quot;&gt;&lt;a href=&quot;#网络爬虫&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫&quot;&gt;&lt;/a&gt;网络爬虫&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;https://cuijiahua.com/blog/2017/10/spider_tutorial_
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
      <category term="爬虫" scheme="https://github.com/zdkswd/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>SSH</title>
    <link href="https://github.com/zdkswd/2019/01/16/SSH/"/>
    <id>https://github.com/zdkswd/2019/01/16/SSH/</id>
    <published>2019-01-16T12:09:56.000Z</published>
    <updated>2019-01-16T12:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>参考<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p><h1 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h1><p>SSH是一种网络协议，用于计算机之间的加密登录。</p><p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p><p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p><p>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。本文只讨论SSH在Linux Shell中的用法。</p><h1 id="最基本的用法"><a href="#最基本的用法" class="headerlink" title="最基本的用法"></a>最基本的用法</h1><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.28.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果本地用户名与远程用户名一致，登录时可以省略用户名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.28.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.29.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面这条命令表示，ssh直接连接远程主机的2222端口。</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p><p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><p>SSH协议也有应对的方法。</p><h1 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h1><p>如果你是第一次登录对方主机，系统会出现下面的提示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.36.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p><p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%886.39.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>系统会出现一句提示，表示host主机已经得到认可。然后会要求输入密码。密码正确就可以登录了。</p><p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/ .ssh /known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p><p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/ etc / ssh /ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h1 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h1><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p><p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.00.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p><p>运行结束以后，在$HOME/ .ssh /目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p><p>这时再输入下面的命令，将公钥传送到远程主机host上面：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.50.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从此再登录，就不需要输入密码了。</p><p>如果还是不行，就打开远程主机的_etc_ssh/sshd_config这个文件，检查下面几行前面# 注释是否取掉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.58.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后，重启远程主机的ssh服务。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/SSH/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-16%20%E4%B8%8B%E5%8D%887.58.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="公钥私钥补充"><a href="#公钥私钥补充" class="headerlink" title="公钥私钥补充"></a>公钥私钥补充</h1><p>如果只是单方面采用非对称性加密算法,其实有两种方式,用于不同用处。</p><p>第一种是签名,使用私钥加密,公钥解密,用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改.但是不用来保证内容不被他人获得。</p><p>第二种是加密,用公钥加密,私钥解密,用于向公钥所有者发布信息,这个信息可能被他人篡改,但是无法被他人获得。</p><p>如果甲想给乙发一个安全的保密的数据,那么应该甲乙各自有一个私钥,甲先用乙的公钥加密这段数据,再用自己的私钥加密这段加密后的数据.最后再发给乙,这样确保了内容即不会被读取,也不会被篡改。</p><h1 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h1><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。</p><p>SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>python requests库</title>
    <link href="https://github.com/zdkswd/2019/01/14/python%20requests%E5%BA%93/"/>
    <id>https://github.com/zdkswd/2019/01/14/python requests库/</id>
    <published>2019-01-14T04:03:56.000Z</published>
    <updated>2019-01-14T04:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="requests库的使用（廖雪峰）"><a href="#requests库的使用（廖雪峰）" class="headerlink" title="requests库的使用（廖雪峰）"></a>requests库的使用（廖雪峰）</h1><p>要通过GET访问一个页面，只需要几行代码：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%888.53.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于带参数的URL，传入一个dict作为params参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%888.56.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests自动检测编码，可以使用encoding属性查看：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.03.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.04.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.05.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要传入HTTP Header时，我们传入一个dict作为headers参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.07.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.08.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests默认使用application/x-www-form-urlencoded对POST数据编码。如果要传递JSON数据，可以直接传入json参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.09.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>类似的，上传文件需要更复杂的编码格式，但是requests把它简化成files参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.10.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在读取文件时，注意务必使用’rb’即二进制模式读取，这样获取的bytes长度才是文件的长度。</p><p>把post()方法替换为put()，delete()等，就可以以PUT或DELETE方式请求资源。</p><p>除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.14.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.15.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要在请求中传入Cookie，只需准备一个dict传入cookies参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.15.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最后，要指定超时，传入以秒为单位的timeout参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-25%20%E4%B8%8A%E5%8D%889.16.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="requests的使用（博客）"><a href="#requests的使用（博客）" class="headerlink" title="requests的使用（博客）"></a>requests的使用（博客）</h1><p><a href="https://blog.csdn.net/WuZuoDingFeng/article/details/76156777" target="_blank" rel="noopener">https://blog.csdn.net/WuZuoDingFeng/article/details/76156777</a></p><h2 id="requests-get"><a href="#requests-get" class="headerlink" title="requests.get()"></a>requests.get()</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.16.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>参数说明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.18.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="requests-post"><a href="#requests-post" class="headerlink" title="requests.post()"></a>requests.post()</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.19.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>参数说明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.19.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="请求响应体说明"><a href="#请求响应体说明" class="headerlink" title="请求响应体说明"></a>请求响应体说明</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.28.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="requests-utils中的常用方法"><a href="#requests-utils中的常用方法" class="headerlink" title="requests.utils中的常用方法"></a>requests.utils中的常用方法</h2><ol><li>requests.utils.get_encodings_from_content(r.content): 返回原始数据编码;</li><li>requests.utils.dict_from_cookiejar(r.cookies): 将CookieJar转为字典;</li><li>requests.utils.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True): 将字典转为CookieJar;</li></ol><h2 id="开启会话，保持cookie"><a href="#开启会话，保持cookie" class="headerlink" title="开启会话，保持cookie"></a>开启会话，保持cookie</h2><blockquote><p>s = requests.Session()             # 开启会话<br>cookies = json.loads(result)                     # phantomjs获取的cookies json对象<br>cookie = {}<br>for k in cookies:<br>   cookie[k[‘name’]] = k[‘value’]               # 获取每个cookie中的name和value<br>s.cookies = requests.utils.cookiejar_from_dict(cookie, cookiejar=None,<br>overwrite=True)       # 将字典cookie转换为cookieJar,然后放在会话中<br>s.get(url…..)              # 此时每个请求都会带上cookie<br>……………………………………………………<br>s.cookies: cookiejar对象;<br>s.cookies.get_dict(): dict,cookie键值对;  </p></blockquote><h2 id="设置超时和最大尝试次数"><a href="#设置超时和最大尝试次数" class="headerlink" title="设置超时和最大尝试次数"></a>设置超时和最大尝试次数</h2><ol><li>timeout是get/post等的参数, 单位秒.</li><li>max_retries需要构建一个HTTPAdapter并设置其max_retries, 最后将该Adaptor加载给requests的Session对象. mount时的链接是前端最大匹配, 使用” http: ”和” https: ”可以分别对应两大类网址. 也可以更具体针对某网站.</li><li>注：max_retries适用于超时，并不适用于访问出错。</li><li>注：在会话中，请求url1所返回的cookies会自动保存，当访问url2的时候也会被自动带入。</li></ol><blockquote><p>requestsSession = requests.Session()                # 开启会话<br>requestsAdapterA = requests.adapters.HTTPAdapter(max_retries=3)     # 挂载适配器<br>requestsSession.mount(‘http: ‘, requestsAdapterA)    # 此会话中适用所有http请求<br>r = requestsSession.get(url , timeout=20)                  # 打开相应url并设置超时  </p></blockquote><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><blockquote><p>url = ‘<a href="http://httpbin.org/post&#39;" target="_blank" rel="noopener">http://httpbin.org/post&#39;</a><br>files = {‘file’: open(‘report.xls’, ‘rb’)}<br> #  files = {‘file’: (‘report.xls’, open(‘report.xls’, ‘rb’), ‘application/vnd.ms-excel’, {‘Expires’: ‘0’})}   # 显示的设置文件名、文件类型、文件头<br>r = requests.post(url, files=files)<br>r.text  </p></blockquote><h2 id="流式上传"><a href="#流式上传" class="headerlink" title="流式上传"></a>流式上传</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.49.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/python%20requests%E5%BA%93/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8810.49.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>get()或post()中的headers、cookies设置的值，将合并到Requests中去，所以传入 {} 也没关系；</li><li>图片、pdf等打开方式应该为 ‘wb’，写入的内容应该是 r.content；</li><li>若是响应头Content-Type中不含charset，则 r.text 默认为 ‘ISO-8859-1’；</li><li>若是timeout没有显示的设置，理论上requests请求永不超时。</li><li>在session中删除一个参数，直接设置其值为None；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;requests库的使用（廖雪峰）&quot;&gt;&lt;a href=&quot;#requests库的使用（廖雪峰）&quot; class=&quot;headerlink&quot; title=&quot;requests库的使用（廖雪峰）&quot;&gt;&lt;/a&gt;requests库的使用（廖雪峰）&lt;/h1&gt;&lt;p&gt;要通过GET访问一个
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Python" scheme="https://github.com/zdkswd/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发的MVC和MVP模式</title>
    <link href="https://github.com/zdkswd/2019/01/08/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%9A%84MVC%E5%92%8CMVP%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/zdkswd/2019/01/08/安卓开发的MVC和MVP模式/</id>
    <published>2019-01-08T12:04:56.000Z</published>
    <updated>2019-01-08T12:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC和MVP示意图"><a href="#MVC和MVP示意图" class="headerlink" title="MVC和MVP示意图"></a>MVC和MVP示意图</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%9A%84MVC%E5%92%8CMVP%E6%A8%A1%E5%BC%8F/20170813105245063.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%9A%84MVC%E5%92%8CMVP%E6%A8%A1%E5%BC%8F/20170813013123472.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="MVP和MVC的区别"><a href="#MVP和MVC的区别" class="headerlink" title="MVP和MVC的区别"></a>MVP和MVC的区别</h1><ol><li><strong>Activity职责不同</strong>，Activity在MVP中是View层，在MVC中是Controller层，这是MVC和MVP很主要的一个区别，可以说Android从MVC转向MVP开发也主要是优化Activity的代码，避免Activity的代码臃肿庞大。</li><li><strong>View层不同</strong>，MVC的View层指的是XML布局文件或者是用Java自定义的View，MVP的View层是Activity或者Fragment。使用传统的MVC，其中的View，对应的是各种Layout布局文件，但是这些布局文件中并不像Web端那样强大，能做的事情非常有限。MVP的View层Activity在实际项目中，随着逻辑的复杂度越来越大，Activity臃肿的缺点仍然体现出来了，因为Activity中还是充满了大量与View层无关的代码，比如各种事件的处理派发，就如MVC中的那样View层和Controller代码耦合在一起无法自拔。</li><li><strong>控制层不同</strong>，MVC的控制层是Activity，或者是Fragment，Controller对应的是Activity，而Activity中却又具有操作UI的功能，我们在实际的项目中也会有很多UI操作在这一层，也做了很多View中应该做的事情，当然Controller层Activity中也包含Controller应该做的事情，比如各种事件的派发回调，而且在一层中我们会根据事件再去调用Model层操作数据，所以这种MVC的方式在实际项目中，Activity所在的Controller是非常重的，各层次之间的耦合情况也比较严重，不方便单元测试。MVP的控制层是Presenter，里面没有很多的实际东西，主要是做Model和View层的交互。</li><li><strong>关系链不同</strong>，MVP中Model层与View是没有关系的，彼此不会通讯和操作，Model与View的通讯都是Presenter层来传达的。但是在MVC中，Model层和View是曾在交互的。比如我们自定义的View控件里面肯定是要使用Model的数据的，View也要根据不同的Model数据做出不同的展现！这点尤其是体现在自定义的View中，自定义View需要设置数据，用户操作了自定义控件需要改变数据，View要操作Model怎么办？有人说把Controller传到自定义的View啊，现实是不可能没一个自定义View都去持有Controller的引用，其实在MVP中就不会这么尴尬，接口就可以完成。</li><li><strong>适用范围不同</strong>，在Android中，MVP和MVC都用自己的适用情况，使用MVP可以更好的解耦三大模块，模块之间比较清晰，也很方便使用MVP来组件化架构整体项目。但是MVC也是有用武之地的，在组件化的Module或者中间件我们可以使用MVC来做，Module或者中间件不会存在很复杂的View层，使用MVC可以更加方便我们实现功能。</li><li><strong>交互方式不同</strong>，MVP中通讯交互基本都是通过接口的，MVC中的通讯交互很多时候都是实打实的调用对象的方法，简单粗暴！</li><li><strong>实现方法不同</strong> ，MVC和MVP的Model几乎一样的，都是处理数据，只要不在Activity或者Fragment中请求数据，其他的所有控制都放在Activity或者Fragment中，这样写就基本是MVC的模式，这样写不麻烦，但是很容易把Activity写出上万行代码。用MVP的时候我们需要写很多View和Presenter接口来实现模块之间的通讯，会增加很多类。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MVC和MVP示意图&quot;&gt;&lt;a href=&quot;#MVC和MVP示意图&quot; class=&quot;headerlink&quot; title=&quot;MVC和MVP示意图&quot;&gt;&lt;/a&gt;MVC和MVP示意图&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
           
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="https://github.com/zdkswd/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C++内存格局 汇编语言</title>
    <link href="https://github.com/zdkswd/2019/01/05/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/"/>
    <id>https://github.com/zdkswd/2019/01/05/C++内存格局/</id>
    <published>2019-01-05T06:48:56.000Z</published>
    <updated>2019-01-05T06:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-内存格局"><a href="#C-内存格局" class="headerlink" title="C++内存格局"></a>C++内存格局</h1><p>C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/1097927-20180724163319830-302594590.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012204.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。</p><h2 id="汇编语言是什么"><a href="#汇编语言是什么" class="headerlink" title="汇编语言是什么"></a>汇编语言是什么</h2><p>CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。<strong>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</strong>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p><h2 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h2><p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p><p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p><p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p><p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><p>寄存器不依靠地址区分数据，而依靠<strong>名称</strong>。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p><h2 id="寄存器的种类"><a href="#寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。<br>EAX，EBX，ECX，EDX，EDI，ESI，EBP，ESP<br>8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址。</p><p>32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p><h2 id="内存模型：Heap"><a href="#内存模型：Heap" class="headerlink" title="内存模型：Heap"></a>内存模型：Heap</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012208.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012209.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h2 id="内存模型：Stack"><a href="#内存模型：Stack" class="headerlink" title="内存模型：Stack"></a>内存模型：Stack</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012210.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.21.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012211.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果函数内部调用了其他函数，会发生什么情况？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.22.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012215.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。</p><h2 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h2><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><p>一个简单的程序example.c。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.30.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>gcc 将这个程序转成汇编语言。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.30.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p>example.s经过简化以后，大概是下面的样子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.32.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。<br>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%881.33.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.00.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.03.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第二行也是一样，push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/bg2018012216.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>第三行的call指令用来调用函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.04.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。下面就开始执行_add_a_and_b的代码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.05.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p><h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>mov指令用于将一个值写入某个寄存器。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.08.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。下一行代码也是干同样的事情。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.11.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。</p><h3 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h3><p>add指令用于将两个运算子相加，并将结果写入第一个运算子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.14.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="pop指令"><a href="#pop指令" class="headerlink" title="pop指令"></a>pop指令</h3><p>pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.16.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p><h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p>ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.17.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，该指令没有运算子。</p><p>随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.18.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%E5%86%85%E5%AD%98%E6%A0%BC%E5%B1%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-05%20%E4%B8%8B%E5%8D%882.19.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最后，main函数运行结束，ret指令退出程序执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-内存格局&quot;&gt;&lt;a href=&quot;#C-内存格局&quot; class=&quot;headerlink&quot; title=&quot;C++内存格局&quot;&gt;&lt;/a&gt;C++内存格局&lt;/h1&gt;&lt;p&gt;C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
      <category term="汇编" scheme="https://github.com/zdkswd/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 对象和类</title>
    <link href="https://github.com/zdkswd/2019/01/04/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"/>
    <id>https://github.com/zdkswd/2019/01/04/C++ Primer 对象和类/</id>
    <published>2019-01-04T12:32:56.000Z</published>
    <updated>2019-01-04T12:39:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-对象和类"><a href="#C-Primer-对象和类" class="headerlink" title="C++ Primer 对象和类"></a>C++ Primer 对象和类</h1><h2 id="C-中的类"><a href="#C-中的类" class="headerlink" title="C++中的类"></a>C++中的类</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-27%20%E4%B8%8B%E5%8D%889.42.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏(将数据放在类的私有部分中)是一种封装，将实现的细节隐藏在私有部分中，就像Stock类对set tot() 所做的那样，也是一种封装。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。</p><h3 id="控制对成员的访问：公有还是私有"><a href="#控制对成员的访问：公有还是私有" class="headerlink" title="控制对成员的访问：公有还是私有"></a>控制对成员的访问：公有还是私有</h3><p>无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明它。但由于隐藏数据是OOP主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分:否则，就无法从程序中调用这些函数。也可以把成员函数放在私有部分。不能直接从程序中调用这种函数，但公有方法却可以使用它们。通常，程序员使用私有成员函数来处理不属于公有接口的实现细节。</p><p>不必在类声明中使用关键字 private, 因为这是类对象的默认访问控制:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-27%20%E4%B8%8B%E5%8D%889.52.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为强调数据隐藏的概念，显式使用private。</p><h3 id="类和结构"><a href="#类和结构" class="headerlink" title="类和结构"></a>类和结构</h3><p>类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。实际上，C++对结构进行了扩展，使之具有与类相同的特性 它们之间惟一的区别是，结构的默认访问类型是public, 而类为private C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象或没有私有部分的类。</p><h3 id="实现类成员函数"><a href="#实现类成员函数" class="headerlink" title="实现类成员函数"></a>实现类成员函数</h3><p>成员函数定义与常规丽数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征:</p><ol><li>定义成员函数时，使用作用域解析操作符(::) 来标识函数所属的类。</li><li>类方法可以访问类的private组件。</li></ol><p>如：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%884.32.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>类方法的完整名称中包括类名。我们说，Stock::update() 是函数的限定名(qualfied name);而简单的update()是全名的缩写(非限定名，unqualified name), 它只能在类作用域中使用。</p><p>这些方法定义可以放在单独一个文件中，也可以位于类声明所在的文件中。</p><h4 id="内联方法"><a href="#内联方法" class="headerlink" title="内联方法"></a>内联方法</h4><p>其定义位于类声明中的函数都将自动成为内联函数。如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此只需要在类实现部分中定义函数时使用inline限定符即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%884.48.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是:将内联定义放在定义类的头文件中(有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件)。</p><h4 id="方法与对象"><a href="#方法与对象" class="headerlink" title="方法与对象"></a>方法与对象</h4><p>所创建的每个新对象都有自己的存储空间，<strong>用于存储其内部变量和类成员</strong>;但同一个类的所有对象<strong>共享同一组类方法</strong>，即每种方法只有一个副本。例如，假设kate和joe都是Stock对象，则kate.shares将占据一个内存块，而je.shares 占用另一一个内存块， 但kate.show()和joe.show()都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。在OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给2个不同的对象将调用同一个方法，但该方法被用于2个不同的对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%884.58.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><p>C++提供了一个特殊的成员函数—类构造函数，专门用于构造新对象、将值赋给它们的数据成员。更准确地说，C++为这些成员函数提供了名称和使用方法，而程序员需要提供方法定义。构造函数的原型和函数头有一个有趣的特征—虽然没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。</p><h3 id="声明和定义构造函数"><a href="#声明和定义构造函数" class="headerlink" title="声明和定义构造函数"></a>声明和定义构造函数</h3><p>原型如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%887.20.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>构造函数的一种可能定义：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%887.21.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>程序声明对象时，将自动调用构造函数。<br>参数名不能与类成员相同，为避免混乱，通常的做法是在数据成员名中使用m_前缀：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%887.45.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h3><p>C++提供了两种使用构造函数来初始化对象的方式。第一种方式是显式地调用构造函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%887.48.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一种方式是隐式地调用构造函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%887.48.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它与下面的显式调用等价：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%887.50.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>每次创建类对象(甚至使用new动态分配内存)时，C++都将使用类构造函数。下面是将构造函数与new 起使用的方法:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%887.52.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这条语句创建一个Stock对象，将其初始化为参数提供的值，并将该对象的地址赋给pstock指针。在这种情况下，对象没有名称，但可以使用指针来管理该对象。</p><p>无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。因此构造函数被用来创建对象， 而不能通过对象来调用。</p><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>默认构造函数是在未提供显式的初始化值时,被用来创建对象的构造函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.01.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。对于Stock类来说，默认构造函数可能如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.05.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建 stock 对象,但不初始化其成员,这和下面的语句<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.05.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>创建x,但没有提供值给它一样。默认构造函数没有参数,因为声明中不包含值。</p><p>当且仅当没有定义任何构造函数时,编译器才会提供默认构造函数。为类定义了构造函数后,程序员就必须为它提供默认构造函数。如果提供了非默认构造函数但没有提供默认构造函数,则将出错。如果要创建对象,而不显式地初始化, 则必须定义一个不接受任何参数的默认构造函数。</p><p>定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.11.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一种方式是通过函数重载来定义另一个构造函数一一一个没有参数的构造函数:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.12.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于只能有个默认构造函数， 因此不要同时采用这两种方式。</p><p>在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。</p><p>使用上述任何一种方式(没有参数或所有参数都有默认值)创建了默认构造函数后，便可以声明对象变量，而不对它们进行显式初始化:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.23.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>隐式地调用默认构造函数时，不要使用圆括号。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数，该函数的名称令人生畏一析构函数。析构函数完成清理工作，因此实际上很有用。如，如果构造函数使用new 来分配内存，则析构函数将使用delete来释放这些内存。如果构造函数没有使用new，析构函数实际上没有需要完成的任务。此时，只需让编译器生成一个什么都不用做的隐式析构函数。</p><p>和构造函数一样，析构函数的名称也很特殊:在类名前加上(~)。因此，Stock类的析构函数为~Stock().另外， 和构造函数一样，析构函数也可以没有返回值和声明类型。与构造函数不同的是，析构函数没有参数，因此析构函数的原型必须是这样的:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.32.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>什么时候调用析构函数由<strong>编译器</strong>决定，通常不应在代码中显式地调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象,则其析构函数将在程序执行完代码块时(该对象是在其中定义的)自动被调用。如果对象是通过new创建的，则它将驻留在堆栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。</p><p>由于在类对象过期时析构函数将自动被调用，因此必须有- 个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象破删除的代码后，提供默认析构函数的定义。</p><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.47.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于当前的C++来说，编译器将拒绝第二行。因为show()的代码无法确保调用对象不被修改一调用对象和const一样，不应被修改。一种新的句法—保证函数不会修改调用对象。C++的解决方法是将const关键字放在函数的括号后面。<br>show（）声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.51.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>函数定义的开头：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%888.51.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>以这种方式声明和定义的类函数被称为const成员函数。就像应尽可能将const引用和指针用作函数形参一样， 只要类方法不修改调用对象，就应将其声明为const.从现在开始，我们将遵守这一规则。</p><h4 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h4><p>接收一个参数的构造函数允许使用赋值句法将对象初始化为一个值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%889.06.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>每个成员函数(包括构造函数和析构函数)都有一个this 指针。this 指针指向调用对象。this是对象的地址，如果方法需要引用整个调用对象，则可以使用表达式 * this。在函数的括号后面使用const 限定符将this限定为const,这样将不能使用this 来修改对象的值。</p><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>声明对象数组的方法与声明标准类型数组相同：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%889.24.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当程序创建未被现实初始化的类对象时，总是调用默认构造函数。此时要么是没有显示地定义任何构造函数，将使用不执行任何操作的隐式默认构造函数。要么定义了一个显式默认构造函数。每个元素都是Stock对象可以使用Stock方法。</p><p>可以用构造函数来初始化数组元素。此时，必须为每个元素调用构造函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%889.31.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，<strong>要创建类对象数组，则这个类必须有默认构造函数。</strong></p><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><p>在类中定义的名称(如类数据成员名和类成员函数名)的作用域都为整个类,作用域为整个类的名称只在该类中是已知的,在类外是不可知的。因此,可以在不同类中使用相同的类成员名而不会引起冲突。另外,类作用域意味着不能从外部直接访问类的成员,公有成员函数也是如此。也就是说,要调用公有成员函数,必须通过对象。在定义成员函数时，必须使用作用域解析操作符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-28%20%E4%B8%8B%E5%8D%889.42.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="作用域为整个类的常量"><a href="#作用域为整个类的常量" class="headerlink" title="作用域为整个类的常量"></a>作用域为整个类的常量</h3><p>使用关键字static，在类中定义常量。该常量将与其他静态变量存储在一起，而不是存储在对象中。只能使用这种结束声明值为整数或枚举的静态常量，而不能存储double常量。</p><h1 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>要重载操作符,需使用被称为操作符函数的特殊函数形式。操作符函数的格式如下:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-02%20%E4%B8%8B%E5%8D%889.26.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>op是将要重载的操作符。operator+()重载+操作符，op必须是有效的C++操作符，不能虚构一个新的符号。例如，不能有operator@()这样的函数，因为C++中没有@操作符。但是，operator<a href=""></a>函数将重载[]操作符，因为【】是数组索引操作符。</p><h2 id="友元简介"><a href="#友元简介" class="headerlink" title="友元简介"></a>友元简介</h2><p>友元有3种：</p><ol><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ol><p>对于重载操作符，左侧的操作数是调用对象。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%881.23.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中要使用重载运算符就只能将B写在左侧。使用非成员函数，大多数操作符都可以通过成员或非成员函数来重载。非成员函数不是由对象调用的，它使用的所有值都是显示参数。这样编译器能够将表达式中B写到右侧。有一类特殊的非成员函数可以访问类的私有成员，为友元函数。</p><h3 id="创建友元"><a href="#创建友元" class="headerlink" title="创建友元"></a>创建友元</h3><p>创建友元函数的第一步，是将其原型放在类声明中，并在原型声明前加上关键字friend。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%881.35.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>该原型意味着两点：</p><ol><li>虽然operator * （）函数是在类声明中声明的，但它不是成员函数，因此不能使用成员函数操作符来调用。</li><li>虽然operator * （）函数不是成员函数，但它与成员函数的访问权限相同。</li></ol><p>第二步是编写函数定义。因为它不是成员函数，所以不要使用Time：：限定符。另外，不要再定义中使用关键字friend，定义如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%881.41.26.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>简而言之，类的友元函数是非成员函数，其访问权限与成员函数相同。</p><h3 id="友元是否有悖于OOP"><a href="#友元是否有悖于OOP" class="headerlink" title="友元是否有悖于OOP"></a>友元是否有悖于OOP</h3><p>只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据。简而言之，类方法和友元只是表达类接口的两种不同机制。</p><h3 id="常用的友元：重载-lt-lt-操作符"><a href="#常用的友元：重载-lt-lt-操作符" class="headerlink" title="常用的友元：重载&lt;&lt;操作符"></a>常用的友元：重载&lt;&lt;操作符</h3><h2 id="重载操作符：作为成员函数还是非成员函数"><a href="#重载操作符：作为成员函数还是非成员函数" class="headerlink" title="重载操作符：作为成员函数还是非成员函数"></a>重载操作符：作为成员函数还是非成员函数</h2><p>对于很多操作符来说，可以选择使用成员函数或非成员函数来实现操作符重载。一般来说，非成员函数应是友元函数， 这样它才能直接访问类的私有数据。例如，Time 类的加法操作符在Time类声明中的原型如下:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%881.57.09.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>加法操作符需要两个操作数。对于成员函数版本来说，一个操作数通过this指针隐式地传递，另一个操作数作为函数参数显式地传递;对于友元版本来说，两个操作数都作为参数来传递。</p><p>非成员版本的重载操作符函数所需的形参数目与操作符使用的操作数数目相同;而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象。</p><h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><h2 id="一个简单的基类"><a href="#一个简单的基类" class="headerlink" title="一个简单的基类"></a>一个简单的基类</h2><p>从一个类派生出另一个类，原始类称为基类，继承类称为派生类。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%882.29.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>冒号指出RatedPlayer类的基类是TableTennisplayer 类。上述特殊的声明头表明TableTennisPlayer 是一个公有基类，这被称为公有派生。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员; 基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%882.34.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="构造函数：访问权限的考虑"><a href="#构造函数：访问权限的考虑" class="headerlink" title="构造函数：访问权限的考虑"></a>构造函数：访问权限的考虑</h3><p>派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。具体地说，派生类构造函数必须使用基类构造函数。</p><p>创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表句法来完成这种工作。RatedPlayer构造函数代码：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%882.44.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中TableTennisPlayer(fn,ln,ht)是成员初始化列表，它调用TableTennisPlayer构造函数。</p><p>派生类构造函数要点：</p><ol><li>基类对象首先被创建。</li><li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数。</li><li>派生类构造函数应初始化派生类新增的数据成员。</li></ol><p>如果没有提供显示构造函数，因此将使用隐式构造函数。释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。</p><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-03%20%E4%B8%8B%E5%8D%883.53.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="使用派生类"><a href="#使用派生类" class="headerlink" title="使用派生类"></a>使用派生类</h3><p>要使用派生类，程序必须要能够访问基类声明。可以将这两种类的声明置于同一个头文件中。也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。</p><h2 id="派生类和基类之间的特殊关系"><a href="#派生类和基类之间的特殊关系" class="headerlink" title="派生类和基类之间的特殊关系"></a>派生类和基类之间的特殊关系</h2><p>派生类对象可以使用基类的方法，条件是方法不是私有的。<br>基类指针可以在不进行显式类型转换的情况下指向派生类对象。<br>基类引用可以在不进行显式类型转换的情况下引用派生类对象。</p><p>不过，基类指针或引用只能用户调用基类方法，而不能调用派生类的方法。通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。不过，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。</p><h2 id="继承——is-a关系"><a href="#继承——is-a关系" class="headerlink" title="继承——is-a关系"></a>继承——is-a关系</h2><p>派生类和基类之间的特殊关系是基于C++继承的底层模型。C++有3种继承方式：<strong>公有继承、保护继承和私有继承</strong>。公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行任何操作，也可以对派生类对象执行。</p><h2 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h2><p>希望同一个方法在派生类和基类中的行为是不同的，有两种重要的机制可用于实现多态公有继承：</p><ol><li>在派生类中重新定义基类方法。</li><li>使用虚方法。</li></ol><p>在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，实现多态性，使用关键字virtual来声明虚方法。virtual 函数返回类型 函数名（参数表） {函数体}；</p><h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在C++中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。C/C++编译器可以再编译过程完成这种联编。在编译过程中进行联编被称为静态联编（static binding）又称为早期联编。不过虚函数使这项工作变得更困难，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。</p><h3 id="为什么有两种类型的联编以及为什么默认为静态联编"><a href="#为什么有两种类型的联编以及为什么默认为静态联编" class="headerlink" title="为什么有两种类型的联编以及为什么默认为静态联编"></a>为什么有两种类型的联编以及为什么默认为静态联编</h3><p>如果动态联编让您能够重新定义类方法，而静态联编在这方面很差; 为何不摒弃静态联编呢?原因有两个—效率和概念模型。</p><p>效率：为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销。如果类不会用作基类，则不需要动态联编。如果派生类不重新定义基类的任何方法，也不需要使用动态联编。这时，使用静态联编更合理，效率也更高。由于静态联编的效率更高，因此被设置为C++的默认选择。概念模型，在设计类时，可能包含一些不在派生类重新定义的成员函数。不该将函数设置为虚函数，有两方面的好处：首先效率更高；其次指出不要重新定义该函数。</p><h3 id="虚函数的工作原理"><a href="#虚函数的工作原理" class="headerlink" title="虚函数的工作原理"></a>虚函数的工作原理</h3><p>编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（vtbl）。虚函数表中存储了为类对象进行声明的虚函数地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。无论类中包含的虚函数是一个还是10个，都只需要在对象中添加一个地址成员，只是表的大小不同而已。</p><p>调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</p><p>简而言之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p><ol><li>每个对象都将增大，增大量为存储地址的空间。</li><li>对每个类，编译器都创建一个虚函数地址表（数组）。</li><li>每个函数调用都需要执行一步额外的操作，即到表中查找地址。<br>虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。</li></ol><h3 id="有关虚函数的注意事项"><a href="#有关虚函数的注意事项" class="headerlink" title="有关虚函数的注意事项"></a>有关虚函数的注意事项</h3><p>虚函数的要点：</p><ol><li>在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类(包括从派生类派生出来的类)中是虚拟的。</li><li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。</li><li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚拟的。</li></ol><p>对于虚函数还有。<br>1.构造函数，构造函数不能是虚函数。<br>2.析构函数，析构函数应当是虚函数，除非类不用做基类。<br>如<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-04%20%E4%B8%8B%E5%8D%887.59.17.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果使用默认的静态联编，delete 语句将调用~Employee()析构函数。这将释放由Singer 对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存。但如果析构函数是虚拟的，则上述代码将先调用~Singer析构函数释放由Singer 组件指向的内存，然后，调用~Employee() 析构函数来释放由Employee组件指向的内存。</p><p><strong>通常应给基类提供一个虚拟析构函数，即使它并不需要析构函数。</strong><br>3.友元，友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数</p><h2 id="访问控制：protected"><a href="#访问控制：protected" class="headerlink" title="访问控制：protected"></a>访问控制：protected</h2><p>关键字 protected与 private相似,在类外只能用公有类成员来访问protected部分中的类成员。private和 protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-Primer-对象和类&quot;&gt;&lt;a href=&quot;#C-Primer-对象和类&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer 对象和类&quot;&gt;&lt;/a&gt;C++ Primer 对象和类&lt;/h1&gt;&lt;h2 id=&quot;C-中的类&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计算机是怎么启动的</title>
    <link href="https://github.com/zdkswd/2018/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/"/>
    <id>https://github.com/zdkswd/2018/12/26/计算机是怎么启动的/</id>
    <published>2018-12-26T02:03:47.000Z</published>
    <updated>2018-12-26T12:15:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机是怎么启动的"><a href="#计算机是怎么启动的" class="headerlink" title="计算机是怎么启动的"></a>计算机是怎么启动的</h1><p>参考：<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/02/booting.html</a></p><p>计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！所以启动又称为boot，”pull oneself up by one’s bootstraps”。</p><h2 id="第一阶段-BIOS"><a href="#第一阶段-BIOS" class="headerlink" title="第一阶段 BIOS"></a>第一阶段 BIOS</h2><p>开机程序被刷入ROM（”只读内存”）芯片，计算机通电后，第一件事就是读取它。芯片里的程序叫做”基本輸出輸入系統”（Basic Input/Output System），简称为BIOS。</p><h3 id="硬件自检"><a href="#硬件自检" class="headerlink" title="硬件自检"></a>硬件自检</h3><p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。</p><p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p><h3 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h3><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p><p>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p><p>打开BIOS的操作界面，里面有一项就是”设定启动顺序”。</p><h2 id="第二阶段：主引导记录"><a href="#第二阶段：主引导记录" class="headerlink" title="第二阶段：主引导记录"></a>第二阶段：主引导记录</h2><p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。</p><p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p><p>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。</p><h3 id="主引导记录的结构"><a href="#主引导记录的结构" class="headerlink" title="主引导记录的结构"></a>主引导记录的结构</h3><p>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p><p>主引导记录由三个部分组成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-26%20%E4%B8%8B%E5%8D%887.48.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。</p><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。</p><p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p><p>每个主分区的16个字节，由6个部分组成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-26%20%E4%B8%8B%E5%8D%888.00.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p><p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p><h2 id="第三阶段：硬盘启动"><a href="#第三阶段：硬盘启动" class="headerlink" title="第三阶段：硬盘启动"></a>第三阶段：硬盘启动</h2><p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p><h3 id="情况A：卷引导记录"><a href="#情况A：卷引导记录" class="headerlink" title="情况A：卷引导记录"></a>情况A：卷引导记录</h3><p>四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）。</p><p>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p><h3 id="情况B：扩展分区和逻辑分区"><a href="#情况B：扩展分区和逻辑分区" class="headerlink" title="情况B：扩展分区和逻辑分区"></a>情况B：扩展分区和逻辑分区</h3><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。</p><p>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。</p><p>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p><p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p><p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p><h3 id="情况C：启动管理器"><a href="#情况C：启动管理器" class="headerlink" title="情况C：启动管理器"></a>情况C：启动管理器</h3><p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。</p><p>Linux环境中，目前最流行的启动管理器是Grub。</p><h2 id="第四阶段：操作系统"><a href="#第四阶段：操作系统" class="headerlink" title="第四阶段：操作系统"></a>第四阶段：操作系统</h2><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p><p>以Linux系统为例，先载入_boot目录下面的kernel。内核加载成功后，第一个运行的程序是_sbin_init。它根据配置文件（Debian系统是_etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p><p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行_bin_login程序，跳出登录界面，等待用户输入用户名和密码。</p><p>至此，全部启动过程完成。</p><h1 id="冯诺依曼体系图"><a href="#冯诺依曼体系图" class="headerlink" title="冯诺依曼体系图"></a>冯诺依曼体系图</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/a8773912b31bb051973f1da5367adab44aede020.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机是怎么启动的&quot;&gt;&lt;a href=&quot;#计算机是怎么启动的&quot; class=&quot;headerlink&quot; title=&quot;计算机是怎么启动的&quot;&gt;&lt;/a&gt;计算机是怎么启动的&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;http://www.ruanyifeng.com/blog
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机科学" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="https://github.com/zdkswd/2018/12/20/TCP/"/>
    <id>https://github.com/zdkswd/2018/12/20/TCP/</id>
    <published>2018-12-20T07:19:47.000Z</published>
    <updated>2018-12-20T07:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html</a><br>《码出高效》</p><p>TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。</p><p>因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/bg20170060810.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/download_resize_jpg.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>传输控制协议（Transmission Control Protoco,TCP，是一种面向连接、确保数据在端到端间可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”完成传输。为了确保数据的可靠传输，不仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时情况下进行重传，还需要通过实线滑动窗口和拥塞控制等机制，避免网络状况恶化而最终影响数据传输的极端情形。</p><h1 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/download_resize_jpg%202.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>TCP是面向连接的，因此有服务器端和客户端之分。需要服务器端先在相应的端口上进行监听，准备好接受客户端发起的建立连接的请求。客户端发起的，目标机器端口就是服务器端所监听的端口号。比如一些由国际组织定义的广为人知的端口号——代表HTTP的80端口，代表SSH的22端口，代表HTTPS的443端口。</p><p>SYN用作建立连接时的同步信号；ACK用于对收到的数据进行确认，所确认的数据有确认序列号表示；FIN表示后面没有数据需要发送，通常意味着所建立的连接需要关闭了。</p><h1 id="TCP数据包的编号（SEQ）"><a href="#TCP数据包的编号（SEQ）" class="headerlink" title="TCP数据包的编号（SEQ）"></a>TCP数据包的编号（SEQ）</h1><p>一个包1400字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送7100多个包。</p><p>发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。</p><p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/bg2017060807.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>（图片说明：当前包的编号是45943，下一个数据包的编号是46183，由此可知，这个包的负载是240字节。）</p><h1 id="TCP数据包的组装"><a href="#TCP数据包的组装" class="headerlink" title="TCP数据包的组装"></a>TCP数据包的组装</h1><p>收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。</p><p>对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在 TCP 数据包里面，有自己的格式（比如 HTTP 协议）。</p><p>TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息Content-Length，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。</p><p>操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。</p><p>应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的Content-Length字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。</p><h1 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/1FE37517-343E-4A56-BEF8-B5D6917902CE.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>三次握手：</p><ol><li>A机器发出的一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。</li><li>B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置1。假设这个包中的序列号为y，而确认序列号必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据部分的一个字节。</li><li>A收到B的响应包后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。</li></ol><p>之所以需要三次握手是为了信息对等和防止超时。在第二次握手完成时，对B来说并不知道A收到了B的第一次回信，就是不确定A有收报的能力以及自己有发报的能力。所以需要A再一次回复来确认。而且还要防止出现请求超时导致的脏连接。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/E1B0A675-06F7-49B6-9646-D1BECC6A2F6D.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="从编程角度来看TCP连接"><a href="#从编程角度来看TCP连接" class="headerlink" title="从编程角度来看TCP连接"></a>从编程角度来看TCP连接</h1><p>从编程的角度，TCP连接的建立是通过文件描述符（FIle Descripter,fd）完成的。通过创建套接字获得一个fd，然后服务器端和客户端需要机遇所获得的fd调用不同的函数分别进入监听状态和发起连接请求。由于fd的数量将决定服务端进程所能建立连接的数量，对于大规模分布式服务来说，当fd不足时就会出现“open too many files”错误而使得无法建立更多的连接。为此，需要注意调整服务端进程和操作系统所支持的最大文件句柄数。通过使用ulimit -n命令来查看单个进程可以打开文件句柄的数目。如果想查看当前系统各进程产生了多少句柄，可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n | awk &apos;&#123;print $2&#125;&apos;| sort|uniq -c |sort -nr|more</span><br></pre></td></tr></table></figure></p><p>执行结果中左侧是句柄数，右侧是进程号。lsof命令用于查看当前系统所打开fd的数量。在Linux系统中，很多资源都是以fd的形式进行读写的，除了提到的文件和TCP连接，UDP数据报、输入输出设备等都抽象成了fd。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在linux系统中文件句柄（file handles）和文件描述符(file descriptor)是一个一一对应的关系</span><br></pre></td></tr></table></figure></p><p>想知道具体的PID对应的具体应用程序是谁，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ax|grep 32764</span><br></pre></td></tr></table></figure></p><p>TCP在协议层面支持Keep Alive功能，即隔段时间通过向对方发送数据表示连接处于健康状态。不少服务将确保连接健康的行为放到了应用层，通过定期发送心跳包检查连接的健康度。一旦心跳包出现异常不仅会主动关闭连接，还会回收与连接相关的其他用于提供服务的资源，确保系统资源最大限度地被有效利用。</p><h1 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h1><p>四次挥手。A机器想要关闭连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完数据，再主动给A机器发送FIN信号。这时，A机器处于半关闭状态（FIN_WAIT_2）,无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态（CLOSE_WAIT）。A机器发送针对B机器FIN的ACK后，进入TIME-WAIT状态，经过2MSL后，没有收到B机器传来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/106CECAD-6E10-481C-91ED-AA5B8E258E18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>TIME_WAIT</strong>和<strong>CLOSE_WAIT</strong>分别表示主动关闭和被动关闭产生的阶段性状态，如果在线上服务器大量出现这两种状态，就会加重机器负载，也会影响有效连接的创建，因此需要进行有针对性的调优处理。</p><p><strong>TIME_WAIT</strong>：主动要求关闭的机器表示收到了对方的FIN报文，并发送出ACK报文，进入TIME_WAIT状态，等2MSL后即可进入到CLOSED状态。如果FIN_WAIT_1状态下，同时收到带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p><p><strong>CLOSE_WAIT</strong>：被动要求关闭的机器收到对方请求关闭连接的FIN报文，在第一次ACK应答后，马上进入CLOSE_WAIT状态。这种状态其实表示在等待关闭，并且通知应用程序发送剩余数据，处理现场信息，关闭相关资源。</p><p>2MSL是报文在网络上生存的最长时间，超过阈值便将报文丢弃。一般来说，MSL大于TTL衰减至0的时间。在RFC793中规定MSL为2分钟。但是在当前的高速网络中，2分钟的等待时间会造成资源的极大浪费，在高并发服务器上通常会使用更小的值。不直接关闭，进入CLOSED状态的原因有如下几点：</p><ol><li>确认被动关闭方能够顺利进入CLOSED状态。假如最后一个ACK由于网络原因导致无法到达B机器，处于LAST_ACK的B机器通常“自信”地以为对方没有收到自己的FIN+ACK报文，所以会重发。A机器收到第二次的FIN+ACK报文，会重发一次ACK，并且重新计时。如果A机器收到B机器的FIN+ACK报文后，发送一个ACK给B机器，就“自私”地立马进入CLOSED状态，可能会导致B机器无法确保收到最后的ACK指令，也无法进入CLOSED状态。这是A机器不负责任的表现。</li><li>防止失效请求。这样做是为了防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。</li></ol><h1 id="编程角度看TCP断开"><a href="#编程角度看TCP断开" class="headerlink" title="编程角度看TCP断开"></a>编程角度看TCP断开</h1><p>因为TIME_WAIT状态下无法真正释放句柄资源，在此期间，Socket中使用的本地端口在默认情况下不能再被使用。该限制对于客户端机器无所谓，但对于高并发服务器来说，会极大地限制有效连接的创建数量，称为性能瓶颈。所以将高并发服务器TIME_WAIT超时时间调小。</p><p>在服务器上通过变更/ etc /sysctl.conf文件来修改该省略值（秒）：net.ipv4.tcp_fin_timeout=30(建议小于30秒为宜)。</p><p>修改完之后执行/ sbin / sysctl -p让参数生效即可。可通过如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a,S[a]&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>查看各连接状态的计数情况。</p><p>在sysctl.conf中还有其他连接参数也用来不断地调优服务器TCP连接能力，以提升服务器的有效利用率。毕竟现代网络和路由器处理能力越来越强，跨国时延通常也在1s以内，丢包率极低。如何快速地使用连接资源被释放和复用，参数的优化往往可以取得事半功倍的效果。记得某大公司在大型购物节时，系统宕机，老总下令要加一倍的服务器来解决问题。事实上，如果是参数配置错误导致的系统宕机，即使增加硬件资源，也无法达到好的效果。硬件的增加与性能的提升绝对不是线性相关的，更多的时候是对数曲线关系。</p><p>TIME_WAIT是挥手四次断开连接的尾声，如果此状态连接过多，则可以通过优化服务器参数得到解决。如果不是对方连接的异常，一般不会出现连接无法关闭的情况。</p><p>CLOSE_WAIT过多很可能是程序自身的问题，如果在对方关闭连接后，程序没有检测到，或者忘记自己关闭连接。在某次故障中，外部请求出现超时的情况，当时的Apache服务器使用的是默认的配置方式，通过命令： netstat -ant|grep -i “443”|grep CLOSE_WAIT|wc -1发现在HTTPS的443端口堆积了2.1万个左右的CLOSE_WAIT状态。经排查发现，原来是某程序处理完业务逻辑后没有释放流操作，但程序一直运行正常，直到运营活动时才大量触发该业务逻辑，最终导致故障的产生。</p><h1 id="慢启动和ACK"><a href="#慢启动和ACK" class="headerlink" title="慢启动和ACK"></a>慢启动和ACK</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/2010101120591634.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/2010101123101842.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。</p><p>最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。</p><p>TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p><p>Linux 内核里面设定了（常量TCP_INIT_CWND），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。</p><p>默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。</p><p>ACK 携带两个信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-20%20%E4%B8%8A%E5%8D%889.13.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为”发送窗口”，这个窗口的大小是可变的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/bg2017060809.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>（图片说明：每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量。双方都会发送 ACK。）</p><p>注意，由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/bg2017060812.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>（图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。）</p><p>即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。</p><h1 id="数据包的遗失处理"><a href="#数据包的遗失处理" class="headerlink" title="数据包的遗失处理"></a>数据包的遗失处理</h1><p>TCP 协议可以保证数据通信的完整性，这是怎么做到的？</p><p>前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。</p><p>举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。</p><p>如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/TCP/bg2017060811.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>（图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2017/0
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议  SSL/TLS协议 HTTPS</title>
    <link href="https://github.com/zdkswd/2018/12/19/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/zdkswd/2018/12/19/HTTP协议  SSL:TLS协议/</id>
    <published>2018-12-19T12:12:47.000Z</published>
    <updated>2018-12-25T04:21:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>已修改<br>参考<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门 - 阮一峰的网络日志</a><br>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p><h1 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.11.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.12.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>服务器发送完毕，就关闭TCP连接。</p><h1 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p><p>HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><p>下面是一个1.0版的HTTP请求的例子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.19.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。</p><h2 id="回应格式"><a href="#回应格式" class="headerlink" title="回应格式"></a>回应格式</h2><p>服务器的回应如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.21.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>回应的格式是”头信息 + 一个空行（ \ r \ n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p><h2 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h2><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.25.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。除了预定义的类型，厂商也可以自定义类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.27.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的类型表明，发送的是Debian系统的二进制数据包。<br>MIME type还可以在尾部使用分号，添加参数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.28.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.34.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码中，客户端声明自己可以接受任何格式的数据。<br>MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.35.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h2><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.36.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.37.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.39.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.39.19%202.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h1 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h1><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.43.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h2><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h2 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h2><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.47.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用Content-Length字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.56.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%886.57.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.06.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h1 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h1><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p><h2 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h2><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h2 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h2><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个<strong>数据流</strong>（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h2 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h2><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><h1 id="SSL-TLS协议运行机制的概述"><a href="#SSL-TLS协议运行机制的概述" class="headerlink" title="SSL/TLS协议运行机制的概述"></a>SSL/TLS协议运行机制的概述</h1><p>互联网的通信安全，建立在SSL/TLS协议之上。<br>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.40.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.40.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p><strong>如何保证公钥不被篡改？</strong><br>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><p><strong>公钥加密计算量太大，如何减少耗用的时间？</strong><br>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p><p>因此，SSL/TLS协议的基本过程是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.51.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面过程的前两步，又称为”握手阶段”（handshake）。</p><p><strong>握手阶段的详细过程</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/bg2014020502.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。</p><p>第一步，<strong>客户端（通常是浏览器）先向服务器发出加密通信的请求</strong>，这被叫做<strong>ClientHello</strong>请求。在这一步，客户端主要向服务器提供以下信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.55.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p><p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p><p>第二步，<strong>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%887.59.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p><p>第三步，<strong>客户端回应</strong>。客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%888.04.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>至于为什么一定要用三个随机数，来生成”会话密钥”<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%888.07.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><p>第四步，<strong>服务器的最后回应</strong>，服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/HTTP%E5%8D%8F%E8%AE%AE%20%20SSL:TLS%E5%8D%8F%E8%AE%AE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%888.08.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><p>HTTPS 要比 HTTP 多用多少服务器资源？里面还有关于SSL握手的各步需要的原因以及解释<br><a href="https://www.zhihu.com/question/21518760/answer/19698894" target="_blank" rel="noopener">https://www.zhihu.com/question/21518760/answer/19698894</a></p><h1 id="码出高效HTTPS"><a href="#码出高效HTTPS" class="headerlink" title="码出高效HTTPS"></a>码出高效HTTPS</h1><p>对称加密算法，比如DES。<br>访问一个HTTPS的网站流程如下：</p><ol><li>浏览器向服务器发送请求，请求中包括浏览器支持的协议，并附带一个随机数。</li><li>服务器收到请求后，选择某种非对称加密算法，把数字证书签名公钥、身份信息发送给浏览器，同时也附带一个随机数。</li><li>浏览器收到后，验证证书的真实性，用服务器的公钥发送握手信息给服务器。</li><li>服务器解密后，使用之前的随机数计算出一个对称加密的秘钥，以此作为加密信息并发送。</li><li>后续所有的信息发送都是以对称加密方式进行的</li></ol><p>TLS和SSL的区别。TLS可以理解成SSL协议3.0版本的升级，所以TLS的1.0版本也被标识为SSL3.1版本。但对于大的协议栈而言，SSL和TLS并没有太大的区别，因此在Wireshark里，分层依然用的是安全套接字（SSL） 标识。</p><p>在整个HTTPS的传输过程中，主要分两个部分：首先是HTTPS的握手，然后是数据的传输。前者是建立一个HTTPS的通道，并确定连接使用的加密套件及数据传输使用的秘钥。而后者主要使用秘钥对数据加密并传输。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>第一，客户端发送了一个Client Hello协议的请求：在Client Hello中最重要的信息是Cipher Suites字段，这里客户端会告诉服务端自己支持哪些加密的套件。</p><p>第二，服务端在收到客户端发来的Client Hello的请求后，会返回一系列的协议数据，并以一个没有数据内容的Server Hello Done作为结束。这些协议数据有的是单独发送，有的是合并发送。这里解释几个比较重要的协议。<br>（1）Server Hello协议。主要告知客户端后续协议中要使用的TLS协议版本，这个版本主要和客户端与服务器端支持的最高版本有关。并为本次连接分配一个会话ID（Session ID）。此外，还会确认后续采用的加密套件（Cipher Suite），比如加密套件为TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256。该加密套件的基本含义为：使用非对称协议加密（RSA）进行对称协议加密（AES）密钥的加密，并使用对称加密协议（AES）进行信息的加密。<br>（2）Certificate协议。主要传输服务端的证书内容。<br>（3）Server Key Exchange。如果在Certificate协议中未给出客户端足够的信息，则会在Server Key Exchange进行补充。比如在连接中Certificate未给出证书的公钥（Public Key），这个公钥的信息将会通过Server Key Exchange送给客户端。<br>（4）Certificate Request。这个协议是一个可选项，当服务端需要对客户端进行证书验证时，才会向客户端发送一个证书请求（Certificate Request）。<br>（5）最后以Server Hello Done作为结束信息，告知客户端整个Server Hello过程结束。</p><p>第三，客户端在收到服务端的握手信息后，根据服务端的请求，也会发送一系列的协议。<br>（1）Certificate。可选项。上文中服务端发送了Certificate Request需要对客户端进行证书验证，所以客户端要发送自己的证书信息。<br>（2）Client Key Exchange。它与上文中Server Key Exchange类似，是对客户端Certificate信息的补充，在本次请求中同样是补充了客户端证书的公钥信息。<br>（3）Certification Verity。对服务端发送的证书信息进行确认。<br>（4）Change Cipher Spec。该协议不同于其他握手协议（Handshake Protocol）,而是作为一个独立协议告知服务端，客户端已经接受之前服务端确认的加密套件，并会在后续通信中使用该加密套件进行加密。<br>（5）Encrypted Handshake Message。用于客户端给服务端加密套件加密一段Finish的数据，用以验证这条建立起来的加解密通道的正确性。</p><p>第四，服务端在接受客户端的确认信息及验证信息后，会对客户端发送的数据进行确认，这里也分为几个协议进行回复。<br>（1）Change Cipher Spec。通过使用私钥对客户端发送的数据进行解密，并告知后续将使用协商好的加密套件进行加密传输数据。<br>（2）Encrypted Handshake Message。与客户端的操作相同，发送一段Finish的加密数据验证加密通道的正确性。</p><p>最后，如果客户端和服务端都确认加解密无误后，各自按照之前约定的Session Secret对Application Data进行加密传输。</p><h1 id="解析HTTP协议六种请求方法"><a href="#解析HTTP协议六种请求方法" class="headerlink" title="解析HTTP协议六种请求方法"></a>解析HTTP协议六种请求方法</h1><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。</p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。<br>增加一个朋友，uri: generalcode.cn/v1/friends 接口类型：POST<br>删除一个朋友，uri: generalcode.cn/va/friends 接口类型：DELETE<br>修改一个朋友，uri: generalcode.cn/va/friends 接口类型：PUT<br>查找朋友，uri: generalcode.cn/va/friends 接口类型：GET<br>上面我们定义的四个接口就是符合REST协议的，请注意，这几个接口都没有动词，只有名词friends，都是通过Http请求的接口类型来判断是什么业务操作。</p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li>GET与POST都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ol><h1 id="HTTP中Cookie"><a href="#HTTP中Cookie" class="headerlink" title="HTTP中Cookie"></a>HTTP中Cookie</h1><p>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。</p><h2 id="cookie存在哪"><a href="#cookie存在哪" class="headerlink" title="cookie存在哪"></a>cookie存在哪</h2><p>Cookie是存在硬盘上，  IE存cookie的地方和Firefox存cookie的地方不一样。  不同的操作系统也可能存cookie的地方不一样。不同的浏览器会在各自的独立空间存放Cookie, 互不干涉。不同的网站会有不同的cookie文件。</p><p>浏览器把cookie通过HTTP Request 中的“Cookie: header”发送给Web服务器。<br>Web服务器通过HTTP Response中的”Set-Cookie: header”把cookie发送给浏览器。</p><h2 id="网站自动登陆的原理"><a href="#网站自动登陆的原理" class="headerlink" title="网站自动登陆的原理"></a>网站自动登陆的原理</h2><p>以”博客园自动登陆“的例子，来说明cookie是如何传递的。大家知道博客园是可以自动登陆的。假如我已经在登陆页面输入了用户名，密码，选择了保存密码，登陆。<br>下次访问博客园流程如下。</p><ol><li>用户打开IE浏览器，在地址栏上输入<a href="http://www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com</a>.</li><li>IE首先会在硬盘中查找关于cnblogs.com的cookie. 然后把cookie放到HTTP Request中，再把Request发给Web服务器。</li><li>Web服务器返回博客园首页（你会看到你已经登陆了）。</li></ol><h2 id="截获Cookie，冒充别人身份"><a href="#截获Cookie，冒充别人身份" class="headerlink" title="截获Cookie，冒充别人身份"></a>截获Cookie，冒充别人身份</h2><p>通过上面这个例子，可以看到cookie是很重要的，识别是否是登陆用户，就是通过cookie。  假如截获了别人的cookie是否可以冒充他人的身份登陆呢。  当然可以， 这就是一种黑客技术叫Cookie欺骗。利用Cookie 欺骗， 不需要知道用户名密码。就可以直接登录，使用别人的账户做坏事。</p><p>有两种方法可以截获他人的cookie</p><ol><li>通过XSS脚步攻击， 获取他人的cookie.</li><li>想办法获取别人电脑上保存的cookie文件（这个比较难）</li></ol><p>拿到cookie后，就可以冒充别人的身份了。</p><p>cookie和文件缓存，这两个完全是不一样的东西。唯一的相同之处可能是它们俩都存在硬盘上，而且是存在同一个文件夹下。Cookies是当你浏览某网站时，由Web服务器置于你硬盘上的一个非常小的文本文件，它可以记录你的用户ID、密码、浏览过的网页、停留的时间等信息。</p><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>分为请求报文和响应报文。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/add/21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已修改&lt;br&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/08/http.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 协议入门 - 阮一峰的网络日志&lt;/a&gt;&lt;br&gt;HTTP 协议是互联
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>互联网协议复习</title>
    <link href="https://github.com/zdkswd/2018/12/19/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/"/>
    <id>https://github.com/zdkswd/2018/12/19/互联网协议复习/</id>
    <published>2018-12-19T11:55:47.000Z</published>
    <updated>2018-12-19T09:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p><h1 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052902.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h1><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p>这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h1 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p><h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052904.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>一块网卡怎么会知道另一块网卡的MAC地址？有一种ARP协议，可以解决这个问题。</p><p>有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052907.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的由来"><a href="#网络层的由来" class="headerlink" title="网络层的由来"></a>网络层的由来</h2><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052914.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，<strong>使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p><p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052908.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”<strong>子网掩码</strong>“（subnet mask）。</p><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><h2 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h2><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为”标头”和”数据”两个部分。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052909.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052910.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。</p><p>我们需要一种机制，能够从IP地址得到MAC地址。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层的由来"><a href="#传输层的由来" class="headerlink" title="传输层的由来"></a>传输层的由来</h2><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”标头”和”数据”两部分组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052911.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052912.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p>“应用层”的作用，就是规定应用程序的数据格式。</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012052913.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="网关转发"><a href="#网关转发" class="headerlink" title="网关转发"></a>网关转发</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061101.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是，于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%889.55.55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。</strong></p><h1 id="用户的上网设置"><a href="#用户的上网设置" class="headerlink" title="用户的上网设置"></a>用户的上网设置</h1><h2 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a>静态IP地址</h2><p>一个电脑想要上网需要填入以下的内容：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%885.22.39.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p><p>这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p><h2 id="动态IP地址"><a href="#动态IP地址" class="headerlink" title="动态IP地址"></a>动态IP地址</h2><p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做<strong>DHCP协议</strong>。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p>如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定。</p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>首先，它是一种<strong>应用层协议</strong>，建立在UDP协议之上，所以整个数据包是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061102.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。<br>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。<br>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><h1 id="访问网页"><a href="#访问网页" class="headerlink" title="访问网页"></a>访问网页</h1><h2 id="本机参数"><a href="#本机参数" class="headerlink" title="本机参数"></a>本机参数</h2><p>假定用户设置好了网络参数：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%885.32.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>想要访问Google，在地址栏输入了网址：<a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a><br>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a href="http://www.google.com，不知道它的IP地址。" target="_blank" rel="noopener">www.google.com，不知道它的IP地址。</a></p><p><strong>DNS协议</strong>可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061105.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061106.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>HTTP部分的内容，类似于下面这样：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%20%E4%B8%8B%E5%8D%885.39.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><h2 id="TCP协议-1"><a href="#TCP协议-1" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h2 id="IP协议-1"><a href="#IP协议-1" class="headerlink" title="IP协议"></a>IP协议</h2><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><h2 id="以太网协议-1"><a href="#以太网协议-1" class="headerlink" title="以太网协议"></a>以太网协议</h2><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/bg2012061107.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a>服务器端响应</h2><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyif
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="计算机网络" scheme="https://github.com/zdkswd/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C C++程序的构筑过程</title>
    <link href="https://github.com/zdkswd/2018/12/18/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://github.com/zdkswd/2018/12/18/C C++程序的构筑过程/</id>
    <published>2018-12-18T10:13:56.000Z</published>
    <updated>2018-12-18T10:14:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-程序的构筑过程"><a href="#C-C-程序的构筑过程" class="headerlink" title="C C++程序的构筑过程"></a>C C++程序的构筑过程</h1><p>参考：<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a><br>源码要运行，必须先转成二进制的机器码。这是编译器的任务。<br>如源码test.c<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.21.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要编译器处理一下才能运行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.23.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于复杂的项目，编译过程还必须分成三步。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.23.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/bg2014110803.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="第一步-配置（configure）"><a href="#第一步-配置（configure）" class="headerlink" title="第一步 配置（configure）"></a>第一步 配置（configure）</h2><p>编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。</p><p>这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。</p><p>configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。</p><h2 id="第二步-确定标准库和头文件的位置"><a href="#第二步-确定标准库和头文件的位置" class="headerlink" title="第二步 确定标准库和头文件的位置"></a>第二步 确定标准库和头文件的位置</h2><p>源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。</p><p>编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</p><h2 id="第三步-确定依赖关系"><a href="#第三步-确定依赖关系" class="headerlink" title="第三步 确定依赖关系"></a>第三步 确定依赖关系</h2><p>对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.35.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。</p><p>在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。</p><h2 id="第四步-头文件的预编译"><a href="#第四步-头文件的预编译" class="headerlink" title="第四步 头文件的预编译"></a>第四步 头文件的预编译</h2><p>不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。</p><p>不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。</p><h2 id="第五步-预处理（Preprocessing）"><a href="#第五步-预处理（Preprocessing）" class="headerlink" title="第五步 预处理（Preprocessing）"></a>第五步 预处理（Preprocessing）</h2><p>预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.41.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。</p><p>这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。</p><h2 id="第六步-编译（Compilation）"><a href="#第六步-编译（Compilation）" class="headerlink" title="第六步 编译（Compilation）"></a>第六步 编译（Compilation）</h2><p>预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。</p><p>下面是本文开头的那段源码转成的汇编码。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C%20C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E7%AD%91%E8%BF%87%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%884.42.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种转码后的文件称为对象文件（object file）。</p><h2 id="第七步-连接（Linking）"><a href="#第七步-连接（Linking）" class="headerlink" title="第七步 连接（Linking）"></a>第七步 连接（Linking）</h2><p>对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。</p><p>编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。</p><p>make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。</p><h2 id="第八步-安装（Installation）"><a href="#第八步-安装（Installation）" class="headerlink" title="第八步 安装（Installation）"></a>第八步 安装（Installation）</h2><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。</p><p>表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。</p><h2 id="第九步-操作系统连接"><a href="#第九步-操作系统连接" class="headerlink" title="第九步 操作系统连接"></a>第九步 操作系统连接</h2><p>可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。</p><p>这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在 / usr/ share/ applications目录下的.desktop文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。</p><p>这些事情就叫做”操作系统连接”。make install命令，就用来完成”安装”和”操作系统连接”这两步。</p><h2 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h2><p>写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。</p><p>所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。</p><h2 id="动态连接（Dynamic-linking）"><a href="#动态连接（Dynamic-linking）" class="headerlink" title="动态连接（Dynamic linking）"></a>动态连接（Dynamic linking）</h2><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。</p><p>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。</p><p>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-C-程序的构筑过程&quot;&gt;&lt;a href=&quot;#C-C-程序的构筑过程&quot; class=&quot;headerlink&quot; title=&quot;C C++程序的构筑过程&quot;&gt;&lt;/a&gt;C C++程序的构筑过程&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;http://www.ruanyifen
      
    
    </summary>
    
      <category term="知识总结" scheme="https://github.com/zdkswd/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 函数 内存 名称空间</title>
    <link href="https://github.com/zdkswd/2018/12/18/C++%20Primer%20%E5%87%BD%E6%95%B0%20%E5%86%85%E5%AD%98%20%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/"/>
    <id>https://github.com/zdkswd/2018/12/18/C++ Primer 函数 内存 名称空间/</id>
    <published>2018-12-18T07:07:56.000Z</published>
    <updated>2019-01-07T06:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>定义函数:</strong><br>分为有返回值函数和无返回值函数。<br>void：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%888.56.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>有返回值：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-12%20%E4%B8%8B%E5%8D%889.00.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C++对于返回值的类型有一定的限制:不能是数组，但可以是其他任何类型，如整数、浮点数、指针，甚至可以是结构和对象(有趣的是，虽然C++函数不能直接返回数组，但可以将数组作为结构或对象组成部分来返回)。</p><p>通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。<br> <strong>函数原型和函数调用</strong><br> <strong>为什么需要原型:</strong><br>原型描述了函数到编译器的接口，即，将函数的返回值类型（如果有的话）以及参数的类型和数量告诉编译器。<br> <strong>原型的句法:</strong><br>函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.36.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在函数原型中不要求提供变量名，有类型列表就足够了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.37.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。<br><strong>原型的功能:</strong><br>原型可以帮助编译器完成许多工作，可以极大地降低程序出错的几率，具体说，原型确保：</p><ol><li>编译器正确处理函数返回值。</li><li>编译器检查使用的参数数目是否正确。</li><li>编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型（如果可能的话）。</li></ol><p>静态类型检查可捕获许多在运行阶段非常难以捕获的错误。</p><h2 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h2><p>C++使用参数（argument）来表示实参，使用参量（parameter）来表示形参。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%8812.54.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.07.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。arr实际上并不是数组，而是一个指针。在编写函数的其余部分时，可以将arr看作是数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.09.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中使用int * arr 替换了int arr [] 。这证明这两个函数头都是正确的，因为在C++中，当(且仅当)用于函数头或函数原型中，int * arr 和int arr[ ]的含义才是相同的。它们都意味着arr是一个int指针。不过，数组表示法(int arr[]) 提醒用户，arr 不仅指向int, 还指向int数组的第一个int。当指针指向数组的第一个元素时， 本书使用数组表示法;而当指针指向一个独立的值时，使用指针表示法。 别忘了，在其他的上下文中，int * arr和int arr[]的含义并不相同。例如， 不能在函数体中使用int tip[ ]来声明指针。<br>两个恒等式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.14.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型长度相等的值。对于遍历数组而言，使用指针加法和数组下标是等效的。</p><h3 id="将数组作为参数意味着什么"><a href="#将数组作为参数意味着什么" class="headerlink" title="将数组作为参数意味着什么"></a>将数组作为参数意味着什么</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.21.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将数组地址作为参数可以节省复制整个数组所需的时间和内存。 如果数组很大，则使用拷贝的系统开销将非常大;程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。可以使用const来解决这个问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%881.25.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h3><p>对于处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C、C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供了找到所有数据所需的信息。</p><p>还有另一种给两数提供所需信息的方法，即指定元素区间(range), 这可以通过传递两个指针来完成:一个指针标识数组的开头，另一个指针标识数组的尾部。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>可以用两种不同的方式将const用于指针。第一种是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值。第二种是将指针本身声明为常量，这样可以防止改变指针指向的位置。<br>指向常量的指针pt:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.51.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt 指向age, 而age不是const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它。</p><p>可以将const变量的地址赋给指向const的指针，但不能将const地址赋给常规指针。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%882.56.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.03.53.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>上述函数调用试图将const指针赋给非const指针，编译器将禁止这种函数调用。</p><p>第二种使用const的方式使得无法修改指针的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.12.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>关键字const的位置与之前不同。这种声明格式使得finger只能指向sloth,但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。</p><h2 id="函数和二维数组"><a href="#函数和二维数组" class="headerlink" title="函数和二维数组"></a>函数和二维数组</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.25.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>data是一个数组名，该数组有3个元素。每个元素都是数组，由4个int值组成。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.22.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="函数和C-风格字符串"><a href="#函数和C-风格字符串" class="headerlink" title="函数和C-风格字符串"></a>函数和C-风格字符串</h2><h3 id="将c-风格字符串作为参数的函数"><a href="#将c-风格字符串作为参数的函数" class="headerlink" title="将c-风格字符串作为参数的函数"></a>将c-风格字符串作为参数的函数</h3><p>假设要将字符串作为参数传递给函数，表示字符串的方式有3种：</p><ol><li>char数组。</li><li>用引号括起的字符串常量。</li><li>被设置为字符串的地址的char指针</li></ol><p>3种选择的类型都是char指针（即char * ），可将其作为字符串处理函数的参数。字符串函数原型应将其表示字符串的形参声明为char * 指针。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%883.31.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="返回C-风格字符串的函数"><a href="#返回C-风格字符串的函数" class="headerlink" title="返回C-风格字符串的函数"></a>返回C-风格字符串的函数</h3><p>函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。</p><p>要创建包含n个字符的字符串，需要能够存储n+1个字符的空间，以便能够存储空值字符。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>分为以下三个步骤。</p><h3 id="获取函数地址"><a href="#获取函数地址" class="headerlink" title="获取函数地址"></a>获取函数地址</h3><p>获取函数的地址很简单，只要使用函数名（后面不跟参数）即可。一定要区分传递的是函数的地址还是函数的返回值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.06.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="声明函数指针"><a href="#声明函数指针" class="headerlink" title="声明函数指针"></a>声明函数指针</h3><p>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.10.57.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>提示:通常，要声明指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用( * pf)替换函数名，这样pf就是这类函数的指针。</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.15.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>正确地声明pf后，便可以将对应函数的地址赋给它：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.17.30.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="使用指针来调用函数"><a href="#使用指针来调用函数" class="headerlink" title="使用指针来调用函数"></a>使用指针来调用函数</h3><p>使用指针来调用被指向的函数。（ * pf）扮演的角色与函数名相同，因此使用（ * pf）时，只需将它看做函数名即可。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.24.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C++进行了折衷，这2种方式都是正确的。</p><h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><p>内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。</p><p>内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，然后再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数的10个代码拷贝。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%884.40.38.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>要使用这项特性，必须采用下述措施之一：</p><ol><li>在函数声明前加关键字inline。</li><li>在函数定义前加上关键字inline。</li></ol><p>程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己(内联函数不能递归)，因此不将其作为内联函数;而有些编译器没有启用或实现这种特性。</p><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>C和C++使用&amp;符号来指示变量的地址。C++给&amp;符号赋了了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.00.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中,  &amp; 不是地址操作符，而是类型标识符的一部分。就像声明中的char * 指的是指向char的指针一样,int  &amp; 指的是指向int的引用。</p><p>看似引用和指针用法很类似，其实是有差别的，差别之一是，必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%885.05.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>引用更接近const指针，鼻血在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.18.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%886.39.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="引用的属性和特别之处"><a href="#引用的属性和特别之处" class="headerlink" title="引用的属性和特别之处"></a>引用的属性和特别之处</h3><h4 id="临时变量、引用参数和const"><a href="#临时变量、引用参数和const" class="headerlink" title="临时变量、引用参数和const"></a>临时变量、引用参数和const</h4><p>如果实参与引用参数不匹配，C++将生成临时变量。仅当参数为const引用时，C++才允许这样做。</p><p>如果引用参数时const，则编译器将在下面两种情况下生成临时变量：</p><ol><li>实参的类型正确，但不是左值。</li><li>实参的类型不正确，但可以转换为正确的类型。</li></ol><p>左值参数时可被引用的数据对象，例如，变量、数组元素、结构成员、引用和被解除引用的指针都是左值。非左值包括字面常量和包含多项的表达式。</p><p>记住:如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p><h3 id="应尽可能使用const"><a href="#应尽可能使用const" class="headerlink" title="应尽可能使用const"></a>应尽可能使用const</h3><p>将引用参数声明为常量数据的引用的理由有3个:</p><ol><li>使用const可以避免无意中修改数据的编程错误。</li><li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据。</li><li>使用const引用使函数能够正确生成并使用临时变量。</li></ol><p>因此，应尽可能将引用形参声明为const。</p><h3 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>引用非常适合用于结构和类(C++的用户定义类型).确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。</p><h3 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h3><p>使用引用参数的主要原因有两个：</p><ol><li>程序员能够修改调用函数的数据对象。</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li></ol><p>当数据对象较大时(如结构和类对象),第二个原因最重要。这些也是使用指针参数的原因。这是有道理的,因为引用参数实际上是基于指针的代码的另一个接口。</p><p>指导原则<br>对于使用传递的值而不作修改的函数:</p><ol><li>如果数据对象很小,如内置数据类型或小型结构,则按值传递。</li><li>如果数据对象是数组,则使用指针,因为这是惟一的选择,并将指针声明为指向 const的指针。</li><li>如果数据对象是较大的结构,则使用 const指针或 const引用,以提高程序的效率。这样可以节省复制结构所需的时间和空间。</li><li>如果数据对象是类对象,则使用 const引用。类设计的语义常常要求使用引用,这是C+新增这项特性的主要原因。因此,传递类对象参数的标准方式是按引用传递。</li></ol><p>对于修改调用函数中数据的函数。</p><ol><li>如果数据对象是内置数据类型，则使用指针。</li><li>如果数据对象是数组，则只能使用指针。</li><li>如果数据对象是结构， 则使用引用或指针。</li><li>如果数据对象是类对象，则使用引用。</li></ol><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边所有的参数提供默认值：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.40.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>实参按从左到右的顺序依次被賦给相应的形参，而不能跳过任何参数。下面的调用是不允许的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%887.43.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>默认参数不是编程方面的重大突破，而只是提供了一种便捷的方式。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>所数重载的关键是函数的参数列表一也称为函数特 征标( function signature). 如果两个函数的参数数目和类型相同， 同时参数的排列顺序也相同，则它们的特征标相同， 而变量名是无关紧要的。C++ 允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和或参数类型不同，则特征标也不同。</p><p>一些看起来彼此不同的特征标是不能共存的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.15.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>为避免混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。</p><h3 id="何时使用函数重载"><a href="#何时使用函数重载" class="headerlink" title="何时使用函数重载"></a>何时使用函数重载</h3><p>函数重载很吸引人，但也不能滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时才应采用函数重载。</p><p>使用一个带默认参数的函数要简单些。只需编写一个函数(而不是两个函数)，程序也只需为一个函数(而不是两个)请求内存:需要修改函数时，只需修改一个。不过，如果需要使用不同类型的参数时，则默认参数便不管用了， 在这种情况下，应该使用函数重载。</p><h3 id="名称修饰"><a href="#名称修饰" class="headerlink" title="名称修饰"></a>名称修饰</h3><p>使用C++开发工具中的编辑器编写和编译程序时，C++将执行一些神奇的操作，名称修饰或名称矫正。根据函数原型中指定的形参类型对每个函数名进行加密。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板是通用的函数描述，就是使用通用类型来定义函数，其中的通用类型可用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.44.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>建立一个模板，将类型命名为Any。关键字template和class是必需的，类型名可以任意选择。关键字typename可用来替换关键字class，就是说可以编写模板定义：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.46.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>提示: 如果需要多个将同一种算法用于不同类型的函数，请使用模板，如果不考虑向后兼容的问题，并愿意键入较长的单词, 则声明类型参数时，应使用关键字typename而不使用class。</strong></p><h3 id="重载的模板"><a href="#重载的模板" class="headerlink" title="重载的模板"></a>重载的模板</h3><p>需要多个对不同类型使用同一种算法的函数时，可使用模板。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%888.54.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h3><p>在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。模板并非函数定义，但使用int的模板实例是函数定义。这种实例化方式被称为隐式实例化，因为编译器之所以知道需要进行定义，是由于程序调用Swap（）函数时提供了int参数。</p><p>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，C++还允许显示实例化。这意味着可以直接命令编译器创建特定的实例，Swap<int>()。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.26.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>显示具体化使用下面两个等价声明之一：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-16%20%E4%B8%8B%E5%8D%889.40.36.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>显示具体化声明在关键字Template后包含&lt;&gt;，而显式实例化没有。</int></p><p><strong>警告：试图在同一个编程单元中使用同一类型的显示实例和显示具体化将出错。</strong></p><p>实例化就是不用单独的再有个实现了，具体化是还要有一个单独的实现。</p><p>隐式实例化、显式实例化和显式具体化统称为具体化(specialization)。 它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。</p><h1 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h1><p>C++为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据（作用域和链接）等。可以使用new来动态地分配内存而布局new操作符提供了这种技术的一种变种。C++名称空间是另一种控制访问权的方式。通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据。这样的程序涉及到程序文件的单独编译。</p><h2 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h2><p>和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。可以单独编译这些文件，然后将它们链接成可执行的程序(通常，C++编译器既编译程序，也管理链接器)。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。另外，大多数C++环境都提供了其他工具来帮助管理。例如，UNIX和Linux系统都具有make程序，可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序所需的步骤。</p><p>可以将原来的程序分为三部分：</p><ol><li>头文件：包含结构声明和使用这些结构的函数的原型</li><li>源代码文件：包含与结构有关的函数的代码。</li><li>源代码文件：包含调用与结构相关的函数的代码。</li></ol><p>不要将函数定义或变量声明放到头文件中。例如，如果在头文件包含—个函数定义，然后在其他两个文件(属于同一个程序)中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数是内联的， 否则这将出错。</p><p>下面列出了头文件中常包含的内容:</p><ol><li>函数原型</li><li>使用# define或const定义的符号常量</li><li>结构声明</li><li>类声明</li><li>模板声明</li><li>内联函数</li></ol><p>模板声明不是将被编译的代码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。被声明为const的数据和内联函数有特殊的链接属性，因此可将其放在头文件而不会引起问题。</p><p>注意，在包含头文件时，<br>我们使用“coordin.h”,而不是&lt; coodin.h &gt;。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找:但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录(或其他目录，这取决于编译器)。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用引号而不是尖括号。</p><p>在IDE中，不要将头文件加入到工程列表中，也不要在源代码文件中使用# include 来包含其他源代码文件。</p><h3 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h3><p>在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。例如， 可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef(即if not defined)的。下面的代码片段:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8810.57.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>意味着仅当以前没有使用预处理器编译指令# define定义名称COORDIN_H_时，才处理# ifndef和# endif之间的语句。</p><p>通常，使用# define语句来创建符号常量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.01.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>但只要将# define用于名称，就足以完成该名称的定义。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8A%E5%8D%8811.01.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>编译器首次遇到该文件时，名称COORDIN_H_没有定义（我们根据include文件名来选择名称，并加一些下划线，以创建一个在其他地方不太可能被定义的名称）。如果在同一个文件中遇到其他包含coordin.h的代码，编译器将知道COORDIN_H_已经被定义了，从而跳到# endif后面的一行上。这种方法并不能防止编译器将文件包含两次，而只是让它忽略了第一次包含之外的所有内容。大多数标准C和C++头文件都使用这种防护(guarding)方案。</p><h2 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h2><h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的名称，可在文件间共享，连接性为内部的名称，只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它不能共享。</p><h3 id="作用域和链接"><a href="#作用域和链接" class="headerlink" title="作用域和链接"></a>作用域和链接</h3><p>作用域（scope）描述了名称在文件的多大范围内可见。链接性(linkage) 描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。</p><h3 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h3><p>在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动， 作用域为局部，没有链接性。当程序开始执行这些变量所属的代码块时，将为其分配<br>内存;当函数结束时，这些变量都将消失(注意，执行到代码块时，将为变量分配内存， 但其作用域的起点为其声明位置)。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.50.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以使用C++ (和C)关键字auto 来显式地指出存储类别:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%8812.52.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="自动变量和堆栈"><a href="#自动变量和堆栈" class="headerlink" title="自动变量和堆栈"></a>自动变量和堆栈</h4><p>由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。常用的方法是<strong>留出一段内存，并将其视为堆栈</strong>，以管理变量的增减。之所以被称为堆栈，是由于新数据被象征性地放在原有数据的上面(也就是说，在相邻的内存单元中，而不是在同一个内存单元中)，当程序使用完后，将其从堆栈中删除。堆栈的默认长度取决于实现，但编译器通常提供改变堆栈长度的选项。程序使用两个指针来跟踪堆栈，一个指针指向栈底即堆栈的开始位置，另一个指针指向堆顶即下一个可用内存单元。当函数被调用时，其自动变量将被加入到堆栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p><p>堆栈是后进先出的，即最后加入到堆栈中的变量首先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.05.02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以说形参存在于堆栈。堆栈是内存留出的一小段。</p><h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>和C语言一样，C++也支持使用register关键字来声明局部变量。寄存器变量是另一种形式的自动变量，因此其存储持续性为自动，作用域为局部，但没有链接性。关键字register提醒编译器，用户希望它通过使用CPU寄存器，而不是堆栈来处理特定的变量，从而提供对变量的快速访问。这里的理念是，CPU访问寄存器中的值的速度比访问堆栈中内存快。要声明寄存器变量，请在类型前加上关键字register:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%881.11.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>现代编译器已经足够聪明，在编写for循环时，编译器可能自动使用寄存器来存储循环计数。</p><p>如果变量被存储在寄存器则没有内存地址，因此不能讲地址操作符用于寄存器变量。</p><p>简而言之，常规局部变量、使用auto 声明的局部变量以及使用register 声明的局部变量的存储持续性都是自动的， 作用域都是局部的，也都没有链接性。</p><p>声明局部变量时，如果没有使用说明符，则与使用auto声明变量等效。通常， 处理这种变量的方式是将其放置到内存堆栈中。使用register说明符指出该变量将被频繁使用，编译器可能会选择使用内存堆栈之外的其他方式(如使用CPU寄存器)来存储它。</p><h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><p>和C语言一样，C++也为静态存储持续性变量提供了3种链接性:外部链接性、内部链接性和无链接性。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置(如堆栈)来管理它们。<strong>编译器将分配固定的内存块来存储所有的静态变量</strong>，<strong>这些变量在整个程序执行期间一直存在</strong>。另外， 如果没有显式地初始化静态变量，编译器就将把它<strong>设置为0</strong>。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。</p><p>要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它; 要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符:要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.37.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所有静态持续变量在整个程序执行期间都存在。在funct1（）中声明的变量count的作用域为局部，没有链接性，这意味着只能在funct1（）函数中使用它，就像自动变量一样，但不同之处在于，即使函数没有执行时，count也留在内存中。global和one_file的作用域为整个文件，即在从声明位置到文件结尾的范围内都可以被使用。由于one_file的链接性为内部，因此只能在包含上述代码的文件中；由于global的链接性为外部，因此可以在程序的其他文件中使用它。</p><p>所有静态持续变量只能使用常量表达式来初始化静态变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%885.54.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言都是外部的。外部变量也称为全局变量。如果定义了与外部变量同名的自动变量，该自动变量将隐藏同名的外部变量。</p><p>关键字extern的意思是“通过以前被外部定义的名称使用该变量”。外部变量声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.12.05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>称为定义声明，给该变量分配存储空间。重新声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.13.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>称为引用声明，或简称为声明。它不给变量分配存储空间，因为它引用已有的变量。只能在引用其他地方（或函数）定义的变量的声明中使用关键字extern。当试图赋值时将会报错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.23.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>仅当声明将为变量分配存储空间时（即定义声明），才能在声明中初始化变量。毕竟，初始化指的是在分配内存单元时给它赋值。</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>过多使用全局变量会破坏数据的完整性，外部存储尤其适于表示常量数据，因为这样可以使用关键字const来防止数据被修改。</p><h3 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h3><p>对于外部链接变量，有且只有一个文件中包含了该变量的外部定义，其他文件要使用该变量，必须在引用声明中使用关键字extern。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果文件试图定义另一个同名的外部变量将出错：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.37.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%886.39.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="静态存储持续性、无连接性"><a href="#静态存储持续性、无连接性" class="headerlink" title="静态存储持续性、无连接性"></a>静态存储持续性、无连接性</h3><p>如果初始化了静态局部变量，则程序只在启动时进行一次初始化，以后再调用函数时，将不会像自动变量那样再次被初始化。</p><h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><p>存储说明符：</p><ol><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li></ol><p>在同一个声明中不能使用多个说明符。mutable 是为了突破 const 的限制而设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态，即使是 const 函数中也可以改变这个变量的值。</p><p>cv限定符：</p><ol><li>const</li><li>volatile(易变的，不稳定的)</li></ol><p><strong>volatile</strong>关键字表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。听起来似乎很神秘，实际上并非如此。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。在这种情况下，硬件(而不是程序)可能修改其中的内容。或者两个程序可能互相影响，共享数据。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile, 则编译器将进行这种优化;将变量声明为volatile,相当于告诉编译器，不要进行这种优化。避免出现和想象结果不一致的情况。</p><h3 id="再谈const"><a href="#再谈const" class="headerlink" title="再谈const"></a>再谈const</h3><p>在C++中，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，在C++看来， 全局const定义就像使用了static说明符一样。（就链接性而言）</p><p>内部链接还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量。每个定义都是共所属文件私有的，这就是能够将常量定义放在头文件中的原因。这样，只要在两个源代码文件中包括同一个头文件，则它们将获得同一组常量。</p><p>如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.09.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种情况下，必须在所有使用该常量的文件中使用extem关键字来声明它。这与常规外部变量不同，定义常规外部变量时，不必使用extem关键字，但在使用该变量的其他文件中必须使用extem。</p><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><p>C++不允许在一个函数中定义另一个函数，因此所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。可以在函数原型中使用关键字extern来指出函数时再另一个文件中定义的，不过这是可选的（要让程序在另一个文件中查找函数， 该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件)。还可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义汇总使用该关键字。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-17%20%E4%B8%8B%E5%8D%889.31.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这意味着该函数以在这个文件中可见，还意味着可以在其他文件中定义同名的的函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。</p><p>C++有一个“单定义规则”，即对于每个非内联函数，程序中只能包含一个定义。对于链接性为外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。</p><p>内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定义。不过，C++要求同一个函数的所有内联定义都必须相同。</p><h3 id="C-在哪里查找函数"><a href="#C-在哪里查找函数" class="headerlink" title="C++在哪里查找函数"></a>C++在哪里查找函数</h3><p>如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义;否则， 编译器(包括链接程序)将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。<br>如果在程序文件中没有找到， 编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数， 编译器将使用程序员定义的版本， 而不是库函数(不过，C++保留了标准库函数的名称，即程序员不应使用它们).一些编译器-链接程序要求显式地指出要搜索哪些库。</p><h3 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h3><p>另一种形式的链接性称为语言链接性，也对函数有影响。链接程序要求每个不同的函数都有不同的符号名。在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。例如， 可能将spiff (int)转换为_spof_i,而将spiff (double, double) 转换为_spif_d_d.这种方法被称为C++语言链接(C++ language linkage)。</p><p>链接程序寻找与C++函数调用匹配的函数时，使用的方法与c语言不同。但如果要在c++程序中使用C库中预编译的函数，将出现什么情况呢?例如，假设有下面的代码:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.53.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它在C库文件中的符号名称为_spif, 但对于我们假设的链接程序来说，C++查询约定是查找符号名称_spiff_ i。为解决这种问题，可以用函数原型来指出要使用的约定:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%888.54.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第一个原型使用C语言链接性:而后面的两个使用C+语言链接性。第二个原型是通过默认方式指出这一点的，而第三个显式地指出了这一点。</p><h3 id="存储方案和动态分配"><a href="#存储方案和动态分配" class="headerlink" title="存储方案和动态分配"></a>存储方案和动态分配</h3><p>与自动内存不同，动态内存不是LIFO,其分配和释放顺序要取决于new和delete 在何时以何种方式被使用。通常，<strong>编译器使用3块独立的内存:一块用于静态变量(可能再细分)，一块用于自动变量， 另外一块用于动态存储。</strong></p><p>如果将p_fees的链接性声明为外部的，则文件中位于该声明后面的所有函数都<br>可以使用它。另外，通过在另一个文件中使用：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.13.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以在这个文件中使用该指针。不过，请注意， 使用new来设置p_ fees 的语句必须位于函数中(如下面的代码段所示)，这是因为只能使用常量表达式来初始化静态存储变量:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.14.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.15.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注意: 在程序结束时，由new分配的内存通常都将被释放，不过情况也并不总是这样。例如,在不那么健壮的操作系统中，在某些情况下，请求大型内存块将导致该代码块在程序结束不会被自动释放。最佳的做法是， 使用delete 来释放new分配的内存。</strong></p><h2 id="布局new操作符"><a href="#布局new操作符" class="headerlink" title="布局new操作符"></a>布局new操作符</h2><p>new负责在<strong>堆(heap)</strong> 中找到一个足以能够满足要求的内存块。new操作符还有另一种变体，被称为布局(placement)new操作符，它能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程或处理需要通过特定地址进行访问的硬件。要使用布局new特性，首先需要包含头文件new。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.25.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>它提供了new操作符原型，下面是new操作符的四种用法：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8A%E5%8D%889.26.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中如果buffer是静态存储区，那么就new到了静态存储区。而常规new就到了动态管理的堆中。</p><p>由于buffer指定的内存是静态内存，而delete只能指向常规new操作符分配的堆内存，就是说数组buffer位于delete的管辖区域之外。</p><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>当随着工程的增大，名称相互冲突的可能性也将增加。使用多个厂商的类库时，可能导致名称冲突。C++标准提供了名称空间工具，以便更好地控制名称的作用域。</p><h3 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h3><p>几个概念：<br><strong>声明区域</strong>(declaration region)。 声明区域是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块。</p><p><strong>潜在作用域</strong>。变量的潜在作用域从声明点开始,到其声明域的结尾。因此潜在作用域比声明区域小,这是由于变量必须定义后才能使用。</p><h3 id="新的名称空间特性"><a href="#新的名称空间特性" class="headerlink" title="新的名称空间特性"></a>新的名称空间特性</h3><p>C++新增了这样一种功能,即通过定义一种新的声明区域来创建命名的名称空间,这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突,同时允许程序的其他部分使用该名称空间中声明的东西。例如,下面的代码使用新的关键字 namespace创建了两个名称空间:Jack和Jill。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.09.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>名称空间可以是全局的,也可以位于另一个名称空间中,但不能位于代码块中。因此,在默认情况下,在名称空间中声明的名称的链接性为外部的(除非它引用了常量)</p><p>除了用户定义的名称空间外，还存在另一个名称空间一全局名称空间(global namespace)。 它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。</p><p>任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。</p><p>当然, 需要有一种方法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析操作符::,使用名称空间来限定该名称。未被装饰的名称(如pail)被称为未限定的名称(unqualifed name);包含名称空间的名称(如Jack;pail)被称为限定的名称(qualified name).</p><h4 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h4><p>如果不希望每次使用名称都使用：：，C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。using声明使特定的表示符可用，using编译指令使整个名称空间可用。</p><p>using声明由限定的名称和它前面的关键字using组成：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.24.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>using编译命令使所有的名称都可用。using编译命令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析操作符：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%881.32.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="using编译指令和using声明值比较"><a href="#using编译指令和using声明值比较" class="headerlink" title="using编译指令和using声明值比较"></a>using编译指令和using声明值比较</h4><p>使用using编译指令导入一个名称空间中所有的名称与使用using声明是不一样的，而更像是大量使用作用域解析操作符。使用 using声明时,就好像声明了相应的名称一样。如果某个名称已经在函数中声明了,则不能用 using声明导入相同的名称。然而,使用 using编译指令时,将进行名称解析,就像在包含 using声明和名称空间本身的最小声明区域中声明了名称一样。在下面的范例中,名称空间为全局的。如果使用 using编译指令导入一个已经在函数中声明的名称,则局部名称将隐藏名称空间名,就像隐藏同名的全局变量样。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.11.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一般来说，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p><h4 id="名称空间的其他特性"><a href="#名称空间的其他特性" class="headerlink" title="名称空间的其他特性"></a>名称空间的其他特性</h4><p>可以将名称空间声明进行嵌套。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.39.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里flame指的是element:: fire  ::flame。</p><h4 id="未命名的名称空间"><a href="#未命名的名称空间" class="headerlink" title="未命名的名称空间"></a>未命名的名称空间</h4><p>可以通过省略名称空间的名称来创建未命名的名称空间：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-18%20%E4%B8%8B%E5%8D%882.48.41.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不能再未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称，因此这种方法可以替代链接性为内部的静态变量。</p><h3 id="名称空间的指导原则"><a href="#名称空间的指导原则" class="headerlink" title="名称空间的指导原则"></a>名称空间的指导原则</h3><ol><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li><li>如果开发了一个函数库或类库，将其放在一个名称空间中。</li><li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。（其实若冲突IDE中会报含糊不清错误）</li><li>不要在头文件中使用using 编译指令。首先，这样做掩盖了要让哪些名称可用;另外， 包含头文件的顺序可能影响程序的行为。 如果非要使用编译指令using,应将其放在所有预处理器编译指令#include之后。</li><li>导入名称时， 首选使用作用域解析操作符或using声明的方法。</li><li>对于using声明，首选将其作用域设置为局部而不是全局。</li></ol><p>对于简单程序，使用using编译指令并非什么大逆不道的事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义函数:&lt;/strong&gt;&lt;br&gt;分为有返回值函数和无返回值函数。&lt;br&gt;void：&lt;br&gt;&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 数据 语句</title>
    <link href="https://github.com/zdkswd/2018/12/18/C++%20Primer%20%E6%95%B0%E6%8D%AE%20%E8%AF%AD%E5%8F%A5/"/>
    <id>https://github.com/zdkswd/2018/12/18/C++ Primer 数据 语句/</id>
    <published>2018-12-18T07:06:56.000Z</published>
    <updated>2019-01-06T07:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始学习C"><a href="#开始学习C" class="headerlink" title="开始学习C++"></a>开始学习C++</h1><h2 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h2><p>通常main()被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统的桥梁。</p><p>C++必修包含一个名为main()的函数，大小写拼写都要正确。如果没有main(),程序将不完整，编译器将指出未定义main()函数。</p><p>存在一些例外情况。例如,在 Windows编程中,可以编写一个动态链接库(DLL)模块,这是其他 Windows程序可以使用的代码。由于DLL模块不是独立的程序,因此不需要 main （）。</p><p>C++注释 （/ / ）以及（/ <em> 和 </em> /）</p><h3 id="C-预处理器和iostream文件"><a href="#C-预处理器和iostream文件" class="headerlink" title="C++预处理器和iostream文件"></a>C++预处理器和iostream文件</h3><p>C++和C一样,也使用一种预处理器,该程序在进行主编译之前对源文件进行处理(有些C++实现使用翻译器程序将C++程序转换为C程序。虽然翻译器也是一种预处理器,但这里不讨论这种预处理器,而只讨论处理名称以 # 开头的编译指令的预处理器)。不必执行任何特殊的操作来调用该预处理器,它会在编译程序时自动运行。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.31.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>实际上，iostream文件的内容将取代程序中的代码行# include &lt; iostream&gt;。原始文件没有被修改，而是将源代码文件和iostream组合成一个复合文件，编译的下一阶段将使用该文件。</p><h3 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%889.37.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>像iostream这样的文件由于它们被包含在其他文件中叫做包含文件(include file)；由于它们被包含在文件起始处，也叫头文件(header file)。C++编译器自带了很多头文件，每个头文件都支持一组特定的工具。</p><p>C++的用法发生了变化。现在,对老式C的头文件保留了扩展名h(C++程序仍可以使用这种文件),而C++头文件则没有扩展名。有些C头文件被转换为C++头文件,这些文件被重新命名,去掉了扩展名h(使之成为C++风格的名称),并在文件名称前面加上前缀c(表明来自C语言)。例如,C++版本的math.h为 cmath头文件。有时C头文件的C版本和C++版本相同,而有时候新版本做了些修改。对于纯粹的C++头文件(如 iostream)来说,去掉h不只是形式上的变化,没有h的头文件也可以包含名称空间。</p><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.07.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这叫做using编译指令。</p><p>名称空间支持是C++中一项较新的特性,它是为了使编写将多个厂商已有的代码组合起来的程序更简单而设计的。一个潜在的问题是:可能使用两个已封装好的产品,而它们都包含一个名为 wanda()的函数。这样,使用 wanda函数时,编译器将不知道指的是哪个版本。名称空间让厂商能够将其产品封装在一个叫做名称空间的单元中,这样就可以用名称空间的名称来指出想使用哪个厂商的产品。因此, Microflop Industries可以将其定义放到一个名为 Microflop的名称空间中。这样,其 wanda函数的全称为Microflop:: wanda():同样, Piscine公司的 wandao版本可以表示为 Piscine: :wanda()。这样,程序就可以使用名称空间来区分不同的版本了:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8810.16.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>iostream是C++的标准库，标准库都被放置在命名空间std（standard）中。仅当头文件没有扩展名h时，情况才这样，也就是采用c++的新式风格，即采用了名称空间。头文件为.h由于没有采用名称空间，所以在采用不同库时，是存在命名冲突的风险的，没办法，自己想办法解决吧；）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言与c++，C语言确实是最底层，但是语法不完善，开发效率很低，c++就是为了解决某些问题才诞生的。</span><br><span class="line">鸡先生蛋还是蛋先生鸡，许多语言的编译都是c写的，那么c语言的编译器又是谁写的呢。</span><br><span class="line">1970年Tomphson和Ritchie在BCPL（一种解释型语言）的基础上开发了B语言，1973年又在B语言的基础上成功开发出了现在的C语言。在C语言被用作系统编程语言之前，Tomphson也用过B语言编写过操作系统。可见在C语言实现以前，B语言已经可以投入实用了。因此第一个C语言编译器的原型完全可能是用B语言或者混合B语言与PDP汇编语言编写的。我们现在都知道，B语言的执行效率比较低，但是如果全部用汇编语言来编写，不仅开发周期长、维护难度大，更可怕的是失去了高级程序设计语言必需的移植性。所以早期的C语言编译器就采取了一个取巧的办法：先用汇编语言编写一个C语言的一个子集的编译器，再通过这个子集去递推完成完整的C语言编译器。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编译器为什么会生成汇编语言而不是机器语言？</span><br><span class="line">1)其中有一个好处是方便优化，因为，编译器也是工具，也是机器，毕竟是机器生成的程序，不可以非常 完美的,而汇编是机器指令的助记符，一个汇编指令就对应一条机器指令（特殊指令除外）调试起来肯定会比 机器指令方便的方便，这样优化起来也方便。</span><br><span class="line">2)高级语言只需要编译成汇编代码就可以了,汇编代码到机器码的转换是由硬件实现即可,有必要用软件实 现这样分层可以有效地减弱编译器编写的复杂性,提高了效率.就像网络通讯的实现需要分成很多层一样,主要 目的就是为了从人脑可分析的粒度来减弱复杂性.</span><br><span class="line">3)如果把高级语言的源代码直接编译成机器码的话，那要做高级语言到机器码之间的映射,如果这样做的 话，每个写编译器的都必须熟练机器码。这个不是在做重复劳动么。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8A%E5%8D%8811.16.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>c++在使用函数前需要有函数声明，有了函数声明还要有函数定义。c++不允许将函数定义嵌套在另一个函数定义中。每个函数定义都是独立的，所有函数<br>的创建都是平等的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%885.31.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>int main（）时return 0将返回值返回给了操作系统。例如。UNIX外壳脚本和DOS批处理文件都被设计成运行程序。很多操作系统都可以使用程序的返回值（通常也叫退出值）。通常的约定是，退出值为0则意味着程序运行成功，为非0则意味着存在问题。因此，如果c++程序无法打开文件，可以将它设计为返回一个非零值。然后，便可以设计一个外壳脚本或批处理文件来运行该程序，如果程序发出指示失败的消息，则采取其他措施。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.06.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><h3 id="short、int和long"><a href="#short、int和long" class="headerlink" title="short、int和long"></a>short、int和long</h3><p>如果在所有的系统中，每种类型的宽度都相同，则使用起来将非常方便。但是生活并非那么简单，C++提供了一种灵活的标准，它确保了最小长度（从C语言借鉴而来）：</p><ol><li>short至少16位</li><li>int至少和short一样长。</li><li>long至少32位，且至少与int一样长。</li></ol><p>当前很多系统都使用最小长度,即shot为16位,long为32位。这仍然为int提供了多种选择,其宽度可以是16位、24位或32位,同时又符合标准。通常,在老IMPC的实现中,int的宽度为16位(与short相同),而在 Windows98、 Windows nt、 Windows XP、 Macintosh OS X、VAX和很多其他微型计算机的实现中,为32位(与long相同)。有些实现允许选择如何处理int类型的宽度随实现而异,这可能在将C艹程序从种环境移到另…种环境时引发问题。但只要小心一点就可以最大限度地减少这种问题。</p><p>实际上，<strong>short是short int的简称，而long是long int的简称。</strong>这三种类型（int,short和long）都是符号类型，意思是有一位的符号位。</p><p>sizeof操作符返回类型或变量的长度，单位为字节。头文件 climits(在老式实现中为 limits h)中包含了关于整型限制的信息。具体地说,它定义了表示各种限制的符号名称。例如, INT_MAX为int的最大取值, CHAR_BIT为字节的位数。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%886.46.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="符号常量—预处理器方式"><a href="#符号常量—预处理器方式" class="headerlink" title="符号常量—预处理器方式"></a>符号常量—预处理器方式</h3><p> # define编译指令是C语言遗留下来的。C艹有一种更好的创建符号常量的方法(使用关键字 const）,所以不会经常使用 # define。不过,有些头文件,尤其是那些被设计成可用于C和C艹中的头文件,必须使用 # define</p><h3 id="无符号类型"><a href="#无符号类型" class="headerlink" title="无符号类型"></a>无符号类型</h3><p>要创建无符号版本的基本整形，只需要使用关键字unsigned来修改声明即可：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.15.40.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>climits文件与limits.h文件；老式编译器可能需要使用文件limits.h，有些非常老的编译器可能根本没有这两个文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.19.03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="选择整型的类型"><a href="#选择整型的类型" class="headerlink" title="选择整型的类型"></a>选择整型的类型</h3><p>通常,int被设置为对目标计算机而言最为“自然”的长度。自然长度( natural size)指的是计算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其他类型,则应使用int。</p><p>如果知道变量可能表示的整数值大于16位整数的最大可能值,则使用long。即使系统上int为32位也应这样做。这样,当程序移植到16位的系统中时,程序就不会突然无法正常工作。</p><p>如果 short比int小,则使用 short可以节省内存。通常,仅当有大型整型数组时,才有必要使用 short(数组是一种数据结构,在内存中连续存储同类型的多个值)。如果节省内存很重要,则应使用 short而不是使用int,即使它们的长度是一样的。例如,假设要将程序从int为16位的 DOS PC系统移到int为32位的Windows XP系统,则用于存储int数组的内存量将加倍,但 short数组不受影响。记住,节省一点是一点。如果只需要一个字节，可使用char。</p><h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>十进制，八进制，十六进制。不管书写为10、012还是0xA，都将以相同的方式存储在计算机中—被存储为二进制数。</p><h3 id="C-如何确定常量的类型"><a href="#C-如何确定常量的类型" class="headerlink" title="C++如何确定常量的类型"></a>C++如何确定常量的类型</h3><p>程序将把常量1492存储为int、long还是其他整型呢?答案是,除非有理由存储为其他类型(如使用了特殊的后缀来表示特定的类型,或者值太大,不能存储为int),否则C++将整型常量存储为int类型。</p><p>首先来看看后缀。后缀是放在数字常量后面的字母,用于表示类型。整数后面的1或L后缀表示该整数为long常量,u或U后缀表示 unsigned int常量,ul(可以采用任何一种顺序,大写小写均可)表示 unsigned long常量(由于小写1看上去像1,因此应使用大写L作后缀)。例如,在int为16位、long为32位的系统上,数字22022被存储为int,占16位,数字2022L被存储为long,占32位。同样,22022LU和2202UL都被存储为 unsigned long。</p><p>接下来考察长度。在C艹中,对十进制整数采用的规则,与十六进制和八进制稍微有些不同。对于不带后缀的十进制整数,将使用下面几种类型中能够存储该数的最小类型来表示:int、long或 unsigned long。在int为16位、long为32位的计算机系统上,20000表示为int类型,40000被表示为long类型,3000000被表示为 unsigned long类型。对于不带后缀的十六进制或八进制整数,将使用下面几种类型中能够存储该数的最小类型来表示;int、 unsigned int、long或 unsigned long。在将40000表示为long的计算机系统中,六进制数Ox9C40(40000.将被表示为 unsigned int这是因为十六进制常用来表示内存地址,而内存地址是没有符号的,因此unsigned int比long更适合用来表示16位的地址。</p><h3 id="char类型：字符和小整数"><a href="#char类型：字符和小整数" class="headerlink" title="char类型：字符和小整数"></a>char类型：字符和小整数</h3><p>顾名思义，char类型是专为存储类型（如字母和数字）而设计的。编程语言通过字母的数值编码解决了字母的存储问题。因此，char类型是另一种整型（所以可以加1）。它足够长，能够表示目标计算机系统中所有基本符号—所有的字母、数字、标点符号等。实际上，多数系统所支持的字符都不超过256种，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以将它用做比short更小的整型。在美国，最常用的符号集是ASCII字符集，不过不能很好的满足国际需要，c++支持的宽字符类型可以存储更多的值，如国际Unicode字符集使用的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.53.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%887.55.44.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="wcha-t"><a href="#wcha-t" class="headerlink" title="wcha_t"></a>wcha_t</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.01.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%888.34.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>提示:如果读者在学习C艹之前学习过C语言,并打算使用 # define来定义符号常量,请不要这样做,而应使用 const。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="书写浮点数"><a href="#书写浮点数" class="headerlink" title="书写浮点数"></a>书写浮点数</h3><p>第一种是标准小数点表示法12.34。第二种表示浮点值的方法叫做E表示法3.45E(e)6</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>C++也有3种浮点类型float、double和long double。这些类型是按它们可以表示的有效位数和允许的指数最小范围来描述的。有效位是数字中有意义的位。事实上,C和C++对于有效位数的要求是,foat至少32位, double至少48位,且不少于float, long double至少和 double样多。这种类型的有效位数可以一样多。不过,通常foat为32位, double为64位,long double为80、96或128位。另外,这3种类型的指数范围至少是-37到37。可以从头文件cfloat或 float. h中找到系统的限制( float是C语言的 float h文件的C++版本)。</p><h3 id="浮点数的优缺点"><a href="#浮点数的优缺点" class="headerlink" title="浮点数的优缺点"></a>浮点数的优缺点</h3><p>与整数相比,浮点数有两大优点。首先,它们可以表示整数之间的值。其次,由于有缩放因子,它们可以表示的范围大得多。另一方面,浮点运算的速度比整数运算慢,至少在没有数学协处理器的计算机上是如此,而且精度将降低。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.00.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="C-算术操作符"><a href="#C-算术操作符" class="headerlink" title="C++算术操作符"></a>C++算术操作符</h2><h3 id="操作符优先级和结合性"><a href="#操作符优先级和结合性" class="headerlink" title="操作符优先级和结合性"></a>操作符优先级和结合性</h3><h3 id="除法分支"><a href="#除法分支" class="headerlink" title="除法分支"></a>除法分支</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.03.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="求模操作符"><a href="#求模操作符" class="headerlink" title="求模操作符"></a>求模操作符</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++自动执行很多类型转换：</p><ol><li>将一种算术类型的值赋给另一种算术类型的变量时，c++将对值进行转换。</li><li>表达式中包含不同的类型时，C++将对值进行转换。</li><li>将参数传递给函数时，C++将对值进行转换。<h4 id="赋值时进行的转换"><a href="#赋值时进行的转换" class="headerlink" title="赋值时进行的转换"></a>赋值时进行的转换</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.24.49.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>将0赋值给bool变量时，将被转换为false，而非零值将被转换为true。<h4 id="表达式中的转换"><a href="#表达式中的转换" class="headerlink" title="表达式中的转换"></a>表达式中的转换</h4>当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换：首先，一些类型在出现时便会自动转换。其次，有些类型在与其他类型同时出现在表达式中将被转换。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-20%20%E4%B8%8B%E5%8D%889.32.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>还有其他些整型提升: 如果short比int短，则unsigned short 类型将被转换为int;如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。这种规则确保了在对unsigned short进行提升时不会损失数据。</li></ol><p>同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_ t 取值范围的类型: int. unsigned int、long或unsigned long.</p><p>将不同类型进行算术运算时， 也会进行一些转换，例如将int和float相加时。当运算涉及到两种类型时，较小的类型将破转换为较大的类型。例如，程序清单3.11中的程序用9.0除以5。 由于9.0的类型为double, 因此程序在用5除之前，将5转换为double类型。总之，编译器通过校验表来确定在算术表达式<br>中执行的转换。下面是一一个列表， 编译器将依次查阅该列表:<br>①如果有一个操作数的类型是long double, 则将另一个操作数转换为long double.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.28.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>ANSI C遵循的规则与C++相同，但传统K&amp;R C的规则稍有不同。例如，传统C语言总是将float提升为double,即使两个操作数都是float。</p><h4 id="传递参数时转换"><a href="#传递参数时转换" class="headerlink" title="传递参数时转换"></a>传递参数时转换</h4><p>传递参数时的类型转换通常由C++函数原型控制。不过,也可以取消原型对参      数传递的控制,尽管这样做并不明智。在这种情况下,C++将对char和 short类型( signed和 unsigned)应用整型提升。另外,为保持与传统C语言中大量代码的兼容性,在将参数传递给取消原型对参数传递控制的函数时,C+将float参数提升为 double。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>C++还允许通过强制类型转换机制显式地进行类型转换，强制类型转换的格式有两种。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.40.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>第一种格式来自C语言,第二种格式是纯粹的C++。新格式的想法是,要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。</p><h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>计算机在内存中依次存储数组的各个元素。数组中的每一个元素可以看做一个简单变量。要创建数组，可使用声明语句，应指出三点。</p><ol><li>存储在每个元素中的值的类型</li><li>数组名</li><li>数组中的元素数</li></ol><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.47.20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>表达式arraySize指定元素数目，它必须是整型常数(如10)或const值，也可以是常量表达式(如8*sizeof (in)),即其中所有的值在编译时都是已知的。具体地说，arraySize 不能是变量，变量的值是在程序运行时设置的。不过，可以使用new操作符来避开这种限制。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.50.58.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="数组的初始化规则"><a href="#数组的初始化规则" class="headerlink" title="数组的初始化规则"></a>数组的初始化规则</h3><p>只有在定义数组时才能使用初始化，此后就不能使用了， 也不能将一 个数组赋给另一个数组:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-28%20%E4%B8%8B%E5%8D%889.55.23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>不过， 可以使用下标分别给数组中的元素赋值。<br>初始化数组时，提供的值可以少于数组的元素数目。如果只对数组的部分进行初始化， 则编译器将把其他元素设置为0。<br>如果初始化数组时方括号内([])为空，C++编译器将计算元素个数。</p><p>通常，让编译器计算元素个数是一种很糟的做法，因为其计数可能与您想象的不一样。不过，这种方法对于将字符数组初始化为一个字符串来说比较安全。<br>C++标准模板库（STL）一种数组替代品—模板类vector，它比内置复合类型数组更复杂，也更灵活。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是存储在内存的连续字节中的一系列字符。C++处理字符串有两种方式。一，来自C语言，被称为C-风格字符串，还有一种就是基于string类库的方法。</p><p>存储在连续字节中的一-系列字符意味着可以将字符串存储在char数组中，每个字符都位于自己的数组元素中。C风格具有一种特殊的性质，以空字符结尾，空字符被写作\ 0 ，其ASCII码为0，用来标记字符串的结尾。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.35.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这两个数组都是char数组，但只有第二个数组是子符串。空子符对C-风格子付事心后里大里安。例如，C++有很多处理字符串的函数，其中包括cout使用的那些函数。它们都逐个地处理字符串中的字符， 直到到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示前4个字符，发现空字符后停止。但是，如果使用cout显示上面的dog数组(它不是字符串)，cout 将打印出数组中的5个字母，并接着将内存中随后的各个字节解释为要打印的字符，直到遇到空字符为止。由于空字符(实际上是被设置为0的字节)在内存中很常见，因此这一过程将很快停止。但尽管如此，还是<strong>不应将不是字符串的字符数组当作字符串来处理</strong>。</p><p>有一种更好地将字符数组初始化为字符串的方法，使用用引号括起来的字符串<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.39.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>用引号括起的字符串隐式地包括结尾的空字符,因此不用显式地包括它。</p><p>应确保数组足够大,能够存储字符串中所有字符包括空字符。使用字符串常量初始化字符数组是这样的一种情况,即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处,只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置,而不是数组长度来进行处理。C++对字符串长度没有限制。<br>记住：在确定存储字符串所需的最短数组时，记得将结尾的空字符计算在内。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.45.19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>注意</strong>,字符串常量(使用双引号)不能与字符常量(使用单引号)互换。字符常量(如S)是字符串编码的简写表示。在ASCⅡ系统上,S只是83的另一种写法。因此,下面的语句:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%883.49.06.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>是将内存地址赋给变量。</p><h3 id="拼接字符串常量"><a href="#拼接字符串常量" class="headerlink" title="拼接字符串常量"></a>拼接字符串常量</h3><p>任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.08.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\ 0 )后面。第一个字符串的\ 0 字符将会被第二个字符串的第一个字符取代。</p><h3 id="在数组中使用字符串"><a href="#在数组中使用字符串" class="headerlink" title="在数组中使用字符串"></a>在数组中使用字符串</h3><p>要将字符串存储到数组中，最常用的方法有两种，一是将数组初始化为字符串常量、二将键盘或文件输入读入数组中。</p><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>cin</p><h3 id="每次读取一行字符串输入"><a href="#每次读取一行字符串输入" class="headerlink" title="每次读取一行字符串输入"></a>每次读取一行字符串输入</h3><h4 id="面向行的输入：getline"><a href="#面向行的输入：getline" class="headerlink" title="面向行的输入：getline()"></a>面向行的输入：getline()</h4><p>getline()函数读取整行,它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法,可以使用 cin. getline()。该函数有两个参数。第一个参数是用来存储输入行的数组的名称,第二个参数是要读取的字符数。</p><h4 id="面向行的输入：get"><a href="#面向行的输入：get" class="headerlink" title="面向行的输入：get()"></a>面向行的输入：get()</h4><h3 id="混合输入字符串和数字"><a href="#混合输入字符串和数字" class="headerlink" title="混合输入字符串和数字"></a>混合输入字符串和数字</h3><p>混合输入数字和面向行的字符串会导致问题。</p><h2 id="string类简介"><a href="#string类简介" class="headerlink" title="string类简介"></a>string类简介</h2><p>string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表示方法。</p><p>要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，需要提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，可以像处理普通变量那样处理字符串。</p><h3 id="赋值、拼接和附加"><a href="#赋值、拼接和附加" class="headerlink" title="赋值、拼接和附加"></a>赋值、拼接和附加</h3><p>使用 string类时,某些操作比使用数组时更简单。例如,不能将一个数组赋给另一个数组,但可以将个 string对象赋给另一个string对象。string类简化的字符串合并操作。可以使用操作符+将两个string对象合并起来,还可以使用操作符+      =一个字符串附加到个 string对象的末尾。</p><h3 id="string类的其他操作"><a href="#string类的其他操作" class="headerlink" title="string类的其他操作"></a>string类的其他操作</h3><p>在C艹新增 string类之前,程序员也需要完成诸如给字符串赋值等工作。对于C语言式的字符串,程序员使用C语言库中的函数来完成这些任务。头文件cstring(以前为 string. h)提供了这些函数。例如,可以使用函数 strcpy()将字符串复制到字符数组中,使用函数 strcat()将字符串附加到字符数组末尾:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.51.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="string类I-O"><a href="#string类I-O" class="headerlink" title="string类I/O"></a>string类I/O</h3><p>正如读者知道的,可以使用cin和操作符&lt;&lt;来将输入存储到 string对象中,使用cout和操作符&gt;&gt;来显示 string对象,其句法与处理C-风格字符串相同。但每次读取一行而不是一个单词时,使用的句法不同。</p><h2 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%884.58.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.50.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>C++运行在声明结构变量时省略关键字struct。<br>可以使用成员操作符（.）来访问各个成员。访问类成员函数的方式也是类似的。</p><h3 id="在程序中使用结构"><a href="#在程序中使用结构" class="headerlink" title="在程序中使用结构"></a>在程序中使用结构</h3><p>结构声明的位置很重要。可以将声明放在main()函数中，紧跟在开始括号的后面，另一种选择是将声明放在main()的前面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%886.57.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>C++不提倡使用外部变量但提倡使用外部结构声明。<br>初始化结构：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.11.22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当然也可以把它们放在同一行中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.13.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="结构可以将string类作为成员吗"><a href="#结构可以将string类作为成员吗" class="headerlink" title="结构可以将string类作为成员吗"></a>结构可以将string类作为成员吗</h3><p>大体上说，答案是肯定的。</p><h3 id="其他结构属性"><a href="#其他结构属性" class="headerlink" title="其他结构属性"></a>其他结构属性</h3><p>C++使用户定义的类型与内置类型尽可能相似。例如， 可以将结构作为参数传递给函数, 也可以让函数返同—个结构。另外，还可以使用赋值操作符(=) 将结构賦给另一个同类型的结构， 这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值。</p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.19.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="结构中的位字段"><a href="#结构中的位字段" class="headerlink" title="结构中的位字段"></a>结构中的位字段</h3><p>与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整型或枚举(稍后将介绍),接下来是冒号，冒号后面是一一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段(bit field)。下面是一个例子:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.23.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.27.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>位字段通常用在低级编程中。</p><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体（union）是一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时存储int、long和double,共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。<br>声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.32.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以使用one4all变量来存储int、long或double，条件是在不同的时间进行：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.34.24.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>因此，pail 有时可以是int变量，而有时义可以是double变量。成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。在存储了double后int值就丢失了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.38.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%887.57.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>由于共用体是匿名的，因此id_ num和id_ char被视为prize 的两个成员，它们的地址相同，所以不需要中间标识符id_ val。程序员负责确定当前哪个成员是活动的。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。使用enum的句法与使用结构相似。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.00.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这条语句完成两项工作：<br>第一让spectrum称为新类型的名称，spectrum被称为枚举，就像struct变量被称为结构一样。<br>第二将red,orange,yellow等作为符号常量，它们对应整数值0-7.这些常量叫做枚举量。<br>可以用枚举名来声明这种类型的变量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.07.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.11.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于枚举，只定义了赋值操作符，具体说就是没有为枚举定义算术运算：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.12.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>对于最后一个式子<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.18.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>枚举时整型，可被提升为Int类型，但int类型不能自动转换为枚举类型：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.16.46.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>枚举的规则相当严格，实际上，枚举更常被用来定义相关的符号常量，而不是新类型。如果打算只使用常量而不创建枚举类型的变量，则可以省略枚举类型的名称。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.21.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="设置枚举量的值"><a href="#设置枚举量的值" class="headerlink" title="设置枚举量的值"></a>设置枚举量的值</h3><p>可以使用赋值操作符来显示地设置枚举量的值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.22.43.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>指定的值必须是整数。 也可以只显式地定义其中一些枚举量的值:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.23.07.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里，first在默认情况下为0，后面没有被初始化的枚举量的值将比其前面的枚举量大1，因此，third的值为101。<br>还可以创建多个值相同的枚举量：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.27.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在早期版本中，只能将int值（或提升为int的值）赋给枚举量，现在这种限制已经取消了，因此可以使用long类型的值。</p><h3 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h3><p>最初，对于枚举来说，只有声明中指出的那些值是有效的。不过，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围(range)， 通过强制类型转换， 可以将取值范围中的任何整数值赋给枚举变量， 即使这个值不是枚举值。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.30.45.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>则如下代码将是合法的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.31.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>其中6不是枚举值，但它位于枚举定义的取值范围中。<br>取值范围的定义如下。首先， 要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1, 得到的便是取值范围的上限。例如， 前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0,则取值范围的下限为0;否则，采用与寻找上限方式相同的方式， 但加上负号。例如， 如果最小的枚举量为-6， 而比它小的、最大的2的幂是-8 (加上负号)，因此下限为-7。</p><p>选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举,使用一个字节或更少的空间而对于包含long类型值的枚举,则使用4个字节。</p><h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><p>指针是一个变量，其存储的是值的地址而不是值本身，对变量应用地址操作符（&amp;）就可以获得它的位置，如home是一个变量，则&amp;home是它的地址。</p><p>面向对象编程与传统过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。即使用new和指定固定长度的数组的区别。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.53.50.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="声明和初始化指针"><a href="#声明和初始化指针" class="headerlink" title="声明和初始化指针"></a>声明和初始化指针</h3><p>计算机需要跟踪指针指向的值的类型。例如，char 的地址与double的地址看上去没什么两样，但char和double使用的字节数是不同的，它们存储值时使用的内部格式也不同。因此，指针声明必须指定指针指向的数据的类型。但是地址的格式是相同的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%888.58.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要强调的是，int * 是一种类型，是指向int的指针。在哪里添加空格对于编译器是没有任何区别的。以下声明：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.03.35.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>将创建一个指针p1和一个常规int变量p2。对每个指针变量名，都需要使用一个 * 。</p><h3 id="指针的危险"><a href="#指针的危险" class="headerlink" title="指针的危险"></a>指针的危险</h3><p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。</p><p><strong>警告</strong>：<strong>一定要在对指针应用解除引用操作符（ * ）之前，将指针初始化为一个确定的、适当的地址。</strong></p><h3 id="指针和数字"><a href="#指针和数字" class="headerlink" title="指针和数字"></a>指针和数字</h3><p>指针不是整型，虽然计算机通常把地址当做整数来处理。在C99标准发布前，C语言允许直接对指针赋值整数，但C++在类型一致性上要求更严格，编译器将显示一条错误信息，要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%20%E4%B8%8B%E5%8D%889.58.11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>注意，pt是int值的地址，并不意味着pt本身的类型是int。</p><h3 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h3><p>指针的真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc()来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—使用new操作符。</p><p>在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new操作符。程序员要告诉new,需要为哪种数据类型分配内存; <strong>new将找到一个长度正确的内存块，并返回该内存块的地址。</strong>程序员的责任是将该地址赋给一个指针。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.50.00.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在之前是通过如下方式指定指针的地址的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.51.34.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>两种情况都是将一个int变量的地址赋给了指针。第二种情况下还可以通过名称来访问该int，第一种情况下，则只能通过该指针进行访问。pn指向的内存没有名称，该怎么称呼呢？我们称pn指向一个数据对象。这里的对象不是面向对象中的那个对象，术语数据对象比变量更通用，指为数据项分配的内存块，因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。</p><p>为一个数据对象(可以是结构，也可以是基本类型)获得并指定分配内存的通用格式如下:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-07%20%E4%B8%8B%E5%8D%889.59.47.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>需要在两个地方指定数据类型:用来指定需要什么样的内存和用来声明合适的指针。由于内存地址形式一样，所以得通过指针的类型知道需要读几个内存单元的值。</p><h3 id="内存被耗尽"><a href="#内存被耗尽" class="headerlink" title="内存被耗尽"></a>内存被耗尽</h3><p>计算机可能会由于没有足够的内存而无法满足new的请求。此时，new将返回0。在C++中，值为0的指针被称为空值指针（null pointer）。C++确保空值指针不会指向有效的数据，因此它常被用来表示操作符或函数失效，如果成功，它们将返回一个有用的指针。可以通过if语句来检查new是否返回的是空值指针，从而防止程序超界。如果无法分配内存，new除返回空值指针外，还可能引发bad_alloc异常。</p><h3 id="使用delete来释放内存"><a href="#使用delete来释放内存" class="headerlink" title="使用delete来释放内存"></a>使用delete来释放内存</h3><p>当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是delete操作符，它使得在使用完内存后， 能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放(free)的内存可供程序的其他部分使用。使用delete时，后面要加.比指向内存块的指针(这些内存块最初是用new分配的):<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.09.51.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这将释放ps指向的内存，但不会删除指针ps本身。例如，可以将ps重新指向另一个新分配的内存块。一定要配对地使用new和delete: 否则将发生内存泄漏(memory leak), 也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。</p><p>不要尝试释放已经释放的内存，这样做的结果是不确定的，不能使用delete来释放声明变量获得的内存。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.15.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><strong>只能用delete来释放使用new分配的内存</strong>，不过对空指针使用delete是安全的。</p><p>使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.19.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>一般来说， 不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。</p><h3 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h3><p>如果通过声明来创建数组,则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组,数组都在那里,它占用了内存。在编译时给数组分配内存被称为静态联编( static binding),意味着数组是在编译时加入到程序中的。但使用new时,如果在运行阶段需要数组,则创建它:如果不需要, 则不创建。还可以在程序运行时选择数组的长度。这被称为动态联编(dynamic binding),意味着数组是在程序运行时创建的。这种数组叫作动态数组(dynamic array)使用静态联编时,必须在编写程序时指定数组的长度;使用动态联编时,程序将在运行时确定数组的长度。</p><h4 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h4><p>在C++中,创建动态数组很容易;只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号,其中包含元素数目。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.28.33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>new操作符返回第一个元素的地址，当程序结束使用内存块后，应使用delete释放它们。</p><p>使用new创建数组时，应使用另一种格式的delete,它能指出所要释放的是一个数组。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.49.29.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意delete和指针之间的方括号。如果使用new时，不带方括号，则使用delete时，也不应带方括号。如果使用new时带方括号，则使用delete时也应带方括号。</p><p>总之, 使用new和delete时，应遵守以下规则:</p><ol><li>不要使用delete来释放不是new分配的内存。</li><li>不要使用delete释放同一个内存块两次。</li><li>如果使用new[ ]为数组分配内存，则应使用delete[ ]来释放。</li><li>如果使用new[ ]为一个实体分配内存，则应使用delete (没有方括号)来释放。</li><li>对空值指针应用delete是安全的。</li></ol><p>由于动态数组返回的是指向第一个元素的指针，所以程序员需要跟踪内存块中的元素个数，实际上程序跟踪了分配的内存量以便在使用delete[]操作符时能正确地释放这些内存。但是这些信息是不公用的，如，不能使用sizeof操作符来确定动态分配的数组包含的字节数。</p><p>为数组分配内存的通用格式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%886.12.10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>使用new操作符可以确保内存块足以存储num_elements 个类型为type_ name的元素，而pointer_ name将指向第1个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于new与delete的问题</span><br><span class="line">一般来说在程序结束后操作系统会收回分配的所有资源，不delete也不会造成影响。但是如果程序常驻内存只new不delete就会很快耗尽内存，造成内存泄露，所以要养成new delete的习惯。</span><br></pre></td></tr></table></figure></p><h4 id="使用动态数组"><a href="#使用动态数组" class="headerlink" title="使用动态数组"></a>使用动态数组</h4><p>将指针当做数组名使用即可，对于第一个元素，即为p[0]。<br>数组名和指针的根本区别在于，不能修改数组名的值，但指针是变量，因此可以修改它的值。相邻的int地址通常相差2个字节或4个字节，而将p3加1后，它将指向下一个元素的地址，这表明指针算术有:些特别的地方。情况确实如此。</p><h2 id="指针、数组和指针算术"><a href="#指针、数组和指针算术" class="headerlink" title="指针、数组和指针算术"></a>指针、数组和指针算术</h2><p>指针和数组基本等价的原因在于指针算术( pointer arithmetic和C++内部处理数组的方式。算术。将整数变量加1后,其值将增加1;但将指针变量加1后,增加的量等于它指向的类型的字节数。将指向double的指针加1后,如果系统对double使用8个字节存储,则数值将增加8;将指向short的指针加1后,如果系统对 short使用2个字节存储,则指针值（存储的地址值）将增加2。C++将数组名解释为地址。</p><p>如数组表达式stack[1]，C++编译器将该表达式看作是*(stacks+1)，这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。<br>区别之一在于可以修改指针的值，而数组名是常量。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%884.26.08.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一个区别是，对数组应用sizeof操作符得到的数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。</p><h3 id="指针算术："><a href="#指针算术：" class="headerlink" title="指针算术："></a>指针算术：</h3><p>C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种运算才有意义;这将得到两个元素的间隔。</p><h3 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h3><p>cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。在C++中，用引号括起来的字符串像数组名一样，也是第一个元素的地址。</p><p><strong>在cout和多数C++表达式中, char数组名、指向char的指针以及用引号括起的宇符串常量都被解释为字符串第一个字符的地址。</strong></p><h3 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用new创建动态结构</h3><p>将new用于结构由两步组成:创建结构和访问其成员。要创建结构，需要同时使用结构类型和new。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%885.39.32.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这将把足以存储infatable结构的 块可用内存的地址赋给ps。 这种句法和C++的内置类型完全相同。</p><p>箭头成员操作符（-&gt;），可用于指向结构的指针，就像点操作符可用于结构名一样。如ps指向一个inflatable结构，则ps-&gt;price是被指向的结构的price成员。如果结构标识符是结构名，则使用句点操作符;如果标识符是指向结构的指针，则使用箭头操作符。</p><p>另一种访问结构成员的方法是，如果ps是指向结构的指针，则 * ps 就是被指向的值一结构本身。 由于 * ps是一个结构，因此( * ps) .price 是该结构的price 成员。C++的操作符优先规则要求使用括号。</p><h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C++有3种管理数据内存的方式: 自助存储、静态存储和动态存储(有时也叫作自由存储空间或堆)。</p><h4 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h4><p>在函数内部定义的常规变量使用自助存储空间，被称为自动变量(automatic variable),这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。</p><p>实际上，自动变量是一个局部变量，其作用域为包它的代码块。代码块是被包含在花括号中的一段代码。</p><h4 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h4><p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种:一种是在函数外面定义它:另一种是在声明变量时使用关键字static。</p><p>自动存储和静态存储的关键在于:这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期(静态变量)，也可能只是在特定函数被执行时存在(自动变量)。</p><h4 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h4><p>new和delete操作符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间(free store)。内存池同用于静态变量和自动变量的内存是分开的。new和delete允许在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期就不完全受到程序或函数的生存时间的控制了。与使用常规变量相比， 使用new和delete使程序员对程序如何使用内存有更大的控制权。</p><h3 id="堆栈、堆和内存泄露"><a href="#堆栈、堆和内存泄露" class="headerlink" title="堆栈、堆和内存泄露"></a>堆栈、堆和内存泄露</h3><p>如果使用new在自由空间（或堆）上创建变量后，没有调用delete，即使指针由于作用域规则和对象声明周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄露。被泄露的内存将在程序的整个生命周期都不可使用。</p><h1 id="循环和关系表达式"><a href="#循环和关系表达式" class="headerlink" title="循环和关系表达式"></a>循环和关系表达式</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%886.15.14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>循环只执行一次初始化。</p><p>测试表达式结果为真，则程序将执行循环体，为假循环结束。<br>C++并没有将test expression的值限制为只能为真或假。可以使用任意表达式，C++将把结果强制转换为bool类型。因此， 值为0的表达式将被转换为bool值false,导致循环结束。 如果表达式的值为非零，则被强制转换为bool值true。</p><h3 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h3><p><strong>在C++中，每个表达式都有值。</strong><br>通常值是很明显的，如22+27<br>但x=20这个表达式由两个值和一个赋值操作符组成。C++将赋值表达式的值定义为左侧成员的值。因此maids=（x=20）+2可得maids为22。对于x=y=z=0，赋值操作符是从右向左结合的，因此首先将0赋给z，然后将z=0赋给y，以此类推。</p><p>从表达式到语句的转变是很小的一步，只要加一个分号就可以完成。</p><h3 id="递增操作符（-）和递减操作符（—）"><a href="#递增操作符（-）和递减操作符（—）" class="headerlink" title="递增操作符（++）和递减操作符（—）"></a>递增操作符（++）和递减操作符（—）</h3><p>a++意味着使用a的当前值计算表达式，然后将a的值加1;而++b的意思是先将b的值加1, 然后使用新的值来计算表达式。</p><h3 id="组合赋值操作符"><a href="#组合赋值操作符" class="headerlink" title="组合赋值操作符"></a>组合赋值操作符</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.08.16.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.10.42.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="可能犯的错误"><a href="#可能犯的错误" class="headerlink" title="可能犯的错误"></a>可能犯的错误</h3><p>==与=</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.21.59.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="for与while"><a href="#for与while" class="headerlink" title="for与while"></a>for与while</h3><p>在C++中， for和while循环本质上是相同的。<br>可以相互改写。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>C++为类型建立别名的方式有两种。一种是使用预处理器<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.31.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这样，预处理器将在编译程序时用char替换所有的BYTE,从而使BYTE成为char的别名。<br>第二种方法是使用C++(和C)的关键字typedef来创建别名。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.32.48.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.34.04.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>也可以使用#define，不过声明一系列变量时，这种方法不适用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.36.28.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>typedef方法不会有这样的问题。它能够处理更复杂的类型别名，这使得与使用#define相比，使用typedef时一种更佳的选择，有时也是唯一的选择。</p><p>注意, typedef不会创建新类型,而只是为已有的类型建立一个新名称。</p><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.47.25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="嵌套循环和二维数组"><a href="#嵌套循环和二维数组" class="headerlink" title="嵌套循环和二维数组"></a>嵌套循环和二维数组</h2><p>声明数组：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.55.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.56.18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%887.59.13.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于二维数组，由于每个元素本身就是一个数组，因此可以使用与上述代码类似的格式来初始化每一个元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.00.15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>}；</p><h1 id="分支语句和逻辑操作符"><a href="#分支语句和逻辑操作符" class="headerlink" title="分支语句和逻辑操作符"></a>分支语句和逻辑操作符</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.07.52.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="格式化if-else语句"><a href="#格式化if-else语句" class="headerlink" title="格式化if else语句"></a>格式化if else语句</h3><p>如果需要多条语句，需要用花括号将它们括起来，组成一个块语句。和有些语言不同的是，由于C++不会自动将if和else之间的所有代码视为一个代码块，因此必须使用花括号将这些语句组合成一个语句块。</p><h3 id="if-else-if-else结构"><a href="#if-else-if-else结构" class="headerlink" title="if else if else结构"></a>if else if else结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.12.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><h3 id="逻辑OR操作符："><a href="#逻辑OR操作符：" class="headerlink" title="逻辑OR操作符：| |"></a>逻辑OR操作符：| |</h3><h3 id="逻辑AND操作符：-amp-amp"><a href="#逻辑AND操作符：-amp-amp" class="headerlink" title="逻辑AND操作符：&amp;&amp;"></a>逻辑AND操作符：&amp;&amp;</h3><h3 id="逻辑NOT操作符：！"><a href="#逻辑NOT操作符：！" class="headerlink" title="逻辑NOT操作符：！"></a>逻辑NOT操作符：！</h3><h3 id="逻辑操作符细节"><a href="#逻辑操作符细节" class="headerlink" title="逻辑操作符细节"></a>逻辑操作符细节</h3><p>OR和AND操作符的优先级都低于关系操作符。这意味着<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.19.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>另一方面！操作符的优先级高于所有的关系操作符和算术操作符。因此，要对表达式求反，必须用括号将其括起来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.20.31.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>逻辑AND操作符的优先级高于逻辑OR操作符。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.21.21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="其他表示方式"><a href="#其他表示方式" class="headerlink" title="其他表示方式"></a>其他表示方式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.22.56.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库cctype</h2><p>C++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（老式风格为ctype.h）中定义的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.34.27.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="？：操作符"><a href="#？：操作符" class="headerlink" title="？：操作符"></a>？：操作符</h2><p>C++有一个常被用来代替if else语句的操作符，这个操作符被称为条件操作符（?:），它是C++中唯一一个需要3个操作数的操作符。该操作符通用格式如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.36.37.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如果expressionl 为true, 则整个条件表达式的值为expression2 的值; 否则，整个表达式的值为expression3的值。</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/media/C++%20Primer%20%E7%B1%BB%E4%B9%8B%E5%89%8D/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%888.53.54.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>注意使用break。</p><h3 id="将枚举量作为标签"><a href="#将枚举量作为标签" class="headerlink" title="将枚举量作为标签"></a>将枚举量作为标签</h3><h3 id="switch和if-else"><a href="#switch和if-else" class="headerlink" title="switch和if else"></a>switch和if else</h3><p>switch并不是为处理取值范围而设计的。switch语句中的每一个case标签都必须是一个单独的值。另外这个值必须是整数（包括char），因此switch无法处理浮点测试。如果既可以使用if else语句，也可以使用switch语句，则当选项不少于3个时，应使用switch语句。</p><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h2 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h2><h3 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h3><ol><li>必须包含头文件iostream</li><li>头文件iostream定义了个用处理输入的istream类。</li><li>头文件iostream声明了一个名为cin的istream变量(对象)。</li><li>必须指明名称空间std;例如,为引用元素cin,必须使用编译指令 using或前缀std::。</li><li>可以结合使用cin和操作符&lt;&lt;来读取各种类型的数据。</li><li>可以使用cin和get（）方法来读取一个字符,使用cin和 getline（）来读取一行字符。</li><li>可以结合使用cin和eof()、fail()方法来判断输入是否成功。</li><li>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ol><h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><ol><li>必须包含头文件fstream</li><li>头文件 fstream定义了一个用于处理输入的 ifstream类。</li><li>需要声明一个或多个 ifstream变量(对象),并以自己喜欢的方式对其进行命名,条件是遵守常用的命名规则。</li><li>必须指明名称空间std:例如，为引用元素ifstream, 必须使用编译指令using 或前缀std:.。</li><li>需要将ifstream对象与文件关联起来。为此， 方法之一是使用open()方法。</li><li>使用完文件后，应使用close()方法将其关闭。</li><li>可结合使用ifstream对象和操作符&lt;&lt;来读取各种类型的数据。</li><li>可以使用ifstream 对象和get() 方法来读取一个字符， 使用ifstream对象和getine()来读取一行字符。</li><li>可以结合使用ifstream 和eof()、 fail()等方法来判断输入是否成功。</li><li>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true,否则被转换为false。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开始学习C&quot;&gt;&lt;a href=&quot;#开始学习C&quot; class=&quot;headerlink&quot; title=&quot;开始学习C++&quot;&gt;&lt;/a&gt;开始学习C++&lt;/h1&gt;&lt;h2 id=&quot;进入C&quot;&gt;&lt;a href=&quot;#进入C&quot; class=&quot;headerlink&quot; title=&quot;进入C
      
    
    </summary>
    
      <category term="教程" scheme="https://github.com/zdkswd/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="https://github.com/zdkswd/tags/C/"/>
    
  </entry>
  
</feed>
