{"meta":{"title":"ZDK's blog","subtitle":null,"description":null,"author":"ZDK","url":"https://github.com/zdkswd"},"pages":[{"title":"categories","date":"2018-05-16T08:57:06.000Z","updated":"2018-05-16T08:58:10.000Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/zdkswd/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-16T07:23:52.000Z","updated":"2018-05-16T08:58:32.000Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/zdkswd/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《深度学习》2 线性代数","slug":"《深度学习》2 线性代数","date":"2018-07-31T09:41:12.000Z","updated":"2018-07-31T10:05:57.000Z","comments":true,"path":"2018/07/31/《深度学习》2 线性代数/","link":"","permalink":"https://github.com/zdkswd/2018/07/31/《深度学习》2 线性代数/","excerpt":"","text":"标量、向量、矩阵和张量 标量( scalar)一个标量就是一个单独的数,它不同于线性代数中研究的其他大部分对象(通常是多个数的数组)。我们用斜体表示标量。标量通常被赋予小写的变量名称。当我们介绍标量时,会明确它们是哪种类型的数。比如,在定义实数标量时,我们可能会说“令s∈R表示一条线的斜率”;在定义自然数标量时,我们可能会说“令n∈N表示元素的数目”。 向量( vector):一个向量是一列数。这些数是有序排列的。通过次序中的索引,我们可以确定每个单独的数。通常我们赋予向量粗体的小写变量名称,比如x。向量中的元素可以通过带脚标的斜体表示。向量x的第一个元素是x1,第二个元素是x2,等等。我们也会注明存储在向量中的元素是什么类型的。如果每个元素都属于R,并且该向量有n个元素,那么该向量属于实数集R的n次笛卡尔乘积构成的集合,记为 。当需要明确表示向量中的元素时,我们会将元素排列成一个方括号包围的纵列: 我们可以把向量看作空间中的点,每个元素是不同坐标轴上的坐标。有时我们需要索引向量中的一些元素。在这种情况下,我们定义一个包含这些元素索引的集合,然后将该集合写在脚标处。比如,指定x1,和,我们定义集合S={1,3,6},然后写作xs。我们用符号一表示集合的补集中的索引。比如x-1表示x中除x1外的所有元素,x-s表示x中除x1,x3,x6外所有元素构成的向量。 矩阵( matrix):矩阵是一个二维数组,其中的每一个元素被两个索引(而非一个)所确定。我们通常会赋予矩阵粗体的大写变量名称,比如A（斜体）。如果一个实数矩阵高度为m,宽度为n,那么我们说 。我们在表示矩阵中的元素时,通常以不加粗的斜体形式使用其名称,索引用逗号间隔。比如,A1，1表示A左上的元素,Am，n表示A右下的元素。我们通过用“：”表示水平坐标,以表示垂直坐标i中的所有元素。比如,Ai,:表示A中垂直坐标i上的一横排元素。这也被称为A的第i行(row)。同样地,A:,i表示A的第i列column)。当我们需要明确表示矩阵中的元素时,我们将它们写在用方括号括起来的数组中: 有时我们需要矩阵值表达式的索引,而不是单个元素。在这种情况下,我们在表达式后面接下标,但不必将矩阵的变量名称小写化。比如 表示函数f作用在A上输出的矩阵的第i行第j列元素。 张量( tensor):在某些情况下,我们会讨论坐标超过两维的数组。一般地个数组中的元素分布在若干维坐标的规则网格中,我们称之为张量。我们使用字体A（不是斜体）来表示张量“A”。张量A中坐标为(i,j,k)的元素记作Ai,j,k。 转置( transpose)是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像这条从左上角到右下角的对角线被称为主对角线( main diagonal)。我们将矩阵A的转置表示为AT,定义如下 向量可以看作只有一列的矩阵。对应地,向量的转置可以看作是只有一行的矩阵。 。标量可以看作是只有一个元素的矩阵。因此,标量的转置等于它本身,a=aT。 1【】只是记法 在深度学习中,我们也使用一些不那么常规的符号。我们允许矩阵和向量相加,产生另一个矩阵:C=A+b,其中 。换言之,向量b和矩阵A的每一行相加。这个简写方法使我们无需在加法操作前定义一个将向量b复制到每一行而生成的矩阵。这种隐式地复制向量b到很多位置的方式,被称为广播( broadcasting )。 矩阵和向量相乘 单位矩阵和逆矩阵 线性相关和生成子空间 ](/img/media/15329168471815/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-30%20%E4%B8%8A%E5%8D%8811.39.02.png)![屏幕快照 2018-07-30 上午11.40.58 1还有一种看法是以列向量为新的参考系，看在参考系下要表示的向量的坐标。 不等式n≥m仅是方程对每一点都有解的必要条件。这不是一个充分条件。 1奇异值行列式为0 范数有时我们需要衡量一个向量的大小。在机器学习中,我们经常使用被称为范数（norm)的函数衡量向量大小。形式上, 范数定义如下： 范数(包括 范数)是将向量映射到非负值的函数。直观上来说,向量x的范数衡量从原点到点x的距离。更严格地说,范数是满足下列性质的任意函数： 当p=2时, 范数被称为欧几里得范数( Euclidean norm)。它表示从原点出发到向量c确定的点的欧几里得距离。L2范数在机器学习中出现地十分频繁,经常简化表示为 ,略去了下标2。平方L2范数也经常用来衡量向量的大小,可以简单地通过点积 计算。 另外一个经常在机器学习中出现的范数是L∞范数,也被称为最大范数（max norm)这个范数表示向量中具有最大幅值的元素的绝对值: 1弗罗贝尼乌斯范数 特殊类型的矩阵和向量对角矩阵 对称 单位向量 正交矩阵 特征分解特征分解( eigendecomposition)是使用最广的矩阵分解之一,即我们将矩阵分解成一组特征向量和特征值。 1矩阵A乘以x表示，对向量x进行一次转换（旋转或拉伸)（是一种线性转换），而该转换的效果为常数c乘以向量x（即只进行拉伸）。 奇异值分解我们探讨了如何将矩阵分解成特征向量和特征值。还有另一种分解矩阵的方法,被称为奇异值分解( singular value decomposition,SVD),将矩阵分解为奇异向量( singular vector)和奇异值( singular value)。通过奇异值分解,我们会得到一些与特征分解相同类型的信息。然而,奇异值分解有更广泛的应用。每个实数矩阵都有一个奇异值分解,但不一定都有特征分解。例如,非方阵的矩阵没有特征分解,这时我们只能使用奇异值分解。 Moore-Penrose伪逆 迹运算 另一个有用的事实是标量在迹运算后仍然是它自己:a=Tr(a)。 行列式行列式,记作det(A),是一个将方阵A映射到实数的函数。行列式等于矩阵特征值的乘积。行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或者缩了多少。如果行列式是0,那么空间至少沿着某一维完全收缩了,使其失去了所有的体积。如果行列式是1,那么这个转换保持空间体积不变。 实例:主成分分析主成分分析( principal components analysis,PCA)是一个简单的机器学习算法,可以通过基础的线性代数知识推导。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"深度学习","slug":"深度学习","permalink":"https://github.com/zdkswd/tags/深度学习/"}]},{"title":"《深度学习》 1 引言","slug":"《深度学习》 1 引言","date":"2018-07-29T10:55:12.000Z","updated":"2018-07-29T10:56:38.000Z","comments":true,"path":"2018/07/29/《深度学习》 1 引言/","link":"","permalink":"https://github.com/zdkswd/2018/07/29/《深度学习》 1 引言/","excerpt":"","text":"引言讽刺的是,抽象和形式化的任务对人类而言是最困难的脑力任务之一,但对计算机而言却属于最容易的。计算机早就能够打败人类最好的象棋选手,但直到最近计算机才在识别对象或语音任务中达到人类平均水平。一个人的日常生活需要关于世界的巨量知识。很多这方面的知识是主观的、直观的,因此很难通过形式化的方式表达清楚。计算机需要获取同样的知识才能表现出智能。人工智能的一个关键挑战就是如何将这些非形式化的知识传达给计算机。 些人工智能项目力求将关于世界的知识用形式化的语言进行硬编码(hard code)。计算机可以使用逻辑推理规则来自动地理解这些形式化语言中的声明。这就是众所周知的人工智能的知识库( knowledge base)方法。然而,这些项目最终都没有取得重大的成功。其中最著名的项目是 Cyc(Lenat and Guha,1989)Cyc包括一个推断引擎和一个使用CycL语言描述的声明数据库。这些声明是由人类监督者输入的。这是一个笨拙的过程。人们设法设计出足够复杂的形式化规则来精确地描述世界。例如,Cyc不能理解一个关于名为rred的人在早上剃须的故事( Linde,1992)。它的推理引擎检测到故事中的不一致性:它知道人体的构成不包含电气零件,但由于Fred正拿着一个电动剃须刀,它认为实体“正在剃须的Fred”(“ Fred While Shaving”)含有电气部件。因此它产生了这样的疑问—Fred在刮胡子的时候是否仍然是一个人。；） 依靠硬编码的知识体系面对的困难表明,AI系统需要具备自己获取知识的能力即从原始数据中提取模式的能力。这种能力被称为机器学习( machine learning)引入机器学习使计算机能够解决涉及现实世界知识的问题，并能作出看似主观的决策。比如,一个被称为逻辑回归( logistic regression)的简单机器学习算法可以决定是否建议剖腹产(Mor- Yosef et al,1990)。而同样是简单机器学习算法的朴素贝叶斯( naive Bayes)则可以区分垃圾电子邮件和合法电子邮件 这些简单的机器学习算法的性能在很大程度上依赖于给定数据的表示( repre-sentation)。 许多人工智能任务都可以通过以下方式解决:先提取一个合适的特征集,然后将这些特征提供给简单的机器学习算法。例如,对于通过声音鉴别说话者的任务来说,一个有用的特征是对其声道大小的估计。这个特征为判断说话者是男性、女性还是儿童提供了有力线索。 然而,对于许多任务来说,我们很难知道应该提取哪些特征。例如,假设我们想编写一个程序来检测照片中的车。我们知道,汽车有轮子,所以我们可能会想用车轮的存在与否作为特征。不幸的是,我们难以准确地根据像素值来描述车轮看上去像什么。虽然车轮具有简单的几何形状,但它的图像可能会因场景而异,如落在车轮上的阴影、太阳照亮的车轮的金属零件、汽车的挡泥板或者遮挡的车轮一部分的前景物体等等。 解决这个问题的途径之一是使用机器学习来发掘表示本身,而不仅仅把表示映射到输出。这种方法我们称之为表示学习( representation learning)。学习到的表示往往比手动设计的表示表现得更好。并且它们只需最少的人工干预,就能让AI系统迅速适应新的任务。表示学习算法只需几分钟就可以为简单的任务发现一个很好的特征集,对于复杂任务则需要几小时到几个月。手动为一个复杂的任务设计特征需要耗费大量的人工时间和精力;甚至需要花费整个社群研究人员几十年的时间。 表示学习算法的典型例子是自编码器( autoencoder)。自编码器由一个编码器( encoder)函数和一个解码器( decoder)函数组合而成。编码器函数将输入数据转换为一种不同的表示,而解码器函数则将这个新的表示转换到原来的形式。我们期望当输人数据经过编码器和解码器之后尽可能多地保留信息,同时希望新的表示有各种好的特性,这也是自编码器的训练目标。为了实现不同的特性,我们可以设计不同形式的自编码器。 当设计特征或设计用于学习特征的算法时,我们的目标通常是分离出能解释观察数据的变差因素( factors of variation)。在此背景下,“因素”这个词仅指代影响的不同来源;因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反,它们可能是现实世界中观察不到的物体或者不可观测的力,但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因,它们还可能以概念的形式存在于人类的思维中。它们可以被看作数据的概念或者抽象,帮助我们了解这些数据的丰富多样性。当分析语音记录时,变差因素包括说话者的年龄、性别、他们的口音和他们正在说的词语。当分析汽车的图像时,变差因素包括汽车的位置、它的颜色、太阳的角度和亮度。 显然,从原始数据中提取如此高层次、抽象的特征是非常困难的。许多诸如说话口音这样的变差因素,只能通过对数据进行复杂的、接近人类水平的理解来辨识。这几乎与获得原问题的表示一样困难,因此,乍一看,表示学习似乎并不能帮助我们。 深度学习( deep learning)通过其他较简单的表示来表达复杂表示,解决了表示学习中的核心问题。 屏幕快照 2018-07-29 下午5.55.44 如何通过组合较简单的概念(例如转角和轮廓,它们转而由边线定义)来表示图像中人的概念。深度学习模型的典型例子是前馈深度网络或多层感知机( multilayer perceptron,MLP)。多层感知机仅仅是一个将一组输人值映射到输出值的数学函数该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。 学习数据的正确表示的想法是解释深度学习的一个视角。另一个视角是深度促使计算机学习一个多步骤的计算机程序。每一层表示都可以被认为是并行执行另组指令之后计算机的存储器状态。更深的网络可以按顺序执行更多的指令。顺序指令提供了极大的能力,因为后面的指令可以参考早期指令的结果。从这个角度上看在某层激活函数里,并非所有信息都蕴涵着解释输入的变差因素。表示还存储着状态信息,用于帮助程序理解输人。这里的状态信息类似于传统计算机程序中的计数器或指针。它与具体的输人内容无关,但有助于模型组织其处理过程。 屏幕快照 2018-07-29 下午6.03.19 由于不同的人选择不同的最小元素集来构建相应的图,因此就像计算机程序的长度不存在单一的正确值一样,架构的深度也不存在单一的正确值。另外,也不存在模型多么深才能被修饰为“深”的共识。但相比传统机器学习,深度学习研究的模型涉及更多学到功能或学到概念的组合,这点毋庸置疑。 屏幕快照 2018-07-29 下午6.07.58 本书面向的读者 屏幕快照 2018-07-29 下午6.09.31 深度学习的历史趋势神经网络的众多名称和命运变迁20世纪40年代到60年代深度学习的雏形出现在控制论( cybernetics)中。 尽管有些机器学习的神经网络有时被用来理解大脑功能( Hinton and shallice,1991),但它们一般都没有被设计成生物功能的真实模型。 现在,神经科学被视为深度学习研究的一个重要灵感来源,但它已不再是该领域的主要指导。 媒体报道经常强调深度学习与大脑的相似性。的确,深度学习研究者比其他器学习领域(如核方法或贝叶斯统计)的研究者更可能地引用大脑作为影响,但是大家不应该认为深度学习在尝试模拟大脑。 深度学习领域主要关注如何构建计算机系统,从而成功解决需要智能才能解决的任务,而计算神经科学领域主要关注构建大脑如何进行真实工作的比较精确的模型。 在20世纪80年代,神经网络研究的第二次浪潮在很大程度上是伴随一个被称为联结主义( connectionism)或并行分布处理( parallel distributed processing)潮流而出现的( Rumelhart et al,1986d; McClelland et al,1995)。 联结主义的中心思想是,当网络将大量简单的计算单元连接在一起时可以实现智能行为。这种见解同样适用于生物神经系统中的神经元,因为它和计算模型中隐藏单元起着类似的作用。 其中一个概念是分布式表示( distributed representation)( Hinton et al,1986)其思想是:系统的每一个输入都应该由多个特征表示,并且每一个特征都应该参与到多个可能输人的表示。例如,假设我们有一个能够识别红色、绿色、或蓝色的汽车、卡车和鸟类的视觉系统,表示这些输人的其中一个方法是将九个可能的组合:红卡车,红汽车,红鸟,绿卡车等等使用单独的神经元或隐藏单元激活。这需要九个不同的神经元,并且每个神经必须独立地学习颜色和对象身份的概念。改善这种情况的方法之一是使用分布式表示,即用三个神经元描述颜色,三个神经元描述对象身份。这仅仅需要6个神经元而不是9个,并且描述红色的神经元能够从汽车、卡车和鸟类的图像中学习红色,而不仅仅是从一个特定类别的图像中学习。分布式表示的概念是本书的核心。 联结主义潮流的另一个重要成就是反向传播在训练具有内部表示的深度神经网络中的成功使用以及反向传播算法的普及( Rumelhart et al,1986c; LeCun,1987)。这个算法虽然曾黯然失色不再流行,但截至写书之时,它仍是训练深度模型的主导方法。 在20世纪90年代,研究人员在使用神经网络进行序列建模的方面取得了重要进展。 Hochreiter(191b)和 Bengio et al.(1994a)指出了对长序列进行建模的些根本性数学难题, Hochreiter and schmidhuber(1997)引入长短期记忆( long short-term memory,LSTM)网络来解决这些难题。如今,LSTM在许多序列建模任务中广泛应用,包括 Google的许多自然语言处理任务。 神经网络研究的第三次浪潮始于2006年的突破。Geoffrey Hinton表明名为深度信念网络的神经网络可以使用一种称为贪婪逐层预训练的策略来有效地训练。 神经网络研究的这一次浪潮普及了“深度学习”这一术语的使用,强调研究者现在有能力训练以前不可能训练的比较深的神经网络,并着力于深度的理论重要。此时,深度神经网络已经优于与之竞争的基于其他机器学习技术以及手工设计功能的AI系统。 尽管深度学习的研究重点在这一段时间内发生了巨大变化。第三次浪潮已开始着眼于新的无监督学习技术和深度模型在小数据集的泛化能力,但目前更多的兴趣点仍是比较传统的监督学习算法和深度模型充分利用大型标注数据集的能力。 与日俱增的数据量“大数据”时代使机器学习更加容易。截至2016年,一个粗略的经验法则是,监督深度学习算法在每类给定约5000个标注样本情况下一般将达到可以接受的性能,当至少有1000万个标注样本的数据集用于训练时,它将达到或超过人类表现。此外,在更小的数据集上获得成功是一个重要的研究领域,为此我们应特别侧重于如何通过无监督或半监督学习充分利用大量的未标注样本。 与日俱增的模型规模20世纪80年代,神经网络只能取得相对较小的成功,而现在神经网络非常成功的另一个重要原因是我们现在拥有的计算资源可以运行更大的模型。联结主义的主要见解之一是,当动物的许多神经元一起工作时会变得聪明。单独神经元或小集合的神经元不是特别有用。 就神经元的总数目而言,直到最近神经网络都是惊人的小。自从隐藏单元引人以来,人工神经网络的规模大约每2.4年扩大一倍。这种增长是由更大内存、更快的计算机和更大的可用数据集驱动的。更大的网络能够在更复杂的任务中实现更高的精度。这种趋势看起来将持续数十年。除非有能力迅速扩展的新技术,否则至少要到21世纪50年代,人工神经网络将才能具备与人脑相同数量级的神经元。生物神经元表示的功能可能比目前的人工神经元所表示的更复杂。 屏幕快照 2018-07-29 下午6.47.54 现在看来,其神经元比一个水蛭还少的神经网络不能解决复杂的人工智能问题是不足为奇的。即使现在的网络,从计算系统角度来看它可能相当大的,但实际上它比相对原始的脊椎动物如青蛙的神经系统还要小。 由于更快的CPU、通用GPU的出现更快的网络连接和更好的分布式计算的软件基础设施,模型规模随着时间的推移不断增加是深度学习历史中最重要的趋势之一。人们普遍预计这种趋势将很好地持续到未来。 与日俱增的精度、复杂度和对现实世界的冲击 屏幕快照 2018-07-29 下午6.51.21 深度学习的另一个最大的成就是其在强化学习( reinforcement learning)领域的扩展。在强化学习中,一个自主的智能体必须在没有人类操作者指导的情况下,通过试错来学习执行任务。 DeepMind表明,基于深度学习的强化学习系统能够学会玩并在多种任务中可与人类匹敌Mnih et al.,2015)。深度学习也显著改善了机器人强化学习的性能。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"深度学习","slug":"深度学习","permalink":"https://github.com/zdkswd/tags/深度学习/"}]},{"title":"松本行弘的程序世界 14 函数式编程","slug":"松本行弘的程序世界 14 函数式编程","date":"2018-07-26T13:00:32.000Z","updated":"2018-07-27T03:20:34.000Z","comments":true,"path":"2018/07/26/松本行弘的程序世界 14 函数式编程/","link":"","permalink":"https://github.com/zdkswd/2018/07/26/松本行弘的程序世界 14 函数式编程/","excerpt":"","text":"松本行弘的程序世界 14 函数式编程新范型–函数式编程函数式编程是全部使用函数来编写程序代码的编程方法。这是可以与一般的结构化编程及面向对象编程相提并论的编程方法。 以函数为中心的函数式编程具有特征： 函数本身也作为数据来处理（第一级函数） 以函数为参数的高阶函数 参数相同即可保证结果相同的引用透明性。 为实现引用透明性，禁止产生副作用的处理。 函数式编程的最大优点在于，程序可以按照数学的形式以及声明的形式来编写。 结构式编程是在改变变量值的同时进行计算，所以一直注意着，这个变量的值是什么，并据此来预想计算过程。 采用函数式编程方式并不改变变量的值。并不包含状态或者动作等信息，仅仅是对想要做什么加以描述，这样不容易出错。 这种不是描述动作而是描述性质的编程方式称为声明式编程。声明式描述是函数式编程的一大优点。 具有多种函数式性质的Lisp之前，Lisp被认为是函数式编程的代表。Lisp具备函数式语言的很多性质。 Lisp最大的特征是S式记法。S式是括号很多的Lisp的记法。S式无与伦比的优点是它彻底的统一性。对Lisp而言，不管什么都可以同一成单一形式。 第二个重要之处在于链这种数据结构。Lisp语言本名是List Processor（链表处理器），从侧面说明了链的重要性。链是一种构成树结构数据的通用数据结构，构成数据结构的节点分别包含两个引用。 屏幕快照 2018-07-25 上午10.02.29 总之，Lisp具备了函数编程语言的基本特征。但是Lisp不直接支持多数纯粹的函数式编程语言所拥有的副作用如回避以及延迟计算等功能。对变量的赋值没有任何限制。且编程风格为很多很多括号。比较难适应。 近年来，由于像Haskell这样的彻底的函数式编程语言的兴起，Lisp作为函数式编程语言在人们心中的印象越来越淡薄。 彻底的函数式编程语言HaskellHaskell可以说是纯粹的函数式编程语言。Haskell语言特征： 没有副作用 高阶函数 函数部分应用 延迟计算(非正式) 静态多态类型系统 型推论 链内包表达式 用对齐来表示块 没有副作用Haskell程序基本没有副作用，不但不能改变变量的值，就连链的元素也是不能改变的。因此，只要参数不变，函数的返回值也就总是一样的。相同输入总能返回相同结果，这种可重复性对测试程序非常有利。这种重复性也称为引用透明性。 高阶函数Haskell高阶函数把函数本身作为数据来处理。比如，Haskell中没有循环控制结构，循环都是用递归调用或者高阶函数来实现的。 延迟计算：不必要的处理就不做必要时才进行处理。 灵活的“静态多态性”类型系统与没有类型的Ruby不同，Haskell是在编译时确定所有变量类型的静态类型语言。但实际上Haskell程序基本上没有必要给出变量的类型。这是因为聪明的Haskell语言处理系统会推测变量的类型。 Haskell利用多态性的类型系统和系统推测，在维持着接近于duck typing灵活性的同时，也使编译时的完全类型检查成为可能。 近代函数式语言之父OCamlOCaml也是具有代表性的函数式编程语言之一。它比Haskell还古老，说它是近代函数式语言之父也毫不为过。 与Haskell相比，OCaml具有如下不同： 没有副作用 没有延迟计算 具有强力的模块系统 虽然不像Haskell那样自然地做到延迟计算，但换来的好处是，程序内容与实际处理关系接近，使人容易理解程序的执行过程。 强于并行计算的Erlang作为函数式编程语言，二郎的特点 受Prolog影响 专用于并行计算 用Ruby进行函数式编程Ruby中有几个能进行函数式编程的工具 Proc对象（lambda）Ruby中唯一与函数直接对应的是Proc对象。 程序块以程序块为参数的方法等价于函数型语言的高阶函数。灵活运用以程序块为参数的方法，就可以实现函数式编程的高阶函数的技巧。 枚举器Ruby中没有延迟计算，但用枚举器对数组和列表进行循环，可以实现类似于延迟计算的处理。 避免副作用所谓避免副作用，就是对生成的对象，尽量少去改变其状态。 用枚举器来实现延迟计算从Ruby1.8.7开始，很多以块为参数的方法在参数不是块的时候，就会返回枚举器。 枚举器就是把循环用对象来表达的一种方法。 使用这样的枚举器可以实现与Haskell类似的延迟计算。 自动生成代码在商业中利用Ruby使用Ruby自动生成代码编程中的代码重复是非常恶劣的。发现了代码重复，就应该考虑在合理的代价范围内避免代码重复的方法。 消除重复代码为了在构建程序的时候，自动生成省略部分，我们只需要定义make的规则、在构建程序的过程中调用代码生成工具。 代码生成的应用数据库访问从数据结构定义自动生成数据库的访问例程（包括SQL）。 用户接口大多数依赖于数据库的Web应用程序，常常需要对表的各项目进行增删改查操作。 单元测试代码生成对单元测试也很有效果。只要有数据和测试条件，就可以开始单元测试。 客户界面文档化代码生成也适合与文档化。对于自动生成的类，由人工记入档案是纯粹的浪费。按照JavaDoc的形式，在生成代码的程序里写好相应的文档，应该是个聪明的办法。 代码生成的效果代码生成有如下好处： 改进质量。 确保一致性 集中知识。 增加用于设计的时间。 独立于程序实现的设计判断 编写代码生成器对代码生成最有帮助的工具要数eRuby。Ruby本身也拥有优越的文本处理功能。使用eRuby以比较自然地形式编写模板的同时，还可以灵活运用Ruby的处理能力。 也可以使用XML幸运的是，Ruby拥有解释XML的标准库REXML。REXML提供操作XML的功能。 在EJB中使用代码生成1EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分 内存管理与垃圾收集垃圾收集（GC）是一种管理程序使用的内存区域的方法。使用具有垃圾收集功能的编程语言或处理程序的话，程序中不需要编写内存管理的代码，即不用编写代码来释放使用过的内存区域。 内存管理的困难在垃圾收集普及之前，内存区域的取得和释放完全是程序员的责任。随着程序的执行，会使用一些内存区域作为作业区。为记忆对象、字符串和数组等个别信息，都需要使用内存区域。没有垃圾收集的语言一般都提供有API，利用这些API，可以再需要时向操作系统申请并取得内存，使用过之后再把内存区域返回给操作系统。 悬挂指针如果把还在使用中的内存区域错误调用free予以释放的话，就会发生悬挂指针的现象。程序再去访问该区域时就可能会出错。在引用该区域内容时，多数场合会读取到被破坏的数据，或是在更新该领域数据的时候，会置换成预想之外的数据。 内存泄漏另一方面，如果忘记了把申请的内存区域返还给操作系统的话，就会发生内存泄漏。这时候因为使用过的内存区域越来越多，程序占有的内存就会逐渐增加。特别是长时间启动，连续提供服务的常驻内存型程序，容易发生内存泄漏，导致系统停止等重大问题。 二重释放对已经释放过的内存区域再次调用free的情况也时有发生。这称为二重释放。这会带来malloc和free内部使用的数据区域不一致的问题。 内存泄漏问题只有在内存占用量超过预想的时候才会显露，而悬挂指针问题不会发生在释放使用内存的时刻，而是要到访问释放过的内存区域才会出现。程序员往往会在看起来完全没有问题的地方突然遭遇意想不到的错误。 垃圾收集亮相之前应该管理的内存区域越来越多，内存释放时刻的管理也就越来越难，这是产生内存问题的原因。 关于垃圾收集，有以下这些先入为主的观念。 垃圾收集慢有研究表明，在某些条件下，垃圾收集比手工管理内存还更快。 垃圾收集可靠性低在Java之后诞生的编程语言，不管是否受到Lisp的影响，几乎都毫无例外的拥有垃圾收集的功能。垃圾收集从诞生之日起，经历了40多年的发展，终于成为大家认可的一项特性了。 评价垃圾收集的两个指标假如存在无线内存的计算机的话，就没有必要进行垃圾收集。 垃圾收集的性能可以由两个指标来测定： 吞吐量吞吐量是垃圾收集处理在程序全部执行时间中所占的比例。比例越小越好，比例大的话，程序整体的性能就会低下。 暂停时间暂停时间是一次垃圾收集处理所中断的时间。暂停时间过长的话，处理的中断时间就会变得很显眼，程序反应就会变慢。 垃圾收集每次所花的时间会因垃圾收集执行时对象的总数而变化，暂停时间有两种，一是把垃圾收集时间求平均值得到平均暂停时间，二是程序执行中最长的垃圾收集时间所代表的最大暂停时间。 那些实时性要求高的程序，就很重视最大暂停时间。像批处理这样非对话的处理强调吞吐量要高，而重视反应速度的嵌入式或者GUI程序就强调暂停时间要短。 Java运行环境中实现由多种垃圾收集算法，可以根据程序的性质来切换合适的垃圾收集算法。 垃圾收集算法基本上是以下4类，还有几种变形： 引用计数方式 标记和扫除方式 标记和紧缩方式 复制方式 引用计数方式引用计数方式在垃圾收集算法中具有最简单最容易实现的特征。 屏幕快照 2018-07-25 下午5.25.46 引用计数器最大的优点就是容易实现。这种方式得到广泛的使用。暂停时间短也是它的优点。 最大的缺点是不能释放有循环引用关系的对象群。 屏幕快照 2018-07-25 下午5.28.21 与生俱来的缺点，因为在引用增减的时候有必要同时正确维护引用计数器的增减，忘了这一点就会带来悬挂指针或内存泄露问题。 最后一个缺点是，引用计数器的管理与并行处理不相容。如果多个进程同时增减一个引用计数器的话，就会发生引用计数器的值不一致的现象。为避免这一个问题，需要在操作引用计数器的时候进行排他处理，但在频繁发生引用操作的同时进行排他处理的话，会带来巨大的时间开销。 总之，这种原理简单实现也简单的引用计数器方式，缺点很多，最近已经不怎么用了。 采用引用计数器方式的主要语言处理系统有Perl和Python。为了回避循环引用的问题，它们都组合了其他垃圾收集方式。这些语言基本上以引用计数器方式来进行垃圾收集，只有在极个别的情况下，才通过别的垃圾收集算法来处理引用计数器不能回收的对象。 标记和扫除方式标记和扫除方式也是古老的垃圾收集算法。标记和扫除方式从有可能成为对象引用元的变数（根）开始，给被引用的对象加上标记，表明其“活着”。然后再给标记对象所引用的对象还有其再引用的对象，也都递归地加上引用标记。 这样从根开始不管是直接还是间接，只要把所有引用的对象都加上标记的话，那么没有标记的对象就是没有被引用的，也就是“已经死了”。然后在所有的对象中找出没有标记的对象，把它们作为垃圾扫除出去。 屏幕快照 2018-07-25 下午5.50.20 此法虽然古老，但是非常优秀，现在也还被多种处理系统所采用。 但是当对象数目较多时，性能容易恶化。在标记的时候要访问生存的所有对象，在回收时按顺序访问所有的对象，找出”已经死了“的对象。在寻找垃圾和扫除过程中，基本不能进行其他处理，垃圾收集时间长的话，会影响到本来的处理工作。 标记和紧缩方式标记和紧缩方式是标记和扫除的变形。标记处理是一样的，后阶段有所不同。 屏幕快照 2018-07-26 下午12.01.29 标记和紧缩方式最大的特征也是他的优越之处，是把空间集中起来（紧缩）。紧缩的结果是把没有释放而活下来的对象都集中到一个地方。这样，内存访问就集中到一个局部区域，这可以提高缓存功能的效率。对象的分配也只是把指针移动一下就完成了，降低了对象分配的开销。 缺点是，把生存着的对象全部复制的紧缩开销，容易比标记和扫除方式中执行的开销还要大。因为对象被移动位置了。 一部分Lisp处理系统采用的是标记和紧缩方式，Java处理系统（作为多个垃圾收集算法中的一个）也有标记和紧缩方式。 复制方式像标记和扫除方式、标记和紧缩方式这样“标记之后释放死了的对象”的算法，标记时间与活着的对象数成比例，扫除时间与总对象数成比例。所以在分配有很多的对象，其中几乎所有对象都要被释放的场合，扫除的开销会变高，在性能方面很不利。 复制方式与标记和扫除方式一样，从根开始扫描所有的对象，但他不仅仅是加标记，还执行复制。 屏幕快照 2018-07-26 下午12.11.58 复制方式把内存空间分成旧空间和新空间两大块，总是在旧空间中分配对象。旧空间爆满时，从根开始扫描对象，把对象复制到新空间。这时，复制后的引用也要随之更新。 递归的执行从旧空间到新空间的复制，结束时就会把所有活着的对象都移动到新空间。不再被引用的对象都遗留到旧空间，旧空间就可以整个弃之不用，就避免了扫除的开销，从此再把新空间作为旧空间再进行同样的处理。 最大的优点是，垃圾回收的开销只和活着的对象数成比例。对象分配的开销也低。还有“局部性”的优点。复制方式按顺序把引用的对象复制到新空间，关系近的对象会被分配到相近的内存空间，称为局部性。关系近的对象被访问的可能性也高。计算机因为有缓存，内存空间相接近的访问可能具有较好的性能，局部性高的程序具有提高性能的优势。 缺点：复制方式要复制所有活着的对象，几乎具有和标记和紧缩方式一样的缺点。 多种多样的垃圾收集算法把基本算法组合起来的技术，几个具有代表性的： 分代垃圾收集 保守垃圾收集 增量垃圾收集 并行垃圾收集 位图标志 这些技术的组合也是有可能的。 分代垃圾收集分代垃圾收集的基本思想是利用程序和对象的性质。一般程序都有这样一个性质，几乎所有的对象都在比较短的时间里变成垃圾，存活时间超过一定程度的对象总是拥有更长的寿命。 因为这一性质，就可以重点对分配之后的年轻对象进行扫描，这样就不用扫描全部对象就可能高效率地回收垃圾。 分代垃圾收集把对象的内存空间分成两个，新代和旧代，也有分成3个的。 只扫描新代区域的回收称为轻垃圾收集，但没有检查旧代区域对新代的引用，被引用的对象可能误判死亡，就会带来内存问题。 解决这一问题的方法是，监视对象的更新。在旧代区域引用新代区域的同时，就把这一引用的记录例程以及对象的更新场所全都记录下来，这个检查例程叫做写屏障，记录旧代区域对新代区域的引用叫记录集。 以所有区域对象的垃圾收集称为全垃圾收集或重垃圾收集。 屏幕快照 2018-07-26 下午12.33.58 分代垃圾收集减少了扫描对象的个数，有缩短平均暂停时间的效果。但是，因为要执行全垃圾收集，最大暂停时间不会得到明显的改善。 最近几乎所有的Java都实现有分代垃圾收集。另外，函数型语言OCaml也采用了分代垃圾收集。 保守垃圾收集像C这种本来没有垃圾收集的语言，编译之后没有保留区别整数和指针的信息，因为CPU对两者不加区分，所以也就没这个必要。通常，垃圾收集的实现需要明确区分引用（指针），而C和C++没有这样的功能，在这样的环境下实现垃圾收集的技巧之一称为保守垃圾收集。 其基本思想就是如果碰巧有整数的值与引用相同的话，该对象就有可能被引用，就当它是活着的。保守就是倾向于安全的意思。与此相对，能够明确区别所用的环境下的垃圾收集称为精确垃圾收集。 因为倾向于安全一面，保守垃圾收集在C或者C++这样没有垃圾收集功能的语言中也可以得到实现，这是它的优点。但是，本来应该回收的对象却在意料之外保留下来不能回收，这是它的缺点。以及，它不能喝复制垃圾收集这样需要移动的垃圾收集算法组合使用。 Ruby采用的是保守垃圾收集。局部变量可以按照通常语言的访问路径来处理，系统堆栈部分是当做指针数组来扫描的。Ruby大部分是用C编写的，因为有了保守垃圾收集，C库的实现变得非常简单。实际上，Python和Perl因为采用的是引用计数器，C例程内部的引用数管理非常复杂，偶然忘记增减就会发生内存问题。但是，用C编写Ruby扩展库时，基本上不用操心内存管理，好处十分明显。 Boehm GC为C和C++增加了垃圾收集功能。Boehm GC也同时实现了分代垃圾收集。Boehm GC不仅用于C和C++，在Scheme处理系统Gauche等多种语言处理系统中，也作为垃圾收集功能得到广泛的应用。 增量垃圾收集在实时性要求高的程序中，垃圾收集带来的中断时间必须是可预测的。为保证实时性，不需要等垃圾收集完全执行结束，而是要把垃圾收集细分正许多细小的片段，每次执行一点，这叫增量垃圾收集。 增量垃圾收集在垃圾收集处理过程中程序也在同时执行，引用有可能会改变。结果是垃圾收集的一致性不能得到保证。增量垃圾收集为避免这样的问题，采用了与保守垃圾收集相同的写屏蔽操作。 嵌入式处理系统采用的是增量垃圾收集。有名的Io和Lua都实现了增量垃圾收集。 并行垃圾收集在多核环境下，灵活运用线程可以最大限度地发挥多个CPU的能力。并行垃圾收集就是要最大限度利用多个CPU的能力。 并行垃圾收集基本原理与增量垃圾收集大致是一样的，都是利用写屏蔽来维护当前状态的信息。有的并行垃圾收集的实现生成垃圾收集专用线程，把垃圾收集设计成总是与普通处理并行执行。 位图标记以Linux为首的UNIX系列操作系统在使用fork系统调用复制过程时，内存空间并不进行复制而是直接共享。通过写时复制来提高性能。 垃圾收集与这一功能兼容性不好，给引用对象那个设置标记的方式会因设置标记而复制包含该对象的内存页。复制方式也同样会产生大量写内存操作。 位图标记是在利用标记的垃圾收集中消减操作系统内存页复制的方法。它不在对象里设置被引用的标记，而是利用外部位图区域（管理用内存区域）来保存引用标记。 只有标记用的位图部分会发生内存页复制，从而避免了复制没有实际更新的对象所在的内存页。 Ruby的垃圾收集也有了实现位图标记的补丁。 用C语言来扩展RubyRuby是解释型语言，即Ruby程序是由Ruby解释器的程序来解释执行的。 提起解释器，大家会觉得它是逐行读取程序并执行，实际上Ruby解释器是把要执行的程序全部读进来，首先变换成更有效率的内部表现形式。解释器对其内部表现加以分析来执行程序。 解释型语言的特点，马上可以执行，开发周期非常快。至于C、C++、Java这样的编译语言，首先要把程序变换成计算机可以直接执行的形式再从头执行。 在执行程序过程中，编译型语言不再需要对原来程序进行解释和变换，速度很快。但是开发周期较长。 开发与执行速度的取舍这两种类型的语言要做取舍。Ruby的设计方针是开发效率优于执行效率，选择解释型的实现也是必然。 Ruby解释器是由C语言开发的，采用C语言开发理由： C语言作者拿手 C语言运行系统调用，速度高 用面向对象语言来实现别的面向对象语言的话，容易混淆对象的概念。 屏幕快照 2018-07-26 下午5.36.05 引擎是解释内部表现，并实际上执行程序的部分。1.9版本的引擎解释的字节码，可以说是近似于虚拟计算机的机器语言。所以1.9版本的引擎也可以成为VM。 引擎在解释内部表现是，需要其他组件的帮助。内存和对象的管理，变量访问和方法调用的实现等，都要依靠底层称为运行库的组件来完成。运行库提供底层强有力的支持，是程序执行时不可或缺的部分。 Ruby利用的各种类是类库提供的。Ruby的这一部分也是用C编写的。像Ruby这样的解释型语言，因为是经过C编写的引擎来间接执行程序，与一般的编译语言相比，执行速度明显慢得多（100 倍或者 1000 倍）。但是，实际上程序的执行时间大部分都花在 C 編写的类库方法内部，因此在执行速度上很少会产生那么巨大的差距。 扩展库扩展库是指利用Ruby运行库的API,用C定义的类库。Ruby的API使用C几乎可以实现Ruby所有的功能。使用这些API可以很简单地实现如下的功能： 定义类 定义方法 访问实例变量 调用方法 调用块 特意花时间用C来实现扩展库的理由主要有以下两点。 想要比Ruby执行速度快 想使用C可以利用的库。 前面已经说过,Ruby是解释型语言,它的执行速度不如像C这样的编译型语言。如果是绝对需要改善速度的程序,用C扩展库来实现其中成为瓶颈的部分的话,有可能显著改善程序的执行速度。 UNX系列操作系统的大多数功能都是通过C可以访问的库来提供的。Ruby要想利用这些功能的话,就需要有一种从Ruby调用C的API的方法,这最简单的方法就是利用扩展库。 扩展库的编译首先按照以上的顺序编写源代码。若C程序的文件名后约定为c的话,后续步骤会自动识别出来C程序文件。 为生成编译所需要的文件,需要准备必要的Ruby文件。这个文件通常命名为 extconf.rbminitab的 extconf.rb的内容如图所示 屏幕快照 2018-07-26 下午7.09.31 extons,xb是由以下几个部分构成的: 调用 require’mkmf’; 用have_1 ibrary和 hava header检查必要的库和头文件是否存在； 用 create makefile来生成必要的Makefile. create makefile的参数是库的名字。 照图14-34执行 extconfrb,就可以生成Makefi1e。 屏幕快照 2018-07-26 下午7.13.48 用make命令来编译,尔后可以用 make insta11命令来安装编译后的库。 扩展库之外的工具RubyInlineRubylnline可以在Ruby的源代码中直接嵌入C的程序。不用每次准备 exton,rb文件,也不需要明确的编译步骤,非常便利,但它也有不少约束,比如在执行环境中需要有编译器,与外部库的链接也有些麻烦等。 dl有了d1,仅用Ruby也能实现与 minitab同样动作的库。把图1435的程序保存成 inial,rb文件,没有扩展库也可以使用 minitab。al的优点是在没有安装编译器和头文件的环境下也可以运行。 ffi关于Ruby的扩展,ffi库受到关注。ffi是 foreign function interface的缩写,它也提供在Ruby水平上的与外部函数的直接接口,这个目的与d1几乎是一样的。ffi可以从 Ruby Gems得到。ffi的特征是使用lb更有效率地调用外部函数,Ruby、 Rubinius和 GRubby都可以使用同样的API。 为什么要开源自由软件的思想为保证执行的自由,必须能够将软件免费拿到手。出于学习和研究的目的,也必须能够自由地得到源代码。还有,为了修改程序错误,或者为适合自己的目的而进行改造,那就不单单是阅读源代码,还要允许改变源代码。把自己认为好的软件推荐给别人,或者把自己进行的修改或改善与他人共享的话,就需要有再发布的自由。 自由软件的历史曾几何时,在计算机的黎明期,软件完全是硬件的附属物。买了计算机,附带操作系统等源代码,根本就不是什么稀罕的事。那时,或者在更早一些的时候,甚至有这样的情况,从生产厂家买来的计算机连操作系统也没有,需要用户自己来开发各种软件。买了同样计算机的用户互相交换自己开发的软件,互助合作。虽然不够精致,但与如今开源软件的情况很有些相似之处。 Emacs事件的发生但是,戈斯林把 Gosmacs的专利卖给了 Unipress公司,斯托曼就不能够在 Gosmacs的基础上开发新的 Emacs了。结果,斯托曼从零开始开发了自己的UNIX版的Emacs。 他们的最终目标是，创造一个从上到下完全自由的操作系统环境。 开源的诞生 屏幕快照 2018-07-26 下午8.52.32 OSS许可证GPLGPL( GNU General Public license)应该可以说是自由软件许可证的鼻祖,它具有如下特征: 没有保证; 表示版权; 保持同样的许可证 GPL特征中最重要的是保持同样的许可证,也就是说,在对GPL许可证的软件进行修改或复制的情况下,必须保持其原来的GPL许可证。这意味着再利用GPL软件的源代码而开发的软件的许可证也必须是GPL。批判GPL的人把这称为感染性。赞同GPL的人们称之为版权保留,因为这一性质意味着版权的保留。 LGPLBSD许可证APL和CPL开源的背景在科学领域,共享知识和信息本来是非常普通的事情。即使不用看站在巨人的肩膀上的牛顿的例子,把知识作为论文(免费)公开,利用前人的成绩进行新的研究是再理所当然不过的。 软件,特别是商业软件,一旦作为商品来经营的话,就容易忘记这样一点,与论文的内容一样,软件也不过是信息的一种,也应该适用同样的原则。科学家致力于研究,大学或研究机构对科学家给予支持,这种体制对软件也有可能成立。实际上,大学或研究机构支援软件开发的例子相当多。 但是,谈到近年来开源的普及和发展,计算机的普及和因特网的发展则功不可没。过去如果要想开发髙质量软件的话,需要购买价格髙昂的计算机,召集大量的技术人员。现在一般家庭里的计算机都完全能够开发软件,通过网络进行合作开发的事情也屡见不鲜。个人出于兴趣而编程也已经能够达到相当高的水平了。 软件的复杂化和商品化也是开源的背景之一,不容忽视。软件所覆盖的领域越来越广,软件也越来越复杂。过去1万行左右的程序就实现了的操作系统,如今变成了超过600万行的巨大软件。 企业关注开源的理由从1998年以来,开始出现了盈利企业为自己的利益而开发开源软件的事例。一旦认识到无法自己来开发所有软件之后,企业只自己开发最具竞争力的小部分核心软件,而让大家共同来开发其他软件,结果对大家都有好处,企业关注开源正是这种冷静的分析考量的结果。 参与开源的人们也各有各的想法。有因经营考虑而参加的企业,有为软件自由而参加的程序员,有因上级命令而参加的公司职员,各种各样,千差万别。但是,开源有可能为个人和全人类带来幸福,如果能继续下去形成良性循环的话,那真是再好不过了。 Ruby与开源Ruby从一开始就是开源软件。Ruby在1995年初次公开的时候,开源这个单词还没有诞生,也许应该称为自由软件。 选择许可证的方法许可证与技术无关,而是有关法律和合同的工作,这不是技术人员的工作,而是属于律师的工作范围。对于软件开发人员来说,这决不是一件令人感兴趣的工作,有人甚至会想:“哪用得着这些东西呢?” 如果使用你的许可证的软件的所有代码都完全是由你自己写出来的话,这几乎不成为什么问题。只要发布新的许可证版本,问题就解决了但是,如果其中包含了其他人写的补丁的话,软件就不再是你一个人的了,在法律上写补丁的人是共同拥有版权的。 FSF作为软件自由的拥护者,强烈推行版权保留。另一方面,不怎么在乎版权保留的开发人员好像更多一些。如果你希望版权保留的话,几乎就只能选择GPL。 如果你的软件是作为库来使用的话,那么LGPL则是个不错的选择。如果对库适用GPL许可证的话,那事实上就只能为GPL软件所用,采用限制较为宽松的LGPL的话,有可能使你的软件得到更为广泛的使用。但是,LGPL有不方便、难于理解以及没有得到充分考察等缺点,在不太强烈希望版权保留的时候,最好不要选择它。 对于不太在乎版权保留的人来说,可以选择GPL以外的许可证。这里的要点是,该软件是否需要与其他软件进行链接。如果预想到将来可能以某种方式与GPL许可证的软件链接在一起的话,那么与GPL的互换性就变得很重要。拥有插件功能的软件或库特别要注意这一点。作为与GPL不相矛盾的许可证,有修正BSD许可证和MIT许可证等。 另一个应该考虑的要点是,与相关软件和许可证是否一致。比如 Eclipse插件就应该选择Eclipse许可证(即使不与GPL互换)。另外,PHP关联软件选择与PHP一致的许可证也是安全的。用Ruby编写的软件与Ruby本身的许可证本来是相互独立的,但好像也大都选择Rby许可证。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 13 关于数据的持久化","slug":"松本行弘的程序世界 13 关于数据的持久化","date":"2018-07-24T02:00:32.000Z","updated":"2018-07-25T02:35:06.000Z","comments":true,"path":"2018/07/24/松本行弘的程序世界 13 关于数据的持久化/","link":"","permalink":"https://github.com/zdkswd/2018/07/24/松本行弘的程序世界 13 关于数据的持久化/","excerpt":"","text":"松本行弘的程序世界 13 关于数据的持久化持久化数据的方法保存文本变换成文本的Marshal将对象按一定的方式变换成文本，就可以保存到文件中去。这样的对象文本化就称为serialize(序列化)，或是marshal(封送处理)。 使用Marshal模块标准Ruby中，嵌入了marshal功能，这就是Marshal模块。Marshal模块中提供了几乎能将全部Ruby对象变为字节串的方法dump，以及将字节串恢复成原对象（的复制）的load方法。对象可以简单地保存到文件里。 复制有两种方式使用Marshal可以完成对象的深复制。复制对象的时候，通常使用clone方法。这种情况下，只复制直接对象，引用的对象不复制。称为浅复制。深复制连同引用对象也一起进行递归复制。 仔细看Marshal的格式Marshal用二进制形式将对象文本化。 屏幕快照 2018-07-23 上午11.07.00 屏幕快照 2018-07-23 上午11.09.40 不能保存的3类对象Marshal在实现上有限制。以下3类对象不能保存： 定义了特异方法的对象。 输入、输出或是套接字等不能超越进程保存的对象。 在扩充库中定义，Ruby不知道保存方法的对象。 但是即使不能封送处理，若不是像输入输出那种从原理上不可能的情况，单纯是不知道封送处理方法的话，重新教一遍也就行了。 制作面向对象数据库使用Marshal保存对象，使对象具有了持久性。所以，Marshal也可应用于面向对象数据库。PStore库是Marshal的一个用例。Marshal虽然只是将数据变换成字符串，PStore却利用了这一点，简单地实现了面向对象数据库。PStore有三个特征：使用Marshal，可以原封不动地保存任意的Ruby对象；具有容易使用的接口；有事务处理（transaction）。PStore也有缺点，它不适合一下子将数据全部读入内存的大规模数据库。但几百字节的小规模数据库，应该没问题。 试用PStore打开数据库开始事务处理对象的登录和取得事务处理的终止简单说明一下事务处理的步骤： 用flock将数据文件加锁。 用Marshal从数据文件中读取数据 执行（事务处理）块 块的执行成功，Marshal将数据写入数据文件 块的执行失败，什么也不做。 变换为文本的YAMLMarshal的变换结果是二进制文件，内容不容易看懂。有些场合及时效率低一些，也需要能够以更容易看懂的形式输出。能够满足要求的是YAML。使用文本形式，不依赖平台的体系结构，是一种对人而言易读易编辑的序列化格式。 有以下几个特征：记述简洁；结果容易读懂；使用缩进的层次表现；数据表现是专用的，不必烦恼标签的名称问题。 YMAL可以活用在Ruby on Rails的配置文件等各种各样的领域。YMAL是在Perl中开发的，但正式的支持，Ruby是第一个。 用YAML制作数据库类似于PStore的东西，YAML：：Store，其与PStore的互换性非常高，只要把名字换一换，面向PStore的程序在YAML：：Store也能运行。 他俩的区别： 数据格式很显然，一个YAML，一个Marshal。 数据量Marshal比YAML紧凑的多，Marshal牺牲了易读性而实现了良好性能。 执行速度性能优良不光是容量的问题。使用Marshal的PStore比YAML：：Store速度高，在这一点上，也是数据量越大，两者的差异就越显著。 对象的保存对象持久化库Madeleine，利用直接持久化对象的设计模式Object Prevalence。 Madeleine是Object Prevalence在Ruby中的实现，应称为PStore的发展形式。 PStore只是对象单纯由Marshal输出而来，Madeleine则与应用程序相协调，实现了高可靠性和高性能的持久化。 高速的Object Prevalence所谓Prevalence，是一种实现应用程序持久化和进程间共享数据的设计模式。高性能的秘密在于直接访问内存中的数据。Object Prevalence将处理的数据保存在正在执行的应用程序的内存中，检索等操作不通过SQL而是直接进行，节省了与数据库副武器的通信成本，引用当然就会很高速。 但是，只有是同一进程，才能引用内存中的数据，进程一结束，数据马上消失。从持久化角度有必要解决这一问题。 Object Prevalence用日志记录（journaling）和快照（snapshot）来解决这一问题。Object Prevalence中，数据更新时不是直接更新对象，而是创建称为command的对象，采用的是一种非常间接的方法，在用command更新对象时，内存中的对象更新的同时，所有的更新内容也会写到称为日志（journal log）的外部文件中。 长此下去日志越来越大，所以要将现在数据状态写到称为快照的文件中。有了快照，老日志就不需要了，可在适当的时机删除。 有了最新的快照和最新的日志，可以完全恢复现在对象的状态。程序启动，按三步骤恢复内存的数据。及时有多个进程，只要写入日志的信息是完整的，就可以共享对象的状态。 如果不存在快照，就初始化应用程序数据。 如果存在快照，就读入其中最新的一个。 如果还存在日志，也将其读入，并用其中最新的一个更新应用程序数据。 Object Prevalence的问题点Object Prevalence通过使用日志记录和快照实现了对象的持久化和进程间共享。Object Prevalence将所有数据都保存到内存中，随着数据量的增大，内存的消耗也在增大。 关系数据库中，不引用的数据放在文件中，必要的内存量就不用那么多了。 Object Prevalence有为了数据更新而具有的特殊结构，更新持久化数据时需要经由command对象。 使用Madeleine访问时刻信息让Madeleine更容易使用Madeleine既保持简洁性，又能让对象持久化，但是最大的缺点是在每次更新应用程序时必须生成command对象。 Madeleine的实用例InstikiMadeleine没有得到广泛应用，除了知道的人少，还因为数据全保存在内存中，就必须十分留意数据的大小。 Madeleine有一个很大的缺点，就是没有考虑多个进程同时更新数据的情况。 关于XML的考察XML的祖先是SGMLSGML是将文档电子化的一种格式。由三部分组成：表示数据本身的Instance，表示数据结构的DTD，以及SGML声明。 由于SGML太复杂，处理成本太高，为了表现网页，将SGML特化为HTML，随之诞生的是XML。 XML不像HTML那样是为了特定目的的标记语言，它一开始就是为了通用目的而设计的。为了让XML在没有DTD来定义语法或提供schema信息的情况下，也能够解析，人们对其语法进行了简化。 XML是树结构的数据表现XML基本上是纯文本，以类似于HTML的标签嵌套方式实现树结构。XML是继承了SGML的通用标记语言，其与SGML最大的区别是其基本语法固定，不依赖于DTD那样的外部信息也能解析。 即使没有标签的概要信息也能解析的语法称为良构的（well-formed）,这是XML的一大特征。 优点在于纯文本最大的优点在于XML基本上是纯文本的，表示结构的信息附加在标签里。 第二个优点是不易发生字符编码的问题。XML规定，在没有明确指定的情况下，字符编码均使用Unicode。 第三个优点是得益于良构的性质，在没有数据结构的情况下也能解析XML数据。这样就可以不考虑目的，而用共同的工具来处理XML数据。 第四个优点在于，XML与其解析工具不依赖于特定的语言，比如Java生成的XML数据在Ruby中的解析也很简单。解析XML的API，像DOM和SAX都超越语言提供了几乎共通的性质，所以不同语言也可以进行同样的操作。 最后一个有点是，人们也很容易理解。 总之，XML作为各种数据交换格式的框架，具有优良的性质。作为格式的格式，也就是元格式，是很优秀的。 缺点在于冗长最大的缺点是效率低下。XML是以纯文本出现的，标签信息反复出现，显得冗长。与表示相同信息的二进制数据相比，XML数据的容量要大得多，与其他文本表现方式相比（YAML，JSON）也显得冗长。 效率低下不光体现在数据大小上，解析XML的效率也不怎么高。与二进制文件相比，XML文件的解析因为含有大量字符串处理，而容易变得很慢。 作为文本的标记语言而诞生的XML，用其表现有一定结构的数据到底好不好还是个疑问。如果只是用于表现构造数据，比XML更有效率的格式还有很多。而且XML原则上只能表现树结构的数据。 总结，XML作为出于通用目的的数据格式，效率很低，所谓很多优点，如果场合不对，也没多大意义。适才适用，XML也要分情况适当使用。 不适合重视效率的处理对于重视通信量和速度的情况都不适合，此时应使用专用的协议或是效率更高的格式。 像配置文件那样靠人直接编辑的数据也不推荐XML。配置文件中，需要用到XML的树结构数据地方很少，随着要素数增加，就会很难读，用YMAL和JSON才更合适。 XML适合的场合： 人一般不直接接触 复杂性不成问题 效率不成为问题 跨平台 适合于信息交换的格式利用XML的元格式性质，以XML为基础的格式的例子。 RSS。Web网站更新信息。 Atom。RSS的代替。 ebXML。电子商务数据交换。 SVG。向量-图像表示。 SMIL。 多媒体及内容控制。 以上这些都具有XML的性质，可以用XML处理工具简单地解析。制作数据格式时，最麻烦的就是制作处理这种格式的软件。所以，XML与XML处理库的存在是很可贵的。 另外，XML数据库中，问题不在于数据是不是实际以纯文本XML来表现，而在于XML能够表现的树结构能够自由自在地操作。即，不是带标签的纯文本，而是由带属性、带内容的节点所构成的树结构本身才是最重要的。关系数据库的表只能表示间接数据，如果是树结构，可以直接操作直接表现的数据。 XML的解析XML的解析方法有好几种。 DOMDOM是文档对象模型的缩写，是对读取了XML数据的树结构进行操作的库。 SAXSimple API for XML,与将数据全部读入内存的DOM不同，通常，SAX以数据流的形式读入XML，以事件驱动进行处理。SAX中，没必要将数据全部读入，这样往往处理效率更高，所以适合于将XML变换为其他形式的处理，反过来说，不适合于对树结构进行随机访问等用途。 XPathXPath是用于指定XML树的一部分的书写格式。使用XPath，可以用节点名、属性名或是属性值等来选择特定的节点（群）。 XML处理库REXMLREXML是Ruby标准附属的XML处理库。REXML是具有DOM、SAX、SAX2以及XML Pull Parser等多照片那个功能的库。全部用Ruby实现，所以速度表现不怎么优秀。在特别重视效率的情况下，有必要用libxml等别的XML处理库。 XML的代替JSON（JavaScript Object Notation）JSON是把JavaScript的对象记法作为表现格式来使用。 将JSON数据原封不动地作为JavaScript去执行，就可以得到数据表现所对应的对象。但是JSON数据从外部读取的情况较多，实际上作为JavaScript直接执行容易引起安全上的问题，即使效率稍稍低一些，也应当使用解析JSON的库。 Ruby支持JSON。 YMAL（YMAL ain’t Markup Language）YMAL是作为XML的对立面而诞生的，具有以下特征。完全放弃标记性记述，专注于数据表现；以缩进为基础表现数据结构；不要标签；可以对应各种语言。 在用作数据表现及配置文件时，具有易读和不易变复杂等优点。实际上，YAML在Ruby on Rails中广泛用于配置文件。 另一方面，YAML到底是数据表现语言，没有相当于schema的东西，不适合于带结构的文本表现及元数据格式。 活用记号和缩进的YMAL比JSON更简洁，正如其名，YMAL不是标记语言，需要使用标记语言时还是XML合适。 Binary XML与通常的XML有等价意义，但效率更高，采用二进制表现的是Binary XML。但现在还没有Binary XML的标准规格。 Protocol BufferProtocol Buffer使用一种“数据描述语言”来定义数据结构，然后从这个定义生成一个库，将原始数据变为二进制表现（序列化）。 12持久数据的重要性如果不是有了像纸和刻了文字的石头等经久不烂而且可以读出的媒介，将来人类文明说不定会遇到失去重要信息的危险。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 12 关于时间的处理","slug":"松本行弘的程序世界 12 关于时间的处理","date":"2018-07-23T13:53:32.000Z","updated":"2018-07-23T13:53:46.000Z","comments":true,"path":"2018/07/23/松本行弘的程序世界 12 关于时间的处理/","link":"","permalink":"https://github.com/zdkswd/2018/07/23/松本行弘的程序世界 12 关于时间的处理/","excerpt":"","text":"松本行弘的程序世界 12 关于时间的处理用程序处理时刻与时间时差与时区世界协调时间夏令时一定时期内时钟拨快一小时。 改历日期与时间的类Time类表示日常所用时间的类。 Date类表示不含时刻的日期的类。 DateTime类Date类附加上时间信息的类。能表示时间，而且没有范围限制，功能上最强。 2038年问题不仅限UNIX，很多操作系统都是以过去某个时点开始所经过的时间来表示时刻的。在UNIX中，过去某个时点指1970年1月1日零点。问题是计算机能够处理的整数大小有限，界限是2038年1月19日3时14分7秒。 DateTime类相对于epoch（某个时点）开始的秒数来管理Time类，DateTime类是以日期为基础计算的Date类，附加上时刻信息而生成的。 Time与DateTime的相互变换","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 11 程序安全性","slug":"松本行弘的程序世界 11 程序安全性","date":"2018-07-21T13:28:32.000Z","updated":"2018-07-21T13:29:05.000Z","comments":true,"path":"2018/07/21/松本行弘的程序世界 11 程序安全性/","link":"","permalink":"https://github.com/zdkswd/2018/07/21/松本行弘的程序世界 11 程序安全性/","excerpt":"","text":"松本行弘的程序世界 11 程序安全性程序的漏洞与攻击方法四种软件漏洞 dos攻击 信息泄露 权限夺取 权限升格 DOS攻击，即拒绝服务攻击，指妨碍软件正常运行（服务的执行）的网络攻击手段。能够引起软件异常终止的程序错误，全部都是引发DOS攻击的安全性程序错误。分为软件漏洞与外部DOS攻击。信息泄露指不愿公开的信息被公开了。 因权限被窃取而成为重大问题安全问题的根源在于运行软件的人（权限所有者）和利用软件的人是不同的。安全问题有三种 恶意软件指在程序本身植入了恶意代码。 setuid/setgid指执行的程序以所有者权限进行动作。setuid的缺点已经变得比优点更突出，现在几乎不用了。 服务器 “守护神”引起的问题服务这里指的是为了提供服务而常驻型的软件，又为后台服务(daemon),即守护神的意思。后台服务基本上都是受理经由socket而来的请求。执行它所提供的服务，将结果经socket返回。几乎所有的情况，发出请求者和执行权限者都是不同的。这种软件若有了漏洞，会引起DOS问题和权限夺取问题。 多样化的攻击手段代表性的有： 缓冲区溢出 整数溢出 跨站点脚本攻击（XSS） SQL注入 跨站点伪造请求（CSRF） 缓冲区溢出指向固定的缓冲区输入了比假定长度要长很多的数据，使程序异常终止。或者是更改堆栈的跳转地址劫持程序。使用C那种连数组长度都不检查的语言，可以说肯定会产生问题。幸亏，像Ruby这样的高级语言，语言处理系统自动分配内存，可以不使用固定长的缓冲区。使用更高级的语言，可以从缓冲区溢出问题中解放出来。但由于速度上的考虑，还会开发C语言的CGI及Daemon程序，应多加注意。 整数溢出整数溢出与缓冲区溢出相似，但它是更难被发现的问题。c等很多语言，整数只能表示一定范围的数，超过范围，就会发生溢出，也不发出警告就将数值舍入。这个问题通过使用Ruby这样的高级语言可以解决，内存分配不是由用户直接进行，内部分配都要经过严格检查。所以，只要使用Ruby，与整数溢出就不沾边。 SQL注入SQL注入是对外部的输入检查不充分时所产生的典型问题。从外部的输入不能原封不动填到SQL语句中去，因为填入的文字可能含有对SQL语句有某种意义的文字。 Shell注入Shell注入与SQL注入原理相同。从外部的输入，如果不进行检查就不能传递给system等危险的函数。为了从一定程度上检查出这类问题，Ruby和Perl中有“污染检查”功能。给外部输入的数据加上“污染记号”，禁止对字符串进行危险操作。 跨站点脚本攻击跨站点脚本攻击与SQL注入和Shell注入一样，也是因为将输入值原封不动地放在输出值内而引起的问题。如用户输入中含有HTML标签。而且HTML可能夹杂JavaScript。 跨站点伪造请求跨站点伪造请求（CSRF）是Web应用程序固有的攻击手段。构成Web应用程序的每一页由两部分构成，一个来自网路浏览器的HTTP请求，一个是HTTP服务器的响应。 屏幕快照 2018-07-21 下午7.11.22 社会工程用异常进行错误处理异常的历史Java的受控异常采用受控异常的，Java是第一个。 Icon的面向目标判断Ruby在设计之初，也曾认真考虑过采用像Icon式的真伪值判断，结果还是采用了nil和false以外的值全是真值的这种正统方式。 Ruby的异常 屏幕快照 2018-07-21 下午7.30.12 异常发生 屏幕快照 2018-07-21 下午7.33.32 异常处理的设计方针方法的执行应当“异常安全”，即执行时及时发生了异常也不会发生异常情况： 因为发生了异常，留下了不完全的数据结构 因为发生了异常，数据库里进了垃圾 因为发生了异常，程序异常终止 异常发生的设计原则假设发生的情况与既有的异常类明显不同，需要制作一个新的异常。此时考虑： 名称：应该给新的类起一个什么样的名字 父类：新的类应该属于哪一个异常类的子类 生成方法：应该如何初始化新的类实例 产生异常的两个原则：1异步异常，基本原则是不要使用异步异常。2.文档化，有必要清楚详细的写成文档。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 10 高速执行和并行处理","slug":"松本行弘的程序世界 10 高速执行和并行处理","date":"2018-07-20T09:58:32.000Z","updated":"2018-07-20T10:20:12.000Z","comments":true,"path":"2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/","link":"","permalink":"https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/","excerpt":"","text":"松本行弘的程序世界 10 高速执行和并行处理让程序高速执行（前篇）是不是越快越好并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。 高速执行的乐趣与效率在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。 以数据为基础做出判断改善系统调用排序处理任务重时，典型的对策是使用施瓦茨变换。 数据可靠吗误差 只需改善瓶颈性能优化中，“因为是排序，所以就用施瓦茨变换”这种条件反射式的对策并非总管用。为了合理提高速度，确立恰当的策略是很必要的。帕累托法则又称80/20法则，即80%的数值是由20%的构成要素产生的。由帕累托法则可知，有20%的努力可以达到巨大回报，而有80%的努力得不到多少回报。在得不到回报的地方，不管怎么努力都是徒劳的。Donald Knuth也提到，通常一半以上的执行时间都耗费在程序中不到4%的部分。这些耗费了大半以上执行时间的部分称为瓶颈。判定瓶颈，可以用profiler这一工具。 profiler本身成了累赘不确定性原理是指测定行为本身对被测对象产生了影响，从原理上可以说不可能正确知道对象的状态。但是知道实际状态的大体倾向。 算法与数据结构选择合适的算法，这是性能改善的第一考虑因素，要记住这条铁则。 理解O记法如何从效率方面判定一个算法的好坏呢。一个方法就是O记法，表示某种算法对于变量（比如使用的元素个数）如何变化。 屏幕快照 2018-07-20 上午11.05.39 选择算法调查算法的性能Ruby提供进行算法性能比较时用的benchmark程序。 高速执行的悲哀徒劳无益的努力很容易在瓶颈无关的地方花费太多徒劳无益的努力。 改良绊住了手脚sort_by所依据的施瓦茨变换，是用时间和空间的交换来消减计算量的方法。sort_by方法与sort方法相比，占用了多达三倍以上的内存。所以，模块内的处理本来不是很重，如果一味地占用内存反而可能会变慢。性能优化，光有理论还不行，如果不实际做的话就不知道到底什么是正确的。 算法选择的圈套在进行性能优化时，不改变原来程序的执行时一个大原则。 性能优化的格言过早的优化是万恶之源。 优化有两条准则。1.别做优化2.（仅适用于专家）先不要做优化 过早的优化是万恶之源代码优化的好处多多，但是这并不意味着所有的代码都需要进行优化，有时过度的优化反而适得其反——费时、费力、不讨好。“现代计算机科学的鼻祖”Donald Knuth曾说过“过早的优化是万恶之源”，因为：让正确的程序更快，要比让快速的程序正确容易得多。在项目开发中，总是有程序员浪费宝贵的时间去改进那些不需要改进的代码，而没有通过所做的改进增加价值。在对项目进行优化时，究竟哪些地方应该优化，应该如何优化，哪些不应该优化呢？你需要先来了解一下本文所说的这7件事。1.究竟要优化什么？在优化工作开始的时候，你还尚未明确优化内容和目的，那么你很容易陷入误区。在一开始，你就应该清楚地了解你要达到的效果，以及其他优化相关的各种问题。这些目标需要明确指出（至少精通技术的项目经理可以理解和表达它），接下来，在整个优化过程中，你需要坚持这些目标。在实际的项目开发中，经常会存在各种各样的变数。可能一开始时要优化这一方面，随后你可能会发现需要优化另一方面。这种情况下，你需要清晰地了解这些变化，并确保团队中的每个人都明白目标已经发生了变化。2.选择一个正确的优化指标选择正确的指标，是优化的一个重要组成部分，你需要按照这些指标来测量优化工作的进展情况。如果指标选择不恰当，或者完全错误，你所做的努力有可能白费了。即使指标正确，也必须有一些辨别。在某些情况下，将最多的努力投入到运行消耗时间最多的那部分代码中，这是实用的策略。但也要记住，Unix/Linux内核的大部分时间花费在了空循环上。需要注意的是，如果你轻易选择了一个很容易达到的指标，这作用不大，因为没有真正解决问题。你有必要选择一个更复杂的、更接近你的目标的指标。3.优化在刀刃上这是有效优化的关键。找到项目中与你的目标（性能、资源或其他）相背的地方，并将你的努力和时间用在那里。举一个典型的例子，一个Web项目速度比较慢，开发者在优化时将大部分精力放在了数据库优化上，最终发现真正的问题是网络连接慢。另外，不要分心于容易实现的问题。这些问题尽管很容易解决，但可能不是必要的，或与你的目标不相符。容易优化并不意味着值得你花费工夫。4.优化层次越高越好在一般情况下，优化的层次越高，就会越有效。根据这个标准，最好的优化是找到一个更有效的算法。举个例子，在一个软件开发项目中，有一个重要的应用程序性能较差，于是开发团队开始着手优化，但性能并没有提升太多，之后，项目人员交替，新的开发人员在检查代码时发现，性能问题的核心是由于在表中使用了冒泡排序算法，导致成千上万项的增加。尽管如此，高层次的优化也不是“银弹”。一些基本技术，如将所有东西移到循环语句外，也可以产生一些优化的效果。通常情况下，大量低层次的优化可以产生等同于一个高层次优化的效果。还需要注意的是，高层次优化，会减少一些代码块，那么你之前对这些代码块所做的优化就没有任何意义了，因此，刚开始就应该考虑高层次的优化。5.不要过早优化在项目早期就进行优化，会导致你的代码难以阅读，或者会影响运行。另一方面，在项目后期，你可能会发现之前所做的优化没有起到任何作用，白白浪费了时间和精力。正确的方式是，你应该将项目开发和优化当作两个独立的步骤来做。6.依赖性能分析，而不是直觉你往往会认为你已经知道哪里需要优化，这是不可取的，尤其是在复杂的软件系统中，性能分析数据应该是第一位的，最后才是直觉。优化的一个有效的策略是，你要根据所做工作对优化效果的影响来进行排序。在开始工作之前找到影响最大的“路障”，然后再处理小的“路障”。7.优化不是万金油优化最重要的规则之一是，你无法优化一切，甚至无法同时优化两个问题。比如，优化了速度，可能会增加资源利用；优化了存储的利用率，可能会使其他地方放慢。你需要权衡一下，哪个更符合你的优化目标。 让程序高速执行（后篇）例题是曼德勃罗集合的计算程序，指复平面上满足以下条件的复素数的集合：经过某种反复迭代运算以后，其值不会发散到无限大。 确认程序概要发现瓶颈使用profiler 使用更好地profilerruby-prof程序通过使用扩展库可以实现高速profile 高速优化之一：消减对象Ruby高速优化的规则。 减少对象高级面向对象语言中对象的生成要花费一定的时间，减少对象，除了会降低生成成本外，还有别的好处。Ruby中不在使用的对象，由被称作垃圾收集的处理自动进行回收。垃圾收集处理需要检查对象的引用关系，任何地方都不再引用的对象会被判定为已经不再使用了。当对象的数量很多时，判断成本就要增大。 减少方法调用方法调用中，存在多态性这一面向对象的本质特征，先要评价参数，判定对象种类，然后选出一个合适的方法，再讲控制交给该方法，这是一个缓慢的处理过程。为了避开方法调用，尽可能不用Ruby中实现的方法。Ruby中实现的方法，几乎所有的情况都是调用其他方法来实现的。也就是说，只要使用了一次Ruby中实现的方法，就会有多余的方法调用发生。 高速优化之二：利用立即值Ruby中有几类对象并不实际分配内存，而是用引用本身来表示，这种值称为立即值。现在的Ruby中，小的整数（±2 ^30以内）、真假值、nil和符号名等都是立即值。立即值既然不生成对象，就不用担心对象的生成成本，而且也不用垃圾收集处理，所以它具有特别理想的特性。 高速优化之三：利用C语言Ruby是解释性语言，单纯计算的循环不是很快。如果将处理交给编译器，就可以变得很快。 高速优化之四：采用合适的数据结构全部以C语言计算还存在其他技巧还有以空间换时间。 并行编程使用线程的理由与进程不同，同一进程的线程可以共享内存空间，所以，不同的线程能够引用同一对象。不需要经过将数据变为字节流再进行通信这样麻烦的处理，就能交换信息。 生成线程线程的执行状态Ruby的线程有四种状态。run：执行中stop：停止中to_kill:终止处理中killed:终止 屏幕快照 2018-07-20 下午1.55.11 传递值给线程的方法信息共享所产生的问题 数据完整性丧失 死锁 与其说是线程的问题，不如说是并行处理本身的问题。 数据完整性的丧失原子操作 死锁哲学家进餐问题 用锁来实现对资源的独占Ruby Mutex类，互斥锁。Java中，方法定义声明为synchronize,该方法被调用时自动加锁。 二级互斥很遗憾，锁的问题并不全是Mutex所能覆盖的单纯事例。如数据库中，对数据的访问需要以下多种互斥控制。 可以同时引用 禁止同时更新 禁止更新中引用 禁止引用中更新 引用与更新这种两个层次的互斥（二级互斥），在文件读取时也经常会发生。 数据库锁总结 数据库锁出现的原因是为了处理并发问题，因为数据库是一个多用户共享的资源，当出现并发的时候，就会导致出现各种各样奇怪的问题，就像程序代码一样，出现多线程并发的时候，如果不做特殊控制的话，就会出现意外的事情，比如“脏“数据、修改丢失等问题。所以数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制，所以数据库锁是跟并发控制和事务联系在一起的。 平时会经常看到或者听到数据库锁有“共享锁”，“排它锁”，“互斥锁”，“写锁”，“读锁”，“悲观锁”，“乐观锁”，“行级锁”，“表级锁”，“页级锁”等，同时我们还会常看到“丢失修改“，”不可重复读“，”读脏数据“这三个术语，他们究竟是什么关系以及怎么理解呢，下面就来介绍一下他们。 先说事务的特性，要想成为事务，必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；一致性指的是事务的执行结果必须是使数据库从一个一致性状态变大另一个一致性状态，一致性和原子性是密切相关的；隔离性指的是一个事务执行不能被其他事务干扰；持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。 先说悲观锁和乐观锁吧。并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。乐观锁就比较简单了，就是不做控制，这只是一部分人对于并发所持有的一种态度而已。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁和共享锁，其中排它锁又称为写锁，共享锁又称为读锁。 共享锁和排它锁是具体的锁，是数据库机制上的锁，存在以下关系： 屏幕快照 2018-07-20 下午2.17.40 (x表示是排它锁(Exclusive)，s表示共享锁(Share)，Y表示yes，N表示no） 上图表示可以共存的锁，如，第二行表示，一个事务T1给某数据加了X锁，则事务T2就不能再给那数据加X锁了，同时也不能再加S锁了，只有到T1事务提交完成之后，才可以。默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁。另外，并发操作会导致数据的不一致性，主要包括“丢失数据”，“不可重复读”，“读脏数据等。还有就是，并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防，预防的方法有：1一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；2顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。另外，系统如何判断出现死锁呢，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁，诊断和判断死锁有两种方法，一是超时法，二是等待图法。超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。 最后，说下行级锁和表级锁。锁包括行级锁和表级锁行级锁是一种排他锁，防止其他事务修改此行。 用队列协调线程使用锁对资源进行互斥控制，是线程间保证协调的一种机制。除了锁以外，为了保证协调，还有别的方法。问题的根源在于多个进程访问同一资源，为了实现无共享，给每个资源准备一个管理用的线程，各线程间只能交换某些限定的信息。线程间信息交换的方法有代表性的有信息存储，信道及队列。 屏幕快照 2018-07-20 下午3.05.36 1这里的生产者消费者问题并不是典型的生成者消费者问题，而是做出了一定的限制，即生产速度小于消费速度。不锁buffer,仅做信息传递的通道来进行说明。 队列也可以用于解决资源的竞争。 屏幕快照 2018-07-20 下午3.08.13 锁模型与队列模型的比较锁模型如果竞争足够少，多数情况下能保持较高性能，对于资源的竞争，不能忘记加锁，要做到完美无缺较难。 队列模型在竞争少的时候，其性能比不上锁模型，比锁模型更容易贯彻，会因线程增多而带来性能低下的恶果。 前景可期的并行编程技术，Actor并行编程，要求有更高的抽象度和对人类而言更简单的编程模型。Actor（参与者模式）或许就是答案。 何谓Actor所谓Actor，是（仅）通过消息（message）进行通信的实体。与面向对象语言中对象的区别。向对象发送消息（方法调用），调用开始后，会一直等到返回结果，是一种同步方式。面向Actor发送消息，仅仅是发送消息而不返回结果，是一种异步方式。123同步(Synchronous)和异步(Asynchronous)1.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。2.异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。 Actor由于仅仅通过消息进行信息交换，所以不能直接共享同一个值，信息传达要多花些代价。Actor由于没有消息以外的信息传递手段，所以不用担心Actor之间的资源竞争。发送给Actor的消息都配送到各个Actor所拥有的邮箱里。多个消息同时到达时竞争由内嵌到系统中的排除机制来处理。Actor的一大优点是安全，更大的优点是易懂。Actor根据消息进行处理，必要的化会向其他Actor传递消息，或向Actor返回消息。这与现实世界中人与人之间相处没有多大的差别。现实世界中，别人在想什么你不知道，想要求什么时，需要通过某种手段传递“消息”。理论上要到达最高性能，一般认为线程更优秀。但如果不注意使用线程的话，会出现与时机相关的很麻烦的问题。在计算机性能日益提高的今天，与理论上最高性能的可能性相比，Actor的安全性和易懂性更引人注目。 操作Actor的三种处理系统Actor Model的函数型语言Erlang。Erlang是只允许单一赋值的函数型语言，即一旦赋值，变量的值就不再改变。 Erlang的程序pingpong处理的开始启动pingpong程序Erlang的错误处理Erlang中通过发送消息来通知异常终止。收到消息的process（actor）料理死去的process后事。有了这种机制，使得Erlang适合构造抗障碍性强的系统。 Erlang的使用场所Erlang在通常的文本处理汇总并不怎么快。Erlang的好处在于其扩展性。对于多个处理并列执行的情况，分割成合适的Erlang process，能够发挥多CPU的威力。同样的多任务分割虽然用操作系统的进程或线程也能实现，但Erlang的process与操作系统的进程或线程相比，能够轻量实现（1个process最小只耗费300字节），即使有大量process也不必顾虑、更进一步说，Erlang设计思想不用process连基本处理都不能实现，process分割在某种意义上可以说是强制的。 适合现代服务器端程序。 面向Ruby的库“Revactor”Revactor的目的是为Ruby提供Erlang式的编程。其优点是可以同时体验Ruby和Erlang的好处。但是Revactor中Actor的实现不是靠线程而是靠Fiber。Erlang的目的在于最大限度地利用多核CPU，而Revactor并不适合这种目的。Revactor的最大优点，是能够在等待文件输入输出时，将程序的停止控制在最小程度。 另一个库DramatisDramatis是Ruby中另一个Actor库。函数型语言Erlang不支持面向对象功能。用Ruby这样的面向对象语言来实现Actor的时候，即使用普通对象来实现Actor，也不可避免地会出现把方法调用和发送消息这两种类似概念混在一起的情况。Dramatis库就是解答这种“概念混淆”。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"Android群英传 3 Android控件架构与自定义控件详解","slug":"Android群英传 3 Android控件架构与自定义控件详解","date":"2018-07-18T07:27:32.000Z","updated":"2018-07-18T09:58:53.000Z","comments":true,"path":"2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/","link":"","permalink":"https://github.com/zdkswd/2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/","excerpt":"","text":"Android群英传 3 Android控件架构与自定义控件详解Android控件架构控件大致被分为两类，即ViewGroup控件与View控件。通过ViewGroup，整个界面的控件形成了一个树形结构控件树。上层控件负责下层子控件的测量与绘制，并传递交互事件。findViewById（）方法，就是在控件树以数深度优先来遍历查找对应的元素。每颗控件树的顶部，都有一个ViewParent对象，为整棵树的控制核心，所有的交互管理事件都由它统一调度和分配，从而可以对整个视图进行整体控制。 屏幕快照 2018-07-17 下午2.31.03 通常，在Activity中使用setContentView（）方法来设置一个布局，在调用该方法后，布局内容才真正的显示出来。 屏幕快照 2018-07-17 下午2.36.21 每个Activity都包含一个Window对象，由PhoneWindow来实现。PhoneWindow将一个DecorView设置为整个应用窗口的根View。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通用方法。DecorView将要显示的具体方法呈现在PhoneWindow上，这里面的所有View的监听事件通过WindowManageService来进行验收，并通过Activity对象来回调相应的onClickListener。在显示上，它将屏幕分为两部分，TitleView和ContentView。 屏幕快照 2018-07-17 下午2.45.14 其中ViewGroup会根据对应参数设置不同的布局，如最常用的布局。而如果用户通过设置requestWindowFeature(Window.FEATURE_NO_TITLE)来设置全屏显示，视图树中的布局就只有Content了，这就解释了为什么调用requestWindowFeature()方法一定要在调用setContentView()方法之前才能生效的原因。在代码中，当程序在onCreate（）方法中调用setContentView（）方法后，ActivityManagerService会回调onResume（）方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。 View的测量系统在绘制View前，必须对View进行测量，即告诉系统该画一个多大的View，在onMeasure（）方法中进行。通过系统提供的设计精悍功能强大的类MeasureSpec类来测量View。MeasureSpec为32位int值，高2位位测量的模式，低30位为测量的大小，在计算中使用位运算是为了提高并优化效率。测量模式为3种： EXACTLY即精确值模式，当我们将控件的layout_width或layout_height属性指定为具体数值时，或指定为match_parent属性时（占据父View的大小），系统使用的是EXACTLY模式。 AT_MOST即最大值模式，当控件的layout_width或layout_height属性指定为wrap_content时，控件大小一般岁总监的子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。 UNSPECIFID不指定大小测量模式，View想多大就多大，通常情况下在绘制自定义View时才会使用。 View类默认的onMeasure（）方法只支持EXACTLY模式，所以如果自定义控件时不重写onMeasure方法的话，就只能使用EXACTLY模式。控件可以响应你指定的具体宽高值或是match_parent属性。而如果要让自定义View支持wrap_content属性，那么就必须重写onMeasure（）方法来指定wrap_content时的大小，如果不重写，就不知道该使用默认多大的尺寸，因此，就会默认填充整个父布局，所以重写onMeasure（）方法的目的，就是为了能够给View一个wrap_content属性下的默认大小。 View的绘制测量好一个View后，我们就可以重写onDraw（）方法，在Canvas对象上来绘制所需要的图形。当创建一个Canvas对象时，需要传进去一个bitmap对象。这个bitmap用来存储所有绘制在Canvas上的像素信息。调用所有的Canvas.drawXXX方法都发生在这个bitmap上。 ##ViewGroup的测量ViewGroup会去管理子View，就有负责子View的显示大小。当ViewGroup大小为wrap_content时，就需要对子View进行遍历，以获得所有子View的大小，从而决定自己的大小。其他模式则会通过具体的指定值来设置自身的大小。ViewGroup在测量时通过遍历所有的子View，从而调用View的Measure方法来获得每一个子View的测量结果。当子View测量完毕时，就需要将子View放到合适的位置，这个过程就是View的Layout过程。ViewGroup在执行Layout过程时，同样是使用遍历来调用子View的Layout方法，并制定其具体显示的位置从而来决定其布局位置。在定义ViewGroup时，通常会重写onLayout方法来控制其子View显示位置的逻辑。同样，如果要支持wrap_content属性，必须重写onMeasure。 ViewGroup的绘制ViewGroup通常不需要绘制，如果不是指定了ViewGroup的背景颜色，ViewGroup的onDraw方法都不会被调用，但是，ViewGroup会使用dispatchDraw()方法来绘制其子View，其过程同样是通过遍历所有的子View，并调用子View绘制方法来完成绘制。 自定义View在自定义View时，我们通常会去重写onDraw()来绘制View的显示内容，如果该View还需要使用wrap_content属性，那么还必须重写onMeasure()方法。另外，通过自定义attrs属性，还可以设置新的属性配置值。在View中通常有以下一些比较重要的回调方法。 onFinishInflate():从XML加载组件后回调。 onSizeChanged():组件大小改变时回调。 onMeasure():回调该方法来进行测量。 onLayout():回调该方法来确定显示的位置。 onTouchEvent():监听到触摸事件时回调。 通常有以下方法来实现自定义的控件。 对现有控件进行扩展。 通过组合来实现新的控件。 重写View来实现全新的控件。 对现有控件进行扩展可以再onDraw()方法中对原生控件行为进行扩展。程序调用super.onDraw(canvas)方法来实现原生控件的功能。 创建复合控件创建复合控件可以很好地创建出具有重用功能的控件集合。这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，再给它添加指定功能的控件，从而组合成新的复合控件。通过这种方式创建的控件，我们一般会给它指定一些可配置的属性，让它具有更强的扩展性。 定义属性为一个View提供可自定义的属性非常简单，只需要在res资源目录的values目录下创建一个attrs.xml的属性定义文件，并在该文件中通过代码定义相应的属性即可。 屏幕快照 2018-07-17 下午5.04.48 在代码中通过&lt; declare-styleable&gt;标签声明了使用自定义属性，通过name属性来确定引用的名称。通过&lt; attr&gt;标签来声明具体的自定义属性。通过format属性来指定属性的类型。在确定好属性后，就可以创建一个自定义控件，让它继承自ViewGroup，从而组合一些需要的控件。在构造方法中，通过TypedArray对象的getString()和getColor()等方法，就可以获取这些定义的属性值。 屏幕快照 2018-07-17 下午5.11.26 屏幕快照 2018-07-17 下午5.12.42 屏幕快照 2018-07-17 下午5.13.03 当获取完所有的属性值后，需要调用TypedArray的recyle方法来完成资源的回收。 组合控件通过动态添加控件的方式，使用addView（）方法将控件加入到模板中，并给它们设置前面所获取到的具体的属性值，如文字颜色、大小等。 屏幕快照 2018-07-17 下午5.16.29 定义接口 屏幕快照 2018-07-17 下午5.21.03 暴露接口给调用者 屏幕快照 2018-07-17 下午5.25.21 屏幕快照 2018-07-17 下午5.25.46 实现接口回调在调用者的代码中，调用者需要实现这样一个接口，并完成接口中的方法。 屏幕快照 2018-07-17 下午5.28.58 除了通过接口回调的方式来动态的控制UI模板，同样可以使用公共方法来动态地修改UI模板中的UI。这样可以进一步提高模板的可定制性。 屏幕快照 2018-07-17 下午5.31.54 引用UI模板在需要使用的地方引用UI模板，在引用前，需要指定第三方控件的命名空间。 屏幕快照 2018-07-17 下午5.33.56 这行代码就是在指定引用的命名空间xmlns，即xml namespace。这里指定了名字空间为“android”，因此在接下来使用系统属性时，才可以使用“android:”来引用Android的系统属性。如果要使用自定义的属性，就需要创建自己的名字空间。在Android Studio中，第三方的控件都使用如下代码来引入名字空间。 屏幕快照 2018-07-17 下午5.39.45 这里我们将引入的第三方控件的名字空间取名为custom，之后再xml文件中使用自定义的属性时，就可以通过这个名字空间来引用。 屏幕快照 2018-07-17 下午5.41.56 使用自定义的View与系统原生的View的最大区别就是在申明控件时，需要指定完整的包名，而在引用自定义的属性时，需要使用自定义的xmls名字。再更进一步，将这个UI模板写到一个布局文件中，在其他的布局文中，直接通过&lt; include&gt;标签来引用这个UI模板的View。 重写View来实现全新的控件当Android系统原生的控件无法满足我们的需求时，我们就可以完全创建一个新的自定义View来实现需要的功能。通常需要继承View类，重写onDraw，onMeasure来实现绘制逻辑，同时重写onTouchEvent等触控时间来实现交互逻辑。还可以像实现组合控件那样，通过引入自定义属性，丰富自定义View的可定制性。 弧线展示图音频条形图自定义ViewGroup重写onMeasure来对子View进行测量，重写onLayout确定子View的位置，重写onTouchEvent增加响应事件。 事件拦截机制分析Android为触摸事件封装了一个类MotionEvent，里面封装了触摸点的坐标，点击事件的类型。 屏幕快照 2018-07-18 下午3.08.26 对于ViewGroup重写了三个方法：dispatchTouchEventonInterceptTouchEventonTouchEvent对于View来说，重写了两个方法：onTouchEventdispatchTouchEvent 屏幕快照 2018-07-18 下午3.12.38 屏幕快照 2018-07-18 下午3.12.47 dispatchTouchEvent基本不用动。事件拦截的核心方法是onInterceptTouchEvent返回值：True，拦截，不继续；False，不拦截，继续流程。事件处理onTouchEvent返回值：True，处理了，不用给上级汇报了，上级不会继续处理了；False，给上级处理。 屏幕快照 2018-07-18 下午3.20.48","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"Android群英传 2 Android开发工具新接触","slug":"Android群英传 2 Android开发工具新接触","date":"2018-07-14T04:18:32.000Z","updated":"2018-07-14T04:19:03.000Z","comments":true,"path":"2018/07/14/Android群英传 2 Android开发工具新接触/","link":"","permalink":"https://github.com/zdkswd/2018/07/14/Android群英传 2 Android开发工具新接触/","excerpt":"","text":"Android群英传 2 Android开发工具新接触Android开发IDE介绍ADB命令使用技巧ADB–Android Debug Bridge，借助此工具，我们可以用电脑来操作手机。 ADB基础ADB工具位于SDK的platform-tools目录下。手机助手也是使用ADB来实现它的功能。手机端需要开发者模式，USB Debug。 adb shell可以使用Linux Shell命令。 android list targets显示系统中全部Android平台 adb install -r 程序.apk安装apk程序之install abd push &lt; local&gt; &lt; remote&gt;安装apk程序之push两者都可以安装上APK，但是install是安装到data/data目录中，作为普通的用户应用程序。push则不是安装命令，是将文件写入手机的存储系统，所以，只要拥有相应的权限，就可以把任何Apk放到任何目录中，甚至是System目录下成为一个系统应用程序。 abd push &lt; local&gt; &lt; remote&gt;向手机写入文件 abd pull &lt; local&gt; &lt; remote&gt;从手机获取文件。这些东西在Android Device Monitor工具都可以直接使用。 通过Logcat来查看Log删除应用查看系统盘符输出所有已经安装的应用模拟按键输入模拟滑动输入查看运行状态Package管理信息AM管理信息录制屏幕重新启动ADB命令来源模拟器使用与配置","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"Android群英传 1 Android体系与系统架构","slug":"Android群英传 1 Android体系与系统架构","date":"2018-07-14T03:01:32.000Z","updated":"2018-07-14T03:02:20.000Z","comments":true,"path":"2018/07/14/Android群英传 1 Android体系与系统架构/","link":"","permalink":"https://github.com/zdkswd/2018/07/14/Android群英传 1 Android体系与系统架构/","excerpt":"","text":"Android群英传 1 Android体系与系统架构Google生态系统Android系统架构 2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d 这些层次结构即是相互独立的，又是相互关联的。 LinuxLinux层(仅为Linux内核)，Android最底层最核心的部分。显示内核版本，就是显示所用的Linux内核的版本。Linux层包含了Android系统的核心服务，包括硬件驱动，进程管理，安全系统等等。 Dalvik与ARTDalvik包含了一整套Android运行环境虚拟机，每个App都会分配Dalvik虚拟机来保证互相之间不受干扰，并保持独立，特点是在运行时编译。在Android 5.x开始，ART模式已经取代了Dalvik，ART是安装时进行编译，在运行时就不用编译了。 Framework见上图 Standard libraries见上图 Application不管是使用NDK开发还是Java开发的App，都有Android Manifest文件、Dalvik Classes、Resource Bundle这些东西。 Android App组件架构即四大组件：Activity、BroadCastReciever、ContentProvider和Service。它们是组成一个Android App的最基本元素。 Android四大组件如何协同工作Activity作为人机交互的第一界面，负责向用户展示和处理结果，信息的来源可以是通过资源获取，也可以是通过Content Provider来获取其他应用的信息，或是Service从后台计算，下载，处理后的结果，也可以是通过BroadCast Reciever获取到广播信息。同时，Android系统还提供了一个信使Intent，作为信息传递的载体。组件与组件之间通过Intent来通信、传递信息、交换数据，正是通过这样一种方式，四大组件形成了各自独立而又紧密联系的关系。 应用运行上下文对象Android系统上下文对象即Context，Activity、Service、Application都是继承自Context。Android应用程序会在几个时间点创建应用上下文Context。 创建Application 创建Activity 创建Service 创建Context的时机就是在创建Context的实现类时。 Android系统源代码目录与系统目录Android系统源代码目录包含了Android系统所有的源代码，从底层驱动到上层应用，Android系统对所有文件都进行了详细管理。在手机中，Android系统的目录和源代码目录不是一一对应的，与源代码编译后，与打包生成的Image文件的结构相同。 Android系统源代码目录看完Android源代码，要懂C、懂脚本、懂Java。 屏幕快照 2018-07-14 上午10.18.18 应注意，不是所有的源代码结构都是这样。只有AOSP的Android项目才是这样的结构，有些芯片厂家如MTK目录结构就不同。Android源码采用Makefile编译。像Android这样的大型项目，它的源代码不计其数，不同的功能，模块，按类型分别放置在不同的目录中，这些模块通常会有Makefile文件进行管理。它定义了一系列的规则来指定模块，哪些文件需要编译，以及这些文件该按照怎演的顺序去编译。甚至可以配置更复杂的功能操作，比如定义编译规则，打包规则，Makefile就像一个shell脚本，不仅可以使用自己的语法，也能调用操作系统的命令。Android系统源代码目录每个目录中还会包含更多的目录，而它的每一个最小的功能单位的目录下，都会有一个Makefile文件，这样每一级向上，通过一个个Makefile文件，就把整个源代码有条不紊的联系在一起了。 Android系统目录通过ADB连上手机，通过Linux的ls命令查看Android系统的根目录。其中/system和/data是开发者非常关心的两个目录。 /system/app/这里面放的是一些系统的App /system/bin/这里面主要放的是Linux自带的组件 /system/build.prop这里记录的是系统的属性信息。 /system/fonts/系统字体存放的目录root后可下载TTF格式字体替代原字体。 /system/framework/系统的核心文件，架构层。 /system/lib/存放几乎所有的共享库（.so）文件。 /system/media/该目录用来保存系统提示音、系统铃声。 /system/usr/该目录用来保存用户的配置文件，如键盘布局、共享、时区文件等。 /data/app/data目录包含了用户大部分数据信息。app目录下包含了用户安装的App或者升级的App。 /data/data/这个目录应该是开发者访问最多的目录了，这里包含了App的数据信息，文件信息、数据库信息等，以包名的方式来区分各个应用。 /data/system/这个目录包含了手机的各项系统信息。 /data/misc/这个目录保存了大部分的WiFi、VPN信息。 Android App文件目录","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"松本行弘的程序世界 9 整数和浮点小数","slug":"松本行弘的程序世界 9 整数和浮点小数","date":"2018-07-12T09:41:32.000Z","updated":"2018-07-12T09:39:19.000Z","comments":true,"path":"2018/07/12/松本行弘的程序世界 9 整数和浮点小数/","link":"","permalink":"https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 9 整数和浮点小数/","excerpt":"","text":"松本行弘的程序世界 9 整数和浮点小数深奥的整数世界整数是有范围的 屏幕快照 2018-07-12 下午4.23.38 尝试位运算 屏幕快照 2018-07-12 下午4.24.58 操作特定的位位运算组合起来，可以对存储在计算机中的各位进行自由操作。操作二进制位就等于操作计算机的数据。基本的位处理操作有4种。 取出特定位的状态 特定位置位（设为1） 特定位清零（设为0） 特定位反转 将操作限制在特定位的数为掩码。 表示负数的办法 开头一位做符号位 将整数的各位反转（1的补数） Ruby的整数Ruby的整数有两种，一种是范围有限制的整数Fixnum（32位CPU是31位，64位CPU是63位），另一种是范围没有限制（超过内存容量除外）的整数Bignum，根据计算结果自动变换。 挑战公开密钥方式RSA加密的强度（解读的困难程度），就归因于素因数分解的难度。 扑朔迷离的浮点小数世界计算机对小数的处理固定小数点数不易使用浮点数，就是小数点的位置可以移动。 科学计数法也有问题计算机中广泛使用的小数表示方法是科学计数法。科学计数法是指将有效数字和指数组合起来表示小数（实数）。 屏幕快照 2018-07-12 下午5.01.23 IEEE754规定，尾数部分的首位始终归一化为1，所以首位始终省略，实质有效数字为53位。 小数不能完全表示 计算机中的数的表示有长度（位数）限制。 计算机中数的表示是二进制。 浮点数是有限的浮点数有误差对于浮点小数，结合法不成立有不能比较的时候对于浮点数进行比较运算，只有两个数在内部表示是完全相同的情况下才判定为相等。作为铁则，两个浮点数不能用==进行比较运算。如果有进行比较的必要，判断条件中的两个数的差要足够小。根据操作系统的不同，对于浮点数，足够小的值e有不同的定义。 误差积累减少运算次数。 不是数的特别“数” 屏幕快照 2018-07-12 下午5.13.14 无限大Inf，零0，非数NaN 计算误差有多种舍入误差最大值溢出与最小值溢出信息丢失位数脱落截止误差误差导致的严重问题BigDecimal是什么浮点数运算的陷阱可以归结为：1. 能够表示的精度有限 以二进制来表示 Ruby提供了BigDecimal类，有以下3个特点： 与Bignum一样，有效数字自动扩展 以十进制计算 以C语言记述，比内嵌的浮点数类（Float）要慢 能够表示分数的Rational类","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 8 正则表达式","slug":"松本行弘的程序世界 8 正则表达式","date":"2018-07-12T04:41:32.000Z","updated":"2018-07-12T04:43:36.000Z","comments":true,"path":"2018/07/12/松本行弘的程序世界 8 正则表达式/","link":"","permalink":"https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 8 正则表达式/","excerpt":"","text":"松本行弘的程序世界 8 正则表达式正则表达式基础检索“像那样的东西”正则表达式的语法普通字符除了表中所示的元字符以外的普通字符，都与该字符自身相匹配。 屏幕快照 2018-07-12 上午10.28.08 字符集合用括号（【】）括起来的部分为字符集合。与括号内所含的每一个字符都匹配。比如，【abcde】能与小写字母abcde中的任何一个相匹配。字符集合中，用中划线（-）来指定范围。所以，【abcde】可以用【a-e】来代替。字符集合中，第一个字符是【\\^】时，表示取反。就是说，不与括号（【】）中的字符相匹配。 任意一个字符表示任意一个字符读得模式是“.”。除了匹配换行符。 重复 屏幕快照 2018-07-12 上午10.42.59 贪婪与懒惰贪婪：寻找符合的最长的，遍历完再回溯，懒惰：寻找第一个符合的。 分组将模式绑定起来的功能称为分组。（ma）+ 选择| 锚点指定位置而不是字符来进行匹配。称为锚点（anchor）。 屏幕快照 2018-07-12 上午10.53.24 三个陷阱记号多、密度高的表达式为应对这一问题，出现了扩展正则表达式。 0次以上的重复贪婪型匹配正则表达式对象面向对象语言Ruby中，所有数据都是对象。正则表达式也是对象。Ruby程序中正则表达式对象写成/.*/的样子。正则表达式对象可以用正则表达式类方法生成。程序中由组合字符串生成正则表达式时，使用类方法更自然。 选项Ruby正则表达式末尾斜杠的后面，可以为这个正则表达式添加选项。 屏幕快照 2018-07-12 上午11.34.28 屏幕快照 2018-07-12 上午11.35.23 正则表达式匹配的方法 屏幕快照 2018-07-12 上午11.37.23 特殊变量Ruby中有源于Perl的特殊变量。以$开头的变量。 屏幕快照 2018-07-12 上午11.41.33 字符串与正则表达式 屏幕快照 2018-07-12 上午11.43.29 split的本质分割字符串的方法split,与正则表达式组合起来能实现很多功能。 字符串的扫描置换想要置换与字符串模式匹配的部分，可以用置换方法。 正则表达式的应用实例与“鬼车”正则表达式是表达字符串模式的一种微型语言。正则表达式由字符本身、字符模式、锚点以及重复等组合而成。 解析日志文件的方法避免使用$的方法记号$不美观。Ruby中，以match方法替代=~运算符，就可以在程序中不使用这些记号了。 从邮件中取出日期的方法典型拼写错误的检索方法Ruby1.9的新功能“鬼车”“鬼车”新正则表达式库。123456DSLDomain Specific Language,意为面向特定领域的编程语言。DSL分内部DSL和外部DSL。内部DSL，就是往既有的语言中加入特定领域的词汇，使之DSL化。如软件编译工具Rake中表达依存关系的内部DSL。make是一个同样目的的工具，它使用Makefile来表达依存关系。Rake可以利用Ruby的编程功能、方法定义、条件分歧和循环等，不管关系有多复杂，都可以编程对应。外部DSL，不是扩展现有的语言，而是面向特定目的，如SQL就是DSL的代表性例子。正则表达式也可以称作是以实现模式匹配为目的的外部DSL。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 7 文字编码","slug":"松本行弘的程序世界 7 文字编码","date":"2018-07-12T02:00:32.000Z","updated":"2018-07-12T02:01:00.000Z","comments":true,"path":"2018/07/12/松本行弘的程序世界 7 文字编码/","link":"","permalink":"https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 7 文字编码/","excerpt":"","text":"松本行弘的程序世界 7 文字编码文字编码的种类早期的文字编码纸带与文字的表现文字是什么走向英语以外的语言（欧洲篇）英语以外得到语言（亚洲篇）Unicode的问世统一编码成16位的汉字统合Unicode的两个问题选择16位文字的Unicode有两大副作用。一是字节顺序的问题，一是NUL文字问题。字节顺序就是低八位先放还是高八位先放的问题。传统C语言处理的字符串，一般有一个终端文字NUL（‘\\0’）。但是作为16位文字的字符串，中途会出现NUL文字。所以，C语言中处理字符串的传统函数不能用于16位文字的字符串。像java那样的语言，一开始就是以16位文字为前提而设计的，所以没什么问题。但以C语言处理16位文字的时候，需要全新的api。 Unicode的文字集现在，Unicode放弃了16位方式，而用21位来表示一个文字，现在Unicode能够表示4111个文字，肯定够用了。 文字表示的不确定性Unicode的字符编码方式UTF-8UTF-8以一定式样的字节组合来表示Unicode中的21位文字。对于内部程序处理字符串非常方便，另外没有字节顺序问题，在外部处理时也很有用。缺点：消费过多内存，几乎所有的汉字都要占用3个字节。构成文字的字节数是可变的，随机访问任意文字，代价与字符串长度成正比。但是随着计算机内存的容量和性能提高，这些缺点也无所谓了。 UTF-16Unicode中能以16位表示的空间就以16位表示，超过16位就以两个16位码组合来表示。到现在缺点已经很突出了，从今以后没必要采用这种字符编码方式了。 UTF-32固定长，可以随机访问，但存在字节顺序的问题。因为4字节，没什么人气。 程序中的文字处理文字编码有多个意思只能处理文字集中包含的文字纷繁复杂的文字编码方式影响力渐微的Shift_JIS与EUC-JPUnicode有多种字符编码方式为什么会发生乱码字符编码方式错误没有字体变换为内部码时出错发生不完全变换文字集的不同字节顺序错误像UTF-16，UTF-32这种基本数据单位大于一个字节的编码方式，存放数据时字节该以什么顺序摆放，有两大流派，一个是big endian,一个是little endian。所以同样是UTF-16格式（UTF-32也一样）根据字节顺序不同就会有两种。UTF-8就不会。 从编程语言的角度处理文字编程语言处理文本数据的方法，有UCS方式和CSI方式两种。 以变换为前提的UCS方式UCS（泛用字符集），是指程序中所处理的共同文字集（及字符编码方式）。输入输出时，编程语言将文本数据变成UCS，内部对文本数据进行统一处理。优点： 原理简单，容易实现 除变换外，处理成本低 实际成果多 缺点： 发生不必要的变换 变换存在模糊部分 有外字及机种依存文字的问题 UCS中不包含的文字绝对不能处理 原封不动处理的CSI方式CSI（Character Set Independent，字符集独立），是指不对各种文字集（及编码方式）进行任何变换，原封不动地进行处理。相对于UCS的内部只有一种编码方式的处理方式，CSI中对各种编码方式原封不动地处理。CSI是优点多，自由度高的方式。 不发生不必要的变换 不发生变换所带来的问题 不易发生外字的问题。 理论上不存在不能处理的文字 根据需要，可以处理应用程序独立的文字集 缺点： 字符串的处理容易变得复杂化 预计处理性能会变低 实际成果少 实际上，现在存在的多种编程语言中，采用CSI方式的几乎没有。 使用UTF-16的JavaJava采用UCS方式，内部字符编码选用UTF-16制作Java时，Unicode仅限于16位。java没选择可变长的UTF-8，而选择UTF-16，因而产生了这样的悲剧。说是时机的恶作剧也罢，真是太可惜了。 使用UTF-8的PerlPerl也使用UCS方式，内部编码方式采用UTF-8。 用UTF-16的PythonUCS，UTF-16 采用CSI方式的Ruby1.8强化了功能的Ruby1.9是UCS还是CSI","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 6 Ruby On Rails","slug":"松本行弘的程序世界 6 Ruby On Rails","date":"2018-07-11T04:00:32.000Z","updated":"2018-07-11T03:59:46.000Z","comments":true,"path":"2018/07/11/松本行弘的程序世界 6 Ruby On Rails/","link":"","permalink":"https://github.com/zdkswd/2018/07/11/松本行弘的程序世界 6 Ruby On Rails/","excerpt":"","text":"松本行弘的程序世界 6 Ruby On RailsMVC和Ruby On RailsMVC是设计GUI程序的设计模式之一。大部分设计模式仅决定程序某一部分的构成，而MVC决定了应用程序的整体部分，有时候也被成为架构模式。 模型、视图和控制的作用模型：是表现窗口中表示内容（信息）的对象。模型代表的只是信息（名字、数值等抽象的信息），它不能包含如何来显示这些信息的信息。视图：代表将模型中包含的信息在窗口中进行表示的对象。视图知道要表现的模型的信息，而模型一般不知道要表示自己的视图信息。控制：是从用户端接受输入，对视图和模型进行操作的对象。 屏幕快照 2018-07-11 上午9.26.46 用秒表的例子来学习MVC模式生成视图和控制部分GUI工具箱与MVC同时使用工具箱和MVCMVC的优缺点优点： 可以更换界面一个模型对应多个视图多个视图可以同时响应容易测试缺点： 复杂性强关联性对模型对象进行了功能追加这样的变更后，相应地也必须对视图和控制进行变更。 Web应用中的MVCWeb应用基本是HTTP。HTTP的一次处理经过了一下过程：（1）Web浏览器对应于用户的操作，向Web服务器发出HTTP请求。（2）Web服务器根据请求，准备好发送到Web浏览器的数据。（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。 利用MVC来描述：（1）Web浏览器发送过来的HTTP请求通过Web服务器传给控制部分。Web应用框架的分配器把请求传递给合适的控制部分。（2）控制部分操作的模型和请求的信息相对应，同时制定显示使用的视图。视图从模型启动，一边引用模型一边准备发送给Web浏览器的数据。（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。 屏幕快照 2018-07-11 上午9.54.09 Ruby on Rails上的MVC各部分功能稍有不同。Rails中的模型相当于数据库层，视图指显示用的模板，控制器指控制用的类（包含了应用逻辑）。 屏幕快照 2018-07-11 上午9.56.48 开放类和猴子补丁猴子补丁，即在动态语言中，不改变源代码而对功能进行追加和变更。现在灵活使用开放类，变更和追加方法全部称为猴子补丁。 开放类Ruby的类的特征是所谓的开放类，相对于其他语言，特别容易打猴子补丁。Ruby中，可以把String类、Array类等基本的数据类型及所有的类都作为开放类处理，可以自由地追加功能。 猴子补丁的目的功能追加利用开放类可以给已有的类追加功能。 功能变更修改程序错误因为重新定义了有程序错误或有副作用的方法，不用修改原来那部分的代码就可以解决问题。这也是本来的猴子补丁的目的。 钩子有时间想在每个方法调用的同时增加一些其他处理。这种伴随方法调用而进行的处理称为“钩子”（hook），钩子的追加也可以用猴子补丁来实现。 缓存（cache）猴子补丁的技巧可以吧Ruby提供的对方法、类和模块进行操作的功能运用到打猴子补丁上。最基本的功能就是给已有的方法改名或取消。 屏幕快照 2018-07-11 上午10.58.20 undefundef有把方法取消定义的功能。用undef不仅可以取消本类中的方法，也可以取消父类中定义的方法。 aliasinclude灵活使用开放类的库jcode库可以不使用正则表达式，利用开放类的功能，使得字符串的方法可以处理多字节文字。 猴子补丁的几点问题若要正确使用开放类，安全地打猴子补丁，需遵守： 基本上只是追加功能对类追加新方法不会让已有的程序无法执行。使用开放类时，主要做不容易导致问题的功能追加会更保险。做功能追加时，如果发生名称重复会造成麻烦，在选择追加的方法名时需要慎重。 进行功能变更时要慎重，尽可能小规模 小心相互作用 其他方法猴子补丁能够不改变源代码进行动态修改，这种灵活性是显示动态语言柔软性和扩展性的好例子。实现猴子补丁的Ruby开放类有时功能过强，可能会引起问题。其他语言中用更易控制的形式也能实现猴子补丁。 Ruby on Rails和开放类Rails构成部分之一ActiveSupport库。ActiveSupport利用Ruby的开放类功能，对Ruby标准提供的类大胆地追加了功能。 ActiveSupport带来的扩展 时间 字节单位系列 复数形和序数 大规模开发和Ruby编译时不作类型检查Ruby在执行时作类型检查，大规模程序为了保证可靠性一定会有严格的测试程序，如果作了严格的测试，在编译时作类型检查的优点就不像所说的那么重要了。 没有包Java对于构成库的类和文件有独立的包，要想具备某种功能，必须明确地进行import操作。而Ruby是不具备这种功能的。所以，库定义的类和模块名是全局的，从任何地方都可以引用。因此，可以说名称重复的危险性很大。 存在开放类各自独立的库发生互相矛盾的变更时，问题不能简单解决。这也可能在大规模开发时引发问题。 信赖性模型在某种类型的大规模开发中，Ruby的性质会造成问题，或者说造成问题时解决起来不像其他语言那么容易，这种现象是现实中可能存在的。如果认为这些是问题的话，可能不使用Ruby会更好。但是，到现在为止我们看到的情况表明，会发生那种问题的大规模开发本来就绝不是好的开发状况。首先要做的，是把项目的信赖关系改善到可以使用Ruby的程度。就算是最后也没有使用Ruby，这也是应该先做到的事情。 猴子补丁的未来猴子补丁虽然有一定的危险性，但有利有弊，它也提供了方便性、扩展性和灵活性。开放类和利用它的猴子补丁，将来也可能会被更安全的、由1特定目的而特制的功能群而替代。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 5 Ajax","slug":"松本行弘的程序世界 5 Ajax","date":"2018-07-10T09:25:32.000Z","updated":"2018-07-10T09:26:45.000Z","comments":true,"path":"2018/07/10/松本行弘的程序世界 5 Ajax/","link":"","permalink":"https://github.com/zdkswd/2018/07/10/松本行弘的程序世界 5 Ajax/","excerpt":"","text":"松本行弘的程序世界 5 AjaxAjax和JavaScript（前篇）Ajax（Asynchronous JavaScript and XML）,含义是异步JavaScript及XML。Ajax不算是一个新技术，只是既有技术的组合。 通信及异步页面更新Ajax的最大特点是进行异步操作，异步意味着Web浏览器的通信和页面更新是互相独立的。以前的Web应用程序，每按下一个按钮就开始显示下一个页面，在页面完整呈现之前，用户只能等待，无法进行其他操作，使用Ajax技术的页面是在后台和HTTP服务器进行通信，设计优良的Web应用程序，在客户和服务器通信的过程中也可以让用户进行操作，而不需要等待。Ajax的最大优点是改善了应用程序的操控性。 屏幕快照 2018-07-10 上午8.52.52 Ajax技术中，对于用户进行的操作，基本是由JavaScript在Web浏览器中进行响应。尽在数据必须从服务器获取的情况下，才在后台进行异步通信。在通信过程中，用户也可以继续对Web浏览器进行操作。和服务器通信得到的结果由DHTML对当前的页面进行部分更新而现实出来。 技术要素之一：JavaScript支撑Ajax的三个主要技术：JavaScript、XML及DHTML。JavaScript是几乎所有Web浏览器处理系统都支撑的一种编程语言。因此，它被称为世界上最普及的编程语言。JavaScript可以简单的嵌入到表示网页的HTML中去，利用JavaScript可以做出完全不用和服务器进行通信的网页。 技术要素之二：XMLXML（eXtensible Markup Language）,和SGML、HTML类似，使用标签（tag）对数据进行标识说明的一种语言。XML已经成为了数据表示、配置各种文件及其他多种场合下广泛使用的一种格式。Ajax的名字中部分包括了XML，是因为当初大部分使用Ajax技术的应用程序都使用了XML数据，以及用JavaScript进行异步通信的对象的名字是XMLHTTPRequest。当然不用XML的XMLHTTPRequest的通信也是存在的，使用Ajax技术的Web应用进行通信的数据格式也是多种多样的，比如有普通文本格式以及YAML，JSON。 XML以外的数据表示形式YAML（YAML Ain’t Markup Language）看出它不是标记语言。YAML只是表示数据的语言，目的仅仅是表示数据。特点有： 记述简洁 容易理解 专注于表示数据，不用费心考虑给标签起名字。 屏幕快照 2018-07-10 上午9.30.23 和YMAL相提并论的是JSON（JavaScript Object Notation）意思是JavaScript对象表示法。是直接把JavaScript表示对象的程序拿来记述数据。JSON是合法的JavaScript程序，作为JavaScript实现可以生成对象。JSON可以表现下面6种数据类型：数值（整数及浮点小数）、字符串、布尔值（真、假）、数组、对象（键和值的表）和null。YAML通过扩展可以表示各种形式的数据。相比较，JSON就简单太多了，但也够用了。 技术要素之三：DHTMLDHTML，动态HTML，顾名思义，可以动态地对HTML进行引用、修改和更新。更具体的说，是利用装载在网页中的JavaScript，使用DOM（文档对象模型）对网页数据进行操作。使用DOM可以进行下述处理： 取得页面中特定标签中的数据； 修改标签的数据（文字、属性等） 在页面中添加标签； 设定事件处理程序JavaScript技术基础JavaScript是以对象为基础的语言，所有的数据都可以作为“对象”进行统一处理。不过，它不具备“类”这样的所谓普通面向对象语言所提供的功能，即使去除JavaScript面向对象的编程功能，它也可以作为普通的结构化编程语言来使用。基本语法JavaScript的基本语法和C、Java类似。最大的不同是，JavaScript不指定变量类型。函数定义JavaScript的特点之一是把函数作为对象进行处理。C也是将函数作为对象处理，但JavaScript的不同之处在于函数对象有闭包（closure），可以使用函数外面的局部变量。闭包功能称为了JavaScript面向对象功能的基础。1闭包是Ruby中块变为对象后的结果。它的优点是，只要闭包还存在，就能访问闭包内的变量。 原型模式的面向对象编程语言如果具有原型模式的面向对象功能的话，就可以最大限度地消减语言本身的固有功能。这非常适合于JavaScript这样的语言。以类为中心的传统面向对象编程，是以类为基础生成新对象。类和对象的关系可以类比成铸模和铸件的关系。而原型模式的面向对象编程语言没有类这样一个概念。需要生成新的对象时，只要给对象追加属性。设置函数对象作为属性的话，就成为方法。当访问对象中不存在的属性时，JavaScript会去搜索该对象prototype属性所指向的对象。JavaScript利用这个功能，使用“委派”而非“继承”来实现面向对象编程。1委派是指，把对于某个对象的调用传送到另一个对象上。 JavaScript的方式过于简单反而使记述太过复杂。 使用prototype.js库为了克服JavaScript记述过于繁杂的缺点，JavaScript提供了进行功能扩展的一些库。如prototype.js库prototype.js受到了Ruby的影响，实际上Ruby on Rails中标准地附加了prototype.js库，使用得很广泛。 prototype.js的功能Ajax功能prototype.js支持XMLHttpRequest对象，可以对HTML进行异步更新。实际上不同Web浏览器获取XMLHttpRequest对象的方法也是不同的。Ajax.Request帮我们屏蔽了与代码移植相关的问题。 Enumerable它是Ruby的Enumerable模块在JavaScript中的实现。 其他扩展功能如使用Object.extend()给对象追加功能。 Ajax和JavaScript(后篇)像Ajax有3个特点： 没有Web页面跳转 通过异步通信实现快速反应 实现了动画和拖拽等单独使用HTML格式无法表现的用户界面构成DHTML基础的JavaScript是一个速度不怎么快的语言。某种技术在开发出来之后经过相当长一段时间才得到普及，此类例子并不少见。巧妙使用DHTMLDHTML被称为Ajax的本质技术。顾名思义，可以动态访问、更新HTML。具体就是利用嵌入网页的JavaScript，使用DOM操作页面数据。1DOM是操作HTML和XML的规范。特点是把HTML和XML作为树结构进行处理。 HTML被读取后，生成树结构。 屏幕快照 2018-07-10 下午4.39.14 使用JavaScript对树结构进行操作就是DHTML的本质。因此JavaScript提供的W3C DOM API有如下功能： 获取documnent节点 获取和更新标签数据（包括文字、类型以及属性等） 追加documnent节点 设定时间处理程序（event handler） 获取documnent节点 getElementById(name)getElementsByTagName(name) 获取和更新标签数据获取节点对象后，通过调用对象的方法，读写对象的属性等就能够获取和更新标签数据。 设定事件处理程序两种办法： 指定标签属性。如设置为a标签的onclick属性值来指定事件处理程序。 把方法设为JavaScript对象的属性。如 屏幕快照 2018-07-10 下午4.49.48 追加标签节点用appendChild方法可以为节点对象追加节点，消除节点用removeChild方法。 本地HTML应用和服务器间的通信使用DHTML之后，对于较简单的应用，在客户端就能够实现。但是，客户端无法保存数据，所以保存和获取数据时需要和服务器进行通信。Ajax是利用XMLHTTPRequest对象来进行异步通信，不需要网页跳转，在后台就可以进行通信。 使用Prototype.js的优点不需要麻烦的记述。 在服务器上保存数据Web应用的脆弱性如XSS（跨站点脚本问题） 使用JavaScript的感觉作为动态语言名副其实DHTML比想象的更有趣Prototype.js也不错调试比较麻烦JavaScript理就算有程序错误，Web浏览器也不会显示任何信息。想要确认程序的状态，只能多次使用alert()。Firefox提供了Firebug的扩展功能，对于JavaScript的调试非常有用。 兼容性问题Ajax开发最难的一点就是Web浏览器间JavaScript的兼容性问题。12名字的重要性起了一个合适的名字本身意味着功能设计的正确。反过来，起了不好的名字说明设计者自己也没有完全理解应完成什么样的功能。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 4 设计模式","slug":"松本行弘的程序世界 4 设计模式","date":"2018-07-09T10:21:32.000Z","updated":"2018-07-20T11:02:15.000Z","comments":true,"path":"2018/07/09/松本行弘的程序世界 4 设计模式/","link":"","permalink":"https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 4 设计模式/","excerpt":"","text":"松本行弘的程序世界 4 设计模式设计模式（1）设计模式的价值和意义Gamma他们并没有发现新的模式，总结出来的23种设计模式也是软件开发中早就存在并反复使用的模式，因此并不能说是Gamma他们的首创。但即使是这样，设计模式有了名字，人们就可以认识到它的存在，并对之进行讨论。这种不能用语言表达的知识称为内隐知识。给这些在软件中经常反复出现的模式命名，使得这些本来只有经验丰富的程序员才能认识到的软件设计模式能被广泛认识和讨论。 设计模式是程序抽象化的延伸一旦有了设计模式，只要把过去优秀的人们考虑出来的模式拿来应用一下。 Ruby中的设计模式Singleton模式单件模式。用来保证某个类的实例只有一个。Ruby实现Singleton模式的方法有几个 使用singleton库的方法Ruby以库的形式实现了Singleton模式。使用Singleton库，在任意类中include Singleton模块，那个类就变成Singleton模式的对象。 使用类或模块C++和java是不能把类作为对象使用的，与之不同的是，smalltalk或Ruby能把类也作为对象来处理。因此，在类或模块中定义一个方法就可以实现Singleton模式。 把一般的对象作为Singleton来使用为了把一个类的对象限制为只有一个，并不一定要对对象的一般生产方法进行限制。可以生成一个一般的对象，然后不要在生产更多个对象了。 使用对象和特异方法Ruby可以在对象生成以后再增加新的方法。 Proxy模式Proxy（代理）模式是为某个对象提供代理对象的模式。在不知道是否真正需要一个生成代价很大的对象时可能造成很大浪费，但不生成又什么都做不了。 Iterator模式Iterator（迭代器）模式提供按顺序访问集合对象中各元素的方法。即使不知道对象的内部构造，也可以按顺序访问其中的每个元素。Iterator模式是为集合对象另外准备用来控制循环处理的对象，就像C++或java一样，我们称这个循环控制对象为Iyerator，也称为游标。 外部与内部，哪一个更好它们都有方便的一面，也都有不方便的另一面。 内部迭代器的缺陷内部迭代器不能同时进行多个循环，也就无法实现按顺序比较两个集合元素的处理。 外部迭代器的缺陷外部迭代器的缺陷在于迭代器对象需要引用集合对象的内部信息，为了按顺序访问集合对象的各个元素，迭代器需要访问集合的内部构造，破坏了隐藏集合内部构造的封装性原则。 设计模式（2）模式与动态语言的关系《设计模式》一书中介绍了23个设计模式。这些设计模式可分为3大类：（1）有关生成的模式（5个），有关构造的模式（7个）以及有关行为的模式（11个）。Singleton为（1），Proxy为（2），Iterayor为（3）。 重复使用既存对象的Protoype模式Protoype（原型）模式明确一个实例作为要生成对象的种类原型，通过复制该实例来生成新的对象。在需要新种类对象时，首先复制一个既存的对象，给复制的对象直接增加方法或实例变量等功能，生成最初的第一个新种类对象。最初一个也并不特别，只是偶尔被用来复制而已。相对于类模式编程，原型模式的编程构成元素比较少，具有简单实现面向对象功能设计的倾向，JavaScript的面向对象就是原型模式。io语言也是。 亲身体验IO语言Ruby中的原型基本上讲Ruby是类模式的语言，但也拥有支持原型模式编程功能。 复制对象的clone方法 给个别对象增加方法的特意方法功能 给个别对象增加一组功能的extend方法 静态语言中没有原型编程，因为不可能给复制的对象增加新方法。 编写抽象算法的Template Method模式用Ruby来尝试Template MethodRuby的类库中最大限度灵活运用Template Method模式的部分，应该是Enumerable模块和Comparable模块了。 动态语言与Template Method模式Template Method模式的这种优秀性质与语言是不是静态没有关系。 避免高度依赖性的Observer模式Observer（观察者）模式是当某个对象的状态发生变化时，依存于该状态的全部对象都自动得到通知，而且为了让它们都得到通知，定义了对象间一对多的依存关系。这是控制类与类之间依存关系的一种模式。高度依赖性会导致组成程序的零件过大，避免高度依赖性的Observer模式，构成观察者模式的有两个对象，一个称谓Observer（观察者）接受变更通知；另一个称为Subject（对象）或Observable（被观察者），发出变更通知。被观察者让人得到被动的印象，在实际处理中，被观察者会发出通知“我已经变化了哦”。 Observable模块Ruby中为实现Observer模式提供了名为observer的库。observer库提供observer模块。 Observer模式与动态语言由于Ruby的动态性质，Observer库具有以下几方面的灵活性。 观察者类不必是特定类的子类。 观察者类不必实现特定的接口（本来在Ruby中也没有接口） 观察者类的更新方法名可以自由决定 观察者类更新方法的参数可以自由决定 被观察者类不必是特定类的子类 对被观察者类的要求，只是将Observable模块包括进来。 123说到事件监听模式,很容易将它和观察者模式联系在一起。实质上这两者完成同类型的工作。依个人理解，事件监听模式更像是观察者模式的进阶。事件监听机制就是对观察者模式进行了进一步抽象，节省了代码量。 设计模式（3）软件开发的悲剧 复杂性 变化性 软件的规模越大，各个部分之间的牵连越复杂，更改也就越难。在软件开发过程中，需求变更几乎是不可避免的。 开放-封闭原则对模块扩展必须开放，对修改必须封闭。为了应对将来的需要，扩展必须是开放的，但是即使某一模块的内部结构改变了，对外接口也应当是不变的。简称OCP。 面向对象的情况既要开放，又要封闭，看似互相矛盾，但是面向对象编程语言能够很彻底地消除这个矛盾。 非面向对象的情况非面向对象则很难处理好。面向对象的精髓在于对OCP的实践。至于把对象看做物体理解起来比较容易，能够建立现实世界的模型等，不过是锦上添花。 OCP与Template Method模式虽说使用面向对象语言的功能，可以实现OCP，但是只是说有这种可能性，并不是说什么时候都能实现。当然，虽然使用了面向对象语言，却做成了一个糟糕的设计，这种情况也是屡见不鲜。分类中很多设计模式之所以优秀是因为经得起OCP所要求的变化。Template Method模式，是满足OCP的基本手段。其他的设计模式都是利用多个类的关联来实现的，而Template Method模式则仅仅使用了继承，基本上无非是实现了一个抽象类。 Observer模式Observer模式是满足OCP的。DRY也好，OCP也好，都不过是原则，根据具体情况，要做适当的选择，如果代码没有再利用的打算，也没有扩展功能的打算，也就没有必要生搬硬套设计模式。使用前有必要先做判断。 使用Strategy模式Strategy（策略）模式是定义算法的集合，将各算法封装，使它们能够交换。利用Strategy模式，算法和利用这些算法的客户程序可以分别独立进行修改而不互相影响。Strategy模式就是将容易变化的处理归纳为独立的对象，然后使它们能够互相交换，使用方法与将容易变化的处理交给子类的Template Method模式相类似。两个模式最大的区别在于，Strategy模式是独立的对象，能够动态交换处理逻辑。 Strategy模式与OCPStrategy模式完全满足OCP。世上很多设计模式，为了能应对将来可能的修改，都是按照OCP的要求来设计的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 3 程序块","slug":"松本行弘的程序世界 3 程序块","date":"2018-07-09T02:21:32.000Z","updated":"2018-07-11T02:11:19.000Z","comments":true,"path":"2018/07/09/松本行弘的程序世界 3 程序块/","link":"","permalink":"https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 3 程序块/","excerpt":"","text":"松本行弘的程序世界 3 程序块程序块的威力Ruby的特色功能之一——程序块。Ruby的程序块是指在方法调用时可以追加的代码块。 把函数作为参数的高阶函数高阶函数是指以函数作为参数的函数。为了实现高阶函数，编程语言中必须把函数和方法作为数据来处理。 C语言高阶函数的局限在C语言中，实现函数间的信息传递只有两种方法：要么明确地传递参数，要么使用全局变量，没有其他方法。如果使用全局变量来传递信息，就搞不清楚什么时候、谁在引用或者更新这一变量。除了全局变量之外，没有别的办法在函数间共享信息，这是C语言的局限。 可以保存外部环境的闭包Ruby中，增加了引用函数外部变量的功能。与C语言指针的例子比较，Ruby具有以下两个易于使用的优点： 可以再使用时定义； 可以引用外部的局部变量。 java的匿名类和C语言的函数指针也能实现同样的功能，但是没有那么简洁。在块中可以引用外部局部变量的方法，这说明不只是简单的程序代码，而且把外部“环境”也包括进来，像这样的块叫做闭包。通常的局部变量在方法执行结束时就不存在了，但如果被包括进了闭包，闭包存在期间，局部变量也会一直存在。 块的两种使用方法Ruby的块是可以追加给调用方法的代码块，块自身不是对象（对象化后的块是闭包）。参数传递的方法和普通函数不同。在被调用的方法中有两种方式来使用传递过来的块。一种是用“块参数”的方式明确声明接受块作为参数，另一种是使用yield这个Ruby的保留词。块作为参数具有三个优点： 明确表示了块处理 块和对象一样被统一处理 检查参数是否为nil就可以判断出是否传递了块参数。 另外，yield具有下面两个优点： 没有用到闭包，执行速度少快 错误提示信息比较容易理解 最终来看，块到底是什么Ruby的块具有以下三个特点： 代码块可以作为参数传递给方法 在被调用的方法中可以执行传递过来的代码块，执行后程序的控制权返还给方法。 块中最后执行的算式的值是块的值，这个值可以返回给方法。 块也可以被看做只是高阶函数的一种特殊形式的语法。虽然只是稍作改进，但Ruby中块的各种灵活应用的方法还是让人赞叹不已。 块在循环处理中的应用最典型的用法是，在逐个处理集合对象的元素的方法中使用块。 屏幕快照 2018-07-06 上午11.19.23 Ruby中几乎所有的容器类都有each这个方法。使用这个方法可以循环处理容器类中的所有元素。也可以用for语句来实现each方法。本来，Ruby就是为了要实现循环功能才导入了块。所以，在以前的文档中把具有块的方法称为迭代器（iterator）。iterate就是循环、迭代的意思。但是，如今块的应用范围比当初所能想到的要广泛的多，和循环没有关系的处理中也大量的用到块。所以现在仍把块称为迭代器就很不恰当了。 内部迭代器和外部迭代器像Ruby块这样，把对各个元素的处理逻辑传送给容器类的方法，然后在方法中对容器类中每个元素调用指定的处理逻辑，这种迭代方式称为内部迭代器的方式。与之对应，C++和java中所谓的迭代器，是用别的类对象来循环处理容器中的元素，这种循环处理的方式称为外部迭代器方式。在外部迭代器方式中，把顺序取出容器中元素对象称为迭代器，也称为游标。内部迭代器不用额外生成类，使用和实现都很简单，但是，对于不支持闭包的编程语言，想要拥有循环外部的信息就要费些功夫。外部迭代器可以简单地处理从多个容器中逐个取出数据进行并行处理。从设计模式来看，内部迭代器是访问者模式，外部迭代器是迭代器模式。 在排序和比较大小中的应用用块保证程序的后处理用块实现新的控制结构用块的话，不需要改变文法，就可以控制结构的定义。 在回调中使用块块处理的特别理由ruby的块具有以下特点： 在普通参数以外，另外被传送； 块不是对象（lambda方法可以作闭包对象化）。 其他具有闭包功能的编程语言，比如Lisp和Smalltalk，它们没有这样的区别，总是把闭包作为对象来处理。Ruby作了改进，因为： 减少对象的生成数。初期Ruby生成闭包对象的代价很高，所以尽量避免了闭包对象的生成。即使是真正必要的对象，也尽量延迟到必要的时候才生成。 外观上的理由。 调用方法时只能用一个块，是Ruby中的一个限制，但实际情况中也几乎没有必要使用多个块。 用块做循环Ruby的块本来就是在循环的抽象化过程中诞生的。现在除了循环以外，在其他一些场合也得到广泛应用，但这并未有改变其实现循环的初衷。 块是处理的集合循环是程序的基本元素。从结构化编程的原理来说，所有算法都是有顺序、分支和循环的组合来实现的。可以说处理好了循环，也就处理好了程序。Ruby也用while循环，但是循环还有其他更为深奥的表现形式。Ruby中有until语句。块是处理的集合。Ruby中，在方法调用的最后，可以附加上块。Ruby的简洁性不只体现在程序简短，更重要的是体现在对本质问题的处理，使程序更为灵活。 屏幕快照 2018-07-09 上午9.00.34 第二行大括号中的部分是块，这行程序是作为参数来调用数组的each方法。用Ruby实现这种循环非常简单，知识在块调用的地方用yield来指定。 屏幕快照 2018-07-09 上午9.08.46 1一个方法的定义，在方法内部有yield的出现；在方法的调用处会有程序块的出现。 也可以用do-end来定义块。大括号和do-end基本是一样的。但是，在块是多行时。用do-end结构统一性更好一些。 块是一行的时候用大括号，是多行的时候用do-end; 块作为表达式的一部分，给方法返回值时用大括号，块作为处理语句或程序流程控制时用do-end。大括号的优先级更高。 在省略括号调用方法时，一定要注意块的结合优先顺序。 块应用范围的扩展当时块主要使用在循环里。在Ruby中不必特别的结构，在任意的方法中都可以使用块，所以不仅仅在循环中，块在各种各样的领域中都得到了应用。 高阶函数和块本质一样编程语言要实现高阶函数，就必须把函数或者方法作为数据来处理。反之，具有这样功能的编程语言就可以利用高阶函数。可以把块看做高阶函数调用，只能有一个函数参数。事实上，在高阶函数中94%都只有一个函数参数，有两个以上函数参数是极少的。Ruby以更易于使用的形式，把只有一个函数参数的情形在语法上加以特殊处理，导入了块功能。 用Enumerable来利用块把块应用于循环抽象化的，最典型的应该是Enumerable模块。Enumerable模块以each方法为基础，定义了each方法的类提供了多种功能。如果继承（Mix-in）了这个模块，就可以很方便地利用它的各种功能。Enumberable的意思是可数的。它是对数组等各种集合元素做循环处理的方法的集成。可大致分为： 循环 指定条件 排序、比较大小 Enumerable的局限 循环都依赖each方法，而且不能并行执行。 Enumerable可以用each方法简单的实现循环，反过来也是一个局限。 精通集合的使用使用Ruby的数组在动态语言ruby中，集合可以混合存在各种类型的对象，所以可以定义复杂得数组。 修改指定范围的元素的内容和C语言、java语言相比，ruby的数组具有以下特点。 Ruby的数组是对象，可以调用各种方法。 用【】访问数组实际上是方法调用。【】是方法名，里面的值是参数。 变更数组元素实际上也是方法调用。【】=是方法名，里面和右边的值是参数。 Ruby中的哈希处理 屏幕快照 2018-07-09 上午9.55.21 支持循环的EnumerableRuby中提供的方法可以更好地发挥集合的作用。Ruby中，集合的功能都定义在Enumerable这个Mix-in中了。从另一个角度来说，只要把Enumerable模块通过Mix-in继承进来，就可以使用集合对象的大量方法了。 用于循环的each方法在Enumerable中没有定义each方法，反之，Enumerable中所有方法都是在内部调用each方法实现的。 使用inject、zip和grepinject是用块吧各个元素结合起来。zip是从多个集合并行取得元素的方法。grep方法可以对集合中的元素进行模式匹配。 用来指定条件的select方法对集合的各个元素进行块处理的是循环类型的方法。和它相对的，对各个元素进行块处理，用快处理的结果作为下个处理的判定条件的是条件指定型方法。条件指定型方法中最常用的是select方法。select方法把快处理结果为真的元素存放在数组中返回。 排序与比较大小在类中包括（include）Enumerable模块列表内包表达式和块的区别","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"艺术的力量 卡拉瓦乔","slug":"艺术的力量 卡拉瓦乔","date":"2018-07-06T09:56:20.000Z","updated":"2018-07-06T09:58:37.000Z","comments":true,"path":"2018/07/06/艺术的力量 卡拉瓦乔/","link":"","permalink":"https://github.com/zdkswd/2018/07/06/艺术的力量 卡拉瓦乔/","excerpt":"","text":"艺术的力量 卡拉瓦乔这个天才，是个恶人教堂寻寻觅觅及卡拉瓦乔生来注定要做的，就是在罪人的生命中找到超凡入圣之处。卡拉瓦乔笔下的主角不是圣人，而是罪人。这名画家，对穷苦信徒的处境感身受他艺术的力量来自于真实的力量，其中包括了对自身真相的觉醒。 青年音乐家 1595 自比酒神的自画像 赌博 圣母之死 圣母玛利亚 男孩与水果篮 有人说他是艺术天才，也有人说他是血性魔鬼，他的一生可以说就是一部历险记。卡拉瓦乔出生在米兰，家庭状况还阔以，爸妈在当时有点名气和地位。在卡拉瓦乔5岁的时候发生了一场瘟疫，为了躲避瘟疫，他们全家搬离了米兰。但不幸还是发生了，他的爸爸和爷爷都感染了这种瘟疫，并在同一天去世了，生活的重担就都落到他妈妈一个人身上，那时候的卡拉瓦乔才6岁。等到他卡拉瓦乔13岁时候，妈妈也离开了这个世界，于是他就成了孤儿。也就是在妈妈去世那一年，卡拉瓦乔开始跟着意大利画家西蒙·彼得扎诺学画画，一画就是四年，期间他也看了很多大师的作品，比如达芬奇的最后的晚餐啥的，增加了对艺术的了解。画家靠自己是很难的，因为你要搞商业你就无心创作，毕竟一个人的精力有限，所以需要钱的帮助，就是一定资金上的支持…卡拉瓦乔的命就很好。 多疑的thomas 召唤使徒马太 马太的殉难 手提歌利亚头的大卫 画中的男子手里提的，正是卡拉瓦乔的头。 意大利画家卡拉瓦乔，作为一个被通缉的画家，常年过着颠沛流离的逃亡生活。罪行满满的卡拉瓦乔最终想回到那个让他登上巅峰的罗马，但是他在那里杀过人啊，所以他决定画一幅画讨掌权者的欢心…… 被斩首的施洗约翰","categories":[{"name":"纪录片","slug":"纪录片","permalink":"https://github.com/zdkswd/categories/纪录片/"}],"tags":[{"name":"艺术","slug":"艺术","permalink":"https://github.com/zdkswd/tags/艺术/"}]},{"title":"松本行弘的程序世界 2 面向对象","slug":"松本行弘的程序世界 2 面向对象","date":"2018-07-05T14:14:32.000Z","updated":"2018-07-25T02:33:55.000Z","comments":true,"path":"2018/07/05/松本行弘的程序世界 2 面向对象/","link":"","permalink":"https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/","excerpt":"","text":"松本行弘的程序世界 2 面向对象编程和面向对象的关系计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。 颠倒的构造程序员要夺得主动权。 主宰计算机的武器为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。 怎样写程序编程风格 算法 数据结构 设计模式 开发方法 面向对象的编程方法smalltalk为面向对象编程语言之母。 面向对象的难点面向对象编程语言中最重要的技术是“多态性”。 多态性多态就是可以把不同种类的东西当做相同的东西处理。操作对象是三个箱子，分别是盖着盖子的箱子、加了锁的箱子、系着彩带的箱子。在编程中，“打开箱子”的命令，称之为消息；打开不同箱子的具体操作，称之为方法。 具体的程序调用box_open这个方法，根据参数（箱子的种类）的不同做相应的处理。 屏幕快照 2018-07-04 上午8.11.02 但是如果增加种类代码就要重写，修改的地方越来越多，追加箱子的种类就会变得非常困难。修改程序，实现真正的多态。“.”可以理解为“给前面的式子的值发送一个open消息”。 屏幕快照 2018-07-04 上午8.14.46 多态性的优点首先，各种数据可以统一地处理。关注要处理什么，而不是怎么处理。其次，根据对象选择方法，程序内部不会冲突。减轻程序员的负担。再次，新数据简单的追加可以实现，不需要改动以前程序，具备了扩展性。 数据抽象和继承面向对象编程的三原则：多态性，数据抽象，继承。别称：多态性：动态绑定，数据抽象：信息隐藏或封装。 面向对象的历史simula的“发明”面向对象编程思想起源于瑞典20世纪60年代后期发展起来的模拟编程语言Simula。以前，表示模拟对象的数据和实际的模拟方法是互相独立的，需要分别管理。 Smalltalk的发展smalltalke的开发宗旨是“让儿童也可以使用”，吸收了Simula的面向对象思想，且独居一格。不仅如此，还有一个很好的图形用户界面。使得世人开始了解面向对象编程的概念。 Lisp的发展许多重要的面向对象的概念都是从Lisp的面向对象功能中诞生的。 和c语言的相遇C++是直接受到了simula语言的影响而没有受到smalltalk多大影响。 Java的诞生java语言放弃了和C语言的兼容性，并增加了Lisp语言中一些好的功能。此外，通过Java虚拟机（JVM），java程序可以不用重新编译而在所有操作系统中运行。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 复杂性是面向对象的敌人软件开发的最大敌人是复杂性。人类的大脑无法做台复杂得处理，记忆力和理解力也是有限的。在计算机性能这么高的今天，人们为了找到迅速开发大规模复杂软件的方法，哪怕牺牲一些性能也在所不辞。 结构化编程如果不考虑黑盒内部的处理，系统复杂性就可以降低到人类的可控范围内。针对程序控制流的复杂问题，结构化编程采用看限制和抽象化的武器解决问题。 数据抽象化数据抽象是数据和处理方法结合。对数据内容的处理和操作，必须通过实先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。比如说栈。有了数据抽象，程序处理的数据就不再是单纯的数值或者文字这些概念性的东西，而变成了人脑容易想象的具体事物。而代码的“抽象化”则是把想象的过程“具体化”了。 雏形同样的对象大量存在时，为避免重复，可以采用两种方法管理对象。 原型。用原始对象的副本来作为新的相同的对象，JS用的原型。 模板，称为类。跟原型不同，面向对象编程语言的类和对象有明显区别。对象又称作实例。 找出相似的部分来继承类的增多会用到很多性质相似的类。这就违背了我们的DRY（Don’t Repeat Yourself）原则。把这些相似的部分汇总到一起就好了。继承就是这种方法。子类继承父类所有方法，如有需要可以增加新的方法，也可以重写父类方法。Ruby跟多数编程语言一样，一个子类只能有一个父类，即单一继承，C++、Lisp等编程语言中，一个子类可以有多个父类，这称为“多重继承”。 多重继承的缺点继承的原本目的实际上是逐步细化。所以为解决抽出类中相似部分的问题并不完全准确。 为什么需要多继承一个程序员也可能是一个作家。 多重继承和单一继承不可分离单一继承的特点： 继承关系单纯，有利有弊 多重继承的特点： 很自然的做到了单一继承的扩展。 可以继承多个类的功能。单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系变得复杂。这是多重继承的一个缺点。 goto语句和多重继承比较相似多重继承导致的问题： 结构复杂化 优先顺序模糊 功能冲突 解决多重继承的问题继承作为抽象化的手段，是需要实现多重继承功能的，如果一个类只允许抽出一个功能，那么限制就太多了。受限制的多重继承，这个解决或改善多重继承问题的方法出现了，它在Java中被称为接口（interface）,在Lisp或Ruby中是Mix-in。 静态语言与动态语言的区别编程语言可以分为静态语言和动态语言两种。像Java这样规定变量和算式类型的语言称为静态语言。在静态语言中，不能给变量赋不同类型的值，会导致编译错误，不通过执行就可以发现类型不匹配是静态语言的一个优点。如果只能给一个变量赋值同类对象，就不可能根据对象的类自动选择合适的处理方式（多态性）。 静态语言的特点当给一个类变量赋值时，既可以用这个类的对象来赋值，也可以用这个类的子类对象来赋值。这样就可以实现多态性。但是这时，如果定义了父类变量，赋值子类对象，变量不能调用子类特有的方法。 动态语言的特点动态语言允许调用没有继承关系的方法。静态语言中只能调用有继承关系的方法，数组、哈希表和字符串都能调用的方法，只能是在它们共同的父类（恐怕是Object）中定义。在静态语言中，如果要调用类层次中平行类的方法，那么必须要有一个可以表现这些对象的类型。如果没有这个类型，可调用的方法是十分有限的。由此我们看到静态语言中某种形式的多重继承是不可少的。 静态语言与动态语言的比较静态语言即使不通过执行也可以检查出类型是否匹配。但是逐个来定义算式和变量的类型又会使程序变得冗长。只有包含继承关系的类才会具有多态性。对于动态语言来说，静态语言显得限制过多，灵活性差。程序中有没有错误只有执行了才会知道。程序中没有类型定义，这样程序会变得很简洁。只要方法名一样，这些对象可以以相同的方式去处理。这样生产效率会大大提高，这种宽松的编程机制称为Duck Typing（鸭子类型检测） 继承的两种含义继承包括两种含义，一种是“类都有哪些方法”，也就是说这个类都支持些什么操作，即规格的继承。另一种是“类中都用了什么数据结构什么算法”，也就是实现的继承。静态语言中这两者的区别很重要，动态语言中区别规格的继承和实现的继承意义不大。即使没有继承关系，方法也可以自由地调用。java对两者有很明确的区分，实现的继承用extends来继承父类，规格的继承用implements来指定接口。类是用来指定对象实现的，而接口只是指定对象的外观（都有哪些方法）。类的继承是单一的，implements可以指定多个接口。接口对实现没有任何限制，也就是说，接口可以由跟实现的继承没有任何关系的类来实现。 接口的缺点为了解决多重继承的问题，人们允许了规格的多重继承，但是还是不允许实现多重继承。 继承实现的方法和静态语言Java不同，动态语言本来就没有继承规格这种概念。动态语言需要解决的就是实现的多重继承。Lisp、Perl和Python都提供了多重继承功能，这样就不存在单一继承的问题了。 从多重继承变形而来的Mix-inMix-in是降低多重继承复杂性的一个技术，最初是在Lisp中开始使用的。按以下规则来限制多重继承： 通常的继承用单一继承 第二个以及两个以上的父类必须是Mix-in的抽象类。 Mix-in类是具有以下特征的抽象类。 不能单独生成实例 不能继承普通类 积极支持Mix-in的Ruby 屏幕快照 2018-07-04 下午5.39.58 12345678我理解的接口的作用：接口是一种协议，满足同一接口实际上是告诉计算机你们是满足了同一样协议，你们是有关系的，java以这种方式间接实现了多态。当然可以实现多个接口，抽象为不同的“种类”，这样就相当于某种意义上的”多继承“。InterA a; a= new B(); a.fun(); a = new C(); a.fun(); bc都实现a的接口 两个误解 对象是对现实世界中具体物体的反应，继承是对物体分类的反应。（误） 多重继承是不好的。Mix-in不错。（误） 澄清：如果多继承用的不好就会出问题，Mix-in只不过是实现多重继承的一个技巧而已。 面向对象的编程不管过去怎样，现在面向对象最好的理解是，面向对象编程是结构化编程的延伸。随着软件的复杂化，开发越来越复杂，Dijkstra提倡把程序控制限制为（1）顺序（2）循环（3）分支 使得程序变得简单且容易理解。面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上对数据的结构化。面向对象编程，封装（黑盒）和多态（减少分支处理）是提高生产率的技术。结构化编程通过整理数据流，提高程序的生成效率和可维护性。同样，面向对象编程通过对数据结构的整理，提高了程序的生产效率和可维护性。 对象的模板=类类是吧数据黑盒化的工具，由于对类内部的操作都是通过类的方法来实现的，所以内部数据结构即使在以后发生变化，对外部也没有影响。 利用模板的手段=继承类是模块，继承就是利用模块的方法。传统的面向对象编程语言是一下子把规格和实现都继承下来，在最近，有的是把这两种继承分开了。比如java里的接口就是规格继承。 多重继承不好吗单一继承的类之间的关系是很单纯的树结构。但是对于多重继承而言，类之间的关系却是复杂得网状结构。静态语言中可以实现多态性只是局限于拥有共通父类的对象。为了解决这个问题，静态面向对象编程语言的代表C++支持多重继承。java也可以通过接口来支持规格的多重继承。1234**静态类型语言**: 是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型，某些具有类型推导能力的现代语言可能能够部分减轻这个要求. **动态类型语言**: 是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 **强类型语言**: 是一旦变量的类型被确定，就不能转化的语言。实际上所谓的貌似转化，都是通过中间变量来达到，原本的变量的类型肯定是没有变化的。 **弱类型语言**: 则反之，一个变量的类型是由其应用上下文确定的。比如语言直接支持字符串和整数可以直接用 + 号搞定。当然，在支持运算符重载的强类型语言中也能通过外部实现的方式在形式上做到这一点，不过这个是完全不一样的内涵 动态编程语言也需要多重继承动态编程语言没有类型检查，从这方面来说没有理由用多重继承，但是动态编程语言肯定需要多重继承。实现共享可以通过多个对象的组合（composition）和委托（delegate）来做到。 驯服多重继承的方法多重继承可能引发的问题： 类关系复杂化 继承功能名字重复最初的问题是因为类关系从简单的树结构变成了复杂的网状结构。 屏幕快照 2018-07-05 上午9.18.30 父类的优先级并不明确，多重继承设计的一个有效的技巧是Mix-in。用Mix-in做多继承设计时，从第2个父类开始的类要满足以下条件。 不能单独生成实例的抽象类。 不能继承Mix-in以外的类。 抽象类和接口的对比 屏幕快照 2018-07-05 上午10.41.50 mix-in的例子 屏幕快照 2018-07-05 上午10.44.57 通过对功能的分离，多重继承就可以由单一继承加上Mix-in类来实现。利用Mix-in就可以同时享有单一继承的单纯性和多重继承的共有性。 对于名字重复问题（如函数名），多重继承编程语言都有自己的应对方法，大致分为以下3种： 给父类定义优先级 把重复的名字替换掉 指定使用类的名字 ruby中多重继承的实现方法Mix-in java实现多重继承的方法接口。。 Duck Typing诞生之前静态是指程序执行之前，从代码中就可以知道一切。程序静态的部分包括变量、方法的名称和类型以及控制程序的结构等等。相对于静态，动态是指在程序执行之前有些地方是不知道的。程序动态的部分包括变量的值、执行时间和使用的内存等等。通常情况下、程序本来就是不被执行就不知道结果的，所以在一定程度上说程序都具有动态特性。因此，严格说静态和动态之间的界限是很微妙的。 为什么需要类型动态的类型是从Lisp中诞生的动态类型在面向对象中发展起来了对象保存着有关自己种类的信息，某个变量可以用各种类型的数据来赋值，这两点是多态这一面向对象重要特性的必要条件。 动态类型和静态类型的邂逅20世纪80年代，面向对象编程语言主流是包含动态数据类型的语言，但是在21世纪的今天，使用最广泛的面向对象编程语言是具有静态类型的java和c++。受simula很大影响的c++引入了子类对象可以看成是父类对象这个原则，对象也采用了静态类型。根据这个原则，在编译时就可以知道变量或算式的类型，又可以根据执行时的数据类型自动选择合适的处理，从而同时具备了静态类型的优点和动态类型的多态性。 静态类型的优点 最大的优点是在编译时能够发现不匹配的错误。 如果明确指定了数据类型，在编译时可以用到的信息就很多，利用这种信息可以在编译时对程序做优化，提高程序执行速度。 在读程序时提高理解度，IDE也可以自动补充。 问题： 不指定类型就写不了程序，数据类型只是一些辅助信息，并不是程序本质。有的类型声明仅仅是为了满足编译器的要求。程序规模也因为数据类型的定义而变大。 灵活性问题。静态类型本身限制了给某个变量只能赋值某种类型的对象，这种限制可能成为妨碍将来变化的枷锁。 动态类型的优点 源代码简洁，提高生产力。 会不会更难以理解，更突出程序处理的实质，程序函数相差几十倍并不少见，理解起来反而简单。 会不会运行更缓慢，同样的处理，在大多数情况下，静态类型编程语言运行得要快些。这是因为动态类型程序执行时要做类型检查。另外，静态类型的编程语言大都是通过编译把程序源代码转换成可以直接执行的形式，而动态类型的编程语言大多是边解释源代码（转换成内部形式）边执行，这种编译型处理和解释型处理的区别也是影响程序执行速度的愿意之一。 灵活，灵活性的关键是Duck Typing。 最大的缺点是不执行就检测不出错误。 只关心行为的Duck TypingIf it walks like a duck and quacks like a duck,it must be a duck.（走起路来像鸭子，叫起来也像鸭子，那么他就是鸭子）。根本不考虑一个对象属于什么类，只关心它有什么样的行为（它有哪些方法）。动态语言用Duck Typing的概念设计时需要遵循的原则最低限度是避免明确的类型检查。 避免明确的类型检查克服动态类型的缺点 执行时才能发现可以用完备的单元测试来解决，如果能严格实行完备的单元测试的话，即使没有编译时的错误检查，程序的可靠性也不会降低。 读程序时可用到的线索少这一点可以通过完整的文档来解决。可以在源代码中同时写文档，减轻维护文档的负担。 运行速度慢，随着计算机性能的提升已经不再重要，现在的程序开发中，程序的灵活性和生产力更为重要。 动态编程语言现在我们对程序开发生产力的要求越来越高，也就是说，要在更短的时间内开发出更多的功能。尽快着手开发，快速应对需求变更的开发方式变得越来越重要。在这种快速开发模式中，Duck Typing所代表的执行时的灵活性就非常有用。Ruby、Python、Perl和PHP等优秀的动态类型编程语言，因为它们在执行时所具有的灵活性而越来越受到人们的关注。 元编程元编程是对程序进行编程的意思。 元编程利用元编程可以动态生成类的方法，而且重要的是你可以自己编写生成过程，不支持元编程的编程语言实现这样的功能是很麻烦的，要么需要扩展语言的语法，要么用宏定义等预处理方法来实现。 反射元编程的反射（reflection）,在编程语言中它是指在程序执行时取出程序的信息或者改变程序的信息。Ruby彻底实现了对程序的动态操作。 屏幕快照 2018-07-05 下午7.10.21 元编程的例子Ruby使用Delegator这个库实现了委托功能，调用对象d的方法时可以转变为调用a的方法。我们还可以给这个对象增加特意方法来改变它的部分行为，这就大大扩展了它的应用范围。 使用反射功能分布式Ruby的实现Delegator将被调用的方法直接委派到其他对象，这一功能在很多领域都有应用。如dRuby。dRuby是通过网络来调用方法的库。dRuby可以生成服务器上存在的远程对象（Proxy），Proxy的方法调用可以通过网络执行。调用的方法在服务器上的远程对象中执行，执行结果可以通过网络返回。这和java的RMI(Remote Method Invocation)功能比较相似。但是，利用Ruby的元编程功能，不用明确定义接口，也可以通过网络调用任一对象的方法。C++和Java的远程调用是用IDL（Interface Definition Language）等语言来定义接口的，自动生成的存根（stub）必须编译和连接。和这些相比，Ruby的元编程更简单。 数据库的应用在数据库领域，元编程也很有用。web应用程序框架Ruby on Rails(也称为Rails或RoR)中也应用了元编程。具体地说是在与数据库关联的类库（ActiveRecord）中，利用元编程简单的把数据记录定义为对象。由于元编程功能让我们可以获取类名，在执行时增加方法。元编程的功能使得Rails被称赞为生产效率高的Web应用程序框架。 输出xml手工写XML是很麻烦的，利用Ruby块功能则可以很方便的处理。 元编程和小编程语言元编程功能可以运用到DSL领域，DSL是针对特定领域强化了功能的小规模编程语言。通过DSL用户可以强化应用程序的功能或者定制一些功能。 声明的实现Ruby的方法可以读取或改变程序自身的状态，利用普通的方法调用，可以实现其他编程语言中声明所完成的工作。 上下文相关的实现instance_eval方法接受块作为参数，把调用对象置换成self来执行块。 单位的实现词汇的实现针对特定领域，如果用Ruby来定义需要的类和方法，那么就可以认为Ruby是这个领域的专用语言。这些类和方法可以称为这个领域的词汇。 层次数据的实现适合DSL的语言，不适合DSL的语言Ruby是非常适合DSL的语言。首先定义好DSL用的小语言，然后编译成C++、java等目标语言。编译器经常用到Ruby这种具有优秀文本处理的语言。另一种实现DSL方法的例子是解释器。比如开发应用程序时从设计到实现是很复杂的，可以利用固定的语法和类库函数来读取程序。具体方法是用XML、DOM等XML处理类库来解释小语言语法。这是Java应用程序的配置文件曹勇XML的原因之一。通过XML文件，不用每次编译Java程序就可以改变配置，定制程序的行为。这种用法可以把XML称为Java界的DSL，或是Java应用程序的脚本语言。12脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是--解释运行--而非编译。虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"周海宏音乐鉴赏 一 打开你的耳朵","slug":"周海宏音乐鉴赏 一 打开你的耳朵","date":"2018-07-04T14:28:13.000Z","updated":"2018-07-04T14:28:47.000Z","comments":true,"path":"2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/","excerpt":"","text":"周海宏音乐鉴赏 一 打开你的耳朵1.1音乐鉴赏的误区音乐中包含各种内容的表现，说不出来是什么是因为你“听不懂”.专业学生也”听不懂“。音乐两个基本属性1 没有视觉性2 没有语义性“听不懂”–说不出音乐表现的是什么并非听者欣赏水平差，因为音乐不能直接传达视觉性与语义性的内容。 在音乐的欣赏中-不一定非要听出明确的视觉性、语义性内容。-不一定非要用文学化、美术化的内容去解说音乐。 在音乐中追求明确的概念性、视觉性内容，用文学化与美术化的方式欣赏音乐是一个误区。 音乐何须“懂”。 1.2音乐的艺术本质音乐是动态的。音乐是情绪的艺术。1 纯听觉感受2 情绪的感受动态纪实细腻地描摹内心的感受。 1.3 音乐审美的基本概念幸福人生最重要的是丰富多彩，真正的欣赏音乐，就去听最伟大的音乐。世界是这么龌龊这么黑暗，可悲的不是世界这么龌龊这么黑暗，而是不知道世界还有光明。音乐是人类精神的避难所。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"音乐鉴赏","slug":"音乐鉴赏","permalink":"https://github.com/zdkswd/tags/音乐鉴赏/"}]},{"title":"松本行弘的程序世界1 我为什么开发Ruby","slug":"松本行弘的程序世界1 我为什么开发Ruby","date":"2018-07-04T10:38:32.000Z","updated":"2018-07-04T10:38:47.000Z","comments":true,"path":"2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/","excerpt":"","text":"松本行弘的程序世界1 我为什么开发Ruby编程语言的重要性程序员由于使用的编程语言不同，思考方法和编写出的代码都会受到很大的影响。 Ruby的原则 简洁性 扩展性 稳定性简洁性随着编程语言的演进，程序员已经可以更简单、更抽象地编程了。面向对象的方法没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序运行开销。现在由于计算机性能大大提高，只要可以提高软件的开发效率，浪费一些计算机资源也无所谓了。ruby的目标是成为开发效率高、能直接运行的伪码式编程语言。省去了不必要的声明。扩展性Ruby看重的不是明哲保身，而是如何最大限度的发挥程序员自身的能力。编程的历史就是因为想当然而失败的历史，ruby对整数范围不做任何限定，尽最大努力排除“想当然”。稳定性虽然ruby非常重视扩展性，但明知道LISP风格的宏能带来巨大的扩展性，仍没有使用。一切皆因兴趣","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界0 说在前面","slug":"松本行弘的程序世界0 说在前面","date":"2018-07-04T10:35:32.000Z","updated":"2018-07-04T10:36:06.000Z","comments":true,"path":"2018/07/04/松本行弘的程序世界0 说在前面/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/松本行弘的程序世界0 说在前面/","excerpt":"","text":"松本行弘的程序世界0 说在前面vczh如何设计一门语言（一）好的语言，除了库写起来又容易又好用以外，还有两个重要的特点：容易学，容易分析。关于容易学这一点，其实不是说，你随便看一看就能学会，而是说，只要你掌握了门道，很多未知的特性你都可以猜中。这就有一个语法的一致性问题在里面了。 前言ruby code for fun这本书是松本行弘从一个编程语言设计者的角度去看待各种各样的流行编程语言，分析它们有哪些特点以及ruby编程语言如何进行取舍。ruby本身大量参考了一个更古老而著名的面向对象编程方法的开山鼻祖smalltalk以及偷师函数式编程语言鼻祖LISP。程序员社区有种说法：任何现代编程语言都脱胎于smalltalk于LISP。看看Ruby设计师是怎么设计Ruby语言的，则可以高屋建瓴的理解一些主流的编程语言。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"growth全栈","slug":"growth全栈","date":"2018-07-03T01:12:25.000Z","updated":"2018-07-03T03:01:34.000Z","comments":true,"path":"2018/07/03/growth全栈/","link":"","permalink":"https://github.com/zdkswd/2018/07/03/growth全栈/","excerpt":"","text":"基础知识篇环境是生产率的一部分。高效的程序员与低效的程序员间十倍的差距，至少有三倍是因为环境差异。语言和开发软件都是工具，都有相对更合适的情况。 提高效率的工具：快速启动软件windows-&gt; launcy IDEDEBUG工具终端或命令提示符包管理环境搭建OSXHomebrew包管理工具，官方称之为 The missing package manager for OS X。 Homebrew Caskbrew-cask 允许你使用命令行安装 OS X 应用。 iTerm2iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。 ZshZsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:• 更高效• 更好的自动补全• 更好的文件名展开(通配符展开) • 更好的数组处理• 可定制性高 Oh My ZshOh My Zsh 同时提供一套插件和工具，可以简化命令行操作。 MacDownMacDown 是 Markdown 编辑器。 CheatSheetCheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按 。 SourceTreeSourceTree 是 Atlassian 公司出品的一款优秀的 Git 图形化客户端。 AlfredMac 用户不用鼠标键盘的必备神器，配合大量 Workflows，习惯之后可以大 大减少操作时间。上手简单，调教成本在后期自定义 Workflows，不过有大量雷锋使用者提供的现成 扩展，访问这里挑选喜欢的，并可以极其简单地根据自己的需要修改。 VimiumVimium 是一个 Google Chrome 扩展，让你可以纯键盘操作 Chrome。 WindowsChocolateyChocolatey 是一个软件包管理工具，类似于 Ubuntu 下面的 apt-get, 不过是 运行在 Windows 环境下面。 WoxWox 是一个高效的快速启动器工具，通过快捷键呼出，然后输入关键字来搜 索程序进行快速启动，或者搜索本地硬盘的文件，打开百度、Google 进行搜 索，甚至是通过一些插件的功能实现单词翻译、关闭屏幕、查询剪贴板历史、 查询编程文档、查询天气等更多功能。它最大的特点是可以支持中文拼音的 模糊匹配。 PowerShellWindows PowerShell 是微软公司为 Windows 环境所开发的壳程序(shell) 及脚本语言技术，采用的是命令行界面。这项全新的技术提供了丰富的控制 与自动化的系统管理能力。 cmdercmder 把 conemu，msysgit 和 clink 打包在一起，让你无需配置就能使用一 个真正干净的 Linux 终端!她甚至还附带了漂亮的 monokai 配色主题。 Total CommanderTotal Commander 是一款应用于 Windows 平台的文件管理器，它包含两个 并排的窗又，这种设计可以让用户方便地对不同位置的 “文件或文件夹” 进 行操作，例如复制、移动、删除、比较等，相对 Windows 资源管理器而言 方便很多，极大地提高了文件操作的效率，被广大软件爱好者亲切地简称为: TC 。 GNU/LinuxZshZsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:• 更高效• 更好的自动补全• 更好的文件名展开(通配符展开)• 更好的数组处理• 可定制性高 Oh My ZshOh My Zsh 同时提供一套插件和工具，可以简化命令行操作。 ReTextReText 是一个使用 Markdown 语法和 reStructuredText (reST) 结构的文本 编辑器，编辑的内容支持导出到 PDF、ODT 和 HTML 以及纯文本，支持即 时预览、网页生成以及 HTML 语法高亮、全屏模式，可导出文件到 Google Docs 等。 LaunchyLaunchy 是一款免费开源的协助您摒弃 Windows “运行” 的 Dock 式替代工 具，既方便又实用，自带多款皮肤，作为美化工具也未尝不可。 学习一门语言，输出是最好的输入，实践更是硬道理。 Web编程基础运用HTTP传递数据,浏览器第一步Parser HTML,Paser HTML 实质上就是将其 将解析为 DOM Tree。与此同时，CSS 解析器会解析 CSS 会产生 CSS 规则树。随后会根据生成的 DOM 树和 CSS 规则树来构建 Render Tree，接着生成 Render Tree 的布局，最后就是绘制出 Render Tree。 HTML超文本标记语言 浏览器解析器对中文支持不友好。 浏览器解析器对英文支持友好。 CSS选择器类选择器，id选择器JavaScriptHTML 中插入 JavaScript 的方法，就需要用到 HTML 中的 &lt; script&gt; 标签 完整的 JavaScript 应该由下列三个部分组成:• 核心 (ECMAScript)——核心语言功能• 文档对象模型 (DOM)——访问和操作网页内容的方法和接口• 浏览器对象模型 (BOM)——与浏览器交互的方法和接口 有了 DOM 我们就可以对页面进行操作，可以说我们看到的绝大部分的页面效果都是通过 DOM 操作实现的。 前端与后端后台语言选择javascript只要是 Web 就会有前端,只要有前端就需要有 JavaScript。与此同时 Node.js在后台中的地位已经愈发重要了。对于 JavaScript 来说，它可以做很多类型的应用。这些应用都是基于浏览器来运行 的，有:• Electron + Node.js + JavaScript 做桌面应用• Ionic + JavaScript 做移动应用• Node.js + JavaScript 网站前后台• JavaScript + Tessl 做硬件 PythonJavaphpMVCModel模型用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。View 层只是单纯的一个显示作用，这也是我们推荐的做法。业务逻辑应 该尽可能的放置于业务层。Controller控制器层起到不同层面间的组织作用，用于控制应用程序的流程。 后台即服务移动端应用程序 前端框架选择AngularAngularJS 对于后端人员写前端代码来说，是一个非常不错的选择。Angular 框架 采用并扩展了传统 HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许 模型和视图之间的自动同步。 ReactReact 只是我们在上面章节里说到的 View 层，而这个 View 层需要辅以其他框架才 能完成更多的工作。并且 React 还有一个不错的杀手锏——React Native，虽然这个框架还在有条不紊地 挖坑中，但是这真的是太爽了。以后我们只需要一次开发就可以多处运行了，再也没有 比这更爽的事情发生了。 VueVue.js 是一个轻量级的前端框架。它是一个更加灵活开放的解决方案。它允许你以 希望的方式组织应用程序，你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。 jQuery系jQuery 还是一个不错的选择，不仅仅对于学习来说，而且对于工作来说也是如此。 如果你们不是新起一个项目或者重构旧的项目，那么必然你是没有多少机会去超越 DOM。 前台与后台交互AjaxAJAX 即 “Asynchronous JavaScript And XML”(异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更 新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的 网页如果需要更新内容，必须重载整个网页页面。 JSON WEB TokensJSON Web Token (JWT) 是一种基于 token 的认证方案。在人们大规模地开始 Web 应用的时候，我们在授权的时候遇到了一些问题，而这些 问题不是 Cookie 所能解决的。通过 JWT 我们可以更方便地写出适用于前端应用的认证方案，如登陆、注册这些功能。在使用 JWT 的时候也需要注意安全问题，在允许的情况下应该使用 HTTPS 协议。 WebSocketHTML5 推出了一种 在单个 TCP 连接上进行全双工通讯的协议 WebSocket。WebSocket 可以让客户端和服务器之间存在持久的连接，而且双方都可以随时开始 发送数据。 编码Web 应用的构建系统构建系统 (build system) 是用来从源代码生成用户可以使用的目标的自动化 工具。目标可以包括库、可执行文件、或者生成的脚本等等。 常用的构建工具包括 GNU Make、GNU autotools、CMake、Apache Ant(主要用于 JAVA)。此外，所有的集成开发环境(IDE)比如 Qt Creator、Microsoft Visual Studio 和 Eclipse 都对他们支持的语言添加了自己的构建系统配置工具。通常 IDE 中的构建系 统只是基于控制台的构建系统(比如 Autotool 和 CMake )的前端。对比于 Web 应用开发来说，构建系统应该还包括应用打包 (如 Java 中的 Jar 包，或 者用于部署的 RPM 包、源代码分析、测试覆盖率分析等等。 Web 应用的构建GulpGulp.js是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你 可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务 的 Gulp 文件都是通过 JavaScript(或者 CoffeeScript )源码来实现的。 JSHint最初，lint这个工具用来扫描C源文件并对源程序中不可移植的代码提出警告。但是现在大多数lint实用程序已经变得更加严密，它不但可以检查出可移植性问题，而且可以检查出那些虽然可移植并且完全合乎语法但却很可能是错误的特性。对应于不同的语言都会有不同的 lint 工具，在 JavaScript 中就有JSLint。JavaScript 是一门年轻、语法灵活多变且对格式要求相对松散的语言，因此这样的工具对于这门语 言来说比较重要。• 可配置规则，每个团队可以自己定义自己想要的代码规范。• 对社区非常友好，社区支持度高。• 可定制的结果报表。 自动化测试工具Mocha 是一个可以运行在 Node.js 和浏览器环境里的测试框架。 编译对于静态型语言来说，编译是一个很重要的步骤。不过，对于动态语言来说也存在这样的工具。动态语言的编译:是以我们常见的 JavaScript 为代表。打包,1. DEB 2.RPM 3.压缩文档 tar.gz 如何编写测试TODO测试金字塔 从上到下 ui测试 服务测试 单元测试测试替身 Stub Mock 代码重构TODO重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。 上线HTTP服务器目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。 ApacheApache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广 泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器 端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译 到服务器中。 NginxNginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件(IMAP/ POP3)代理服务器，并在一个 BSD-like 协议下发行。由俄罗斯的程序设计师 Igor Sysoev 所开发，供俄国大型的入又网站及搜索引擎 Rambler(俄文:Рамблер)使用。 其特点是占有内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务 器中表现较好，中国大陆使用 Nginx 网站用户有:百度、新浪、网易、腾讯等。 IISInternet Information Services(IIS，互联网信息服务)，是由微软公司提供的基 于运行 Microsoft Windows 的互联网基本服务。最初是 Windows NT 版本的可选包，随 后内置在 Windows 2000、Windows XP Professional 和 Windows Server 2003 一起发 行，但在 Windows XP Home 版本上并没有 IIS。 代理服务器代理服务器(Proxy Server)是一种重要的服务器安全功能，它的工作主要在 开放系统互联 (OSI) 模型的会话层，从而起到防火墙的作用。代理服务器大 多被用来连接 INTERNET(国际互联网)和 Local Area Network(局域网)。 Web缓存• 数据库端缓存• 应用层缓存• 前端缓存• 客户端缓存 功能开关当我们上线了我们的新功能的时候，这时候如果有个 Bug，那么我们是下线么?要 知道这个版本里面包含了很多的 Bug 修复。Feature Toggle 它是一种允许控制线上功能开启或者关闭的方式 依赖与包仓库数据分析SEO 搜索引擎优化分析工具 google analytics网站性能 Apdex联盟","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"全栈","slug":"全栈","permalink":"https://github.com/zdkswd/tags/全栈/"}]},{"title":"[Linux内核设计与实现]中断与中断处理","slug":"【Linux内核设计与实现】中断与中断处理","date":"2018-07-01T11:37:32.000Z","updated":"2018-07-01T11:37:21.000Z","comments":true,"path":"2018/07/01/【Linux内核设计与实现】中断与中断处理/","link":"","permalink":"https://github.com/zdkswd/2018/07/01/【Linux内核设计与实现】中断与中断处理/","excerpt":"","text":"【Linux内核设计与实现】中断与中断处理中断中断处理程序在Linux中，中断处理程序就是普普通通的C函数。 上半部与下半部的对比把中断处理分为两部分。中断处理程序是上半部–接收到一个中断，就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部。 注册中断处理程序中断处理程序是管理硬件的驱动程序的组成部分。每一设备都有相关的驱动程序，如果设备使用中断，则对应的驱动程序就注册一个中断处理程序。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters","slug":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters","date":"2018-06-15T09:49:56.000Z","updated":"2018-06-15T03:55:47.000Z","comments":true,"path":"2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/","link":"","permalink":"https://github.com/zdkswd/2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/","excerpt":"","text":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFiltersimport module在import module时，如果图标没有变化，不要忘了改setting.gradle AsyncTaskAsyncTask,即异步任务,是Android给我们提供的一个处理异步任务的类.通过此类,可以实现UI线程和后台线程进行通讯,后台线程执行异步任务,并把结果返回给UI线程. AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个泛型参数:Params:启动任务时输入的参数类型.Progress:后台任务执行中返回进度值的类型.Result:后台任务执行完成后返回结果的类型. AsyncTask主要有如下几个方法:doInBackground:必须重写,异步执行后台线程要完成的任务,耗时操作将在此方法中完成.onPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作.onPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.onProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度. Make Project Clean Project Make Project：编译Project下所有Module，一般是自上次编译后Project下有更新的文件，不生成apk。 Make Selected Modules：编译指定的Module，一般是自上次编译后Module下有更新的文件，不生成apk。 Clean Project：删除之前编译后的编译文件，并重新编译整个Project，比较花费时间，不生成apk。 Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成apk，这里效果其实跟Clean Project是一致的，这个不知道Google搞什么鬼～～ Build APK：前面4个选项都是编译，没有生成apk文件，如果想生成apk，需要点击Build APK。 Generate Signed APK：生成有签名的apk。 平时小的改动直接用Make Project就可以，可以看到只有它有快捷方式，表明这个功能要经常用。对于一些大的改动比如更新lib，大功能修改等，用Clean或Rebuild，毕竟这两个编译起来要费时间。如果有的时候死活编译不过，多试试Clean吧，会有意想不到的效果！ 关于abiFilters的使用最近项目中遇到了要使用opencv的情况，涉及到了abi兼容的选择。因为如果全部都适配的话，包很大，这样兼容那些用户数极少的cpu就很不划算，所以我只适配了armeabi-v7a这一个。但是今天在x64-v8a的模拟器上看的时候，提示我的library.so文件找不到，我记得这个应该是向下兼容的，但是出现这种情况很奇怪，于是我就在网上找了找答案。解决方法：abiFilters在app的gradle的defaultConfig里面加上这么一句ndk { abiFilters “armeabi-v7a” // 指定要ndk需要兼容的架构(这样其他依赖包里mips,x86,armeabi,arm-v8之类的so会被过滤掉)} 这句话的意思就是指定ndk需要兼容的架构，把除了v7a以外的兼容包都过滤掉，只剩下一个v7a的文件夹。用了这个方法之后，确实解决了问题。这就是解决方法。具体分析其实这个方法我开始是很奇怪的，我明明没有指定其他的兼容框架，为什么会需要一个过滤。我打来了apk的包，找到了里面的lib目录，发现里面有很多的兼容目录，然后看到里面目录里面的是一个fresco的.so文件。也就是说，fresco做了各个平台的兼容，所以它创建了各个兼容平台的目录。因为只要出现了这个目录，系统就只会在这个目录里找.so文件而不会遍历其他的目录，所以就出现了之前找不到.so文件的情况（因为其他目录没有我的.so文件）。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/zdkswd/tags/AndroidStudio/"}]},{"title":"[Linux内核设计与实现]系统调用","slug":"[Linux内核设计与实现]系统调用","date":"2018-06-15T03:53:32.000Z","updated":"2018-06-18T02:49:58.000Z","comments":true,"path":"2018/06/15/[Linux内核设计与实现]系统调用/","link":"","permalink":"https://github.com/zdkswd/2018/06/15/[Linux内核设计与实现]系统调用/","excerpt":"","text":"[Linux内核设计与实现]系统调用内核提供接口让应用程序调用实现特定功能，避免应用程序肆意妄为。 与内核通信系统调用在用户空间进程和硬件设备间添加了一个中间层。 提供硬件的抽象接口，即无需管磁盘类型，介质等问题。 保证系统的安全。 告知内核自己在使用硬件以实现多任务和虚拟内存。内核知道了才能更好的管理分配。系统调用是用户空间访问内核的唯一手段。 API、POSIX、和C库用户程序在用户空间使用API进行编程。API可以实现零个，一个或多个系统调用。UNIX世界中，最流行的应用程序接口是基于POSIX标准的。在大多数Unix上，根据POSIX定义的API函数和系统调用之间有着直接的关系。这个协议是对操作系统服务接口的标准化，从而保证了应用程序在源码层次的可移植性。具体来说是应用程序调用API，API中包含有系统调用，调用内核。程序员与API打交道，内核与系统调用打交道。 系统调用要访问系统调用（在Linux中常称为syscall）,通常通过C库中定义的函数调用来进行。 系统调用号在Linux中，每个系统调用被赋予一个系统调用号。通过这个独一无二的号可以关联系统调用。系统调用号非常重要，一旦分配就不能变更，否则编译好的应用就会崩溃。Linux中的sys_ni_syscall()系统调用几乎不做任何操作，相当于白板儿，用来替代那些被删除的或不可用的系统调用。内核用sys_call_table记录注册过的系统调用。 系统调用的性能Linux系统调用比其他操作系统执行的快。一是因为Linux有很短的上下文切换时间。二是系统调用处理程序和每个系统调用都很简洁。 系统调用的处理程序应用程序实际在API中调用的系统调用也并不是直接执行内核代码。应用程序以软中断的方式来通知系统执行一个系统的调用。通过引发异常来促使系统切换到内核态去执行异常处理程序。正是系统调用的处理程序。通过int$0x80指令触发中断。 指定恰当的系统调用系统调用号通过eax寄存器传递给内核。 参数传递也可以通过寄存器进行参数的传递。 系统调用的实现实现系统调用Unix格言提供机制而不是策略，当写一个系统调用时，要时刻注意可移植性和健壮性，还要为以后做打算。 参数验证系统调用必须仔细检查参数是否合法有效最重要的检查是用户提供的指针知否有效。内核无论何时都不能轻率接受来自用户空间的指针。 系统调用上下文在Context中，内核可以休眠可以被抢占。 绑定一个系统调用的最后步骤从用户空间访问系统调用","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback","slug":"Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T09:51:27.000Z","comments":true,"path":"2018/05/31/Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback/","excerpt":"","text":"SurfaceSurface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原生缓冲器以及其它方面的内容。原生缓冲器（rawbuffer）是用于保存当前窗口的像素数据的。通常画图是在一个Canvas对象上面进行的。 SurfaceViewSurfaceView，顾名思义就是Surface的View，通过SurfaceView就可以看到Surface的部分或者全部的内容.也就是说，Surface是用通过SurfaceView才能展示其中的内容。SurfaceView是Android中View的子类。事实上，在Android中所有用于界面展示的类皆为View的子类，包括那些不可见的、各种各样的Layout。 在Android中Surface是从Object派生而来，且实现了Parcelable接口。看到Parcelable就让人能很自然地想到数据容器，SurfaceView就是用来展示Surface中的数据的。在这个层面上而言，Surface就是管理数据的地方，SurfaceView就是展示数据的地方。 这个类的目的之一，就是提供一个可以用另外一个线程（第二个线程）进行屏幕渲染的surface（译注：即UI线程和绘制线程可以分离）。如果你打算这样使用，那么应当注意一些线程方面的语义： 所有SurfaceView和SurfaceHolder.Callback中声明的方法，必须在运行SurfaceView窗口中的线程中调用（典型地，就是应用的主线程。译注：即UI线程），因为它们需要正确地将同时被绘制线程访问的各种状态进行同步。 必须保证，只有在背后的Surface有效的时候 – 在SurfaceHolder.Callback.surfaceCreated()和 SurfaceHolder.Callback.surfaceDestroyed()这两个方法调用之间，访问它。 Android中实现序列化有两个选择：一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。 SurfaceHolderSurfaceHolder是一个接口，其作用就像一个关于Surface的监听器。提供访问和控制SurfaceView背后的Surface 相关的方法.它通过三个回调方法，让我们可以感知到Surface的创建、销毁或者改变。在SurfaceView中有一个方法getHolder，可以很方便地获得SurfaceView所对应的Surface所对应的SurfaceHolder.从设计模式的高度来看，Surface、SurfaceView和SurfaceHolder实质上就是广为人知的MVC，即Model-View-Controller。 SurfaceHolder.Callback前面已经讲到SurfaceHolder是一个接口，它通过回到方法的方式，让我们可以感知到Surface的创建、销毁或者改变。其实这一点是通过其内部的静态子接口SurfaceHolder.Callback来实现的。SurfaceHolder.Callback中定义了三个接口方法： abstract void surfaceChanged(SurfaceHolderholder, int format, int width, int height)当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。 abstract void surfaceCreated(SurfaceHolderholder)当surface对象创建后，该方法就会被立即调用。 abstract void surfaceDestroyed(SurfaceHolderholder)当surface对象在将要销毁前，该方法会被立即调用。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"}]},{"title":"implementation 与 compile 的区别 .iml build文件夹 安卓视图","slug":"implementation 与 compile 的区别 .iml build文件夹 安卓视图","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T09:51:21.000Z","comments":true,"path":"2018/05/31/implementation 与 compile 的区别 .iml build文件夹 安卓视图/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/implementation 与 compile 的区别 .iml build文件夹 安卓视图/","excerpt":"","text":"##implement概念 : 将该依赖隐藏在内部，而不对外部公开。理解 : 在 app mudule 中使用 implement 依赖的第三方库, 在其他 mudule 是无法调用的.举例 : 此时项目中有一个 mudule 是 ImageLoader ,其内部用 implement 指令依赖了 glide 这个库, 那么此时我们在 app mudule 中无法调用 glide 库中的方法. ##compile概念: android studio 3.0 版本后废弃该指令 改用 api 代替, api 完全等同于之前的 compile 指令, 也就是普通的依赖, 第三方库在 mudule 中依赖后其他 mudule 都可以使用该库.官方推荐在不影响的前提下优先使用 implement 指令依赖. .iml文件iml是 intellij idea的工程配置文件，里面是当前project的一些配置信息可以配置不输出文件夹。 build文件夹中的generated intermediates成功build后会产生以下文件夹：generated：The “generated“ folder contains java code generated by Android Studio for the module. The primary file here is “R.java“ which assigns symbolic names to each of the items in the “res” directory so they can be referenced in java source code.intermediates：The “intermediates“ folder contains individual files that are created during the build process and which are eventually combined to produce the “apk” file. Android视图与Project视图Project视图：Project视图是真实的文件结构，真实文件就是这么存放的。Android视图:可以说是build成功后根据配置信息，生成的结构。结构与配置信息有关，与build文件夹有关。不是真实文件的存放方式。其项目树的名字也不一定是真实名字，与配置信息有关。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/zdkswd/tags/AndroidStudio/"}]},{"title":"【安卓开发艺术探索】JNI和NDK编程","slug":"【安卓开发艺术探索】JNI和NDK编程","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T12:53:11.000Z","comments":true,"path":"2018/05/31/【安卓开发艺术探索】JNI和NDK编程/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/【安卓开发艺术探索】JNI和NDK编程/","excerpt":"","text":"NDK还提供了交叉编译器，开发人员只需要简单地修改mk文件就可以生成特定CPU平台的动态库。 JNI开发流程 在java中声明native方法声明native方法，且在类头部有加载动态库的过程，库的真实名字为加载所用名字加前缀lib，这是加载so库的规范。 编译java源文件得到class文件，然后通过javah命令导出JNI的头文件 javac com/ddd/example.javajavah com.ddd.example 在当前目录会产生一个com_ddd_example.h的头文件，它是javah命令自动生成的。函数名的格式遵循java_包名_类名_方法名 实现JNI方法，JNI方法是指java中声明的native方法，在工程的主目录下创建一个子目录，名称随意，将上一步生成的头文件复制其中，接着创建.cpp文件，include它。实现其中的方法。 编译so库并在java中调用so库这里采用gcc编译，切换到刚刚生成的子目录中，对于cpp编译指令如下： gcc -shared-I /本地jdk的安装路径/include -fPIC .cpp -o libexample.so so库编译完成后，就可以在Java程序中调用so库了，切换至主目录，执行指令 java -Djava.library.path=子目录名 com.ddd.example 其中-Djava.library.path指明了so库的路径。 NDK开发流程 下载并配置NDK 创建一个安卓项目，并声明所需的native方法如： public static native String hello(); 3.实现安卓项目中声明的native方法,在外部创建一个名为jni的目录，然后在jni目录下创建3个文件，.cpp,Android.mk和Application.mk .h中： JNIEXPORT jstring JNICALL Java_com_aiseminar_EasyPR_PlateRecognizer_hello(JNIEnv *, jclass); .cpp中实现其.h中的函数。Android.mk中，LOCAL_MODULE表示模块的名称，LOCAL_SRC_FILES表示需要参与编译的源文件。Application.mk中常用的配置项是APP_ABI,它表示CPU架构平台的类型，默认NDK编译全平台的so库，但可以指定编译特定平台的so库。 切换到jni目录的父目录，然后通过ndk-build命令编译产生so库这时NDK会创建一个和jni平级的目录libs，存放so库的目录。需要注意ndk-build命令默认指定jni目录为本地源码目录。若不是则无法成功编译。然后在app/src/main中创建一个名为jniLibs目录，将生成so库复制过去，通过AndroidStudio编译运行即可。jniLibs目录是AndroidStudio默认目录，也可修改App build.gradle文件，jniLibs.srcDir选项指定了新的存放so库的目录。 也可以通过AndroidStudio来自动编译来产生so库。首先需要在App的build.gradle的defaultConfig区域内添加NDK选项，其中moduleName制定了模块的名称，这个名称指定看打包后的so库文件名。ndk{\u0010 moduleName”example”}接着需要将JNI代码放在app/src/main/jni目录中，注意存JNI必须为jni，也可以通过如下方式指定JNI代码路径，其中jni.srcDirs指定JNI代码路径：jni.srcDirs ‘src/main/lib_src’经过上面的步骤，AndroidStudio就可以自动编译JNI代码了。 JNI的数据类型和类型签名JNI调用Java方法1 找到类名2 找到方法id3 调用方法对于非静态方法要先生成类才行","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"Bazel 和Protocol Buffer","slug":"Bazel 和Protocol Buffer","date":"2018-05-25T11:00:56.000Z","updated":"2018-05-25T11:01:05.000Z","comments":true,"path":"2018/05/25/Bazel 和Protocol Buffer/","link":"","permalink":"https://github.com/zdkswd/2018/05/25/Bazel 和Protocol Buffer/","excerpt":"","text":"BazelBazel是一个类似于Make的编译工具，是Google为其内部软件开发的特点量身定制的工具，如今Google使用它来构建内部大多数的软件。Google认为直接用Makefile构建软件速度太慢，结果不可靠，所以构建了一个新的工具叫做Bazel，Bazel的规则层级更高。 Protocol BufferProtocol Buffer是谷歌开发的处理结构化数据的工具。解决结构数据在信息持久化或网络传输时需要进行序列化以及还原数据的问题。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"Tensorflow模型持久化","slug":"Tensorflow模型持久化","date":"2018-05-25T11:00:56.000Z","updated":"2018-05-25T11:10:23.000Z","comments":true,"path":"2018/05/25/Tensorflow模型持久化/","link":"","permalink":"https://github.com/zdkswd/2018/05/25/Tensorflow模型持久化/","excerpt":"","text":"持久化代码实现通过tf.train.Saver类来保存和还原一个神经网络，模型文件目录下会出现三个文件。这是因为Tensorflow会将计算图的结构和图上参数取值分开保存。 model.ckpt.meta,保存了计算图的结构。 model.ckpt,保存程序中每一个变量的取值。 checkpoint,保存了一个目录下所有的模型文件列表。 加载已经保存的Tensorflow模型方法。1.使用和保存模型代码中一样的方法来声明变量。2.加载已经保存的模型。sever.restore(sess,”.ckpt”) 加载模型的程序也是定义了Tensorflow计算图上的所有运算，并声明了一个tf.train.Saver类。区别在于加载模型的代码中没有运行变量的初始化过程而是将变量的值通过已经保存的模型加载了进来。也可以直接加载已经持久化的图saver=tf.train.import_meta_graph(…..meta) 函数tf.get_default_graph().get_tensor_by_name(“add:0”)可以通过张量的名称获取张量。 也可以声明tf.train.Saver类时提供一个列表指定需要保存或者加载的变量。同样可以在保存和加载时使用字典给变量重命名。 使用Saver会保存运行程序所需的全部信息，然而有时不需要某些信息。在测试或者离线预测时，不需要某些辅助节点的信息。且多个文件存储时也并不方便。convert_variables_to_constants将计算图中的变量及其取值通过常亮保存。导出当前计算图的GraphDef部分只需要这一部分就可以完成从输入层到输出层的计算过程。 graph_def=tf.get_default_graph().as_graph_def() 将图中的变量及其取值转化为常量，同时将图中不必要的节点去掉。一些如变量初始化操作的系统运算也会被转化为计算图的节点。可以通过【】指定需要保存的操作。 output_graph_def=graph_util.convert_variables_to_constants(sess,graph_def,[‘add’])//add为节点名 将导出模型存入文件： with tf.gfile.GFile(“…pb”,”wb”) as f: f.write(output_graph_def.SerialzeToString()) 加载模型： with gflie.FastGFile(model_filename//.pb,’rb’) as f: graph_def=tf.GraphDef() graph_def.ParseFromString(f.read())result=tf.import_graph_def(graph_def,return_elements=[“add:0”])//add:0为一个张量sess.run(result) Saver持久化原理及数据格式Tensorflow通过元图（MetaGraph）来记录计算图中节点信息以及运行计算图中节点所需要的元数据。由Protocol Buffer定义，记录了五类信息： meta_info_def属性,记录计算图中的元数据以及所有使用到运算方法的信息。 graph_def属性，记录计算图的节点信息。 saver_def属性，记录了持久化模型时需要用到的一些参数。 collection_def属性维护集合的底层实现是通过collection_def这个属性。5 signature_def属性。 model.ckpt保存所有变量的取值，通过SSTable格式存储，大致为一个（key，value）列表。checkpoint是Saver类自动生成自动维护的。当某个保存的TensorFlow模型文件被删除时，这个模型对应的文件名也会从checkpoint文件中删除。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"Gradle","slug":"Gradle","date":"2018-05-20T09:28:56.000Z","updated":"2018-05-20T09:42:19.000Z","comments":true,"path":"2018/05/20/Gradle/","link":"","permalink":"https://github.com/zdkswd/2018/05/20/Gradle/","excerpt":"","text":"差异管理说到多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说国内某团购网站的Android App有100多个渠道.这里出现了什么?重复,反复的去打包而且这些包之前的差异很小(只是渠道号不同),和写代码一样我们应该复用,通过Gradle可以实现一个命令打出所有的渠道包,一个命令打出指定的渠道包.再复杂一点,你可能需要不同的渠道对应不同的签名文件,不同的icon,不同的服务器地址…这些都可以通过Gradle来方便的实现. 依赖管理:做软件开发你可能需要依赖各种不同的jar,library.你当然可以通过将.jar/library工程下载到本地再copy到你的工程中,但不知你是否听说过国外有个叫中央仓库的东西,在这个仓库里你可以找到所有你能想到以及你从来没听说过的jar,aar…The Central Repository Search Engine 这里可以找到所有你需要的依赖,而你需要的只是指定一个坐标,如下:compile’com.squareup.picasso:picasso:2.3.3剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点: 依赖不会进入到你的版本控制仓库中(默认会缓存到~/.gradle/下) 方便卸载装载依赖(只是一条坐标依赖,不需要删除即可) 方便的版本管理,如上图中的2.3.3既是picasso的版本号,若改为+就表示从中央仓库中下载最新的版本 不同工程的相同依赖不会存在重复副本(只在~/.gradle下存在一份)项目部署这方面我没怎么接触过,但据我所知通过一些插件,可以实现自动将你的输出(.jar,.apk,.war…)上传到指定仓库,自动部署… Gradle概念Gradle，这是一个基于 JVM 的富有突破性构建工具。Gradle不单单是一个配置脚本，它的背后是三门语言。 ◦ Groovy Language ◦ Gradle DSL ◦ Android DSLDSL的全称是Domain Specific Language，即领域特定语言。 The Gradle wrapperGradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。 Gradle构建基础build.gradle一个项目中会有一个project build.gradle。与若干个module build.gradle.你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本。 project与taskGradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等。插件本身就是包含了若干Task的。 Gradle脚本的执行时序 初始化，分析有哪些module将要被构建，为每个module创建对应的 project实例。这个时候settings.gradle文件会被解析。 配置,处理所有的模块的 build 脚本，处理依赖，属性等。这个时候每个模块的build.gradle文件会被解析并配置，这个时候会构建整个task的链表（这里的链表仅仅指存在依赖关系的task的集合，不是数据结构的链表）。先是project build.gradle后是module build.gradle,且从依赖树的叶节点执行。配置完了以后，有一个重要的回调project.afterEvaluate，它表示所有的模块都已经配置完了，可以准备执行task了。 执行，根据task链表来执行某一个特定的task，这个task所依赖的其他task都将会被提前执行。 Groovy基础[原创：任玉刚]Groovy和Java的关系Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。 Groovy的变量和方法声明在Groovy中，通过 def 关键字来声明变量和方法。 def a = 1def b = “hello world”def int c = 1 def hello() { println “hello world” // 方法调用省略括号 1; // 方法返回值省略return}def hello(String msg) { println (msg)} // 方法省略参数类型int hello(msg) { println (msg) return 1} // 方法省略参数类型int hello(msg) { println msg return 1 // 这个return不能省略 println “done”} Groovy的数据类型 String,用于字符串拼接。 闭包，Groovy中有一种特殊的类型，叫做Closure，翻译过来就是闭包，这是一种类似于C语言中函数指针的东西。闭包用起来非常方便，在Groovy中，闭包作为一种特殊的数据类型而存在，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在。 声明闭包 { parameters -&gt; code} List和Map,Groovy加强了Java中的集合类，比如List、Map、Set等.List还有一种看起来很奇怪的操作符&lt;&lt;，表示向List中添加新元素的意思. 加强的IO. 其他特性 所有的Class类型，都可以省略.class 只要有属性就有Getter/Setter，反之亦然。 with操作符 Book bk = new Book()bk.id = 1bk.name = “android art”bk.press = “china press” 可以简写为： Book bk = new Book()bk.with { id = 1 name = “android art” press = “china press”} 等等http://www.jianshu.com/p/ba55dc163dfd 定义Task task myTask { println “config myTask”} 通过上述方式定义的task,括号内部的代码会在配置阶段执行。 要括号内的代码仅仅在执行我们的task的时候才执行，这个时候可以通过doFirst或者doLast来完成。 • doFirst：task执行时，最开始的操作 • doLast：task执行时，最后的操作 myTask.doLast { println “after execute myTask”}myTask.doFirst { println “before execute myTask”} doLast还有一个等价的操作leftShift，leftShift还可以缩写为&lt;&lt; myTask &lt;&lt; { println “after execute myTask”} 剩下的细节还是需要大家查看Gradle文档，其实学习Gradle就是一个查文档的过程。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"软件构筑","slug":"软件构筑","permalink":"https://github.com/zdkswd/tags/软件构筑/"}]},{"title":"x86 ARM MIPS NDK JNI 交叉编译 ABI","slug":"x86 ARM MIPS NDK JNI 交叉编译 ABI","date":"2018-05-19T13:46:56.000Z","updated":"2018-05-25T10:28:41.000Z","comments":true,"path":"2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/","link":"","permalink":"https://github.com/zdkswd/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/","excerpt":"","text":"X86和ARM,MIPS架构x86架构采用CISC，代表公司Intel。而ARM采用RISC，代表公司ARM。MIPS架构多用在网关、猫、机顶盒等设备。 X86以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。x86为此还必须有复杂的分支预测机构，确保流水线的效率。再加上多级cache，支持超线程、虚拟化等等，x86的复杂度其实相当高ARM（Advanced RISC Machines）一个32位元精简指令集(RISC)处理器架构可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。 扩展性X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行 功耗X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度，考虑其完成复杂操作的能力，功耗很大。ARM则功耗很低。ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场，ARM目前是移动处理器的老大；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 x86是PC端老大。 NDKNative Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C/C++的动态库，并能自动将so和java一起打包成apk。NDK就是帮助我们可以在Android应用中使用C/C++来完成特定功能的一套工具.NDK的作用有很多，我们简单的列举两个:1.首先NDK可以帮助开发者“快速”开发C(或C++)的动态库。2.其次，NDK集成了“交叉编译器”。使用NDK，我们可以将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。 JNIJava Native Interface（JNI）标准是java平台的一部分，JNI是Java语言提供的Java和C/C++相互沟通的机制，其实JNI它就是一种协议,Java可以通过JNI调用C/C++代码，C/C++的代码也可以调用java代码。 交叉编译编译器在将中间代码连接成当前计算机可执行的二进制程序时，连接程序会根据当前计算机的CPU、操作系统的类型来转换。交叉编译就是在一个平台下（比如：CPU架构为X86，操作系统为Windows）编译出在另一个平台上（比如：CPU架构为arm,操作系统为Linux）可以执行的二进制代码。Google提供的NDK就可以完成交叉编译的工作。【Android：基于Linux 内核arm架构的操作系统，装在arm上的linux是需要重新编译内核的 所以和x86上的linux内核是不一样的】 Android 设备的CPU类型(通常称为”ABIs”) armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的部分Android设备都使用它. arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。 armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。 x86: 平板、模拟器用得比较多。 x86_64: 64位的平板。 arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so，那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了，所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，所以要么你别加arm64-v8a,要么armeabi里面有的so库，arm64-v8a里面也必须有。 对策： 为了减小 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中.so数量一致 对只提供 armeabi 版本的第三方 .so，原样复制一份到 armeabi-v7a 文件夹 应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。 当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支持armeabi-v7a和armeabi）。我们往往很容易对.so文件应该放在或者生成到哪里感到困惑，下面是一个总结：Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"},{"name":"c/c++","slug":"c-c","permalink":"https://github.com/zdkswd/tags/c-c/"}]},{"title":"lib dll .h .hpp 预编译","slug":"lib,dll,.h,.hpp,预编译","date":"2018-05-17T13:46:56.000Z","updated":"2018-05-17T13:48:13.000Z","comments":true,"path":"2018/05/17/lib,dll,.h,.hpp,预编译/","link":"","permalink":"https://github.com/zdkswd/2018/05/17/lib,dll,.h,.hpp,预编译/","excerpt":"","text":"静态库动态库静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。 这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。 是动态链接有一个缺点就是可移植性太差，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败。 头文件编译时，编译器通过头文件.h找到对应的函数库，预编译时将整个.h文件插入目标文件头部，项目中需要有其对应的.c文件进行编译生成中间文件进行连接。.hpp，本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数 一个头文件被别的源文件重复包含是经常发生的，如何避免某个头文件被重复包含呢？利用条件编译轻松解决。在头文件的开始加入： #ifndef HEADER_NAME#define HEADER_NAME 在头文件的结尾加上： #endif C/C++中的预编译指令程序的编译过程可以分为预处理、编译、汇编三部分，其中预处理是首先执行的过程，预处理过程扫描程序源代码，对其进行初步的转换，产生新的源代码提供给编译器。 #include指令，#include预处理指令的作用是在指令处展开被包含的文件。#include \\&lt;xxx.h&gt;#include “xxx.h”第一种方法将待包含的头文件使用尖括号括起来，预处理程序会在系统默认目录或者括号内的路径查找，通常用于包含系统中自带的公共头文件。第二种方法将待包含的头文件使用双引号引起来，预处理程序会在程序源文件所在目录查找，如果未找到则去系统默认目录查找，通常用于包含程序作者编写的私有头文件。 2.#define、#undef指令,#define指令定义了一个标识符及一个串，标识符称为宏名，源程序中宏名的每次出现都会用其定义的串进行替换，称为宏替换。#undef指令取消一个已定义的宏。 3.#if、#elif、#else、#endif指令，这几个指令称为条件编译指令，可对程序源代码的各部分有选择地进行编译。跟一般的if、else if、else语句类似，如果一个条件上的值为真，则编译它对应的代码，否则提过这些代码，测试下一个条件上的值是否为真。注意，作为条件的表达式是在编译时求值的，它必须仅含常量及已定义过的标识符，不可使用变量，也不可以含有操作符sizeof（sizeof也是编译时求值）。感觉这主要是用来设置一个宏选择性的编译一部分的代码。 4.#ifdef、#ifndef、#endif指令，这几个也是条件编译指令，其检查后面指定的宏是否已经定义，然后根据检查结果选择是否要编译后面语句。其中#ifdef表示”如果有定义“，#ifndef表示”如果没有定义“。这个通常可以用于防止重复包含头文件的问题 #ifndef MYHEAD_H#define MYHEAD_H#include “myHead.h”#endif 5.#line指令,C语言中可以使用FILE表示本行语句所在源文件的文件名，使用LINE表示本行语句在源文件中的位置信息。#line指令可以重新设定这两个变量的值，其语法格式为#line number[“filename”] 6.#error指令,#error指令在编译时输出编译错误信息，可以方便程序员检查出现的错误。 7.#pragma指令,该指令用来来设定编译器的状态或者是指示编译器完成一些特定的动作，它有许多不同的参数。7.1. #pragma once在头文件的最开始加入这条指令可以保证头文件只被编译一次。它可以实现上述使用#ifndef实现不重复包含头文件同样的功能，但可能会有部分编译系统不支持。 7.2.#pragma message该指令能够让编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。 7.3.#pragma warning…等等其他参数","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"},{"name":"c/c++","slug":"c-c","permalink":"https://github.com/zdkswd/tags/c-c/"}]},{"title":"Tensorflow可视化","slug":"Tensorflow可视化","date":"2018-05-17T10:11:41.000Z","updated":"2018-05-25T11:54:26.000Z","comments":true,"path":"2018/05/17/Tensorflow可视化/","link":"","permalink":"https://github.com/zdkswd/2018/05/17/Tensorflow可视化/","excerpt":"","text":"Tensorflow计算模型–计算图计算图的使用tensorflow程序可分为两个阶段，第一阶段定义图中所有的计算。第二阶段为执行阶段。tensorflow中，系统会自动维护一个默认的计算图，通过tf.get_default_graph函数可以获取当前默认的计算图。除了使用默认的计算图，Tensorflow支持通过tf.Graph函数来生成新的计算图。不同计算图上的张量和运算都不会共享。计算图可以通过tf.Graph.device函数来指定运行计算的设备。有效地整理TensorFlow程序的资源也是计算图的一个重要功能。在一个集合（collection）来管理不同类型的资源。 集合名称 集合内容 使用场景 tf.GraphKeys.VARIABLES 所有变量 持久化Tensorflow模型 tf.GraphKeys.TRAINABLE_VARIABLES 可学习的变量（一般指神经网络中的参数） 模型训练、生成模型可视化内容 tf.GraphKeys.SUMMARIES 日志生成的相关的张量 TensorFlow计算可视化 tf.GraphKeys.QUEUE_RUNNERS 处理输入的QueueRunner 输入处理 tf.GraphKeys.MOVING_AVERAGE_VARIABLES 所有计算了滑动平均值的变量 计算变量的滑动平均值 如通过tf.add_to_collection将资源加入一个或多个集合中。通过tf.get_collection获取一个集合里面的所有资源。 TensorBoard可视化TensorBoard简介TensorBoard可以通过TensorFlow程序运行过程中输出的日志文件可视化TensorFlow程序的运行状态。两者跑在不同进程中，TensorBoard会自动读取TensorFlow最新的日志文件。 #运行TensorBoard，将地址执行日志输出地址tensorboard –logdir=/path/to/log 命令启动服务默认端口号6006，localhost:6006可以看到界面。使用–port参数可以改变启动服务的端口。 变量管理TensorFLow提供了通过变量名称来创建或者获取一个变量的机制。通过这个机制在不同的函数中可以直接通过变量的名称来使用变量，而不需要将变量通过参数的形式到处传递。TensorFLow中通过变量名称获取变量的机制主要是通过tf.get_variable和tf.variable_scope函数实现。 v.get_variable和tf.Variable定义等价。区别在于前者变量名称是个必填项，后者是个选填项。v.get_variable会根据这个名字去创建或者获取变量。首先会试图创建一个变量，如有同名则创建失败。如果需要通v.get_variable获取一个已经创建的变量，需要tf.variable_scope函数生成一个上下文管理器。将参数reuse设置为True(获取唯一途径)，v.get_variable将只能获取已经创建过的变量。否则将尝试创建变量。 with v.variable_scope(“name”,reuse=”True”): v=v.get_variable(“var”,[1]) tf.variable_scope会创建一个命名空间。foo/v:0 “:0”表示这个变量是生成变量这个运算的第一个结果。 TensorFlow计算图可视化命名空间与TensorBoard图上节点变量的初始化过程也会产生新的计算节点。为了更好的组织可视化效果图中的计算节点，TensorBoard支持通过TensorFlow命名空间来整理可视化效果图上的节点。在Tensorflow默认视图中同一命名空间计算图为一个节点，只有顶层命名空间的节点显示。除了tf.Variable_scope函数，tf.name_scope函数也提供了命名空间管理的功能，两者大部分情况下等价。唯一的区别是tf.get_Variable不受tf.name_scope函数的影响。即在tf.name_scope域里tf.get_Variable生成变量也不是域内的变量。节点之间有两种不同的边，一种是通过实线表示的，刻画了数据传输，箭头表示传输方向。另一种箭头是双向的，表示会修改，会互相影响。TensorBoard边上标注了张量的维度信息。如100*784说明batch为100，输入节点个数为784，粗细代表维度的总大小。若张量数量大于1时。图上将只显示张量的个数。虚线表示计算之间的依赖关系，如tf.control_dependencies函数指定操作同时进行。则存在虚线。TensorBoard会自动将连接比较多的节点放在辅助图中，可以手动移入主图或移出主图。TensorBoard不会保存用户对计算图可视化结果的手工修改，页面刷新之后计算图可视化结果又会回到最初的样子。 节点信息使用TensorBoard可以非常直观地展现所有Tensorflow计算节点在某一次运行时所消耗的时间和内存。 run_options =tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)// 运行时记录运行信息的proto。run_metadata = tf.RunMetadata() m, loss_value, step = sess.run( [train_op, loss, global_step], feed_dict={x: xs, y_: ys}, options=run_options, run_metadata=run_metadata) //将节点在运行时的信息写入日志文件。 writer.add_run_metadata(run_metadata=run_metadata,tag=(“tag%d” % i),global_step=i) 使用程序输出的日志启动TensorBoard,就可以了。进入GRAPHS栏，选择Session runs,Color会出现Compute time和Memory这两个选项。颜色越深消耗越大。Structure中如果有两个节点结构相同就会涂上相同的颜色。Device中可显示哪些使用了相同的设备（CPU/GPU）。点击节点时弹出的信息卡片也会显示这个节点的各种信息。 监控指标可视化 TensorFlow日志生成函数 TensorBoard界面栏 显示内容 tf.scalar_summary EVENTS TensorFlow中标量（scalar）监控数据随着迭代进行的变化趋势。 tf.image_summary IMAGES TensorFlow中使用的图片数据，这一栏一般用于可视化当前使用的训练/测试图片。 tf.audio_summary AUDIO TensorFlow中使用的音频数据。 tf.histogram_summary HISTOGRAMS TensorFlow中张量分布监控数据随着迭代轮次的变化趋势。 上述生成函数都不会立即执行，需要通过sess.run来明确调用这些函数。tf.merge_all_summaries()可将定义的所有日志文件执行一次。 writer writer=tf.train.SummaryWriter(path,tf.get_default_graph())writer.close() 或者 with tf.Session() as sess: writer=tf.train.SummaryWriter(path,sess.graph) 上述比较过时，若报错则改为writer = tf.summary.FileWriter(“output”, sess.graph)","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"[Linux内核设计与实现]进程调度","slug":"【Linux】进程调度","date":"2018-05-15T13:39:12.000Z","updated":"2018-05-16T11:00:02.000Z","comments":true,"path":"2018/05/15/【Linux】进程调度/","link":"","permalink":"https://github.com/zdkswd/2018/05/15/【Linux】进程调度/","excerpt":"","text":"多任务现代Linux系统也许有100个进程在内存，但是只有一个处于可运行状态。Linux是抢占式多任务模式。 Linux的进程调度Linux2.5内核开始采用O（1）调度程序，对大服务器工作负载很理想但对于交互性桌面系统表现不佳。2.6.23内核后使用RSDL增加了交互性，此时被称为CFS（完全公平调度算法） 策略I/O消耗型和处理器消耗型的进程GUI属于I/O消耗型，多数时间都在等待键鼠交互操作。应当降低处理器消耗型的调度频率，以延长其运行时间。Linux更倾向于IO消耗型进程，也并未忽略处理器消耗型进程。 进程优先级Linux采用了两种不同范围的优先级范围。1：使用nice值，范围【-20，19】，默认0，越大优先级越低。Linux nice代表时间片比例，mac os nice代表时间片的绝对值。2：实时优先级，其值可配。范围【0，99】，越高优先级越大。任何实时进程优先级都高于普通进程。 时间片Linux的CFS调度器并没有直接分配时间片到进程，将处理器的使用比划分给了进程。进程所获处理器的时间和负载密切相关。受nice值得影响。Linux的CFS调度器抢占时机取决于进程的处理器使用比，若大于当前进程则抢占。 调度策略的活动对于一个文字编辑程序和一个视频处理程序，一般操作系统会分配文字编辑器更高的优先级和更多的时间片。Linux则是nice值相同，即平分50%时间，但是当文字编辑程序要使用处理器时，CFS发现其时间没到50%，会抢占视频处理程序执行。 Linux调度算法调度器类Linux调度器是模块方式，可以针对不同类型的进程选择合适的调度算法。完全公平调度（CFS）是针对普通进程的调度类。 Unix系统的进程调度CFS完全摒弃时间片而是分配进程一个处理器的使用比重，这样CFS确保了进程调度有恒定的公平性，将切换频率置于不断变动中。 公平调度CFS的最小粒度（最小时间片长度）为1ms，时间片分配时间根据目标延迟以及nice值决定的比例计算而得。所以说其实如果进程无限大的话，改法并不公平。但是能保证正常情况下是公平的。 Linux调度的实现时间记账 所有的调度器都必须对进程运行时间做记账。 调度器实体结构,CFS不再有时间片的概念，但是它也必须维护每个进程运行时间记账，为了确保每个进程只在公平分配给它的处理器时间运行。CFS使用调度器实体结构struct sched_entity作为名为se的成员变量，嵌入进程描述符struct task_struct内。 虚拟实时，struct sched_entity结构中的vruntime变量存放进程的虚拟运行时间，虚拟时间是以ns为单位的，与定时器节拍不再相关。vruntime可以准确地测量给定进程的运行时间，而且可知道谁应该是下一个被运行的进程。 进程选择当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小的vruntime值的进程。红黑树是一种以树节点形式存储的数据，这些数据都对应一个键值，可通过键值快速检索节点上的数据。 挑选下一个任务，CFS调度器选取待运行的下一个进程，是所有进程中vruntime最小的那一个，对应的便是树最左侧的叶子节点。 向树中加入进程，CFS如何将进程加入rbtree中，以及如何缓存最左叶子节点。这一切发生在进程变为可运行状态（被唤醒）或是通过fork()调用第一次创建进程时。enqueue_entity()函数实现了这一目的。改函数更新运行时间和其他一些统计数据，然后调用_enqueue_entity()进行繁重的插入操作，把数据项真正插入到红黑树中。 从树中删除进程, 删除动作发生在进程堵塞或者终止时。调度器入口进程调度的主要入口点是函数schedule()，它会找到一个最高优先级的调度类，其需要有自己的可运行队列。睡眠和唤醒休眠（被阻塞）进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程刚好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。 等待队列， 等待队列是由等待某些事件发生的进程组成的简单链表。 唤醒， 唤醒指定等待队列上的所有进程。抢占和上下文切换上下文切换，就是从一个可执行进程切换到另一个可执行的进程。由函数context_switch()负责，每当新的进程被选出来准备投入运行时，schedule()就会调用该函数。内核提供了一个need_resched标志表明是否需要重新执行一次调度，内核也就知道什么时候调用schedule()。当某个进程应该被抢占或优先级高的进程进入可执行状态时或中断返回或系统调用返回用户空间，会设置标志位。用户抢占内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。即用户抢占发生在 从系统调用返回用户空间时。 从中断处理程序返回用户空间时。 内核抢占Linux完整地支持内核抢占，只要重新调度是安全的，内核就可以在任何时候抢占正在执行的内核任务。安全即没有持有锁，即preempy_count=0且need_resched被设置，中断返回内核空间时，就可调度。同样若内核阻塞或显式调用schedule()也会显式抢占。 实时调度策略Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的非实时的调度策略是SCHED_NORMAL.这些策略被一个特殊的实时调度器管理。 SCHED_FIFO, 不基于时间片，可以一直执行下去，其比任何SCHED_NORMAL级的进程都先得到调度。更高优先级的SCHED_FIFO或SCHED_RR才能抢占。优先级一样的就轮流执行。 SCHED_RR,带有时间片的SCHED_FIFO，耗尽时间片时，只能调度同一优先级的进程。【 总结】：对于SCHED_FIFO进程，高优先级总是立即抢占低优先级进程，但低优先级决不能抢占SCHED__RR任务，即使它的时间片耗尽。Linux提供的是软实时工作方式，SCHED_RR与SCHED_FIFO优先级范围【0，99】，而SCHED_NORMAL使用nice值。与调度相关的系统调度Linux提供了一个系统调用族，用于管理与调度程序的相关参数。这些系统调用可以用来操作和处理进程优先级、调度策略及处理器绑定，同时还提供了显式地将处理器交给其他进程的机制。与调度策略和优先级相关的系统调用sched_setscheduler()和sched_getscheduler()用于设置和获取进程的调度策略和实时优先级。sched_setparam()和sched_getparam()用于设置和获取进程的实时优先级。与处理器绑定有关的系统调用Linux调度程序提供强制的处理器绑定机制。放弃处理器时间Linux通过sched_yield()系统调用，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"初识makefile_make_cmake","slug":"cmake","date":"2018-04-29T14:11:20.000Z","updated":"2018-05-16T11:02:54.000Z","comments":true,"path":"2018/04/29/cmake/","link":"","permalink":"https://github.com/zdkswd/2018/04/29/cmake/","excerpt":"","text":"初识makefile,make,cmake什么是makefilemake命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。makefile关系到了整个工程的编译规则。makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 什么是makemakefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法（包括链接）。 关于程序的编译和链接在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。Linux中的.so。一个lib文件是obj文件的集合。源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码 文件路径usr文件夹称为是Unix System Resource，即Unix系统资源的缩写。 bin文件夹是一个二进制程序文件夹1.bin是binary的缩写，代表的意思是二进制，二进制数据是用0和1两个数码来表示的数。2.bin这个文件夹里存放的是二进制可执行的文件，比如exe，msi，com等的都是二进制文件，双击就能运行。 GUN下面绝大部分应用的编译系统都是用automake。于是乎，你看到的很多很多应用都安装在了/usr/local/目录下然后通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变/usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件安装好的lib文件存放在“/usr/local/lib”文件夹，h文件存放在“/usr/local/include”（Unix） 什么是cmakeCMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。 dlldll存在于windows中 openCV安装过程 mkdir releasecd releasecmake -D CMAKE_BUILD_TYPE=RELEASE -D 换行CMAKE_INSTALL_PREFIX=usr/local/opencv3.1.0 -G “Unix Makefiles” ..makesudo make install","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"软件构筑","slug":"软件构筑","permalink":"https://github.com/zdkswd/tags/软件构筑/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"}]},{"title":"李宏毅2017听课笔记1-Where does the error come from?","slug":"李宏毅error","date":"2018-04-25T14:48:13.000Z","updated":"2018-05-16T11:00:59.000Z","comments":true,"path":"2018/04/25/李宏毅error/","link":"","permalink":"https://github.com/zdkswd/2018/04/25/李宏毅error/","excerpt":"","text":"李宏毅2017听课笔记1-Where does the error come from? 这么多线是多次试验，每次试验拟合出一条红线 在这里直观的解释了为什么简单的模型偏差更大，因为最终是在函数集中选取最佳函数，因为函数简单的话，一开始划定的范围就较小。 正则化会伤害bias，因为只选择更平滑的曲线，相当于划了范围。（其实是让模型更简单了） 分为训练集，验证集，测试集","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"李宏毅","slug":"李宏毅","permalink":"https://github.com/zdkswd/tags/李宏毅/"}]},{"title":"李宏毅2017听课笔记0","slug":"李宏毅2017听课笔记0","date":"2018-04-25T01:26:25.000Z","updated":"2018-07-03T02:34:22.000Z","comments":true,"path":"2018/04/25/李宏毅2017听课笔记0/","link":"","permalink":"https://github.com/zdkswd/2018/04/25/李宏毅2017听课笔记0/","excerpt":"","text":"李宏毅2017听课笔记0前言之前听了吴恩达2014大部分的课以及吴恩达最近在网易云上的CNN课程。听闻李宏毅的课程不错，主要比较系统全面，来听一哈喽。不错的博客 0-1Introduction找出function 准备一个function set (model) 机器决定function们的好坏 找出最好的function Deep Learning：分类，非线性 Learning Map Reinforcement Learning在实际运用中，以上方法并不能解决全部问题，常常会遇到Beyond Classification的情况，比如语音识别，人脸识别，语言翻译等，那么就要通过增强学习来解决问题。增强学习的一个非常知名的应用就是 google 阿法狗。 Reinforcement Learning VS SupervisedSupervised 就像给了机器一个点读机，他听到一句话时可以看到其含义，每一句话都有标签，就像有一个手把手教他的老师。而Reinforcement Learning 就像跟女朋友对话，反复讲来回讲很多句话，直到女朋友觉得你无言以对愤然离去，机器唯一可以知道的就是他做的好还是不好，除此之外没有任何information。而这更像人类现实生活中的学习过程，必须自己像哪里做得好做得不够好，怎么修正。 Learning Map: scenario:学习情景，不受自己控制。意思是你现在有什么类型的 training data。 machine learning scenario Supervised Learning 有标签data Semi-supervised Learning 部分有标签data Unsupervised Learning 无标签data Transfer Learning 一堆不相干data Reinforcement Learning 只有来自外界的评价 task，意思是现在function的output是什么，只体现在supervised中，但其实可以插在以上五种Learning的每一种内。 machine learning task(output) Regression scalar Classification class1、class2…之一 Structured Learning 有结构的内容 Method方法模型，比如在Classification中有Linear模型 or Non-linear模型，我们可以将绿色部分插入任何红色部分中。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"李宏毅","slug":"李宏毅","permalink":"https://github.com/zdkswd/tags/李宏毅/"}]},{"title":"[Linux内核设计与实现]进程管理","slug":"【Linux内核】进程管理","date":"2018-04-16T10:50:51.000Z","updated":"2018-07-26T09:22:24.000Z","comments":true,"path":"2018/04/16/【Linux内核】进程管理/","link":"","permalink":"https://github.com/zdkswd/2018/04/16/【Linux内核】进程管理/","excerpt":"","text":"进程内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。父进程调用fork()复制现有进程创建一个全新的进程子进程。 每个线程都有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。进程的另一个名字是task，Linux内核通常把进程也叫做任务。 进程描述符及任务结构内核把进程的列表存放在任务列表（task list）的双向循环列表中。链表的每一项都是类型为task_struct称为进程描述符的结构中，该结构相对较大，包含的数据能够完整的描述一个正在运行的程序：打开的文件，进程地址空间，挂起信号，进程状态及其他。 分配进程描述符Linux通过slab分配器分配task_struct结构,这样能够对象复用和缓存着色。使用slab动态生成task_struct需要用到结构thread_info,其task域有指向实际进程描述符的指针。每个任务的thread_info在它的内核栈的尾端分配。 进程描述符的存放内核通过唯一标识符PID（process indentification value）来标识每个进程，PID存放在进程描述符。为了兼容性设置其为short int型，故其最大值为32768.但是对于大型服务器需要更大值。可以不考虑兼容性修改/proc/sys/kernel/pid_max提高上限。 内核访问任务需要获取指向task_struct的指针，故通过宏找到当前正在运行的进程描述符的速度就尤为重要。硬件的结构体系不同，宏的实现不同。例如有的体系结构有专用寄存器用于加快访问task_struct的速度，x86结构寄存器并不富余，就只能通过计算偏移间接查找task_struct。 进程状态task_struct的state域描述当前状态，必为五中之一 TASK_RUNNING(运行)在运行或在运行队列等待 TASK_INTERRUPIBLE(可中断)被阻塞 TASK_UNINTERRUPTIBLE（不可中断）接到信号也不会唤醒 _TASK_TRACED被其他进程跟踪 _TASK_STOPPED停止执行 设置当前的进程状态调整某个进程状态 set_task_state(task,state); 进程上下文可执行代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行，一般在用户空间执行，执行系统调用或触发异常陷入内核空间。对内核的访问必须经过明确定义的接口。 进程家族树Linux和Unix一样所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程读取系统初始化脚本（initscript）并执行其他相关程序最终完成系统启动整个过程。init进程的进程描述符是作为init_task静态分配的。对于当前task_struct，可以通过task_struct类型parent指针访问其父进程（必有一个），还包含一个children的子进程链表。 进程创建许多其他操作系统：首先在新的地址空间创建进程，读入可执行文件，最后开始执行。Unix：首先通过fork（）拷贝当前进程创建一个子进程，父子进程区别仅限于PID，PPID（子进程将其设为父进程PID值）和某些资源统计量。exec（）负责读取可执行文件并将其载入地址空间运行。如果 exec 调用成功,调用进程将被覆盖,然后从新程序的入口开始执行。这样就产生了一个新的进程,但是它的进程标识符与调用进程相同。这就是说,exec 没有建立一个与调用进程并发的新进程,而是用新进程取代了原来的进程。 写时拷贝Linux的fork（）采用写时拷贝，只有子进程在父进程进行写入时再进行拷贝，其他的时候是只读共享。所以fork（）的实际开销就是复制父进程页表以及创建PID。 fork（）Linux通过clone（）系统调用实现fork（）fork（）-调用-&gt;clone()-调用-&gt;do_fork()（完成创建的大部分工作）-调用-&gt;copy_process()copy_process工作: 调用dup_task_strucr()为新进程创建一个内核栈、thread_info和task_struct，此时，父子进程描述符完全一样。 检查并确保新创建这个进程后进程数目没有超出资源限制。 子进程着手于区别父进程。task_struct的许多成员被清零或设为初始值。 子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行。 copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERRIV标志被清0，表示进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。 调用alloc_pid()为新进程分配一个分配一个有效的PID。 根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信息处理函数、进程地址空间和命名空间等。一般，这些资源会所有线程共享，否则资源对每个进程是不同的，因此拷贝到这里。 最后，copy_process做扫尾工作并返回一个指向子进程的指针。 如果copy_process()成功返回do_fork()，新创进程被唤醒且内核有意让其首先执行。因为一般子进程都会马上调用exec()函数，可以避免父进程首先执行可能的写入造成的额外开销。 vfork（）除了不拷贝父进程的页表项以外，vfork()和fork()功能相同。基本没啥用。 线程在Linux中的实现Linux中，线程具有task_struct,它看起来就是普通进程，只是和其他一些进程共享某些资源，如地址空间。对Linux来说，线程只是进程间共享资源的手段。 创建线程线程创建于进程类似，只是在调用clone时需要传递一些参数标明需要共享的资源。创建Linux进程所花时间和其他操作系统创建线程要少。 内核线程独立运行在内核空间的标准进程，和普通进程区别在于没有独立地址空间。只在内核空间运行，和普通进程一样，可以被调度，也可以被强占。新的任务是由kthread内核进程通过clone()系统调用而创建的。内核线程启动后就一直运行到调用do_exit（）退出或其他部分调用kthread_stop()退出。 进程终结终结时，释放资源并告诉父进程。可以调用exit()主动终结,也可以异常被动终结,但大部分靠do_exit()来完成do_exit(): 将task_struct标志设为PF_EXITING 调用del_time_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器在排队也没有定时器处理程序在运行。 如果BSD的记账功能是开启的，do_exit()调acct_update_integrals()来输入记账信息。 调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是说，这个进程空间没有被共享），就彻底释放它们。 调用sem_exit()函数，如果进程排队等候IPC信号，它则离开队列。 调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为0，那么久代表没有进程在使用相应的资源可以释放。 接着把存放在task_struct和exit_code成员中的任务退出代码置为由exit（）提供的退出代码，或者去完成任何其他由内核机制规定的退出动作，退出代码存放在这里供父进程随时检索。 调用exit_notufy()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或为init进程，并把进程状态（存放在task_struct中的exit_state中）设成EXIT_ZOMBIE。 do_exit()调用schedule（）切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。do_exit()永不返回。 至此进程仅剩的内存就是内核栈，Thread_info 和task_struct结构。此时进程存在的唯一目的数向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关信息后，内存释放。 删除进程描述符进程终结时的清理工作和进程描述符的删除被分开进行，这样做可以让系统有办法在子进程终结后仍能获得它的信息。过程如上段。 孤儿进程造成的进退维谷如果父进程在子进程之前退出，必须有机制来保证子进程能够找到一个新的父亲。解决方法是给子进程在当前线程组内找一个线程做父亲，如果不行，就让init做父进程。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[LINUX内核设计与实现]第二章","slug":"从内核出发","date":"2018-04-13T12:36:32.000Z","updated":"2018-05-16T10:02:54.000Z","comments":true,"path":"2018/04/13/从内核出发/","link":"","permalink":"https://github.com/zdkswd/2018/04/13/从内核出发/","excerpt":"","text":"从内核出发内核源码树内核源码树根目录描述 目录 描述 arch 特定体系结构的源码 block 块设备IO层 crypto 加密API Documentation 内核源码文档 drivers 设备驱动程序 firmware 使用某些驱动程序而需要的设备固件 fs VFS和各种文件系统 include 内核头文件 init 内核引导和初始化 ipc 进程间通信代码 kernel 像调度程序这样的核心子系统 lib 通用内核函数 mm 内存管理子系统和VM net 网络子系统 samples 实例，示范代码 scripts 编译内核所用的脚本 security Linux安全模块 sound 语音子系统 usr 早期用户空间代码（所谓的initramfs） tools 在Linux开发中有用的工具 virt 虚拟化基础结构 在源码根目录还有很多文件值得提及。COPYING文件是内核许可证（GNU GPL v2）。CREDITS是开发了很多内核代码的开发者列表。MAINTAINERS是维护者列表，负责维护内核子系统和驱动程序。Makefile是基本内核的Makefile。 编译内核配置内核在编译前可以把自己的需要的特定功能和驱动程序编译进内核，首先必须先配置，其以CONFIG_FEATURE形式表示。配置选项要么是二选一（yes/no）要么是三选一（yes/no/module）module表示这部分功能的实现代码是以模块的形式生成。驱动程序一般都是三选一选项。配置选项也可以是字符串或整数。这些选项并不控制编译过程，而只是指定内核源码可以访问的值，一般以预处理宏的形式表示。 $ make config 该工具会遍历所有配置项，但耗时过长 $make menuconfig$make gconfig 可破之。以上三种工具将所有配置分门别类的放置。 $make defconfig 创建默认配置。这些配置项被存放在根目录的.config文件中。在进行修改后，你应当验证和更新配置： $ make oldconfig 配置选项CONFIG_IKCONFIG_PROC把完整的压缩内核配置文件放在/proc/config.gz下，在编译新内核时可以克隆配置。 $zcat /proc/config.gz &gt; .config$make oldconfig 衍生多个编译作业make程序能把编译过程拆分成多个并行的作业。极大加快编译的过程。 $make -jn 安装新内核 %make modules_install 内核开发的特点 内核编程时既不能访问c库也不能访问标准c头文件。 内核编程时必须使用GNU C 内核编程时缺乏像用户空间那样的内存保护机制。 内核编程时难以执行浮点运算。 内核给每个进程只有一个很小的定长堆栈。 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。 要考虑可移植性的重要性。 无libc库或无标准头文件因为对内核来说，C库太大太低效了。但是大部分常用的C库函数在内核中都已经得到了实现。内核头文件位于根目录include目录下。&lt; linux/inotify.h&gt;对应内核include/linux/inotify.h体系结构相关的头文件位于源码树arch/&lt; architecture&gt;/include/asm目录下。内核代码通过如&lt; asm/youwant.h&gt;包含。 printk(“Hello world’%s’and ‘%d’”,str,i); 例如内核代码无法调用printf,但它提供printk()。其允许通过一个标志来设置优先级。 GNU Cgcc是多种GNU编译器的集合，它包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其他代码。 内联函数，用于时间要求高，本身长度短的函数。 定义内联函数时需要static 作为关键字，并且用inline限定它。为了类型安全和易读性，优先使用内联函数而不是复杂的宏。 内联汇编，gcc支持C函数嵌入汇编指令，需要知道其体系结构。使用asm()指令嵌入汇编代码。Linux内核混用了C语言和汇编语言。在偏近体系结构底层或对执行时间要求严格的地方，一般使用汇编语言，其他大部分代码是用C语言编写的。 分支声明，对于条件选择语句，gcc内建了优化指令，并封装成了宏。likely()和unlikely()，你的判断正确，性能会得到提升，如果判断错误，性能反而会下降。 没有内存保护机制在内核中不应该去做访问非法的内存地址，引用空指针一类的事，否则可能一声不响的死掉。内核的内存不分页。 不要轻易在内核中使用浮点数内核并不能完美地支持浮点操作，因为它本身不能陷入。在内核使用浮点数时，除了要人工保存和恢复浮点寄存器，还有一些其他的事情要处理。所以不要在内核中使用浮点操作。 容积小而固定的栈同步和并发可移植性的重要性大部分C代码应该与体系结构无关，在不同体系结构的计算机上都能够编译和执行。如保持字节序、64位对齐、不假定字长和页面长度等一系列准则都有助于移植性。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[LINUX内核设计与实现]第一章","slug":"LINUX内核设","date":"2018-04-13T11:45:41.000Z","updated":"2018-05-16T11:04:46.000Z","comments":true,"path":"2018/04/13/LINUX内核设/","link":"","permalink":"https://github.com/zdkswd/2018/04/13/LINUX内核设/","excerpt":"","text":"第一章主要是讲Linux的历史，而我的第一篇纸质书笔记主要是讲一下我的计划。纸质书做读书笔记的话，任务量会远远大于电子版的图书，所以我争取做到不引用原文，因为那样做任务量过于庞大，这就要求我必须以自己理解的方式概括，这样才能达到预期的效果。之后还会出的纸质书笔记预告：深入理解计算机系统 中英两版。深入理解安卓系统。所以说可以看出直到暑假的这一段时间，我的重点是放在c/c++以及操作系统上，之所以这样做是因为希望未来能够为Tensorflow等开源框架贡献自己的力量。希望大家可以共同学习，共同进步。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[猴子都能懂的Git入门]高级篇","slug":"猴子都能懂的Git入门-高级篇","date":"2018-04-08T03:09:55.000Z","updated":"2018-05-16T10:59:22.000Z","comments":true,"path":"2018/04/08/猴子都能懂的Git入门-高级篇/","link":"","permalink":"https://github.com/zdkswd/2018/04/08/猴子都能懂的Git入门-高级篇/","excerpt":"","text":"分支什么是分支分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。 master分支在数据库进行最初的提交后, Git会创建一个名为master的分支。因此之后的提交，在切换分支之前都会添加到master分支里。 分支的运用merge分支Merge分支是为了可以随时发布release而创建的分支，它还能作为Topic分支的源分支使用。保持分支稳定的状态是很重要的。如果要进行更改，通常先创建Topic分支，而针对该分支，可以使用Jenkins之类的CI工具进行自动化编译以及测试。 通常，大家会将master分支当作Merge分支使用。 Topic分支Topic分支是为了开发新功能或修复Bug等任务而建立的分支。若要同时进行多个的任务，请创建多个的Topic分支。 Topic分支是从稳定的Merge分支创建的。完成作业后，要把Topic分支合并回Merge分支。 分支的切换若要切换作业的分支，就要进行checkout操作。进行checkout时，git会从工作树还原向目标分支提交的修改内容。checkout之后的提交记录将被追加到目标分支 HEADHEAD指向的是现在使用中的分支的最后一次更新。通常默认指向master分支的最后一次更新。通过移动HEAD，就可以变更使用的分支。NOTE:提交时使用~(tilde)和^(caret)就可以指定某个提交的相对位置。最常用的就是相对于HEAD的位置。HEAD后面加上~(tilde）可以指定HEAD之前的提交记录。合并分支会有多个根节点，您可以用^(caret) 来指定使用哪个为根节点。 stashstash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。 分支的合并合并分支有2种方法：使用merge或rebase。使用这2种方法，合并后分支的历史记录会有很大的差别。 merge合并 bugfix分支到master分支时，如果master分支的状态没有被更改过,把master分支的位置移动到bugfix的最新分支上，Git 就会合并。这样的合并被称为fast-forward（快进）合并。HEAD还在原位。master分支的历史记录有可能在bugfix分支分叉出去后有新的更新。这种情况下，要把master分支的修改内容和bugfix分支的修改内容汇合起来。合并两个修改会生成一个提交。这时，master分支的HEAD会移动到该提交上。NOTE:执行合并时，如果设定了non fast-forward选项，即使在能够fast-forward合并的情况下也会生成新的提交并合并。 一个圆圈代表一个提交 rebasetopic分支和merge分支的运用实例分支操作示例建立分支 $ git branch &lt; branchname&gt; 不指定参数直接执行branch命令的话，可以显示分支列表。 前面有*的就是现在的分支。 $ git branch issue1 *master 切换分支执行checkout命令以退出分支。 $ git checkout &lt; branch&gt; NOTE:在checkout命令指定 -b选项执行，可以创建分支并进行切换。 $ git checkout -b &lt; branch&gt; 合并分支执行merge命令以合并分支。 $ git merge &lt; commit&gt; 该命令将指定分支导入到HEAD指定的分支。如当HEAD指向issue1时，先切换到master分支，然后把issue1分支导入到master分支。 $ git checkout master$ git merge issue1 删除分支在branch命令指定-d选项执行，以删除分支。 $ git branch -d &lt; branchname&gt; 用rebase合并切换到issue3分支后，对master执行rebase。 $ git checkout issue3$ git rebase master rebase的时候，修改冲突后的提交不是使用commit命令，而是执行rebase命令指定 –continue选项。若要取消rebase，指定 –abort选项。 $ git add myfile.txt$ git rebase –continue 这样，在master分支的issue3分支就可以fast-forward合并了。切换到master分支后执行合并.看来rebase是将issue3分支消失而生成一个新的提交，就像fast-forward的情形一样。切换到master分支后执行合并。 $ git checkout master$ git merge issue3 上图为rebase图 上图为merge图 Merge和rebase都是合并历史记录，但是各自的特征不同。 merge保持修改内容的历史记录，但是历史记录会很复杂。rebase历史记录简单，是在原有提交的基础上将差异内容反映进去。因此，可能导致原本的提交内容无法正常运行。您可以根据开发团队的需要分别使用merge和rebase。例如，想简化历史记录，在topic分支中更新merge分支的最新代码，请使用rebase。向merge分支导入topic分支的话，先使用rebase，再使用merge。 远端数据库pull首先确认更新的本地数据库分支没有任何的更改。这时只执行fast-forward合并。如果本地数据库的分支有新的历史记录，就需要合并双方的修改。执行pull就可以进行合并。这时，如果没有冲突的修改，就会自动创建合并提交。如果发生冲突的话，要先解决冲突，再手动提交。 fetch执行pull，远程数据库的内容就会自动合并。但是，有时只是想确认本地数据库的内容而不想合并。这种情况下，请使用fetch。执行fetch就可以取得远程数据库的最新历史记录。取得的提交会导入到没有名字的分支，这个分支可以从名为FETCH_HEAD的退出。就相当于在本地数据库建立了一个和远程数据库一样的分支，还没合并。合并后，历史记录会和pull相同。实际上pull的内容是fetch + merge组成的。 push从本地数据库push到远程数据库时，要fast-forward合并push的分支。如果发生冲突，push会被拒绝的。若要共享在本地数据库创建的分支，需要明确的push。因此，没有执行push就不会给远程数据库带来影响，因而可以自由的创建自己的分支。基本上，远程数据库共享的提交是不能修改的。如果修改的话，跟远程数据库同步的其他数据库的历史记录会变得很奇怪的。 标签标签是为了更方便地参考提交而给它标上易懂的名称。Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。轻标签：添加名称注解标签：添加名称 添加注解 添加签名一般情况下，发布标签是采用注解标签来添加注解或签名的。轻标签是为了在本地暂时使用或一次性使用。 使用标签 使用tag命令来添加标签，在&lt; tagname&gt;执行标签的名称。 $ git tag &lt; tagname&gt; 在HEAD指向的提交里添加名为apple的标签，请执行以下的命令。 $ git tag apple 如果没有使用参数而执行tag，可以显示标签列表。 $ git tag 如果在log命令添加 –decorate选项执行，可以显示包含标签资料的历史记录。 $ git log –decorate 添加注解标签若要添加注解标签，可以在tag命令指定 -a选项执行,以指定-m选项来添加注解。 $ git tag -a &lt; tagname&gt; $ git tag -am “连猴子都懂的Git” banana 如果在tag命令指定-n选项执行，可以显示标签的列表和注解。 $ git tag -n 删除标签若要删除标签，在tag命令指定 -d选项执行。 $ git tag -d &lt; tagname&gt; 改写提交修改最近的提交指定amend选项执行提交的话，可以修改同一个分支最近的提交内容和注解。 主要使用的场合：添加最近提交时漏掉的档案修改最近提交的注解 取消过去的提交在revert可以取消指定的提交内容。使用后面要提到的rebase -i或reset也可以删除提交。但是，不能随便删除已经发布的提交，这时需要通过revert创建要否定的提交。 主要使用的场合：安全地取消过去发布的提交 遗弃提交在reset可以遗弃不再使用的提交。执行遗弃时，需要根据影响的范围而指定不同的模式，可以指定是否复原索引或工作树的内容。除了默认的mixed模式，还有soft和hard模式。欲了解受各模式影响的部分，请参照下面的表格。 模式名称 HEAD的位置 索引 工作树 soft 修改 不修改 不修改 mixed 修改 修改 不修改 hard 修改 修改 修改 主要使用的场合： 复原修改过的索引的状态(mixed)彻底取消最近的提交(hard)只取消提交(soft) 提取提交在cherry-pick，您可以从其他分支复制指定的提交，然后导入到现在的分支。 主要使用的场合： 把弄错分支的提交移动到正确的地方把其他分支的提交添加到现在的分支 改写提交历史记录在rebase指定i选项，您可以改写、替换、删除或合并提交。 主要使用的场合： 在push之前，重新输入正确的提交注解清楚地汇合内容含义相同的提交。添加最近提交时漏掉的档案 汇合分支上的提交，然后一同合并到分支merge的特殊选项：squash用这个选项指定分支的合并，就可以把所有汇合的提交添加到分支上。 主要使用的场合： 汇合主题分支的提交，然后合并提交到目标分支。 改写提交训练commit –amend git commit –amend revert $ git revert HEAD 在git log中会出现–Revert “添加pull的说明” reset $ git reset –hard HEAD~~ 在git中，我们其实可以通过^和~来定位某个具体的commit，而不用每次都去敲繁琐的hash值。“^”代表父提交,当一个提交有多个父提交时，可以通过在”^”后面跟上一个数字，表示第几个父提交，”^”相当于”^1”.~&lt; n&gt;相当于连续的&lt; n&gt;个”^”.在reset之前的提交可以参照ORIG_HEAD。Reset错误的时候，在ORIG_HEAD上reset 就可以还原到reset前的状态。 $ git reset –hard ORIG_HEAD cherry-pick $ git checkout master$ git cherry-pick 99daed2 如果发生冲突，修改冲突的部分之后再提交。 用rebase -i 汇合提交若要汇合过去的提交，请用rebase -i。 $ git rebase -i HEAD~~ 两个提交就合并成一个提交了。 用rebase -i 修改提交merge –squash","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"Git","slug":"Git","permalink":"https://github.com/zdkswd/tags/Git/"}]},{"title":"[猴子都能懂的Git入门]入门篇","slug":"猴子都能懂的Git入门-入门篇","date":"2018-04-06T02:03:47.000Z","updated":"2018-05-16T10:59:40.000Z","comments":true,"path":"2018/04/06/猴子都能懂的Git入门-入门篇/","link":"","permalink":"https://github.com/zdkswd/2018/04/06/猴子都能懂的Git入门-入门篇/","excerpt":"","text":"前言不知道这是第几次学习Git了，每次都是学完过一段就忘了，这次决定自己写出点东西，深入的再把Git再过一遍。写一下自己的东西，真真正正的把Git转化为自己的东西。这次选用的资料是猴子都能懂的Git入门。之所以选用该资料是因为语言比较通俗易懂，而我也正好想把知识总结的通俗易懂一些，算是两重学习。那么话不多说，现在开始吧~~~(写到后面发现这书已经足够通俗，很难再。。。啊，失败。) Git的基础首先git是版本控制工具，用来解决大家对同一文件操作时的协作问题。Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。 管理历史数据的数据库数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。 远程数据库和本地数据库。Git的数据库分为远程数据库和本地数据库的两种。 创建数据库创建本地数据库的方法有两种：一种是创建全新的数据库，另一种是复制远程数据库。 修改记录的提交若要把文件或目录的添加和变更保存到数据库，就需要进行提交。执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也被称为revision）。Tips:不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。执行提交时，系统会要求输入提交信息。请务必输入提交信息，因为在空白的状态下执行提交会失败的。Tips:查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。以下是Git的标准注解： 第1行：提交修改内容的摘要第2行：空行第3行以后：修改的理由 请以这种格式填写提交信息。 工作树和索引在Git管理下，大家实际操作的目录被称为工作树。 在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。 Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。 凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。 教程1 Git基础Git安装略 初期设定安装Git之后，请输入您的用户名和电子邮件地址。该设置操作在安装Git后进行一次就够了。这些信息将作为提交者信息显示在更新历史中。 Git的设定被存放在用户本地目录的.gitconfig档案里。可以直接编辑配置文件。 $ git config –global user.name “&lt;用户名&gt;”$ git config –global user.email “&lt;电子邮件&gt;” $ git config –global color.ui auto //git彩色显示 可以为Git命令设定别名。例如：把「checkout」缩略为「co」，然后就使用「co」来执行命令。 $ git config –global alias.co checkout 如果在Windows使用命令行 (Git Bash), 含非ASCII字符的文件名会显示为 “\\346\\226\\260\\350\\246…”。若设定如下，就可以让含非ASCII字符的文件名正确显示了。 $ git config –global core.quotepath off 若在Windows使用命令行，您只能输入ASCII字符。所以，如果您的提交信息包含非ASCII字符，请不要使用-m选项，而要用外部编辑器输入。 外部编辑器必须能与字符编码UTF-8和换行码LF兼容。 git config –global core.editor “\\”[使用编辑区的路径]\\”” 新建数据库在目录下使用init命令将该目录移动到本地的Git数据库。 $ git init 提交文件对于一个文件，使用status命令确认工作树和索引的状态。 $ git status 将文件加入到索引，要使用add命令。在&lt; file&gt;指定加入索引的文件。用空格分割可以指定多个文件。 $ git add &lt; file&gt;..$ git add . //将所有的文件加入索引 已加入到索引，我们就可以提交文件了。 $ git commit -m “” 使用log命令，我们可以在数据库的提交记录看到新的提交。 $ git log commit ac56e474afbbe1eab9ebce5b3ab48ac4c73ad60eAuthor: eguchi &#101;&#103;&#x75;&#99;&#104;&#105;&#x40;&#110;&#117;&#x6c;&#x61;&#x62;&#46;&#x63;&#x6f;&#x2e;&#x6a;&#x70;Date: Thu Jul 12 18:00:21 2012 +0900first commit 安装git的同时会安装名为gitk的工具。使用这个工具，可以在GUI下确认提交记录。 $ gitk 共享数据库push到远端数据库注意：对于别人的项目你只能 pull 不能 push，只有你自己（或有权限）的项目才能 push。或者说只有你把 ssk key 添加到账号里才能无密码 push。如果你想参与别人的开源项目，先建立自己的 github 账号，然后 fork 那个项目到自己的账号里，然后在自己的项目里修改，然后发出 pull request，然后看对方愿不愿意接受你的提交。 作者：Intopass链接：https://www.zhihu.com/question/29894004/answer/45956664来源：知乎 推送为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。所以远程数据库的修改记录就会和本地数据库的修改记录保持同步。 克隆远程数据库克隆执行克隆后，远程数据库的全部内容都会被下载。之后您在另一台机器的本地数据库上进行操作。克隆后的本地数据库的变更履历也会被复制，所以可以像原始的数据库一样进行查看记录或其他操作。 从远程服务器Pull若是共享的远程数据库由多人同时作业，那么作业完毕后所有人都要把修改推送到远程数据库。然后，自己的本地数据库也需要更新其他人推送的变更内容。 Pull进行拉取(Pull) 操作，就是从远程数据库下载最近的变更日志，并覆盖自己本地数据库的相关内容。 clone与pull的区别clone是本地没有repository时，将远程repository整个下载过来。 pull是本地有repository时，将远程repository里新的commit数据(如有的话)下载过来，并且与本地代码merge。 对远程服务器进行操作向远程数据库推送本地数据库的修改记录远程数据库命名为“origin”。 请使用remote指令添加远程数据库。在&lt; name&gt;处输入远程数据库名称，在&lt; url&gt;处指定远程数据库的URL。 $ git remote add &lt; name&gt; &lt; url&gt; TIPS:执行推送或者拉取的时候，如果省略了远程数据库的名称，则默认使用名为”origin“的远程数据库。因此一般都会把远程数据库命名为origin。 使用push命令向数据库推送更改内容。&lt; repository&gt;处输入目标地址，&lt; refspec&gt;处指定推送的分支。 $ git push &lt; repository&gt; &lt; refspec&gt;… 当执行命令时，如果您指定了-u选项，那么下一次推送时就可以省略分支名称了。但是，首次运行指令向空的远程数据库推送时，必须指定远程数据库名称和分支名称。 $ git push -u origin master 使用clone指令可以复制数据库，在&lt; repository&gt;指定远程数据库的URL，在&lt; directory&gt;指定新目录的名称。 $ git clone &lt; repository&gt; &lt; directory&gt;$ git clone https://nulab.backlog.jp/git/BLG/tutorial.git tutorial2 当在克隆的数据库目录执行推送时，您可以省略数据库和分支名称。 $ git push 使用pull指令进行拉取操作。省略数据库名称的话，会在名为origin的数据库进行pull。 $ git pull &lt; repository&gt; &lt; refspec&gt;…$ git pull origin master 合并修改记录合并在执行pull之后，进行下一次push之前，如果其他人进行了推送内容到远程数据库的话，那么你的push将被拒绝。这种情况下，在读取别人push的变更并进行合并操作之前，你的push都将被拒绝。这是因为，如果不进行合并就试图覆盖已有的变更记录的话，其他人push的变更（图中的提交C）就会丢失。 合并的时候，Git会自动合并已有的变更点！不过，也存在不能自动合并的情况。此时需要手动合并。 解决冲突如果远程数据库和本地数据库的同一个地方都发生了修改的情况下，因为无法自动判断要选用哪一个修改，所以就会发生冲突。Git会在发生冲突的地方修改文件的内容 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;这就是发生 》 =======冲突的地方 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ==分割线上方是本地数据库的内容,下方是远程数据库的编辑内容。需要手动的修改。 整合修改记录操作为了把变更内容推送到远程数据库，我们必须手动解决冲突。 $ git pull origin master 导入两方的修改，并删除多余的标示行以解决冲突 Github多人协作的三种方式 Fork 方式pull request是一个request，它的目的是让别人pull你的东西。 组织组织的所有者可以针对不同的代码仓库建立不同访问权限的团队。 合作者代码仓库的所有者可以为单个仓库增加具备只读或者读写权限的协作者。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"Git","slug":"Git","permalink":"https://github.com/zdkswd/tags/Git/"}]},{"title":"新增评论区功能","slug":"新增评论区功能","date":"2018-04-05T09:49:48.000Z","updated":"2018-05-16T11:02:14.000Z","comments":true,"path":"2018/04/05/新增评论区功能/","link":"","permalink":"https://github.com/zdkswd/2018/04/05/新增评论区功能/","excerpt":"","text":"今天算是折腾了一下评论区，不得不佩服评论区作者的脑洞。运用github issues的机制来自己创建评论区，运用插件—传送门。 在此过程中也算踩了一些坑，特别感谢有人能无私分享自己的踩坑经历–踩坑教程 我自己也顺便试着改了下模板的源码，感觉有、收获。 分享出去，如果可以帮助到更多的人，那将将是更大的快乐。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://github.com/zdkswd/tags/个人博客/"},{"name":"Gitment","slug":"Gitment","permalink":"https://github.com/zdkswd/tags/Gitment/"}]},{"title":"Hexo+ github Pages建立个人博客","slug":"Hexo+github-Pages建立个人博客","date":"2018-04-04T09:30:56.000Z","updated":"2018-05-16T11:03:32.000Z","comments":true,"path":"2018/04/04/Hexo+github-Pages建立个人博客/","link":"","permalink":"https://github.com/zdkswd/2018/04/04/Hexo+github-Pages建立个人博客/","excerpt":"","text":"折腾了一段时间，还算顺利的把博客给建立好了，以下是参考链接建立过程这个过程大体上是没有问题的，但是我碰到几个小小的问题，大家也可以参考一下 当打开配置文件时，文中说的是用记事本打开，但是我用记事本打开文本完全没有格式，再用写字板打开时，豁然开朗。 再一个就是当上传以后访问自己的首页时,输入https://zdkswd.github.io 死活打不开，我又检查了好几遍，后来直接输入zdkswd.github.io就成功进去了，之后再输入https://zdkswd.github.io 又可以愉快的访问了，感觉特别神奇，也感觉很费解。 第一篇博客就先到这里吧，这一段时间我会上传一些读书笔记，毕竟砖头书不好啃，这既是分享，又是进一步的学习，也是对我自己的一种激励。希望这个博客真正能起到学习，练习，积累，分享的作用。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://github.com/zdkswd/tags/个人博客/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/zdkswd/tags/Hexo/"}]}]}