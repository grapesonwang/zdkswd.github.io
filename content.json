{"meta":{"title":"ZDK's blog","subtitle":null,"description":null,"author":"ZDK","url":"https://github.com/zdkswd"},"pages":[{"title":"categories","date":"2018-05-16T08:57:06.000Z","updated":"2018-05-16T08:58:10.000Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/zdkswd/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-16T07:23:52.000Z","updated":"2018-05-16T08:58:32.000Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/zdkswd/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"机器学习数学基础下","slug":"机器学习数学基础下","date":"2018-10-17T12:31:47.000Z","updated":"2018-10-17T12:34:13.000Z","comments":true,"path":"2018/10/17/机器学习数学基础下/","link":"","permalink":"https://github.com/zdkswd/2018/10/17/机器学习数学基础下/","excerpt":"","text":"线性代数进阶 矩阵变换 矩阵的标准型：相似变换（把矩阵看做线性映射） 矩阵的标准型：相合变换（二次型） 主成分分析（PCA）PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。 选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。 如图中如果想要将二维转化为一维，若想少丢失信息，则应将投影尽可能的分散。而这种分散程度，可以用数学上的方差来表述。 于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。 考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。数学上可以用两个字段的协方差表示其相关性。 至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。 上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。 根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。 最后需要说明的是，PCA是一种无参数技术，也就是说面对同样的数据，如果不考虑清洗，谁来做结果都一样，没有主观参数的介入，所以PCA便于通用实现，但是本身无法个性化的优化。 （奇异值分解）SVD SVD与PCA我们讲到要用PCA降维，需要找到样本协方差矩阵的最大的k个特征向量，然后用这最大的k个特征向量张成的矩阵来做低维投影降维。 SVD也可以得到协方差矩阵最大的k个特征向量张成的矩阵。 就是说，PCA算法可以不用做特征分解，而是做SVD来完成。 凸优化 对于目标函数，我们限定是凸函数；对于优化变量的可行域（注意，还要包括目标函数定义域的约束），我们限定它是凸集。同时满足这两个限制条件的最优化问题称为凸优化问题，这类问题有一个非常好性质，那就是局部最优解一定是全局最优解。 凸集： a,x都是向量，b是常数。 简单来说仿射变换就是线性变换加平移。线性变化中原点还在原点，但仿射变换后，原点就移动了。 如何通俗地讲解「仿射变换」这个概念？ - 马同学的回答 - 知乎https://www.zhihu.com/question/20666664/answer/157400568 将前z维每一项都除以最后一维t,将最后一项t舍弃。 琴生不等式： 上确界（Supremum）：一个集合的最小上界， 数学符号sups下确界（greatest lower boundinf）：一个集合的最大下界,数学符号inf上确界与最大值：上确界类似于最大值，但是和最大值不同的是，最大值有时候会遇到无法取到的情况。比如x∈R,x&lt;2这样的情况下就不存在一个确定的最大值。但是可以确定上确界为2。 打扰了，还是要新开一个凸优化的专题来看了。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/zdkswd/tags/数学/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"3Blue1Brown线性代数","slug":"3Blue1Brown线性代数","date":"2018-10-15T10:05:32.000Z","updated":"2018-10-15T10:10:16.000Z","comments":true,"path":"2018/10/15/3Blue1Brown线性代数/","link":"","permalink":"https://github.com/zdkswd/2018/10/15/3Blue1Brown线性代数/","excerpt":"","text":"向量究竟是什么在数学中向量以原点为起点，在空间中是一个有向的箭头，每一个位置上的数值代表在对应轴上的数值。为了与点区分，所以向量竖着写。 向量的加法 向量的乘法 线性代数围绕两种基本运算：向量加法与向量数乘。 线性组合、张成的空间与基 基向量。 当我们用数字描述向量时，都依赖于我们所选择的基。 在二维空间中，如果v,w不共线且不为零向量，那么理论上av+bw就可以表示二维空间中所有的向量。 为什么叫线性组合，如果固定其中一个向量那么只能表示部分向量，这些向量的末端构成一条直线。 两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么。 向量VS点：可以用点来代替一个起点为原点，终点在该点上的一个向量。 三维向量： 三个向量的线性组合的张成空间同理。 线性相关：一个向量在其他向量线性组合的张成空间中，即这个向量没有提高所有向量组成的张成空间的维度。 线性无关：每一个向量都起到了提高张成空间维度的作用。 矩阵与线性变换变换只不过是函数的一种花哨说法，它接收输入内容，并输出对应结果。在线性代数中考虑的是向量输入，输出一个向量。那为什么不用函数这个词呢？变换这个词在暗示用运动去思考。 如果一个变换有以下两条性质，我们就称它是线性的：一是直线在变换后仍然保持为直线，不能有所弯曲。二是原点保持固定。 如上不是线性变换。 如上为线性变换 变换后的坐标。 由于线性变换后对于基向量的线性组合的值不变，所以只需要知道基向量的变换就可以算出变换后的任意向量的坐标。 变换后的i,j。一个在标准网格的坐标系中的一个向量(x,y) 一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标（标准网格下的坐标）。 矩阵在这里只是一个记号，它含有描述一个线性变换的信息。 矩阵乘法与线性变换复合两个独立变换可以进行复合变换 先旋转再剪切。 两个矩阵相乘有着几何意义，也就是两个线性变换相继作用 之所以能这么做是因为它们都在同一个坐标系下，即标准网格坐标系。 三维空间中的线性变换同理。 行列式 描述一个线性变换是让面积（对二维来说是面积，三维就是体积）拉伸还是挤压了。 也就是说如果一个行列式为0，那就是变换后成了一条线（对二维俩说）。推广就是计算一个矩阵的行列式，我们就能了解这个矩阵代表的变换是否将空间压缩到更小的维度上。 当空间定向改变的情况发生时，原本j在i的左侧，现在j在i的右侧了，行列式为负。 逆矩阵、列空间与零空间 逆矩阵就是逆变换。只要变换不讲空间压缩到更低维度，就有逆变换。 即使压缩到更低的维度，解依然有可能存在，当x恰好在直线上时，解就存在。 列空间就是矩阵的列所张成的空间。秩的更精确的定义是列空间的维数。满秩是指输入空间的维度等于矩阵的秩。对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身。对于非满秩的变换，将维度压缩到更低的维度，也就是说会有一系列的向量会压缩到原点。在变换后落在原点的向量集合，被称为所选矩阵的零空间或核。 非方阵 几何意义是将二维空间映射到三维空间上。矩阵有两列表明输入空间有两个基向量，三维是表明变换到了三维空间坐标系中，张成空间为三维空间的一个过原点的二维平面，矩阵依然是满秩的，因为列空间的维数与输入空间的维数相等。 点积与对偶性 这里可以看做是二维空间压缩到一维的数轴上，由于变换是线性的，所以可以用一个1*2的矩阵来表示变换。 叉乘的标准介绍 顺序不同，正负不同。 这里才是真正的叉乘： 方向右手定则。 以线性变换的眼光看叉乘为什么上述的式子中要用到ijk?下面就来解释。 真正的三维向量的叉乘接收两个向量并输出一个向量。 这个函数的几何意义在于，对于任一输入的向量（x,y,z),你都考虑它和v,w确定的平行六面体得到它的体积，然后根据取向确定符号。这个函数是线性的。 一旦知道它是线性的，就可以知道可以通过矩阵乘法来描述这个函数。具体地说，因为这个函数从三维空间到一维空间，就会存在一个1*3矩阵来代表这个变换。根据对偶性，从多维空间到一维空间的变换的特别之处在于可以将整个变换看做与这个特定向量的点积。 我们要找的就是P，使得p与其他任意向量（x,y,z）的点积等于一个3* 3矩阵的行列式。 从算数角度上来说p就是 （。。。。）i+（。。。。）j+（。。。。）k 从几何的角度： 左边式子，向量p与其他向量的点积的几何解释，是将其他向量投影到p上。 右面式子是(x,y,z)的垂直分量*底部面积。和垂直于v,w且长度等于平行四边形面积的向量与（x,y,z）点乘一样。所以p垂直v,w且长度为平行四边形的面积。 所以 基变换线性变换中一个坐标系中的所有向量都跟着动，变换后的向量仍旧是相同的线性组合，不过使用的是新的基向量。基变换中，一个向量是不动的，动的是坐标系。 詹的坐标系： 一个我们坐标系中的向量： 詹系中对它的描述： 詹的基在我们系中的向量坐标： 詹的基自己的坐标： 不同的坐标系（基）对于空间内同一个向量的描述是不同的，也就是描述的语言不同。 不同的基的坐标原点是重合的。如何在不同的坐标系之间进行转化： 式1 就是将（-1，2）进行线性变换后，可以变为黄色的向量。 可以把这个式子看作是我们把我们对詹的误解（詹的坐标系下的数值直接拿到标准网格坐标系里）转化为真实的詹的所指，都是在标准网格坐标系下。 同理，如果取逆。 这时可以求在标准网格坐标系中的某点，在詹坐标系下的值。可在式一两侧左边同时乘以逆来很好的推出。 如果想要旋转90度，詹的基该如何表示？ 开始是一个詹下的向量： 我们转为我们的语言，在标准网格下的一个向量。 此时再进行旋转操作。 最后左乘一个逆矩阵，将其转换为詹的语言。 这就是詹的语言下旋转的操作。 特征向量与特征值在线性变换中，有的向量并不改变方向，只是拉伸或者缩小。 、 这些向量就叫特征向量，每个特征向量都有一个所属的值，拉伸倍数叫做特征值。 如果在三维变化中找到这个特征向量，那它就是旋转轴 抽象空间本质向量是什么？ 从某种意义上来说函数也是向量。 x,y,z是三个点的纵坐标。 同时也存在另一个函数转换为另一个函数的操作（对应线性变化），例如求导。 可见函数是线性的。 抽象性带来的好处是我们能得到一般性的结论。 所以，什么是向量？数学中有许多类似向量的事物，只要你处理的对象集具有合理的数乘和相加概念，线性代数中所有关于向量、线性变换和其他等产生的概念都应该适用于它。 这些类似向量的事物，比如箭头、一组数、函数等，它们构成的集合被称为“向量空间”。 如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足八条公理。这些公理是一个接口，一边连着应用线代的人，另一边是数学家。 只要满足八条公理，就可以将线代应用到你的研究对象上，而数学家则是根据这些公理证明了你的结论。 向量可以是任何东西，只要它满足公理。回答向量是什么，就像回答3是什么一样。 普适的代价是抽象。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/zdkswd/tags/数学/"}]},{"title":"机器学习数学基础上","slug":"机器学习数学基础上","date":"2018-10-13T11:08:47.000Z","updated":"2018-10-13T07:41:43.000Z","comments":true,"path":"2018/10/13/机器学习数学基础上/","link":"","permalink":"https://github.com/zdkswd/2018/10/13/机器学习数学基础上/","excerpt":"","text":"机器学习基础见李宏毅第0课。 得分函数 权重需要训练得到。 损失函数最优化 左边是非凸函数，右边是凸函数。通过优化损失函数来调整权值。 凸函数琴生不等式 微积分基础 梯度是一个点上升最快的方向。梯度下降法。 极限通俗语言适合于说给对方听，数学记号适合于写给对方看，精确描述比较啰嗦但是非常精确不会造成误解，主要用于证明。不会出错。 无穷小的阶数。 微分学 求导用链式法则。 积分学 泰勒级数。 牛顿法与梯度下降法 为什么不用牛顿法：原因一：牛顿法需要用到梯度和Hessian矩阵，这两个都难以求解。因为很难写出深度神经网络拟合函数的表达式，遑论直接得到其梯度表达式，更不要说得到基于梯度的Hessian矩阵了。原因二：即使可以得到梯度和Hessian矩阵，当输入向量的维度NNN较大时，Hessian矩阵的大小是N×NN×NN\\times N，所需要的内存非常大。原因三：在高维非凸优化问题中，鞍点相对于局部最小值的数量非常多，而且鞍点处的损失值相对于局部最小值处也比较大。而二阶优化算法是寻找梯度为0的点，所以很容易陷入鞍点。 为什么研究凸函数，凸优化？ 概率与统计基础 统计问题是概率问题的逆向工程。概率问题是已知总体的情况，求一次的概率。统计问题则是根据样本的情况反推总体的情况。 概率统计与机器学习的关系概率统计与机器学习天然相关，训练的过程可以看做是统计过程，预测过程可以看做是概率过程。预测分类就是选择一个概率最大的分类。 可以观察各个特征的分布以及标签的分布，筛选出相关性强的特征。 可基于各个分布的特性来评估模型和样本。 统计估计的是分布，机器学习训练出来的是模型，模型可能包含了很多的分布。 训练与预测过程的一个核心评价指标就是模型的误差 误差本身就可以使概率形式，与概率紧密相关。 对误差的不同定义方式就演化成了不同损失函数的定义方式。 机器学习是概率与统计的进阶版本。（不严谨的说法） 方差 协方差 可评估两个分布之间的关系。定义公式几何意义：协方差可以理解成特征进行预处理之后（去均值化，机器学习里比较重要的一个数据预处理的方法）对应的向量的几何的内积。协方差是评价两个变量的线性关系。如果是非线性关系，评价不出来。 相关系数是研究变量之间线性相关程度地量。 var是方差。 概率论 先验——根据若干年的统计（经验）或者气候（常识），某地方下雨（因）的概率； 似然/类条件概率——在下雨（因）的情况下，观测到了乌云（果）的概率，即原因已知时，结果出现的概率； 后验——根据天上有乌云（果），得到的下雨（因）的概率，即给定结果估计原因的概率； x:观察得到的结果。 θ：决定数据分布的原因。 矩： 其中t是一个实数，i是虚数单位，E表示期望值。此乃原点矩。E(（X-0）^n)中心矩就是-μ。 即大部分都分布在均值周围。 没法研究随机变量就研究其特征函数。 当一个分布不是常见的分布时，根据大数定理，反复做实验就可以得到其期望和方差。 大数定理是告诉我们趋近一个数，中心极限定理是告诉我们以何种方式趋近一个数。一个正态分布。 参数估计（统计学） 点估计利用样本来估计总体分布，总体分布的参数很多情况下是未知的。如均值μ、方差\\sigma ^{2} 、泊松分布的λ、二项分布的比例π，其它分布还会有更多的未知参数，需要通过样本进行相应的估计，这种估计值就是点估计。 矩估计 极大似然估计 可以把概率密度看作是θ和x的联合概率密度，把x固定，那么概率密度最大的地方就是θ最可能的地方。 不是概率是因为相加起来和不等于1，类似于概率是因为数值大小是有意义的，代表了可能性的大小。 点估计的评判准则 区间估计对于未知参数，点估计值只是一个近似值，会存在或大或小误差，这时给一个范围可能是更合适，也是更可信的。比如从北京到张家界旅游5天，你恐怕不能准确说出要花多少钱，但你可以给出一个范围，比如10000—13000，你会觉得比较可信。如果给的范围太大，比如10000—30000，虽然可信度更高一些，但这么大的范围参考意义不大；如果给的范围很小，如10000——10500，则准确性提高了，但可信度就似乎不会很高。找到一个合适的估值范围，这是置信区间要解决的问题。 线性代数基础 （1）保持加法（2）保持乘法。线性映射是最简单的研究对象，用线性映射去逼近别的东西。 线性变换与矩阵的关系，对任何向量x进行线性变换T的结果向量，是一个对基向量组进行线性变换T之后的新向量组的一个线性组合，系数没变。 只需要知道两个基向量i向量和j向量转换之后的的结果，而不用知道转换本身，我们就能推导出二维空间中所有向量转换之后的结果。 Ax的几何意义矩阵乘向量，列向量的线性组合。 svd的几何意义。一个很重要的降维算法。 矩阵乘法在计算中的优势 将很多for循环写成矩阵或者向量乘法的方式。 矩阵计算模块在底层有优化。 numpy进行矩阵运算很快。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/zdkswd/tags/数学/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment","slug":"JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment","date":"2018-10-12T13:13:56.000Z","updated":"2018-10-12T13:13:15.000Z","comments":true,"path":"2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/","link":"","permalink":"https://github.com/zdkswd/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/","excerpt":"","text":"属性的操作HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。 属性本身是一个对象（Attr对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（HTMlElement对象）来操作属性。本章介绍如何操作这些属性。 Element.attributes属性元素对象有一个attributes属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有attributes属性，但返回的都是null，因此可以把这个属性视为元素对象独有的。 单个属性可以通过序号引用，也可以通过属性名引用。 返回的都是属性节点对象，而不是属性值。属性节点对象有name和value属性，对应该属性的属性名和属性值，等同于nodeName属性和nodeValue属性。 元素的标准属性HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。 这些属性都是可写的。这种修改属性的方法，常常用于添加表单的属性。 上面代码为表单添加提交网址和提交方法。 注意，这种用法虽然可以读写属性，但是无法删除属性，delete运算符在这里不会生效。 HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如onClick。 有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名。主要是以下两个。 属性操作的标准方法概述元素节点提供四个方法，用来操作属性。 适用性 这四个方法对所有的属性（包括用户自定义的属性）都适用。 返回值 getAttribute()只返回字符串，不会返回其他类型的值。 属性名 这些方法只接受属性的标准名称，不用改写保留字，比如for和class都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。 Element.getAttribute()lement.getAttribute方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。 Element.setAttribute()Element.setAttribute方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。 Element.hasAttribute()Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否包含指定属性。 Element.removeAttribute()Element.removeAttribute方法用于从当前元素节点移除属性。 dataset 属性有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。使用标准提供的data-*属性。 然后，使用元素节点对象的dataset属性，它指向一个对象，可以用来操作 HTML 元素标签的data-*属性。 通过dataset.foo读写data-foo属性。删除一个data-*属性，可以直接使用delete命令。 除了dataset属性，也可以用getAttribute(‘data-foo’)、removeAttribute(‘data-foo’)、setAttribute(‘data-foo’)、hasAttribute(‘data-foo’)等方法操作data-*属性。 Text节点和DocumentFragment节点Text节点的概念文本节点（Text）代表元素节点（Element）和属性节点（Attribute）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。 通常我们使用父节点的firstChild、nextSibling等属性获取文本节点，或者使用Document节点的createTextNode方法创造一个文本节点。 浏览器原生提供一个Text构造函数。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。 文本节点继承了Node接口，所以属性和方法都和Node一样。 Text节点的属性datadata属性等同于nodeValue属性，用来设置或读取文本节点的内容。 wholeTextwholeText属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，wholeText属性的返回值，与data属性和textContent属性相同。 lengthlength属性返回当前文本节点的文本长度。 nextElementSibling，previousElementSiblingnextElementSibling属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回null。 previousElementSibling属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回null：。 Text节点的方法appendData()，deleteData()，insertData()，replaceData()，subStringData() remove()remove方法用于移除当前Text节点。 splitText()splitText方法将Text节点一分为二，变成两个毗邻的Text节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。 分割后，该方法返回分割位置后方的字符串，而原Text节点变成只包含分割位置前方的字符串。 父元素的normalize方法可以实现逆操作，将它们合并。 DocumentFragment节点DocumentFragment节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，parentNode返回null，但是可以插入任意数量的子节点。它不属于当前文档，操作DocumentFragment节点，要比直接操作 DOM 树快得多。 它一般用于构建一个 DOM 结构，然后插入当前文档。document.createDocumentFragment方法，以及浏览器原生的DocumentFragment构造函数，可以创建一个空的DocumentFragment节点。然后再使用其他 DOM 方法，向其添加子节点。 上面代码创建了一个DocumentFragment节点，然后将一个li节点添加在它里面，最后将DocumentFragment节点移动到原文档。 注意，DocumentFragment节点本身不能被插入当前文档。当它作为appendChild()、insertBefore()、replaceChild()等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦DocumentFragment节点被添加进当前文档，它自身就变成了空节点（textContent属性为空字符串），可以被再次使用。如果想要保存DocumentFragment节点的内容，可以使用cloneNode方法。 上面这样添加DocumentFragment节点进入当前文档，不会清空DocumentFragment节点。 DocumentFragment节点对象没有自己的属性和方法，全部继承自Node节点和ParentNode接口。也就是说，DocumentFragment节点比Node节点多出以下四个属性。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"关于JavaScript的对象的理解","slug":"关于JavaScript的对象的理解","date":"2018-10-11T11:26:32.000Z","updated":"2018-10-11T11:26:54.000Z","comments":true,"path":"2018/10/11/关于JavaScript的对象的理解/","link":"","permalink":"https://github.com/zdkswd/2018/10/11/关于JavaScript的对象的理解/","excerpt":"","text":"关于JavaScript的对象的理解JavaScript的对象可以分为狭义的和广义的对象。广义的对象由数组，狭义的对象和函数组成。 狭义的对象就是{}，里面是键值对。广义的对象其实本质也是键值对。只不过声明的方式多了一些。比如new Object()。Object就是一个构造函数，既然是函数，本身也就是一个对象，可以对Object中添加方法，和狭义对象的方法一样。比如Object.test=Function (){};这时候在外部可以调用Object.test()方法，即Object对象的静态方法。 这里Object是构造函数名，但是函数也是对象啊，我估计函数本质上也是一个键值对，函数可以是构造函数Function.prototype的实例对象。所以称为Object对象。 既然是构造函数，里面是有语句的，执行完语句得到一个键值对，这又是一个对象，称为Object.prototype。这时就是一个纯粹的键值对。就是原型对象。Object.prototype也有很多方法可以调用。至于原型链，就是对象与对象之间的一条链。对象都是构造函数.prototype。继承是通过构造函数的继承来实现的，一般就是在子类中要实现父类的方法。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"JavaScript标准参考教程 DOM模型 实际使用DOM Element节点","slug":"JavaScript标准参考教程 DOM模型 实际使用DOM Element节点","date":"2018-10-09T11:42:56.000Z","updated":"2018-10-09T13:19:32.000Z","comments":true,"path":"2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/","link":"","permalink":"https://github.com/zdkswd/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/","excerpt":"","text":"实战中的使用DOM 如果加了括号就会直接执行了。 Element对象Element对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。 元素节点的nodeType属性都是1。 Element对象继承了Node接口，因此Node的属性和方法在Element对象都存在。此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如&lt; a&gt;元素的节点对象由HTMLAnchorElement构造函数生成，&lt; button&gt;元素的节点对象由HTMLButtonElement构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承Element的属性和方法，还有各自构造函数的属性和方法。 实例属性元素特性的相关属性Element.idElement.id属性返回指定元素的id属性，该属性可读写。 id属性的值是大小写敏感。 Element.tagNameElement.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。 Element.dirElement.dir属性用于读写当前元素的文字方向，可能是从左到右（”ltr”），也可能是从右到左（”rtl”）。 Element.accessKeyElement.accessKey属性用于读写分配给当前元素的快捷键。 上面代码中，btn元素的快捷键是h，按下Alt + h就能将焦点转移到它上面。 Element.draggableElement.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。 Element.langElement.lang属性返回当前元素的语言设置。该属性可读写。 Element.tabIndexElement.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。 abIndex属性值如果是负值（通常是-1），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的tabIndex属性的正整数值相同，则按照出现的顺序遍历。遍历完所有tabIndex为正整数的元素以后，再遍历所有tabIndex等于0、或者属性值是非法值、或者没有tabIndex属性的元素，顺序为它们在网页中出现的顺序。 Element.titleElement.title属性用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。 元素状态的相关属性Element.hiddenElement.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。 注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，Element.hidden并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。 CSS 的设置高于Element.hidden。如果 CSS 指定了该元素不可见（display: none）或可见（display: hidden），那么Element.hidden并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。 Element.contentEditable，Element.isContentEditableHTML 元素可以设置contentEditable属性，使得元素的内容可以编辑。 Element.contentEditable属性返回一个字符串，表示是否设置了contenteditable属性，有三种可能的值。该属性可写。 Element.isContentEditable属性返回一个布尔值，同样表示是否设置了contenteditable属性。该属性只读。 Element.attributesElement.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。 Element.className，Element.classListclassName属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割 classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。 classList对象有下列方法。 toggle方法可以接受一个布尔值，作为第二个参数。如果为true，则添加该属性；如果为false，则去除该属性。 Element.dataset网页元素可以自定义data-属性，用来添加数据。 Element.dataset属性返回一个对象，可以从这个对象读写data-属性。 注意，dataset上面的各个属性返回都是字符串。 HTML 代码中，data-属性的属性名，只能包含英文字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_）。它们转成 JavaScript 对应的dataset属性名，规则如下。 因此，data-abc-def对应dataset.abcDef，data-abc-1对应dataset[“abc-1”]。 除了使用dataset读写data-属性，也可以使用Element.getAttribute()和Element.setAttribute()，通过完整的属性名读写这些属性。 Element.innerHTMLElement.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括和元素。 如果将innerHTML属性设为空，等于删除所有它包含的所有节点。 注意，读取属性值的时候，如果文本节点包含 \\&amp;、小于号（ &lt;）和大于号（ &gt;），innerHTML属性会将它们转为实体形式 \\&amp; amp;、\\&amp; lt;、\\&amp; gt;。如果想得到原文，建议使用element.textContent属性。 注意，如果文本之中含有&lt; script&gt;标签，虽然可以生成script节点，但是插入的代码不会执行。 为了安全考虑，如果插入的是文本，最好用textContent属性代替innerHTML。 Element.outerHTMLElement.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。 outerHTML属性是可读写的，对它进行赋值，等于替换掉当前元素。 注意，如果一个节点没有父节点，设置outerHTML属性会报错。 Element.clientHeight，Element.clientWidthElement.clientHeight属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度。 除了元素本身的高度，它还包括padding部分，但是不包括border、margin。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。 Element.clientWidth属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。 document.documentElement的clientHeight属性，返回当前视口的高度（即浏览器窗口的高度），等同于window.innerHeight属性减去水平滚动条的高度（如果有的话）。document.body的高度则是网页的实际高度。一般来说，document.body.clientHeight大于document.documentElement.clientHeight。 Element.clientLeft，Element.clientTopElement.clientLeft属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的padding和margin。如果没有设置左边框，或者是行内元素（display: inline），该属性返回0。该属性总是返回整数值，如果是小数，会四舍五入。 Element.clientTop属性等于网页元素顶部边框的宽度（单位像素），其他特点都与clientTop相同。 Element.scrollHeight，Element.scrollWidthElement.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。 Element.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读。 整张网页的总高度可以从document.documentElement或document.body上读取。 注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，scrollHeight属性仍然返回元素的总高度。 Element.scrollLeft，Element.scrollTopElement.scrollLeft属性表示当前元素的水平滚动条向右侧滚动的像素数量，Element.scrollTop属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。 如果要查看整张网页的水平的和垂直的滚动距离，要从document.documentElement元素上读取。 这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。 Element.offsetParentElement.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。 该属性主要用于确定子元素位置偏移的计算基准，Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。 如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），则offsetParent属性返回null。 如果某个元素的所有上层节点的position属性都是static，则Element.offsetParent属性指向元素。 Element.offsetHeight，Element.offsetWidthElement.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。 Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。 这两个属性都是只读属性，只比Element.clientHeight和Element.clientWidth多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如display: none;），则返回0。 Element.offsetLeft，Element.offsetTopElement.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移 Element.style每个元素节点都有style用来读写该元素的行内样式信息。 Element.children，Element.childElementCountElement.children属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。 这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。 Element.childElementCount属性返回当前元素节点包含的子元素节点的个数，与Element.children.length的值相同。 Element.firstElementChild，Element.lastElementChildElement.firstElementChild属性返回当前元素的第一个元素子节点，Element.lastElementChild返回最后一个元素子节点。 如果没有元素子节点，这两个属性返回null。 Element.nextElementSibling，Element.previousElementSiblingElement.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回null。 Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回null。 实例方法属性相关方法Element.getAttribute()Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。 Element.getAttributeNames()Element.getAttributeNames()返回一个数组，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用Element.attributes属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。 Element.setAttribute()Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。 属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值true就会变成字符串true。 Element.hasAttribute()Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否有指定的属性。 Element.hasAttributes()Element.hasAttributes方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回false，否则返回true。 Element.removeAttribute()Element.removeAttribute方法移除指定属性。该方法没有返回值。 Element.querySelector()Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回null。 注意，这个方法无法选中伪元素。 它可以接受多个选择器，它们之间使用逗号分隔。 Element.querySelectorAll()Element.querySelectorAll方法接受 CSS 选择器作为参数，返回一个NodeList实例，包含所有匹配的子元素。 该方法的执行机制与querySelector方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。 它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的NodeList实例。 Element.getElementsByClassName()Element.getElementsByClassName方法返回一个HTMLCollection实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。 注意，该方法的参数大小写敏感。 由于HTMLCollection实例是一个活的集合，document对象的任何变化会立刻反应到实例。 上面代码中，matches集合的第一个成员，一旦被拿掉 class 里面的foo，就会立刻从matches里面消失，导致出现上面的结果。 Element.getElementsByTagName()Element.getElementsByTagName方法返回一个HTMLCollection实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。 注意，该方法的参数是大小写不敏感的。 Element.closest()Element.closest方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回null。 Element.matches()Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。 事件相关方法以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口， Element.scrollIntoView()Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。 该方法可以接受一个布尔值作为参数。如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为true。 Element.getBoundingClientRect()Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。 只读。 注意，getBoundingClientRect方法的所有属性，都把边框（border属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，width和height包括了元素本身 + padding + border。 Element.getClientRects()Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的Rect用的是复数）。每个矩形都有bottom、height、left、right、top和width六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。 对于盒状元素（比如&lt; div&gt;和&lt; p&gt;），该方法返回的对象中只有该元素一个成员。对于行内元素（比如&lt; span&gt;、&lt; a&gt;、&lt; em&gt;），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和Element.getBoundingClientRect()方法的主要区别，后者对于行内元素总是返回一个矩形。 Element.insertAdjacentElement()Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回null。 Element.insertAdjacentElement方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。 注意，beforebegin和afterend这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。 Element.insertAdjacentHTML()，Element.insertAdjacentText()Element.insertAdjacentHTML方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。 该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。 该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比innerHTML方法快得多。 注意，该方法会使 HTML 字符串显示为网页结构，这导致它不能用来插入用户输入的内容，否则会有安全风险。 Element.focus()，Element.blur()Element.focus方法用于将当前页面的焦点，转移到指定元素上。 该方法可以接受一个对象作为参数。参数对象的preventScroll属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。 Element.blur方法用于将焦点从当前元素移除。 Element.click()Element.click方法用于在当前元素上模拟一次鼠标点击，相当于触发了click事件。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"html+css","slug":"html+css","date":"2018-10-06T13:31:32.000Z","updated":"2018-10-11T07:21:09.000Z","comments":true,"path":"2018/10/06/html+css/","link":"","permalink":"https://github.com/zdkswd/2018/10/06/html+css/","excerpt":"","text":"html+csschrome市场份额多。 常见浏览器内核介绍：浏览器内核又可以分成两个部分：渲染引擎（layout engineer或者Rendering Engine）和JS引擎。 渲染引擎它负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入Css等),以及计算网页的显示方式,然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同,所以渲染的效果也不相同。 JS引擎则是解析Javascript语言,执行 Javascript语言来实现网页的动态效果。 最开始渲染引擎和J5引擎并没有区分的很明确,后来]S引擎越来越独立,内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了个ACID来测试引擎的兼容性和性能。内核的种类很多,如加上没什么人使用的非商业的免费内核,可能会有10多种,但是常见的浏览器内核可以分这四种: Trident、 Gecko、 Blink、 Webkit。 (1) Trident(IE内核)国内很多的双核浏览器的其中一核便是 Trident,美其名曰”兼容模式”。代表:、傲游、世界之窗浏览器、 Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。Window10发布后,正将其内置浏览器命名为Edge,Edge最显著的特点就是新内核 EdgeHTML。 (2)Gecko(firefox)Gecko( Firefox内核): Mozilla fire fox(火狐浏览器)采用该内核, Gecko的特点是代码完全公开,因此,其可开发程度很高,全世界的程序员都可以为其编写代码,增加功能。可惜这几年已经没落了,比如打开速度慢、升级频繁、猪一样的队友flash、神一样的对手 chrome。 (3) webkit(Safari)Safari是苹果公司开发的浏览器,所用浏览器内核的名称是大名鼎鼎的 Webkit.现在很多人错误地把 webkit叫做 chrome内核(即使 chrome内核已经是 blink了),苹果感觉像被别人抢了媳妇,都哭晕再厕所里面了。代表浏览器:傲游浏览器3、 Apple Safari(Win/ Mac_iPhone_iPad)、 Symbian手机浏览器、 Android默认浏览器。 (4) Chromium/Blink(chrome)在 Chromium项目中研发 Blink渲染引擎(即浏览器核心),内置于 Chrome浏览器之中。 Blink其实是 Webkit的分支。大部分国产浏览器最新版都采用Bink内核。 移动端的浏览器内核主要说的是系统内置浏览器的内核。 Android手机而言,使用率最高的就是 Webkit内核,大部分国产浏览器宣称的自己的内核,基本上也是属于 webkit二次开发。 IOS以及WP7平台上,由于系统原因,系统大部分自带浏览器内核,一般是 Safari或者IE内核 Trident的。 Web标准通过Web标准不同的浏览器内核展示统一内容。 Web标准构成主要包括：结构（HTML）（最重要），表现（CSS），和行为（JS）。 HTMl初识超（除了文字之外还有其他的，还可以链接），文本，标签，语言（有规范）。 语法骨架，一万年不变： h4之前标签是不分大小写的，h5之后最好小写。 头部是指标签栏位置。 页面内容基本在body中。 HTML标签分类双标签一对尖括号。 单标签单标签数量非常少，用脚趾能数过来。其中都有’/ ‘,’/‘表示关闭符。 HTML标签关系嵌套关系父子关系 并列关系 倡议：如果两个标签之间的关系是嵌套关系，子元素最好缩进一个Tab的身位。如果是并列关系，最好上下对齐。 HTML开发使用sublime，输入html:5或者！后按下tab键自动生成骨骼框架。 右键在浏览器中打开，快捷键f12。 文档类型&lt;!DOCTYPE&gt; 图中就是h5版本。 字符集 UTF-16固定用2个字节来存储。UTF-8（国际通用）,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个..反正是根据字符对应的数字大小来确定。 HTML语义化核心：在合适的地方给个合适的标签。 HTMl常用标签排版标签（内容）标题标签（熟记） 段落标签（熟记） 水平线标签（认识） 语义化后的效果： 换行标签（熟记） div span标签（重点） 通常css+divdiv独占一行，span一行可以放多个。 文本格式化标签（熟记） 图像标签img(重点) 单独给宽高会等比缩放。 链接标签（重点） 锚点定位（难点） base标签base可以设置整体链接的打开状态。在head中使用，单标签。 特殊字符标签 注释标签 路径（重点难点）相对路径 绝对路径 列表标签整齐有序。 无序列表ul（重点） 先到先得，先到先显示。 有序列表ol(了解)注意事项和ul类似，使用也类似。 自定义列表（理解） 由三个标签组成。 效果： 表格table（会使用）表格不是用来布局的，常见处理，显示表格式数据。 创建表格 表格属性 三参为0 border cellpadding cellspacing 为0 表头标签 一般第一行或第一列使用。居中且加粗。 表格标题 表格结构（了解） 合并单元格（难点） 在td属性中使用。 表单标签（掌握）收集用户信息。一个完整的表单通常由三部分组成：表单控件（也称为表单元素）、提示信息和表单域。 input控件（重点）单标签。 用name来控制单选组，多选组。 label标签（理解）label标签为input元素定义标注（标签）。作用：用于绑定一个表单元素，当点击label标签时，被绑定的表单元素就会获得输入焦点。 textarea控件（文本域） 表单域 CSS层叠样式表。 书写位置行内式（内联样式） 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式，其中属性和值的书写规范与CSS样式规范相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。注意是冒号。 内部样式表内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。 语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。 type=“text/CSS”在H5中可以省略，写上也比较符合规范，所以这个地方可以写也可以省略。 外部样式表（外链式） 在外部样式中，不用style标签，直接写就完事了。 CSS样式规则 选择器（重点）CSS基础选择器标签选择器（元素选择器） 类选择器 多类名选择器 id选择器id选择器和类选择器最大的不同在于使用次数。id选择器id只能使用一次。 使用‘#’ 定义，使用 id= 调用 通配符选择器 几乎不用。 CSS字体样式属性font-size：字号大小 统一用px font-family:字体font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等。 如果字体都没有，就使用系统默认的字体。 为了照顾浏览器的兼容性，可以使用Unicode编码。 font-weight:字体粗细 bold字体加粗。使用normal也可以让标题不加粗。 font-style：字体风格 综合设置字体样式（重点） CSS外观属性color:文本颜色 十六进制时 # ff0000由于数值一样，可以简写为 # f00。 line-height:行间距 text-align:水平对齐方式 css中没有垂直对齐的方式。 是让盒子里面的内容居中，而不是让盒子居中。 text-indent:首行缩进 text-decoration文本的装饰 复合选择器后代选择器 用空格隔开。 是选择所有的后代。 子代选择器只选亲儿子。 交集选择器 并集选择器（重点） 伪类选择器伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，比如可以选择第一个，第n个元素。 链接伪类选择器 active是按下鼠标还没弹起的状态。 CSS注释 快捷键 标签的显示（display）块级元素（block-level）每个块元素通常都会独自占据一整行或者多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 行内元素（inline-level）行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。 a里面可以放块级元素。 注意： 行内块元素（inline-block） 显示模式转换 每一个标签都是一个小盒子。 如果是行内元素，行内块元素，我们可以看做文本，可以在块级使用text-align:center进行居中对齐。 使行高等于盒子的高度，可以让单行文本垂直居中。 行高的测量 CSS三大特性CSS层叠性 CSS继承性 CSS优先级 CSS背景CSS可以添加背景颜色和背景图片，以及来进行图片设置。 背景颜色与背景图片同时设置的话背景图片会在背景颜色之上。 backgroud-repeat backgroud-position backgroud-attachment 背景简写 背景透明（CSS3） 盒子模型盒子边框盒子边框即border,有border-width,border-style,border-color.可简写为 border: 1px solid red;其中border-style常用值。 border亦可单边进行设置。border-top;border-bottom;border-left;border-right。 合并相邻边框 内边距(padding)默认贴在左上角。 padding和border会撑开带有width和height的盒子。对于没有给定的就是盒子大小不变，内容进行了移动。 外边距(margin) margin值的个数表达的意思和padding类似。 使盒子水平居中： 上下是0，左右是auto。 使块中的内容居中：text-align=center。 外边距合并 以比较大的为准。 解决方法：避免 垂直外边距嵌套元素合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。 只有垂直会发生这种情况。 解决方案： 可以为父元素定义1像素的上外边框或上内边距。 可以为父元素添加overflow:hidden. 盒子布局的稳定性按照优先使用顺序：width&gt;padding&gt;margin 插入图片与背景图片 插入图片 最多比如产品展示类；背景图片我们一般用于小图标背景或者超大背景图片。 圆角边框（CSS3） 也可以是px。值越大越圆。 第一个左上，顺时针。 盒子阴影（CSS3） 浮动（float）普通流（normal flow）也称为标准流，CSS的定位机制有三种：普通流、浮动和定位。 普通流实际就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思。比如块级元素会独占一行，行内元素会按顺序依次前后排列。 浮动浮动让盒子浮起来，盒子的位置就由其他盒子占据。 浮动有个很有意思的事情：就是让任何盒子可以一行排列，我们就慢慢地利用浮动的特性来布局了。 为什么不用inline-block?是有的时候需要右对齐，这时就不好知道具体的位置。需要量出来，不同的屏幕显示的效果不一样。而且块之间有缝隙。这时使用浮动就效果比较好。 只有左右。浮动的和浮动的又符合标准流。 浮动的盒子跨越不了padding值。 一个盒子浮动，会影响后面的位置，影响不了前面的位置，也就是说不会往上面的元素上浮。 浮动有一个隐藏的模式转换，浮动可以让元素默认转换为行内块元素，宽度取决于元素的大小。 如果已经给行内元素添加了浮动，此时不需要转换该元素也可以有宽高。 版心和布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 确定页面的版心（可视区）。 分析页面中的行模块，以及每个行模块中的列模块。 制作HTML结构。 CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/zdkswd/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://github.com/zdkswd/tags/HTML/"}]},{"title":"数学之美 第四章 谈谈中文分词","slug":"数学之美 第四章 谈谈中文分词","date":"2018-09-26T10:16:32.000Z","updated":"2018-09-26T10:17:13.000Z","comments":true,"path":"2018/09/26/数学之美 第四章 谈谈中文分词/","link":"","permalink":"https://github.com/zdkswd/2018/09/26/数学之美 第四章 谈谈中文分词/","excerpt":"","text":"中文分词方法的演变对于西方拼音语言来说，词之间有明显的分界符，统计和使用语言模型非常直接。而对于中日韩泰等语言，词之间没有明确的分界符。 最容易想到的分词方法,也是最简单的办法,就是查字典。“查字典”的办法,其实就是把一个句子从左向右扫描一遍,遇到字典里有的词就标识出来,遇到复合词(比如“上海大学”)就找最长的词匹配,遇到不认识的字串就分割成单字词,于是简单的分词就完成了。 这个最简单的方法可以解决七八成以上的分词问题,遇到稍微复杂一点的问题就无能为力了。这种方法的一个明显不足时当遇到有二义性的分割时无能为力，另外并非所有的最长匹配都是一定正确的。 利用统计语言模型分词的方法,可以用几个数学公式简单概括如下:假定一个句子S可以有几种分词方法,为了简单起见,假定有以下三种: 其中,A1,A2…B1,B2…,C1,C2…等等都是汉语的词,那么最好的一种分词方法应该保证分完词后这个句子出现的概率最大。 当然,这里面有一个实现的技巧。如果穷举所有可能的分词方法并计算出每种可能性下句子的概率,那么计算量是相当大的。因此,可以把它看成是一个动态规划( Dynamic Programming)的问题,并利用维特比( Viterbi)算法快速地找到最佳分词。(我们在后面的章节会介绍该算法。) 一般来讲,根据不同应用,汉语分词的颗粒度大小应该不同。 中文分词方法可以帮助判别英语单词的边界。因为手写英文字符时已经不能明显的区分边界了。 最后,需要指出的是任何方法都有它的局限性,虽然利用统计语言模型进行分词,可以取得比人工更好的结果,但是也不可能做到百分之百准确。因为统计语言模型很大程度上是依照“大众的想法”,或者“多数句子的用法”,而在特定情况下可能是错的。 工程上的细节分词的一致性如何衡量分词结果的对与错,好与坏看似容易,其实不是那么简单。说它看似容易,是因为只要对计算机分词的结果和人工分词的结果进行比较就可以了。说它不是那么简单,是因为不同的人对同一个句子可能有不同的分词方法。不同的人对词的切分看法上的差异性远比我们想象的要大得多。当统计语言模型被广泛应用后,不同的分词器产生的结果的差异要远远小于不同人之间看法的差异,这时简单依靠与人工分词的结果比较来衡量分词器的准确性就很难,甚至是毫无意义的了。中文分词现在是一个已经解决了的问题,提高的空间微乎其微了。只要采用统计语言模型,效果都差不到哪里去。 词的颗粒度和层次人工分词产生不一致性的原因主要在于人们对词的颗粒度的认识问题。在这里不去强调谁的观点对,而是要指出在不同的应用中,会有一种颗粒度比另一种更好的情况。比如在机器翻译中,一般来讲,颗粒度大翻译效果好。比如“联想公司”作为一个整体,很容易找到它对应的英语翻译 Lenovo,如果分词时将它们分开,很有可能翻译失败。 虽然可以对不同的应用构造不同的分词器,但是这样做不仅非常浪费,而且也不必要。更好的方法是让一个分词器同时支持不同层次的词的切分。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/zdkswd/tags/数学/"}]},{"title":"Python廖雪峰 常用内建库","slug":"Python廖雪峰 常用内建模块 ","date":"2018-09-24T09:05:56.000Z","updated":"2018-09-24T09:07:45.000Z","comments":true,"path":"2018/09/24/Python廖雪峰 常用内建模块 /","link":"","permalink":"https://github.com/zdkswd/2018/09/24/Python廖雪峰 常用内建模块 /","excerpt":"","text":"datetimedatetime是Python处理日期和时间的标准库。 获取当前日期和时间 注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。 如果仅导入import datetime，则必须引用全名datetime.datetime。 datetime.now()返回当前日期和时间，其类型是datetime。 获取指定日期和时间直接用参数构造一个datetime。 datetime转换为timestamp在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。 timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。 把一个datetime类型转换为timestamp只需要简单调用timestamp()方法。 注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。 某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。 timestamp转换为datetime要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法。 这个得到的时间就是当前操作系统设定的时区，timestamp也可以直接被转换到UTC标准时区的时间。datetime.utcfromtimestamp str转换为datetime很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串。 datetime转换为str如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串。 datetime加减对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类。 本地时间转换为UTC时间本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。 时区转换我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间。 datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。 collectionscollections是Python内建的一个集合模块，提供了许多有用的集合类。 namedtuple namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。 作用是更直接，像类一样表明这个的用途，但又不是类，没那么重。 deque使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。 deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。 deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。 defaultdict使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。 注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。 除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。 OrderedDict使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。 注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序。 dict内是无序的。 CounterCounter是一个简单的计数器，例如，统计字符出现的个数。 Counter实际上也是dict的一个子类。 base64Base64是一种用64个字符来表示任意二进制数据的方法。Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。 Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%。6bit表示一个字符在表中的位置。表中共有64个字符。 Python内置的base64可以直接进行base64的编解码。 由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符+和/分别变成-和_ structPython提供了一个struct模块来解决bytes和其他二进制数据类型的转换。 尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。 hashlibPython的hashlib提供了常见的摘要算法，如MD5，SHA1等等。 摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。 MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。 SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。 比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。 这个函数是一个单向函数，可以通过对比结果的不同来判断原文是否发生过篡改。当然有可能发生两个不同的数据通过某个摘要算法得到了相同的摘要，这种情况叫做碰撞，非常非常罕见。 可以用来在数据库中存储使用md5加密过后的密码，用户登录时，经过计算再与数据库中的摘要作比较。 hmacHmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。 Python自带的hmac模块实现了标准的Hmac算法。 我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下： 可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。 Python内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。 itertoolsPython的内建模块itertools提供了非常有用的用于操作迭代对象的函数。 chain()chain()可以把一组迭代对象串联起来，形成一个更大的迭代器 groupby()groupby()把迭代器中相邻的重复元素挑出来放在一起。 contextlib实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句。实现上下文管理是通过enter和exit这两个方法实现的。 一个是with触发的时候，一个是退出的时候。编写enter和exit仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法。 contextlib是个比with优美的东西，也是提供上下文机制的模块，它是通过Generator装饰器实现的。不再是采用enter和exit。contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制。 一个上下文管理器通过with声明激活, 而且API包含两个方法。__enter__()方法运行执行流进入到with代码块内。他返回一个对象共上下文使用。当执行流离开with块时，__exit__()方法上下文管理器清除任何资源被使用。 @closing如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()。 closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单。 它的作用就是把任意对象变为上下文对象，并支持with语句。 urlliburllib提供了一系列用于操作URL的功能。 Geturllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应。 PostHandlerurllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。 XMLXML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。 DOM vs SAX操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。 正常情况下，优先考虑SAX，因为DOM实在太占内存。 在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。 解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。 HTMLParser如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。 HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。 Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码。 利用HTMLParser，可以把网页中的文本、图像等解析出来。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/zdkswd/tags/Python/"}]},{"title":"数学之美 第三章 统计语言模型","slug":"数学之美 第三章 统计语言模型","date":"2018-09-18T12:25:32.000Z","updated":"2018-09-18T12:40:17.000Z","comments":true,"path":"2018/09/18/数学之美 第三章 统计语言模型/","link":"","permalink":"https://github.com/zdkswd/2018/09/18/数学之美 第三章 统计语言模型/","excerpt":"","text":"自然语言从它产生开始,逐渐演变成一种上下文相关的信息表达和传递的方式,因此让计算机处理自然语言,一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型( Statistical Language Model),它是今天所有自然语言处理的基础,并且广泛应用于机器翻译、语音识别、印刷体或手写体识别、拼写纠错、汉字输入和文献查询。 用数学的方法描述语言规律统计语言模型产生的初衷是为了解决语音识别问题。 相比较于传统的基于语法语义的分析。贾里尼克的出发点很简单:一个句子是否合理,就看看它的可能性大小如何。至于可能性就用概率来衡量。第一个句子出现的概率大致是十的负二十次方，第二个句子出现的概率是十的负二十五次方,第三个句子出现的概率是十的负七十次方。因此,第一个最有可能,它的可能是第二个句子的10万倍,是第三个句子的一百亿亿亿亿亿亿倍。这个方法更普通而严格的描述是: 假定S表示某一个有意义的句子，由一连串特定顺序排列的词w1,w2,…,wn组成，这里n是句子的长度。若是想知道S在文本中出现的可能性，即数学上所说的S的概率P（S）。当然可以把世界上所有出现过的话统计一下，便知道这句话出现的概率了。当然这是不可能做到的。因此，需要有个模型来估算它。S=w1,w2,…,wn,那么P(S)=P(w1,w2,…,wn)利用条件概率公式 到了词wn，它的出现概率取决于它前面的所有词，到了最后一个词wn，条件概率P的可能性太多，无法估算。 俄罗斯数学家提出了一个偷懒且颇为有效的方法，即马尔科夫假设。假设任意一个词wi出现的概率只同它前面的词wi-1有关。 公式对应的统计语言模型是二元模型。假设一个词由前面N-1个词决定，对应的模型稍微复杂些，被称为N元模型。 估计联合概率P(wi-1，wi)和边缘概率P(wi-1),现在变得很简单。因为有了大量机读文本,也就是专业人土讲的语料库,只要数一数wi-1,wi这对词在统计的文本中前后相邻出现了多少次#（w-1,w),以及W-1本身在同样的文本中出现了多少次#(wi-1),然后用两个数分别除以语料库的大小#,即可得到这些词或者二元组的相对频度: 根据大数定理，只要统计量足够，相对频度就等于概率。 统计语言模型的工程诀窍高阶语言模型显然一个词只跟前面一个词有关，似乎太简化，因此，更普遍的假设是某个词和前面若干个词有关。 假定文本中的每个词wi和前面N-1个词有关，而与更前面的词无关，这样当前词wi的概率只取决于前面N-1个词P。 这就是N-1阶马尔可夫假设，对应的语言模型称为N元模型。而实际应用中使用最多的是N=3的三元模型，更高阶的模型就很少使用了。 \u0010\u0010主要是因为N元模型的空间复杂度几乎是N的指数函数，即O（|V|^N），这里|V|是一种语言词典的词汇量，一般在几万到几十万个。同样时间复杂度也几乎是一个指数函数O（|V|^（N-1）），因此N不能很大。当N从1到2，再从2到3时，模型的效果上升显著。当模型从3到3时，效果的提升就不是很显著了，而资源的耗费增加却非常快，所以，除非是不惜资源为了做到极致，很少有人使用四元以上的模型。Google的罗塞塔翻译系统和语言搜索系统,使用的是四元模型,该模型存储于500台以上的 Google服务器中。 模型的训练、零概率问题和平滑方法使用语言模型需要知道模型中所有的条件概率,我们称之为模型的参数。通过对语料的统计,得到这些参数的过程称作模型的训练。 在数理统计中,我们之所以敢于用对采样数据的观察结果来预测概率,是因为有大数定理( Law of Large Numbers)在背后做支持,它的要求是有足够的观测值。 一个直接的办法就是增加数据量,但是即使如此,依然会遇到零概率或者统计量不足的问题。假定要训练一个汉语的语言模型,汉语的词汇量大致是20万这个量级,训练一个三元模型就有8*10的15次方个不同的参数。假如从互联网上刨去垃圾数据,有100亿个有意义的中文网页,这已经是相当高估的数据,每个网页平均1000词。那么,即使将互联网上全部的中文内容都用作训练,依然只有10的13次方,因此,如果用直接的比值计算概率,大部分条件概率依然是零,这种模型我们称之为不平滑。在实际应用中,统计语言模型的零概率问题是无法回避的。 古德-图灵估计可以解决这个问题。当一个词出现的频次过小时，统计可能不可靠，计算它们的概率时要使用一个更小一点的次数,是dr(而不直接使用r),古德-图灵估计按照下面的公式计算dr： 在语料库中出现r次的词有Nr个，语料库的大小为N。 一般来说,出现一次的词的数量比出现两次的多,出现两次的比出现三次的多。这种规律称为zipf定律(zipf’s Law)。 r越大词的数量Nr越小。因此一般情况下dr&lt;r,而d0&gt;0。这样就给未出现的词赋予了一个很小的非零值，从而解决了零概率的问题。同时下调了出现频率很低的词的概率。当然,在实际的自然语言处理中,一般对出现次数超过某个阈值的词,频率不下调,只对出现次数低于这个阈值的词,频率才下调,下调得到的频率总和给未出现的词。 这样出现r次的词的概率估计为dr/N。于是,对于频率超过一定阈值的词,它们的概率估计就是它们在语料库中的相对频度,对于频率小于这个阈值的词,它们的概率估计就小于它们的相对频度,出现次数越少的,折扣越多。对于未看见的词,也给予了一个比较小的概率。这样所有词的概率估计都很平滑了。 例如对于三元模型。 函数fgt()表示经过古德-图灵估计后的相对频度。 语料的选取问题训练数据应当相关，训练数据通常是越多越好。虽然介绍了相关的方法去解决缺数据的问题，但是在数据量最多的时候概率模型的参数可以估计得比较准确，高阶的模型因为参数多,需要的训练数据也相应会多很多。遗憾的是,并非所有的应用都能得到足够的训练数据,比如说机器翻译的双语语料就非常少,在这种情况下片面追求高阶的大模型就变得一点意义也没有了。 在训练数据和应用数据一致并且训练量足够大的情况下,训练语料的噪音高低也会对模型的效果产生一定的影响,因此,在训练以前有时需要对训练数据进行预处理。一般情况下,少量的(没有模式的)随机噪音清除起来成本非常髙,通常就不做处理了。但是对于能找到模式( Pattern)的、量比较大的噪音还是需要进行过滤的,而且它们也比较容易处理,比如网页文本中大量的制表符。因此,在成本不高的情况下,过滤训练数据还是需要做的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/zdkswd/tags/数学/"}]},{"title":"数学之美 第二章 自然语言处理--从规则到统计","slug":"数学之美 第二章 自然语言处理--从规则到统计","date":"2018-09-18T01:07:32.000Z","updated":"2018-09-18T01:07:41.000Z","comments":true,"path":"2018/09/18/数学之美 第二章 自然语言处理--从规则到统计/","link":"","permalink":"https://github.com/zdkswd/2018/09/18/数学之美 第二章 自然语言处理--从规则到统计/","excerpt":"","text":"任何语言都是一种编码的方式，而语言的语法规则则是编解码的算法。 在上世纪70年代之前，计算机对自然语言的处理集中在分析语句和获取语义，基于规则的自然语言处理。主要是因为当时的学术界存在误区，即要让计算机完成翻译或者是语音识别这样只有人类能做到的事情，就必须先让计算机理解自然语言。因为从直觉上大家都会这么认为。但是相比于上下文无关文法，自然语言这种上下文有关的文法对于同样长度的句子复杂度是前者的万倍，因为上下文有关，所以需要更多额外的信息来表示现在的上下文，以及将自然语言变成及其复杂得树，在计算能力没法跟上的那个年代根本没有办法商用。 从规则到统计随着保守的教授陆续的退休，慢慢地研究方向从基于规则逐渐转向了基于统计。 15年,对于一个学者来讲是一段非常长的时间,如果哪个人从做博士开始就选错了方向并且坚持错误,到15年后发现时,基本上这一辈子可能就一事无成了。 小结基于统计的自然语言处理方法，在数学模型和通信是相通的，甚至就是相同的。因此，在数学意义上自然语言处理又和语言的初衷–通信联系在一起了。但是，科学家们认识到这个联系却花了几十年的时间。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/zdkswd/tags/数学/"}]},{"title":"数学之美 第一章 文字和语言vs数字和信息","slug":"数学之美 第一章 文字和语言vs数字和信息","date":"2018-09-14T12:41:32.000Z","updated":"2018-09-14T12:41:59.000Z","comments":true,"path":"2018/09/14/数学之美 第一章 文字和语言vs数字和信息/","link":"","permalink":"https://github.com/zdkswd/2018/09/14/数学之美 第一章 文字和语言vs数字和信息/","excerpt":"","text":"信息 文字和数字当语言和词汇多到一定程度时，人类仅靠大脑已经记不住所有的词汇了。高效记录信息的需求就产生了，这便是文字。 最早是象形文字，当文字的数量多到一定程度时便不再增加了，于是开始了对概念的概括与归类。比如中文的一字多意。对于概念的聚类在原理上与今天自然语言处理或机器学习的聚类有很大的相似性。 文字按照意思来聚类，最终会带来一些歧义性，解决这个问题的方法过去与现在并没有什么不同，都是依靠上下文。但是还是会有有歧义的情况发生。今天的情况也是这样，对上下文建立的概率模型再好也有失灵的时候。这些事语言从产生开始就固有的特点。 翻译之所以能够进行，仅仅是因为不同的文字系统在记录信息上的能力是等价的（这一点非常重要）。文字只是信息的载体，而非信息本身。即使不用文字使用如数字的载体也可以存储同样意义的信息。这便是现代通信的基础。 当然,不同的文明进行交流时,或许会用不同的文字记载同一件事情。这就有可能为我们破解无人能懂的语言提供一把钥匙。 罗塞塔石碑使用了三种语言记录的同一件事情，罗塞塔石碑的破解有两点指导意义。首先，信息的冗余是信息安全的保障，其次，语言的数据，又称为语料尤其是双语或者多语对照语料对翻译至关重要。 既然文字是出现在远古“信息爆炸”导致人们的头脑装不下这些信息的时候,那么数字的出现则是在人们的财产多到需要数一数才搞清楚有多少的时候。 最开始是掰手指头来计数的，所以自然而然的就是十进制了。当然，也有连脚指头算上去的民族，所以他们是二十进制。当十进制不够用时，我们的祖先很聪明,他们发明了进位制,也就是我们今天说的逢十进一。这是人类在科学上的一大飞跃,因为我们的祖先懂得对数量开始编码了,不同的数字代表不同的量。比如二百，就是编过码的数字，解码的方法是乘法2*100。从编码的有效性来说，中国人的做法比罗马人高明。 阿拉伯人传播的古印度发明的数字123是革命性的，标志着数字和文字的分离。 文字和语言背后的数学但是,任何事物的规律性是内在的,并不随它的载体而改变。自然语言的发展在冥冥之中,都受着信息科学规律的引导。 从象形文字到拼音文字是一个飞跃,因为人类在描述物体的方式上,从物体的外表到抽象的概念,同时不自觉地采用了对信息的编码。不仅如此,我们的祖先对文字的编码还非常合理。常用的较短，不常用的较长。这完全符合信息论中的最短编码原理。 在蔡伦发明纸张以前,书写文字不是一件容易的事情。就以中文为例在东汉以前要将文字刻在其他物件比如龟壳、石碑和竹简上。由于刻个字的时间相当长,因此要惜墨如金。这就使得我们的古文(书面文字)非常简洁,但是非常难懂,而同时期的口语却和今天的白话差别不大,语句较长但是易懂。(岭南客家话基本上保留了古代口语的原貌,写出来和我们清末民初的白话颇为相似。)这种现象非常符合今天信息科学(和工程)的一些基本原理,就是在通信时,如果信道较宽,信息不必压缩就可以直接传递;而如果信道很窄,信息在传递前需要尽可能地压缩,然后在接收端进行解压缩。 犹太人在抄写《圣经》时,抄写错误还是难以避免。于是犹太人发明了一种类似于我们今天计算机和通信中校验码的方法。他们把每一个希伯来字母对应于一个数字,这样每行文字加起来便得到一个特殊的数字,这个数字便成为了这一行的校验码。同样,对于每一列也是这样处理。当犹太学者抄完一页《圣经》时,他们需要把每一行的文字加起来,看看新的校验码是否和原文的相同,然后对每一页进行同样的处理。如果这一页每一行和每一列的校验码和原文完全相同,说明这一页的抄写无误。如果某行的校验码和原文中的对应不上,则说明这行至少有一个抄写错误。当然,错误对应列的校验码也一定和原文对不上,这样可以很快找到出错的地方。 如果说从字母到词的构词法(Morphology)是词的编码规则,那么语法则是语言的编码和解码规则。不过,相比较而言,词可以被认为是有限而且封闭的集合,而语言则是无限和开放的集合。从数学上讲,对于前者可以有完备的编解码规则,而后者则不具备这个特性。因此,任何语言都有语法规则覆盖不到的地方,这些例外或者说不精确性,让我们的语言丰富多彩。 小结这些今天自然语言处理学者们研究的问题,我们的祖先在设计语言的时候其实已经遇到了,并且用类似今天的方法解决了,虽然他们的认识大多是自发的,而不是自觉的。他们过去遵循的法则和我们今天探求的研究方法背后有着共同的东西,这就是数学规律。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/zdkswd/tags/数学/"}]},{"title":"浪潮之巅读书笔记","slug":"浪潮之巅读书笔记","date":"2018-09-14T11:08:47.000Z","updated":"2018-09-14T11:09:05.000Z","comments":true,"path":"2018/09/14/浪潮之巅读书笔记/","link":"","permalink":"https://github.com/zdkswd/2018/09/14/浪潮之巅读书笔记/","excerpt":"","text":"转载加修改，自用。对书名《浪潮之巅》中“浪潮”的理解书名为“浪潮之巅”。顾名思义，本书就是讲述那些曾经或正站在互联网浪潮的巅峰的企业。书中列举了好多我们耳熟能详的企业名称，例如苹果公司、微软、诺基亚等等，“之巅”大家都能理解，即”巅峰“的意思，这些公司无疑能让大家所知，无疑都是在各自领域中极有成就的，然而成就它们达到巅峰状态的，除了自身的内功之外，无一例外的，就是这些伟大的公司都赶上了IT产业的兴起、发展与升级。因而“浪潮”可以这样理解：科技革命的浪潮，同时也可以专指信息技术革命的浪潮。 那些曾经或正在浪潮之巅的弄潮儿们帝国黄昏之AT&amp;T公司AT&amp;T公司创始人，说起来很有名，即使电话的发明人贝尔，后来AT&amp;T公司旗下有闻名于世的贝尔实验室，该实验室出过十一位诺贝尔奖得主。 AT&amp;T可谓老字号，于1877年成立，一百年来发展的顺风顺水，很长时期内垄断整个北美的通信业务。虽然有美国政府的反垄断调查，但是每次调查都会帮AT&amp;T公司剪除枝叶，让它更加茁壮。例如1913年美国司法部的调查，避免了AT&amp;T公司的大肆扩张，这反而让它顺利度过了大萧条时期。 时间到了1984年，AT&amp;T终于挺不过反垄断调查，公司进行了拆分，由一家分成7家，这次修剪让AT&amp;T公司从以通话业务为主转向了新兴的网络和移动通信方面。 1995年在华尔街逐利的资本驱动下，这一次公司高管自我拆分，而正是这个举动让AT&amp;T伤筋动骨。然而明白人大有人在，但是禁不住股票期权的诱惑，公司的未来在目前金钱的诱惑下一文不值。接下来的2000年公司又被拆分为四家，而此时AT&amp;T公司已经错过了互联网的浪潮。由于AT&amp;T主营业务是固定电话业务，互联网兴起后，人们可以直接用网络通话，再也不想用AT&amp;T那昂贵的通话业务了。曾经最能代表行业发展的AT&amp;T，由于华尔街资本的贪婪和技术浪潮的波动，已经变成了明日黄花。 科技界常青树之IBMIBM公司成立于1924年，由托马斯·华生创立。IBM成立的时间正好是第二次工业革命的末期，它发明一种机器，能够帮助政府和大型企业组织进行统计数据的整理和简单分析，因而早期的IBM，其主要客户就是政府和大型组织。 二战结束后，公司由托马斯·华生的儿子小华生接任，他是一位伟大的领导者，正是在他的带领下，IBM走向辉煌，并引领了第三次科技革命。 “电子计算机和IBM的名字是分不开的，就如同电话和AT&amp;T分不开一样”。吴军博士的这句话充分说明了IBM公司同电子计算机的相互促进作用。 在小华生的带领下，IBM投注计算机行业，在提高研究经费的同时也召来很多优秀工程师，并且参与了计算机行业标准的制定。正是这样的举动，IBM公司在小华生执掌期间，业绩年均增长30%，同时IBM公司很高的薪水也吸引了优秀的年轻人加入计算机行业。 从1950年代到1980年代这时期的IBM公司可以说是独孤求败。而这种垄断地位自然而然遭到了美国政府的反垄断调查。IBM公司不得不进行拆分，并想社会公布自己的一些专利和技术。 然而，由于IBM的业务重心一直在政府和大型企业这边，它就不可能把工作重点放在个人电脑业务上，此时一位天才人物比尔·盖茨看到了个人电脑的伟大前景，伴随着摩尔定律的作用，日渐强大的个人计算机不断蚕食IBM的主营业务，IBM就像一个走向坟墓的巨人。 1993年，郭士纳临危受命，拯救IBM。郭士纳果断出售不赚钱的硬件业务，把个人电脑业务卖给联想，从硬件制造商转型为服务政府和大型企业组织。这次转型是相当成功的，IBM公司成功从坟墓中爬了出来。 目前IBM公司是拥有专利最多的公司，在2001年起市值一度超过了微软。 向死而生之苹果说起苹果公司，就一定要讲到史蒂夫·乔布斯。在吴军博士看来，他可谓是硅谷最具传奇色彩的人物。他是唯一一个大学没有超过一年就获得美国工程院院士的人，而他获选院士的理由是：在个人计算机领域的伟大贡献。 1976年苹果公司成立，当时乔布斯和他的小伙伴们的愿望是把昂贵的计算机商业化，让计算机走进千家万户。当时的计算机很昂贵，价值几万美元。而当苹果电脑一代出来时，只需花费数百美元。 虽然现在看起来苹果一代几乎做不了什么事，但这代表了计算机不再是大型组织的专属用品，它有可能走进千家万户。与此同时，1980年代的IT产业巨人IBM也向个人计算机领域进军，一出售就占据了当时个人电脑市场的75%。针对于此，乔布斯致力于开发苹果二代，终于1984年研制出来，这是真正意义上有交互式图形界面并且有鼠标的个人电脑。而这个产品也广受市场欢迎，同时助推苹果股价攀上高峰然而好景不长，此时的苹果公司邀请了原百事可乐总裁斯库利加盟，一年之后乔布斯出走。而苹果公司在斯库利的带领下，凭借乔布斯留下的财产，还能坚挺一阵子，然而苹果的摊子越铺越大，虽然开展了不少项目，但收效甚微。同时苹果电脑业务在微软的挤压下日薄西山。 1998年的苹果决定请回乔布斯，让他执掌苹果这艘破船，而乔布斯也不愿意看着自己所创立的公司倒闭，在他的带领下，苹果公司逐渐走出低谷，获得新生。 进入21世纪的苹果公司发展了两项业务：一个是iPod，一个是iPhone。 iPod的成功是因为乔布斯利用了音乐的数字化浪潮，而iPhone的成功同样借助3G时代的东风，如果这两件产品提前几年，估计不会有现在的成功，而乔布斯天才的地方在于他牢牢抓住了这两次浪潮，才成就了今天的苹果。 前途未知的微软帝国吴军博士这样形容微软：“微软永远是所有公司最可怕的敌人。微软靠它在操作系统上的垄断地位和无比雄厚的财力，在计算机领域几乎是无往而不胜。 这句话放在《浪潮之巅》成书的那一年2008年——2009年还成立，但是现在由于谷歌和苹果的双重夹击，微软，这个被吴军博士称之为“IT业的罗马帝国”的人，前途还真的堪忧。 此话暂且不表，今日就来说说微软帝国如何成立的。1980年代的微软，在乔布斯眼里还只是个小小的软件公司。然而微软有个天才，就是比尔·盖茨。虽然比尔·盖茨在其他领域可能不如乔布斯，但是他在商业经营上的天赋要高于乔布斯，通过两手抓的方式狙击了苹果。 一方面盖茨对苹果方面要求研发软件采用拖字诀；另一方面联合当时强大的IBM，开发新的、与苹果不同的操作系统。没想到盖茨还有第三部，就是微软的操作系统便宜，他采用薄利多销的态度，因而吸引了大量计算机爱好者和软件研发者，他们在上面开发了各种各样的软件，这样用户就逐渐对微软的系统产生依赖。 就这样微软依靠自己相对廉价的操作系统，以及系统良好的兼容性，加上对手苹果公司存在的战略失误，帝国就这样建立起来。 1997年微软市场首次超过IBM，然而微软还不放心，它继续进行维护自己垄断地位的战争。这次它的手段是通过模仿比竞争对手更加廉价的产品，以及依靠自己的垄断地位来打击对手的。 然而没有永远的帝国，微软帝国在取得操作系统的绝对领先后，想进一步扩大优势，于是把眼光瞄向了互联网领域，这次迎接微软挑战的是新兴的雅虎，它比微软更绝，因为雅虎的服务是免费的。经过这次战役后，加上2000年的互联网泡沫，微软错过了进军互联网的最佳时机。 2015年下半年，微软将发布windows 10,它想实现所有操作平台的一体化，不知微软能否通过这一举动，实现王者归来？ 互联网中的福特——雅虎之所以称呼雅虎为互联网中的福特，是因为吴军博士认为雅虎对互联网的影响是可以同福特对汽车工业的影响相提并论的。 在汽车工业中，尽管汽车不是福特发明的，但是福特的生产模式，重新定义了汽车行业，并让普通工薪阶层买得起汽车。而雅虎对互联网行业的影响，在这一意义上，与福特对汽车产业的影响是相似的。 早期的互联网，其信息提供是面向用户收费的。不仅用户入网要收费，而且浏览信息也要收费，如果这样下去，互联网的发展将会和有线电视一样，几乎没有可能发展成现在的样子，而正是雅虎改变了这种状况，它把互联网办成了开放的、免费的，而且更重要的是，盈利的。 雅虎面向用户提供的服务是免费的，例如雅虎邮箱业务，而雅虎转而面向企业收取广告费，这样就形成了良性循环：免费模式吸引了更多的用户，而更多的用户意味着更多的流量，流量意味着广告商的投入更高效。 1996年雅虎上市，成为当时互联网的第一品牌，而其两位创始人——杨致远和大卫·肥罗——立刻成为了亿万富翁。 然而雅虎面对资本市场的疯狂追逐，它没有进行理性衡量，反而把自己的摊子越铺越大，因为雅虎要回应资本市场对它的期望，以支撑住它的股价。2000年，互联网泡沫崩溃，雅虎的股价下跌了90%。 从这之后，雅虎的股价再也没回到高峰，而更严重的是，雅虎并没有非常雄厚的技术积累，这个曾经的互联网巨头，按照吴军博士的话来说，已经进入了“红巨星”时代——恒星的最后一个阶段。 消失的贵族——摩托罗拉曾经，没落罗拉就是无线通信的代名词，同时它还是品质和技术的保证。而现在它在浪潮的冲击下，从被谷歌收购，到现在转手联想，这其中的曲折让人叹息，然而我们不能忘记摩托罗拉曾经的荣耀，它也引领过浪潮。 摩托罗拉公司创立于1928年，原名加尔文制造公司，由创始人之一的保罗·加尔文的名字命名。最早生产汽车收音机，二战时该公司的一些工程师帮助政府研究无线通信工具，并获得军方的认可，由此开始，可以表现出该公司在无线通讯上的强悍技术。 二战后，由于摩托罗拉的品牌越来越响，加尔文公司干脆就改名为摩托罗拉。 从二战结束到20世纪90年代，可谓是摩托罗拉的黄金时代，摩托罗拉在模拟无线通信方面有任何公司都无法比拟的技术优势。 摩托罗拉最大的贡献是在20世纪80年代发明了“大哥大”，而且其品质受到人们的交口称赞。正是因为摩托罗拉的品质和技术优势，它很自然地垄断了第一代移动通信市场。当时的摩托罗拉手机占据了全球市场的70%。 然而时间进入到九十年代，以GSM为标准的第二代移动通信技术普及开来，由于这一技术标准是由欧洲制定，作为欧洲公司的诺基亚具有很大的地理优势和后发优势。另一方面摩托罗拉公司错误估计了信息技术的更新换代技术，而且摩托罗拉过度注重技术，忽视了消费者的需求，导致它的产品不如诺基亚和三星等亚洲公司的产品畅销。 尽管后来摩托罗拉推出过多款经典机型，例如著名的刀锋系列，但是已经回天乏术，2014年转手一次的摩托罗拉进入了联想。 没落的雷神之锤——诺基亚诺基亚是《浪潮之巅》中介绍的唯一一家欧洲公司，然而现在的命运也是堪称坎坷。从2007年的市占率40%到如今的黯然退出手机市场，诺基亚的名字貌似距离现在越来越远。 曾几何时诺基亚还是芬兰的一家木工厂，曾经它的业务也如摊大饼一般，不断寻找大的发展方向，其中一个尝试很重要，就是它在20世纪60年代为军方和商业用户提供对讲机，从这些业务中诺基亚积累了一定的技术。 1982年诺基亚研制出了一种可以移动的电话，然而此时的它还不能与当时的巨头摩托罗拉相比，直到20世纪80年代末因为项目太多，出现严重的亏损。 直到1992年通信业务才成为诺基亚的核心，这一转型使得诺基亚由一个普通的电子公司成为全球移动通信的领导者，除了正确的转型方向外，还有三点对诺基亚的成功很重要：第一，抓住了移动通信技术的转型浪潮；第二，芬兰政府的大力支持；第三，科技以换壳为本。 诺基亚在2G浪潮中比摩托罗拉更注重外观、用户的便捷程度，而且一直保持产品开发的快速和灵活性，又是换一个外壳就是一部新手机，因此有人戏称诺基亚——”科技以换壳为本“。 然而诺基亚在3G浪潮中没落，最终被迫与微软走到一起，出了几款Windows Phone手机，最近的新闻是诺基亚手机部门被微软收购，而变成了Lumia品牌，诺基亚这个曾经的”雷神之锤“黯然退出手机市场。 奔腾的芯–英特尔时势造英雄英特尔公司由戈登•摩尔(Gordon E. Moore)和罗伯特.诺伊斯(Robert Noyce)于 1968 年 创立于硅谷。此前，摩尔和诺伊斯在 1956 年还和另外六个人一起创办了仙童(Fairchild)半 导体公司。 一开始英特尔生产的是性能低的微处理器，是用来补充大计算机公 司看不上的低端市场。在很长时间里，英特尔的产品被认为 是低性能、低价格。虽然它的性价比很高，但并不是尖端产品。 1981 年，IBM 为了短平快地搞 出 PC，也懒得自己设计处理器，拿来英特尔的 8086 就直接用上了。这一下子，英特尔一举 成名。 为了和 IBM PC 兼容，处理器都得是英特尔公司的。 英特尔的崛起就成为历史的必然。这正是时势造英雄。 八十年代，英特尔果断地停掉了它的内存业务，将这个 市场完全让给了日本人，从此专心做处理器。当时日本半导体公司在全市界挣了很多钱，日 本一片欢呼，认为它们打败了美国人。其实，这不过是英特尔等美国公司弃子求势的一招棋。 到今天， 即使是最早生产工作站的太阳公司和世界上最大的计算机公司 IBM 以及以前从不使用英特 尔处理器的苹果公司，都开始在自己的计算机中使用英特尔的或者和英特尔兼容的处理器了。 现在，英特尔已经垄断了计算机处理器市场。 英特尔与摩托罗拉之战资金密集型的日本半导体公司终究不可能是技术密集型的英特尔公司的对手。英特尔公 司迄今唯一遇到的重量级对手只有八十年代的摩托罗拉。 正如同罗马帝国的崛起是通过在布 匿战争中打败原有的霸主迦太基而完成的，英特尔的崛起是靠击败老牌半导体公司摩托罗拉 而实现的。 英特尔公司从外部得到了强援。由于 IBM PC 兼容机的逐步普及，技术上相对落 后的英特尔反而占了更多的市场份额。 要分析摩托罗拉之败，我们不妨来比较一下英特尔和摩托罗拉这两个公司。首先，这是 两个不同时代的公司。总部在美国中部伊利诺斯州的摩托罗拉虽然也是一个高技术公司，也 经历了八十年代的信息革命，但是它的作态完全还是五六十年代的传统的公司。虽然摩托罗 拉对雇员在工资和福利上待遇不错，但是公司和员工，基本上还是传统的雇佣关系，公司内 部管理层次较多，大部分员工基本上没有多少股票期权。因此，公司的业绩和员工的利益关 系不大。英特尔公司则是一的典型的硅谷公司。每个员工的工作强度比摩托罗拉要大很多， 但是每个人平均的股票期权也多很多。硅谷几个比较好的学区的房子，不少被英特尔公司的 早期员工买走了，而这些房子靠工资是一辈子也买不起的。 几年前，美国历史频道(History Channel)在节目中评论了中日甲午战争。美国的历史学家认为，这是两个不同时代军队之间 的战争，虽然双方武器相差不多，战争的结果不会有任何悬念，因为一个在专制的农业时代 后期的军队很难打赢一个兴起的工业化国家的军队。英特尔和摩托罗拉之间的竞争也是如此。 两个公司的统帅水平相去甚远。英特尔公司八九十年代的 CEO 格罗夫虽然是学 者出身，同时也是微机时代最优秀的领导者和管理者，他几次被评为世界上最好的 CEO。摩 托罗拉公司由加尔文(Galvin)兄弟创办，公司六十年代传到了儿子手里，八九十年代传到了 孙子手里，是个典型的家族公司。俗话说富不过三代，这话果然应验在加尔文家族上，三代 人可以说是一代不如一代。 在业务上，半导体只是摩托罗拉的一个部门，而微机处理器又只是其半导体部门的一项 业务，可是它对于英特尔来讲却是全部。 指令集之争英特尔在微软的帮助下，在商业上打赢了对摩托罗拉一战。在接下来的十年里，它在技术上又和全世界打了一战。如果转到精简指令的道路上，英特尔的市场优势会荡然无存;如果坚持 走复杂指令的道路，它就必须逆着全世界处理器发展潮流前进。 英特尔为了兼容性，一直坚持使用CISC，但是并没有放弃RISC。应该讲英特尔在精简指令处理器的工作没有白花，它在奔腾及以后的处理器设计上吸取 了 RISC 的长处，使得处理器内部流水线的效率提高很多。英特尔通过高强度的投入，保证 了它处理器性能提升得比精简指令还要快。而在精简指令阵营，九十年代五大工作站厂家太 阳、SGI、IBM、DEC 和 HP 各自为战，每家都生产自己的精简指令处理器，加上摩托罗拉 为苹果生产的 PowerPC，六家瓜分一个市场，最后谁也做不大、做不好。 英特尔经过十年努力终于打赢了对精简指令集的处理器之战。需要强调的是，英特尔不 是靠技术，而是靠市场打赢的此战。英特尔的表现在很多地方很值得圈点。首先，英特尔坚持自己系列产品的兼容性，即保证以往的软件程序肯定能在新的处理器上运行。这样时间一 长，用户便积累了很多在英特尔处理器上运行的软件。每次处理器升级，用户原来的软件都 能使，非常方便。因此大家就不愿意轻易更换其它厂家的处理器，即使那些处理器更快。而 其它处理器生产厂家这点做的都没有英特尔好，它们常常每过几年就重起炉灶，害得用户以 前很多软件不能用了，必须花钱买新的。时间一长，用户就换烦了。第二，英特尔利用规模 经济的优势，大强度投入研发，让业界普遍看衰的复杂指令集处理器一代代更新。在九十年 代初，英特尔的 x86 系列和精简指令集的处理器相比在实数运算上要略逊一筹。但是，英特 尔十几年来坚持不懈地努力，后来居上，而其它厂商因为各自市场不够大，每一个单独的处 理器芯片的投入远远不如英特尔，因此反倒落在了后面。 英特尔并没有拒绝新技术，它也曾经研制出两个不错的精简 指令的处理器，只是看到它们前途不好时，立即停掉了它们。 英特尔运气很好，在精简指令处理器阵营中，群龙无首。 英特尔和AMD的关系英特尔和 AMD 的关系基 本上是既联合又斗争。如果不是反垄 断法的约束，英特尔很可能已经把 AMD 击垮或者收购了。另外，英特尔和 AMD 的关系基 本上是既联合又斗争。 英特尔并没有想彻底把 AMD 打死。因为留着 AMD 对它利大于弊。 首先，它避免了反垄断的很多麻烦。今天 AMD 的股值只有英特尔的 5%，后者靠手中的现 金就足以买下前者。但是，英特尔不能这么做，否则会有反垄断的大麻烦。其次，留着 AMD 这个对手对英特尔自身的技术进步有好处。 AMD 不同于英特尔以往的对手，它从来没有另起炉灶做一种和英特尔不同的芯片，而是 不断推出和英特尔兼容的、更便宜的替代品。 填补艰难当一个公司的市场份额超过 50% 以后，就不用再想去将市场份额翻番了。 英特尔虽然雄霸个人电脑处理器市场，但随着个人微机市场的饱和，它远景不容乐观。 从某种程度上讲，它是反摩尔定理最大的受害者，因为处理器的价格在不断下降。同时，它 在新市场的开拓上举步艰难，很难摆脱“诺威格效应”的阴影。好在英特尔同时也是安迪-比尔 定理的直接受益者，在可以预见的将来，它的发展很大程度上必须依赖于微软等公司软件的 更新。 互联网的金门大桥（思科）好风凭借力思科公司的图标正是旧金山的金门大桥，创始人的意思是要建起连接不同网络的桥梁。 由斯坦福大学的一对夫妇创办，这对夫妇恐怕开始也没有想到以后思科能变成世界上最大的设备制造商。 思科早期成功的关键在于它的两个创始人在最合适的时机创办了一个世界上最需要的公司。假如 思科早创立两年，它可能在市场还没有起来时就烧完了它的投资而关门了，反过来也一样， 如果它迟了两年，就可能被别的公司占了先机。在思科还是一个小公司时，各大计算机公司 各自有自己很大的市场，它们首先想的是在网络市场上打败对手们而不是研制包容各公司网 络产品的路由器，因此，没有公司和思科争夺多协议路由器的市场。而等到互联网兴起时， 思科已经占据了路由器市场的领先地位。 思科的幸运正好和以朗讯为代表的传统电信公司的不幸互补，互联网的兴起，使得世界上数据传输量急剧增加，而语音通话量下降。 思科的办法很像在大航海时代西班牙和葡萄牙国王对待探险者的做法。那时，包括哥伦 布和麦哲伦在内的很多航海家都得到了王室的资助。 思科具体的做法是，如果公司里有人愿意自己创业，公司又觉 得他们做的东西是好东西，就让他们留在公司内部创业而不要到外面去折腾，而思科会作为 投资者而不再是管理者来对待这些创业的人。一旦这些小公司成功了，思科有优先权把它们 买回来，思科的地盘就得到扩大。而这些独立的小公司的创办者和员工，又可以得到很高的 回报。这样本来想离开思科出去创业的人也就不用麻烦了，接着上自己的班，只是名以上换 了一家公司。当然，如果这些小公司没办好关门了，那么思科除了赔上一些风险投资的钱， 没有额外的负担。这种做法不仅调动了各种员工尤其是早期员工的积极性，也避免这些员工 将来成为自己的对手或者加入对手的阵营。 思科通过这种做法，基本上垄断了互联网路由器和其它重要设备的技术。因为一旦有更 新更好的技术出现，思科总是能有钱买回来。如果说微软是赤裸裸地直接垄断市场，那么思 科则是通过技术间接垄断了互联网设备的市场。 既然思科这种办法证明有效，为什么别的公司学不来。当然这一方面因 为并非所有公司的领袖都有思科 CEO 钱伯斯(John Chambers)的胸怀和远见卓识，更重要 的是思科的基因使然。思科自己的创建就是用到了两个创始人的职务发明。 另外，思科员工的发明，一般很难单独成为一种产品，而必须应用到现有 网络通信系统或设备中，因此它们最好的出路就是卖给思科。所以，思科倒是不怕这些小公 司将来反了天。 竞争者思科真正的竞争对只有一假一真两个。让我们先来看看假的—Juniper Networks。这个公 司基本上是思科的影子公司，相当于 AMD 对英特尔的地位。Juniper 的产品定位在高端，而 不像思科从小到 IP 电话机，大到高端路由器都做。 思科真正的对手是中国的小弟弟华为。 中国制造”的效应。它基本的影响是，当一个原本只能在美欧生产的产品，经过一段时间则可以过渡到日本和韩国，进而落脚于中国。 美欧公司能赚钱的时间只有从美国到中国这段时间差，以前这段时间可以长达数十年，现在 只有几年。一旦一项产品可以由中国制造，那么它的利润空间就会薄到让美欧公司退出市场。 诺威格定理的宿命谷歌研究院院长彼得.诺威格博士说，当一个公司的市场占有率超过50%以后，就不要再指望在市场占有率上翻番了。 硅谷的见证人（惠普公司）昔日的硅谷之星由两个斯坦福的毕业生创办。 斯坦福工业园(Stanford Industrial Park)，惠普公司成为进驻工业园的第一批公司。惠普公司的从这里起步，生意得到 了长足的发展，很多公司也随着进驻斯坦福工业园。到了计算机时代，由于这些公司大多从 事和半导体有关的技术，从此这里便被称为硅谷。而斯坦福大学，不但度过了难关，而且从六十年代起，一跃成为世界顶尖名校。惠普则成为硅谷神话的典型代表。 几十年来，惠普和斯坦福互相提携，堪称厂校合作的典范。惠普从斯坦福获得了无数优秀毕业生，同时在财政上给予斯坦福极大的支持。就是在很长时间里，惠普是斯坦福最大的 捐助者，包括帕克特捐给斯坦福电子工程系的系馆。 如果在九十年代 初问一问硅谷最有名的公司是哪一家，十个人中有十个会回答惠普。当时，惠普是很多斯坦 福学生首选的工作公司。 九十年代后期，惠普经历了不很成功的转型，这个曾经辉煌的硅谷巨星渐渐黯淡下来了。 有争议的生死抉择惠普衰落的原因大致有两个，领导者的错误和“日本/中国制造”的冲击。 一般来讲，公司会卖出利润率低的、对自己没有用的，前景不好的部门并买进对公司长 远发展有帮助的公司，比如郭士纳领导下的 IBM 就是这样。但是，惠普接下来的发展史上最 大的两次拆分和并购，却是反其道而行之，因此科技界和华尔街至今很有争议。 应该讲，1999 年的惠普虽然大，但是并不强。这有点像中国战国时候的楚国。惠普的董 事会当然希望把惠普搞得强大。它必须决定分出去哪个部门，保留哪个部门。医疗仪器部门 虽然利润率高，但是在 GE 的打压下发展有限，经过长期酝酿，才决定将科学仪器和医疗仪器 部门都分出去，成立一个新的公司安捷伦，然后新的惠普好集中精力于计算机行业。这么大 的公司重组当然要有个有经验的人来执行，惠普公司董事会看中了菲奥莉娜拆分和并购公司 的经验，破例选择了她出任硅谷最老的惠普公司的 CEO ，来实施安捷伦上市的事宜。 亚洲制造的冲击从 2003 、2004 年起，整个硅谷开始复苏，很多公司回到并超过 2000 年的水平。但是， 惠普一点没有好转的迹象。华尔街不断看空惠普的股票，忍无可忍的股东们终于决定赶走毫 无建树的菲奥莉娜。根据美国公司的惯例，惠普提供给她一笔丰厚的退休金，然后由她自己 提出辞职，这样大家面子上都好看。菲奥莉娜临走还从惠普投资者手中拿走了上亿美元的现 金和股票。但是，股东们宁可花钱请她走。菲奥莉娜离职的当天，惠普的股票大涨了 10% 。 这是一次惨痛的教训，它说明如果一个公司不能挑选好掌舵人，以后替换掉他成本也是很高 的。 惠普虽然是一个大公司，但是它从来没有领导过哪次技术浪潮。因此，它开创出一个新 行业的可能性不大。(它不同于苹果，后者从来就有创新的基因，因此可以完成从微机到 iPod 再到 iPhone 的过渡。前者则很难转型。)它是当年以半导体和计算机硬件为核心时代的硅谷 的代表，而今天的硅谷，半导体已经变得越来越不重要了。惠普已经不能代表今天硅谷的潮 流了，这也是我在开始时讲惠普是黯淡了的巨星的原因。 下一个帝国——谷歌公司长期以来，硅谷的公司在对决微软时都会处于下风，不仅在市场上被挤占，而且在人才争夺战中也会被微软挤压。从苹果到网景公司，他们都被微软后来居上，然而最终有一个公司从小发展，直至虎口拔牙，终于这家公司有资本正面对决微软了，那就是谷歌公司。 谷歌公司的成立也离不开20世纪末的互联网泡沫，当时还在学校读博士的拉里·佩奇和谢尔盖·布林面对时代的浪潮，他们觉得自己应该做点什么，他们瞄准了新兴的搜索引擎业务，于是谷歌成立。 谷歌英文名Google，原意为一个非常大的数字Googol，即10的一百次方，“实际上宇宙中都没有任何事物能有这么大，甚至宇宙中全部的基本粒子数目也没有这么多，佩奇和布林用这个数字的用意为，他们的搜索引擎很大。 1997年9月，佩奇和布林注册了google.com的域名，然而此时二人只能靠刷信用卡度日，于是他们去寻找投资人，找到了同为斯坦福大学的校友、太阳公司创始人安迪·贝托谢姆。 贝托谢姆看到二人展示的搜索技术，果断决定给他们10万美元的支票。虽然这笔钱看起来不多，然而这在无形中给新兴的谷歌公司做了一次成功的广告。 同时斯坦福大学也向佩奇和布林伸出了援手，为其提供了专利，同时成为谷歌的股东。而为了更好发展，佩奇和布林休学，去进行光荣的创业之旅了。 他们在进行创业之旅的时候”顺走“了另一个技术大牛——克雷格·希尔福斯坦，”他几乎一个人写出了谷歌的第一个商业版本……而早期佩奇和布林忙于商业筹资，技术上只剩下了这个技术大牛。 随着业务发展，谷歌开始招人了，佩奇等人认为谷歌要坚持宁缺毋滥，每招一个人必须所有人同意才行，而且进去谷歌的人必须以一挡百，正是这一个个精英，谷歌才能成为今天的谷歌。谷歌前工程副总裁毫不讳言：“我们只需要天才。” 另外谷歌坚持精英战略， “杀鸡就是要用牛刀。”因此谷歌称为全世界单位办公面积博士最集中的地方。”谷歌不仅喜欢招博士，而且特别喜欢大学成绩优异的，这表明这个人自制力强，有责任心，而且一般而言学习好的学生更聪明。 另一方面谷歌在“品质”的坚持上类似于日本公司，它认为为了保持搜索品质，就一定要用更优秀的才人，因为即使一项工作本科生能完成，然而用硕士生效率和质量会更高，这样反而能节省更多的时间。 这样子的谷歌朝气蓬勃，同时也坚持自己“不作恶”的态度，赢得了其他公司的善意。 而当互联网从桌面上向移动端转移的时候，谷歌比微软响应的速度要快，它推出了安卓操作系统，同时在微软擅长的操作系统领域推出了Chrome。 谷歌正在进行新的布局，它已然成为一个帝国。 推动浪潮的三大定律有三大定律主宰IT行业尤其是计算机产业的发展，分别是摩尔定律（Moore’s Law），安迪-比尔定律（Andy and Bill‘s Law）以及反摩尔定律（Reverse Mooore’s Law）。 摩尔定律所谓摩尔定律，就是每过18个月，IT产品的性能会翻一番，或者说相同性能的电子产品，每过18个月价格会下降一半。 这一定律是由英特尔公司创始人戈登·摩尔（Gordon Moore）于1965年提出的。而自从摩尔定律提出以来，计算机行业始终按照摩尔定律的速度向前发展。然而摩尔定律为什么会实现呢？这要归功于IT行业的特殊性。 IT行业与其他行业不太一样的一点在于，它的成本大部分都是研发成本，而在硬件制造上的成本相对来说比例不是很高，它的硬件制造成本主要集中在制造设备上。 可以说摩尔定律主导计算机行业的发展：首先，摩尔定律要实现，硬件制造厂商不得不加快研究速度，在上一代商品出来之后就立马着手下一代产品的研发，而这需要大量的研发资金，因而从某种意义上来说，进入计算机行业有一定的资金壁垒。其次，摩尔定律促使计算机性能得以快速提升，而这为软件的升级提供了硬件上的支持，希望未来计算机行业继续发展，嘻嘻，我想体验更高的网速。 安迪-比尔定律这条定律，顾名思义，安迪——英特尔公司CEO安迪·格鲁夫（Andy Grove）；比尔——微软公司创始人比尔·盖茨，（PS，这一条定律就是赤裸裸的暗示微软-英特尔联盟啊！）这一条定律的产生与摩尔定律有关，如果按照摩尔定律的说法，如果消费者暂时不想花或者不能花很多的钱，他可以等18个月之后花一半的钱去买相同的产品。那这样的话厂商怎么挣钱？这个时候安迪-比尔定律就出现了。按照摩尔定律，过去几十年计算机的硬件性能得到了飞速提升，然而似乎以微软为代表的软件性能貌似提升并不如硬件性能那样多，然而软件占据的空间越来越大，这就逼迫消费者在使用一台计算机之后，由于软件性能的限制，不得不重新购买升级。这听起来一个阴谋，本来电子产品，就像白色家电一样，是耐用消费品，而安迪-比尔定律硬生生的让计算机和手机变成了快消品。然而事实并不是那么简单。几十年前，软件开发人员在编写程序时非常注意程序的大小，他们要充分利用计算机的空间，而现在的软件开发人员，似乎越来越浪费了。 这似乎不能怪罪软件开发人员，因为他们也要人性化，以前的编程的客观要求软件开发人员极低，而现在由于摩尔定律生效，软件工程师可以比较自由地利用硬件资源做自己喜欢的工作。而另一方面由于人力成本的提高，为了编程人员的最大利用化和缩短编程时间，因此编程语言越来越易懂、好用，而编程语言越来越臃肿。 反摩尔定律这一定律是由谷歌前CEO埃里克·施密特提出的，“如果你反过来看摩尔定律，一个IT公司如果今天和十八个月前卖掉同样多的、同样的产品，它的营业额就要下降一半”（吴军）。 这样子下去的话IT公司就很惨了，因为他们花了同样的劳动，却只得到十八个月之前营业额的一半。而反摩尔定律就是硬逼着硬件公司跟上摩尔定律的速度。 反摩尔定律也有积极作用，就是促进IT行业不断寻找质变，而非像传统行业更多的是量变，而且反摩尔定律对新兴的小公司也是有极大好处的，因为在新的浪潮到来之时，新兴小公司和大公司站在同一起跑线。 读后感：看过吴军博士对计算机行业三大定律的介绍，解答了以前的一个疑惑：例如为什么计算机和电脑越用越卡，是不是他们的阴谋？这个问题就是第二条定律能解答的。 行业兴衰的推手——资本幕后英雄——风险投资传统上创业时的资金来源为自己财产积累或借贷。然而年轻人一般没有什么钱，此时资金的不足就成了创业的瓶颈。而敢于冒险的美国人发明了一种非常规多投资方式——风险投资，这种投资不需要抵押，也不需要偿还，如果投资成功，资本家将获得几倍、乃至几十倍上百倍多利润，而不成功，就当交学费了。而这对年轻人太具有了吸引力了，他不用因为创业失败而背上债务，这样年轻人就敢于创业，因此风险资本促使美国成为创业的国度。 科技公司兴衰背后的重要角色——投资银行2008年的那场金融危机，深刻表露出华尔街的贪婪所造成的恶果，同时他们也对科技公司施加着影响：一方面，科技公司上市时的吹捧者，是他们；另一方面，打压科技公司的也是他们。 华尔街——美国的金融中心，这里坐落着诸多金融公司，而这些公司大致分为以下几类：商业银行（类似于我国的工商银行）、投资银行（替别人买卖任何有价值的商品，是股市的主力军）、共同基金公司（掌管美国所有的退休账户和世界上的很多财富）以及对冲基金（著名的有金融大鳄索罗斯的量子基金）。 而其中对科技公司影响最大的乃是投资银行。著名的投资公司有高盛公司（投资银行的NO.1)、摩根斯坦利（美国大银行家摩根创立）等。 风投公司要收回投资，科技公司的从业人员要获得回报，只有两条路可选：第一是被收购；第二是上市。而上市就需要高盛等公司当承包商，承包商以上市价格从被承包的公司收购一定数量的股票，并且以同样的价格分配给它们的客户。而承包商从中获得两笔收入：佣金（包销股票总金额）、以后用上市价购买科技公司一定股份的权利（这笔钱只有当科技公司股票上涨时才有意义）。而当投资银行认为一家科技公司有前途时，其股票会上涨，反之则会下降。股票价格下降对科技公司的影响有时是灾难性的。诚可谓“成也萧何，败也萧何。” 硅谷的摇篮——斯坦福大学硅谷的传奇与斯坦福大学多方位的支持是分不开关系的。很多当今时尚著名的科技公司都是由斯坦福大学的教授和学生创立的。它们包括惠普公司、思科公司、太阳公司、雅虎、谷歌以及英特尔。斯坦福在科技业的这种契机是任何大学都无法比拟的。 首先，按照斯坦福人自己的说法，一个斯坦福等于一个哈佛加麻省理工。这句话粗看略显自大，但实际是有道理的。斯坦福大学在专业设置上人文理工兼修，同时比东岸名校更重视实践。 斯坦福的学生，在这里能够体现更加丰富的多样性，在这里培养了他们创业时需要的沟通能力和团队协作能力。其次，斯坦福大学给予新兴的科技公司以专利和土地。斯坦福大学，其面积的相当大部分都租给了企业，这些企业绝大部分都是高科技企业，同时斯坦福大学也给予自己学校的毕业生和在读生创业上的优惠。 斯坦福大学的这一举动无疑是双赢。这些斯坦福的毕业生们成功之后就会投桃报李，他们会给母校丰厚的捐赠。 怎样做到基业长青——硅谷成功的商业模式 印钞机日本经营之神——松下幸之助有句名言:一个企业必须要盈利，否则就是对全人类的犯罪。因为无法盈利的企业是浪费资源，还不如把这些人力物力用在更需要的地方。因此很多大公司的兴起，不是靠技术的革新，还是靠商业模式的转变，这里吴军博士介绍了硅谷那些成功的商业模式。什么是好的商业模式通常，好的商业模式都非常简单，即使是外行人也能看得清楚。AT&amp;T从事固定电话业务时（19世纪末），就懂得只收服务费而不是高的吓人的安装费，这点中国电信到2000年都不明白，而英特尔开发出比IBM以及惠普更便宜的处理器，分别卖给这些公司，这也是双赢。 相反，如果一种商业模式好几个小时都说不清楚，在巴菲特看来要么是骗人、要不根本不存在。而最理想的商业模式就是如同印钞机一样自动挣钱的模式，这里吴军介绍了三种印钞机模式——谷歌的广告系统、eBay的电子商务系统以及戴尔的微机直销系统。 Google的广告系统谷歌的广告系统大大降低了全国性广告乃至全球广告的门槛，深受中小企业欢迎，另一方面谷歌的技术实力强悍，机器会自动学习，强化个性化广告推荐，这样广告效果更好，广告上自然更加喜欢。 ebay和亚马逊的在线市场而eBay的模式类似于阿里巴巴，坐收卖家和卖家之间的佣金和中介费，只要网上有交易，它就永远会有收入，但有个问题没有解决:就是信用问题和付款问题。付款问题靠PalPal（国外的支付宝）解决，但是信用问题是让eBay头疼的。 戴尔的虚拟工厂第三个是戴尔的虚拟工厂。戴尔自己没有工厂，只有一个商标，它的创始人精简了从设计到零售的环节，精简了不少费用，一度戴尔电脑的市占率为美国第一。 下一个浪潮没有不消亡的帝国，同样也没有永不衰退的企业，浪潮不断推动企业兴衰更替，而从投资银行到求职者，都希望找到下一个浪潮，能站在下一个浪潮之巅的必将是下一个谷歌一般的企业。 吴军博士断言：云计算很可能成为下一个科技浪潮，因为它将使用户摆脱桌面，通过浏览器，借助高速网络和云端服务器，随时随地享受上网的乐趣。（画外音：话说这不是谷歌的笔记本Chromebook吗？到底吴军博士是谷歌的人啊！）”科技产业让人振奋的是，有新一代技术的革命同时拌嘴这新一代公司的诞生，这个时间可能会很长，但终究会来到。而代表新的技术公司有时是新生的，有时却是以前的公司进化而来，不论是哪一种都足以让人振奋。寻找下一个这样的机会，永远是和所有现代生活相关的人追求或谈论的主题。 涨姿势有关罗斯柴尔德家族的阴谋论到底是不是真的？吴军博士的回答：罗斯柴尔德家族早已是过眼云烟，在华尔街眼里，这个家族就是二三流的水平，而美国，这个家族被人认知，还是因为葡萄酒。 按照一些中国作家的观点，一两百年前这个家族的财富作为原始资本，以每年6%的速度递增，现在该家族有几万亿美元，至于为何没有人看到，是因为这个家族的财务不向外界公开。 几万亿美元，相当于整个中国的经济规模，然而金钱只有流动才有可能增值，这么一大笔钱在世界上不可能藏得住。另外这些作者的假设也是错误的。这里可以举个反例：春秋时代的陶朱公，留给后人1两银子，现在应该变成10的60次方两银子，这远比现今世界上所有财富的加总还要多。这显然不可能，既然陶朱公不可能，凭什么罗斯柴尔德家族就可能呢？ 罗斯柴尔德家族衰落与几个大事件有关：第一个，错失19世纪末飞速发展的美国；第二，纳粹德国的抢掠。在华尔街看来，罗斯柴尔德家族的投资公司顶多算三流的投资公司。 硅谷的另一面成王败寇在硅谷创业成功的几率比中六合彩大奖的概率大不了多少，就如同好莱坞的明星带给了无数少男少 女的明星梦一样。这正是风险投资资本家和华尔街所希望的。只有越来越多的人加入这种创 业的游戏，投资者才能有好的项目投资。 毕竟，硅谷的 竞争太残酷了，成功的机会太低了。我有时会开玩笑地说“如果你不相信这辈子会被汽车撞死， 为什么相信能中硅谷大奖?后者的可能性更小。”他们会开玩笑地说:“也许是利令智昏吧。” 小公司想要成功，有很多因素必须同时具备。 创始人很重要，所有的成功者都是实干家。成功的创业者必须有一个小而精的好团队，里面每个 人都得不计较个人得失，同甘共苦，否则成则争功，败则互相推诿。在技术上，他们必须有 自己的金刚钻，他们的技术必须是不容易被别人学会和模仿的。 但是光有好的团体和技术又远远不够，他们有商业头脑而且必须找到一个能盈利的商业 模型(Business Model)。 再接下来是判断力和执行力。 外部环境。 运气。 硅谷汇集了美国三、四成的风险投资，每天硅谷都有成百上千的公司成立，但同时又有 成百上千的公司关门。对于那些失败的公司，大家并不关心，甚至无人知道它们的存在。即 使很多曾经辉煌过的公司，像网景公司、SGI 公司，人们很快也就忘却了它们。在这些成千 上万家硅谷的公司中，最终创造出了一些像思科、谷歌那样的传奇故事。仿佛间在硅谷办一 个公司就能成一个。岂不知，一将功成万骨枯，无数失败的公司在为少数几个成功者做分母。 嗜血的地方在硅谷，加班很正常，与国内有过之而无不及。但是薪水却不是线性的增长，所以单位时间的薪水反而少了。 硅谷就是这样一个“嗜血”的地方。坦率地讲，硅谷的生活质量达不到美国的平均水平。 机会均等硅谷能成为科技之都，而且长盛不衰，必有它高明之处。其中最关键的一条是保证机会 均等。任何人、任何国家和制度都无法保证我们的社会绝对公平，(事实上也没有必要追求绝 对公平。)但是，一个好的制度要保证每个人有均等的机会。 硅谷是一个到处可见权威却从不相信权威的地方。 任何人要想在这里获得成功，都得真刀真枪地拿出真本事 干出个样子。在美国很多地方，尤其是传统产业中，普遍看中甚至过于看重个人的经历 (Resume)而不是做事情的本领。 在硅谷谋职，简历固然重要， 但是个人的本事(包括和人打交道的软本领)才是各个公司真正看中的。由于每个公司产品 的压力很大，同行业公司之间的淘汰率很高，硅谷的公司需要的不是指手画脚的权威而是实 实在在干事情的人。 对创业者来讲，资历固然有用，但就重要性而言远排不进前几位。名气大、职位高的创 业者经验丰富、交际广，容易找到钱和市场，但是闯劲远不如初出茅庐的牛犊那么足。在风 险投资家看来，一个人的能力，包括处理人际关系的“软”能力(Soft Skills)是决定创业成败 的关键。一个人的职位只代表过去，而财富和地位有时反而成为创业的负担。这也是为什么 硅谷很多著名的公司如思科、苹果、Yahoo 和谷歌，包括中国人创办的 Netscreen 和 Webex 都 是原来默默无名的年轻人办成的，但是却很少听说那个成功公司是一位原某公司老总办的 。 自古英雄出少年，这是风险投资家们普遍承认的事实。红杉风投的投资家们和我谈过他 们选择投资对象的原则，其中一条就是创业者一定要有饥渴感(Hungry)。很难想象一个腰缠 万贯的富翁能比一个急于脱离贫困现状的缀学生更有把公司办好的可能。因为前者办公司不 过是为了锦上添花而后者则是要置于死地而后生。这就是乔布斯勉励年轻人要保持饥渴感 (Keep Hungry)的原因。关于风险投资家如何选择投资对象我以后还会详述。因此资深创业 者和毫无经验的年轻人各有优势，但是机会均等。硅谷各个层次的成功者几乎无一例外是靠 自己的双手从零干起，获得成功的。 由于有一些淘到金子的“冒险家”—科技新贵，就产生了替他们打理财务的需求，今天旧金 山和硅谷就成为投资银行最集中的地区之一。 硅谷相对于美国其它地方是机会最多也是最均等的。因此虽然这里工作压力大，竞争激 烈，还是不断有人愿意来。全世界很多国家想学习硅谷建立自己的科技园，但是至今没有一 个能像硅谷这么成功的。我想这些科技园的管理者们，也许首先应该问问自己是否为创业者 提供了同等的机会，还是将人按照财富、经历、名气预先分为了三六九等。(我对一些科技园 按照学历、职称引进人才和投资额招商很不以为然。) 自古英雄不问出处，今天落魄的学子可能就是明天业界的领袖。 硅含量不断降低今天知道仙童公司的人已经不多了，但它在半导体历史上占据着独一无二的地位。 硅谷没有了硅，那么留下了什么呢? 亘古而常青半导体并不是硅谷真正的本质。硅谷的灵魂是创新。硅没有了，创新的灵魂留下了，它保证了硅谷的繁荣和发展。 在硅谷的人，不论是投资者还是创业者，已经习惯了这种快速的产业变迁，人们不断在 寻找着下一个思科、下一个 Google 。其实，硅谷的创新并不局限于 IT 领域。生物科技无疑 是硅谷另一个亮点。今天的硅谷，也是世界上新兴生物公司最集中的地方。 创新必须依靠技术实力。和 Google 一样，基因科技也是世界上单位办公面积博士密度最 高的公司。就连它的七名董事中都有五名博士，九名执行官中也有六名博士。基因科技里的 科学家在同行中是佼佼者，在公司内部地位也很高。 美国的专利保护机制，一个药物只有一段时间的专利保护期，这一段时间用于回收成本，过了一段时间就不保护。对于药厂来说，必须不断的推出新药，而不能躺在功劳簿上吃一辈子。 与机会失之交臂的公司太阳公司太阳公司不乏能人，它不仅为 Google 培养了 CEO 埃里克.施密特和首任工程部副总裁韦恩.罗森(Wayne Rosen)，并且在一定程度上奠定了今天 Google 工程部门的基础。 太阳公司从 1982 年成立到 2000 年达到顶峰用了近二十年时间，而走下坡路只用了一年，足以令经营者为戒。 太阳公司名称的由来很多人不知道，它其实是斯坦福大学校园网(Stanford University Network)的首字母缩写。 太阳公司，它的操作系统 Solaris 在技术上比 Windows NT 有明显的优势。 包括 Solaris 在内的 各种 Unix 操作系统比 Windows NT 能更好地利用计算机资源，尤其是当计算机系统庞大、 用户数量巨大增加时。对太阳来讲，取胜的关键在于是否能将它在 Unix 上的技术优势转换为市场优势。 马可尼里等人的“思维”锁定在卖硬件上了。虽然太阳公司的工作站当年每台要上万美元、服务器要十万美元，但是比 DEC 的小型机和 IBM 的大型机便宜多了。在九十年代末由于互联网的兴起，太阳公司的服务器和工作站销路太好了、太挣钱了。虽然太阳公司的中小企业市场份额不断 被微软/英特尔联盟侵蚀，但是它也在不断占领原来 DEC 和 HP 小型机的市场并有足够的处女地可以开发。这很像十六世纪的西班牙王国，虽然它 的无敌舰队已经被英国人打败了，并失去了海上霸主的地位，但是由于世界上可殖民的处女地仍然很多，支撑着这个海上老二繁荣了两个世纪，直到十九世纪全世界再无殖民地可开拓 时，西班牙早期埋下的危机才表现出来。当然，衰落要比繁荣来得快。 Novell公司虽然 Novell 采用的是 DRDOS， 但是用户使用起来和微软的 MSDOS 一模一样，对程序开发者来讲也是一样。Novell 无疑是 在帮助微软和 UNIX 争夺企业级的市场。当时，微软在网络操作系统上毫无可圈点之处，它 甚至临时性地选择了 IBM 的 OS/2 LAN Server 来抵消 Novell 在网络上的优势，但是 OS/2 LAN Server 从来就没有成为过一种主流的网络操作系统。 从 1995 年起，微软和 Novell 之争起了质的变化。微软一年前推出的 Windows NT 对 Novell 的影响开始显现出来了。用户已经从 DOS 转向了 Windows，Novell 的操作系统对微 软的 Windows NT 几乎没有优势可言。很难想象一个局域网在其网络服务器上安装 Novell 的操作系统，同时在联网的微机上使用 Windows 。显然从服务器到微机一律采用微软的 Windows 是更好的办法，这时胜利的天平开始向微软倾斜，并成为不可逆转的趋势。 网景公司其网络浏览器被微软公司通过捆绑ie浏览器给打败了。 real networks播放器同理。 成功的转基因道琼斯的常青树（3M）3M 公司至今发明了六万种大大小小的产品，全世界有一半的人每天直接或者间接地接触 3M 的产品。该公司营业额中有三分之一来自于近五年的发明，其中相当大的一部分是员工利 于工作时间从事非工作的研究搞出来的。3M 允许员工用 15% 的时间干任何自己喜欢做的 事，后来这个做法被 Google 学去了，变成了 Google 的“百分之二十项目”。在最具有创新力 的公司里，3M 的排名更在 Google 和苹果这些以创新而闻名的公司前面。 世界最大的联合体（GE）今 天的 GE 是全球最大的联合体，到 2007 年底，它包括六大部门，每个部门如果独立，在各自的领域都是佼佼者。 信息产业的规律性70 20 10律一般在全球容不下三个以上的主要竞争者。这个行业一定有一 个老大，斯库利把它比喻成一个猴王，它是这个行业的主导者。毫无疑问，它虽然想顺顺当 当地统领好整个行业，就像猴王想让猴子们永远臣服一样，但是，它一定会遇到一两个主要 的挑战者，也就是老二(也许还有一个老三)。剩下来的是一大群小商家，就像一大群猴子。 老大是这个领域的主导者，不仅占据着超过一半，通常是百分之六七十的市场，并且制定了 这个领域的游戏规则。老二有自己稳定的百分之二三十的市场份额，有时也会挑战老大并给 老大一些颜色看看，但是总的来讲是受老大欺负的时间多。剩下的一群小猴子数量虽然多， 但是却只能占到百分之十甚至更少的市场，它们基本上唯老大马首是瞻。老大总是密切注视 着老二，并时不时地打压它，防止它做大。老大和老二通常都不会太在意剩下的小企业，这 样就让这一群小的企业能有挣一些小钱的地方。这里面的百分比数字 70、20 和 10 是我加 的，因为信息产业大公司之间的市场份额大抵如此。 诺维格定理当一个公司的市场占有率超过 50% 后，就无法再使市场占有率翻番了。 基因决定定理一个公司可以不相信基因的决定性，但是最终无法摆脱它的影响。 估值与创始人公司上市估值过高与过低都不好。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"商业","slug":"商业","permalink":"https://github.com/zdkswd/tags/商业/"}]},{"title":"petri网理论及其应用 0 形式化表示","slug":"petri网理论及其应用 0 形式化表示","date":"2018-09-13T11:09:56.000Z","updated":"2018-09-13T11:19:33.000Z","comments":true,"path":"2018/09/13/petri网理论及其应用 0 形式化表示/","link":"","permalink":"https://github.com/zdkswd/2018/09/13/petri网理论及其应用 0 形式化表示/","excerpt":"","text":"petri网理论及其应用 0 形式化表示楔子热点必须要了解，结合趋势。 为什么要形式化方法形式化方法的研究高潮始于 20世纪60年代后期，针对当时所谓“软件危机”,人们提出种种解决方法,归纳起来有两类：一是采用工程方法来组织、管理软件的开发过程；二是深入探讨程 序和程序开发过程的规律，建立严密的理论，以其用来指导软件开发实践。前者导致“软件工程”的出现和发展，后者则推动了形式化方法的深入研究。 形式化方法的基本含义是借助数学的方法来研究CS中的有关问题。目的是为开发过程提供一些技术和工具，用于发现并指出软件实现中潜在的缺陷问题。数学是完美的，无二义性的，可以用在航空航天工程中，当然工业界也在慢慢的从软件测试逐步变为形式化方法。 什么是形式化方法根据表达能力，形式化方法可以分为五类： 基于模型的方法：通过明确定义状态和操作来建立一个系统模型（使系统从一个状态转换到另一个状态）。用这种方法虽可以表示非功能性需求（诸如时间需求），但不能很好地表示并发性。如：Z语言，VDM，B方法等。 基于逻辑的方法：用逻辑描述系统预期的性能，包括底层规约、时序和可能性行为。采用与所选逻辑相关的公理系统证明系统具有预期的性能。用具体的编程构 造扩充逻辑从而得到一种广谱形式化方法，通过保持正确性的细化步骤集来开发系统。如：ITL（区间时序逻辑），区段演算（DC），hoare 逻辑，WP演算，模态逻辑，时序逻辑，TAM（时序代理模型），RTTL（实时时序逻辑）等。 代数方法：通过将未定义状态下不同的操作行为相联系，给出操作的显式定义。与基于模型的方法相同的是，没有给出并发的显式表示。如：OBJ， Larch族代数规约语言等； 进程代数方法：通过限制所有容许的可观察的过程间通信来表示系统行为。此类方法允许并发过程的显式表示。如：通信顺序过程（CSP），通信系统演算 （CCS），通信过程代数（ACP），时序排序规约语言（LOTOS），计时CSP(TCSP），通信系统计时可能性演算（TPCCS）等。 基于网络的方法：由于图形化表示法易于理解，而且非专业人员能够使用，因此是一种通用的系统确定表示法。该方法采用具有形式语义的图形语言，为系统开发和再工程带来特殊的好处。如 Petri图，计时Petri图，状态图等。 形式化语言与自动机以四类形式语言（短语结构语言、上下文有关语言、上下文无关语言、正则语言） 四种自动机（有穷自动机、下推自动机、图灵机、线性有界自动机） 自动机自动机是有限状态机(FSM)的数学模型。 在编译当中有所应用。自动机描述的是顺序的，线性的。 有限自动机是指有限个状态，在语法，词法分析中有用到。编译解决的主要是上下文无关文法，日常生活中所用的语言是上下文有关的文法。科大讯飞在解决日常语言识别时使用到了大数据。 λ-演算与图灵机这两者是等价的，都是回答了计算机可计算的边界这一问题。 不同的是，λ-演算使用的是数学的演算，而图灵机则是具有了一个物理的模型。","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"https://github.com/zdkswd/categories/课堂笔记/"}],"tags":[{"name":"petri网","slug":"petri网","permalink":"https://github.com/zdkswd/tags/petri网/"}]},{"title":"人工智能第一课","slug":"人工智能第一课","date":"2018-09-13T08:49:32.000Z","updated":"2018-09-13T08:54:01.000Z","comments":true,"path":"2018/09/13/人工智能第一课/","link":"","permalink":"https://github.com/zdkswd/2018/09/13/人工智能第一课/","excerpt":"","text":"考核方式 学术组织，会议 刊物 作业","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"https://github.com/zdkswd/categories/课堂笔记/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://github.com/zdkswd/tags/人工智能/"}]},{"title":"Python廖雪峰 IO编程 进程和线程 正则表达式","slug":"Python廖雪峰 IO编程 进程和线程 正则表达式","date":"2018-09-13T08:46:56.000Z","updated":"2018-09-13T08:46:53.000Z","comments":true,"path":"2018/09/13/Python廖雪峰 IO编程 进程和线程 正则表达式/","link":"","permalink":"https://github.com/zdkswd/2018/09/13/Python廖雪峰 IO编程 进程和线程 正则表达式/","excerpt":"","text":"IO编程IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。 比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。 IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。 由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法： 第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO； 另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。 很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。 操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。 注意，本章的IO编程都是同步模式，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。 文件读写读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。 读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。 读文件要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符： 1f = open(&apos;/Users/michael/test.txt&apos;, &apos;r&apos;) 标示符’r’表示读，这样，我们就成功地打开了一个文件。 如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在。 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示。 最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。 1f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现。 123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法。 12with open('/path/to/file', 'r') as f: print(f.read()) 这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便。 file-like Object像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。 StringIO就是在内存中创建的file-like Object，常用作临时缓冲。 二进制文件前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可。 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)&gt;&gt;&gt; f.read()b&apos;\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...&apos; # 十六进制表示的字节 字符编码要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件。123&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')&gt;&gt;&gt; f.read()'测试' 写文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件。123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)&gt;&gt;&gt; f.close() 你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险。12with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;) 要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。 以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入’a’以追加（append）模式写入。 StringIO和BytesIOStringIO很多时候，数据读写不一定是文件，也可以在内存中读写。 StringIO顾名思义就是在内存中读写str。 要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可。12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()方法用于获得写入后的str。 要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取： 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO('Hello!\\nHi!\\nGoodbye!')&gt;&gt;&gt; while True:... s = f.readline()... if s == '':... break... print(s.strip())...Hello!Hi!Goodbye! BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes。 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 请注意，写入的不是str，而是经过UTF-8编码的bytes。 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取。 1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')&gt;&gt;&gt; f.read()b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。 操作文件和目录操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。 打开Python交互式命令行，我们来看看如何使用os模块的基本功能。 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.name # 操作系统类型'posix' 要获取详细的系统信息，可以调用uname()函数。 环境变量在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看。 要获取某个环境变量的值，可以调用os.environ.get(‘key’)。 操作文件和目录操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：12345678910# 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)&apos;/Users/michael&apos;# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)&apos;/Users/michael/testdir&apos;# 然后创建一个目录:&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)# 删掉一个目录:&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;) 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。 同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。 os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便。 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。 文件操作使用下面的函数。假定当前目录下有一个test.txt文件。 1234# 对文件重命名:&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)# 删掉文件:&gt;&gt;&gt; os.remove(&apos;test.py&apos;) 但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，读写文件就可以完成文件复制。 shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。 我们要列出当前目录下的所有目录，只需要一行代码：12&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)]['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...] 要列出所有的.py文件，也只需一行代码：12&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py'] 序列化我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 Python提供了pickle模块来实现序列化。 把一个对象序列化并写入文件：1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)&gt;&gt;&gt; pickle.dumps(d)b'\\x80\\x03&#125;q\\x00(X\\x03\\x00\\x00\\x00ageq\\x01K\\x14X\\x05\\x00\\x00\\x00scoreq\\x02KXX\\x04\\x00\\x00\\x00nameq\\x03X\\x03\\x00\\x00\\x00Bobq\\x04u.' pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：123&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close() 看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。 当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。 12345&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125; 当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。 Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。 由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。 JSON进阶Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化，但是Student对象不是一个可序列化为JSON的对象。 123456def student2dict(std): return &#123; 'name': std.name, 'age': std.age, 'score': std.score &#125; 这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：12&gt;&gt;&gt; print(json.dumps(s, default=student2dict))&#123;\"age\": 20, \"name\": \"Bob\", \"score\": 88&#125; 我们可以偷个懒，把任意class的实例变为dict：1print(json.dumps(s, default=lambda obj: obj.__dict__)) 因为通常class的实例都有一个dict属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了slots的class。 同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例。 12def dict2student(d): return Student(d['name'], d['age'], d['score']) 123&gt;&gt;&gt; json_str = '&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x10cd3c190&gt; 进程和线程对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。 多进程Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程。 由于Windows没有fork调用，上面的代码在Windows上无法运行。由于Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的，推荐大家用Mac学Python！ 有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。 multiprocessing针对Windows没有fork，由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。 multiprocessing模块提供了一个Process类来代表一个进程对象。 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 Pool如果要启动大量的子进程，可以用进程池的方式批量创建子进程。 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 Pool的默认大小是CPU的核数。 子进程subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。 进程间通信Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。 在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。 多线程多任务可以由多进程完成，也可以由一个进程内的多线程完成。 由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。 Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。 由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…… Lock多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 创建一个锁就是通过threading.Lock()来实现。 当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。 获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。 锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。 多核CPUPython的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。 所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。 不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。 ThreadLocal在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。 但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦。 一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。 进程 vs 线程要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。 如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。 如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。 多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。 在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。 线程切换无论是多进程还是多线程，只要数量一多，效率肯定上不去。 切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。 计算密集型 vs. IO密集型是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。 第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。 IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 异步IO考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。 现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。 对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。 分布式进程在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。 Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。 举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？ 原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。 服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务。 请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。 这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。 Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。 注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。 正则表达式规则和javascript一样，实现形式通过re模块来实现。 re模块由于Python的字符串本身也用\\转义，所以要特别注意。 因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了。 match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。 切分字符串用正则表达式切分字符串比用固定的字符更灵活。在split（）函数中可以使用正则表达式。 分组除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。 注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。 贪婪匹配正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。 和javascript一样，加个?就可以让\\d+采用非贪婪匹配。 编译当我们在Python中使用正则表达式时，re模块内部会干两件事情： 编译正则表达式，如果正则表达式的字符串本身不合法，会报错； 用编译后的正则表达式去匹配字符串。 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/zdkswd/tags/Python/"}]},{"title":"Python廖雪峰 面向对象 异常处理","slug":"Python廖雪峰 面向对象 异常处理","date":"2018-09-02T07:00:56.000Z","updated":"2018-09-24T06:16:52.000Z","comments":true,"path":"2018/09/02/Python廖雪峰 面向对象 异常处理/","link":"","permalink":"https://github.com/zdkswd/2018/09/02/Python廖雪峰 面向对象 异常处理/","excerpt":"","text":"面向对象编程类和实例在Python中，定义类是通过class关键字。 通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 创建实例是通过类名+()实现的。 可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性。 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的init方法，在创建实例的时候，就把name，score等属性绑上去。 注意到init方法的第一个参数永远是self，表示创建的实例本身。 有了init方法，在创建实例的时候，就不能传入空的参数了，必须传入与init方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 数据封装我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。 定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入。 封装的另一个好处是可以给Student类增加新的方法。 访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。 从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性。 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 已经无法从外部访问实例变量.__name和实例变量.__score了 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。 总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。 对私有数据操作用getter以及setter啦。 继承和多态继承有什么好处？最大的好处是子类获得了父类的全部功能。 当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。 多态真正的威力：调用方只管调用，不管细节。 当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则。对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 静态语言 vs 动态语言对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 12维基百科在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。 获取对象信息使用type()判断对象类型，使用type()函数。基本类型都可以用type()判断，如果一个变量指向函数或者类，也可以用type()判断。返回对应的Class类型。 判断一个对象是否是函数怎么办？可以使用types模块中定义的常量。 使用isinstance()对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。 isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。 使用dir()如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list。 类似xxx的属性和方法在Python中都是有特殊用途的，比如len方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的len()方法。 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。 屏幕快照 2018-08-31 下午4.30.39 实例属性和类属性由于Python是动态语言，根据类创建的实例可以任意绑定属性。 给实例绑定属性的方法是通过实例变量，或者通过self变量。 可以直接在class中定义属性，这种属性是类属性，归Student类所有。 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。 面向对象高级编程使用slots正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。 为了给所有实例都绑定方法，可以给class绑定方法。 动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。 Python允许在定义class的时候，定义一个特殊的slots变量，来限制该class实例能添加的属性。 使用slots要注意，slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。 使用@property在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改。 这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数。 调用方法又略显复杂，没有直接用属性这么直接简单。 对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法（图中为getter方法）变成属性调用的。 @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作。 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性。 多重继承 MixIn MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。 这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。 由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。 只允许单一继承的语言（如Java）不能使用MixIn的设计。 定制类__str__定义好str()方法，返回一个好看的字符串就可以了。 这是因为直接显示变量调用的不是str__()，而是repr__()，两者的区别是str__()返回用户看到的字符串，而repr__()返回程序开发者看到的字符串，也就是说，repr()是为调试服务的。 解决办法是再定义一个repr__()。但是通常str__()和repr()代码都是一样的，所以，有个偷懒的写法。 __iter__ 如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 __getitem__要表现得像list那样按照下标取出元素，需要实现getitem()方法。 但是如果想要正确实现一个getitem()还是要有很多工作要做的。 此外，如果把对象看成dict，getitem()的参数也可能是一个可以作key的object，例如str。 与之对应的是setitem、__()方法，把对象视作list或dict来对集合赋值。最后，还有一个delitem__()方法，用于删除某个元素。 总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。 __getattr__正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。 要避免这个错误，Python还有另一个机制，那就是写一个getattr()方法，动态返回一个属性。 当调用不存在的属性时，比如score，Python解释器会试图调用getattr(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值。 返回函数也是完全可以的。 注意，只有在没有找到属性的情况下，才调用getattr，已有的属性，比如name，不会在getattr中查找。 此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的getattr默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误。 __call__一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。 任何类，只需要定义一个call()方法，就可以直接对实例进行调用。 __call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。 如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。 更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有call()的类实例。 通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。 使用枚举类Python提供了Enum类。 使用元类type()动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。 我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。 type()函数既可以返回一个对象的类型，又可以创建出新的类型。 要创建一个class对象，type()函数依次传入3个参数。 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。 metaclass除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。 metaclass，直译为元类，简单的解释就是，当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。 先定义metaclass，就可以创建类，最后创建实例。metaclass允许你创建类或者修改类，可以把类看成是metaclass创建出来的“实例”。 按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass。 metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。 编写ORM会用到。 错误、调试和测试错误处理try 当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。 可以有多个except来捕获不同类型的错误。 可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。 Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。 调用栈如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。 出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。 记录错误Python内置的logging模块可以非常容易地记录错误信息。 同样是出错，但程序打印完错误信息后会继续执行，并正常退出。 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。 抛出错误因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。 如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例。 只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。 raise语句如果不带参数，就会把当前错误原样抛出。 捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。 调试第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看 用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。 断言凡是用print()来辅助查看的地方，都可以用断言（assert）来替代。 assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。 如果断言失败，assert语句本身就会抛出AssertionError。 程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert。 关闭后，你可以把所有的assert语句当成pass来看。 logging把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件。 这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。 logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 pdb第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。 以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt; s = ‘0’。输入命令l来查看代码。 输入命令n可以单步执行代码。 任何时候都可以输入命令p 变量名来查看变量。 这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。 pdb.set_trace()这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点。 运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行。 IDE如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有，Visual Studio Code，需要安装Python插件。PyCharm。 单元测试单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的 为了编写单元测试，我们需要引入Python自带的unittest模块。 编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。 以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。 对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()。 运行单元测试 文档测试如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。 可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。 Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/zdkswd/tags/Python/"}]},{"title":"Python廖雪峰 高级特性 函数式编程 模块","slug":"Python廖雪峰 高级特性 函数式编程 模块","date":"2018-08-31T07:00:56.000Z","updated":"2018-09-24T08:34:55.000Z","comments":true,"path":"2018/08/31/Python廖雪峰 高级特性 函数式编程 模块/","link":"","permalink":"https://github.com/zdkswd/2018/08/31/Python廖雪峰 高级特性 函数式编程 模块/","excerpt":"","text":"高级特性切片取数组前3个元素，用一行代码就可以完成切片。 从索引0开始取，直到索引3为止，但不包括索引3。 如果第一个索引是0，还可以省略。 Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片。 后10个数，L[-10:]。前10个数，每两个取一个，L[:10:2]。甚至什么都不写，只写[:]就可以原样复制一个list。 tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串。 Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。 迭代当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。 通过collections模块的Iterable类型判断一个对象是可迭代对象。 Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。 for循环里，同时引用了两个变量，在Python里是很常见的。 列表生成式列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))。 列表生成式则可以用一行语句代替循环。 for循环后面还可以加上if判断。 还可以使用两层循环，还可以使用两层循环。 for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value。 生成器创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 如果列表元素可以按照某种算法推算出来，可以在循环的过程中不断推算出后续的元素，就不必创建完整的list。Python中，这种一边循环一边计算的机制，称为生成器：generator。 把一个列表生成式的[]改成()，就创建了一个generator。 通过next()函数获得generator的下一个返回值。 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象。 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。 最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值。 我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代。 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。 迭代器可以直接作用于for循环的对象统称为可迭代对象：Iterable。如集合数据类型，如list、tuple、dict、set、str等，generator，包括生成器和带yield的generator function。 可以使用isinstance()判断一个对象是否是Iterable对象。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象。 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数。 Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。所以list、dict、str等数据类型不是Iterator。 函数式编程高阶函数map/reducePython内建了map()和reduce()函数。 map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 所以，map()作为高阶函数，事实上它把运算规则抽象了，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list。 reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。 假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！ filterPython内建的filter()函数用于过滤序列。 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 sorted排序算法Python内置的sorted()函数就可以对list进行排序。 sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序。 key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。 从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。 返回函数函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 闭包返回的函数并没有立刻执行，而是直到调用了f()才执行。 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 匿名函数匿名函数lambda x: x * x实际上就是 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。 同样，也可以把匿名函数作为返回值返回，比如。 装饰器由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。 函数对象有一个name属性，可以拿到函数的名字。 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。 本质上，decorator就是一个返回函数的高阶函数。 我们要定义一个能打印日志的decorator，可以定义如下。 我们要借助Python的@语法，把decorator置于函数的定义处。 把@log放到now()函数的定义处，相当于执行了语句。 将原函数now传入log函数之中，返回wrapper函数，包含了原本的now功能以及加上了新的功能。将值赋予now。这样就完成了装饰。 偏函数Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 模块使用模块Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。 作用域在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等； 类似xxx这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的author，name就是特殊变量，hello模块定义的文档注释也可以用特殊变量doc访问，我们自己的变量一般不要用这种变量名； 类似_xxx和xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，abc等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public，这也是一种非常有用的代码封装和抽象的方法。 安装第三方模块在Python中，安装第三方模块，是通过包管理工具pip完成的。 注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。 一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是。 安装常用模块我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。 模块搜索路径当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。 默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。 如果我们要添加自己的搜索目录，有两种方法一是直接修改sys.path，添加要搜索的目录。第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/zdkswd/tags/Python/"}]},{"title":"Python廖雪峰 简介，解释器，基础，函数","slug":"Python廖雪峰 简介，解释器，基础，函数","date":"2018-08-27T11:33:56.000Z","updated":"2018-09-13T04:46:37.000Z","comments":true,"path":"2018/08/27/Python廖雪峰 简介，解释器，基础，函数/","link":"","permalink":"https://github.com/zdkswd/2018/08/27/Python廖雪峰 简介，解释器，基础，函数/","excerpt":"","text":"Python简介Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 那Python适合开发哪些类型的应用呢？首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 Python的缺点第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 Python解释器由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。 CPython官方版本的解释器：CPython。这个解释器是用C语言开发的。CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。 IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。 PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。 JythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。 IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 小结Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。 Python基础数据类型和变量数据类型在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。 如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识。 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义。 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容。用在命令行中，py文件中直接换行也可输出换行后的内容。 布尔值一个布尔值只有True、False两种值，要么是True，要么是False。 布尔值可以用and、or和not运算。 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 变量变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。 可以看到赋值前不需要声明变量。 这种变量本身类型不固定的语言称之为动态语言。 变量在计算机内存中的表示 Python解释器干了两件事情：在内存中创建了一个’ABC’的字符串；在内存中创建了一个名为a的变量，并把它指向’ABC’。 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量。 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变。用全部大写的变量名表示常量只是一个习惯上的用法。 / 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 还有一种除法是//，称为地板除，两个整数的除法仍然是整数。 字符串和编码字符编码计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。 Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 Python的字符串在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes。 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法。 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数。 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。Python当然也支持其他编码方式，比如把Unicode编码成GB2312。但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。 格式化在Python中，采用的格式化方式和C语言是一致的，用%实现。 常见的占位符有： 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。 转义，用%%来表示一个%。 format()另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多。 使用list和tuplelistlist是一种有序的集合，可以随时添加和删除其中的元素。 len()函数可以获得list元素的个数。 用索引来访问list中每一个位置的元素，记得索引是从0开始的。 -1做索引，直接获取最后一个元素。 append()可以往list中追加元素到末尾 insert()也可以把元素插入到指定的位置。 pop()方法，删除list末尾的元素。要删除指定位置的元素，用pop(i)方法。 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置。 list里面的元素的数据类型也可以不同。list元素也可以是另一个list。 如果一个list中一个元素也没有，就是一个空的list，它的长度为0。 tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。 没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 tuple的陷阱：只有1个元素的tuple定义时必须加一个逗号“ , ”，来消除歧义。 Python在显示只有1个元素的tuple时，也会加一个逗号“ , ”，以免你误解成数学计算意义上的括号。 tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 创建一个内容也不变的tuple那就必须保证tuple的每一个元素本身也不能变。 条件判断if语句elif是else if的缩写。 inputinput()读取用户的输入，这样可以自己输入。 循环for…in循环 for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。 range()函数，可以生成一个整数序列，range(5)生成的序列是从0开始小于5（没有5）的整数。 0-100。 while循环 breakbreak语句可以提前退出循环。 continuecontinue语句，跳过当前的这次循环，直接开始下一次循环。 使用dict和setdictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入。 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。 如果key不存在，dict就会报错，要避免key不存在的错误，有两种办法，一是通过in判断key是否存在，二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value。注意：返回None的时候Python的交互环境不显示结果。 要删除一个key，用pop(key)方法，对应的value也会从dict中删除。 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。 和list比较，dict有以下几个特点查找和插入的速度极快，不会随着key的增加而变慢需要占用大量的内存，内存浪费多而list相反 dict是用空间来换取时间的一种方法。 正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 要创建一个set，需要提供一个list作为输入集合。 重复元素在set中自动被过滤。 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果。 通过remove(key)方法可以删除元素。 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。 set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象。 不可变对象对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 函数调用函数要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误。如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息。 数据类型转换Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数。 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。 定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）。 空函数如果想定义一个什么事也不做的空函数，可以用pass语句。 实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 缺少了pass，代码运行就会有语法错误。 参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError。但是如果参数类型不对，Python解释器就无法帮我们检查。 对参数的限制需要我们手动完成，数据类型检查可以用内置函数isinstance()实现。 返回多个值 但其实这只是一种假象，Python函数返回的仍然是单一值。 原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 小结函数体内部可以用return随时返回函数结果；函数执行完毕也没有return语句时，自动return None。 函数的参数Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 位置参数对于power(x)函数，参数x就是一个位置参数。 默认参数 power(x, n=2) 当我们调用power(5)时，相当于调用power(5, 2) 设置默认参数时，有几点要注意一是必选参数在前，默认参数在后，否则Python的解释器会报错。当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。 有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll(‘Bob’, ‘M’, 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。 也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(‘Adam’, ‘M’, city=’Tianjin’)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。 默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑。定义默认参数要牢记一点：默认参数必须指向不变对象！ 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。 可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的。 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。 Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去。 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。 命名关键字参数如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下 和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。 调用方式如下 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。 命名关键字参数可以有缺省值，从而简化调用。 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。 递归函数尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。 Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/zdkswd/tags/Python/"}]},{"title":"JavaScript标准参考教程 DOM模型 概述 Document节点","slug":"JavaScript标准参考教程 DOM模型 一","date":"2018-08-22T10:33:56.000Z","updated":"2018-10-09T07:11:40.000Z","comments":true,"path":"2018/08/22/JavaScript标准参考教程 DOM模型 一/","link":"","permalink":"https://github.com/zdkswd/2018/08/22/JavaScript标准参考教程 DOM模型 一/","excerpt":"","text":"DOM模型概述基本概念DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。 DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。 节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点的类型有七种 浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。 节点树一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。 浏览器原生提供document节点，代表整个文档。 文档的第一层只有一个节点，就是 HTML 网页的第一个标签&lt; html&gt;，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。 除了根节点，其他节点都有三种层级关系。 DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括firstChild（第一个子节点）和lastChild（最后一个子节点）等属性，同级节点接口包括nextSibling（紧邻在后的那个同级节点）和previousSibling（紧邻在前的那个同级节点）属性。 Node 接口的属性所有 DOM 节点都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。 Node.nodeTypenodeType属性返回一个整数值，表示节点的类型。 Node 对象定义了几个常量，对应这些类型值。 确定节点类型时，使用nodeType属性是常用方法。 Node.nodeNamenodeName属性返回节点的名称。 不同节点的nodeName属性值如下。 Node.nodeValuenodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。 只有文本节点（text）和注释节点（comment）有文本值，因此这两类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这两类节点可以设置nodeValue属性的值，其他类型的节点设置无效。 Node.textContenttextContent属性返回当前节点和它的所有后代节点的文本内容。 textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。 该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。 对于文本节点（text）和注释节点（comment），textContent属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括注释节点。如果一个节点没有子节点，则返回空字符串。 文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。 Node.baseURIbaseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。 如果无法读到网页的 URL，baseURI属性返回null。 该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的&lt; base&gt;标签，改变该属性的值。 设置了以后，baseURI属性就返回标签设置的值。 Node.ownerDocumentNode.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。 document对象本身的ownerDocument属性，返回null。 Node.nextSiblingNode.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。 注意，该属性还包括文本节点和注释节点（）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。 nextSibling属性可以用来遍历所有子节点。 Node.previousSiblingpreviousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。 注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。 Node.parentNodeparentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。 文档节点（document）和文档片段节点（documentfragment）的父节点都是null。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是null。 Node.parentElementparentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。 由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。parentElement属性相当于把后两种父节点都排除了。 Node.firstChild，Node.lastChildfirstChild属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。 注意，firstChild返回的除了元素节点，还可能是文本节点或注释节点。 lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。用法与firstChild属性相同。 Node.childNodeschildNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。 使用该属性，可以遍历某个节点的所有子节点。 文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。 Node.isConnectedisConnected属性返回一个布尔值，表示当前节点是否在文档之中。 Node 接口的方法Node.appendChild()appendChild方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。 如果参数节点是 DOM 已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置。 如果appendChild方法的参数是DocumentFragment节点，那么插入的是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值是一个空的DocumentFragment节点。 Node.hasChildNodes()hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。 注意，子节点包括所有节点，哪怕节点只包含一个空格，hasChildNodes方法也会返回true。 判断一个节点有没有子节点，有许多种方法，下面是其中的三种。 Node.cloneNode()cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。 该方法有一些使用注意点。 克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即node.onclick = fn），添加在这个节点上的事件回调函数。 该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如Node.appendChild这样的方法添加到文档之中。 克隆一个节点之后，DOM 有可能出现两个有相同id属性（即id=”xxx”）的网页元素，这时应该修改其中一个元素的id属性。如果原节点有name属性，可能也需要修改。 Node.insertBefore()insertBefore方法用于将某个节点插入父节点内部的指定位置。 insertBefore方法接受两个参数，第一个参数是所要插入的节点newNode，第二个参数是父节点parentNode内部的一个子节点referenceNode。newNode将插在referenceNode这个子节点的前面。返回值是插入的新节点newNode。 如果insertBefore方法的第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。 注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。 由于不存在insertAfter方法，如果新节点要插在父节点的某个子节点后面，可以用insertBefore方法结合nextSibling属性模拟。 如果要插入的节点是DocumentFragment类型，那么插入的将是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值将是一个空的DocumentFragment节点。 Node.removeChild()removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。 被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。 如果参数节点不是当前节点的子节点，removeChild方法将报错。 Node.replaceChild()replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。 replaceChild方法接受两个参数，第一个参数newChild是用来替换的新节点，第二个参数oldChild是将要替换走的子节点。返回值是替换走的那个节点oldChild。 Node.contains()contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。 Node.compareDocumentPosition()compareDocumentPosition方法的用法，与contains方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。 由于compareDocumentPosition返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。 进行与运算（&amp;）。 Node.isEqualNode()，Node.isSameNode()isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。 isSameNode方法返回一个布尔值，表示两个节点是否为同一个节点。 Node.normalize()normailize方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。 该方法是Text.splitText的逆方法。 Node.getRootNode()getRootNode方法返回当前节点所在文档的根节点。 NodeList 接口节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：NodeList和HTMLCollection。 这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是NodeList实例或HTMLCollection实例。 概述NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。 NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。 注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。 NodeList.prototype.lengthlength属性返回 NodeList 实例包含的节点数量。 document.getElementsByTagName返回一个 NodeList 集合。对于那些不存在的 HTML 标签，length属性返回0。 NodeList.prototype.forEach()forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。 forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。 NodeList.prototype.item()item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。 如果参数值大于实际长度，或者索引不合法（比如负数），item方法返回null。如果省略参数，item方法会报错。 所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用item方法。 NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()这三个方法都返回一个 ES6 的遍历器对象，可以通过for…of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。 HTMLCollection 接口概述HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历。 HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中。 如果元素节点有id或name属性，那么HTMLCollection实例上面，可以使用id属性或name属性引用该节点元素。如果没有对应的节点，则返回null。 HTMLCollection.prototype.lengthlength属性返回HTMLCollection实例包含的成员数量。 HTMLCollection.prototype.item()item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。 如果参数值超出成员数量或者不合法（比如小于0），那么item方法返回null。 HTMLCollection.prototype.namedItem()namedItem方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。 ParentNode 接口节点对象除了继承 Node 接口以外，还会继承其他接口。ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。ChildNode接口表示当前节点是一个子节点，提供一些相关方法。 如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口。 ParentNode.childrenchildren属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。 children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。 HTMLCollection是动态集合，会实时反映 DOM 的任何变化。 ParentNode.firstElementChildfirstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。 ParentNode.lastElementChildlastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。 ParentNode.childElementCountchildElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。 ParentNode.append()，ParentNode.prepend()append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。 该方法不仅可以添加元素子节点，还可以添加文本子节点。 注意，该方法没有返回值。 prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。 ChildNode 接口如果一个节点有父节点，那么该节点就继承了ChildNode接口。 ChildNode.remove()remove方法用于从父节点移除当前节点。 ChildNode.before()，ChildNode.after()before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。 注意，该方法不仅可以插入元素节点，还可以插入文本节点。 after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。 ChildNode.replaceWith()replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。 document 对象概述document对象是文档的根节点，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。 document对象有不同的办法可以获取。 document对象继承了EventTarget接口、Node接口、ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。 属性快捷方式属性以下属性是指向文档内部的某个节点的快捷方式。 document.defaultViewdocument.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。 document.doctype对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt; DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt; !DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。 document.firstChild通常就返回这个节点。 document.documentElementdocument.documentElement属性返回当前文档的根节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是节点。 document.body，document.headdocument.body属性指向&lt; body&gt;节点，document.head属性指向&lt; head&gt;节点。 这两个属性总是存在的，如果网页源码里面省略了&lt; head&gt;或&lt; body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。 document.scrollingElementdocument.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。 标准模式下，这个属性返回的文档的根元素document.documentElement（即）。兼容（quirk）模式下，返回的是元素，如果该元素不存在，返回null。 document.activeElementdocument.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt; input&gt;、&lt; textarea&gt;、&lt; select&gt;等表单元素，如果当前没有焦点元素，返回&lt; body&gt;元素或null。 document.fullscreenElementdocument.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。 节点集合属性以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。 document.linksdocument.links属性返回当前文档所有设定了href属性的&lt; a&gt;及&lt; area&gt;节点。 document.formsdocument.forms属性返回所有&lt; form&gt;表单节点。 document.imagesdocument.images属性返回页面所有&lt; img&gt;图片节点。 document.embeds，document.pluginsdocument.embeds属性和document.plugins属性，都返回所有&lt; embed&gt;节点。 document.scriptsdocument.scripts属性返回所有&lt; script&gt;节点。 document.styleSheetsdocument.styleSheets属性返回文档内嵌或引入的样式表集合。 小结除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。 HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。 文档静态信息属性以下属性返回文档信息。 document.documentURI，document.URLdocument.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。 如果文档的锚点（#anchor）变化，这两个属性都会跟着变化。 document.domaindocument.domain属性返回当前文档的域名，不包含协议和接口。 比如，网页的网址是http://www.example.com:80/hello.html， 那么domain属性就等于www.example.com。如果无法获取域名，该属性返回null。 document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。 另外，设置document.domain会导致端口被改成null。因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同 document.locationLocation对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。 document.lastModifieddocument.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。 注意，document.lastModified属性的值是字符串，所以不能直接用来比较。Date.parse方法将其转为Date实例，才能比较两个网页。 document.titledocument.title属性返回当前文档的标题。默认情况下，返回节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。 document.characterSetdocument.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。 document.referrerdocument.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。 document.dirdocument.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。 document.compatModecompatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。 一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat。 文档状态属性document.hiddendocument.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。 document.visibilityStatedocument.visibilityState返回文档的可见状态。 这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。 document.readyStatedocument.readyState属性返回当前文档的状态，共有三种可能的值。 这个属性变化的过程如下。 每次状态变化都会触发一个readystatechange事件。 document.cookiedocument.cookie属性用来操作浏览器 Cookie。 document.designModedocument.designMode属性控制当前文档是否可编辑，通常用在所见即所得编辑器。该属性只有两个值on和off，默认值为off。 document.implementationdocument.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。 方法document.open()，document.close()document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。 document.close方法用来关闭document.open()打开的文档。 document.write()，document.writeln()document.write方法用于向当前文档写入内容。 在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。 注意，document.write会当作 HTML 代码解析，不会转义。 如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。 如果在页面渲染过程中调用write方法，并不会自动调用open方法。（可以理解成，open方法已调用，但close方法还未调用。） document.write是JavaScript语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对innerHTML属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。 document.writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。 注意，writeln方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入。 document.querySelector()，document.querySelectorAll()document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。 这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。 这两个方法都支持复杂的 CSS 选择器。 但是，它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。 如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。 最后，这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。 document.getElementsByTagName()document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。 HTML 标签名是大小写不敏感的，因此getElementsByTagName方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。 注意，元素节点本身也定义了getElementsByTagName方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。 document.getElementsByClassName()document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。 由于class是保留字，所以 JavaScript 一律使用className表示 CSS 的class。 参数可以是多个class，它们之间使用空格分隔。 注意，正常模式下，CSS 的class是大小写敏感的。（quirks mode下，大小写不敏感。） 与getElementsByTagName方法一样，getElementsByClassName方法不仅可以在document对象上调用，也可以在任何元素节点上调用。 document.getElementsByName()document.getElementsByName方法用于选择拥有name属性的 HTML 元素,返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。 document.getElementById()document.getElementById方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。 注意，该方法的参数是大小写敏感的。比如，如果某个节点的id属性是main，那么document.getElementById(‘Main’)将返回null。 document.getElementById方法与document.querySelector方法都能获取元素节点，不同之处是document.querySelector方法的参数使用 CSS 选择器语法，document.getElementById方法的参数是元素的id属性。document.getElementById()比document.querySelector()效率高得多。 另外，这个方法只能在document对象上使用，不能在其他元素节点上使用。 document.elementFromPoint()，document.elementsFromPoint()document.elementFromPoint方法返回位于页面指定位置最上层的元素节点。 elementFromPoint方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回null。 document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。 document.caretPositionFromPoint()document.caretPositionFromPoint()返回一个 CaretPosition 对象，包含了指定坐标点在节点对象内部的位置信息。CaretPosition 对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。 CaretPosition 对象。该对象有两个属性。 document.createElement()document.createElement方法用来生成元素节点，并返回该节点。 createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感，即参数为div或DIV返回的是同一种节点。如果参数里面包含尖括号（即&lt;和&gt;）会报错。 注意，document.createElement的参数可以是自定义的标签名。 document.createTextNode()document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。 这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。 document.createAttribute()document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。 document.createAttribute方法的参数name，是属性的名称。 document.createComment()document.createComment方法生成一个新的注释节点，并返回该节点。 document.createComment方法的参数是一个字符串，会成为注释节点的内容。 document.createDocumentFragment()document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。 DocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。 document.createEvent()document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。 document.createEvent方法的参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents。 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()这三个方法用于处理document节点的事件。它们都继承自EventTarget接口。 document.hasFocus()document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。 注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。 document.adoptNode()，document.importNode()document.adoptNode方法将某个节点及其子节点，从原来所在的文档或DocumentFragment里面移除，归属当前document对象，返回插入后的新节点。插入的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。 注意，document.adoptNode方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用appendChild方法或insertBefore方法，将新节点插入当前文档树。 document.importNode方法则是从原来所在的文档或DocumentFragment里面，拷贝某个节点及其子节点，让它们归属当前document对象。拷贝的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。 document.importNode方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为true。 注意，document.importNode方法只是拷贝外部节点，这时该节点的父节点是null。下一步还必须将这个节点插入当前文档树。 document.createNodeIterator()document.createNodeIterator方法返回一个子节点遍历器。 document.createNodeIterator方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（NodeFilter.SHOW_ELEMENT）。几种主要的节点类型写法如下。 document.createNodeIterator方法返回一个“遍历器”对象（NodeFilter实例）。该实例的nextNode()方法和previousNode()方法，可以用来遍历所有子节点。 currentNode和previousNode都指向同一个的节点。 注意，遍历器返回的第一个节点，总是根节点。 document.createTreeWalker()document.createTreeWalker方法返回一个 DOM 的子树遍历器。它与document.createNodeIterator方法基本是类似的，区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。另外，它的第一个节点不是根节点。 document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与document.createNodeIterator方法的第二个参数相同）。 document.getSelection()这个方法指向window.getSelection()。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"健身","slug":"健身","date":"2018-08-21T01:49:12.000Z","updated":"2018-08-21T01:50:35.000Z","comments":true,"path":"2018/08/21/健身/","link":"","permalink":"https://github.com/zdkswd/2018/08/21/健身/","excerpt":"","text":"健身关注引领性指标 3900大卡差值消耗一斤脂肪。 计算每日消耗总热量。 计算摄入量 如果差值过大，会导致肌肉减少和基础代谢率降低，很容易反弹，难以持续。 随着体重降低，也要不断的调整。 把摄入热量除以3得到每餐要吃的热量。 三餐热量不同也可以，只要一天内摄入不超过即可。 每餐一个拳头的蛋白质，一个拳头的碳水化合物，蔬菜随便吃。 蛋白质的主要来源 精瘦的鸡肉，猪肉，牛肉，海鲜，鱼，鸡蛋，牛奶，豆类。 碳水化合物尽量选择粗粮，比如说玉米，红薯，土豆，糙米，米粉，面条，面包。 追踪自己的减脂进展。 超实用技巧餐前吃半根香蕉或者一粒糖。 第二个，每餐前吃六到七粒坚果。增加饱腹感。英国有研究表明每天吃20粒坚果能降低癌症和心脏病的风险。 第三个，用南瓜代替主食。 第四点，少油盐，外食要过水，油的热量远远大于菜的热量。 图中的食物可以随便吃。无限量吃。 第六个，嚼无糖口香糖，咀嚼感。 瘦了后保持体形保持期可以放宽，不需要赤字了。 总结 早睡11点 吃早饭 冥想拉伸 少盐多蛋白质 跳绳","categories":[{"name":"知乎Live","slug":"知乎Live","permalink":"https://github.com/zdkswd/categories/知乎Live/"}],"tags":[{"name":"健身","slug":"健身","permalink":"https://github.com/zdkswd/tags/健身/"}]},{"title":"JavaScript标准参考教程 语法专题","slug":"JavaScript标准参考教程 语法专题","date":"2018-08-20T11:14:56.000Z","updated":"2018-08-20T11:14:47.000Z","comments":true,"path":"2018/08/20/JavaScript标准参考教程 语法专题/","link":"","permalink":"https://github.com/zdkswd/2018/08/20/JavaScript标准参考教程 语法专题/","excerpt":"","text":"异步操作概述单线程模型单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。 注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。 JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。 如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。 单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 同步任务和异步任务程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。 同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。 异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。 举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。 任务队列和事件循环JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。） 首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。 异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。 JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件。 异步操作的模式下面总结一下异步操作的几种模式。 回调函数回调函数是异步操作最基本的方法。 回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。 事件监听另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 首先，为f1绑定一个事件（这里采用的 jQuery 的写法）。 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。 发布/订阅事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。 这个模式有多种实现，下面采用的是 Ben Alman 的 Tiny Pub/Sub，这是 jQuery 的一个插件。 f2完成执行后，可以取消订阅（unsubscribe）。 这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 异步操作的流程控制如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。 串行执行我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。 并行执行流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。 相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。 并行与串行的结合所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。 上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。 这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节limit变量，达到效率和资源的最佳平衡。 定时器JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。 setTimeout()setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。 setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。 除了前两个参数，setTimeout还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。 还有一个需要注意的地方，如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。 为了防止出现这个问题，一种解决方法是将obj.y放入一个函数。obj.y放在一个匿名函数之中，这使得obj.y在obj的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。 另一种解决方法是，使用bind方法，将obj.y这个方法绑定在obj上面。 setInterval()setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。 与setTimeout一样，除了前两个参数，setInterval方法还可以接受更多的参数，它们会传入回调函数。 clearTimeout()，clearInterval()setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。 连续调用三次setTimeout，返回值都比上一次大了1。 利用这一点，可以写一个函数，取消当前所有的setTimeout定时器。 实例：debounce 函数有时，我们不希望回调函数被频繁调用。如果用户连续击键，就会连续触发keydown事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的keydown事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，再将数据发送出去。 这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。 运行机制setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。 这意味着，setTimeout和setInterval指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。 setTimeout(f, 0)含义setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f, 0)，那么会立刻执行吗？ 答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行setTimeout指定的回调函数f。也就是说，setTimeout(f, 0)会在下一轮事件循环一开始就执行。 setTimeout(f, 0)这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f。 Promise 对象概述Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。 首先，Promise 是一个对象，也是一个构造函数。 Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。 Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。 Promise 对象的状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。 上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。 这三种的状态的变化途径只有两种。 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 因此，Promise 的最终结果只有两种。 Promise 构造函数JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。 Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。 Promise.prototype.then()Promise 实例的then方法，用来添加回调函数。 then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。 then方法可以链式使用。 p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。 最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。 then() 用法辨析Promise 的用法，简单说就是一句话：使用then方法添加回调函数。 Promise 的实例加载图片 Ajax 操作小结Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。 而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的 Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。 微任务Promise 的回调函数属于异步任务，会在同步任务之后执行。 是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。 严格模式除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。 设计目的早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。 严格模式是从 ES5 进入标准的，主要目的有以下几个。 严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。 启用方法进入严格模式的标志，是一行字符串use strict。 老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。 严格模式可以用于整个脚本，也可以只用于单个函数。 整个脚本文件use strict放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。 单个函数use strict放在函数体的第一行，则整个函数以严格模式运行。 有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。 显式报错严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。 只读属性不可写严格模式下，设置字符串的length属性，会报错。正常模式下，改变length属性是无效的，但不会报错。 严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。 只设置了取值器的属性不可写严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。 禁止扩展的对象不可扩展严格模式下，对禁止扩展的对象添加新属性，会报错。 eval、arguments 不可用作标识名严格模式下，使用eval或者arguments作为标识名，将会报错。下面的语句都会报错。 函数不能有重名的参数正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。 禁止八进制的前缀0表示法正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。 增强的安全措施严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。 全局变量显式声明正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 因此，严格模式下，变量都必须先声明，然后再使用。 禁止 this 关键字指向全局对象正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。 这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加new，这时this不再指向全局对象，而是报错。 禁止使用 fn.callee、fn.caller函数内部不得使用fn.caller、fn.arguments，否则会报错。这意味着不能在函数内部得到调用栈了。 禁止使用 arguments.callee、arguments.callerarguments.callee和arguments.caller是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用arguments.callee、arguments.caller将会报错。 禁止删除变量严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。 静态绑定JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 禁止使用 with 语句严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。 创设 eval 作用域正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。 arguments 不再追踪参数的变化变量arguments代表函数的参数。严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系。 向下一个版本的 JavaScript 过渡JavaScript语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。 非函数代码块不得声明函数ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。 ES6 允许在代码块之中声明函数。 保留字为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":" JavaScript标准参考教程 面向对象编程","slug":"JavaScript标准参考教程 面向对象编程","date":"2018-08-19T15:33:56.000Z","updated":"2018-08-19T15:37:10.000Z","comments":true,"path":"2018/08/19/JavaScript标准参考教程 面向对象编程/","link":"","permalink":"https://github.com/zdkswd/2018/08/19/JavaScript标准参考教程 面向对象编程/","excerpt":"","text":"构造函数与 new 命令JavaScript 语言具有很强的面向对象编程能力。 对象是什么构造函数典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。 构造函数就是一个普通的函数，但是有自己的特征和用法。 为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个。 new 命令基本用法new命令的作用，就是执行构造函数，返回一个实例对象。 使用new命令时，根据需要，构造函数也可以接受参数。 new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。 如果忘了使用new命令，构造函数就变成了普通函数，并不会生成实例对象。this这时代表全局对象，将造成一些意想不到的结果。 因此，应该非常小心，避免不使用new命令、直接调用构造函数。 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。 不管加不加new命令，都会得到同样的结果。 new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。这一点需要特别引起注意。 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。 new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。 使用这个属性，可以判断函数调用的时候，是否使用new命令。 Object.create() 创建实例对象构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。 this 关键字涵义this都有一个共同点：它总是返回一个对象。 简单说，this就是属性或方法“当前”所在的对象。 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。 总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。 使用场合全局环境全局环境使用this，它指的就是顶层对象window。 不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。 构造函数构造函数中的this，指的是实例对象。 对象的方法如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b。 使用注意点避免多层 this由于this的指向是不确定的，所以切勿在函数中包含多层的this。内层的this直接指向顶层对象 因为实际执行的是下面的代码。 使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。 JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。 避免数组处理方法中的 this数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。 foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。 1最主要的问题就是函数表达式的出现，此时变成了全局环境。 解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。 避免回调函数中的 this回调函数中的this往往会改变指向，最好避免使用。 绑定this的方法this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。 call方法还可以接受多个参数。 call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。 call方法的一个应用是调用对象的原生方法。 继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。 Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。 apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 利用这一点，可以做一些有趣的应用。 找出数组最大元素JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。 将数组的空元素变为undefined通过apply方法，利用Array构造函数将数组的空元素变成undefined。 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 转换类似数组的对象另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。 绑定回调函数的对象Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 bind还可以接受更多的参数，将这些参数绑定原函数的参数。 bind还可以接受更多的参数，将这些参数绑定原函数的参数。 bind方法有一些使用注意点。 每一次返回一个新函数bind方法每运行一次，就返回一个新函数，这会产生一些问题。 结合回调函数使用回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。 结合call方法使用prototype 对象面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。 大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。JavaScript 语言的继承则是通过“原型对象”（prototype）。 原型对象概述构造函数的缺点通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。 这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。 prototype 属性的作用JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。 JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。 对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为类类。1类类是自创的概念，类似于类的东西，即指不管实例对象是否存在，它都客观存在的实例对象的原型。 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。 当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。 原型链JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型…… 如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。 那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。 读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。 注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。 constructor 属性prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。 constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。 constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。 构造函数Person的原型对象改掉了，但是没有修改constructor属性，导致这个属性不再指向Person。由于Person的新原型是一个普通对象，而普通对象的contructor属性指向Object构造函数，导致Person.prototype.constructor变成了Object。 修改原型对象时，一般要同时修改constructor属性的指向。 要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法。 如果不能确定constructor属性是什么函数，还有一个办法：通过name属性，从实例得到构造函数的名称。 instanceof 运算符instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。 instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。 只要一个对象的原型不是null，instanceof运算符的判断就不会失真。 instanceof运算符的一个用处，是判断值的类型。 注意，instanceof运算符只能用于对象，不适用原始类型的值。 对于undefined和null，instanceOf运算符总是返回false。 利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。 Object 对象的相关方法Object.getPrototypeOf()Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。 Object.setPrototypeOf()Object.setPrototypeOf方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。 new命令可以使用Object.setPrototypeOf方法模拟。 new命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的prototype属性（上例是F.prototype）；第二步，将构造函数内部的this绑定这个空对象，然后执行构造函数，使得定义在this上面的方法和属性（上例是this.foo），都转移到这个空对象上。 Object.create()JavaScript 提供了Object.create方法，该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。 下面三种方式生成的新对象是等价的。 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。 Object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。 除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。 Object.create方法生成的对象，继承了它的原型对象的构造函数。 Object.prototype.isPrototypeOf()实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。 只要实例对象处在参数对象的原型链上，isPrototypeOf方法都返回true。 Object.prototype.proto实例对象的proto属性（前后各两个下划线），返回该对象的原型。该属性可读写。 根据语言标准，proto属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()和Object.setPrototypeOf()，进行原型对象的读写操作。 获取原型对象方法的比较获取实例对象obj的原型对象，有三种方法。 前两种都不是很可靠。proto属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。 推荐使用第三种Object.getPrototypeOf方法，获取原型对象。 Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。 Object.getOwnPropertyNames方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用Object.keys方法。 Object.prototype.hasOwnProperty()对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。 注意，hasOwnProperty方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。 in 运算符和 for…in 循环in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。 in运算符常用于检查一个属性是否存在。 获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for…in循环。 对象的拷贝如果要拷贝一个对象，需要做到下面两件事情。 面向对象编程的模式构造函数的继承让一个构造函数继承另一个构造函数，是非常常见的需求。 这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。 上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。 1 JavaScript 中对象的赋值是默认引用赋值的，如果你想要复制赋值，则必须要重新分配对象 另外一种写法是Sub.prototype等于一个父类实例。 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。 有时只需要单个方法的继承，这时可以采用下面的写法。 上面代码中，子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法。 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。 这种模式又称为 Mixin（混入）。 模块JavaScript不是一种模块化编程语言，ES5不支持”类”（class），更遑论”模块”（module）了。ES6正式支持”类”和”模块”，但还没有成为主流。 基本的实现方法模块是实现特定功能的一组属性和方法的封装。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。 封装私有变量：构造函数的写法我们可以利用构造函数，封装私有变量。 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。 封装私有变量：立即执行函数的写法使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。 上面的module1就是JavaScript模块的基本写法。下面，再对这种写法进行加工。 模块的放大模式如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。 与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。 输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"JavaScript 标准参考教程 标准库 下","slug":"JavaScript 标准参考教程 标准库 下","date":"2018-08-17T04:03:56.000Z","updated":"2018-09-01T03:58:36.000Z","comments":true,"path":"2018/08/17/JavaScript 标准参考教程 标准库 下/","link":"","permalink":"https://github.com/zdkswd/2018/08/17/JavaScript 标准参考教程 标准库 下/","excerpt":"","text":"RegExp对象概述JavaScript 的正则表达式体系是参照 Perl 5 建立的。 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。 另一种是使用RegExp构造函数。 区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。 RegExp构造函数还可以接受第二个参数，表示修饰符。 实例属性正则对象的实例属性分成两类。 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。 三个属性都是只读的。 另一类是与修饰符无关的属性，主要是下面两个。 实例方法RegExp.prototype.test()正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。 lastIndex属性只对同一个正则表达式有效。 如果正则模式是一个空字符串，则匹配所有字符串。 RegExp.prototype.exec()正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。 exec方法的返回数组还包含以下两个属性： 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。 正则实例对象的lastIndex属性不仅可读，还可写。设置了g修饰符的时候，只要手动设置了lastIndex的值，就会从指定位置开始匹配。 字符串的实例方法 String.prototype.match()字符串实例对象的match方法对字符串进行正则匹配，返回匹配结果。 字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。 设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。 设置正则对象的lastIndex属性是无效的。 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。 String.prototype.replace()字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。 正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。 replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。 replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。 String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。 该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。 正则默认是贪婪匹配。 匹配规则字面量字符和元字符如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。 点字符（.）点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。注意，对于码点大于0xFFFF的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。 位置字符位置字符用来提示字符所处的位置，主要有两个字符。 选择符（|）竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。 转义符正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成\\ +。 正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 字符类字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。 脱字符（ ^ ）如果方括号内的第一个字符是[^ ]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^ xyz]表示除了x、y、z之外都可以匹配。 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。 连字符（-）某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。 [1-31]，不代表1到31，只代表1到3。 连字符还可以用来指定 Unicode 字符的范围。 预定义模式 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。 量词符量词符用来设定某个模式出现的次数。 贪婪模式三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。 模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。 修饰符修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。 修饰符可以单个使用，也可以多个一起使用。 g 修饰符默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。 i 修饰符默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。 m修饰符表示多行模式（multiline），会修改\\^和\\$的行为。默认情况下（即不加m修饰符时），\\^和\\$匹配字符串的开始处和结尾处，加上m修饰符以后，\\^和\\$还会匹配行首和行尾，即\\^和\\$会识别换行符（\\n）。 组匹配概述正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。 注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。 这时必须使用正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获。 正则表达式内部，还可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。 非捕获组(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。 先行断言x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\\d+(?=%)/。 先行否定断言x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\\d+(?!%)/。 JSON对象JSON 格式JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式。 相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。 每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。 JSON 对值的类型和格式有严格的规定。 JSON 对象JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。 JSON.stringify()基本用法JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。 注意，对于原始类型的字符串，转换结果会带双引号。 如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。 正则对象会被转成空对象。 JSON.stringify方法会忽略对象的不可遍历属性。 第二个参数JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 这个类似白名单的数组，只对对象的属性有效，对数组无效。 第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。 f函数，接受两个参数，分别是被转换的对象的键名和键值。 这个处理函数是递归处理所有的键。 第三个参数JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 参数对象的 toJSON 方法如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。 JSON.parse()JSON.parse方法用于将 JSON 字符串转换成对应的值。 如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。 单引号字符串不符合 JSON 格式，会报错。 为了处理解析错误，可以将JSON.parse方法放在try…catch代码块中。 JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。 console对象console对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。 console的常见用途有两个。 浏览器实现可以使用下面三种方法的打开它。 面板。 Console面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。 console 对象的静态方法console对象提供的各种静态方法，用来与控制台窗口互动。 console.log()，console.info()，console.debug()console.log方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。 console.log方法会自动在每次输出的结尾，添加换行符。 如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。 不同类型的数据必须使用对应的占位符。 console.info是console.log方法的别名，用法完全一样。只不过console.info方法会在输出信息的前面，加上一个蓝色图标。 console.debug方法与console.log方法类似，会在控制台输出调试信息。但是，默认情况下，console.debug输出的信息不会显示，只有在打开显示级别在verbose的情况下，才会显示。 console对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。 console.warn()，console.error()warn方法和error方法也是在控制台输出信息，它们与log方法的不同之处在于，warn方法输出信息时，在最前面加一个黄色三角，表示警告；error方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。 console.table()对于某些复合类型的数据，console.table方法可以将其转为表格显示。 console.count()count方法用于计数，输出它被调用了多少次。 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。 console.dir()，console.dirxml()dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 dir方法的输出结果，比log方法更易读，信息也更丰富。 对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。 Node 环境之中，还可以指定以代码高亮的形式输出。 dirxml方法主要用于以目录树的形式，显示 DOM 节点。 如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。 console.assert()console.assert方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。 它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。 console.time()，console.timeEnd()这两个方法用于计时，可以算出一个操作所花费的准确时间。 time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。 console.group()，console.groupEnd()，console.groupCollapsed()console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 console.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 console.trace()，console.clear()console.trace方法显示当前执行的代码在堆栈中的调用路径。 console.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，console.clear方法将不起作用。 命令行API浏览器控制台中，除了使用console对象，还可以使用一些控制台自带的命令行方法。 $_$_属性返回上一个表达式的值。 \\$0 - \\$4控制台保存了最近5个在 Elements 面板选中的 DOM 元素，\\$0代表倒数第一个（最近一个），\\$1代表倒数第二个，以此类推直到\\$4。 $(selector)\\$(selector)返回第一个匹配的元素，等同于document.querySelector()。注意，如果页面脚本对\\$有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行\\$(selector)就会采用 jQuery 的实现，返回一个数组。 $$(selector)$$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。 $x(path)$x(path)方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。 inspect(object)inspect(object)方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在Elements面板中显示，比如inspect(document)会在 Elements 面板显示document元素。JavaScript 对象在控制台面板Profiles面板中显示，比如inspect(window)。 getEventListeners(object)getEventListeners(object)方法返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。 keys(object)，values(object)keys(object)方法返回一个数组，包含object的所有键名。values(object)方法返回一个数组，包含object的所有键值。 monitorEvents(object[, events]) ，unmonitorEvents(object[, events])monitorEvents(object[, events])方法监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息。unmonitorEvents方法用于停止监听。 monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。 其他方法命令行 API 还提供以下方法。 debugger 语句debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。 Chrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。 属性描述对象概述JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。 属性描述对象提供6个元属性。 valuevalue是该属性的属性值，默认为undefined。 writablewritable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。 enumerableenumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for…in循环、Object.keys()，JSON.stringify方法）跳过该属性。 configurableconfigurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 getget是一个函数，表示该属性的取值函数（getter），默认为undefined。 setset是一个函数，表示该属性的存值函数（setter），默认为undefined。 Object.getOwnPropertyDescriptor()Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。 注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。 Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。 Object.defineProperty()，Object.defineProperties()Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。 Object.defineProperty方法接受三个参数，依次如下。 如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。 Object.defineProperty()和Object.defineProperties()的第三个参数，是一个属性对象。它的writable、configurable、enumerable这三个属性的默认值都为false。 Object.prototype.propertyIsEnumerable()实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。 元属性属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。 valuevalue属性是目标属性的值。 writableenumerableconfigurable存取器除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。 一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。 注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。 存取器往往用于，属性的值依赖对象内部数据的场合。 next属性的存值函数和取值函数，都依赖于内部属性$n。 对象的拷贝有时，我们需要将一个对象的所有属性，拷贝到另一个对象。 可以通过Object.defineProperty方法来拷贝属性。 hasOwnProperty那一行用来过滤掉继承的属性，否则会报错，因为Object.getOwnPropertyDescriptor读不到继承属性的属性描述对象。 控制对象状态有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。 Object.preventExtensions()Object.preventExtensions方法可以使得一个对象无法再添加新的属性。 Object.isExtensible()Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。 Object.seal()Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。 Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。 Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。 Object.isSealed()Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。 这时，Object.isExtensible方法也返回false。 Object.freeze()Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。 Object.isFrozen()Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。 使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。 局限性上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。 一种解决方案是，把obj的原型也冻结住。 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。 obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"JavaScript 标准参考教程 标准库 上","slug":"JavaScript 标准参考教程 标准库 上","date":"2018-08-17T04:02:56.000Z","updated":"2018-09-01T03:55:47.000Z","comments":true,"path":"2018/08/17/JavaScript 标准参考教程 标准库 上/","link":"","permalink":"https://github.com/zdkswd/2018/08/17/JavaScript 标准参考教程 标准库 上/","excerpt":"","text":"Object对象概述JavaScript 原生提供Object对象（注意起首的O是大写）。 JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。 Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Object对象本身的方法Object的实例方法Object（）Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。 如果参数为空（或者为undefined和null），Object()返回一个空对象。 instanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例。 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例。 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。 利用这一点，可以写一个判断变量是否为对象的函数。 Object构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 Object构造函数的首要用途，是直接通过它来生成新对象。 注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。或者说，后者只是前者的一种简便写法。 Object的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。 Object.keys()，Object.getOwnPropertyNames()Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。 Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。 对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。 由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。 其他方法对象属性模型的相关方法 控制对象状态的方法 原型链相关方法 Object的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object实例对象的方法，主要有以下六个。 Object.prototype.valueOf()valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。 valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。 Object.prototype.toString()toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。 通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。覆盖原始方法。 toString() 的应用：判断数据类型Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。 由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。 不同数据类型的Object.prototype.toString方法返回值如下。 利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。 Object.prototype.toLocaleString()Object.prototype.toLocaleString方法与toString的返回结果相同，也是返回一个值的字符串形式。 这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。 举例来说，日期的实例对象的toString和toLocaleString返回值就不一样，而且toLocaleString的返回值跟用户设定的所在地域相关。 Object.prototype.hasOwnProperty()Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。而不显示继承而来的属性。 Array对象构造函数Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。 Array构造函数的参数2，表示生成一个两个成员的数组，每个位置都是空值。 如果没有使用new，运行结果也是一样的。 Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。 Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。 注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。 静态方法Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。 typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。 实例方法valueOf()，toString()valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。 toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 push()，pop()push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 对空数组使用pop方法，不会报错，而是返回undefined。 shift()，unshift()shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 shift方法可以遍历并清空一个数组。 push和shift结合使用，就构成了“先进先出”的队列结构（queue）。 unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。 join（）join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 如果数组成员是undefined或null或空位，会被转成空字符串。 通过call方法，这个方法也可以用于字符串或类似数组的对象。 concat()concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。 reverse()reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 slice()slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。 如果slice方法的参数是负数，则表示倒数计算的位置。 slice没有参数，实际上等于返回一个原数组的拷贝。 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 slice方法的一个重要应用，是将类似数组的对象转为真正的数组。 splice()splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 起始位置如果是负数，就表示从倒数位置开始删除。 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。 sort()sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。 map()map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。 map方法还可以接受第二个参数，用来绑定回调函数内部的this变量。 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。 map方法不会跳过undefined和null，但是会跳过空位。 forEach()forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。 forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。 forEach方法也可以接受第二个参数，绑定参数函数的this变量。 forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 forEach方法也会跳过数组的空位。 filter()filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。 它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。 filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 some()，every()这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。 它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。 some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。 every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。 some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 reduce()，reduceRight()reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。 这四个参数之中，只有前两个是必须的，后两个则是可选的。 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。 由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。 indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 indexOf方法还可以接受第二个参数，表示搜索的开始位置。 lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。 这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。 链式使用包装对象定义对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。 所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。 包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。 Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。 即，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。 实例方法包装对象的实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。 valueOf()valueOf方法返回包装对象实例对应的原始类型的值。 toString()toString方法返回对应的字符串形式。 原始类型与实例对象的自动转换原始类型的值，可以自动当作包装对象调用，即调用各种包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。 比如，字符串可以调用length属性，返回字符串的长度。 abc是一个字符串，本身不是对象，不能调用length属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。 自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。 调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。 自定义方法三种包装对象除了提供很多原生的实例方法，还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。 这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。 Boolean 对象概述Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。 Boolean 函数的类型转换作用Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。 Number对象概述Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。 作为构造函数时，它用于生成值为数值的对象。 属性 实例方法Number对象有4个实例方法，都跟将数值转换成指定格式有关。 Number.prototype.toString()Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。 toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。 除了为10加上括号，还可以在10后面加两个点，JavaScript 会把第一个点理解成小数点（即10.0），把第二个点理解成调用对象属性，从而得到正确结果。 意味着，可以直接对一个小数使用toString方法。 通过方括号运算符也可以调用toString方法。 toString方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用parseInt方法。 Number.prototype.toFixed()toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。 Number.prototype.toExponential()toExponential方法用于将一个数转为科学计数法形式。 toExponential方法的参数是小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个 RangeError 错误。 Number.prototype.toPrecision()toPrecision方法用于将一个数转为指定位数的有效数字。 toPrecision方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出 RangeError 错误。 toPrecision方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。 自定义方法与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。 注意，数值的自定义方法，只能定义在它的原型对象Number.prototype上面，数值本身是无法自定义属性的。 String对象概述String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。 字符串对象是一个类似数组的对象（很像数组，但不是数组）。 String对象还可以当作工具方法使用，将任意类型的值转为字符串。 静态方法String.fromCharCode()该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。 String.fromCharCode方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。 注意，该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）。 String.fromCharCode发现参数值大于0xFFFF，就会忽略多出的位（即忽略0x20BB7里面的2）。 码点大于0xFFFF的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把0x20BB7拆成两个字符表示。 码点大于0xFFFF的字符的四字节表示法，由 UTF-16 编码方法决定。 实例属性String.prototype.length字符串实例的length属性返回字符串的长度。 实例方法String.prototype.charAt()charAt方法返回指定位置的字符，参数是从0开始编号的位置。 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。 String.prototype.charCodeAt()charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。 如果没有任何参数，charCodeAt返回首字符的 Unicode 码点。 如果参数为负数，或大于等于字符串的长度，charCodeAt返回NaN。 charCodeAt方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必需连续使用两次charCodeAt，不仅读入charCodeAt(i)，还要读入charCodeAt(i+1)，将两个值放在一起，才能得到准确的字符。 String.prototype.concat()concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。 如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。 String.prototype.slice()slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。 如果省略第二个参数，则表示子字符串一直到原字符串结束。 如果参数是负值，表示从结尾开始倒数计算的位置。 如果第一个参数大于第二个参数，slice方法返回一个空字符串。 String.prototype.substring()substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。 如果省略第二个参数，则表示子字符串一直到原字符串的结束。 如果第一个参数大于第二个参数，substring方法会自动更换两个参数的位置。 如果参数是负数，substring方法会自动将负数转为0。 由于这些规则违反直觉，因此不建议使用substring方法，应该优先使用slice。 String.prototype.substr()substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。 substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。 如果省略第二个参数，则表示子字符串一直到原字符串的结束。 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 String.prototype.indexOf()，String.prototype.lastIndexOf()indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。 indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。 lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。 lastIndexOf的第二个参数表示从该位置起向前匹配。 String.prototype.trim()trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。 该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。 String.prototype.toLowerCase()，String.prototype.toUpperCase()toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。 String.prototype.match()match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 match方法还可以使用正则表达式作为参数。 String.prototype.search()，String.prototype.replace()search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 search方法还可以使用正则表达式作为参数。 replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配。 replace方法还可以使用正则表达式作为参数。 String.prototype.split()split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。 如果省略参数，则返回数组的唯一成员就是原字符串。 如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。 如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。 split方法还可以接受第二个参数，限定返回数组的最大成员数。 split方法还可以使用正则表达式作为参数。 String.prototype.localeCompare()localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。 JavaScript 采用的是 Unicode 码点比较但是，localeCompare方法会考虑自然语言的排序情况，大写字母比小写字母大。 localeCompare还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。 Math对象Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。 静态属性 这些属性都是只读的，不能修改。 静态方法 Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。 Math.floor方法返回小于参数值的最大整数（地板值）。 Math.ceil方法返回大于参数值的最小整数（天花板值）。 Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。 如果要计算以10为底的对数，可以先用Math.log求出自然对数，然后除以Math.LN10；求以2为底的对数，可以除以Math.LN2。 Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 三角函数方法 Date对象Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。 普通函数的用法Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。 即使带有参数，Date作为普通函数使用时，返回的还是当前时间。 无论有没有参数，直接调用Date总是返回当前时间。 构造函数的用法Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。 Date实例有一个独特的地方。其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。 作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。 关于Date构造函数的参数， 第一点，参数可以是负整数，代表1970年元旦之前的时间。 第二点，只要是能被Date.parse()方法解析的字符串，都可以当作参数。 第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。 各个参数的取值范围如下。 注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。 这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。 日期设为0，就代表上个月的最后一天。 参数还可以使用负数，表示扣去的时间。 日期的运算类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。 静态方法Date.now()Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。 Date.parse()Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区 如果解析失败，返回NaN。 Date.UTC()Date.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。 该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。 实例方法Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。 Date.prototype.valueOf()valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。 to 类方法Date.prototype.toString()toString方法返回一个完整的日期字符串。 Date.prototype.toUTCString()toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。 Date.prototype.toISOString()toISOString方法返回对应时间的 ISO8601 写法。 toISOString方法返回的总是 UTC 时区的时间。 Date.prototype.toJSON()toJSON方法返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同。 Date.prototype.toDateString()toDateString方法返回日期字符串（不含小时、分和秒）。 Date.prototype.toTimeString()toTimeString方法返回时间字符串（不含年月日）。 Date.prototype.toLocaleDateString()toLocaleDateString方法返回一个字符串，代表日期的当地写法（不含小时、分和秒）。 get类方法Date对象提供了一系列get*方法，用来获取实例对象某个方面的值。 所有这些get*方法返回的都是整数，不同方法返回值的范围不一样。 上面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。 set 类方法Date对象提供了一系列set*方法，用来设置实例对象的各个方面。 set*方法的参数都会自动折算。以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。 set*系列方法除了setTime()和setYear()，都有对应的 UTC 版本，即设置 UTC 时区的时间。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"JavaScript标准参考教程 语法 一","slug":"JavaScript标准参考教程 语法 一","date":"2018-08-14T02:36:56.000Z","updated":"2018-09-01T05:53:32.000Z","comments":true,"path":"2018/08/14/JavaScript标准参考教程 语法 一/","link":"","permalink":"https://github.com/zdkswd/2018/08/14/JavaScript标准参考教程 语法 一/","excerpt":"","text":"基本语法语句 var a=1+3; 分号语句结束。 变量JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 var a = 1;a = ‘hello’; 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 标识符中文是合法的标识符，可以用作变量名。第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 注释//单行/*多行*/由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以也被视为合法的单行注释。 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 条件语句if和switch 还有三元运算符if switch与c一样。 循环语句while \\for\\ do..whilewhile for do..while语法与c一样。break退出循环，continue退出本轮循环。 JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置。与汇编语言类似。标签:标签通常与break语句和continue语句配合使用，跳出特定的循环. 数据类型概述JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） JavaScript中的值分为2大类：基本类型和引用类型。基本类型：数字类型：Number；字符串类型：String；布尔类型：Boolean(true和false)；Undefined；Null。 引用类型：对象。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。 对基本类型，是按值访问的，即通过值复制的方式来赋值和传递。对引用类型，是按引用访问的，即通过引用复制的方式赋值和传递。 当一个变量进行赋值操作时，就是在重新将变量进行指向。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof可以用来检查一个没有声明的变量，而不报错。 instanceof运算符可以区分数组和对象。 typeof null的类型是object，这是由于历史原因造成的。 null 和 undefinednull与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 布尔值 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 空数组（[]）和空对象（{}）对应的布尔值，都是true。 数值概述JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 有效数字的第一位默认总是1。 数值范围 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。数值也可以采用科学计数法表示。 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。（1）小数点前的数字多于21位。（2）小数点后的零多于5个。 数值的进制JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 特殊数值正零和负零JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的。NaNNaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 0除以0也会得到NaN。 NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 NaN不等于任何值，包括它本身。 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 NaN在布尔运算时被当作false。 NaN与任何数（包括它自己）的运算，得到的都是NaN。InfinityInfinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 Infinity与NaN比较，总是返回false。 Infinity的四则运算，符合无穷的数学计算规则。 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 Infinity减去或除以Infinity，得到NaN。 Infinity与null计算时，null会转成0，等同于与0的计算。 Infinity与undefined计算，返回的都是NaN。 与数值相关的全局方法parseInt方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。如果parseInt的参数不是字符串，则会先转为字符串再转换。 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 如果字符串以0开头，将其按照10进制解析。 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 如果字符串符合科学计数法，则会进行相应的转换。 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 parseFloat方法会自动过滤字符串前导的空格。 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。这些特点使得parseFloat的转换结果不同于Number函数。 isNaNisNaN方法可以用来判断一个值是否为NaN。 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 出于同样的原因，对于对象和数组，isNaN也返回true。 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 上面代码之所以返回false，原因是这些数组能被Number函数转成数值。 因此，使用isNaN之前，最好判断一下数据类型。 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 isFinite（）isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 字符串概述字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 字符串默认只能写在一行内，分成多行将会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 转义 反斜杠还有三种特殊用法。 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 length 属性length属性返回字符串的长度，该属性也是无法改变的。但是不会报错。 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度。对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 Base64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 两个方法不适合非 ASCII 码的字符，会报错。 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 对象概述简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 键名对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。 如果键名是数值，会被自动转为字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 如果属性的值还是一个对象，就形成了链式引用。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 属性可以动态创建，不必在对象声明时就指定。 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 其中任何一个变量添加属性，另一个变量都可以读写该属性。 如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。 表达式还是语句对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好还是在大括号前加上圆括号。 属性的操作读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 数字键可以不加引号，因为会自动转成字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 查看所有属性查看一个对象本身的所有属性，可以使用Object.keys方法。 delete 命令delete命令用于删除对象的属性，删除成功后返回true。delete A[属性名]；。 注意，删除一个不存在的属性，delete不报错，而且返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 注意，delete命令只能删除对象本身的属性，无法删除继承的属性。即为即使delete返回true，该属性依然可能读取到值。 in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。 in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。 for…in 循环for…in循环有两个使用注意点。 如果继承的属性是可遍历的，那么就会被for…in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for…in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 with 语句 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 数组定义数组用方括号表示。任何类型的数据，都可以放入数组。 数组本质本质上，数组属于一种特殊的对象。数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 length属性清空数组的一个有效方法，就是将length属性设为0。如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。 in运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 for…in 循环和数组的遍历for…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。 但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。所以，不推荐使用for…in遍历数组。数组的遍历可以考虑使用for循环或while循环。 数组的forEach方法，也可以用来遍历数组。 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。数组的空位不影响length属性。数组最后一个成员后面有一个逗号，这不影响length属性的值。数组的空位是可以读取的，返回undefined。使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 “类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。 “类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。 数组的slice方法可以将“类似数组的对象”变成真正的数组。 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"JavaScript标准参考教程 语法 二","slug":"JavaScript标准参考教程 语法 二","date":"2018-08-14T02:36:56.000Z","updated":"2018-09-01T05:56:42.000Z","comments":true,"path":"2018/08/14/JavaScript标准参考教程 语法 二/","link":"","permalink":"https://github.com/zdkswd/2018/08/14/JavaScript标准参考教程 语法 二/","excerpt":"","text":"函数概述JavaScript 有三种声明函数的方法。 function 命令function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 函数表达式除了用function命令声明函数，还可以采用变量赋值的写法。 这种写法将一个匿名函数赋值给变量。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 注意，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。 Function 构造函数 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 这种声明函数的方式非常不直观，几乎无人使用。 函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 圆括号运算符，return 语句和递归第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。 由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 不能在条件语句中声明函数根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。 但是，实际情况是各家浏览器往往并不报错，能够运行。 但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。 要达到在条件语句中定义函数的目的，只有使用函数表达式。 函数的属性和方法name属性函数的name属性返回函数的名字。 如果是通过变量赋值定义的函数，那么name属性返回变量名。 只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 name属性的一个用处，就是获取参数函数的名字。 length属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。 toString()函数的toString方法返回一个字符串，内容是函数的源码。 函数内部的注释也可以返回。 函数作用域定义函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 参数概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 参数的省略函数参数不是必需的，Javascript 允许省略参数。 运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。 注意，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 同名参数如果有同名的参数，则取最后出现的那个值。 arguments 对象由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 rguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 正常模式下，arguments对象可以在运行时修改。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 与数组的关系需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 callee属性arguments对象带有一个callee属性，返回它所对应的原函数。 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 函数的其他知识点闭包闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 立即调用的函数表达式（IIFE） 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 eval 命令eval命令的作用是，将字符串当作语句执行。 eval的命令字符串不会得到 JavaScript 引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。 运算符加法运算符JavaScript 允许非数值的相加。如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。 除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。 对象的相加如果运算子是对象，必须先转成原始类型的值，然后再相加。 算数运算符 余数运算符运算结果的正负号由第一个运算子的正负号决定。 余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。 赋值运算符比较运算符 相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。 字符串的比较字符串按照字典顺序进行比较。 JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。 非字符串的比较两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。 字符串和布尔值都会先转成数值，再进行比较。 特殊情况，即任何值（包括NaN本身）与NaN比较，返回的都是false。 对象 严格相等运算符JavaScript 提供两种相等运算符：==和===。 简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。 需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。使用=== 空对象、空数组、空函数的值，都存放在不同的内存地址。 注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。 undefined和nullundefined和null与自身严格相等。 由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。 严格不相等运算符严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。 相等运算符对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。 undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。 因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。 不相等运算符相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。 布尔运算符 ！对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。 如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。 &amp;&amp;||（?:）位运算符 位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。 左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方（最高位即符号位不参与移动）。 右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）。 带符号位的右移运算符（&gt;&gt;&gt;）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。 开关作用掩码 其他运算符void运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。 这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。 逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。 运算顺序优先级五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。 记住所有运算符的优先级，是非常难的，也是没有必要的。 数据类型转换JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。 强制转换强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。 Number()使用Number函数，可以将任意类型的值转化成数值。 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。第三步，如果toString方法返回的是对象，就报错。 String()String函数可以将任意类型的值转化成字符串，转换规则如下。 String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 Boolean()Boolean函数可以将任意类型的值转为布尔值。 它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。 所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。 自动转换自动转换是以强制转换为基础的。 以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。 第一种情况，不同类型的数据互相运算。 第二种情况，对非布尔值类型的数据求布尔值。 第三种情况，对非数值类型的值使用一元运算符（即+和-）。 自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。 自动转换为布尔值自动转换为字符串字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。 这种自动转换很容易出错。期望求导个整数值结果得到个字符串。 自动转换为数值除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 注意：null转为数值时为0，而undefined转为数值时为NaN。 一元运算符也会把运算子转成数值。 错误处理机制Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 原生错误类型Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。 ReferenceError 对象ReferenceError对象是引用一个不存在的变量时发生的错误。 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。 RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 自定义错误throw语句throw语句的作用是手动中断程序执行，抛出一个错误。 实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。 对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。 try…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。 如果你不确定某些代码是否会报错，就可以把它们放在try…catch代码块之中，便于进一步对错误进行处理。 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try…catch结构。 为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。 finally 代码块try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。 return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。 由于没有catch语句块，所以错误没有捕获。执行finally代码块以后，程序就中断在错误抛出的地方。 try…catch…finally这三者之间的执行顺序。 尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生 finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略 所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。 编程风格概述编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。 缩进行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。 Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。 区块如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。 建议总是使用大括号表示区块。 JavaScript 要使用起首的大括号跟在关键字的后面，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。 因此，表示区块起首的大括号，不要另起一行。 圆括号圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。 建议可以用空格，区分这两种不同的括号。 行尾的分号不使用分号的情况for和while循环 注意，do…while循环是有分号的。 分支语句：if，switch，try 函数的声明语句 注意，函数表达式仍然要使用分号。 以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。 分号的自动添加所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。 麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。 如果continue、break、return和throw这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果return语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。 由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。 不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。 另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。 上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。 全局变量JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。 因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如UPPER_CASE。 变量声明JavaScript 会自动将变量声明”提升“（hoist）到代码块（block）的头部。 为了避免可能出现的问题，最好把变量声明都放在代码块的头部。 所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。 with语句with可以减少代码的书写，但是会造成混淆。 因此，不要使用with语句。 相等和严格相等相等运算符会自动转换变量类型，造成很多意想不到的情况。 建议不要使用相等运算符（==），只使用严格相等运算符（===）。 语句的合并建议不要将不同目的的语句，合并成一行。 自增和自减运算符自增（++）和自减（–）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的++运算符都可以用+= 1代替。 建议自增（++）和自减（–）运算符尽量使用+=和-=代替。 switch…case结构switch…case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。这样不仅容易忘记，还会造成代码的冗长。 建议switch…case结构可以用对象结构代替。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"JavaScript标准参考教程 1 导论","slug":"JavaScript标准参考教程 导论","date":"2018-08-11T08:58:56.000Z","updated":"2018-10-09T03:11:45.000Z","comments":true,"path":"2018/08/11/JavaScript标准参考教程 导论/","link":"","permalink":"https://github.com/zdkswd/2018/08/11/JavaScript标准参考教程 导论/","excerpt":"","text":"JS标准参考教程 1 导论什么是JSJavaScript 是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。 目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。 JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。 • 浏览器控制类：操作浏览器 • DOM 类：操作网页的各种元素 • Web 类：实现互联网的各种功能 JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。 此书是针对浏览器的js JS代码的注意问题","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/zdkswd/tags/JavaScript/"}]},{"title":"微信小程序剖析 运行机制","slug":"微信小程序剖析-运行机制","date":"2018-08-11T02:02:43.000Z","updated":"2018-08-11T03:34:11.000Z","comments":true,"path":"2018/08/11/微信小程序剖析-运行机制/","link":"","permalink":"https://github.com/zdkswd/2018/08/11/微信小程序剖析-运行机制/","excerpt":"","text":"解压应用简单的说明一下： app 目录下放置了app的代码 modified_modules 即一些修改后的模块 node_modules 地球人都知道 package.json 配置了NW相关的内容 在modified_modules目录下有两个子模块： anyproxy，从名字就可以看起来这是一个代理模块 weinre，远程调试工具 IDE这是一个NodeWebkit封装的Web应用。 1234node-webkit能做什么？用Web技术（Node.JS，JavaScript，HTML5）开发桌面应用程序。Node.js是一个Javascript运行环境(runtime environment)。实质是对Chrome V8引擎进行了封装。Node.js使用Module模块去划分不同的功能，以简化应用的开发。Modules模块有点像C++语言中的类库。每一个Node.js的类库都包含了十分丰富的各类函数，比如http模块就包含了和http功能相关的很多函数，可以帮助开发者很容易地对比如http,tcp/udp等进行操作，还可以很容易的创建http和tcp/udp的服务器。 在package.json中的”main”: “app/html/index.html”,即定义了这个APP的入口是这个index.html，而不是别的文件。 这是一个React应用。 1React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套。 其中的编辑环境是基于Monaco。1monaco editor是微软开源的一款web版代码编辑器。它支持智能提示，代码高亮，代码格式化。 WeAPP运行机制wxml： html，wxss ： css。对应的有几个不同的transform: transWxmlToJs transWxssToCss transConfigToPf transWxmlToHtml transManager PF指代的是PageFrame的意思，pageFrame有一个对应的模板文件。 名为wcc以及一个名为wcsc的工具。wcc用于转换wxml中的自定义tag为virtual_dom。wcsc转换wxss为css 可以理解为微信小应用有点类似于 Virtual Dom + WebView，毕竟上面有个WAWebView文件 ，还有一个webviewSDK文件 。 当然无论是React + WebView，或者Vue + WebView都不重要，现在有了 WA + WebView 在本地写的WeApp都会被提交到微信服务器，然后打包，上传到服务器，交给CDN。 1CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 上传的过程大致如下： APP会被打包成以日期命名 + .wx文件。 IDE会检测包的大小，并提示：代码包大小为 xx kb，超过限制 xx kb，请删除文件后重试。这个xx好像是1024，所以APP的大小是1M。 APP将会上传。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://github.com/zdkswd/tags/微信小程序/"}]},{"title":"微信应用号开发基础教程","slug":"微信应用号开发基础教程","date":"2018-08-10T03:14:13.000Z","updated":"2018-08-10T03:19:22.000Z","comments":true,"path":"2018/08/10/微信应用号开发基础教程/","link":"","permalink":"https://github.com/zdkswd/2018/08/10/微信应用号开发基础教程/","excerpt":"","text":"前言获取微信小程序的AppID创建项目编写代码app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。 app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 创建页面微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。 每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。 index.wxml 是页面的结构文件。 index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。 index.wxss 是页面的样式表。页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。 index.json 是页面的配置文件。页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。 手机预览第一章 准备工作第二章 项目架构从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。 生命周期：顺序是 App Launch–&gt;App Show–&gt;onload–&gt;onShow–&gt;onReady。 首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。 路由：微信在路由方面经过很好的封装，也提供三个跳转方法。 wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。 wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。 wx.navigateBack()：关闭当前页面，回退前一页面。 组件：微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。 其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的rem.js也是不支持的。 此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。 注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。 建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。 编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。 使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式： @import “wxss/index.CSS“ 注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。","categories":[{"name":"教程","slug":"教程","permalink":"https://github.com/zdkswd/categories/教程/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://github.com/zdkswd/tags/微信小程序/"}]},{"title":"《深度学习》4 数值计算","slug":"《深度学习》4 数值计算","date":"2018-08-03T01:47:12.000Z","updated":"2018-08-10T03:22:24.000Z","comments":true,"path":"2018/08/03/《深度学习》4 数值计算/","link":"","permalink":"https://github.com/zdkswd/2018/08/03/《深度学习》4 数值计算/","excerpt":"","text":"上溢和下溢连续数学在数字计算机上的根本困难是,我们需要通过有限数量的位模式来表示无限多的实数。这意味着我们在计算机中表示实数时,几乎总会引入一些近似误差。 种极具毁灭性的舍人误差是下溢( underflow)。当接近零的数被四舍五入为零时发生下溢。 另一个极具破坏力的数值错误形式是上溢( overfow)。当大量级的数被近似为+∞或-∞时发生上溢。进一步的运算通常会导致这些无限值变为非数字。 必须对上溢和下溢进行数值稳定的一个例子是softmax函数。 病态条件 这是最大和最小特征值的模之比1 。当该数很大时，矩阵求逆对输入的误差特别敏感。 这种敏感性是矩阵本身的固有特性，而不是矩阵求逆期间舍入误差的结果。 基于梯度的优化方法大多数深度学习算法都涉及某种形式的优化。优化指的是改变 x 以最小化或最 大化某个函数 f(x) 的任务。我们通常以最小化 f(x) 指代大多数最优化问题。最大化可经由最小化算法最小化−f(x) 来实现。 我们把要最小化或最大化的函数称为 目标函数(objective function)或 准则 (criterion)。当我们对其进行最小化时，我们也把它称为 代价函数(cost function)、 损失函数(loss function)或 误差函数(error function)。 有些临界点既不是最小点也不是最大点。这些点被称为 鞍点(saddle point)。 最速下降法(method of steepest descent) 或 梯度下降(gradient descent)。 其中 ε 为 学习率(learning rate)。 梯度之上:Jacobian 和 Hessian 矩阵有时我们需要计算输入和输出都为向量的函数的所有偏导数。包含所有这样的偏导数的矩阵被称为 Jacobian 矩阵。 雅可比矩阵。 当我们的函数具有多维输入时，二阶导数也有很多。我们可以将这些导数合并 成一个矩阵，称为 Hessian 矩阵。 黑塞矩阵。 Hessian 等价于梯度的 Jacobian 矩阵。 当 Hessian 的条件数很差时，梯度下降法也会表现得很差。 病态条件也导致很难选择合适的步长。步长必须足够小，以免冲过最小而向具有较强正曲率的方向上升。这通常意味着步长太小，以致于在其他较小曲率的方向上进展不明显。 牛顿法， 仅使用梯度信息的优化算法被称为一阶优化算法(first-order optimization al- gorithms)，如梯度下降。使用 Hessian 矩阵的优化算法被称为二阶最优化算法(second-order optimization algorithms)(Nocedal and Wright, 2006)，如牛顿法。 在深度学习的背景下，限制函数满足Lipschitz 连续(Lipschitz continuous)或 其导数Lipschitz连续可以获得一些保证。直觉上，利普希茨连续函数限制了函数改变的速度，符合利普希茨条件的函数的斜率，必小于一个称为利普希茨常数的实数（该常数依函数而定）。 最成功的特定优化领域或许是 凸优化(Convex optimization)。凸优化通过更强 的限制提供更多的保证。凸优化算法只对凸函数适用，即 Hessian 处处半正定的函 数。因为这些函数没有鞍点而且其所有局部极小点必然是全局最小点，所以表现很 好。然而，深度学习中的大多数问题都难以表示成凸优化的形式。凸优化仅用作一 些深度学习算法的子程序。凸优化中的分析思路对证明深度学习算法的收敛性非常 有用，然而一般来说，深度学习背景下凸优化的重要性大大减少。 约束优化在 x 的某些集合 S 中找 f(x) 的最大值或最小值。这被称 为 约束优化(constrained optimization)。在约束优化术语中，集合 S 内的点 x 被称为可行(feasible)点。 我们常常希望找到在某种意义上小的解。针对这种情况下的常见方法是强加一 个范数约束，如 ||x|| ≤ 1。 Karush–Kuhn–Tucker(KKT)方法是针对约束优化非常通用的解决方案。KKT 方法是 Lagrange 乘子法(只允许等式约束)的推广。 我们可以使用一组简单的性质来描述约束优化问题的最优点。这些性质称 为 Karush–Kuhn–Tucker(KKT)条件 (Karush, 1939; Kuhn and Tucker, 1951)。 这些是确定一个点是最优点的必要条件，但不一定是充分条件。这些条件是: 广义 Lagrangian 的梯度为零。 所有关于 x 和 KKT 乘子的约束都满足。 不等式约束显示的 ‘‘互补松弛性’’.","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"https://github.com/zdkswd/tags/深度学习/"}]},{"title":"《深度学习》3 概率与信息论","slug":"《深度学习》3 概率与信息论","date":"2018-08-01T09:20:12.000Z","updated":"2018-08-10T03:22:18.000Z","comments":true,"path":"2018/08/01/《深度学习》3 概率与信息论/","link":"","permalink":"https://github.com/zdkswd/2018/08/01/《深度学习》3 概率与信息论/","excerpt":"","text":"为什么要使用概率在医生诊断病人的例子中,我们用概率来表示一种信任度( degree of belief),其中1表示非常肯定病人患有流感,而0表示非常肯定病人没有流感。前面那种概率,直接与事件发生的频率相联系,被称为频率派概率( frequentist probability);而后者,涉及到确定性水平,被称为贝叶斯概率( Bayesian probability)。 随机变量随机变量( random variable)是可以随机地取不同值的变量。 随机变量可以是离散的或者连续的。离散随机变量拥有有限或者可数无限多的状态。注意这些状态不一定非要是整数;它们也可能只是一些被命名的状态而没有数值。连续随机变量伴随着实数值。 概率分布离散型变量和概率质量函数 1也有翻译成概率分布律的 连续型变量和概率密度函数 边缘概率 条件概率 条件概率的链式法则 独立性和条件独立性 如果关于x和y的条件概率分布对于z的每一个值都可以写成乘积的形式那么这两个随机变量x和y在给定随机变量z时是条件独立的。 期望、方差和协方差 协方差的绝对值如果很大则意味着变量值变化很大并且它们同时距离各自的均值很远。如果协方差是正的,那么两个变量都倾向于同时取得相对较大的值。如果协方差是负的,那么其中一个变量倾向于取得相对较大的值的同时,另一个变量倾向于取得相对较小的值,反之亦然。其他的衡量指标如相关系数( correlation)将每个变量的贡献归一化,为了只衡量变量的相关性而不受各个变量尺度大小的影响。 协方差和相关性是有联系的,但实际上是不同的概念。它们是有联系的,因为两个变量如果相互独立那么它们的协方差为零,如果两个变量的协方差不为零那么它们一定是相关的。然而,独立性又是和协方差完全不同的性质。两个变量如果协方差为零,它们之间一定没有线性关系。独立性比零协方差的要求更强,因为独立性还排除了非线性的关系。两个变量相互依赖但具有零协方差是可能的。 常用概率分布Bernoulli分布（01分布） Multinoulli分布就是多项分布。 高斯分布即为正态分布。 指数分布和 Laplace分布指数分布 拉普拉斯分布 Dirac分布和经验分布Dirac分布狄拉克δ函数是一个广义函数，在物理学中常用其表示质点、点电荷等理想模型的密度分布，该函数在除了零以外的点取值都等于零，而其在整个定义域上的积分等于1。 狄拉克δ函数在概念上，它是这么一个“函数”：在除了零以外的点函数值都等于零，而其在整个定义域上的积分等于1。 经验分布 分布的混合通过组合一些简单的概率分布来定义新的概率分布也是很常见的。一种通用的组合方法是构造混合分布( mixture distribution)。混合分布由一些组件( component)分布构成。 混合模型是组合简单概率分布来生成更丰富的分布的一种简单策略。 混合模型使我们能够一瞥以后会用到的一个非常重要的概念—潜变量。 常用函数的有用性质logistic sigmoid函数 softplus函数 贝叶斯规则 连续型变量的技术细节连续型随机变量和概率密度函数的深入理解需要用到数学分支测度论(Ineasure heory)的相关内容来扩展概率论。 信息论信息论是应用数学的一个分支,主要研究的是对一个信号包含信息的多少进行量化。在机器学习中,我们也可以把信息论应用于连续型变量。 信息论的基本想法是一个不太可能的事件居然发生了,要比一个非常可能的事件发生,能提供更多的信息。 也记作H(P)。换言之,一个分布的香农熵是指遵循这个分布的事件所产生的期望信息总量。当x是连续的,香农熵被称为微分熵( differential entropy)。 又称为相对熵，是用来度量使用基于Q的编码来编码来自P的样本平均所需的额外的比特个数。典型情况下，P表示数据的真实分布，Q表示数据的理论分布，模型分布，或P的近似分布。 是描述两个概率分布P和Q差异的一种方法。它是非对称的，这意味着D(P||Q) ≠ D(Q||P)。特别的，在信息论中，D(P||Q)表示当用概率分布Q来拟合真实分布P时，产生的信息损耗，其中P表示真实分布，Q表示P的拟合分布。 有人将KL散度称为KL距离，但事实上，KL散度并不满足距离的概念，因为：(1)KL散度不是对称的；(2)KL散度不满足三角不等式。 结构化概率模型机器学习的算法经常会涉及到在非常多的随机变量上的概率分布。通常，这些概率分布涉及到的直接相互作用都是介于非常少的变量之间的。使用单个函数来描述整个联合概率分布是非常低效的 (无论是计算上还是统计上)。 我们可以把概率分布分解成许多因子的乘积形式，而不是使用单一的函数来表 示概率分布。例如，假设我们有三个随机变量 a, b 和 c，并且a影响b的取值，b影响c的取值，但是 a 和 c 在给定 b 时是条件独立的。我们可以把全部三个变量的概 率分布重新表示为两个变量的概率分布的连乘形式: 这种分解可以极大地减少用来描述一个分布的参数数量。每个因子使用的参数 数目是它的变量数目的指数倍。 我们可以用图来描述这种分解。把它称为结构化概率模型(structured probabilistic model)或者图模型(graphical model)。 有两种主要的结构化概率模型:有向的和无向的。两种图模型都使用图 G，其中 图的每个节点对应着一个随机变量，连接两个随机变量的边意味着概率分布可以表 示成这两个随机变量之间的直接作用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"https://github.com/zdkswd/tags/深度学习/"}]},{"title":"《深度学习》2 线性代数","slug":"《深度学习》2 线性代数","date":"2018-07-31T09:41:12.000Z","updated":"2018-08-10T03:22:13.000Z","comments":true,"path":"2018/07/31/《深度学习》2 线性代数/","link":"","permalink":"https://github.com/zdkswd/2018/07/31/《深度学习》2 线性代数/","excerpt":"","text":"标量、向量、矩阵和张量 标量( scalar)一个标量就是一个单独的数,它不同于线性代数中研究的其他大部分对象(通常是多个数的数组)。我们用斜体表示标量。标量通常被赋予小写的变量名称。当我们介绍标量时,会明确它们是哪种类型的数。比如,在定义实数标量时,我们可能会说“令s∈R表示一条线的斜率”;在定义自然数标量时,我们可能会说“令n∈N表示元素的数目”。 向量( vector):一个向量是一列数。这些数是有序排列的。通过次序中的索引,我们可以确定每个单独的数。通常我们赋予向量粗体的小写变量名称,比如x。向量中的元素可以通过带脚标的斜体表示。向量x的第一个元素是x1,第二个元素是x2,等等。我们也会注明存储在向量中的元素是什么类型的。如果每个元素都属于R,并且该向量有n个元素,那么该向量属于实数集R的n次笛卡尔乘积构成的集合,记为 。当需要明确表示向量中的元素时,我们会将元素排列成一个方括号包围的纵列: 我们可以把向量看作空间中的点,每个元素是不同坐标轴上的坐标。有时我们需要索引向量中的一些元素。在这种情况下,我们定义一个包含这些元素索引的集合,然后将该集合写在脚标处。比如,指定x1,和,我们定义集合S={1,3,6},然后写作xs。我们用符号一表示集合的补集中的索引。比如x-1表示x中除x1外的所有元素,x-s表示x中除x1,x3,x6外所有元素构成的向量。 矩阵( matrix):矩阵是一个二维数组,其中的每一个元素被两个索引(而非一个)所确定。我们通常会赋予矩阵粗体的大写变量名称,比如A（斜体）。如果一个实数矩阵高度为m,宽度为n,那么我们说 。我们在表示矩阵中的元素时,通常以不加粗的斜体形式使用其名称,索引用逗号间隔。比如,A1，1表示A左上的元素,Am，n表示A右下的元素。我们通过用“：”表示水平坐标,以表示垂直坐标i中的所有元素。比如,Ai,:表示A中垂直坐标i上的一横排元素。这也被称为A的第i行(row)。同样地,A:,i表示A的第i列column)。当我们需要明确表示矩阵中的元素时,我们将它们写在用方括号括起来的数组中: 有时我们需要矩阵值表达式的索引,而不是单个元素。在这种情况下,我们在表达式后面接下标,但不必将矩阵的变量名称小写化。比如 表示函数f作用在A上输出的矩阵的第i行第j列元素。 张量( tensor):在某些情况下,我们会讨论坐标超过两维的数组。一般地个数组中的元素分布在若干维坐标的规则网格中,我们称之为张量。我们使用字体A（不是斜体）来表示张量“A”。张量A中坐标为(i,j,k)的元素记作Ai,j,k。 转置( transpose)是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像这条从左上角到右下角的对角线被称为主对角线( main diagonal)。我们将矩阵A的转置表示为AT,定义如下 向量可以看作只有一列的矩阵。对应地,向量的转置可以看作是只有一行的矩阵。 。标量可以看作是只有一个元素的矩阵。因此,标量的转置等于它本身,a=aT。转置的运算性质 1【】只是记法 在深度学习中,我们也使用一些不那么常规的符号。我们允许矩阵和向量相加,产生另一个矩阵:C=A+b,其中 。换言之,向量b和矩阵A的每一行相加。这个简写方法使我们无需在加法操作前定义一个将向量b复制到每一行而生成的矩阵。这种隐式地复制向量b到很多位置的方式,被称为广播( broadcasting )。 矩阵和向量相乘 单位矩阵和逆矩阵 线性相关和生成子空间 1还有一种看法是以列向量为新的参考系，看在参考系下要表示的向量的坐标。 不等式n≥m仅是方程对每一点都有解的必要条件。这不是一个充分条件。 1奇异值行列式为0 范数有时我们需要衡量一个向量的大小。在机器学习中,我们经常使用被称为范数（norm)的函数衡量向量大小。形式上, 范数定义如下： 范数(包括 范数)是将向量映射到非负值的函数。直观上来说,向量x的范数衡量从原点到点x的距离。更严格地说,范数是满足下列性质的任意函数： 当p=2时, 范数被称为欧几里得范数( Euclidean norm)。它表示从原点出发到向量c确定的点的欧几里得距离。L2范数在机器学习中出现地十分频繁,经常简化表示为 ,略去了下标2。平方L2范数也经常用来衡量向量的大小,可以简单地通过点积 计算。 另外一个经常在机器学习中出现的范数是L∞范数,也被称为最大范数（max norm)这个范数表示向量中具有最大幅值的元素的绝对值: 1弗罗贝尼乌斯范数 特殊类型的矩阵和向量对角矩阵 对称 单位向量 正交矩阵 特征分解特征分解( eigendecomposition)是使用最广的矩阵分解之一,即我们将矩阵分解成一组特征向量和特征值。 1矩阵A乘以x表示，对向量x进行一次转换（旋转或拉伸)（是一种线性转换），而该转换的效果为常数c乘以向量x（即只进行拉伸）。 奇异值分解我们探讨了如何将矩阵分解成特征向量和特征值。还有另一种分解矩阵的方法,被称为奇异值分解( singular value decomposition,SVD),将矩阵分解为奇异向量( singular vector)和奇异值( singular value)。通过奇异值分解,我们会得到一些与特征分解相同类型的信息。然而,奇异值分解有更广泛的应用。每个实数矩阵都有一个奇异值分解,但不一定都有特征分解。例如,非方阵的矩阵没有特征分解,这时我们只能使用奇异值分解。 Moore-Penrose伪逆 迹运算 另一个有用的事实是标量在迹运算后仍然是它自己:a=Tr(a)。 行列式行列式,记作det(A),是一个将方阵A映射到实数的函数。行列式等于矩阵特征值的乘积。行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或者缩了多少。如果行列式是0,那么空间至少沿着某一维完全收缩了,使其失去了所有的体积。如果行列式是1,那么这个转换保持空间体积不变。 实例:主成分分析主成分分析( principal components analysis,PCA)是一个简单的机器学习算法,可以通过基础的线性代数知识推导。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"https://github.com/zdkswd/tags/深度学习/"}]},{"title":"《深度学习》 1 引言","slug":"《深度学习》 1 引言","date":"2018-07-29T10:55:12.000Z","updated":"2018-08-10T03:22:06.000Z","comments":true,"path":"2018/07/29/《深度学习》 1 引言/","link":"","permalink":"https://github.com/zdkswd/2018/07/29/《深度学习》 1 引言/","excerpt":"","text":"引言讽刺的是,抽象和形式化的任务对人类而言是最困难的脑力任务之一,但对计算机而言却属于最容易的。计算机早就能够打败人类最好的象棋选手,但直到最近计算机才在识别对象或语音任务中达到人类平均水平。一个人的日常生活需要关于世界的巨量知识。很多这方面的知识是主观的、直观的,因此很难通过形式化的方式表达清楚。计算机需要获取同样的知识才能表现出智能。人工智能的一个关键挑战就是如何将这些非形式化的知识传达给计算机。 些人工智能项目力求将关于世界的知识用形式化的语言进行硬编码(hard code)。计算机可以使用逻辑推理规则来自动地理解这些形式化语言中的声明。这就是众所周知的人工智能的知识库( knowledge base)方法。然而,这些项目最终都没有取得重大的成功。其中最著名的项目是 Cyc(Lenat and Guha,1989)Cyc包括一个推断引擎和一个使用CycL语言描述的声明数据库。这些声明是由人类监督者输入的。这是一个笨拙的过程。人们设法设计出足够复杂的形式化规则来精确地描述世界。例如,Cyc不能理解一个关于名为rred的人在早上剃须的故事( Linde,1992)。它的推理引擎检测到故事中的不一致性:它知道人体的构成不包含电气零件,但由于Fred正拿着一个电动剃须刀,它认为实体“正在剃须的Fred”(“ Fred While Shaving”)含有电气部件。因此它产生了这样的疑问—Fred在刮胡子的时候是否仍然是一个人。；） 依靠硬编码的知识体系面对的困难表明,AI系统需要具备自己获取知识的能力即从原始数据中提取模式的能力。这种能力被称为机器学习( machine learning)引入机器学习使计算机能够解决涉及现实世界知识的问题，并能作出看似主观的决策。比如,一个被称为逻辑回归( logistic regression)的简单机器学习算法可以决定是否建议剖腹产(Mor- Yosef et al,1990)。而同样是简单机器学习算法的朴素贝叶斯( naive Bayes)则可以区分垃圾电子邮件和合法电子邮件 这些简单的机器学习算法的性能在很大程度上依赖于给定数据的表示( repre-sentation)。 许多人工智能任务都可以通过以下方式解决:先提取一个合适的特征集,然后将这些特征提供给简单的机器学习算法。例如,对于通过声音鉴别说话者的任务来说,一个有用的特征是对其声道大小的估计。这个特征为判断说话者是男性、女性还是儿童提供了有力线索。 然而,对于许多任务来说,我们很难知道应该提取哪些特征。例如,假设我们想编写一个程序来检测照片中的车。我们知道,汽车有轮子,所以我们可能会想用车轮的存在与否作为特征。不幸的是,我们难以准确地根据像素值来描述车轮看上去像什么。虽然车轮具有简单的几何形状,但它的图像可能会因场景而异,如落在车轮上的阴影、太阳照亮的车轮的金属零件、汽车的挡泥板或者遮挡的车轮一部分的前景物体等等。 解决这个问题的途径之一是使用机器学习来发掘表示本身,而不仅仅把表示映射到输出。这种方法我们称之为表示学习( representation learning)。学习到的表示往往比手动设计的表示表现得更好。并且它们只需最少的人工干预,就能让AI系统迅速适应新的任务。表示学习算法只需几分钟就可以为简单的任务发现一个很好的特征集,对于复杂任务则需要几小时到几个月。手动为一个复杂的任务设计特征需要耗费大量的人工时间和精力;甚至需要花费整个社群研究人员几十年的时间。 表示学习算法的典型例子是自编码器( autoencoder)。自编码器由一个编码器( encoder)函数和一个解码器( decoder)函数组合而成。编码器函数将输入数据转换为一种不同的表示,而解码器函数则将这个新的表示转换到原来的形式。我们期望当输人数据经过编码器和解码器之后尽可能多地保留信息,同时希望新的表示有各种好的特性,这也是自编码器的训练目标。为了实现不同的特性,我们可以设计不同形式的自编码器。 当设计特征或设计用于学习特征的算法时,我们的目标通常是分离出能解释观察数据的变差因素( factors of variation)。在此背景下,“因素”这个词仅指代影响的不同来源;因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反,它们可能是现实世界中观察不到的物体或者不可观测的力,但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因,它们还可能以概念的形式存在于人类的思维中。它们可以被看作数据的概念或者抽象,帮助我们了解这些数据的丰富多样性。当分析语音记录时,变差因素包括说话者的年龄、性别、他们的口音和他们正在说的词语。当分析汽车的图像时,变差因素包括汽车的位置、它的颜色、太阳的角度和亮度。 显然,从原始数据中提取如此高层次、抽象的特征是非常困难的。许多诸如说话口音这样的变差因素,只能通过对数据进行复杂的、接近人类水平的理解来辨识。这几乎与获得原问题的表示一样困难,因此,乍一看,表示学习似乎并不能帮助我们。 深度学习( deep learning)通过其他较简单的表示来表达复杂表示,解决了表示学习中的核心问题。 屏幕快照 2018-07-29 下午5.55.44 如何通过组合较简单的概念(例如转角和轮廓,它们转而由边线定义)来表示图像中人的概念。深度学习模型的典型例子是前馈深度网络或多层感知机( multilayer perceptron,MLP)。多层感知机仅仅是一个将一组输人值映射到输出值的数学函数该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。 学习数据的正确表示的想法是解释深度学习的一个视角。另一个视角是深度促使计算机学习一个多步骤的计算机程序。每一层表示都可以被认为是并行执行另组指令之后计算机的存储器状态。更深的网络可以按顺序执行更多的指令。顺序指令提供了极大的能力,因为后面的指令可以参考早期指令的结果。从这个角度上看在某层激活函数里,并非所有信息都蕴涵着解释输入的变差因素。表示还存储着状态信息,用于帮助程序理解输人。这里的状态信息类似于传统计算机程序中的计数器或指针。它与具体的输人内容无关,但有助于模型组织其处理过程。 屏幕快照 2018-07-29 下午6.03.19 由于不同的人选择不同的最小元素集来构建相应的图,因此就像计算机程序的长度不存在单一的正确值一样,架构的深度也不存在单一的正确值。另外,也不存在模型多么深才能被修饰为“深”的共识。但相比传统机器学习,深度学习研究的模型涉及更多学到功能或学到概念的组合,这点毋庸置疑。 屏幕快照 2018-07-29 下午6.07.58 本书面向的读者 屏幕快照 2018-07-29 下午6.09.31 深度学习的历史趋势神经网络的众多名称和命运变迁20世纪40年代到60年代深度学习的雏形出现在控制论( cybernetics)中。 尽管有些机器学习的神经网络有时被用来理解大脑功能( Hinton and shallice,1991),但它们一般都没有被设计成生物功能的真实模型。 现在,神经科学被视为深度学习研究的一个重要灵感来源,但它已不再是该领域的主要指导。 媒体报道经常强调深度学习与大脑的相似性。的确,深度学习研究者比其他器学习领域(如核方法或贝叶斯统计)的研究者更可能地引用大脑作为影响,但是大家不应该认为深度学习在尝试模拟大脑。 深度学习领域主要关注如何构建计算机系统,从而成功解决需要智能才能解决的任务,而计算神经科学领域主要关注构建大脑如何进行真实工作的比较精确的模型。 在20世纪80年代,神经网络研究的第二次浪潮在很大程度上是伴随一个被称为联结主义( connectionism)或并行分布处理( parallel distributed processing)潮流而出现的( Rumelhart et al,1986d; McClelland et al,1995)。 联结主义的中心思想是,当网络将大量简单的计算单元连接在一起时可以实现智能行为。这种见解同样适用于生物神经系统中的神经元,因为它和计算模型中隐藏单元起着类似的作用。 其中一个概念是分布式表示( distributed representation)( Hinton et al,1986)其思想是:系统的每一个输入都应该由多个特征表示,并且每一个特征都应该参与到多个可能输人的表示。例如,假设我们有一个能够识别红色、绿色、或蓝色的汽车、卡车和鸟类的视觉系统,表示这些输人的其中一个方法是将九个可能的组合:红卡车,红汽车,红鸟,绿卡车等等使用单独的神经元或隐藏单元激活。这需要九个不同的神经元,并且每个神经必须独立地学习颜色和对象身份的概念。改善这种情况的方法之一是使用分布式表示,即用三个神经元描述颜色,三个神经元描述对象身份。这仅仅需要6个神经元而不是9个,并且描述红色的神经元能够从汽车、卡车和鸟类的图像中学习红色,而不仅仅是从一个特定类别的图像中学习。分布式表示的概念是本书的核心。 联结主义潮流的另一个重要成就是反向传播在训练具有内部表示的深度神经网络中的成功使用以及反向传播算法的普及( Rumelhart et al,1986c; LeCun,1987)。这个算法虽然曾黯然失色不再流行,但截至写书之时,它仍是训练深度模型的主导方法。 在20世纪90年代,研究人员在使用神经网络进行序列建模的方面取得了重要进展。 Hochreiter(191b)和 Bengio et al.(1994a)指出了对长序列进行建模的些根本性数学难题, Hochreiter and schmidhuber(1997)引入长短期记忆( long short-term memory,LSTM)网络来解决这些难题。如今,LSTM在许多序列建模任务中广泛应用,包括 Google的许多自然语言处理任务。 神经网络研究的第三次浪潮始于2006年的突破。Geoffrey Hinton表明名为深度信念网络的神经网络可以使用一种称为贪婪逐层预训练的策略来有效地训练。 神经网络研究的这一次浪潮普及了“深度学习”这一术语的使用,强调研究者现在有能力训练以前不可能训练的比较深的神经网络,并着力于深度的理论重要。此时,深度神经网络已经优于与之竞争的基于其他机器学习技术以及手工设计功能的AI系统。 尽管深度学习的研究重点在这一段时间内发生了巨大变化。第三次浪潮已开始着眼于新的无监督学习技术和深度模型在小数据集的泛化能力,但目前更多的兴趣点仍是比较传统的监督学习算法和深度模型充分利用大型标注数据集的能力。 与日俱增的数据量“大数据”时代使机器学习更加容易。截至2016年,一个粗略的经验法则是,监督深度学习算法在每类给定约5000个标注样本情况下一般将达到可以接受的性能,当至少有1000万个标注样本的数据集用于训练时,它将达到或超过人类表现。此外,在更小的数据集上获得成功是一个重要的研究领域,为此我们应特别侧重于如何通过无监督或半监督学习充分利用大量的未标注样本。 与日俱增的模型规模20世纪80年代,神经网络只能取得相对较小的成功,而现在神经网络非常成功的另一个重要原因是我们现在拥有的计算资源可以运行更大的模型。联结主义的主要见解之一是,当动物的许多神经元一起工作时会变得聪明。单独神经元或小集合的神经元不是特别有用。 就神经元的总数目而言,直到最近神经网络都是惊人的小。自从隐藏单元引人以来,人工神经网络的规模大约每2.4年扩大一倍。这种增长是由更大内存、更快的计算机和更大的可用数据集驱动的。更大的网络能够在更复杂的任务中实现更高的精度。这种趋势看起来将持续数十年。除非有能力迅速扩展的新技术,否则至少要到21世纪50年代,人工神经网络将才能具备与人脑相同数量级的神经元。生物神经元表示的功能可能比目前的人工神经元所表示的更复杂。 屏幕快照 2018-07-29 下午6.47.54 现在看来,其神经元比一个水蛭还少的神经网络不能解决复杂的人工智能问题是不足为奇的。即使现在的网络,从计算系统角度来看它可能相当大的,但实际上它比相对原始的脊椎动物如青蛙的神经系统还要小。 由于更快的CPU、通用GPU的出现更快的网络连接和更好的分布式计算的软件基础设施,模型规模随着时间的推移不断增加是深度学习历史中最重要的趋势之一。人们普遍预计这种趋势将很好地持续到未来。 与日俱增的精度、复杂度和对现实世界的冲击 屏幕快照 2018-07-29 下午6.51.21 深度学习的另一个最大的成就是其在强化学习( reinforcement learning)领域的扩展。在强化学习中,一个自主的智能体必须在没有人类操作者指导的情况下,通过试错来学习执行任务。 DeepMind表明,基于深度学习的强化学习系统能够学会玩并在多种任务中可与人类匹敌Mnih et al.,2015)。深度学习也显著改善了机器人强化学习的性能。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"https://github.com/zdkswd/tags/深度学习/"}]},{"title":"松本行弘的程序世界 14 函数式编程","slug":"松本行弘的程序世界 14 函数式编程","date":"2018-07-26T13:00:32.000Z","updated":"2018-07-27T03:20:34.000Z","comments":true,"path":"2018/07/26/松本行弘的程序世界 14 函数式编程/","link":"","permalink":"https://github.com/zdkswd/2018/07/26/松本行弘的程序世界 14 函数式编程/","excerpt":"","text":"松本行弘的程序世界 14 函数式编程新范型–函数式编程函数式编程是全部使用函数来编写程序代码的编程方法。这是可以与一般的结构化编程及面向对象编程相提并论的编程方法。 以函数为中心的函数式编程具有特征： 函数本身也作为数据来处理（第一级函数） 以函数为参数的高阶函数 参数相同即可保证结果相同的引用透明性。 为实现引用透明性，禁止产生副作用的处理。 函数式编程的最大优点在于，程序可以按照数学的形式以及声明的形式来编写。 结构式编程是在改变变量值的同时进行计算，所以一直注意着，这个变量的值是什么，并据此来预想计算过程。 采用函数式编程方式并不改变变量的值。并不包含状态或者动作等信息，仅仅是对想要做什么加以描述，这样不容易出错。 这种不是描述动作而是描述性质的编程方式称为声明式编程。声明式描述是函数式编程的一大优点。 具有多种函数式性质的Lisp之前，Lisp被认为是函数式编程的代表。Lisp具备函数式语言的很多性质。 Lisp最大的特征是S式记法。S式是括号很多的Lisp的记法。S式无与伦比的优点是它彻底的统一性。对Lisp而言，不管什么都可以同一成单一形式。 第二个重要之处在于链这种数据结构。Lisp语言本名是List Processor（链表处理器），从侧面说明了链的重要性。链是一种构成树结构数据的通用数据结构，构成数据结构的节点分别包含两个引用。 屏幕快照 2018-07-25 上午10.02.29 总之，Lisp具备了函数编程语言的基本特征。但是Lisp不直接支持多数纯粹的函数式编程语言所拥有的副作用如回避以及延迟计算等功能。对变量的赋值没有任何限制。且编程风格为很多很多括号。比较难适应。 近年来，由于像Haskell这样的彻底的函数式编程语言的兴起，Lisp作为函数式编程语言在人们心中的印象越来越淡薄。 彻底的函数式编程语言HaskellHaskell可以说是纯粹的函数式编程语言。Haskell语言特征： 没有副作用 高阶函数 函数部分应用 延迟计算(非正式) 静态多态类型系统 型推论 链内包表达式 用对齐来表示块 没有副作用Haskell程序基本没有副作用，不但不能改变变量的值，就连链的元素也是不能改变的。因此，只要参数不变，函数的返回值也就总是一样的。相同输入总能返回相同结果，这种可重复性对测试程序非常有利。这种重复性也称为引用透明性。 高阶函数Haskell高阶函数把函数本身作为数据来处理。比如，Haskell中没有循环控制结构，循环都是用递归调用或者高阶函数来实现的。 延迟计算：不必要的处理就不做必要时才进行处理。 灵活的“静态多态性”类型系统与没有类型的Ruby不同，Haskell是在编译时确定所有变量类型的静态类型语言。但实际上Haskell程序基本上没有必要给出变量的类型。这是因为聪明的Haskell语言处理系统会推测变量的类型。 Haskell利用多态性的类型系统和系统推测，在维持着接近于duck typing灵活性的同时，也使编译时的完全类型检查成为可能。 近代函数式语言之父OCamlOCaml也是具有代表性的函数式编程语言之一。它比Haskell还古老，说它是近代函数式语言之父也毫不为过。 与Haskell相比，OCaml具有如下不同： 没有副作用 没有延迟计算 具有强力的模块系统 虽然不像Haskell那样自然地做到延迟计算，但换来的好处是，程序内容与实际处理关系接近，使人容易理解程序的执行过程。 强于并行计算的Erlang作为函数式编程语言，二郎的特点 受Prolog影响 专用于并行计算 用Ruby进行函数式编程Ruby中有几个能进行函数式编程的工具 Proc对象（lambda）Ruby中唯一与函数直接对应的是Proc对象。 程序块以程序块为参数的方法等价于函数型语言的高阶函数。灵活运用以程序块为参数的方法，就可以实现函数式编程的高阶函数的技巧。 枚举器Ruby中没有延迟计算，但用枚举器对数组和列表进行循环，可以实现类似于延迟计算的处理。 避免副作用所谓避免副作用，就是对生成的对象，尽量少去改变其状态。 用枚举器来实现延迟计算从Ruby1.8.7开始，很多以块为参数的方法在参数不是块的时候，就会返回枚举器。 枚举器就是把循环用对象来表达的一种方法。 使用这样的枚举器可以实现与Haskell类似的延迟计算。 自动生成代码在商业中利用Ruby使用Ruby自动生成代码编程中的代码重复是非常恶劣的。发现了代码重复，就应该考虑在合理的代价范围内避免代码重复的方法。 消除重复代码为了在构建程序的时候，自动生成省略部分，我们只需要定义make的规则、在构建程序的过程中调用代码生成工具。 代码生成的应用数据库访问从数据结构定义自动生成数据库的访问例程（包括SQL）。 用户接口大多数依赖于数据库的Web应用程序，常常需要对表的各项目进行增删改查操作。 单元测试代码生成对单元测试也很有效果。只要有数据和测试条件，就可以开始单元测试。 客户界面文档化代码生成也适合与文档化。对于自动生成的类，由人工记入档案是纯粹的浪费。按照JavaDoc的形式，在生成代码的程序里写好相应的文档，应该是个聪明的办法。 代码生成的效果代码生成有如下好处： 改进质量。 确保一致性 集中知识。 增加用于设计的时间。 独立于程序实现的设计判断 编写代码生成器对代码生成最有帮助的工具要数eRuby。Ruby本身也拥有优越的文本处理功能。使用eRuby以比较自然地形式编写模板的同时，还可以灵活运用Ruby的处理能力。 也可以使用XML幸运的是，Ruby拥有解释XML的标准库REXML。REXML提供操作XML的功能。 在EJB中使用代码生成1EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分 内存管理与垃圾收集垃圾收集（GC）是一种管理程序使用的内存区域的方法。使用具有垃圾收集功能的编程语言或处理程序的话，程序中不需要编写内存管理的代码，即不用编写代码来释放使用过的内存区域。 内存管理的困难在垃圾收集普及之前，内存区域的取得和释放完全是程序员的责任。随着程序的执行，会使用一些内存区域作为作业区。为记忆对象、字符串和数组等个别信息，都需要使用内存区域。没有垃圾收集的语言一般都提供有API，利用这些API，可以再需要时向操作系统申请并取得内存，使用过之后再把内存区域返回给操作系统。 悬挂指针如果把还在使用中的内存区域错误调用free予以释放的话，就会发生悬挂指针的现象。程序再去访问该区域时就可能会出错。在引用该区域内容时，多数场合会读取到被破坏的数据，或是在更新该领域数据的时候，会置换成预想之外的数据。 内存泄漏另一方面，如果忘记了把申请的内存区域返还给操作系统的话，就会发生内存泄漏。这时候因为使用过的内存区域越来越多，程序占有的内存就会逐渐增加。特别是长时间启动，连续提供服务的常驻内存型程序，容易发生内存泄漏，导致系统停止等重大问题。 二重释放对已经释放过的内存区域再次调用free的情况也时有发生。这称为二重释放。这会带来malloc和free内部使用的数据区域不一致的问题。 内存泄漏问题只有在内存占用量超过预想的时候才会显露，而悬挂指针问题不会发生在释放使用内存的时刻，而是要到访问释放过的内存区域才会出现。程序员往往会在看起来完全没有问题的地方突然遭遇意想不到的错误。 垃圾收集亮相之前应该管理的内存区域越来越多，内存释放时刻的管理也就越来越难，这是产生内存问题的原因。 关于垃圾收集，有以下这些先入为主的观念。 垃圾收集慢有研究表明，在某些条件下，垃圾收集比手工管理内存还更快。 垃圾收集可靠性低在Java之后诞生的编程语言，不管是否受到Lisp的影响，几乎都毫无例外的拥有垃圾收集的功能。垃圾收集从诞生之日起，经历了40多年的发展，终于成为大家认可的一项特性了。 评价垃圾收集的两个指标假如存在无线内存的计算机的话，就没有必要进行垃圾收集。 垃圾收集的性能可以由两个指标来测定： 吞吐量吞吐量是垃圾收集处理在程序全部执行时间中所占的比例。比例越小越好，比例大的话，程序整体的性能就会低下。 暂停时间暂停时间是一次垃圾收集处理所中断的时间。暂停时间过长的话，处理的中断时间就会变得很显眼，程序反应就会变慢。 垃圾收集每次所花的时间会因垃圾收集执行时对象的总数而变化，暂停时间有两种，一是把垃圾收集时间求平均值得到平均暂停时间，二是程序执行中最长的垃圾收集时间所代表的最大暂停时间。 那些实时性要求高的程序，就很重视最大暂停时间。像批处理这样非对话的处理强调吞吐量要高，而重视反应速度的嵌入式或者GUI程序就强调暂停时间要短。 Java运行环境中实现由多种垃圾收集算法，可以根据程序的性质来切换合适的垃圾收集算法。 垃圾收集算法基本上是以下4类，还有几种变形： 引用计数方式 标记和扫除方式 标记和紧缩方式 复制方式 引用计数方式引用计数方式在垃圾收集算法中具有最简单最容易实现的特征。 屏幕快照 2018-07-25 下午5.25.46 引用计数器最大的优点就是容易实现。这种方式得到广泛的使用。暂停时间短也是它的优点。 最大的缺点是不能释放有循环引用关系的对象群。 屏幕快照 2018-07-25 下午5.28.21 与生俱来的缺点，因为在引用增减的时候有必要同时正确维护引用计数器的增减，忘了这一点就会带来悬挂指针或内存泄露问题。 最后一个缺点是，引用计数器的管理与并行处理不相容。如果多个进程同时增减一个引用计数器的话，就会发生引用计数器的值不一致的现象。为避免这一个问题，需要在操作引用计数器的时候进行排他处理，但在频繁发生引用操作的同时进行排他处理的话，会带来巨大的时间开销。 总之，这种原理简单实现也简单的引用计数器方式，缺点很多，最近已经不怎么用了。 采用引用计数器方式的主要语言处理系统有Perl和Python。为了回避循环引用的问题，它们都组合了其他垃圾收集方式。这些语言基本上以引用计数器方式来进行垃圾收集，只有在极个别的情况下，才通过别的垃圾收集算法来处理引用计数器不能回收的对象。 标记和扫除方式标记和扫除方式也是古老的垃圾收集算法。标记和扫除方式从有可能成为对象引用元的变数（根）开始，给被引用的对象加上标记，表明其“活着”。然后再给标记对象所引用的对象还有其再引用的对象，也都递归地加上引用标记。 这样从根开始不管是直接还是间接，只要把所有引用的对象都加上标记的话，那么没有标记的对象就是没有被引用的，也就是“已经死了”。然后在所有的对象中找出没有标记的对象，把它们作为垃圾扫除出去。 屏幕快照 2018-07-25 下午5.50.20 此法虽然古老，但是非常优秀，现在也还被多种处理系统所采用。 但是当对象数目较多时，性能容易恶化。在标记的时候要访问生存的所有对象，在回收时按顺序访问所有的对象，找出”已经死了“的对象。在寻找垃圾和扫除过程中，基本不能进行其他处理，垃圾收集时间长的话，会影响到本来的处理工作。 标记和紧缩方式标记和紧缩方式是标记和扫除的变形。标记处理是一样的，后阶段有所不同。 屏幕快照 2018-07-26 下午12.01.29 标记和紧缩方式最大的特征也是他的优越之处，是把空间集中起来（紧缩）。紧缩的结果是把没有释放而活下来的对象都集中到一个地方。这样，内存访问就集中到一个局部区域，这可以提高缓存功能的效率。对象的分配也只是把指针移动一下就完成了，降低了对象分配的开销。 缺点是，把生存着的对象全部复制的紧缩开销，容易比标记和扫除方式中执行的开销还要大。因为对象被移动位置了。 一部分Lisp处理系统采用的是标记和紧缩方式，Java处理系统（作为多个垃圾收集算法中的一个）也有标记和紧缩方式。 复制方式像标记和扫除方式、标记和紧缩方式这样“标记之后释放死了的对象”的算法，标记时间与活着的对象数成比例，扫除时间与总对象数成比例。所以在分配有很多的对象，其中几乎所有对象都要被释放的场合，扫除的开销会变高，在性能方面很不利。 复制方式与标记和扫除方式一样，从根开始扫描所有的对象，但他不仅仅是加标记，还执行复制。 屏幕快照 2018-07-26 下午12.11.58 复制方式把内存空间分成旧空间和新空间两大块，总是在旧空间中分配对象。旧空间爆满时，从根开始扫描对象，把对象复制到新空间。这时，复制后的引用也要随之更新。 递归的执行从旧空间到新空间的复制，结束时就会把所有活着的对象都移动到新空间。不再被引用的对象都遗留到旧空间，旧空间就可以整个弃之不用，就避免了扫除的开销，从此再把新空间作为旧空间再进行同样的处理。 最大的优点是，垃圾回收的开销只和活着的对象数成比例。对象分配的开销也低。还有“局部性”的优点。复制方式按顺序把引用的对象复制到新空间，关系近的对象会被分配到相近的内存空间，称为局部性。关系近的对象被访问的可能性也高。计算机因为有缓存，内存空间相接近的访问可能具有较好的性能，局部性高的程序具有提高性能的优势。 缺点：复制方式要复制所有活着的对象，几乎具有和标记和紧缩方式一样的缺点。 多种多样的垃圾收集算法把基本算法组合起来的技术，几个具有代表性的： 分代垃圾收集 保守垃圾收集 增量垃圾收集 并行垃圾收集 位图标志 这些技术的组合也是有可能的。 分代垃圾收集分代垃圾收集的基本思想是利用程序和对象的性质。一般程序都有这样一个性质，几乎所有的对象都在比较短的时间里变成垃圾，存活时间超过一定程度的对象总是拥有更长的寿命。 因为这一性质，就可以重点对分配之后的年轻对象进行扫描，这样就不用扫描全部对象就可能高效率地回收垃圾。 分代垃圾收集把对象的内存空间分成两个，新代和旧代，也有分成3个的。 只扫描新代区域的回收称为轻垃圾收集，但没有检查旧代区域对新代的引用，被引用的对象可能误判死亡，就会带来内存问题。 解决这一问题的方法是，监视对象的更新。在旧代区域引用新代区域的同时，就把这一引用的记录例程以及对象的更新场所全都记录下来，这个检查例程叫做写屏障，记录旧代区域对新代区域的引用叫记录集。 以所有区域对象的垃圾收集称为全垃圾收集或重垃圾收集。 屏幕快照 2018-07-26 下午12.33.58 分代垃圾收集减少了扫描对象的个数，有缩短平均暂停时间的效果。但是，因为要执行全垃圾收集，最大暂停时间不会得到明显的改善。 最近几乎所有的Java都实现有分代垃圾收集。另外，函数型语言OCaml也采用了分代垃圾收集。 保守垃圾收集像C这种本来没有垃圾收集的语言，编译之后没有保留区别整数和指针的信息，因为CPU对两者不加区分，所以也就没这个必要。通常，垃圾收集的实现需要明确区分引用（指针），而C和C++没有这样的功能，在这样的环境下实现垃圾收集的技巧之一称为保守垃圾收集。 其基本思想就是如果碰巧有整数的值与引用相同的话，该对象就有可能被引用，就当它是活着的。保守就是倾向于安全的意思。与此相对，能够明确区别所用的环境下的垃圾收集称为精确垃圾收集。 因为倾向于安全一面，保守垃圾收集在C或者C++这样没有垃圾收集功能的语言中也可以得到实现，这是它的优点。但是，本来应该回收的对象却在意料之外保留下来不能回收，这是它的缺点。以及，它不能喝复制垃圾收集这样需要移动的垃圾收集算法组合使用。 Ruby采用的是保守垃圾收集。局部变量可以按照通常语言的访问路径来处理，系统堆栈部分是当做指针数组来扫描的。Ruby大部分是用C编写的，因为有了保守垃圾收集，C库的实现变得非常简单。实际上，Python和Perl因为采用的是引用计数器，C例程内部的引用数管理非常复杂，偶然忘记增减就会发生内存问题。但是，用C编写Ruby扩展库时，基本上不用操心内存管理，好处十分明显。 Boehm GC为C和C++增加了垃圾收集功能。Boehm GC也同时实现了分代垃圾收集。Boehm GC不仅用于C和C++，在Scheme处理系统Gauche等多种语言处理系统中，也作为垃圾收集功能得到广泛的应用。 增量垃圾收集在实时性要求高的程序中，垃圾收集带来的中断时间必须是可预测的。为保证实时性，不需要等垃圾收集完全执行结束，而是要把垃圾收集细分正许多细小的片段，每次执行一点，这叫增量垃圾收集。 增量垃圾收集在垃圾收集处理过程中程序也在同时执行，引用有可能会改变。结果是垃圾收集的一致性不能得到保证。增量垃圾收集为避免这样的问题，采用了与保守垃圾收集相同的写屏蔽操作。 嵌入式处理系统采用的是增量垃圾收集。有名的Io和Lua都实现了增量垃圾收集。 并行垃圾收集在多核环境下，灵活运用线程可以最大限度地发挥多个CPU的能力。并行垃圾收集就是要最大限度利用多个CPU的能力。 并行垃圾收集基本原理与增量垃圾收集大致是一样的，都是利用写屏蔽来维护当前状态的信息。有的并行垃圾收集的实现生成垃圾收集专用线程，把垃圾收集设计成总是与普通处理并行执行。 位图标记以Linux为首的UNIX系列操作系统在使用fork系统调用复制过程时，内存空间并不进行复制而是直接共享。通过写时复制来提高性能。 垃圾收集与这一功能兼容性不好，给引用对象那个设置标记的方式会因设置标记而复制包含该对象的内存页。复制方式也同样会产生大量写内存操作。 位图标记是在利用标记的垃圾收集中消减操作系统内存页复制的方法。它不在对象里设置被引用的标记，而是利用外部位图区域（管理用内存区域）来保存引用标记。 只有标记用的位图部分会发生内存页复制，从而避免了复制没有实际更新的对象所在的内存页。 Ruby的垃圾收集也有了实现位图标记的补丁。 用C语言来扩展RubyRuby是解释型语言，即Ruby程序是由Ruby解释器的程序来解释执行的。 提起解释器，大家会觉得它是逐行读取程序并执行，实际上Ruby解释器是把要执行的程序全部读进来，首先变换成更有效率的内部表现形式。解释器对其内部表现加以分析来执行程序。 解释型语言的特点，马上可以执行，开发周期非常快。至于C、C++、Java这样的编译语言，首先要把程序变换成计算机可以直接执行的形式再从头执行。 在执行程序过程中，编译型语言不再需要对原来程序进行解释和变换，速度很快。但是开发周期较长。 开发与执行速度的取舍这两种类型的语言要做取舍。Ruby的设计方针是开发效率优于执行效率，选择解释型的实现也是必然。 Ruby解释器是由C语言开发的，采用C语言开发理由： C语言作者拿手 C语言运行系统调用，速度高 用面向对象语言来实现别的面向对象语言的话，容易混淆对象的概念。 屏幕快照 2018-07-26 下午5.36.05 引擎是解释内部表现，并实际上执行程序的部分。1.9版本的引擎解释的字节码，可以说是近似于虚拟计算机的机器语言。所以1.9版本的引擎也可以成为VM。 引擎在解释内部表现是，需要其他组件的帮助。内存和对象的管理，变量访问和方法调用的实现等，都要依靠底层称为运行库的组件来完成。运行库提供底层强有力的支持，是程序执行时不可或缺的部分。 Ruby利用的各种类是类库提供的。Ruby的这一部分也是用C编写的。像Ruby这样的解释型语言，因为是经过C编写的引擎来间接执行程序，与一般的编译语言相比，执行速度明显慢得多（100 倍或者 1000 倍）。但是，实际上程序的执行时间大部分都花在 C 編写的类库方法内部，因此在执行速度上很少会产生那么巨大的差距。 扩展库扩展库是指利用Ruby运行库的API,用C定义的类库。Ruby的API使用C几乎可以实现Ruby所有的功能。使用这些API可以很简单地实现如下的功能： 定义类 定义方法 访问实例变量 调用方法 调用块 特意花时间用C来实现扩展库的理由主要有以下两点。 想要比Ruby执行速度快 想使用C可以利用的库。 前面已经说过,Ruby是解释型语言,它的执行速度不如像C这样的编译型语言。如果是绝对需要改善速度的程序,用C扩展库来实现其中成为瓶颈的部分的话,有可能显著改善程序的执行速度。 UNX系列操作系统的大多数功能都是通过C可以访问的库来提供的。Ruby要想利用这些功能的话,就需要有一种从Ruby调用C的API的方法,这最简单的方法就是利用扩展库。 扩展库的编译首先按照以上的顺序编写源代码。若C程序的文件名后约定为c的话,后续步骤会自动识别出来C程序文件。 为生成编译所需要的文件,需要准备必要的Ruby文件。这个文件通常命名为 extconf.rbminitab的 extconf.rb的内容如图所示 屏幕快照 2018-07-26 下午7.09.31 extons,xb是由以下几个部分构成的: 调用 require’mkmf’; 用have_1 ibrary和 hava header检查必要的库和头文件是否存在； 用 create makefile来生成必要的Makefile. create makefile的参数是库的名字。 照图14-34执行 extconfrb,就可以生成Makefi1e。 屏幕快照 2018-07-26 下午7.13.48 用make命令来编译,尔后可以用 make insta11命令来安装编译后的库。 扩展库之外的工具RubyInlineRubylnline可以在Ruby的源代码中直接嵌入C的程序。不用每次准备 exton,rb文件,也不需要明确的编译步骤,非常便利,但它也有不少约束,比如在执行环境中需要有编译器,与外部库的链接也有些麻烦等。 dl有了d1,仅用Ruby也能实现与 minitab同样动作的库。把图1435的程序保存成 inial,rb文件,没有扩展库也可以使用 minitab。al的优点是在没有安装编译器和头文件的环境下也可以运行。 ffi关于Ruby的扩展,ffi库受到关注。ffi是 foreign function interface的缩写,它也提供在Ruby水平上的与外部函数的直接接口,这个目的与d1几乎是一样的。ffi可以从 Ruby Gems得到。ffi的特征是使用lb更有效率地调用外部函数,Ruby、 Rubinius和 GRubby都可以使用同样的API。 为什么要开源自由软件的思想为保证执行的自由,必须能够将软件免费拿到手。出于学习和研究的目的,也必须能够自由地得到源代码。还有,为了修改程序错误,或者为适合自己的目的而进行改造,那就不单单是阅读源代码,还要允许改变源代码。把自己认为好的软件推荐给别人,或者把自己进行的修改或改善与他人共享的话,就需要有再发布的自由。 自由软件的历史曾几何时,在计算机的黎明期,软件完全是硬件的附属物。买了计算机,附带操作系统等源代码,根本就不是什么稀罕的事。那时,或者在更早一些的时候,甚至有这样的情况,从生产厂家买来的计算机连操作系统也没有,需要用户自己来开发各种软件。买了同样计算机的用户互相交换自己开发的软件,互助合作。虽然不够精致,但与如今开源软件的情况很有些相似之处。 Emacs事件的发生但是,戈斯林把 Gosmacs的专利卖给了 Unipress公司,斯托曼就不能够在 Gosmacs的基础上开发新的 Emacs了。结果,斯托曼从零开始开发了自己的UNIX版的Emacs。 他们的最终目标是，创造一个从上到下完全自由的操作系统环境。 开源的诞生 屏幕快照 2018-07-26 下午8.52.32 OSS许可证GPLGPL( GNU General Public license)应该可以说是自由软件许可证的鼻祖,它具有如下特征: 没有保证; 表示版权; 保持同样的许可证 GPL特征中最重要的是保持同样的许可证,也就是说,在对GPL许可证的软件进行修改或复制的情况下,必须保持其原来的GPL许可证。这意味着再利用GPL软件的源代码而开发的软件的许可证也必须是GPL。批判GPL的人把这称为感染性。赞同GPL的人们称之为版权保留,因为这一性质意味着版权的保留。 LGPLBSD许可证APL和CPL开源的背景在科学领域,共享知识和信息本来是非常普通的事情。即使不用看站在巨人的肩膀上的牛顿的例子,把知识作为论文(免费)公开,利用前人的成绩进行新的研究是再理所当然不过的。 软件,特别是商业软件,一旦作为商品来经营的话,就容易忘记这样一点,与论文的内容一样,软件也不过是信息的一种,也应该适用同样的原则。科学家致力于研究,大学或研究机构对科学家给予支持,这种体制对软件也有可能成立。实际上,大学或研究机构支援软件开发的例子相当多。 但是,谈到近年来开源的普及和发展,计算机的普及和因特网的发展则功不可没。过去如果要想开发髙质量软件的话,需要购买价格髙昂的计算机,召集大量的技术人员。现在一般家庭里的计算机都完全能够开发软件,通过网络进行合作开发的事情也屡见不鲜。个人出于兴趣而编程也已经能够达到相当高的水平了。 软件的复杂化和商品化也是开源的背景之一,不容忽视。软件所覆盖的领域越来越广,软件也越来越复杂。过去1万行左右的程序就实现了的操作系统,如今变成了超过600万行的巨大软件。 企业关注开源的理由从1998年以来,开始出现了盈利企业为自己的利益而开发开源软件的事例。一旦认识到无法自己来开发所有软件之后,企业只自己开发最具竞争力的小部分核心软件,而让大家共同来开发其他软件,结果对大家都有好处,企业关注开源正是这种冷静的分析考量的结果。 参与开源的人们也各有各的想法。有因经营考虑而参加的企业,有为软件自由而参加的程序员,有因上级命令而参加的公司职员,各种各样,千差万别。但是,开源有可能为个人和全人类带来幸福,如果能继续下去形成良性循环的话,那真是再好不过了。 Ruby与开源Ruby从一开始就是开源软件。Ruby在1995年初次公开的时候,开源这个单词还没有诞生,也许应该称为自由软件。 选择许可证的方法许可证与技术无关,而是有关法律和合同的工作,这不是技术人员的工作,而是属于律师的工作范围。对于软件开发人员来说,这决不是一件令人感兴趣的工作,有人甚至会想:“哪用得着这些东西呢?” 如果使用你的许可证的软件的所有代码都完全是由你自己写出来的话,这几乎不成为什么问题。只要发布新的许可证版本,问题就解决了但是,如果其中包含了其他人写的补丁的话,软件就不再是你一个人的了,在法律上写补丁的人是共同拥有版权的。 FSF作为软件自由的拥护者,强烈推行版权保留。另一方面,不怎么在乎版权保留的开发人员好像更多一些。如果你希望版权保留的话,几乎就只能选择GPL。 如果你的软件是作为库来使用的话,那么LGPL则是个不错的选择。如果对库适用GPL许可证的话,那事实上就只能为GPL软件所用,采用限制较为宽松的LGPL的话,有可能使你的软件得到更为广泛的使用。但是,LGPL有不方便、难于理解以及没有得到充分考察等缺点,在不太强烈希望版权保留的时候,最好不要选择它。 对于不太在乎版权保留的人来说,可以选择GPL以外的许可证。这里的要点是,该软件是否需要与其他软件进行链接。如果预想到将来可能以某种方式与GPL许可证的软件链接在一起的话,那么与GPL的互换性就变得很重要。拥有插件功能的软件或库特别要注意这一点。作为与GPL不相矛盾的许可证,有修正BSD许可证和MIT许可证等。 另一个应该考虑的要点是,与相关软件和许可证是否一致。比如 Eclipse插件就应该选择Eclipse许可证(即使不与GPL互换)。另外,PHP关联软件选择与PHP一致的许可证也是安全的。用Ruby编写的软件与Ruby本身的许可证本来是相互独立的,但好像也大都选择Rby许可证。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 13 关于数据的持久化","slug":"松本行弘的程序世界 13 关于数据的持久化","date":"2018-07-24T02:00:32.000Z","updated":"2018-08-10T16:09:13.000Z","comments":true,"path":"2018/07/24/松本行弘的程序世界 13 关于数据的持久化/","link":"","permalink":"https://github.com/zdkswd/2018/07/24/松本行弘的程序世界 13 关于数据的持久化/","excerpt":"","text":"松本行弘的程序世界 13 关于数据的持久化持久化数据的方法保存文本变换成文本的Marshal将对象按一定的方式变换成文本，就可以保存到文件中去。这样的对象文本化就称为serialize(序列化)，或是marshal(封送处理)。 使用Marshal模块标准Ruby中，嵌入了marshal功能，这就是Marshal模块。Marshal模块中提供了几乎能将全部Ruby对象变为字节串的方法dump，以及将字节串恢复成原对象（的复制）的load方法。对象可以简单地保存到文件里。 复制有两种方式使用Marshal可以完成对象的深复制。复制对象的时候，通常使用clone方法。这种情况下，只复制直接对象，引用的对象不复制。称为浅复制。深复制连同引用对象也一起进行递归复制。 仔细看Marshal的格式Marshal用二进制形式将对象文本化。 屏幕快照 2018-07-23 上午11.07.00 屏幕快照 2018-07-23 上午11.09.40 不能保存的3类对象Marshal在实现上有限制。以下3类对象不能保存： 定义了特异方法的对象。 输入、输出或是套接字等不能超越进程保存的对象。 在扩充库中定义，Ruby不知道保存方法的对象。 但是即使不能封送处理，若不是像输入输出那种从原理上不可能的情况，单纯是不知道封送处理方法的话，重新教一遍也就行了。 制作面向对象数据库使用Marshal保存对象，使对象具有了持久性。所以，Marshal也可应用于面向对象数据库。PStore库是Marshal的一个用例。Marshal虽然只是将数据变换成字符串，PStore却利用了这一点，简单地实现了面向对象数据库。PStore有三个特征：使用Marshal，可以原封不动地保存任意的Ruby对象；具有容易使用的接口；有事务处理（transaction）。PStore也有缺点，它不适合一下子将数据全部读入内存的大规模数据库。但几百字节的小规模数据库，应该没问题。 试用PStore打开数据库开始事务处理对象的登录和取得事务处理的终止简单说明一下事务处理的步骤： 用flock将数据文件加锁。 用Marshal从数据文件中读取数据 执行（事务处理）块 块的执行成功，Marshal将数据写入数据文件 块的执行失败，什么也不做。 变换为文本的YAMLMarshal的变换结果是二进制文件，内容不容易看懂。有些场合及时效率低一些，也需要能够以更容易看懂的形式输出。能够满足要求的是YAML。使用文本形式，不依赖平台的体系结构，是一种对人而言易读易编辑的序列化格式。 有以下几个特征：记述简洁；结果容易读懂；使用缩进的层次表现；数据表现是专用的，不必烦恼标签的名称问题。 YMAL可以活用在Ruby on Rails的配置文件等各种各样的领域。YMAL是在Perl中开发的，但正式的支持，Ruby是第一个。 用YAML制作数据库类似于PStore的东西，YAML：：Store，其与PStore的互换性非常高，只要把名字换一换，面向PStore的程序在YAML：：Store也能运行。 他俩的区别： 数据格式很显然，一个YAML，一个Marshal。 数据量Marshal比YAML紧凑的多，Marshal牺牲了易读性而实现了良好性能。 执行速度性能优良不光是容量的问题。使用Marshal的PStore比YAML：：Store速度高，在这一点上，也是数据量越大，两者的差异就越显著。 对象的保存对象持久化库Madeleine，利用直接持久化对象的设计模式Object Prevalence。 Madeleine是Object Prevalence在Ruby中的实现，应称为PStore的发展形式。 PStore只是对象单纯由Marshal输出而来，Madeleine则与应用程序相协调，实现了高可靠性和高性能的持久化。 高速的Object Prevalence所谓Prevalence，是一种实现应用程序持久化和进程间共享数据的设计模式。高性能的秘密在于直接访问内存中的数据。Object Prevalence将处理的数据保存在正在执行的应用程序的内存中，检索等操作不通过SQL而是直接进行，节省了与数据库副武器的通信成本，引用当然就会很高速。 但是，只有是同一进程，才能引用内存中的数据，进程一结束，数据马上消失。从持久化角度有必要解决这一问题。 Object Prevalence用日志记录（journaling）和快照（snapshot）来解决这一问题。Object Prevalence中，数据更新时不是直接更新对象，而是创建称为command的对象，采用的是一种非常间接的方法，在用command更新对象时，内存中的对象更新的同时，所有的更新内容也会写到称为日志（journal log）的外部文件中。 长此下去日志越来越大，所以要将现在数据状态写到称为快照的文件中。有了快照，老日志就不需要了，可在适当的时机删除。 有了最新的快照和最新的日志，可以完全恢复现在对象的状态。程序启动，按三步骤恢复内存的数据。及时有多个进程，只要写入日志的信息是完整的，就可以共享对象的状态。 如果不存在快照，就初始化应用程序数据。 如果存在快照，就读入其中最新的一个。 如果还存在日志，也将其读入，并用其中最新的一个更新应用程序数据。 Object Prevalence的问题点Object Prevalence通过使用日志记录和快照实现了对象的持久化和进程间共享。Object Prevalence将所有数据都保存到内存中，随着数据量的增大，内存的消耗也在增大。 关系数据库中，不引用的数据放在文件中，必要的内存量就不用那么多了。 Object Prevalence有为了数据更新而具有的特殊结构，更新持久化数据时需要经由command对象。 使用Madeleine访问时刻信息让Madeleine更容易使用Madeleine既保持简洁性，又能让对象持久化，但是最大的缺点是在每次更新应用程序时必须生成command对象。 Madeleine的实用例InstikiMadeleine没有得到广泛应用，除了知道的人少，还因为数据全保存在内存中，就必须十分留意数据的大小。 Madeleine有一个很大的缺点，就是没有考虑多个进程同时更新数据的情况。 关于XML的考察XML的祖先是SGMLSGML是将文档电子化的一种格式。由三部分组成：表示数据本身的Instance，表示数据结构的DTD，以及SGML声明。 由于SGML太复杂，处理成本太高，为了表现网页，将SGML特化为HTML，随之诞生的是XML。 XML不像HTML那样是为了特定目的的标记语言，它一开始就是为了通用目的而设计的。为了让XML在没有DTD来定义语法或提供schema信息的情况下，也能够解析，人们对其语法进行了简化。 XML是树结构的数据表现XML基本上是纯文本，以类似于HTML的标签嵌套方式实现树结构。XML是继承了SGML的通用标记语言，其与SGML最大的区别是其基本语法固定，不依赖于DTD那样的外部信息也能解析。 即使没有标签的概要信息也能解析的语法称为良构的（well-formed）,这是XML的一大特征。 优点在于纯文本最大的优点在于XML基本上是纯文本的，表示结构的信息附加在标签里。 第二个优点是不易发生字符编码的问题。XML规定，在没有明确指定的情况下，字符编码均使用Unicode。 第三个优点是得益于良构的性质，在没有数据结构的情况下也能解析XML数据。这样就可以不考虑目的，而用共同的工具来处理XML数据。 第四个优点在于，XML与其解析工具不依赖于特定的语言，比如Java生成的XML数据在Ruby中的解析也很简单。解析XML的API，像DOM和SAX都超越语言提供了几乎共通的性质，所以不同语言也可以进行同样的操作。 最后一个有点是，人们也很容易理解。 总之，XML作为各种数据交换格式的框架，具有优良的性质。作为格式的格式，也就是元格式，是很优秀的。 缺点在于冗长最大的缺点是效率低下。XML是以纯文本出现的，标签信息反复出现，显得冗长。与表示相同信息的二进制数据相比，XML数据的容量要大得多，与其他文本表现方式相比（YAML，JSON）也显得冗长。 效率低下不光体现在数据大小上，解析XML的效率也不怎么高。与二进制文件相比，XML文件的解析因为含有大量字符串处理，而容易变得很慢。 作为文本的标记语言而诞生的XML，用其表现有一定结构的数据到底好不好还是个疑问。如果只是用于表现构造数据，比XML更有效率的格式还有很多。而且XML原则上只能表现树结构的数据。 总结，XML作为出于通用目的的数据格式，效率很低，所谓很多优点，如果场合不对，也没多大意义。适才适用，XML也要分情况适当使用。 不适合重视效率的处理对于重视通信量和速度的情况都不适合，此时应使用专用的协议或是效率更高的格式。 像配置文件那样靠人直接编辑的数据也不推荐XML。配置文件中，需要用到XML的树结构数据地方很少，随着要素数增加，就会很难读，用YMAL和JSON才更合适。 XML适合的场合： 人一般不直接接触 复杂性不成问题 效率不成为问题 跨平台 适合于信息交换的格式利用XML的元格式性质，以XML为基础的格式的例子。 RSS。Web网站更新信息。 Atom。RSS的代替。 ebXML。电子商务数据交换。 SVG。向量-图像表示。 SMIL。 多媒体及内容控制。 以上这些都具有XML的性质，可以用XML处理工具简单地解析。制作数据格式时，最麻烦的就是制作处理这种格式的软件。所以，XML与XML处理库的存在是很可贵的。 另外，XML数据库中，问题不在于数据是不是实际以纯文本XML来表现，而在于XML能够表现的树结构能够自由自在地操作。即，不是带标签的纯文本，而是由带属性、带内容的节点所构成的树结构本身才是最重要的。关系数据库的表只能表示间接数据，如果是树结构，可以直接操作直接表现的数据。 XML的解析XML的解析方法有好几种。 DOMDOM是文档对象模型的缩写，是对读取了XML数据的树结构进行操作的库。 SAXSimple API for XML,与将数据全部读入内存的DOM不同，通常，SAX以数据流的形式读入XML，以事件驱动进行处理。SAX中，没必要将数据全部读入，这样往往处理效率更高，所以适合于将XML变换为其他形式的处理，反过来说，不适合于对树结构进行随机访问等用途。 XPathXPath是用于指定XML树的一部分的书写格式。使用XPath，可以用节点名、属性名或是属性值等来选择特定的节点（群）。 XML处理库REXMLREXML是Ruby标准附属的XML处理库。REXML是具有DOM、SAX、SAX2以及XML Pull Parser等多照片那个功能的库。全部用Ruby实现，所以速度表现不怎么优秀。在特别重视效率的情况下，有必要用libxml等别的XML处理库。 XML的代替JSON（JavaScript Object Notation）JSON是把JavaScript的对象记法作为表现格式来使用。 将JSON数据原封不动地作为JavaScript去执行，就可以得到数据表现所对应的对象。但是JSON数据从外部读取的情况较多，实际上作为JavaScript直接执行容易引起安全上的问题，即使效率稍稍低一些，也应当使用解析JSON的库。 Ruby支持JSON。 YAML（YMAL ain’t Markup Language）YAML是作为XML的对立面而诞生的，具有以下特征。完全放弃标记性记述，专注于数据表现；以缩进为基础表现数据结构；不要标签；可以对应各种语言。文件后缀为.yml 在用作数据表现及配置文件时，具有易读和不易变复杂等优点。实际上，YAML在Ruby on Rails中广泛用于配置文件。 另一方面，YAML到底是数据表现语言，没有相当于schema的东西，不适合于带结构的文本表现及元数据格式。 活用记号和缩进的YMAL比JSON更简洁，正如其名，YMAL不是标记语言，需要使用标记语言时还是XML合适。1YAML是JSON的超集，采用空格来作为结构，JSON则是括号，一般YAML解析速度高于JSON，但对于某些东西定义的复杂性高于JSON，速度差别不大时可考虑用JSON。 Binary XML与通常的XML有等价意义，但效率更高，采用二进制表现的是Binary XML。但现在还没有Binary XML的标准规格。 Protocol BufferProtocol Buffer使用一种“数据描述语言”来定义数据结构，然后从这个定义生成一个库，将原始数据变为二进制表现（序列化）。 12持久数据的重要性如果不是有了像纸和刻了文字的石头等经久不烂而且可以读出的媒介，将来人类文明说不定会遇到失去重要信息的危险。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 12 关于时间的处理","slug":"松本行弘的程序世界 12 关于时间的处理","date":"2018-07-23T13:53:32.000Z","updated":"2018-07-23T13:53:46.000Z","comments":true,"path":"2018/07/23/松本行弘的程序世界 12 关于时间的处理/","link":"","permalink":"https://github.com/zdkswd/2018/07/23/松本行弘的程序世界 12 关于时间的处理/","excerpt":"","text":"松本行弘的程序世界 12 关于时间的处理用程序处理时刻与时间时差与时区世界协调时间夏令时一定时期内时钟拨快一小时。 改历日期与时间的类Time类表示日常所用时间的类。 Date类表示不含时刻的日期的类。 DateTime类Date类附加上时间信息的类。能表示时间，而且没有范围限制，功能上最强。 2038年问题不仅限UNIX，很多操作系统都是以过去某个时点开始所经过的时间来表示时刻的。在UNIX中，过去某个时点指1970年1月1日零点。问题是计算机能够处理的整数大小有限，界限是2038年1月19日3时14分7秒。 DateTime类相对于epoch（某个时点）开始的秒数来管理Time类，DateTime类是以日期为基础计算的Date类，附加上时刻信息而生成的。 Time与DateTime的相互变换","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 11 程序安全性","slug":"松本行弘的程序世界 11 程序安全性","date":"2018-07-21T13:28:32.000Z","updated":"2018-07-21T13:29:05.000Z","comments":true,"path":"2018/07/21/松本行弘的程序世界 11 程序安全性/","link":"","permalink":"https://github.com/zdkswd/2018/07/21/松本行弘的程序世界 11 程序安全性/","excerpt":"","text":"松本行弘的程序世界 11 程序安全性程序的漏洞与攻击方法四种软件漏洞 dos攻击 信息泄露 权限夺取 权限升格 DOS攻击，即拒绝服务攻击，指妨碍软件正常运行（服务的执行）的网络攻击手段。能够引起软件异常终止的程序错误，全部都是引发DOS攻击的安全性程序错误。分为软件漏洞与外部DOS攻击。信息泄露指不愿公开的信息被公开了。 因权限被窃取而成为重大问题安全问题的根源在于运行软件的人（权限所有者）和利用软件的人是不同的。安全问题有三种 恶意软件指在程序本身植入了恶意代码。 setuid/setgid指执行的程序以所有者权限进行动作。setuid的缺点已经变得比优点更突出，现在几乎不用了。 服务器 “守护神”引起的问题服务这里指的是为了提供服务而常驻型的软件，又为后台服务(daemon),即守护神的意思。后台服务基本上都是受理经由socket而来的请求。执行它所提供的服务，将结果经socket返回。几乎所有的情况，发出请求者和执行权限者都是不同的。这种软件若有了漏洞，会引起DOS问题和权限夺取问题。 多样化的攻击手段代表性的有： 缓冲区溢出 整数溢出 跨站点脚本攻击（XSS） SQL注入 跨站点伪造请求（CSRF） 缓冲区溢出指向固定的缓冲区输入了比假定长度要长很多的数据，使程序异常终止。或者是更改堆栈的跳转地址劫持程序。使用C那种连数组长度都不检查的语言，可以说肯定会产生问题。幸亏，像Ruby这样的高级语言，语言处理系统自动分配内存，可以不使用固定长的缓冲区。使用更高级的语言，可以从缓冲区溢出问题中解放出来。但由于速度上的考虑，还会开发C语言的CGI及Daemon程序，应多加注意。 整数溢出整数溢出与缓冲区溢出相似，但它是更难被发现的问题。c等很多语言，整数只能表示一定范围的数，超过范围，就会发生溢出，也不发出警告就将数值舍入。这个问题通过使用Ruby这样的高级语言可以解决，内存分配不是由用户直接进行，内部分配都要经过严格检查。所以，只要使用Ruby，与整数溢出就不沾边。 SQL注入SQL注入是对外部的输入检查不充分时所产生的典型问题。从外部的输入不能原封不动填到SQL语句中去，因为填入的文字可能含有对SQL语句有某种意义的文字。 Shell注入Shell注入与SQL注入原理相同。从外部的输入，如果不进行检查就不能传递给system等危险的函数。为了从一定程度上检查出这类问题，Ruby和Perl中有“污染检查”功能。给外部输入的数据加上“污染记号”，禁止对字符串进行危险操作。 跨站点脚本攻击跨站点脚本攻击与SQL注入和Shell注入一样，也是因为将输入值原封不动地放在输出值内而引起的问题。如用户输入中含有HTML标签。而且HTML可能夹杂JavaScript。 跨站点伪造请求跨站点伪造请求（CSRF）是Web应用程序固有的攻击手段。构成Web应用程序的每一页由两部分构成，一个来自网路浏览器的HTTP请求，一个是HTTP服务器的响应。 屏幕快照 2018-07-21 下午7.11.22 社会工程用异常进行错误处理异常的历史Java的受控异常采用受控异常的，Java是第一个。 Icon的面向目标判断Ruby在设计之初，也曾认真考虑过采用像Icon式的真伪值判断，结果还是采用了nil和false以外的值全是真值的这种正统方式。 Ruby的异常 屏幕快照 2018-07-21 下午7.30.12 异常发生 屏幕快照 2018-07-21 下午7.33.32 异常处理的设计方针方法的执行应当“异常安全”，即执行时及时发生了异常也不会发生异常情况： 因为发生了异常，留下了不完全的数据结构 因为发生了异常，数据库里进了垃圾 因为发生了异常，程序异常终止 异常发生的设计原则假设发生的情况与既有的异常类明显不同，需要制作一个新的异常。此时考虑： 名称：应该给新的类起一个什么样的名字 父类：新的类应该属于哪一个异常类的子类 生成方法：应该如何初始化新的类实例 产生异常的两个原则：1异步异常，基本原则是不要使用异步异常。2.文档化，有必要清楚详细的写成文档。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 10 高速执行和并行处理","slug":"松本行弘的程序世界 10 高速执行和并行处理","date":"2018-07-20T09:58:32.000Z","updated":"2018-07-20T10:20:12.000Z","comments":true,"path":"2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/","link":"","permalink":"https://github.com/zdkswd/2018/07/20/松本行弘的程序世界 10 高速执行和并行处理/","excerpt":"","text":"松本行弘的程序世界 10 高速执行和并行处理让程序高速执行（前篇）是不是越快越好并不是视速度最优先就一定好。预算、开发效率和开发周期等制约因素也在性能权衡范围之内。 高速执行的乐趣与效率在进行性能优化之前，必须确认是否真有必要提高速度。速度提高到什么程度也要事先估算。 以数据为基础做出判断改善系统调用排序处理任务重时，典型的对策是使用施瓦茨变换。 数据可靠吗误差 只需改善瓶颈性能优化中，“因为是排序，所以就用施瓦茨变换”这种条件反射式的对策并非总管用。为了合理提高速度，确立恰当的策略是很必要的。帕累托法则又称80/20法则，即80%的数值是由20%的构成要素产生的。由帕累托法则可知，有20%的努力可以达到巨大回报，而有80%的努力得不到多少回报。在得不到回报的地方，不管怎么努力都是徒劳的。Donald Knuth也提到，通常一半以上的执行时间都耗费在程序中不到4%的部分。这些耗费了大半以上执行时间的部分称为瓶颈。判定瓶颈，可以用profiler这一工具。 profiler本身成了累赘不确定性原理是指测定行为本身对被测对象产生了影响，从原理上可以说不可能正确知道对象的状态。但是知道实际状态的大体倾向。 算法与数据结构选择合适的算法，这是性能改善的第一考虑因素，要记住这条铁则。 理解O记法如何从效率方面判定一个算法的好坏呢。一个方法就是O记法，表示某种算法对于变量（比如使用的元素个数）如何变化。 屏幕快照 2018-07-20 上午11.05.39 选择算法调查算法的性能Ruby提供进行算法性能比较时用的benchmark程序。 高速执行的悲哀徒劳无益的努力很容易在瓶颈无关的地方花费太多徒劳无益的努力。 改良绊住了手脚sort_by所依据的施瓦茨变换，是用时间和空间的交换来消减计算量的方法。sort_by方法与sort方法相比，占用了多达三倍以上的内存。所以，模块内的处理本来不是很重，如果一味地占用内存反而可能会变慢。性能优化，光有理论还不行，如果不实际做的话就不知道到底什么是正确的。 算法选择的圈套在进行性能优化时，不改变原来程序的执行时一个大原则。 性能优化的格言过早的优化是万恶之源。 优化有两条准则。1.别做优化2.（仅适用于专家）先不要做优化 过早的优化是万恶之源代码优化的好处多多，但是这并不意味着所有的代码都需要进行优化，有时过度的优化反而适得其反——费时、费力、不讨好。“现代计算机科学的鼻祖”Donald Knuth曾说过“过早的优化是万恶之源”，因为：让正确的程序更快，要比让快速的程序正确容易得多。在项目开发中，总是有程序员浪费宝贵的时间去改进那些不需要改进的代码，而没有通过所做的改进增加价值。在对项目进行优化时，究竟哪些地方应该优化，应该如何优化，哪些不应该优化呢？你需要先来了解一下本文所说的这7件事。1.究竟要优化什么？在优化工作开始的时候，你还尚未明确优化内容和目的，那么你很容易陷入误区。在一开始，你就应该清楚地了解你要达到的效果，以及其他优化相关的各种问题。这些目标需要明确指出（至少精通技术的项目经理可以理解和表达它），接下来，在整个优化过程中，你需要坚持这些目标。在实际的项目开发中，经常会存在各种各样的变数。可能一开始时要优化这一方面，随后你可能会发现需要优化另一方面。这种情况下，你需要清晰地了解这些变化，并确保团队中的每个人都明白目标已经发生了变化。2.选择一个正确的优化指标选择正确的指标，是优化的一个重要组成部分，你需要按照这些指标来测量优化工作的进展情况。如果指标选择不恰当，或者完全错误，你所做的努力有可能白费了。即使指标正确，也必须有一些辨别。在某些情况下，将最多的努力投入到运行消耗时间最多的那部分代码中，这是实用的策略。但也要记住，Unix/Linux内核的大部分时间花费在了空循环上。需要注意的是，如果你轻易选择了一个很容易达到的指标，这作用不大，因为没有真正解决问题。你有必要选择一个更复杂的、更接近你的目标的指标。3.优化在刀刃上这是有效优化的关键。找到项目中与你的目标（性能、资源或其他）相背的地方，并将你的努力和时间用在那里。举一个典型的例子，一个Web项目速度比较慢，开发者在优化时将大部分精力放在了数据库优化上，最终发现真正的问题是网络连接慢。另外，不要分心于容易实现的问题。这些问题尽管很容易解决，但可能不是必要的，或与你的目标不相符。容易优化并不意味着值得你花费工夫。4.优化层次越高越好在一般情况下，优化的层次越高，就会越有效。根据这个标准，最好的优化是找到一个更有效的算法。举个例子，在一个软件开发项目中，有一个重要的应用程序性能较差，于是开发团队开始着手优化，但性能并没有提升太多，之后，项目人员交替，新的开发人员在检查代码时发现，性能问题的核心是由于在表中使用了冒泡排序算法，导致成千上万项的增加。尽管如此，高层次的优化也不是“银弹”。一些基本技术，如将所有东西移到循环语句外，也可以产生一些优化的效果。通常情况下，大量低层次的优化可以产生等同于一个高层次优化的效果。还需要注意的是，高层次优化，会减少一些代码块，那么你之前对这些代码块所做的优化就没有任何意义了，因此，刚开始就应该考虑高层次的优化。5.不要过早优化在项目早期就进行优化，会导致你的代码难以阅读，或者会影响运行。另一方面，在项目后期，你可能会发现之前所做的优化没有起到任何作用，白白浪费了时间和精力。正确的方式是，你应该将项目开发和优化当作两个独立的步骤来做。6.依赖性能分析，而不是直觉你往往会认为你已经知道哪里需要优化，这是不可取的，尤其是在复杂的软件系统中，性能分析数据应该是第一位的，最后才是直觉。优化的一个有效的策略是，你要根据所做工作对优化效果的影响来进行排序。在开始工作之前找到影响最大的“路障”，然后再处理小的“路障”。7.优化不是万金油优化最重要的规则之一是，你无法优化一切，甚至无法同时优化两个问题。比如，优化了速度，可能会增加资源利用；优化了存储的利用率，可能会使其他地方放慢。你需要权衡一下，哪个更符合你的优化目标。 让程序高速执行（后篇）例题是曼德勃罗集合的计算程序，指复平面上满足以下条件的复素数的集合：经过某种反复迭代运算以后，其值不会发散到无限大。 确认程序概要发现瓶颈使用profiler 使用更好地profilerruby-prof程序通过使用扩展库可以实现高速profile 高速优化之一：消减对象Ruby高速优化的规则。 减少对象高级面向对象语言中对象的生成要花费一定的时间，减少对象，除了会降低生成成本外，还有别的好处。Ruby中不在使用的对象，由被称作垃圾收集的处理自动进行回收。垃圾收集处理需要检查对象的引用关系，任何地方都不再引用的对象会被判定为已经不再使用了。当对象的数量很多时，判断成本就要增大。 减少方法调用方法调用中，存在多态性这一面向对象的本质特征，先要评价参数，判定对象种类，然后选出一个合适的方法，再讲控制交给该方法，这是一个缓慢的处理过程。为了避开方法调用，尽可能不用Ruby中实现的方法。Ruby中实现的方法，几乎所有的情况都是调用其他方法来实现的。也就是说，只要使用了一次Ruby中实现的方法，就会有多余的方法调用发生。 高速优化之二：利用立即值Ruby中有几类对象并不实际分配内存，而是用引用本身来表示，这种值称为立即值。现在的Ruby中，小的整数（±2 ^30以内）、真假值、nil和符号名等都是立即值。立即值既然不生成对象，就不用担心对象的生成成本，而且也不用垃圾收集处理，所以它具有特别理想的特性。 高速优化之三：利用C语言Ruby是解释性语言，单纯计算的循环不是很快。如果将处理交给编译器，就可以变得很快。 高速优化之四：采用合适的数据结构全部以C语言计算还存在其他技巧还有以空间换时间。 并行编程使用线程的理由与进程不同，同一进程的线程可以共享内存空间，所以，不同的线程能够引用同一对象。不需要经过将数据变为字节流再进行通信这样麻烦的处理，就能交换信息。 生成线程线程的执行状态Ruby的线程有四种状态。run：执行中stop：停止中to_kill:终止处理中killed:终止 屏幕快照 2018-07-20 下午1.55.11 传递值给线程的方法信息共享所产生的问题 数据完整性丧失 死锁 与其说是线程的问题，不如说是并行处理本身的问题。 数据完整性的丧失原子操作 死锁哲学家进餐问题 用锁来实现对资源的独占Ruby Mutex类，互斥锁。Java中，方法定义声明为synchronize,该方法被调用时自动加锁。 二级互斥很遗憾，锁的问题并不全是Mutex所能覆盖的单纯事例。如数据库中，对数据的访问需要以下多种互斥控制。 可以同时引用 禁止同时更新 禁止更新中引用 禁止引用中更新 引用与更新这种两个层次的互斥（二级互斥），在文件读取时也经常会发生。 数据库锁总结 数据库锁出现的原因是为了处理并发问题，因为数据库是一个多用户共享的资源，当出现并发的时候，就会导致出现各种各样奇怪的问题，就像程序代码一样，出现多线程并发的时候，如果不做特殊控制的话，就会出现意外的事情，比如“脏“数据、修改丢失等问题。所以数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制，所以数据库锁是跟并发控制和事务联系在一起的。 平时会经常看到或者听到数据库锁有“共享锁”，“排它锁”，“互斥锁”，“写锁”，“读锁”，“悲观锁”，“乐观锁”，“行级锁”，“表级锁”，“页级锁”等，同时我们还会常看到“丢失修改“，”不可重复读“，”读脏数据“这三个术语，他们究竟是什么关系以及怎么理解呢，下面就来介绍一下他们。 先说事务的特性，要想成为事务，必须满足：ACID（原子性，一致性，隔离性，持久性）四特性，事务是恢复和并发控制的基本单位。原子性指的是事务是数据库的逻辑工作单位，事务中操作要么都做，要么都不做；一致性指的是事务的执行结果必须是使数据库从一个一致性状态变大另一个一致性状态，一致性和原子性是密切相关的；隔离性指的是一个事务执行不能被其他事务干扰；持久性指的是一个事务一旦提交，他对数据库中数据的改变就是永久性的。 先说悲观锁和乐观锁吧。并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。乐观锁就比较简单了，就是不做控制，这只是一部分人对于并发所持有的一种态度而已。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁和共享锁，其中排它锁又称为写锁，共享锁又称为读锁。 共享锁和排它锁是具体的锁，是数据库机制上的锁，存在以下关系： 屏幕快照 2018-07-20 下午2.17.40 (x表示是排它锁(Exclusive)，s表示共享锁(Share)，Y表示yes，N表示no） 上图表示可以共存的锁，如，第二行表示，一个事务T1给某数据加了X锁，则事务T2就不能再给那数据加X锁了，同时也不能再加S锁了，只有到T1事务提交完成之后，才可以。默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁。另外，并发操作会导致数据的不一致性，主要包括“丢失数据”，“不可重复读”，“读脏数据等。还有就是，并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防，预防的方法有：1一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；2顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。另外，系统如何判断出现死锁呢，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁，诊断和判断死锁有两种方法，一是超时法，二是等待图法。超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。 最后，说下行级锁和表级锁。锁包括行级锁和表级锁行级锁是一种排他锁，防止其他事务修改此行。 用队列协调线程使用锁对资源进行互斥控制，是线程间保证协调的一种机制。除了锁以外，为了保证协调，还有别的方法。问题的根源在于多个进程访问同一资源，为了实现无共享，给每个资源准备一个管理用的线程，各线程间只能交换某些限定的信息。线程间信息交换的方法有代表性的有信息存储，信道及队列。 屏幕快照 2018-07-20 下午3.05.36 1这里的生产者消费者问题并不是典型的生成者消费者问题，而是做出了一定的限制，即生产速度小于消费速度。不锁buffer,仅做信息传递的通道来进行说明。 队列也可以用于解决资源的竞争。 屏幕快照 2018-07-20 下午3.08.13 锁模型与队列模型的比较锁模型如果竞争足够少，多数情况下能保持较高性能，对于资源的竞争，不能忘记加锁，要做到完美无缺较难。 队列模型在竞争少的时候，其性能比不上锁模型，比锁模型更容易贯彻，会因线程增多而带来性能低下的恶果。 前景可期的并行编程技术，Actor并行编程，要求有更高的抽象度和对人类而言更简单的编程模型。Actor（参与者模式）或许就是答案。 何谓Actor所谓Actor，是（仅）通过消息（message）进行通信的实体。与面向对象语言中对象的区别。向对象发送消息（方法调用），调用开始后，会一直等到返回结果，是一种同步方式。面向Actor发送消息，仅仅是发送消息而不返回结果，是一种异步方式。123同步(Synchronous)和异步(Asynchronous)1.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。2.异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。 Actor由于仅仅通过消息进行信息交换，所以不能直接共享同一个值，信息传达要多花些代价。Actor由于没有消息以外的信息传递手段，所以不用担心Actor之间的资源竞争。发送给Actor的消息都配送到各个Actor所拥有的邮箱里。多个消息同时到达时竞争由内嵌到系统中的排除机制来处理。Actor的一大优点是安全，更大的优点是易懂。Actor根据消息进行处理，必要的化会向其他Actor传递消息，或向Actor返回消息。这与现实世界中人与人之间相处没有多大的差别。现实世界中，别人在想什么你不知道，想要求什么时，需要通过某种手段传递“消息”。理论上要到达最高性能，一般认为线程更优秀。但如果不注意使用线程的话，会出现与时机相关的很麻烦的问题。在计算机性能日益提高的今天，与理论上最高性能的可能性相比，Actor的安全性和易懂性更引人注目。 操作Actor的三种处理系统Actor Model的函数型语言Erlang。Erlang是只允许单一赋值的函数型语言，即一旦赋值，变量的值就不再改变。 Erlang的程序pingpong处理的开始启动pingpong程序Erlang的错误处理Erlang中通过发送消息来通知异常终止。收到消息的process（actor）料理死去的process后事。有了这种机制，使得Erlang适合构造抗障碍性强的系统。 Erlang的使用场所Erlang在通常的文本处理汇总并不怎么快。Erlang的好处在于其扩展性。对于多个处理并列执行的情况，分割成合适的Erlang process，能够发挥多CPU的威力。同样的多任务分割虽然用操作系统的进程或线程也能实现，但Erlang的process与操作系统的进程或线程相比，能够轻量实现（1个process最小只耗费300字节），即使有大量process也不必顾虑、更进一步说，Erlang设计思想不用process连基本处理都不能实现，process分割在某种意义上可以说是强制的。 适合现代服务器端程序。 面向Ruby的库“Revactor”Revactor的目的是为Ruby提供Erlang式的编程。其优点是可以同时体验Ruby和Erlang的好处。但是Revactor中Actor的实现不是靠线程而是靠Fiber。Erlang的目的在于最大限度地利用多核CPU，而Revactor并不适合这种目的。Revactor的最大优点，是能够在等待文件输入输出时，将程序的停止控制在最小程度。 另一个库DramatisDramatis是Ruby中另一个Actor库。函数型语言Erlang不支持面向对象功能。用Ruby这样的面向对象语言来实现Actor的时候，即使用普通对象来实现Actor，也不可避免地会出现把方法调用和发送消息这两种类似概念混在一起的情况。Dramatis库就是解答这种“概念混淆”。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"Android群英传 3 Android控件架构与自定义控件详解","slug":"Android群英传 3 Android控件架构与自定义控件详解","date":"2018-07-18T07:27:32.000Z","updated":"2018-07-18T09:58:53.000Z","comments":true,"path":"2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/","link":"","permalink":"https://github.com/zdkswd/2018/07/18/Android群英传 3 Android控件架构与自定义控件详解/","excerpt":"","text":"Android群英传 3 Android控件架构与自定义控件详解Android控件架构控件大致被分为两类，即ViewGroup控件与View控件。通过ViewGroup，整个界面的控件形成了一个树形结构控件树。上层控件负责下层子控件的测量与绘制，并传递交互事件。findViewById（）方法，就是在控件树以数深度优先来遍历查找对应的元素。每颗控件树的顶部，都有一个ViewParent对象，为整棵树的控制核心，所有的交互管理事件都由它统一调度和分配，从而可以对整个视图进行整体控制。 屏幕快照 2018-07-17 下午2.31.03 通常，在Activity中使用setContentView（）方法来设置一个布局，在调用该方法后，布局内容才真正的显示出来。 屏幕快照 2018-07-17 下午2.36.21 每个Activity都包含一个Window对象，由PhoneWindow来实现。PhoneWindow将一个DecorView设置为整个应用窗口的根View。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通用方法。DecorView将要显示的具体方法呈现在PhoneWindow上，这里面的所有View的监听事件通过WindowManageService来进行验收，并通过Activity对象来回调相应的onClickListener。在显示上，它将屏幕分为两部分，TitleView和ContentView。 屏幕快照 2018-07-17 下午2.45.14 其中ViewGroup会根据对应参数设置不同的布局，如最常用的布局。而如果用户通过设置requestWindowFeature(Window.FEATURE_NO_TITLE)来设置全屏显示，视图树中的布局就只有Content了，这就解释了为什么调用requestWindowFeature()方法一定要在调用setContentView()方法之前才能生效的原因。在代码中，当程序在onCreate（）方法中调用setContentView（）方法后，ActivityManagerService会回调onResume（）方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。 View的测量系统在绘制View前，必须对View进行测量，即告诉系统该画一个多大的View，在onMeasure（）方法中进行。通过系统提供的设计精悍功能强大的类MeasureSpec类来测量View。MeasureSpec为32位int值，高2位位测量的模式，低30位为测量的大小，在计算中使用位运算是为了提高并优化效率。测量模式为3种： EXACTLY即精确值模式，当我们将控件的layout_width或layout_height属性指定为具体数值时，或指定为match_parent属性时（占据父View的大小），系统使用的是EXACTLY模式。 AT_MOST即最大值模式，当控件的layout_width或layout_height属性指定为wrap_content时，控件大小一般岁总监的子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。 UNSPECIFID不指定大小测量模式，View想多大就多大，通常情况下在绘制自定义View时才会使用。 View类默认的onMeasure（）方法只支持EXACTLY模式，所以如果自定义控件时不重写onMeasure方法的话，就只能使用EXACTLY模式。控件可以响应你指定的具体宽高值或是match_parent属性。而如果要让自定义View支持wrap_content属性，那么就必须重写onMeasure（）方法来指定wrap_content时的大小，如果不重写，就不知道该使用默认多大的尺寸，因此，就会默认填充整个父布局，所以重写onMeasure（）方法的目的，就是为了能够给View一个wrap_content属性下的默认大小。 View的绘制测量好一个View后，我们就可以重写onDraw（）方法，在Canvas对象上来绘制所需要的图形。当创建一个Canvas对象时，需要传进去一个bitmap对象。这个bitmap用来存储所有绘制在Canvas上的像素信息。调用所有的Canvas.drawXXX方法都发生在这个bitmap上。 ##ViewGroup的测量ViewGroup会去管理子View，就有负责子View的显示大小。当ViewGroup大小为wrap_content时，就需要对子View进行遍历，以获得所有子View的大小，从而决定自己的大小。其他模式则会通过具体的指定值来设置自身的大小。ViewGroup在测量时通过遍历所有的子View，从而调用View的Measure方法来获得每一个子View的测量结果。当子View测量完毕时，就需要将子View放到合适的位置，这个过程就是View的Layout过程。ViewGroup在执行Layout过程时，同样是使用遍历来调用子View的Layout方法，并制定其具体显示的位置从而来决定其布局位置。在定义ViewGroup时，通常会重写onLayout方法来控制其子View显示位置的逻辑。同样，如果要支持wrap_content属性，必须重写onMeasure。 ViewGroup的绘制ViewGroup通常不需要绘制，如果不是指定了ViewGroup的背景颜色，ViewGroup的onDraw方法都不会被调用，但是，ViewGroup会使用dispatchDraw()方法来绘制其子View，其过程同样是通过遍历所有的子View，并调用子View绘制方法来完成绘制。 自定义View在自定义View时，我们通常会去重写onDraw()来绘制View的显示内容，如果该View还需要使用wrap_content属性，那么还必须重写onMeasure()方法。另外，通过自定义attrs属性，还可以设置新的属性配置值。在View中通常有以下一些比较重要的回调方法。 onFinishInflate():从XML加载组件后回调。 onSizeChanged():组件大小改变时回调。 onMeasure():回调该方法来进行测量。 onLayout():回调该方法来确定显示的位置。 onTouchEvent():监听到触摸事件时回调。 通常有以下方法来实现自定义的控件。 对现有控件进行扩展。 通过组合来实现新的控件。 重写View来实现全新的控件。 对现有控件进行扩展可以再onDraw()方法中对原生控件行为进行扩展。程序调用super.onDraw(canvas)方法来实现原生控件的功能。 创建复合控件创建复合控件可以很好地创建出具有重用功能的控件集合。这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，再给它添加指定功能的控件，从而组合成新的复合控件。通过这种方式创建的控件，我们一般会给它指定一些可配置的属性，让它具有更强的扩展性。 定义属性为一个View提供可自定义的属性非常简单，只需要在res资源目录的values目录下创建一个attrs.xml的属性定义文件，并在该文件中通过代码定义相应的属性即可。 屏幕快照 2018-07-17 下午5.04.48 在代码中通过&lt; declare-styleable&gt;标签声明了使用自定义属性，通过name属性来确定引用的名称。通过&lt; attr&gt;标签来声明具体的自定义属性。通过format属性来指定属性的类型。在确定好属性后，就可以创建一个自定义控件，让它继承自ViewGroup，从而组合一些需要的控件。在构造方法中，通过TypedArray对象的getString()和getColor()等方法，就可以获取这些定义的属性值。 屏幕快照 2018-07-17 下午5.11.26 屏幕快照 2018-07-17 下午5.12.42 屏幕快照 2018-07-17 下午5.13.03 当获取完所有的属性值后，需要调用TypedArray的recyle方法来完成资源的回收。 组合控件通过动态添加控件的方式，使用addView（）方法将控件加入到模板中，并给它们设置前面所获取到的具体的属性值，如文字颜色、大小等。 屏幕快照 2018-07-17 下午5.16.29 定义接口 屏幕快照 2018-07-17 下午5.21.03 暴露接口给调用者 屏幕快照 2018-07-17 下午5.25.21 屏幕快照 2018-07-17 下午5.25.46 实现接口回调在调用者的代码中，调用者需要实现这样一个接口，并完成接口中的方法。 屏幕快照 2018-07-17 下午5.28.58 除了通过接口回调的方式来动态的控制UI模板，同样可以使用公共方法来动态地修改UI模板中的UI。这样可以进一步提高模板的可定制性。 屏幕快照 2018-07-17 下午5.31.54 引用UI模板在需要使用的地方引用UI模板，在引用前，需要指定第三方控件的命名空间。 屏幕快照 2018-07-17 下午5.33.56 这行代码就是在指定引用的命名空间xmlns，即xml namespace。这里指定了名字空间为“android”，因此在接下来使用系统属性时，才可以使用“android:”来引用Android的系统属性。如果要使用自定义的属性，就需要创建自己的名字空间。在Android Studio中，第三方的控件都使用如下代码来引入名字空间。 屏幕快照 2018-07-17 下午5.39.45 这里我们将引入的第三方控件的名字空间取名为custom，之后再xml文件中使用自定义的属性时，就可以通过这个名字空间来引用。 屏幕快照 2018-07-17 下午5.41.56 使用自定义的View与系统原生的View的最大区别就是在申明控件时，需要指定完整的包名，而在引用自定义的属性时，需要使用自定义的xmls名字。再更进一步，将这个UI模板写到一个布局文件中，在其他的布局文中，直接通过&lt; include&gt;标签来引用这个UI模板的View。 重写View来实现全新的控件当Android系统原生的控件无法满足我们的需求时，我们就可以完全创建一个新的自定义View来实现需要的功能。通常需要继承View类，重写onDraw，onMeasure来实现绘制逻辑，同时重写onTouchEvent等触控时间来实现交互逻辑。还可以像实现组合控件那样，通过引入自定义属性，丰富自定义View的可定制性。 弧线展示图音频条形图自定义ViewGroup重写onMeasure来对子View进行测量，重写onLayout确定子View的位置，重写onTouchEvent增加响应事件。 事件拦截机制分析Android为触摸事件封装了一个类MotionEvent，里面封装了触摸点的坐标，点击事件的类型。 屏幕快照 2018-07-18 下午3.08.26 对于ViewGroup重写了三个方法：dispatchTouchEventonInterceptTouchEventonTouchEvent对于View来说，重写了两个方法：onTouchEventdispatchTouchEvent 屏幕快照 2018-07-18 下午3.12.38 屏幕快照 2018-07-18 下午3.12.47 dispatchTouchEvent基本不用动。事件拦截的核心方法是onInterceptTouchEvent返回值：True，拦截，不继续；False，不拦截，继续流程。事件处理onTouchEvent返回值：True，处理了，不用给上级汇报了，上级不会继续处理了；False，给上级处理。 屏幕快照 2018-07-18 下午3.20.48","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"Android群英传 2 Android开发工具新接触","slug":"Android群英传 2 Android开发工具新接触","date":"2018-07-14T04:18:32.000Z","updated":"2018-07-14T04:19:03.000Z","comments":true,"path":"2018/07/14/Android群英传 2 Android开发工具新接触/","link":"","permalink":"https://github.com/zdkswd/2018/07/14/Android群英传 2 Android开发工具新接触/","excerpt":"","text":"Android群英传 2 Android开发工具新接触Android开发IDE介绍ADB命令使用技巧ADB–Android Debug Bridge，借助此工具，我们可以用电脑来操作手机。 ADB基础ADB工具位于SDK的platform-tools目录下。手机助手也是使用ADB来实现它的功能。手机端需要开发者模式，USB Debug。 adb shell可以使用Linux Shell命令。 android list targets显示系统中全部Android平台 adb install -r 程序.apk安装apk程序之install abd push &lt; local&gt; &lt; remote&gt;安装apk程序之push两者都可以安装上APK，但是install是安装到data/data目录中，作为普通的用户应用程序。push则不是安装命令，是将文件写入手机的存储系统，所以，只要拥有相应的权限，就可以把任何Apk放到任何目录中，甚至是System目录下成为一个系统应用程序。 abd push &lt; local&gt; &lt; remote&gt;向手机写入文件 abd pull &lt; local&gt; &lt; remote&gt;从手机获取文件。这些东西在Android Device Monitor工具都可以直接使用。 通过Logcat来查看Log删除应用查看系统盘符输出所有已经安装的应用模拟按键输入模拟滑动输入查看运行状态Package管理信息AM管理信息录制屏幕重新启动ADB命令来源模拟器使用与配置","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"Android群英传 1 Android体系与系统架构","slug":"Android群英传 1 Android体系与系统架构","date":"2018-07-14T03:01:32.000Z","updated":"2018-07-14T03:02:20.000Z","comments":true,"path":"2018/07/14/Android群英传 1 Android体系与系统架构/","link":"","permalink":"https://github.com/zdkswd/2018/07/14/Android群英传 1 Android体系与系统架构/","excerpt":"","text":"Android群英传 1 Android体系与系统架构Google生态系统Android系统架构 2fdda3cc7cd98d10ac7dfab52b3fb80e7aec908d 这些层次结构即是相互独立的，又是相互关联的。 LinuxLinux层(仅为Linux内核)，Android最底层最核心的部分。显示内核版本，就是显示所用的Linux内核的版本。Linux层包含了Android系统的核心服务，包括硬件驱动，进程管理，安全系统等等。 Dalvik与ARTDalvik包含了一整套Android运行环境虚拟机，每个App都会分配Dalvik虚拟机来保证互相之间不受干扰，并保持独立，特点是在运行时编译。在Android 5.x开始，ART模式已经取代了Dalvik，ART是安装时进行编译，在运行时就不用编译了。 Framework见上图 Standard libraries见上图 Application不管是使用NDK开发还是Java开发的App，都有Android Manifest文件、Dalvik Classes、Resource Bundle这些东西。 Android App组件架构即四大组件：Activity、BroadCastReciever、ContentProvider和Service。它们是组成一个Android App的最基本元素。 Android四大组件如何协同工作Activity作为人机交互的第一界面，负责向用户展示和处理结果，信息的来源可以是通过资源获取，也可以是通过Content Provider来获取其他应用的信息，或是Service从后台计算，下载，处理后的结果，也可以是通过BroadCast Reciever获取到广播信息。同时，Android系统还提供了一个信使Intent，作为信息传递的载体。组件与组件之间通过Intent来通信、传递信息、交换数据，正是通过这样一种方式，四大组件形成了各自独立而又紧密联系的关系。 应用运行上下文对象Android系统上下文对象即Context，Activity、Service、Application都是继承自Context。Android应用程序会在几个时间点创建应用上下文Context。 创建Application 创建Activity 创建Service 创建Context的时机就是在创建Context的实现类时。 Android系统源代码目录与系统目录Android系统源代码目录包含了Android系统所有的源代码，从底层驱动到上层应用，Android系统对所有文件都进行了详细管理。在手机中，Android系统的目录和源代码目录不是一一对应的，与源代码编译后，与打包生成的Image文件的结构相同。 Android系统源代码目录看完Android源代码，要懂C、懂脚本、懂Java。 屏幕快照 2018-07-14 上午10.18.18 应注意，不是所有的源代码结构都是这样。只有AOSP的Android项目才是这样的结构，有些芯片厂家如MTK目录结构就不同。Android源码采用Makefile编译。像Android这样的大型项目，它的源代码不计其数，不同的功能，模块，按类型分别放置在不同的目录中，这些模块通常会有Makefile文件进行管理。它定义了一系列的规则来指定模块，哪些文件需要编译，以及这些文件该按照怎演的顺序去编译。甚至可以配置更复杂的功能操作，比如定义编译规则，打包规则，Makefile就像一个shell脚本，不仅可以使用自己的语法，也能调用操作系统的命令。Android系统源代码目录每个目录中还会包含更多的目录，而它的每一个最小的功能单位的目录下，都会有一个Makefile文件，这样每一级向上，通过一个个Makefile文件，就把整个源代码有条不紊的联系在一起了。 Android系统目录通过ADB连上手机，通过Linux的ls命令查看Android系统的根目录。其中/system和/data是开发者非常关心的两个目录。 /system/app/这里面放的是一些系统的App /system/bin/这里面主要放的是Linux自带的组件 /system/build.prop这里记录的是系统的属性信息。 /system/fonts/系统字体存放的目录root后可下载TTF格式字体替代原字体。 /system/framework/系统的核心文件，架构层。 /system/lib/存放几乎所有的共享库（.so）文件。 /system/media/该目录用来保存系统提示音、系统铃声。 /system/usr/该目录用来保存用户的配置文件，如键盘布局、共享、时区文件等。 /data/app/data目录包含了用户大部分数据信息。app目录下包含了用户安装的App或者升级的App。 /data/data/这个目录应该是开发者访问最多的目录了，这里包含了App的数据信息，文件信息、数据库信息等，以包名的方式来区分各个应用。 /data/system/这个目录包含了手机的各项系统信息。 /data/misc/这个目录保存了大部分的WiFi、VPN信息。 Android App文件目录","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"松本行弘的程序世界 9 整数和浮点小数","slug":"松本行弘的程序世界 9 整数和浮点小数","date":"2018-07-12T09:41:32.000Z","updated":"2018-07-12T09:39:19.000Z","comments":true,"path":"2018/07/12/松本行弘的程序世界 9 整数和浮点小数/","link":"","permalink":"https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 9 整数和浮点小数/","excerpt":"","text":"松本行弘的程序世界 9 整数和浮点小数深奥的整数世界整数是有范围的 屏幕快照 2018-07-12 下午4.23.38 尝试位运算 屏幕快照 2018-07-12 下午4.24.58 操作特定的位位运算组合起来，可以对存储在计算机中的各位进行自由操作。操作二进制位就等于操作计算机的数据。基本的位处理操作有4种。 取出特定位的状态 特定位置位（设为1） 特定位清零（设为0） 特定位反转 将操作限制在特定位的数为掩码。 表示负数的办法 开头一位做符号位 将整数的各位反转（1的补数） Ruby的整数Ruby的整数有两种，一种是范围有限制的整数Fixnum（32位CPU是31位，64位CPU是63位），另一种是范围没有限制（超过内存容量除外）的整数Bignum，根据计算结果自动变换。 挑战公开密钥方式RSA加密的强度（解读的困难程度），就归因于素因数分解的难度。 扑朔迷离的浮点小数世界计算机对小数的处理固定小数点数不易使用浮点数，就是小数点的位置可以移动。 科学计数法也有问题计算机中广泛使用的小数表示方法是科学计数法。科学计数法是指将有效数字和指数组合起来表示小数（实数）。 屏幕快照 2018-07-12 下午5.01.23 IEEE754规定，尾数部分的首位始终归一化为1，所以首位始终省略，实质有效数字为53位。 小数不能完全表示 计算机中的数的表示有长度（位数）限制。 计算机中数的表示是二进制。 浮点数是有限的浮点数有误差对于浮点小数，结合法不成立有不能比较的时候对于浮点数进行比较运算，只有两个数在内部表示是完全相同的情况下才判定为相等。作为铁则，两个浮点数不能用==进行比较运算。如果有进行比较的必要，判断条件中的两个数的差要足够小。根据操作系统的不同，对于浮点数，足够小的值e有不同的定义。 误差积累减少运算次数。 不是数的特别“数” 屏幕快照 2018-07-12 下午5.13.14 无限大Inf，零0，非数NaN 计算误差有多种舍入误差最大值溢出与最小值溢出信息丢失位数脱落截止误差误差导致的严重问题BigDecimal是什么浮点数运算的陷阱可以归结为：1. 能够表示的精度有限 以二进制来表示 Ruby提供了BigDecimal类，有以下3个特点： 与Bignum一样，有效数字自动扩展 以十进制计算 以C语言记述，比内嵌的浮点数类（Float）要慢 能够表示分数的Rational类","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 8 正则表达式","slug":"松本行弘的程序世界 8 正则表达式","date":"2018-07-12T04:41:32.000Z","updated":"2018-07-12T04:43:36.000Z","comments":true,"path":"2018/07/12/松本行弘的程序世界 8 正则表达式/","link":"","permalink":"https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 8 正则表达式/","excerpt":"","text":"松本行弘的程序世界 8 正则表达式正则表达式基础检索“像那样的东西”正则表达式的语法普通字符除了表中所示的元字符以外的普通字符，都与该字符自身相匹配。 屏幕快照 2018-07-12 上午10.28.08 字符集合用括号（【】）括起来的部分为字符集合。与括号内所含的每一个字符都匹配。比如，【abcde】能与小写字母abcde中的任何一个相匹配。字符集合中，用中划线（-）来指定范围。所以，【abcde】可以用【a-e】来代替。字符集合中，第一个字符是【\\^】时，表示取反。就是说，不与括号（【】）中的字符相匹配。 任意一个字符表示任意一个字符读得模式是“.”。除了匹配换行符。 重复 屏幕快照 2018-07-12 上午10.42.59 贪婪与懒惰贪婪：寻找符合的最长的，遍历完再回溯，懒惰：寻找第一个符合的。 分组将模式绑定起来的功能称为分组。（ma）+ 选择| 锚点指定位置而不是字符来进行匹配。称为锚点（anchor）。 屏幕快照 2018-07-12 上午10.53.24 三个陷阱记号多、密度高的表达式为应对这一问题，出现了扩展正则表达式。 0次以上的重复贪婪型匹配正则表达式对象面向对象语言Ruby中，所有数据都是对象。正则表达式也是对象。Ruby程序中正则表达式对象写成/.*/的样子。正则表达式对象可以用正则表达式类方法生成。程序中由组合字符串生成正则表达式时，使用类方法更自然。 选项Ruby正则表达式末尾斜杠的后面，可以为这个正则表达式添加选项。 屏幕快照 2018-07-12 上午11.34.28 屏幕快照 2018-07-12 上午11.35.23 正则表达式匹配的方法 屏幕快照 2018-07-12 上午11.37.23 特殊变量Ruby中有源于Perl的特殊变量。以$开头的变量。 屏幕快照 2018-07-12 上午11.41.33 字符串与正则表达式 屏幕快照 2018-07-12 上午11.43.29 split的本质分割字符串的方法split,与正则表达式组合起来能实现很多功能。 字符串的扫描置换想要置换与字符串模式匹配的部分，可以用置换方法。 正则表达式的应用实例与“鬼车”正则表达式是表达字符串模式的一种微型语言。正则表达式由字符本身、字符模式、锚点以及重复等组合而成。 解析日志文件的方法避免使用$的方法记号$不美观。Ruby中，以match方法替代=~运算符，就可以在程序中不使用这些记号了。 从邮件中取出日期的方法典型拼写错误的检索方法Ruby1.9的新功能“鬼车”“鬼车”新正则表达式库。123456DSLDomain Specific Language,意为面向特定领域的编程语言。DSL分内部DSL和外部DSL。内部DSL，就是往既有的语言中加入特定领域的词汇，使之DSL化。如软件编译工具Rake中表达依存关系的内部DSL。make是一个同样目的的工具，它使用Makefile来表达依存关系。Rake可以利用Ruby的编程功能、方法定义、条件分歧和循环等，不管关系有多复杂，都可以编程对应。外部DSL，不是扩展现有的语言，而是面向特定目的，如SQL就是DSL的代表性例子。正则表达式也可以称作是以实现模式匹配为目的的外部DSL。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 7 文字编码","slug":"松本行弘的程序世界 7 文字编码","date":"2018-07-12T02:00:32.000Z","updated":"2018-07-12T02:01:00.000Z","comments":true,"path":"2018/07/12/松本行弘的程序世界 7 文字编码/","link":"","permalink":"https://github.com/zdkswd/2018/07/12/松本行弘的程序世界 7 文字编码/","excerpt":"","text":"松本行弘的程序世界 7 文字编码文字编码的种类早期的文字编码纸带与文字的表现文字是什么走向英语以外的语言（欧洲篇）英语以外得到语言（亚洲篇）Unicode的问世统一编码成16位的汉字统合Unicode的两个问题选择16位文字的Unicode有两大副作用。一是字节顺序的问题，一是NUL文字问题。字节顺序就是低八位先放还是高八位先放的问题。传统C语言处理的字符串，一般有一个终端文字NUL（‘\\0’）。但是作为16位文字的字符串，中途会出现NUL文字。所以，C语言中处理字符串的传统函数不能用于16位文字的字符串。像java那样的语言，一开始就是以16位文字为前提而设计的，所以没什么问题。但以C语言处理16位文字的时候，需要全新的api。 Unicode的文字集现在，Unicode放弃了16位方式，而用21位来表示一个文字，现在Unicode能够表示4111个文字，肯定够用了。 文字表示的不确定性Unicode的字符编码方式UTF-8UTF-8以一定式样的字节组合来表示Unicode中的21位文字。对于内部程序处理字符串非常方便，另外没有字节顺序问题，在外部处理时也很有用。缺点：消费过多内存，几乎所有的汉字都要占用3个字节。构成文字的字节数是可变的，随机访问任意文字，代价与字符串长度成正比。但是随着计算机内存的容量和性能提高，这些缺点也无所谓了。 UTF-16Unicode中能以16位表示的空间就以16位表示，超过16位就以两个16位码组合来表示。到现在缺点已经很突出了，从今以后没必要采用这种字符编码方式了。 UTF-32固定长，可以随机访问，但存在字节顺序的问题。因为4字节，没什么人气。 程序中的文字处理文字编码有多个意思只能处理文字集中包含的文字纷繁复杂的文字编码方式影响力渐微的Shift_JIS与EUC-JPUnicode有多种字符编码方式为什么会发生乱码字符编码方式错误没有字体变换为内部码时出错发生不完全变换文字集的不同字节顺序错误像UTF-16，UTF-32这种基本数据单位大于一个字节的编码方式，存放数据时字节该以什么顺序摆放，有两大流派，一个是big endian,一个是little endian。所以同样是UTF-16格式（UTF-32也一样）根据字节顺序不同就会有两种。UTF-8就不会。 从编程语言的角度处理文字编程语言处理文本数据的方法，有UCS方式和CSI方式两种。 以变换为前提的UCS方式UCS（泛用字符集），是指程序中所处理的共同文字集（及字符编码方式）。输入输出时，编程语言将文本数据变成UCS，内部对文本数据进行统一处理。优点： 原理简单，容易实现 除变换外，处理成本低 实际成果多 缺点： 发生不必要的变换 变换存在模糊部分 有外字及机种依存文字的问题 UCS中不包含的文字绝对不能处理 原封不动处理的CSI方式CSI（Character Set Independent，字符集独立），是指不对各种文字集（及编码方式）进行任何变换，原封不动地进行处理。相对于UCS的内部只有一种编码方式的处理方式，CSI中对各种编码方式原封不动地处理。CSI是优点多，自由度高的方式。 不发生不必要的变换 不发生变换所带来的问题 不易发生外字的问题。 理论上不存在不能处理的文字 根据需要，可以处理应用程序独立的文字集 缺点： 字符串的处理容易变得复杂化 预计处理性能会变低 实际成果少 实际上，现在存在的多种编程语言中，采用CSI方式的几乎没有。 使用UTF-16的JavaJava采用UCS方式，内部字符编码选用UTF-16制作Java时，Unicode仅限于16位。java没选择可变长的UTF-8，而选择UTF-16，因而产生了这样的悲剧。说是时机的恶作剧也罢，真是太可惜了。 使用UTF-8的PerlPerl也使用UCS方式，内部编码方式采用UTF-8。 用UTF-16的PythonUCS，UTF-16 采用CSI方式的Ruby1.8强化了功能的Ruby1.9是UCS还是CSI","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 6 Ruby On Rails","slug":"松本行弘的程序世界 6 Ruby On Rails","date":"2018-07-11T04:00:32.000Z","updated":"2018-07-11T03:59:46.000Z","comments":true,"path":"2018/07/11/松本行弘的程序世界 6 Ruby On Rails/","link":"","permalink":"https://github.com/zdkswd/2018/07/11/松本行弘的程序世界 6 Ruby On Rails/","excerpt":"","text":"松本行弘的程序世界 6 Ruby On RailsMVC和Ruby On RailsMVC是设计GUI程序的设计模式之一。大部分设计模式仅决定程序某一部分的构成，而MVC决定了应用程序的整体部分，有时候也被成为架构模式。 模型、视图和控制的作用模型：是表现窗口中表示内容（信息）的对象。模型代表的只是信息（名字、数值等抽象的信息），它不能包含如何来显示这些信息的信息。视图：代表将模型中包含的信息在窗口中进行表示的对象。视图知道要表现的模型的信息，而模型一般不知道要表示自己的视图信息。控制：是从用户端接受输入，对视图和模型进行操作的对象。 屏幕快照 2018-07-11 上午9.26.46 用秒表的例子来学习MVC模式生成视图和控制部分GUI工具箱与MVC同时使用工具箱和MVCMVC的优缺点优点： 可以更换界面一个模型对应多个视图多个视图可以同时响应容易测试缺点： 复杂性强关联性对模型对象进行了功能追加这样的变更后，相应地也必须对视图和控制进行变更。 Web应用中的MVCWeb应用基本是HTTP。HTTP的一次处理经过了一下过程：（1）Web浏览器对应于用户的操作，向Web服务器发出HTTP请求。（2）Web服务器根据请求，准备好发送到Web浏览器的数据。（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。 利用MVC来描述：（1）Web浏览器发送过来的HTTP请求通过Web服务器传给控制部分。Web应用框架的分配器把请求传递给合适的控制部分。（2）控制部分操作的模型和请求的信息相对应，同时制定显示使用的视图。视图从模型启动，一边引用模型一边准备发送给Web浏览器的数据。（3）Web服务器把数据以HTTP响应的形式送还Web浏览器。 屏幕快照 2018-07-11 上午9.54.09 Ruby on Rails上的MVC各部分功能稍有不同。Rails中的模型相当于数据库层，视图指显示用的模板，控制器指控制用的类（包含了应用逻辑）。 屏幕快照 2018-07-11 上午9.56.48 开放类和猴子补丁猴子补丁，即在动态语言中，不改变源代码而对功能进行追加和变更。现在灵活使用开放类，变更和追加方法全部称为猴子补丁。 开放类Ruby的类的特征是所谓的开放类，相对于其他语言，特别容易打猴子补丁。Ruby中，可以把String类、Array类等基本的数据类型及所有的类都作为开放类处理，可以自由地追加功能。 猴子补丁的目的功能追加利用开放类可以给已有的类追加功能。 功能变更修改程序错误因为重新定义了有程序错误或有副作用的方法，不用修改原来那部分的代码就可以解决问题。这也是本来的猴子补丁的目的。 钩子有时间想在每个方法调用的同时增加一些其他处理。这种伴随方法调用而进行的处理称为“钩子”（hook），钩子的追加也可以用猴子补丁来实现。 缓存（cache）猴子补丁的技巧可以吧Ruby提供的对方法、类和模块进行操作的功能运用到打猴子补丁上。最基本的功能就是给已有的方法改名或取消。 屏幕快照 2018-07-11 上午10.58.20 undefundef有把方法取消定义的功能。用undef不仅可以取消本类中的方法，也可以取消父类中定义的方法。 aliasinclude灵活使用开放类的库jcode库可以不使用正则表达式，利用开放类的功能，使得字符串的方法可以处理多字节文字。 猴子补丁的几点问题若要正确使用开放类，安全地打猴子补丁，需遵守： 基本上只是追加功能对类追加新方法不会让已有的程序无法执行。使用开放类时，主要做不容易导致问题的功能追加会更保险。做功能追加时，如果发生名称重复会造成麻烦，在选择追加的方法名时需要慎重。 进行功能变更时要慎重，尽可能小规模 小心相互作用 其他方法猴子补丁能够不改变源代码进行动态修改，这种灵活性是显示动态语言柔软性和扩展性的好例子。实现猴子补丁的Ruby开放类有时功能过强，可能会引起问题。其他语言中用更易控制的形式也能实现猴子补丁。 Ruby on Rails和开放类Rails构成部分之一ActiveSupport库。ActiveSupport利用Ruby的开放类功能，对Ruby标准提供的类大胆地追加了功能。 ActiveSupport带来的扩展 时间 字节单位系列 复数形和序数 大规模开发和Ruby编译时不作类型检查Ruby在执行时作类型检查，大规模程序为了保证可靠性一定会有严格的测试程序，如果作了严格的测试，在编译时作类型检查的优点就不像所说的那么重要了。 没有包Java对于构成库的类和文件有独立的包，要想具备某种功能，必须明确地进行import操作。而Ruby是不具备这种功能的。所以，库定义的类和模块名是全局的，从任何地方都可以引用。因此，可以说名称重复的危险性很大。 存在开放类各自独立的库发生互相矛盾的变更时，问题不能简单解决。这也可能在大规模开发时引发问题。 信赖性模型在某种类型的大规模开发中，Ruby的性质会造成问题，或者说造成问题时解决起来不像其他语言那么容易，这种现象是现实中可能存在的。如果认为这些是问题的话，可能不使用Ruby会更好。但是，到现在为止我们看到的情况表明，会发生那种问题的大规模开发本来就绝不是好的开发状况。首先要做的，是把项目的信赖关系改善到可以使用Ruby的程度。就算是最后也没有使用Ruby，这也是应该先做到的事情。 猴子补丁的未来猴子补丁虽然有一定的危险性，但有利有弊，它也提供了方便性、扩展性和灵活性。开放类和利用它的猴子补丁，将来也可能会被更安全的、由1特定目的而特制的功能群而替代。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 5 Ajax","slug":"松本行弘的程序世界 5 Ajax","date":"2018-07-10T09:25:32.000Z","updated":"2018-07-10T09:26:45.000Z","comments":true,"path":"2018/07/10/松本行弘的程序世界 5 Ajax/","link":"","permalink":"https://github.com/zdkswd/2018/07/10/松本行弘的程序世界 5 Ajax/","excerpt":"","text":"松本行弘的程序世界 5 AjaxAjax和JavaScript（前篇）Ajax（Asynchronous JavaScript and XML）,含义是异步JavaScript及XML。Ajax不算是一个新技术，只是既有技术的组合。 通信及异步页面更新Ajax的最大特点是进行异步操作，异步意味着Web浏览器的通信和页面更新是互相独立的。以前的Web应用程序，每按下一个按钮就开始显示下一个页面，在页面完整呈现之前，用户只能等待，无法进行其他操作，使用Ajax技术的页面是在后台和HTTP服务器进行通信，设计优良的Web应用程序，在客户和服务器通信的过程中也可以让用户进行操作，而不需要等待。Ajax的最大优点是改善了应用程序的操控性。 屏幕快照 2018-07-10 上午8.52.52 Ajax技术中，对于用户进行的操作，基本是由JavaScript在Web浏览器中进行响应。尽在数据必须从服务器获取的情况下，才在后台进行异步通信。在通信过程中，用户也可以继续对Web浏览器进行操作。和服务器通信得到的结果由DHTML对当前的页面进行部分更新而现实出来。 技术要素之一：JavaScript支撑Ajax的三个主要技术：JavaScript、XML及DHTML。JavaScript是几乎所有Web浏览器处理系统都支撑的一种编程语言。因此，它被称为世界上最普及的编程语言。JavaScript可以简单的嵌入到表示网页的HTML中去，利用JavaScript可以做出完全不用和服务器进行通信的网页。 技术要素之二：XMLXML（eXtensible Markup Language）,和SGML、HTML类似，使用标签（tag）对数据进行标识说明的一种语言。XML已经成为了数据表示、配置各种文件及其他多种场合下广泛使用的一种格式。Ajax的名字中部分包括了XML，是因为当初大部分使用Ajax技术的应用程序都使用了XML数据，以及用JavaScript进行异步通信的对象的名字是XMLHTTPRequest。当然不用XML的XMLHTTPRequest的通信也是存在的，使用Ajax技术的Web应用进行通信的数据格式也是多种多样的，比如有普通文本格式以及YAML，JSON。 XML以外的数据表示形式YAML（YAML Ain’t Markup Language）看出它不是标记语言。YAML只是表示数据的语言，目的仅仅是表示数据。特点有： 记述简洁 容易理解 专注于表示数据，不用费心考虑给标签起名字。 屏幕快照 2018-07-10 上午9.30.23 和YMAL相提并论的是JSON（JavaScript Object Notation）意思是JavaScript对象表示法。是直接把JavaScript表示对象的程序拿来记述数据。JSON是合法的JavaScript程序，作为JavaScript实现可以生成对象。JSON可以表现下面6种数据类型：数值（整数及浮点小数）、字符串、布尔值（真、假）、数组、对象（键和值的表）和null。YAML通过扩展可以表示各种形式的数据。相比较，JSON就简单太多了，但也够用了。 技术要素之三：DHTMLDHTML，动态HTML，顾名思义，可以动态地对HTML进行引用、修改和更新。更具体的说，是利用装载在网页中的JavaScript，使用DOM（文档对象模型）对网页数据进行操作。使用DOM可以进行下述处理： 取得页面中特定标签中的数据； 修改标签的数据（文字、属性等） 在页面中添加标签； 设定事件处理程序JavaScript技术基础JavaScript是以对象为基础的语言，所有的数据都可以作为“对象”进行统一处理。不过，它不具备“类”这样的所谓普通面向对象语言所提供的功能，即使去除JavaScript面向对象的编程功能，它也可以作为普通的结构化编程语言来使用。基本语法JavaScript的基本语法和C、Java类似。最大的不同是，JavaScript不指定变量类型。函数定义JavaScript的特点之一是把函数作为对象进行处理。C也是将函数作为对象处理，但JavaScript的不同之处在于函数对象有闭包（closure），可以使用函数外面的局部变量。闭包功能称为了JavaScript面向对象功能的基础。1闭包是Ruby中块变为对象后的结果。它的优点是，只要闭包还存在，就能访问闭包内的变量。 原型模式的面向对象编程语言如果具有原型模式的面向对象功能的话，就可以最大限度地消减语言本身的固有功能。这非常适合于JavaScript这样的语言。以类为中心的传统面向对象编程，是以类为基础生成新对象。类和对象的关系可以类比成铸模和铸件的关系。而原型模式的面向对象编程语言没有类这样一个概念。需要生成新的对象时，只要给对象追加属性。设置函数对象作为属性的话，就成为方法。当访问对象中不存在的属性时，JavaScript会去搜索该对象prototype属性所指向的对象。JavaScript利用这个功能，使用“委派”而非“继承”来实现面向对象编程。1委派是指，把对于某个对象的调用传送到另一个对象上。 JavaScript的方式过于简单反而使记述太过复杂。 使用prototype.js库为了克服JavaScript记述过于繁杂的缺点，JavaScript提供了进行功能扩展的一些库。如prototype.js库prototype.js受到了Ruby的影响，实际上Ruby on Rails中标准地附加了prototype.js库，使用得很广泛。 prototype.js的功能Ajax功能prototype.js支持XMLHttpRequest对象，可以对HTML进行异步更新。实际上不同Web浏览器获取XMLHttpRequest对象的方法也是不同的。Ajax.Request帮我们屏蔽了与代码移植相关的问题。 Enumerable它是Ruby的Enumerable模块在JavaScript中的实现。 其他扩展功能如使用Object.extend()给对象追加功能。 Ajax和JavaScript(后篇)像Ajax有3个特点： 没有Web页面跳转 通过异步通信实现快速反应 实现了动画和拖拽等单独使用HTML格式无法表现的用户界面构成DHTML基础的JavaScript是一个速度不怎么快的语言。某种技术在开发出来之后经过相当长一段时间才得到普及，此类例子并不少见。巧妙使用DHTMLDHTML被称为Ajax的本质技术。顾名思义，可以动态访问、更新HTML。具体就是利用嵌入网页的JavaScript，使用DOM操作页面数据。1DOM是操作HTML和XML的规范。特点是把HTML和XML作为树结构进行处理。 HTML被读取后，生成树结构。 屏幕快照 2018-07-10 下午4.39.14 使用JavaScript对树结构进行操作就是DHTML的本质。因此JavaScript提供的W3C DOM API有如下功能： 获取documnent节点 获取和更新标签数据（包括文字、类型以及属性等） 追加documnent节点 设定时间处理程序（event handler） 获取documnent节点 getElementById(name)getElementsByTagName(name) 获取和更新标签数据获取节点对象后，通过调用对象的方法，读写对象的属性等就能够获取和更新标签数据。 设定事件处理程序两种办法： 指定标签属性。如设置为a标签的onclick属性值来指定事件处理程序。 把方法设为JavaScript对象的属性。如 屏幕快照 2018-07-10 下午4.49.48 追加标签节点用appendChild方法可以为节点对象追加节点，消除节点用removeChild方法。 本地HTML应用和服务器间的通信使用DHTML之后，对于较简单的应用，在客户端就能够实现。但是，客户端无法保存数据，所以保存和获取数据时需要和服务器进行通信。Ajax是利用XMLHTTPRequest对象来进行异步通信，不需要网页跳转，在后台就可以进行通信。 使用Prototype.js的优点不需要麻烦的记述。 在服务器上保存数据Web应用的脆弱性如XSS（跨站点脚本问题） 使用JavaScript的感觉作为动态语言名副其实DHTML比想象的更有趣Prototype.js也不错调试比较麻烦JavaScript理就算有程序错误，Web浏览器也不会显示任何信息。想要确认程序的状态，只能多次使用alert()。Firefox提供了Firebug的扩展功能，对于JavaScript的调试非常有用。 兼容性问题Ajax开发最难的一点就是Web浏览器间JavaScript的兼容性问题。12名字的重要性起了一个合适的名字本身意味着功能设计的正确。反过来，起了不好的名字说明设计者自己也没有完全理解应完成什么样的功能。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 4 设计模式","slug":"松本行弘的程序世界 4 设计模式","date":"2018-07-09T10:21:32.000Z","updated":"2018-07-20T11:02:15.000Z","comments":true,"path":"2018/07/09/松本行弘的程序世界 4 设计模式/","link":"","permalink":"https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 4 设计模式/","excerpt":"","text":"松本行弘的程序世界 4 设计模式设计模式（1）设计模式的价值和意义Gamma他们并没有发现新的模式，总结出来的23种设计模式也是软件开发中早就存在并反复使用的模式，因此并不能说是Gamma他们的首创。但即使是这样，设计模式有了名字，人们就可以认识到它的存在，并对之进行讨论。这种不能用语言表达的知识称为内隐知识。给这些在软件中经常反复出现的模式命名，使得这些本来只有经验丰富的程序员才能认识到的软件设计模式能被广泛认识和讨论。 设计模式是程序抽象化的延伸一旦有了设计模式，只要把过去优秀的人们考虑出来的模式拿来应用一下。 Ruby中的设计模式Singleton模式单件模式。用来保证某个类的实例只有一个。Ruby实现Singleton模式的方法有几个 使用singleton库的方法Ruby以库的形式实现了Singleton模式。使用Singleton库，在任意类中include Singleton模块，那个类就变成Singleton模式的对象。 使用类或模块C++和java是不能把类作为对象使用的，与之不同的是，smalltalk或Ruby能把类也作为对象来处理。因此，在类或模块中定义一个方法就可以实现Singleton模式。 把一般的对象作为Singleton来使用为了把一个类的对象限制为只有一个，并不一定要对对象的一般生产方法进行限制。可以生成一个一般的对象，然后不要在生产更多个对象了。 使用对象和特异方法Ruby可以在对象生成以后再增加新的方法。 Proxy模式Proxy（代理）模式是为某个对象提供代理对象的模式。在不知道是否真正需要一个生成代价很大的对象时可能造成很大浪费，但不生成又什么都做不了。 Iterator模式Iterator（迭代器）模式提供按顺序访问集合对象中各元素的方法。即使不知道对象的内部构造，也可以按顺序访问其中的每个元素。Iterator模式是为集合对象另外准备用来控制循环处理的对象，就像C++或java一样，我们称这个循环控制对象为Iyerator，也称为游标。 外部与内部，哪一个更好它们都有方便的一面，也都有不方便的另一面。 内部迭代器的缺陷内部迭代器不能同时进行多个循环，也就无法实现按顺序比较两个集合元素的处理。 外部迭代器的缺陷外部迭代器的缺陷在于迭代器对象需要引用集合对象的内部信息，为了按顺序访问集合对象的各个元素，迭代器需要访问集合的内部构造，破坏了隐藏集合内部构造的封装性原则。 设计模式（2）模式与动态语言的关系《设计模式》一书中介绍了23个设计模式。这些设计模式可分为3大类：（1）有关生成的模式（5个），有关构造的模式（7个）以及有关行为的模式（11个）。Singleton为（1），Proxy为（2），Iterayor为（3）。 重复使用既存对象的Protoype模式Protoype（原型）模式明确一个实例作为要生成对象的种类原型，通过复制该实例来生成新的对象。在需要新种类对象时，首先复制一个既存的对象，给复制的对象直接增加方法或实例变量等功能，生成最初的第一个新种类对象。最初一个也并不特别，只是偶尔被用来复制而已。相对于类模式编程，原型模式的编程构成元素比较少，具有简单实现面向对象功能设计的倾向，JavaScript的面向对象就是原型模式。io语言也是。 亲身体验IO语言Ruby中的原型基本上讲Ruby是类模式的语言，但也拥有支持原型模式编程功能。 复制对象的clone方法 给个别对象增加方法的特意方法功能 给个别对象增加一组功能的extend方法 静态语言中没有原型编程，因为不可能给复制的对象增加新方法。 编写抽象算法的Template Method模式用Ruby来尝试Template MethodRuby的类库中最大限度灵活运用Template Method模式的部分，应该是Enumerable模块和Comparable模块了。 动态语言与Template Method模式Template Method模式的这种优秀性质与语言是不是静态没有关系。 避免高度依赖性的Observer模式Observer（观察者）模式是当某个对象的状态发生变化时，依存于该状态的全部对象都自动得到通知，而且为了让它们都得到通知，定义了对象间一对多的依存关系。这是控制类与类之间依存关系的一种模式。高度依赖性会导致组成程序的零件过大，避免高度依赖性的Observer模式，构成观察者模式的有两个对象，一个称谓Observer（观察者）接受变更通知；另一个称为Subject（对象）或Observable（被观察者），发出变更通知。被观察者让人得到被动的印象，在实际处理中，被观察者会发出通知“我已经变化了哦”。 Observable模块Ruby中为实现Observer模式提供了名为observer的库。observer库提供observer模块。 Observer模式与动态语言由于Ruby的动态性质，Observer库具有以下几方面的灵活性。 观察者类不必是特定类的子类。 观察者类不必实现特定的接口（本来在Ruby中也没有接口） 观察者类的更新方法名可以自由决定 观察者类更新方法的参数可以自由决定 被观察者类不必是特定类的子类 对被观察者类的要求，只是将Observable模块包括进来。 123说到事件监听模式,很容易将它和观察者模式联系在一起。实质上这两者完成同类型的工作。依个人理解，事件监听模式更像是观察者模式的进阶。事件监听机制就是对观察者模式进行了进一步抽象，节省了代码量。 设计模式（3）软件开发的悲剧 复杂性 变化性 软件的规模越大，各个部分之间的牵连越复杂，更改也就越难。在软件开发过程中，需求变更几乎是不可避免的。 开放-封闭原则对模块扩展必须开放，对修改必须封闭。为了应对将来的需要，扩展必须是开放的，但是即使某一模块的内部结构改变了，对外接口也应当是不变的。简称OCP。 面向对象的情况既要开放，又要封闭，看似互相矛盾，但是面向对象编程语言能够很彻底地消除这个矛盾。 非面向对象的情况非面向对象则很难处理好。面向对象的精髓在于对OCP的实践。至于把对象看做物体理解起来比较容易，能够建立现实世界的模型等，不过是锦上添花。 OCP与Template Method模式虽说使用面向对象语言的功能，可以实现OCP，但是只是说有这种可能性，并不是说什么时候都能实现。当然，虽然使用了面向对象语言，却做成了一个糟糕的设计，这种情况也是屡见不鲜。分类中很多设计模式之所以优秀是因为经得起OCP所要求的变化。Template Method模式，是满足OCP的基本手段。其他的设计模式都是利用多个类的关联来实现的，而Template Method模式则仅仅使用了继承，基本上无非是实现了一个抽象类。 Observer模式Observer模式是满足OCP的。DRY也好，OCP也好，都不过是原则，根据具体情况，要做适当的选择，如果代码没有再利用的打算，也没有扩展功能的打算，也就没有必要生搬硬套设计模式。使用前有必要先做判断。 使用Strategy模式Strategy（策略）模式是定义算法的集合，将各算法封装，使它们能够交换。利用Strategy模式，算法和利用这些算法的客户程序可以分别独立进行修改而不互相影响。Strategy模式就是将容易变化的处理归纳为独立的对象，然后使它们能够互相交换，使用方法与将容易变化的处理交给子类的Template Method模式相类似。两个模式最大的区别在于，Strategy模式是独立的对象，能够动态交换处理逻辑。 Strategy模式与OCPStrategy模式完全满足OCP。世上很多设计模式，为了能应对将来可能的修改，都是按照OCP的要求来设计的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界 3 程序块","slug":"松本行弘的程序世界 3 程序块","date":"2018-07-09T02:21:32.000Z","updated":"2018-07-11T02:11:19.000Z","comments":true,"path":"2018/07/09/松本行弘的程序世界 3 程序块/","link":"","permalink":"https://github.com/zdkswd/2018/07/09/松本行弘的程序世界 3 程序块/","excerpt":"","text":"松本行弘的程序世界 3 程序块程序块的威力Ruby的特色功能之一——程序块。Ruby的程序块是指在方法调用时可以追加的代码块。 把函数作为参数的高阶函数高阶函数是指以函数作为参数的函数。为了实现高阶函数，编程语言中必须把函数和方法作为数据来处理。 C语言高阶函数的局限在C语言中，实现函数间的信息传递只有两种方法：要么明确地传递参数，要么使用全局变量，没有其他方法。如果使用全局变量来传递信息，就搞不清楚什么时候、谁在引用或者更新这一变量。除了全局变量之外，没有别的办法在函数间共享信息，这是C语言的局限。 可以保存外部环境的闭包Ruby中，增加了引用函数外部变量的功能。与C语言指针的例子比较，Ruby具有以下两个易于使用的优点： 可以再使用时定义； 可以引用外部的局部变量。 java的匿名类和C语言的函数指针也能实现同样的功能，但是没有那么简洁。在块中可以引用外部局部变量的方法，这说明不只是简单的程序代码，而且把外部“环境”也包括进来，像这样的块叫做闭包。通常的局部变量在方法执行结束时就不存在了，但如果被包括进了闭包，闭包存在期间，局部变量也会一直存在。 块的两种使用方法Ruby的块是可以追加给调用方法的代码块，块自身不是对象（对象化后的块是闭包）。参数传递的方法和普通函数不同。在被调用的方法中有两种方式来使用传递过来的块。一种是用“块参数”的方式明确声明接受块作为参数，另一种是使用yield这个Ruby的保留词。块作为参数具有三个优点： 明确表示了块处理 块和对象一样被统一处理 检查参数是否为nil就可以判断出是否传递了块参数。 另外，yield具有下面两个优点： 没有用到闭包，执行速度少快 错误提示信息比较容易理解 最终来看，块到底是什么Ruby的块具有以下三个特点： 代码块可以作为参数传递给方法 在被调用的方法中可以执行传递过来的代码块，执行后程序的控制权返还给方法。 块中最后执行的算式的值是块的值，这个值可以返回给方法。 块也可以被看做只是高阶函数的一种特殊形式的语法。虽然只是稍作改进，但Ruby中块的各种灵活应用的方法还是让人赞叹不已。 块在循环处理中的应用最典型的用法是，在逐个处理集合对象的元素的方法中使用块。 屏幕快照 2018-07-06 上午11.19.23 Ruby中几乎所有的容器类都有each这个方法。使用这个方法可以循环处理容器类中的所有元素。也可以用for语句来实现each方法。本来，Ruby就是为了要实现循环功能才导入了块。所以，在以前的文档中把具有块的方法称为迭代器（iterator）。iterate就是循环、迭代的意思。但是，如今块的应用范围比当初所能想到的要广泛的多，和循环没有关系的处理中也大量的用到块。所以现在仍把块称为迭代器就很不恰当了。 内部迭代器和外部迭代器像Ruby块这样，把对各个元素的处理逻辑传送给容器类的方法，然后在方法中对容器类中每个元素调用指定的处理逻辑，这种迭代方式称为内部迭代器的方式。与之对应，C++和java中所谓的迭代器，是用别的类对象来循环处理容器中的元素，这种循环处理的方式称为外部迭代器方式。在外部迭代器方式中，把顺序取出容器中元素对象称为迭代器，也称为游标。内部迭代器不用额外生成类，使用和实现都很简单，但是，对于不支持闭包的编程语言，想要拥有循环外部的信息就要费些功夫。外部迭代器可以简单地处理从多个容器中逐个取出数据进行并行处理。从设计模式来看，内部迭代器是访问者模式，外部迭代器是迭代器模式。 在排序和比较大小中的应用用块保证程序的后处理用块实现新的控制结构用块的话，不需要改变文法，就可以控制结构的定义。 在回调中使用块块处理的特别理由ruby的块具有以下特点： 在普通参数以外，另外被传送； 块不是对象（lambda方法可以作闭包对象化）。 其他具有闭包功能的编程语言，比如Lisp和Smalltalk，它们没有这样的区别，总是把闭包作为对象来处理。Ruby作了改进，因为： 减少对象的生成数。初期Ruby生成闭包对象的代价很高，所以尽量避免了闭包对象的生成。即使是真正必要的对象，也尽量延迟到必要的时候才生成。 外观上的理由。 调用方法时只能用一个块，是Ruby中的一个限制，但实际情况中也几乎没有必要使用多个块。 用块做循环Ruby的块本来就是在循环的抽象化过程中诞生的。现在除了循环以外，在其他一些场合也得到广泛应用，但这并未有改变其实现循环的初衷。 块是处理的集合循环是程序的基本元素。从结构化编程的原理来说，所有算法都是有顺序、分支和循环的组合来实现的。可以说处理好了循环，也就处理好了程序。Ruby也用while循环，但是循环还有其他更为深奥的表现形式。Ruby中有until语句。块是处理的集合。Ruby中，在方法调用的最后，可以附加上块。Ruby的简洁性不只体现在程序简短，更重要的是体现在对本质问题的处理，使程序更为灵活。 屏幕快照 2018-07-09 上午9.00.34 第二行大括号中的部分是块，这行程序是作为参数来调用数组的each方法。用Ruby实现这种循环非常简单，知识在块调用的地方用yield来指定。 屏幕快照 2018-07-09 上午9.08.46 1一个方法的定义，在方法内部有yield的出现；在方法的调用处会有程序块的出现。 也可以用do-end来定义块。大括号和do-end基本是一样的。但是，在块是多行时。用do-end结构统一性更好一些。 块是一行的时候用大括号，是多行的时候用do-end; 块作为表达式的一部分，给方法返回值时用大括号，块作为处理语句或程序流程控制时用do-end。大括号的优先级更高。 在省略括号调用方法时，一定要注意块的结合优先顺序。 块应用范围的扩展当时块主要使用在循环里。在Ruby中不必特别的结构，在任意的方法中都可以使用块，所以不仅仅在循环中，块在各种各样的领域中都得到了应用。 高阶函数和块本质一样编程语言要实现高阶函数，就必须把函数或者方法作为数据来处理。反之，具有这样功能的编程语言就可以利用高阶函数。可以把块看做高阶函数调用，只能有一个函数参数。事实上，在高阶函数中94%都只有一个函数参数，有两个以上函数参数是极少的。Ruby以更易于使用的形式，把只有一个函数参数的情形在语法上加以特殊处理，导入了块功能。 用Enumerable来利用块把块应用于循环抽象化的，最典型的应该是Enumerable模块。Enumerable模块以each方法为基础，定义了each方法的类提供了多种功能。如果继承（Mix-in）了这个模块，就可以很方便地利用它的各种功能。Enumberable的意思是可数的。它是对数组等各种集合元素做循环处理的方法的集成。可大致分为： 循环 指定条件 排序、比较大小 Enumerable的局限 循环都依赖each方法，而且不能并行执行。 Enumerable可以用each方法简单的实现循环，反过来也是一个局限。 精通集合的使用使用Ruby的数组在动态语言ruby中，集合可以混合存在各种类型的对象，所以可以定义复杂得数组。 修改指定范围的元素的内容和C语言、java语言相比，ruby的数组具有以下特点。 Ruby的数组是对象，可以调用各种方法。 用【】访问数组实际上是方法调用。【】是方法名，里面的值是参数。 变更数组元素实际上也是方法调用。【】=是方法名，里面和右边的值是参数。 Ruby中的哈希处理 屏幕快照 2018-07-09 上午9.55.21 支持循环的EnumerableRuby中提供的方法可以更好地发挥集合的作用。Ruby中，集合的功能都定义在Enumerable这个Mix-in中了。从另一个角度来说，只要把Enumerable模块通过Mix-in继承进来，就可以使用集合对象的大量方法了。 用于循环的each方法在Enumerable中没有定义each方法，反之，Enumerable中所有方法都是在内部调用each方法实现的。 使用inject、zip和grepinject是用块吧各个元素结合起来。zip是从多个集合并行取得元素的方法。grep方法可以对集合中的元素进行模式匹配。 用来指定条件的select方法对集合的各个元素进行块处理的是循环类型的方法。和它相对的，对各个元素进行块处理，用快处理的结果作为下个处理的判定条件的是条件指定型方法。条件指定型方法中最常用的是select方法。select方法把快处理结果为真的元素存放在数组中返回。 排序与比较大小在类中包括（include）Enumerable模块列表内包表达式和块的区别","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"艺术的力量 卡拉瓦乔","slug":"艺术的力量 卡拉瓦乔","date":"2018-07-06T09:56:20.000Z","updated":"2018-07-06T09:58:37.000Z","comments":true,"path":"2018/07/06/艺术的力量 卡拉瓦乔/","link":"","permalink":"https://github.com/zdkswd/2018/07/06/艺术的力量 卡拉瓦乔/","excerpt":"","text":"艺术的力量 卡拉瓦乔这个天才，是个恶人教堂寻寻觅觅及卡拉瓦乔生来注定要做的，就是在罪人的生命中找到超凡入圣之处。卡拉瓦乔笔下的主角不是圣人，而是罪人。这名画家，对穷苦信徒的处境感身受他艺术的力量来自于真实的力量，其中包括了对自身真相的觉醒。 青年音乐家 1595 自比酒神的自画像 赌博 圣母之死 圣母玛利亚 男孩与水果篮 有人说他是艺术天才，也有人说他是血性魔鬼，他的一生可以说就是一部历险记。卡拉瓦乔出生在米兰，家庭状况还阔以，爸妈在当时有点名气和地位。在卡拉瓦乔5岁的时候发生了一场瘟疫，为了躲避瘟疫，他们全家搬离了米兰。但不幸还是发生了，他的爸爸和爷爷都感染了这种瘟疫，并在同一天去世了，生活的重担就都落到他妈妈一个人身上，那时候的卡拉瓦乔才6岁。等到他卡拉瓦乔13岁时候，妈妈也离开了这个世界，于是他就成了孤儿。也就是在妈妈去世那一年，卡拉瓦乔开始跟着意大利画家西蒙·彼得扎诺学画画，一画就是四年，期间他也看了很多大师的作品，比如达芬奇的最后的晚餐啥的，增加了对艺术的了解。画家靠自己是很难的，因为你要搞商业你就无心创作，毕竟一个人的精力有限，所以需要钱的帮助，就是一定资金上的支持…卡拉瓦乔的命就很好。 多疑的thomas 召唤使徒马太 马太的殉难 手提歌利亚头的大卫 画中的男子手里提的，正是卡拉瓦乔的头。 意大利画家卡拉瓦乔，作为一个被通缉的画家，常年过着颠沛流离的逃亡生活。罪行满满的卡拉瓦乔最终想回到那个让他登上巅峰的罗马，但是他在那里杀过人啊，所以他决定画一幅画讨掌权者的欢心…… 被斩首的施洗约翰","categories":[{"name":"纪录片","slug":"纪录片","permalink":"https://github.com/zdkswd/categories/纪录片/"}],"tags":[{"name":"艺术","slug":"艺术","permalink":"https://github.com/zdkswd/tags/艺术/"}]},{"title":"松本行弘的程序世界 2 面向对象","slug":"松本行弘的程序世界 2 面向对象","date":"2018-07-05T14:14:32.000Z","updated":"2018-07-25T02:33:55.000Z","comments":true,"path":"2018/07/05/松本行弘的程序世界 2 面向对象/","link":"","permalink":"https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/","excerpt":"","text":"松本行弘的程序世界 2 面向对象编程和面向对象的关系计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。 颠倒的构造程序员要夺得主动权。 主宰计算机的武器为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。 怎样写程序编程风格 算法 数据结构 设计模式 开发方法 面向对象的编程方法smalltalk为面向对象编程语言之母。 面向对象的难点面向对象编程语言中最重要的技术是“多态性”。 多态性多态就是可以把不同种类的东西当做相同的东西处理。操作对象是三个箱子，分别是盖着盖子的箱子、加了锁的箱子、系着彩带的箱子。在编程中，“打开箱子”的命令，称之为消息；打开不同箱子的具体操作，称之为方法。 具体的程序调用box_open这个方法，根据参数（箱子的种类）的不同做相应的处理。 屏幕快照 2018-07-04 上午8.11.02 但是如果增加种类代码就要重写，修改的地方越来越多，追加箱子的种类就会变得非常困难。修改程序，实现真正的多态。“.”可以理解为“给前面的式子的值发送一个open消息”。 屏幕快照 2018-07-04 上午8.14.46 多态性的优点首先，各种数据可以统一地处理。关注要处理什么，而不是怎么处理。其次，根据对象选择方法，程序内部不会冲突。减轻程序员的负担。再次，新数据简单的追加可以实现，不需要改动以前程序，具备了扩展性。 数据抽象和继承面向对象编程的三原则：多态性，数据抽象，继承。别称：多态性：动态绑定，数据抽象：信息隐藏或封装。 面向对象的历史simula的“发明”面向对象编程思想起源于瑞典20世纪60年代后期发展起来的模拟编程语言Simula。以前，表示模拟对象的数据和实际的模拟方法是互相独立的，需要分别管理。 Smalltalk的发展smalltalke的开发宗旨是“让儿童也可以使用”，吸收了Simula的面向对象思想，且独居一格。不仅如此，还有一个很好的图形用户界面。使得世人开始了解面向对象编程的概念。 Lisp的发展许多重要的面向对象的概念都是从Lisp的面向对象功能中诞生的。 和c语言的相遇C++是直接受到了simula语言的影响而没有受到smalltalk多大影响。 Java的诞生java语言放弃了和C语言的兼容性，并增加了Lisp语言中一些好的功能。此外，通过Java虚拟机（JVM），java程序可以不用重新编译而在所有操作系统中运行。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 复杂性是面向对象的敌人软件开发的最大敌人是复杂性。人类的大脑无法做台复杂得处理，记忆力和理解力也是有限的。在计算机性能这么高的今天，人们为了找到迅速开发大规模复杂软件的方法，哪怕牺牲一些性能也在所不辞。 结构化编程如果不考虑黑盒内部的处理，系统复杂性就可以降低到人类的可控范围内。针对程序控制流的复杂问题，结构化编程采用看限制和抽象化的武器解决问题。 数据抽象化数据抽象是数据和处理方法结合。对数据内容的处理和操作，必须通过实先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。比如说栈。有了数据抽象，程序处理的数据就不再是单纯的数值或者文字这些概念性的东西，而变成了人脑容易想象的具体事物。而代码的“抽象化”则是把想象的过程“具体化”了。 雏形同样的对象大量存在时，为避免重复，可以采用两种方法管理对象。 原型。用原始对象的副本来作为新的相同的对象，JS用的原型。 模板，称为类。跟原型不同，面向对象编程语言的类和对象有明显区别。对象又称作实例。 找出相似的部分来继承类的增多会用到很多性质相似的类。这就违背了我们的DRY（Don’t Repeat Yourself）原则。把这些相似的部分汇总到一起就好了。继承就是这种方法。子类继承父类所有方法，如有需要可以增加新的方法，也可以重写父类方法。Ruby跟多数编程语言一样，一个子类只能有一个父类，即单一继承，C++、Lisp等编程语言中，一个子类可以有多个父类，这称为“多重继承”。 多重继承的缺点继承的原本目的实际上是逐步细化。所以为解决抽出类中相似部分的问题并不完全准确。 为什么需要多继承一个程序员也可能是一个作家。 多重继承和单一继承不可分离单一继承的特点： 继承关系单纯，有利有弊 多重继承的特点： 很自然的做到了单一继承的扩展。 可以继承多个类的功能。单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系变得复杂。这是多重继承的一个缺点。 goto语句和多重继承比较相似多重继承导致的问题： 结构复杂化 优先顺序模糊 功能冲突 解决多重继承的问题继承作为抽象化的手段，是需要实现多重继承功能的，如果一个类只允许抽出一个功能，那么限制就太多了。受限制的多重继承，这个解决或改善多重继承问题的方法出现了，它在Java中被称为接口（interface）,在Lisp或Ruby中是Mix-in。 静态语言与动态语言的区别编程语言可以分为静态语言和动态语言两种。像Java这样规定变量和算式类型的语言称为静态语言。在静态语言中，不能给变量赋不同类型的值，会导致编译错误，不通过执行就可以发现类型不匹配是静态语言的一个优点。如果只能给一个变量赋值同类对象，就不可能根据对象的类自动选择合适的处理方式（多态性）。 静态语言的特点当给一个类变量赋值时，既可以用这个类的对象来赋值，也可以用这个类的子类对象来赋值。这样就可以实现多态性。但是这时，如果定义了父类变量，赋值子类对象，变量不能调用子类特有的方法。 动态语言的特点动态语言允许调用没有继承关系的方法。静态语言中只能调用有继承关系的方法，数组、哈希表和字符串都能调用的方法，只能是在它们共同的父类（恐怕是Object）中定义。在静态语言中，如果要调用类层次中平行类的方法，那么必须要有一个可以表现这些对象的类型。如果没有这个类型，可调用的方法是十分有限的。由此我们看到静态语言中某种形式的多重继承是不可少的。 静态语言与动态语言的比较静态语言即使不通过执行也可以检查出类型是否匹配。但是逐个来定义算式和变量的类型又会使程序变得冗长。只有包含继承关系的类才会具有多态性。对于动态语言来说，静态语言显得限制过多，灵活性差。程序中有没有错误只有执行了才会知道。程序中没有类型定义，这样程序会变得很简洁。只要方法名一样，这些对象可以以相同的方式去处理。这样生产效率会大大提高，这种宽松的编程机制称为Duck Typing（鸭子类型检测） 继承的两种含义继承包括两种含义，一种是“类都有哪些方法”，也就是说这个类都支持些什么操作，即规格的继承。另一种是“类中都用了什么数据结构什么算法”，也就是实现的继承。静态语言中这两者的区别很重要，动态语言中区别规格的继承和实现的继承意义不大。即使没有继承关系，方法也可以自由地调用。java对两者有很明确的区分，实现的继承用extends来继承父类，规格的继承用implements来指定接口。类是用来指定对象实现的，而接口只是指定对象的外观（都有哪些方法）。类的继承是单一的，implements可以指定多个接口。接口对实现没有任何限制，也就是说，接口可以由跟实现的继承没有任何关系的类来实现。 接口的缺点为了解决多重继承的问题，人们允许了规格的多重继承，但是还是不允许实现多重继承。 继承实现的方法和静态语言Java不同，动态语言本来就没有继承规格这种概念。动态语言需要解决的就是实现的多重继承。Lisp、Perl和Python都提供了多重继承功能，这样就不存在单一继承的问题了。 从多重继承变形而来的Mix-inMix-in是降低多重继承复杂性的一个技术，最初是在Lisp中开始使用的。按以下规则来限制多重继承： 通常的继承用单一继承 第二个以及两个以上的父类必须是Mix-in的抽象类。 Mix-in类是具有以下特征的抽象类。 不能单独生成实例 不能继承普通类 积极支持Mix-in的Ruby 屏幕快照 2018-07-04 下午5.39.58 12345678我理解的接口的作用：接口是一种协议，满足同一接口实际上是告诉计算机你们是满足了同一样协议，你们是有关系的，java以这种方式间接实现了多态。当然可以实现多个接口，抽象为不同的“种类”，这样就相当于某种意义上的”多继承“。InterA a; a= new B(); a.fun(); a = new C(); a.fun(); bc都实现a的接口 两个误解 对象是对现实世界中具体物体的反应，继承是对物体分类的反应。（误） 多重继承是不好的。Mix-in不错。（误） 澄清：如果多继承用的不好就会出问题，Mix-in只不过是实现多重继承的一个技巧而已。 面向对象的编程不管过去怎样，现在面向对象最好的理解是，面向对象编程是结构化编程的延伸。随着软件的复杂化，开发越来越复杂，Dijkstra提倡把程序控制限制为（1）顺序（2）循环（3）分支 使得程序变得简单且容易理解。面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上对数据的结构化。面向对象编程，封装（黑盒）和多态（减少分支处理）是提高生产率的技术。结构化编程通过整理数据流，提高程序的生成效率和可维护性。同样，面向对象编程通过对数据结构的整理，提高了程序的生产效率和可维护性。 对象的模板=类类是吧数据黑盒化的工具，由于对类内部的操作都是通过类的方法来实现的，所以内部数据结构即使在以后发生变化，对外部也没有影响。 利用模板的手段=继承类是模块，继承就是利用模块的方法。传统的面向对象编程语言是一下子把规格和实现都继承下来，在最近，有的是把这两种继承分开了。比如java里的接口就是规格继承。 多重继承不好吗单一继承的类之间的关系是很单纯的树结构。但是对于多重继承而言，类之间的关系却是复杂得网状结构。静态语言中可以实现多态性只是局限于拥有共通父类的对象。为了解决这个问题，静态面向对象编程语言的代表C++支持多重继承。java也可以通过接口来支持规格的多重继承。1234**静态类型语言**: 是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型，某些具有类型推导能力的现代语言可能能够部分减轻这个要求. **动态类型语言**: 是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 **强类型语言**: 是一旦变量的类型被确定，就不能转化的语言。实际上所谓的貌似转化，都是通过中间变量来达到，原本的变量的类型肯定是没有变化的。 **弱类型语言**: 则反之，一个变量的类型是由其应用上下文确定的。比如语言直接支持字符串和整数可以直接用 + 号搞定。当然，在支持运算符重载的强类型语言中也能通过外部实现的方式在形式上做到这一点，不过这个是完全不一样的内涵 动态编程语言也需要多重继承动态编程语言没有类型检查，从这方面来说没有理由用多重继承，但是动态编程语言肯定需要多重继承。实现共享可以通过多个对象的组合（composition）和委托（delegate）来做到。 驯服多重继承的方法多重继承可能引发的问题： 类关系复杂化 继承功能名字重复最初的问题是因为类关系从简单的树结构变成了复杂的网状结构。 屏幕快照 2018-07-05 上午9.18.30 父类的优先级并不明确，多重继承设计的一个有效的技巧是Mix-in。用Mix-in做多继承设计时，从第2个父类开始的类要满足以下条件。 不能单独生成实例的抽象类。 不能继承Mix-in以外的类。 抽象类和接口的对比 屏幕快照 2018-07-05 上午10.41.50 mix-in的例子 屏幕快照 2018-07-05 上午10.44.57 通过对功能的分离，多重继承就可以由单一继承加上Mix-in类来实现。利用Mix-in就可以同时享有单一继承的单纯性和多重继承的共有性。 对于名字重复问题（如函数名），多重继承编程语言都有自己的应对方法，大致分为以下3种： 给父类定义优先级 把重复的名字替换掉 指定使用类的名字 ruby中多重继承的实现方法Mix-in java实现多重继承的方法接口。。 Duck Typing诞生之前静态是指程序执行之前，从代码中就可以知道一切。程序静态的部分包括变量、方法的名称和类型以及控制程序的结构等等。相对于静态，动态是指在程序执行之前有些地方是不知道的。程序动态的部分包括变量的值、执行时间和使用的内存等等。通常情况下、程序本来就是不被执行就不知道结果的，所以在一定程度上说程序都具有动态特性。因此，严格说静态和动态之间的界限是很微妙的。 为什么需要类型动态的类型是从Lisp中诞生的动态类型在面向对象中发展起来了对象保存着有关自己种类的信息，某个变量可以用各种类型的数据来赋值，这两点是多态这一面向对象重要特性的必要条件。 动态类型和静态类型的邂逅20世纪80年代，面向对象编程语言主流是包含动态数据类型的语言，但是在21世纪的今天，使用最广泛的面向对象编程语言是具有静态类型的java和c++。受simula很大影响的c++引入了子类对象可以看成是父类对象这个原则，对象也采用了静态类型。根据这个原则，在编译时就可以知道变量或算式的类型，又可以根据执行时的数据类型自动选择合适的处理，从而同时具备了静态类型的优点和动态类型的多态性。 静态类型的优点 最大的优点是在编译时能够发现不匹配的错误。 如果明确指定了数据类型，在编译时可以用到的信息就很多，利用这种信息可以在编译时对程序做优化，提高程序执行速度。 在读程序时提高理解度，IDE也可以自动补充。 问题： 不指定类型就写不了程序，数据类型只是一些辅助信息，并不是程序本质。有的类型声明仅仅是为了满足编译器的要求。程序规模也因为数据类型的定义而变大。 灵活性问题。静态类型本身限制了给某个变量只能赋值某种类型的对象，这种限制可能成为妨碍将来变化的枷锁。 动态类型的优点 源代码简洁，提高生产力。 会不会更难以理解，更突出程序处理的实质，程序函数相差几十倍并不少见，理解起来反而简单。 会不会运行更缓慢，同样的处理，在大多数情况下，静态类型编程语言运行得要快些。这是因为动态类型程序执行时要做类型检查。另外，静态类型的编程语言大都是通过编译把程序源代码转换成可以直接执行的形式，而动态类型的编程语言大多是边解释源代码（转换成内部形式）边执行，这种编译型处理和解释型处理的区别也是影响程序执行速度的愿意之一。 灵活，灵活性的关键是Duck Typing。 最大的缺点是不执行就检测不出错误。 只关心行为的Duck TypingIf it walks like a duck and quacks like a duck,it must be a duck.（走起路来像鸭子，叫起来也像鸭子，那么他就是鸭子）。根本不考虑一个对象属于什么类，只关心它有什么样的行为（它有哪些方法）。动态语言用Duck Typing的概念设计时需要遵循的原则最低限度是避免明确的类型检查。 避免明确的类型检查克服动态类型的缺点 执行时才能发现可以用完备的单元测试来解决，如果能严格实行完备的单元测试的话，即使没有编译时的错误检查，程序的可靠性也不会降低。 读程序时可用到的线索少这一点可以通过完整的文档来解决。可以在源代码中同时写文档，减轻维护文档的负担。 运行速度慢，随着计算机性能的提升已经不再重要，现在的程序开发中，程序的灵活性和生产力更为重要。 动态编程语言现在我们对程序开发生产力的要求越来越高，也就是说，要在更短的时间内开发出更多的功能。尽快着手开发，快速应对需求变更的开发方式变得越来越重要。在这种快速开发模式中，Duck Typing所代表的执行时的灵活性就非常有用。Ruby、Python、Perl和PHP等优秀的动态类型编程语言，因为它们在执行时所具有的灵活性而越来越受到人们的关注。 元编程元编程是对程序进行编程的意思。 元编程利用元编程可以动态生成类的方法，而且重要的是你可以自己编写生成过程，不支持元编程的编程语言实现这样的功能是很麻烦的，要么需要扩展语言的语法，要么用宏定义等预处理方法来实现。 反射元编程的反射（reflection）,在编程语言中它是指在程序执行时取出程序的信息或者改变程序的信息。Ruby彻底实现了对程序的动态操作。 屏幕快照 2018-07-05 下午7.10.21 元编程的例子Ruby使用Delegator这个库实现了委托功能，调用对象d的方法时可以转变为调用a的方法。我们还可以给这个对象增加特意方法来改变它的部分行为，这就大大扩展了它的应用范围。 使用反射功能分布式Ruby的实现Delegator将被调用的方法直接委派到其他对象，这一功能在很多领域都有应用。如dRuby。dRuby是通过网络来调用方法的库。dRuby可以生成服务器上存在的远程对象（Proxy），Proxy的方法调用可以通过网络执行。调用的方法在服务器上的远程对象中执行，执行结果可以通过网络返回。这和java的RMI(Remote Method Invocation)功能比较相似。但是，利用Ruby的元编程功能，不用明确定义接口，也可以通过网络调用任一对象的方法。C++和Java的远程调用是用IDL（Interface Definition Language）等语言来定义接口的，自动生成的存根（stub）必须编译和连接。和这些相比，Ruby的元编程更简单。 数据库的应用在数据库领域，元编程也很有用。web应用程序框架Ruby on Rails(也称为Rails或RoR)中也应用了元编程。具体地说是在与数据库关联的类库（ActiveRecord）中，利用元编程简单的把数据记录定义为对象。由于元编程功能让我们可以获取类名，在执行时增加方法。元编程的功能使得Rails被称赞为生产效率高的Web应用程序框架。 输出xml手工写XML是很麻烦的，利用Ruby块功能则可以很方便的处理。 元编程和小编程语言元编程功能可以运用到DSL领域，DSL是针对特定领域强化了功能的小规模编程语言。通过DSL用户可以强化应用程序的功能或者定制一些功能。 声明的实现Ruby的方法可以读取或改变程序自身的状态，利用普通的方法调用，可以实现其他编程语言中声明所完成的工作。 上下文相关的实现instance_eval方法接受块作为参数，把调用对象置换成self来执行块。 单位的实现词汇的实现针对特定领域，如果用Ruby来定义需要的类和方法，那么就可以认为Ruby是这个领域的专用语言。这些类和方法可以称为这个领域的词汇。 层次数据的实现适合DSL的语言，不适合DSL的语言Ruby是非常适合DSL的语言。首先定义好DSL用的小语言，然后编译成C++、java等目标语言。编译器经常用到Ruby这种具有优秀文本处理的语言。另一种实现DSL方法的例子是解释器。比如开发应用程序时从设计到实现是很复杂的，可以利用固定的语法和类库函数来读取程序。具体方法是用XML、DOM等XML处理类库来解释小语言语法。这是Java应用程序的配置文件曹勇XML的原因之一。通过XML文件，不用每次编译Java程序就可以改变配置，定制程序的行为。这种用法可以把XML称为Java界的DSL，或是Java应用程序的脚本语言。12脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是--解释运行--而非编译。虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"周海宏音乐鉴赏 一 打开你的耳朵","slug":"周海宏音乐鉴赏 一 打开你的耳朵","date":"2018-07-04T14:28:13.000Z","updated":"2018-07-04T14:28:47.000Z","comments":true,"path":"2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/","excerpt":"","text":"周海宏音乐鉴赏 一 打开你的耳朵1.1音乐鉴赏的误区音乐中包含各种内容的表现，说不出来是什么是因为你“听不懂”.专业学生也”听不懂“。音乐两个基本属性1 没有视觉性2 没有语义性“听不懂”–说不出音乐表现的是什么并非听者欣赏水平差，因为音乐不能直接传达视觉性与语义性的内容。 在音乐的欣赏中-不一定非要听出明确的视觉性、语义性内容。-不一定非要用文学化、美术化的内容去解说音乐。 在音乐中追求明确的概念性、视觉性内容，用文学化与美术化的方式欣赏音乐是一个误区。 音乐何须“懂”。 1.2音乐的艺术本质音乐是动态的。音乐是情绪的艺术。1 纯听觉感受2 情绪的感受动态纪实细腻地描摹内心的感受。 1.3 音乐审美的基本概念幸福人生最重要的是丰富多彩，真正的欣赏音乐，就去听最伟大的音乐。世界是这么龌龊这么黑暗，可悲的不是世界这么龌龊这么黑暗，而是不知道世界还有光明。音乐是人类精神的避难所。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"音乐鉴赏","slug":"音乐鉴赏","permalink":"https://github.com/zdkswd/tags/音乐鉴赏/"}]},{"title":"松本行弘的程序世界1 我为什么开发Ruby","slug":"松本行弘的程序世界1 我为什么开发Ruby","date":"2018-07-04T10:38:32.000Z","updated":"2018-07-04T10:38:47.000Z","comments":true,"path":"2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/","excerpt":"","text":"松本行弘的程序世界1 我为什么开发Ruby编程语言的重要性程序员由于使用的编程语言不同，思考方法和编写出的代码都会受到很大的影响。 Ruby的原则 简洁性 扩展性 稳定性简洁性随着编程语言的演进，程序员已经可以更简单、更抽象地编程了。面向对象的方法没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序运行开销。现在由于计算机性能大大提高，只要可以提高软件的开发效率，浪费一些计算机资源也无所谓了。ruby的目标是成为开发效率高、能直接运行的伪码式编程语言。省去了不必要的声明。扩展性Ruby看重的不是明哲保身，而是如何最大限度的发挥程序员自身的能力。编程的历史就是因为想当然而失败的历史，ruby对整数范围不做任何限定，尽最大努力排除“想当然”。稳定性虽然ruby非常重视扩展性，但明知道LISP风格的宏能带来巨大的扩展性，仍没有使用。一切皆因兴趣","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界0 说在前面","slug":"松本行弘的程序世界0 说在前面","date":"2018-07-04T10:35:32.000Z","updated":"2018-07-04T10:36:06.000Z","comments":true,"path":"2018/07/04/松本行弘的程序世界0 说在前面/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/松本行弘的程序世界0 说在前面/","excerpt":"","text":"松本行弘的程序世界0 说在前面vczh如何设计一门语言（一）好的语言，除了库写起来又容易又好用以外，还有两个重要的特点：容易学，容易分析。关于容易学这一点，其实不是说，你随便看一看就能学会，而是说，只要你掌握了门道，很多未知的特性你都可以猜中。这就有一个语法的一致性问题在里面了。 前言ruby code for fun这本书是松本行弘从一个编程语言设计者的角度去看待各种各样的流行编程语言，分析它们有哪些特点以及ruby编程语言如何进行取舍。ruby本身大量参考了一个更古老而著名的面向对象编程方法的开山鼻祖smalltalk以及偷师函数式编程语言鼻祖LISP。程序员社区有种说法：任何现代编程语言都脱胎于smalltalk于LISP。看看Ruby设计师是怎么设计Ruby语言的，则可以高屋建瓴的理解一些主流的编程语言。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"growth全栈","slug":"growth全栈","date":"2018-07-03T01:12:25.000Z","updated":"2018-07-03T03:01:34.000Z","comments":true,"path":"2018/07/03/growth全栈/","link":"","permalink":"https://github.com/zdkswd/2018/07/03/growth全栈/","excerpt":"","text":"基础知识篇环境是生产率的一部分。高效的程序员与低效的程序员间十倍的差距，至少有三倍是因为环境差异。语言和开发软件都是工具，都有相对更合适的情况。 提高效率的工具：快速启动软件windows-&gt; launcy IDEDEBUG工具终端或命令提示符包管理环境搭建OSXHomebrew包管理工具，官方称之为 The missing package manager for OS X。 Homebrew Caskbrew-cask 允许你使用命令行安装 OS X 应用。 iTerm2iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。 ZshZsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:• 更高效• 更好的自动补全• 更好的文件名展开(通配符展开) • 更好的数组处理• 可定制性高 Oh My ZshOh My Zsh 同时提供一套插件和工具，可以简化命令行操作。 MacDownMacDown 是 Markdown 编辑器。 CheatSheetCheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按 。 SourceTreeSourceTree 是 Atlassian 公司出品的一款优秀的 Git 图形化客户端。 AlfredMac 用户不用鼠标键盘的必备神器，配合大量 Workflows，习惯之后可以大 大减少操作时间。上手简单，调教成本在后期自定义 Workflows，不过有大量雷锋使用者提供的现成 扩展，访问这里挑选喜欢的，并可以极其简单地根据自己的需要修改。 VimiumVimium 是一个 Google Chrome 扩展，让你可以纯键盘操作 Chrome。 WindowsChocolateyChocolatey 是一个软件包管理工具，类似于 Ubuntu 下面的 apt-get, 不过是 运行在 Windows 环境下面。 WoxWox 是一个高效的快速启动器工具，通过快捷键呼出，然后输入关键字来搜 索程序进行快速启动，或者搜索本地硬盘的文件，打开百度、Google 进行搜 索，甚至是通过一些插件的功能实现单词翻译、关闭屏幕、查询剪贴板历史、 查询编程文档、查询天气等更多功能。它最大的特点是可以支持中文拼音的 模糊匹配。 PowerShellWindows PowerShell 是微软公司为 Windows 环境所开发的壳程序(shell) 及脚本语言技术，采用的是命令行界面。这项全新的技术提供了丰富的控制 与自动化的系统管理能力。 cmdercmder 把 conemu，msysgit 和 clink 打包在一起，让你无需配置就能使用一 个真正干净的 Linux 终端!她甚至还附带了漂亮的 monokai 配色主题。 Total CommanderTotal Commander 是一款应用于 Windows 平台的文件管理器，它包含两个 并排的窗又，这种设计可以让用户方便地对不同位置的 “文件或文件夹” 进 行操作，例如复制、移动、删除、比较等，相对 Windows 资源管理器而言 方便很多，极大地提高了文件操作的效率，被广大软件爱好者亲切地简称为: TC 。 GNU/LinuxZshZsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:• 更高效• 更好的自动补全• 更好的文件名展开(通配符展开)• 更好的数组处理• 可定制性高 Oh My ZshOh My Zsh 同时提供一套插件和工具，可以简化命令行操作。 ReTextReText 是一个使用 Markdown 语法和 reStructuredText (reST) 结构的文本 编辑器，编辑的内容支持导出到 PDF、ODT 和 HTML 以及纯文本，支持即 时预览、网页生成以及 HTML 语法高亮、全屏模式，可导出文件到 Google Docs 等。 LaunchyLaunchy 是一款免费开源的协助您摒弃 Windows “运行” 的 Dock 式替代工 具，既方便又实用，自带多款皮肤，作为美化工具也未尝不可。 学习一门语言，输出是最好的输入，实践更是硬道理。 Web编程基础运用HTTP传递数据,浏览器第一步Parser HTML,Paser HTML 实质上就是将其 将解析为 DOM Tree。与此同时，CSS 解析器会解析 CSS 会产生 CSS 规则树。随后会根据生成的 DOM 树和 CSS 规则树来构建 Render Tree，接着生成 Render Tree 的布局，最后就是绘制出 Render Tree。 HTML超文本标记语言 浏览器解析器对中文支持不友好。 浏览器解析器对英文支持友好。 CSS选择器类选择器，id选择器JavaScriptHTML 中插入 JavaScript 的方法，就需要用到 HTML 中的 &lt; script&gt; 标签 完整的 JavaScript 应该由下列三个部分组成:• 核心 (ECMAScript)——核心语言功能• 文档对象模型 (DOM)——访问和操作网页内容的方法和接口• 浏览器对象模型 (BOM)——与浏览器交互的方法和接口 有了 DOM 我们就可以对页面进行操作，可以说我们看到的绝大部分的页面效果都是通过 DOM 操作实现的。 前端与后端后台语言选择javascript只要是 Web 就会有前端,只要有前端就需要有 JavaScript。与此同时 Node.js在后台中的地位已经愈发重要了。对于 JavaScript 来说，它可以做很多类型的应用。这些应用都是基于浏览器来运行 的，有:• Electron + Node.js + JavaScript 做桌面应用• Ionic + JavaScript 做移动应用• Node.js + JavaScript 网站前后台• JavaScript + Tessl 做硬件 PythonJavaphpMVCModel模型用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。View 层只是单纯的一个显示作用，这也是我们推荐的做法。业务逻辑应 该尽可能的放置于业务层。Controller控制器层起到不同层面间的组织作用，用于控制应用程序的流程。 后台即服务移动端应用程序 前端框架选择AngularAngularJS 对于后端人员写前端代码来说，是一个非常不错的选择。Angular 框架 采用并扩展了传统 HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许 模型和视图之间的自动同步。 ReactReact 只是我们在上面章节里说到的 View 层，而这个 View 层需要辅以其他框架才 能完成更多的工作。并且 React 还有一个不错的杀手锏——React Native，虽然这个框架还在有条不紊地 挖坑中，但是这真的是太爽了。以后我们只需要一次开发就可以多处运行了，再也没有 比这更爽的事情发生了。 VueVue.js 是一个轻量级的前端框架。它是一个更加灵活开放的解决方案。它允许你以 希望的方式组织应用程序，你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。 jQuery系jQuery 还是一个不错的选择，不仅仅对于学习来说，而且对于工作来说也是如此。 如果你们不是新起一个项目或者重构旧的项目，那么必然你是没有多少机会去超越 DOM。 前台与后台交互AjaxAJAX 即 “Asynchronous JavaScript And XML”(异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更 新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的 网页如果需要更新内容，必须重载整个网页页面。 JSON WEB TokensJSON Web Token (JWT) 是一种基于 token 的认证方案。在人们大规模地开始 Web 应用的时候，我们在授权的时候遇到了一些问题，而这些 问题不是 Cookie 所能解决的。通过 JWT 我们可以更方便地写出适用于前端应用的认证方案，如登陆、注册这些功能。在使用 JWT 的时候也需要注意安全问题，在允许的情况下应该使用 HTTPS 协议。 WebSocketHTML5 推出了一种 在单个 TCP 连接上进行全双工通讯的协议 WebSocket。WebSocket 可以让客户端和服务器之间存在持久的连接，而且双方都可以随时开始 发送数据。 编码Web 应用的构建系统构建系统 (build system) 是用来从源代码生成用户可以使用的目标的自动化 工具。目标可以包括库、可执行文件、或者生成的脚本等等。 常用的构建工具包括 GNU Make、GNU autotools、CMake、Apache Ant(主要用于 JAVA)。此外，所有的集成开发环境(IDE)比如 Qt Creator、Microsoft Visual Studio 和 Eclipse 都对他们支持的语言添加了自己的构建系统配置工具。通常 IDE 中的构建系 统只是基于控制台的构建系统(比如 Autotool 和 CMake )的前端。对比于 Web 应用开发来说，构建系统应该还包括应用打包 (如 Java 中的 Jar 包，或 者用于部署的 RPM 包、源代码分析、测试覆盖率分析等等。 Web 应用的构建GulpGulp.js是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你 可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务 的 Gulp 文件都是通过 JavaScript(或者 CoffeeScript )源码来实现的。 JSHint最初，lint这个工具用来扫描C源文件并对源程序中不可移植的代码提出警告。但是现在大多数lint实用程序已经变得更加严密，它不但可以检查出可移植性问题，而且可以检查出那些虽然可移植并且完全合乎语法但却很可能是错误的特性。对应于不同的语言都会有不同的 lint 工具，在 JavaScript 中就有JSLint。JavaScript 是一门年轻、语法灵活多变且对格式要求相对松散的语言，因此这样的工具对于这门语 言来说比较重要。• 可配置规则，每个团队可以自己定义自己想要的代码规范。• 对社区非常友好，社区支持度高。• 可定制的结果报表。 自动化测试工具Mocha 是一个可以运行在 Node.js 和浏览器环境里的测试框架。 编译对于静态型语言来说，编译是一个很重要的步骤。不过，对于动态语言来说也存在这样的工具。动态语言的编译:是以我们常见的 JavaScript 为代表。打包,1. DEB 2.RPM 3.压缩文档 tar.gz 如何编写测试TODO测试金字塔 从上到下 ui测试 服务测试 单元测试测试替身 Stub Mock 代码重构TODO重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。 上线HTTP服务器目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。 ApacheApache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广 泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器 端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译 到服务器中。 NginxNginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件(IMAP/ POP3)代理服务器，并在一个 BSD-like 协议下发行。由俄罗斯的程序设计师 Igor Sysoev 所开发，供俄国大型的入又网站及搜索引擎 Rambler(俄文:Рамблер)使用。 其特点是占有内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务 器中表现较好，中国大陆使用 Nginx 网站用户有:百度、新浪、网易、腾讯等。 IISInternet Information Services(IIS，互联网信息服务)，是由微软公司提供的基 于运行 Microsoft Windows 的互联网基本服务。最初是 Windows NT 版本的可选包，随 后内置在 Windows 2000、Windows XP Professional 和 Windows Server 2003 一起发 行，但在 Windows XP Home 版本上并没有 IIS。 代理服务器代理服务器(Proxy Server)是一种重要的服务器安全功能，它的工作主要在 开放系统互联 (OSI) 模型的会话层，从而起到防火墙的作用。代理服务器大 多被用来连接 INTERNET(国际互联网)和 Local Area Network(局域网)。 Web缓存• 数据库端缓存• 应用层缓存• 前端缓存• 客户端缓存 功能开关当我们上线了我们的新功能的时候，这时候如果有个 Bug，那么我们是下线么?要 知道这个版本里面包含了很多的 Bug 修复。Feature Toggle 它是一种允许控制线上功能开启或者关闭的方式 依赖与包仓库数据分析SEO 搜索引擎优化分析工具 google analytics网站性能 Apdex联盟","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"全栈","slug":"全栈","permalink":"https://github.com/zdkswd/tags/全栈/"}]},{"title":"[Linux内核设计与实现]中断与中断处理","slug":"【Linux内核设计与实现】中断与中断处理","date":"2018-07-01T11:37:32.000Z","updated":"2018-07-01T11:37:21.000Z","comments":true,"path":"2018/07/01/【Linux内核设计与实现】中断与中断处理/","link":"","permalink":"https://github.com/zdkswd/2018/07/01/【Linux内核设计与实现】中断与中断处理/","excerpt":"","text":"【Linux内核设计与实现】中断与中断处理中断中断处理程序在Linux中，中断处理程序就是普普通通的C函数。 上半部与下半部的对比把中断处理分为两部分。中断处理程序是上半部–接收到一个中断，就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部。 注册中断处理程序中断处理程序是管理硬件的驱动程序的组成部分。每一设备都有相关的驱动程序，如果设备使用中断，则对应的驱动程序就注册一个中断处理程序。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters","slug":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters","date":"2018-06-15T09:49:56.000Z","updated":"2018-06-15T03:55:47.000Z","comments":true,"path":"2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/","link":"","permalink":"https://github.com/zdkswd/2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/","excerpt":"","text":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFiltersimport module在import module时，如果图标没有变化，不要忘了改setting.gradle AsyncTaskAsyncTask,即异步任务,是Android给我们提供的一个处理异步任务的类.通过此类,可以实现UI线程和后台线程进行通讯,后台线程执行异步任务,并把结果返回给UI线程. AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个泛型参数:Params:启动任务时输入的参数类型.Progress:后台任务执行中返回进度值的类型.Result:后台任务执行完成后返回结果的类型. AsyncTask主要有如下几个方法:doInBackground:必须重写,异步执行后台线程要完成的任务,耗时操作将在此方法中完成.onPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作.onPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.onProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度. Make Project Clean Project Make Project：编译Project下所有Module，一般是自上次编译后Project下有更新的文件，不生成apk。 Make Selected Modules：编译指定的Module，一般是自上次编译后Module下有更新的文件，不生成apk。 Clean Project：删除之前编译后的编译文件，并重新编译整个Project，比较花费时间，不生成apk。 Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成apk，这里效果其实跟Clean Project是一致的，这个不知道Google搞什么鬼～～ Build APK：前面4个选项都是编译，没有生成apk文件，如果想生成apk，需要点击Build APK。 Generate Signed APK：生成有签名的apk。 平时小的改动直接用Make Project就可以，可以看到只有它有快捷方式，表明这个功能要经常用。对于一些大的改动比如更新lib，大功能修改等，用Clean或Rebuild，毕竟这两个编译起来要费时间。如果有的时候死活编译不过，多试试Clean吧，会有意想不到的效果！ 关于abiFilters的使用最近项目中遇到了要使用opencv的情况，涉及到了abi兼容的选择。因为如果全部都适配的话，包很大，这样兼容那些用户数极少的cpu就很不划算，所以我只适配了armeabi-v7a这一个。但是今天在x64-v8a的模拟器上看的时候，提示我的library.so文件找不到，我记得这个应该是向下兼容的，但是出现这种情况很奇怪，于是我就在网上找了找答案。解决方法：abiFilters在app的gradle的defaultConfig里面加上这么一句ndk { abiFilters “armeabi-v7a” // 指定要ndk需要兼容的架构(这样其他依赖包里mips,x86,armeabi,arm-v8之类的so会被过滤掉)} 这句话的意思就是指定ndk需要兼容的架构，把除了v7a以外的兼容包都过滤掉，只剩下一个v7a的文件夹。用了这个方法之后，确实解决了问题。这就是解决方法。具体分析其实这个方法我开始是很奇怪的，我明明没有指定其他的兼容框架，为什么会需要一个过滤。我打来了apk的包，找到了里面的lib目录，发现里面有很多的兼容目录，然后看到里面目录里面的是一个fresco的.so文件。也就是说，fresco做了各个平台的兼容，所以它创建了各个兼容平台的目录。因为只要出现了这个目录，系统就只会在这个目录里找.so文件而不会遍历其他的目录，所以就出现了之前找不到.so文件的情况（因为其他目录没有我的.so文件）。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/zdkswd/tags/AndroidStudio/"}]},{"title":"[Linux内核设计与实现]系统调用","slug":"[Linux内核设计与实现]系统调用","date":"2018-06-15T03:53:32.000Z","updated":"2018-06-18T02:49:58.000Z","comments":true,"path":"2018/06/15/[Linux内核设计与实现]系统调用/","link":"","permalink":"https://github.com/zdkswd/2018/06/15/[Linux内核设计与实现]系统调用/","excerpt":"","text":"[Linux内核设计与实现]系统调用内核提供接口让应用程序调用实现特定功能，避免应用程序肆意妄为。 与内核通信系统调用在用户空间进程和硬件设备间添加了一个中间层。 提供硬件的抽象接口，即无需管磁盘类型，介质等问题。 保证系统的安全。 告知内核自己在使用硬件以实现多任务和虚拟内存。内核知道了才能更好的管理分配。系统调用是用户空间访问内核的唯一手段。 API、POSIX、和C库用户程序在用户空间使用API进行编程。API可以实现零个，一个或多个系统调用。UNIX世界中，最流行的应用程序接口是基于POSIX标准的。在大多数Unix上，根据POSIX定义的API函数和系统调用之间有着直接的关系。这个协议是对操作系统服务接口的标准化，从而保证了应用程序在源码层次的可移植性。具体来说是应用程序调用API，API中包含有系统调用，调用内核。程序员与API打交道，内核与系统调用打交道。 系统调用要访问系统调用（在Linux中常称为syscall）,通常通过C库中定义的函数调用来进行。 系统调用号在Linux中，每个系统调用被赋予一个系统调用号。通过这个独一无二的号可以关联系统调用。系统调用号非常重要，一旦分配就不能变更，否则编译好的应用就会崩溃。Linux中的sys_ni_syscall()系统调用几乎不做任何操作，相当于白板儿，用来替代那些被删除的或不可用的系统调用。内核用sys_call_table记录注册过的系统调用。 系统调用的性能Linux系统调用比其他操作系统执行的快。一是因为Linux有很短的上下文切换时间。二是系统调用处理程序和每个系统调用都很简洁。 系统调用的处理程序应用程序实际在API中调用的系统调用也并不是直接执行内核代码。应用程序以软中断的方式来通知系统执行一个系统的调用。通过引发异常来促使系统切换到内核态去执行异常处理程序。正是系统调用的处理程序。通过int$0x80指令触发中断。 指定恰当的系统调用系统调用号通过eax寄存器传递给内核。 参数传递也可以通过寄存器进行参数的传递。 系统调用的实现实现系统调用Unix格言提供机制而不是策略，当写一个系统调用时，要时刻注意可移植性和健壮性，还要为以后做打算。 参数验证系统调用必须仔细检查参数是否合法有效最重要的检查是用户提供的指针知否有效。内核无论何时都不能轻率接受来自用户空间的指针。 系统调用上下文在Context中，内核可以休眠可以被抢占。 绑定一个系统调用的最后步骤从用户空间访问系统调用","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"【安卓开发艺术探索】JNI和NDK编程","slug":"【安卓开发艺术探索】JNI和NDK编程","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T12:53:11.000Z","comments":true,"path":"2018/05/31/【安卓开发艺术探索】JNI和NDK编程/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/【安卓开发艺术探索】JNI和NDK编程/","excerpt":"","text":"NDK还提供了交叉编译器，开发人员只需要简单地修改mk文件就可以生成特定CPU平台的动态库。 JNI开发流程 在java中声明native方法声明native方法，且在类头部有加载动态库的过程，库的真实名字为加载所用名字加前缀lib，这是加载so库的规范。 编译java源文件得到class文件，然后通过javah命令导出JNI的头文件 javac com/ddd/example.javajavah com.ddd.example 在当前目录会产生一个com_ddd_example.h的头文件，它是javah命令自动生成的。函数名的格式遵循java_包名_类名_方法名 实现JNI方法，JNI方法是指java中声明的native方法，在工程的主目录下创建一个子目录，名称随意，将上一步生成的头文件复制其中，接着创建.cpp文件，include它。实现其中的方法。 编译so库并在java中调用so库这里采用gcc编译，切换到刚刚生成的子目录中，对于cpp编译指令如下： gcc -shared-I /本地jdk的安装路径/include -fPIC .cpp -o libexample.so so库编译完成后，就可以在Java程序中调用so库了，切换至主目录，执行指令 java -Djava.library.path=子目录名 com.ddd.example 其中-Djava.library.path指明了so库的路径。 NDK开发流程 下载并配置NDK 创建一个安卓项目，并声明所需的native方法如： public static native String hello(); 3.实现安卓项目中声明的native方法,在外部创建一个名为jni的目录，然后在jni目录下创建3个文件，.cpp,Android.mk和Application.mk .h中： JNIEXPORT jstring JNICALL Java_com_aiseminar_EasyPR_PlateRecognizer_hello(JNIEnv *, jclass); .cpp中实现其.h中的函数。Android.mk中，LOCAL_MODULE表示模块的名称，LOCAL_SRC_FILES表示需要参与编译的源文件。Application.mk中常用的配置项是APP_ABI,它表示CPU架构平台的类型，默认NDK编译全平台的so库，但可以指定编译特定平台的so库。 切换到jni目录的父目录，然后通过ndk-build命令编译产生so库这时NDK会创建一个和jni平级的目录libs，存放so库的目录。需要注意ndk-build命令默认指定jni目录为本地源码目录。若不是则无法成功编译。然后在app/src/main中创建一个名为jniLibs目录，将生成so库复制过去，通过AndroidStudio编译运行即可。jniLibs目录是AndroidStudio默认目录，也可修改App build.gradle文件，jniLibs.srcDir选项指定了新的存放so库的目录。 也可以通过AndroidStudio来自动编译来产生so库。首先需要在App的build.gradle的defaultConfig区域内添加NDK选项，其中moduleName制定了模块的名称，这个名称指定看打包后的so库文件名。ndk{\u0010 moduleName”example”}接着需要将JNI代码放在app/src/main/jni目录中，注意存JNI必须为jni，也可以通过如下方式指定JNI代码路径，其中jni.srcDirs指定JNI代码路径：jni.srcDirs ‘src/main/lib_src’经过上面的步骤，AndroidStudio就可以自动编译JNI代码了。 JNI的数据类型和类型签名JNI调用Java方法1 找到类名2 找到方法id3 调用方法对于非静态方法要先生成类才行","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback","slug":"Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T09:51:27.000Z","comments":true,"path":"2018/05/31/Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback/","excerpt":"","text":"SurfaceSurface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原生缓冲器以及其它方面的内容。原生缓冲器（rawbuffer）是用于保存当前窗口的像素数据的。通常画图是在一个Canvas对象上面进行的。 SurfaceViewSurfaceView，顾名思义就是Surface的View，通过SurfaceView就可以看到Surface的部分或者全部的内容.也就是说，Surface是用通过SurfaceView才能展示其中的内容。SurfaceView是Android中View的子类。事实上，在Android中所有用于界面展示的类皆为View的子类，包括那些不可见的、各种各样的Layout。 在Android中Surface是从Object派生而来，且实现了Parcelable接口。看到Parcelable就让人能很自然地想到数据容器，SurfaceView就是用来展示Surface中的数据的。在这个层面上而言，Surface就是管理数据的地方，SurfaceView就是展示数据的地方。 这个类的目的之一，就是提供一个可以用另外一个线程（第二个线程）进行屏幕渲染的surface（译注：即UI线程和绘制线程可以分离）。如果你打算这样使用，那么应当注意一些线程方面的语义： 所有SurfaceView和SurfaceHolder.Callback中声明的方法，必须在运行SurfaceView窗口中的线程中调用（典型地，就是应用的主线程。译注：即UI线程），因为它们需要正确地将同时被绘制线程访问的各种状态进行同步。 必须保证，只有在背后的Surface有效的时候 – 在SurfaceHolder.Callback.surfaceCreated()和 SurfaceHolder.Callback.surfaceDestroyed()这两个方法调用之间，访问它。 Android中实现序列化有两个选择：一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。 SurfaceHolderSurfaceHolder是一个接口，其作用就像一个关于Surface的监听器。提供访问和控制SurfaceView背后的Surface 相关的方法.它通过三个回调方法，让我们可以感知到Surface的创建、销毁或者改变。在SurfaceView中有一个方法getHolder，可以很方便地获得SurfaceView所对应的Surface所对应的SurfaceHolder.从设计模式的高度来看，Surface、SurfaceView和SurfaceHolder实质上就是广为人知的MVC，即Model-View-Controller。 SurfaceHolder.Callback前面已经讲到SurfaceHolder是一个接口，它通过回到方法的方式，让我们可以感知到Surface的创建、销毁或者改变。其实这一点是通过其内部的静态子接口SurfaceHolder.Callback来实现的。SurfaceHolder.Callback中定义了三个接口方法： abstract void surfaceChanged(SurfaceHolderholder, int format, int width, int height)当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。 abstract void surfaceCreated(SurfaceHolderholder)当surface对象创建后，该方法就会被立即调用。 abstract void surfaceDestroyed(SurfaceHolderholder)当surface对象在将要销毁前，该方法会被立即调用。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"}]},{"title":"implementation 与 compile 的区别 .iml build文件夹 安卓视图","slug":"implementation 与 compile 的区别 .iml build文件夹 安卓视图","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T09:51:21.000Z","comments":true,"path":"2018/05/31/implementation 与 compile 的区别 .iml build文件夹 安卓视图/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/implementation 与 compile 的区别 .iml build文件夹 安卓视图/","excerpt":"","text":"##implement概念 : 将该依赖隐藏在内部，而不对外部公开。理解 : 在 app mudule 中使用 implement 依赖的第三方库, 在其他 mudule 是无法调用的.举例 : 此时项目中有一个 mudule 是 ImageLoader ,其内部用 implement 指令依赖了 glide 这个库, 那么此时我们在 app mudule 中无法调用 glide 库中的方法. ##compile概念: android studio 3.0 版本后废弃该指令 改用 api 代替, api 完全等同于之前的 compile 指令, 也就是普通的依赖, 第三方库在 mudule 中依赖后其他 mudule 都可以使用该库.官方推荐在不影响的前提下优先使用 implement 指令依赖. .iml文件iml是 intellij idea的工程配置文件，里面是当前project的一些配置信息可以配置不输出文件夹。 build文件夹中的generated intermediates成功build后会产生以下文件夹：generated：The “generated“ folder contains java code generated by Android Studio for the module. The primary file here is “R.java“ which assigns symbolic names to each of the items in the “res” directory so they can be referenced in java source code.intermediates：The “intermediates“ folder contains individual files that are created during the build process and which are eventually combined to produce the “apk” file. Android视图与Project视图Project视图：Project视图是真实的文件结构，真实文件就是这么存放的。Android视图:可以说是build成功后根据配置信息，生成的结构。结构与配置信息有关，与build文件夹有关。不是真实文件的存放方式。其项目树的名字也不一定是真实名字，与配置信息有关。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/zdkswd/tags/AndroidStudio/"}]},{"title":"Bazel 和Protocol Buffer","slug":"Bazel 和Protocol Buffer","date":"2018-05-25T11:00:56.000Z","updated":"2018-05-25T11:01:05.000Z","comments":true,"path":"2018/05/25/Bazel 和Protocol Buffer/","link":"","permalink":"https://github.com/zdkswd/2018/05/25/Bazel 和Protocol Buffer/","excerpt":"","text":"BazelBazel是一个类似于Make的编译工具，是Google为其内部软件开发的特点量身定制的工具，如今Google使用它来构建内部大多数的软件。Google认为直接用Makefile构建软件速度太慢，结果不可靠，所以构建了一个新的工具叫做Bazel，Bazel的规则层级更高。 Protocol BufferProtocol Buffer是谷歌开发的处理结构化数据的工具。解决结构数据在信息持久化或网络传输时需要进行序列化以及还原数据的问题。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"Tensorflow模型持久化","slug":"Tensorflow模型持久化","date":"2018-05-25T11:00:56.000Z","updated":"2018-05-25T11:10:23.000Z","comments":true,"path":"2018/05/25/Tensorflow模型持久化/","link":"","permalink":"https://github.com/zdkswd/2018/05/25/Tensorflow模型持久化/","excerpt":"","text":"持久化代码实现通过tf.train.Saver类来保存和还原一个神经网络，模型文件目录下会出现三个文件。这是因为Tensorflow会将计算图的结构和图上参数取值分开保存。 model.ckpt.meta,保存了计算图的结构。 model.ckpt,保存程序中每一个变量的取值。 checkpoint,保存了一个目录下所有的模型文件列表。 加载已经保存的Tensorflow模型方法。1.使用和保存模型代码中一样的方法来声明变量。2.加载已经保存的模型。sever.restore(sess,”.ckpt”) 加载模型的程序也是定义了Tensorflow计算图上的所有运算，并声明了一个tf.train.Saver类。区别在于加载模型的代码中没有运行变量的初始化过程而是将变量的值通过已经保存的模型加载了进来。也可以直接加载已经持久化的图saver=tf.train.import_meta_graph(…..meta) 函数tf.get_default_graph().get_tensor_by_name(“add:0”)可以通过张量的名称获取张量。 也可以声明tf.train.Saver类时提供一个列表指定需要保存或者加载的变量。同样可以在保存和加载时使用字典给变量重命名。 使用Saver会保存运行程序所需的全部信息，然而有时不需要某些信息。在测试或者离线预测时，不需要某些辅助节点的信息。且多个文件存储时也并不方便。convert_variables_to_constants将计算图中的变量及其取值通过常亮保存。导出当前计算图的GraphDef部分只需要这一部分就可以完成从输入层到输出层的计算过程。 graph_def=tf.get_default_graph().as_graph_def() 将图中的变量及其取值转化为常量，同时将图中不必要的节点去掉。一些如变量初始化操作的系统运算也会被转化为计算图的节点。可以通过【】指定需要保存的操作。 output_graph_def=graph_util.convert_variables_to_constants(sess,graph_def,[‘add’])//add为节点名 将导出模型存入文件： with tf.gfile.GFile(“…pb”,”wb”) as f: f.write(output_graph_def.SerialzeToString()) 加载模型： with gflie.FastGFile(model_filename//.pb,’rb’) as f: graph_def=tf.GraphDef() graph_def.ParseFromString(f.read())result=tf.import_graph_def(graph_def,return_elements=[“add:0”])//add:0为一个张量sess.run(result) Saver持久化原理及数据格式Tensorflow通过元图（MetaGraph）来记录计算图中节点信息以及运行计算图中节点所需要的元数据。由Protocol Buffer定义，记录了五类信息： meta_info_def属性,记录计算图中的元数据以及所有使用到运算方法的信息。 graph_def属性，记录计算图的节点信息。 saver_def属性，记录了持久化模型时需要用到的一些参数。 collection_def属性维护集合的底层实现是通过collection_def这个属性。5 signature_def属性。 model.ckpt保存所有变量的取值，通过SSTable格式存储，大致为一个（key，value）列表。checkpoint是Saver类自动生成自动维护的。当某个保存的TensorFlow模型文件被删除时，这个模型对应的文件名也会从checkpoint文件中删除。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"Gradle","slug":"Gradle","date":"2018-05-20T09:28:56.000Z","updated":"2018-05-20T09:42:19.000Z","comments":true,"path":"2018/05/20/Gradle/","link":"","permalink":"https://github.com/zdkswd/2018/05/20/Gradle/","excerpt":"","text":"差异管理说到多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说国内某团购网站的Android App有100多个渠道.这里出现了什么?重复,反复的去打包而且这些包之前的差异很小(只是渠道号不同),和写代码一样我们应该复用,通过Gradle可以实现一个命令打出所有的渠道包,一个命令打出指定的渠道包.再复杂一点,你可能需要不同的渠道对应不同的签名文件,不同的icon,不同的服务器地址…这些都可以通过Gradle来方便的实现. 依赖管理:做软件开发你可能需要依赖各种不同的jar,library.你当然可以通过将.jar/library工程下载到本地再copy到你的工程中,但不知你是否听说过国外有个叫中央仓库的东西,在这个仓库里你可以找到所有你能想到以及你从来没听说过的jar,aar…The Central Repository Search Engine 这里可以找到所有你需要的依赖,而你需要的只是指定一个坐标,如下:compile’com.squareup.picasso:picasso:2.3.3剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点: 依赖不会进入到你的版本控制仓库中(默认会缓存到~/.gradle/下) 方便卸载装载依赖(只是一条坐标依赖,不需要删除即可) 方便的版本管理,如上图中的2.3.3既是picasso的版本号,若改为+就表示从中央仓库中下载最新的版本 不同工程的相同依赖不会存在重复副本(只在~/.gradle下存在一份)项目部署这方面我没怎么接触过,但据我所知通过一些插件,可以实现自动将你的输出(.jar,.apk,.war…)上传到指定仓库,自动部署… Gradle概念Gradle，这是一个基于 JVM 的富有突破性构建工具。Gradle不单单是一个配置脚本，它的背后是三门语言。 ◦ Groovy Language ◦ Gradle DSL ◦ Android DSLDSL的全称是Domain Specific Language，即领域特定语言。 The Gradle wrapperGradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。 Gradle构建基础build.gradle一个项目中会有一个project build.gradle。与若干个module build.gradle.你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本。 project与taskGradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等。插件本身就是包含了若干Task的。 Gradle脚本的执行时序 初始化，分析有哪些module将要被构建，为每个module创建对应的 project实例。这个时候settings.gradle文件会被解析。 配置,处理所有的模块的 build 脚本，处理依赖，属性等。这个时候每个模块的build.gradle文件会被解析并配置，这个时候会构建整个task的链表（这里的链表仅仅指存在依赖关系的task的集合，不是数据结构的链表）。先是project build.gradle后是module build.gradle,且从依赖树的叶节点执行。配置完了以后，有一个重要的回调project.afterEvaluate，它表示所有的模块都已经配置完了，可以准备执行task了。 执行，根据task链表来执行某一个特定的task，这个task所依赖的其他task都将会被提前执行。 Groovy基础[原创：任玉刚]Groovy和Java的关系Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。 Groovy的变量和方法声明在Groovy中，通过 def 关键字来声明变量和方法。 def a = 1def b = “hello world”def int c = 1 def hello() { println “hello world” // 方法调用省略括号 1; // 方法返回值省略return}def hello(String msg) { println (msg)} // 方法省略参数类型int hello(msg) { println (msg) return 1} // 方法省略参数类型int hello(msg) { println msg return 1 // 这个return不能省略 println “done”} Groovy的数据类型 String,用于字符串拼接。 闭包，Groovy中有一种特殊的类型，叫做Closure，翻译过来就是闭包，这是一种类似于C语言中函数指针的东西。闭包用起来非常方便，在Groovy中，闭包作为一种特殊的数据类型而存在，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在。 声明闭包 { parameters -&gt; code} List和Map,Groovy加强了Java中的集合类，比如List、Map、Set等.List还有一种看起来很奇怪的操作符&lt;&lt;，表示向List中添加新元素的意思. 加强的IO. 其他特性 所有的Class类型，都可以省略.class 只要有属性就有Getter/Setter，反之亦然。 with操作符 Book bk = new Book()bk.id = 1bk.name = “android art”bk.press = “china press” 可以简写为： Book bk = new Book()bk.with { id = 1 name = “android art” press = “china press”} 等等http://www.jianshu.com/p/ba55dc163dfd 定义Task task myTask { println “config myTask”} 通过上述方式定义的task,括号内部的代码会在配置阶段执行。 要括号内的代码仅仅在执行我们的task的时候才执行，这个时候可以通过doFirst或者doLast来完成。 • doFirst：task执行时，最开始的操作 • doLast：task执行时，最后的操作 myTask.doLast { println “after execute myTask”}myTask.doFirst { println “before execute myTask”} doLast还有一个等价的操作leftShift，leftShift还可以缩写为&lt;&lt; myTask &lt;&lt; { println “after execute myTask”} 剩下的细节还是需要大家查看Gradle文档，其实学习Gradle就是一个查文档的过程。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"软件构筑","slug":"软件构筑","permalink":"https://github.com/zdkswd/tags/软件构筑/"}]},{"title":"x86 ARM MIPS NDK JNI 交叉编译 ABI","slug":"x86 ARM MIPS NDK JNI 交叉编译 ABI","date":"2018-05-19T13:46:56.000Z","updated":"2018-05-25T10:28:41.000Z","comments":true,"path":"2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/","link":"","permalink":"https://github.com/zdkswd/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/","excerpt":"","text":"X86和ARM,MIPS架构x86架构采用CISC，代表公司Intel。而ARM采用RISC，代表公司ARM。MIPS架构多用在网关、猫、机顶盒等设备。 X86以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。x86为此还必须有复杂的分支预测机构，确保流水线的效率。再加上多级cache，支持超线程、虚拟化等等，x86的复杂度其实相当高ARM（Advanced RISC Machines）一个32位元精简指令集(RISC)处理器架构可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。 扩展性X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行 功耗X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度，考虑其完成复杂操作的能力，功耗很大。ARM则功耗很低。ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场，ARM目前是移动处理器的老大；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 x86是PC端老大。 NDKNative Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C/C++的动态库，并能自动将so和java一起打包成apk。NDK就是帮助我们可以在Android应用中使用C/C++来完成特定功能的一套工具.NDK的作用有很多，我们简单的列举两个:1.首先NDK可以帮助开发者“快速”开发C(或C++)的动态库。2.其次，NDK集成了“交叉编译器”。使用NDK，我们可以将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。 JNIJava Native Interface（JNI）标准是java平台的一部分，JNI是Java语言提供的Java和C/C++相互沟通的机制，其实JNI它就是一种协议,Java可以通过JNI调用C/C++代码，C/C++的代码也可以调用java代码。 交叉编译编译器在将中间代码连接成当前计算机可执行的二进制程序时，连接程序会根据当前计算机的CPU、操作系统的类型来转换。交叉编译就是在一个平台下（比如：CPU架构为X86，操作系统为Windows）编译出在另一个平台上（比如：CPU架构为arm,操作系统为Linux）可以执行的二进制代码。Google提供的NDK就可以完成交叉编译的工作。【Android：基于Linux 内核arm架构的操作系统，装在arm上的linux是需要重新编译内核的 所以和x86上的linux内核是不一样的】 Android 设备的CPU类型(通常称为”ABIs”) armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的部分Android设备都使用它. arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。 armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。 x86: 平板、模拟器用得比较多。 x86_64: 64位的平板。 arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so，那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了，所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，所以要么你别加arm64-v8a,要么armeabi里面有的so库，arm64-v8a里面也必须有。 对策： 为了减小 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中.so数量一致 对只提供 armeabi 版本的第三方 .so，原样复制一份到 armeabi-v7a 文件夹 应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。 当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支持armeabi-v7a和armeabi）。我们往往很容易对.so文件应该放在或者生成到哪里感到困惑，下面是一个总结：Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"},{"name":"c/c++","slug":"c-c","permalink":"https://github.com/zdkswd/tags/c-c/"}]},{"title":"lib dll .h .hpp 预编译","slug":"lib,dll,.h,.hpp,预编译","date":"2018-05-17T13:46:56.000Z","updated":"2018-05-17T13:48:13.000Z","comments":true,"path":"2018/05/17/lib,dll,.h,.hpp,预编译/","link":"","permalink":"https://github.com/zdkswd/2018/05/17/lib,dll,.h,.hpp,预编译/","excerpt":"","text":"静态库动态库静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。 这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。 是动态链接有一个缺点就是可移植性太差，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败。 头文件编译时，编译器通过头文件.h找到对应的函数库，预编译时将整个.h文件插入目标文件头部，项目中需要有其对应的.c文件进行编译生成中间文件进行连接。.hpp，本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数 一个头文件被别的源文件重复包含是经常发生的，如何避免某个头文件被重复包含呢？利用条件编译轻松解决。在头文件的开始加入： #ifndef HEADER_NAME#define HEADER_NAME 在头文件的结尾加上： #endif C/C++中的预编译指令程序的编译过程可以分为预处理、编译、汇编三部分，其中预处理是首先执行的过程，预处理过程扫描程序源代码，对其进行初步的转换，产生新的源代码提供给编译器。 #include指令，#include预处理指令的作用是在指令处展开被包含的文件。#include \\&lt;xxx.h&gt;#include “xxx.h”第一种方法将待包含的头文件使用尖括号括起来，预处理程序会在系统默认目录或者括号内的路径查找，通常用于包含系统中自带的公共头文件。第二种方法将待包含的头文件使用双引号引起来，预处理程序会在程序源文件所在目录查找，如果未找到则去系统默认目录查找，通常用于包含程序作者编写的私有头文件。 2.#define、#undef指令,#define指令定义了一个标识符及一个串，标识符称为宏名，源程序中宏名的每次出现都会用其定义的串进行替换，称为宏替换。#undef指令取消一个已定义的宏。 3.#if、#elif、#else、#endif指令，这几个指令称为条件编译指令，可对程序源代码的各部分有选择地进行编译。跟一般的if、else if、else语句类似，如果一个条件上的值为真，则编译它对应的代码，否则提过这些代码，测试下一个条件上的值是否为真。注意，作为条件的表达式是在编译时求值的，它必须仅含常量及已定义过的标识符，不可使用变量，也不可以含有操作符sizeof（sizeof也是编译时求值）。感觉这主要是用来设置一个宏选择性的编译一部分的代码。 4.#ifdef、#ifndef、#endif指令，这几个也是条件编译指令，其检查后面指定的宏是否已经定义，然后根据检查结果选择是否要编译后面语句。其中#ifdef表示”如果有定义“，#ifndef表示”如果没有定义“。这个通常可以用于防止重复包含头文件的问题 #ifndef MYHEAD_H#define MYHEAD_H#include “myHead.h”#endif 5.#line指令,C语言中可以使用FILE表示本行语句所在源文件的文件名，使用LINE表示本行语句在源文件中的位置信息。#line指令可以重新设定这两个变量的值，其语法格式为#line number[“filename”] 6.#error指令,#error指令在编译时输出编译错误信息，可以方便程序员检查出现的错误。 7.#pragma指令,该指令用来来设定编译器的状态或者是指示编译器完成一些特定的动作，它有许多不同的参数。7.1. #pragma once在头文件的最开始加入这条指令可以保证头文件只被编译一次。它可以实现上述使用#ifndef实现不重复包含头文件同样的功能，但可能会有部分编译系统不支持。 7.2.#pragma message该指令能够让编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。 7.3.#pragma warning…等等其他参数","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"},{"name":"c/c++","slug":"c-c","permalink":"https://github.com/zdkswd/tags/c-c/"}]},{"title":"Tensorflow可视化","slug":"Tensorflow可视化","date":"2018-05-17T10:11:41.000Z","updated":"2018-09-27T02:56:27.000Z","comments":true,"path":"2018/05/17/Tensorflow可视化/","link":"","permalink":"https://github.com/zdkswd/2018/05/17/Tensorflow可视化/","excerpt":"","text":"Tensorflow计算模型–计算图计算图的使用tensorflow程序可分为两个阶段，第一阶段定义图中所有的计算。第二阶段为执行阶段。tensorflow中，系统会自动维护一个默认的计算图，通过tf.get_default_graph函数可以获取当前默认的计算图。除了使用默认的计算图，Tensorflow支持通过tf.Graph函数来生成新的计算图。不同计算图上的张量和运算都不会共享。计算图可以通过tf.Graph.device函数来指定运行计算的设备。有效地整理TensorFlow程序的资源也是计算图的一个重要功能。在一个集合（collection）来管理不同类型的资源。 集合名称 集合内容 使用场景 tf.GraphKeys.VARIABLES 所有变量 持久化Tensorflow模型 tf.GraphKeys.TRAINABLE_VARIABLES 可学习的变量（一般指神经网络中的参数） 模型训练、生成模型可视化内容 tf.GraphKeys.SUMMARIES 日志生成的相关的张量 TensorFlow计算可视化 tf.GraphKeys.QUEUE_RUNNERS 处理输入的QueueRunner 输入处理 tf.GraphKeys.MOVING_AVERAGE_VARIABLES 所有计算了滑动平均值的变量 计算变量的滑动平均值 如通过tf.add_to_collection将资源加入一个或多个集合中。通过tf.get_collection获取一个集合里面的所有资源。 TensorBoard可视化TensorBoard简介TensorBoard可以通过TensorFlow程序运行过程中输出的日志文件可视化TensorFlow程序的运行状态。两者跑在不同进程中，TensorBoard会自动读取TensorFlow最新的日志文件。 #运行TensorBoard，将地址执行日志输出地址tensorboard –logdir=/path/to/log 命令启动服务默认端口号6006，localhost:6006可以看到界面。使用–port参数可以改变启动服务的端口。 变量管理TensorFLow提供了通过变量名称来创建或者获取一个变量的机制。通过这个机制在不同的函数中可以直接通过变量的名称来使用变量，而不需要将变量通过参数的形式到处传递。TensorFLow中通过变量名称获取变量的机制主要是通过tf.get_variable和tf.variable_scope函数实现。 v.get_variable和tf.Variable定义等价。区别在于前者变量名称是个必填项，后者是个选填项。v.get_variable会根据这个名字去创建或者获取变量。首先会试图创建一个变量，如有同名则创建失败。如果需要通v.get_variable获取一个已经创建的变量，需要tf.variable_scope函数生成一个上下文管理器。将参数reuse设置为True(获取唯一途径)，v.get_variable将只能获取已经创建过的变量。否则将尝试创建变量。 with tf.variable_scope(“name”,reuse=”True”): v=v.get_variable(“var”,[1]) tf.variable_scope会创建一个命名空间。foo/v:0 “:0”表示这个变量是生成变量这个运算的第一个结果。 TensorFlow计算图可视化命名空间与TensorBoard图上节点变量的初始化过程也会产生新的计算节点。为了更好的组织可视化效果图中的计算节点，TensorBoard支持通过TensorFlow命名空间来整理可视化效果图上的节点。在Tensorflow默认视图中同一命名空间计算图为一个节点，只有顶层命名空间的节点显示。除了tf.Variable_scope函数，tf.name_scope函数也提供了命名空间管理的功能，两者大部分情况下等价。唯一的区别是tf.get_Variable不受tf.name_scope函数的影响。即在tf.name_scope域里tf.get_Variable生成变量也不是域内的变量。节点之间有两种不同的边，一种是通过实线表示的，刻画了数据传输，箭头表示传输方向。另一种箭头是双向的，表示会修改，会互相影响。TensorBoard边上标注了张量的维度信息。如100*784说明batch为100，输入节点个数为784，粗细代表维度的总大小。若张量数量大于1时。图上将只显示张量的个数。虚线表示计算之间的依赖关系，如tf.control_dependencies函数指定操作同时进行。则存在虚线。TensorBoard会自动将连接比较多的节点放在辅助图中，可以手动移入主图或移出主图。TensorBoard不会保存用户对计算图可视化结果的手工修改，页面刷新之后计算图可视化结果又会回到最初的样子。 节点信息使用TensorBoard可以非常直观地展现所有Tensorflow计算节点在某一次运行时所消耗的时间和内存。 run_options =tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)// 运行时记录运行信息的proto。run_metadata = tf.RunMetadata() m, loss_value, step = sess.run( [train_op, loss, global_step], feed_dict={x: xs, y_: ys}, options=run_options, run_metadata=run_metadata) //将节点在运行时的信息写入日志文件。 writer.add_run_metadata(run_metadata=run_metadata,tag=(“tag%d” % i),global_step=i) 使用程序输出的日志启动TensorBoard,就可以了。进入GRAPHS栏，选择Session runs,Color会出现Compute time和Memory这两个选项。颜色越深消耗越大。Structure中如果有两个节点结构相同就会涂上相同的颜色。Device中可显示哪些使用了相同的设备（CPU/GPU）。点击节点时弹出的信息卡片也会显示这个节点的各种信息。 监控指标可视化 TensorFlow日志生成函数 TensorBoard界面栏 显示内容 tf.scalar_summary EVENTS TensorFlow中标量（scalar）监控数据随着迭代进行的变化趋势。 tf.image_summary IMAGES TensorFlow中使用的图片数据，这一栏一般用于可视化当前使用的训练/测试图片。 tf.audio_summary AUDIO TensorFlow中使用的音频数据。 tf.histogram_summary HISTOGRAMS TensorFlow中张量分布监控数据随着迭代轮次的变化趋势。 上述生成函数都不会立即执行，需要通过sess.run来明确调用这些函数。tf.merge_all_summaries()可将定义的所有日志文件执行一次。 writer writer=tf.train.SummaryWriter(path,tf.get_default_graph())writer.close() 或者 with tf.Session() as sess: writer=tf.train.SummaryWriter(path,sess.graph) 上述比较过时，若报错则改为writer = tf.summary.FileWriter(“output”, sess.graph) 可视化时，需要在程序中给必要的节点添加摘要（summary）,摘要会收集该节点的数据，并标记上第几步、时间戳等标识，写入事件文件（event file）中。tf.summary.FileWriter类用于在目录中创建事件文件，并且向文件中添加摘要和事件，用来在TensorBoard中展示。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"[Linux内核设计与实现]进程调度","slug":"【Linux】进程调度","date":"2018-05-15T13:39:12.000Z","updated":"2018-05-16T11:00:02.000Z","comments":true,"path":"2018/05/15/【Linux】进程调度/","link":"","permalink":"https://github.com/zdkswd/2018/05/15/【Linux】进程调度/","excerpt":"","text":"多任务现代Linux系统也许有100个进程在内存，但是只有一个处于可运行状态。Linux是抢占式多任务模式。 Linux的进程调度Linux2.5内核开始采用O（1）调度程序，对大服务器工作负载很理想但对于交互性桌面系统表现不佳。2.6.23内核后使用RSDL增加了交互性，此时被称为CFS（完全公平调度算法） 策略I/O消耗型和处理器消耗型的进程GUI属于I/O消耗型，多数时间都在等待键鼠交互操作。应当降低处理器消耗型的调度频率，以延长其运行时间。Linux更倾向于IO消耗型进程，也并未忽略处理器消耗型进程。 进程优先级Linux采用了两种不同范围的优先级范围。1：使用nice值，范围【-20，19】，默认0，越大优先级越低。Linux nice代表时间片比例，mac os nice代表时间片的绝对值。2：实时优先级，其值可配。范围【0，99】，越高优先级越大。任何实时进程优先级都高于普通进程。 时间片Linux的CFS调度器并没有直接分配时间片到进程，将处理器的使用比划分给了进程。进程所获处理器的时间和负载密切相关。受nice值得影响。Linux的CFS调度器抢占时机取决于进程的处理器使用比，若大于当前进程则抢占。 调度策略的活动对于一个文字编辑程序和一个视频处理程序，一般操作系统会分配文字编辑器更高的优先级和更多的时间片。Linux则是nice值相同，即平分50%时间，但是当文字编辑程序要使用处理器时，CFS发现其时间没到50%，会抢占视频处理程序执行。 Linux调度算法调度器类Linux调度器是模块方式，可以针对不同类型的进程选择合适的调度算法。完全公平调度（CFS）是针对普通进程的调度类。 Unix系统的进程调度CFS完全摒弃时间片而是分配进程一个处理器的使用比重，这样CFS确保了进程调度有恒定的公平性，将切换频率置于不断变动中。 公平调度CFS的最小粒度（最小时间片长度）为1ms，时间片分配时间根据目标延迟以及nice值决定的比例计算而得。所以说其实如果进程无限大的话，改法并不公平。但是能保证正常情况下是公平的。 Linux调度的实现时间记账 所有的调度器都必须对进程运行时间做记账。 调度器实体结构,CFS不再有时间片的概念，但是它也必须维护每个进程运行时间记账，为了确保每个进程只在公平分配给它的处理器时间运行。CFS使用调度器实体结构struct sched_entity作为名为se的成员变量，嵌入进程描述符struct task_struct内。 虚拟实时，struct sched_entity结构中的vruntime变量存放进程的虚拟运行时间，虚拟时间是以ns为单位的，与定时器节拍不再相关。vruntime可以准确地测量给定进程的运行时间，而且可知道谁应该是下一个被运行的进程。 进程选择当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小的vruntime值的进程。红黑树是一种以树节点形式存储的数据，这些数据都对应一个键值，可通过键值快速检索节点上的数据。 挑选下一个任务，CFS调度器选取待运行的下一个进程，是所有进程中vruntime最小的那一个，对应的便是树最左侧的叶子节点。 向树中加入进程，CFS如何将进程加入rbtree中，以及如何缓存最左叶子节点。这一切发生在进程变为可运行状态（被唤醒）或是通过fork()调用第一次创建进程时。enqueue_entity()函数实现了这一目的。改函数更新运行时间和其他一些统计数据，然后调用_enqueue_entity()进行繁重的插入操作，把数据项真正插入到红黑树中。 从树中删除进程, 删除动作发生在进程堵塞或者终止时。调度器入口进程调度的主要入口点是函数schedule()，它会找到一个最高优先级的调度类，其需要有自己的可运行队列。睡眠和唤醒休眠（被阻塞）进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程刚好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。 等待队列， 等待队列是由等待某些事件发生的进程组成的简单链表。 唤醒， 唤醒指定等待队列上的所有进程。抢占和上下文切换上下文切换，就是从一个可执行进程切换到另一个可执行的进程。由函数context_switch()负责，每当新的进程被选出来准备投入运行时，schedule()就会调用该函数。内核提供了一个need_resched标志表明是否需要重新执行一次调度，内核也就知道什么时候调用schedule()。当某个进程应该被抢占或优先级高的进程进入可执行状态时或中断返回或系统调用返回用户空间，会设置标志位。用户抢占内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。即用户抢占发生在 从系统调用返回用户空间时。 从中断处理程序返回用户空间时。 内核抢占Linux完整地支持内核抢占，只要重新调度是安全的，内核就可以在任何时候抢占正在执行的内核任务。安全即没有持有锁，即preempy_count=0且need_resched被设置，中断返回内核空间时，就可调度。同样若内核阻塞或显式调用schedule()也会显式抢占。 实时调度策略Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的非实时的调度策略是SCHED_NORMAL.这些策略被一个特殊的实时调度器管理。 SCHED_FIFO, 不基于时间片，可以一直执行下去，其比任何SCHED_NORMAL级的进程都先得到调度。更高优先级的SCHED_FIFO或SCHED_RR才能抢占。优先级一样的就轮流执行。 SCHED_RR,带有时间片的SCHED_FIFO，耗尽时间片时，只能调度同一优先级的进程。【 总结】：对于SCHED_FIFO进程，高优先级总是立即抢占低优先级进程，但低优先级决不能抢占SCHED__RR任务，即使它的时间片耗尽。Linux提供的是软实时工作方式，SCHED_RR与SCHED_FIFO优先级范围【0，99】，而SCHED_NORMAL使用nice值。与调度相关的系统调度Linux提供了一个系统调用族，用于管理与调度程序的相关参数。这些系统调用可以用来操作和处理进程优先级、调度策略及处理器绑定，同时还提供了显式地将处理器交给其他进程的机制。与调度策略和优先级相关的系统调用sched_setscheduler()和sched_getscheduler()用于设置和获取进程的调度策略和实时优先级。sched_setparam()和sched_getparam()用于设置和获取进程的实时优先级。与处理器绑定有关的系统调用Linux调度程序提供强制的处理器绑定机制。放弃处理器时间Linux通过sched_yield()系统调用，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"初识makefile_make_cmake","slug":"cmake","date":"2018-04-29T14:11:20.000Z","updated":"2018-05-16T11:02:54.000Z","comments":true,"path":"2018/04/29/cmake/","link":"","permalink":"https://github.com/zdkswd/2018/04/29/cmake/","excerpt":"","text":"初识makefile,make,cmake什么是makefilemake命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。makefile关系到了整个工程的编译规则。makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 什么是makemakefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法（包括链接）。 关于程序的编译和链接在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。Linux中的.so。一个lib文件是obj文件的集合。源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码 文件路径usr文件夹称为是Unix System Resource，即Unix系统资源的缩写。 bin文件夹是一个二进制程序文件夹1.bin是binary的缩写，代表的意思是二进制，二进制数据是用0和1两个数码来表示的数。2.bin这个文件夹里存放的是二进制可执行的文件，比如exe，msi，com等的都是二进制文件，双击就能运行。 GUN下面绝大部分应用的编译系统都是用automake。于是乎，你看到的很多很多应用都安装在了/usr/local/目录下然后通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变/usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件安装好的lib文件存放在“/usr/local/lib”文件夹，h文件存放在“/usr/local/include”（Unix） 什么是cmakeCMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。 dlldll存在于windows中 openCV安装过程 mkdir releasecd releasecmake -D CMAKE_BUILD_TYPE=RELEASE -D 换行CMAKE_INSTALL_PREFIX=usr/local/opencv3.1.0 -G “Unix Makefiles” ..makesudo make install","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"软件构筑","slug":"软件构筑","permalink":"https://github.com/zdkswd/tags/软件构筑/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"}]},{"title":"李宏毅2017听课笔记1-Where does the error come from?","slug":"李宏毅error","date":"2018-04-25T14:48:13.000Z","updated":"2018-05-16T11:00:59.000Z","comments":true,"path":"2018/04/25/李宏毅error/","link":"","permalink":"https://github.com/zdkswd/2018/04/25/李宏毅error/","excerpt":"","text":"李宏毅2017听课笔记1-Where does the error come from? 这么多线是多次试验，每次试验拟合出一条红线 在这里直观的解释了为什么简单的模型偏差更大，因为最终是在函数集中选取最佳函数，因为函数简单的话，一开始划定的范围就较小。 正则化会伤害bias，因为只选择更平滑的曲线，相当于划了范围。（其实是让模型更简单了） 分为训练集，验证集，测试集","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"李宏毅","slug":"李宏毅","permalink":"https://github.com/zdkswd/tags/李宏毅/"}]},{"title":"李宏毅2017听课笔记0","slug":"李宏毅2017听课笔记0","date":"2018-04-25T01:26:25.000Z","updated":"2018-07-03T02:34:22.000Z","comments":true,"path":"2018/04/25/李宏毅2017听课笔记0/","link":"","permalink":"https://github.com/zdkswd/2018/04/25/李宏毅2017听课笔记0/","excerpt":"","text":"李宏毅2017听课笔记0前言之前听了吴恩达2014大部分的课以及吴恩达最近在网易云上的CNN课程。听闻李宏毅的课程不错，主要比较系统全面，来听一哈喽。不错的博客 0-1Introduction找出function 准备一个function set (model) 机器决定function们的好坏 找出最好的function Deep Learning：分类，非线性 Learning Map Reinforcement Learning在实际运用中，以上方法并不能解决全部问题，常常会遇到Beyond Classification的情况，比如语音识别，人脸识别，语言翻译等，那么就要通过增强学习来解决问题。增强学习的一个非常知名的应用就是 google 阿法狗。 Reinforcement Learning VS SupervisedSupervised 就像给了机器一个点读机，他听到一句话时可以看到其含义，每一句话都有标签，就像有一个手把手教他的老师。而Reinforcement Learning 就像跟女朋友对话，反复讲来回讲很多句话，直到女朋友觉得你无言以对愤然离去，机器唯一可以知道的就是他做的好还是不好，除此之外没有任何information。而这更像人类现实生活中的学习过程，必须自己像哪里做得好做得不够好，怎么修正。 Learning Map: scenario:学习情景，不受自己控制。意思是你现在有什么类型的 training data。 machine learning scenario Supervised Learning 有标签data Semi-supervised Learning 部分有标签data Unsupervised Learning 无标签data Transfer Learning 一堆不相干data Reinforcement Learning 只有来自外界的评价 task，意思是现在function的output是什么，只体现在supervised中，但其实可以插在以上五种Learning的每一种内。 machine learning task(output) Regression scalar Classification class1、class2…之一 Structured Learning 有结构的内容 Method方法模型，比如在Classification中有Linear模型 or Non-linear模型，我们可以将绿色部分插入任何红色部分中。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"李宏毅","slug":"李宏毅","permalink":"https://github.com/zdkswd/tags/李宏毅/"}]},{"title":"[Linux内核设计与实现]进程管理","slug":"【Linux内核】进程管理","date":"2018-04-16T10:50:51.000Z","updated":"2018-07-26T09:22:24.000Z","comments":true,"path":"2018/04/16/【Linux内核】进程管理/","link":"","permalink":"https://github.com/zdkswd/2018/04/16/【Linux内核】进程管理/","excerpt":"","text":"进程内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。父进程调用fork()复制现有进程创建一个全新的进程子进程。 每个线程都有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。进程的另一个名字是task，Linux内核通常把进程也叫做任务。 进程描述符及任务结构内核把进程的列表存放在任务列表（task list）的双向循环列表中。链表的每一项都是类型为task_struct称为进程描述符的结构中，该结构相对较大，包含的数据能够完整的描述一个正在运行的程序：打开的文件，进程地址空间，挂起信号，进程状态及其他。 分配进程描述符Linux通过slab分配器分配task_struct结构,这样能够对象复用和缓存着色。使用slab动态生成task_struct需要用到结构thread_info,其task域有指向实际进程描述符的指针。每个任务的thread_info在它的内核栈的尾端分配。 进程描述符的存放内核通过唯一标识符PID（process indentification value）来标识每个进程，PID存放在进程描述符。为了兼容性设置其为short int型，故其最大值为32768.但是对于大型服务器需要更大值。可以不考虑兼容性修改/proc/sys/kernel/pid_max提高上限。 内核访问任务需要获取指向task_struct的指针，故通过宏找到当前正在运行的进程描述符的速度就尤为重要。硬件的结构体系不同，宏的实现不同。例如有的体系结构有专用寄存器用于加快访问task_struct的速度，x86结构寄存器并不富余，就只能通过计算偏移间接查找task_struct。 进程状态task_struct的state域描述当前状态，必为五中之一 TASK_RUNNING(运行)在运行或在运行队列等待 TASK_INTERRUPIBLE(可中断)被阻塞 TASK_UNINTERRUPTIBLE（不可中断）接到信号也不会唤醒 _TASK_TRACED被其他进程跟踪 _TASK_STOPPED停止执行 设置当前的进程状态调整某个进程状态 set_task_state(task,state); 进程上下文可执行代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行，一般在用户空间执行，执行系统调用或触发异常陷入内核空间。对内核的访问必须经过明确定义的接口。 进程家族树Linux和Unix一样所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程读取系统初始化脚本（initscript）并执行其他相关程序最终完成系统启动整个过程。init进程的进程描述符是作为init_task静态分配的。对于当前task_struct，可以通过task_struct类型parent指针访问其父进程（必有一个），还包含一个children的子进程链表。 进程创建许多其他操作系统：首先在新的地址空间创建进程，读入可执行文件，最后开始执行。Unix：首先通过fork（）拷贝当前进程创建一个子进程，父子进程区别仅限于PID，PPID（子进程将其设为父进程PID值）和某些资源统计量。exec（）负责读取可执行文件并将其载入地址空间运行。如果 exec 调用成功,调用进程将被覆盖,然后从新程序的入口开始执行。这样就产生了一个新的进程,但是它的进程标识符与调用进程相同。这就是说,exec 没有建立一个与调用进程并发的新进程,而是用新进程取代了原来的进程。 写时拷贝Linux的fork（）采用写时拷贝，只有子进程在父进程进行写入时再进行拷贝，其他的时候是只读共享。所以fork（）的实际开销就是复制父进程页表以及创建PID。 fork（）Linux通过clone（）系统调用实现fork（）fork（）-调用-&gt;clone()-调用-&gt;do_fork()（完成创建的大部分工作）-调用-&gt;copy_process()copy_process工作: 调用dup_task_strucr()为新进程创建一个内核栈、thread_info和task_struct，此时，父子进程描述符完全一样。 检查并确保新创建这个进程后进程数目没有超出资源限制。 子进程着手于区别父进程。task_struct的许多成员被清零或设为初始值。 子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行。 copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERRIV标志被清0，表示进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。 调用alloc_pid()为新进程分配一个分配一个有效的PID。 根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信息处理函数、进程地址空间和命名空间等。一般，这些资源会所有线程共享，否则资源对每个进程是不同的，因此拷贝到这里。 最后，copy_process做扫尾工作并返回一个指向子进程的指针。 如果copy_process()成功返回do_fork()，新创进程被唤醒且内核有意让其首先执行。因为一般子进程都会马上调用exec()函数，可以避免父进程首先执行可能的写入造成的额外开销。 vfork（）除了不拷贝父进程的页表项以外，vfork()和fork()功能相同。基本没啥用。 线程在Linux中的实现Linux中，线程具有task_struct,它看起来就是普通进程，只是和其他一些进程共享某些资源，如地址空间。对Linux来说，线程只是进程间共享资源的手段。 创建线程线程创建于进程类似，只是在调用clone时需要传递一些参数标明需要共享的资源。创建Linux进程所花时间和其他操作系统创建线程要少。 内核线程独立运行在内核空间的标准进程，和普通进程区别在于没有独立地址空间。只在内核空间运行，和普通进程一样，可以被调度，也可以被强占。新的任务是由kthread内核进程通过clone()系统调用而创建的。内核线程启动后就一直运行到调用do_exit（）退出或其他部分调用kthread_stop()退出。 进程终结终结时，释放资源并告诉父进程。可以调用exit()主动终结,也可以异常被动终结,但大部分靠do_exit()来完成do_exit(): 将task_struct标志设为PF_EXITING 调用del_time_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器在排队也没有定时器处理程序在运行。 如果BSD的记账功能是开启的，do_exit()调acct_update_integrals()来输入记账信息。 调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是说，这个进程空间没有被共享），就彻底释放它们。 调用sem_exit()函数，如果进程排队等候IPC信号，它则离开队列。 调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为0，那么久代表没有进程在使用相应的资源可以释放。 接着把存放在task_struct和exit_code成员中的任务退出代码置为由exit（）提供的退出代码，或者去完成任何其他由内核机制规定的退出动作，退出代码存放在这里供父进程随时检索。 调用exit_notufy()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或为init进程，并把进程状态（存放在task_struct中的exit_state中）设成EXIT_ZOMBIE。 do_exit()调用schedule（）切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。do_exit()永不返回。 至此进程仅剩的内存就是内核栈，Thread_info 和task_struct结构。此时进程存在的唯一目的数向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关信息后，内存释放。 删除进程描述符进程终结时的清理工作和进程描述符的删除被分开进行，这样做可以让系统有办法在子进程终结后仍能获得它的信息。过程如上段。 孤儿进程造成的进退维谷如果父进程在子进程之前退出，必须有机制来保证子进程能够找到一个新的父亲。解决方法是给子进程在当前线程组内找一个线程做父亲，如果不行，就让init做父进程。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[LINUX内核设计与实现]第二章","slug":"从内核出发","date":"2018-04-13T12:36:32.000Z","updated":"2018-05-16T10:02:54.000Z","comments":true,"path":"2018/04/13/从内核出发/","link":"","permalink":"https://github.com/zdkswd/2018/04/13/从内核出发/","excerpt":"","text":"从内核出发内核源码树内核源码树根目录描述 目录 描述 arch 特定体系结构的源码 block 块设备IO层 crypto 加密API Documentation 内核源码文档 drivers 设备驱动程序 firmware 使用某些驱动程序而需要的设备固件 fs VFS和各种文件系统 include 内核头文件 init 内核引导和初始化 ipc 进程间通信代码 kernel 像调度程序这样的核心子系统 lib 通用内核函数 mm 内存管理子系统和VM net 网络子系统 samples 实例，示范代码 scripts 编译内核所用的脚本 security Linux安全模块 sound 语音子系统 usr 早期用户空间代码（所谓的initramfs） tools 在Linux开发中有用的工具 virt 虚拟化基础结构 在源码根目录还有很多文件值得提及。COPYING文件是内核许可证（GNU GPL v2）。CREDITS是开发了很多内核代码的开发者列表。MAINTAINERS是维护者列表，负责维护内核子系统和驱动程序。Makefile是基本内核的Makefile。 编译内核配置内核在编译前可以把自己的需要的特定功能和驱动程序编译进内核，首先必须先配置，其以CONFIG_FEATURE形式表示。配置选项要么是二选一（yes/no）要么是三选一（yes/no/module）module表示这部分功能的实现代码是以模块的形式生成。驱动程序一般都是三选一选项。配置选项也可以是字符串或整数。这些选项并不控制编译过程，而只是指定内核源码可以访问的值，一般以预处理宏的形式表示。 $ make config 该工具会遍历所有配置项，但耗时过长 $make menuconfig$make gconfig 可破之。以上三种工具将所有配置分门别类的放置。 $make defconfig 创建默认配置。这些配置项被存放在根目录的.config文件中。在进行修改后，你应当验证和更新配置： $ make oldconfig 配置选项CONFIG_IKCONFIG_PROC把完整的压缩内核配置文件放在/proc/config.gz下，在编译新内核时可以克隆配置。 $zcat /proc/config.gz &gt; .config$make oldconfig 衍生多个编译作业make程序能把编译过程拆分成多个并行的作业。极大加快编译的过程。 $make -jn 安装新内核 %make modules_install 内核开发的特点 内核编程时既不能访问c库也不能访问标准c头文件。 内核编程时必须使用GNU C 内核编程时缺乏像用户空间那样的内存保护机制。 内核编程时难以执行浮点运算。 内核给每个进程只有一个很小的定长堆栈。 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。 要考虑可移植性的重要性。 无libc库或无标准头文件因为对内核来说，C库太大太低效了。但是大部分常用的C库函数在内核中都已经得到了实现。内核头文件位于根目录include目录下。&lt; linux/inotify.h&gt;对应内核include/linux/inotify.h体系结构相关的头文件位于源码树arch/&lt; architecture&gt;/include/asm目录下。内核代码通过如&lt; asm/youwant.h&gt;包含。 printk(“Hello world’%s’and ‘%d’”,str,i); 例如内核代码无法调用printf,但它提供printk()。其允许通过一个标志来设置优先级。 GNU Cgcc是多种GNU编译器的集合，它包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其他代码。 内联函数，用于时间要求高，本身长度短的函数。 定义内联函数时需要static 作为关键字，并且用inline限定它。为了类型安全和易读性，优先使用内联函数而不是复杂的宏。 内联汇编，gcc支持C函数嵌入汇编指令，需要知道其体系结构。使用asm()指令嵌入汇编代码。Linux内核混用了C语言和汇编语言。在偏近体系结构底层或对执行时间要求严格的地方，一般使用汇编语言，其他大部分代码是用C语言编写的。 分支声明，对于条件选择语句，gcc内建了优化指令，并封装成了宏。likely()和unlikely()，你的判断正确，性能会得到提升，如果判断错误，性能反而会下降。 没有内存保护机制在内核中不应该去做访问非法的内存地址，引用空指针一类的事，否则可能一声不响的死掉。内核的内存不分页。 不要轻易在内核中使用浮点数内核并不能完美地支持浮点操作，因为它本身不能陷入。在内核使用浮点数时，除了要人工保存和恢复浮点寄存器，还有一些其他的事情要处理。所以不要在内核中使用浮点操作。 容积小而固定的栈同步和并发可移植性的重要性大部分C代码应该与体系结构无关，在不同体系结构的计算机上都能够编译和执行。如保持字节序、64位对齐、不假定字长和页面长度等一系列准则都有助于移植性。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[LINUX内核设计与实现]第一章","slug":"LINUX内核设","date":"2018-04-13T11:45:41.000Z","updated":"2018-05-16T11:04:46.000Z","comments":true,"path":"2018/04/13/LINUX内核设/","link":"","permalink":"https://github.com/zdkswd/2018/04/13/LINUX内核设/","excerpt":"","text":"第一章主要是讲Linux的历史，而我的第一篇纸质书笔记主要是讲一下我的计划。纸质书做读书笔记的话，任务量会远远大于电子版的图书，所以我争取做到不引用原文，因为那样做任务量过于庞大，这就要求我必须以自己理解的方式概括，这样才能达到预期的效果。之后还会出的纸质书笔记预告：深入理解计算机系统 中英两版。深入理解安卓系统。所以说可以看出直到暑假的这一段时间，我的重点是放在c/c++以及操作系统上，之所以这样做是因为希望未来能够为Tensorflow等开源框架贡献自己的力量。希望大家可以共同学习，共同进步。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[猴子都能懂的Git入门]高级篇","slug":"猴子都能懂的Git入门-高级篇","date":"2018-04-08T03:09:55.000Z","updated":"2018-05-16T10:59:22.000Z","comments":true,"path":"2018/04/08/猴子都能懂的Git入门-高级篇/","link":"","permalink":"https://github.com/zdkswd/2018/04/08/猴子都能懂的Git入门-高级篇/","excerpt":"","text":"分支什么是分支分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。 master分支在数据库进行最初的提交后, Git会创建一个名为master的分支。因此之后的提交，在切换分支之前都会添加到master分支里。 分支的运用merge分支Merge分支是为了可以随时发布release而创建的分支，它还能作为Topic分支的源分支使用。保持分支稳定的状态是很重要的。如果要进行更改，通常先创建Topic分支，而针对该分支，可以使用Jenkins之类的CI工具进行自动化编译以及测试。 通常，大家会将master分支当作Merge分支使用。 Topic分支Topic分支是为了开发新功能或修复Bug等任务而建立的分支。若要同时进行多个的任务，请创建多个的Topic分支。 Topic分支是从稳定的Merge分支创建的。完成作业后，要把Topic分支合并回Merge分支。 分支的切换若要切换作业的分支，就要进行checkout操作。进行checkout时，git会从工作树还原向目标分支提交的修改内容。checkout之后的提交记录将被追加到目标分支 HEADHEAD指向的是现在使用中的分支的最后一次更新。通常默认指向master分支的最后一次更新。通过移动HEAD，就可以变更使用的分支。NOTE:提交时使用~(tilde)和^(caret)就可以指定某个提交的相对位置。最常用的就是相对于HEAD的位置。HEAD后面加上~(tilde）可以指定HEAD之前的提交记录。合并分支会有多个根节点，您可以用^(caret) 来指定使用哪个为根节点。 stashstash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。 分支的合并合并分支有2种方法：使用merge或rebase。使用这2种方法，合并后分支的历史记录会有很大的差别。 merge合并 bugfix分支到master分支时，如果master分支的状态没有被更改过,把master分支的位置移动到bugfix的最新分支上，Git 就会合并。这样的合并被称为fast-forward（快进）合并。HEAD还在原位。master分支的历史记录有可能在bugfix分支分叉出去后有新的更新。这种情况下，要把master分支的修改内容和bugfix分支的修改内容汇合起来。合并两个修改会生成一个提交。这时，master分支的HEAD会移动到该提交上。NOTE:执行合并时，如果设定了non fast-forward选项，即使在能够fast-forward合并的情况下也会生成新的提交并合并。 一个圆圈代表一个提交 rebasetopic分支和merge分支的运用实例分支操作示例建立分支 $ git branch &lt; branchname&gt; 不指定参数直接执行branch命令的话，可以显示分支列表。 前面有*的就是现在的分支。 $ git branch issue1 *master 切换分支执行checkout命令以退出分支。 $ git checkout &lt; branch&gt; NOTE:在checkout命令指定 -b选项执行，可以创建分支并进行切换。 $ git checkout -b &lt; branch&gt; 合并分支执行merge命令以合并分支。 $ git merge &lt; commit&gt; 该命令将指定分支导入到HEAD指定的分支。如当HEAD指向issue1时，先切换到master分支，然后把issue1分支导入到master分支。 $ git checkout master$ git merge issue1 删除分支在branch命令指定-d选项执行，以删除分支。 $ git branch -d &lt; branchname&gt; 用rebase合并切换到issue3分支后，对master执行rebase。 $ git checkout issue3$ git rebase master rebase的时候，修改冲突后的提交不是使用commit命令，而是执行rebase命令指定 –continue选项。若要取消rebase，指定 –abort选项。 $ git add myfile.txt$ git rebase –continue 这样，在master分支的issue3分支就可以fast-forward合并了。切换到master分支后执行合并.看来rebase是将issue3分支消失而生成一个新的提交，就像fast-forward的情形一样。切换到master分支后执行合并。 $ git checkout master$ git merge issue3 上图为rebase图 上图为merge图 Merge和rebase都是合并历史记录，但是各自的特征不同。 merge保持修改内容的历史记录，但是历史记录会很复杂。rebase历史记录简单，是在原有提交的基础上将差异内容反映进去。因此，可能导致原本的提交内容无法正常运行。您可以根据开发团队的需要分别使用merge和rebase。例如，想简化历史记录，在topic分支中更新merge分支的最新代码，请使用rebase。向merge分支导入topic分支的话，先使用rebase，再使用merge。 远端数据库pull首先确认更新的本地数据库分支没有任何的更改。这时只执行fast-forward合并。如果本地数据库的分支有新的历史记录，就需要合并双方的修改。执行pull就可以进行合并。这时，如果没有冲突的修改，就会自动创建合并提交。如果发生冲突的话，要先解决冲突，再手动提交。 fetch执行pull，远程数据库的内容就会自动合并。但是，有时只是想确认本地数据库的内容而不想合并。这种情况下，请使用fetch。执行fetch就可以取得远程数据库的最新历史记录。取得的提交会导入到没有名字的分支，这个分支可以从名为FETCH_HEAD的退出。就相当于在本地数据库建立了一个和远程数据库一样的分支，还没合并。合并后，历史记录会和pull相同。实际上pull的内容是fetch + merge组成的。 push从本地数据库push到远程数据库时，要fast-forward合并push的分支。如果发生冲突，push会被拒绝的。若要共享在本地数据库创建的分支，需要明确的push。因此，没有执行push就不会给远程数据库带来影响，因而可以自由的创建自己的分支。基本上，远程数据库共享的提交是不能修改的。如果修改的话，跟远程数据库同步的其他数据库的历史记录会变得很奇怪的。 标签标签是为了更方便地参考提交而给它标上易懂的名称。Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。轻标签：添加名称注解标签：添加名称 添加注解 添加签名一般情况下，发布标签是采用注解标签来添加注解或签名的。轻标签是为了在本地暂时使用或一次性使用。 使用标签 使用tag命令来添加标签，在&lt; tagname&gt;执行标签的名称。 $ git tag &lt; tagname&gt; 在HEAD指向的提交里添加名为apple的标签，请执行以下的命令。 $ git tag apple 如果没有使用参数而执行tag，可以显示标签列表。 $ git tag 如果在log命令添加 –decorate选项执行，可以显示包含标签资料的历史记录。 $ git log –decorate 添加注解标签若要添加注解标签，可以在tag命令指定 -a选项执行,以指定-m选项来添加注解。 $ git tag -a &lt; tagname&gt; $ git tag -am “连猴子都懂的Git” banana 如果在tag命令指定-n选项执行，可以显示标签的列表和注解。 $ git tag -n 删除标签若要删除标签，在tag命令指定 -d选项执行。 $ git tag -d &lt; tagname&gt; 改写提交修改最近的提交指定amend选项执行提交的话，可以修改同一个分支最近的提交内容和注解。 主要使用的场合：添加最近提交时漏掉的档案修改最近提交的注解 取消过去的提交在revert可以取消指定的提交内容。使用后面要提到的rebase -i或reset也可以删除提交。但是，不能随便删除已经发布的提交，这时需要通过revert创建要否定的提交。 主要使用的场合：安全地取消过去发布的提交 遗弃提交在reset可以遗弃不再使用的提交。执行遗弃时，需要根据影响的范围而指定不同的模式，可以指定是否复原索引或工作树的内容。除了默认的mixed模式，还有soft和hard模式。欲了解受各模式影响的部分，请参照下面的表格。 模式名称 HEAD的位置 索引 工作树 soft 修改 不修改 不修改 mixed 修改 修改 不修改 hard 修改 修改 修改 主要使用的场合： 复原修改过的索引的状态(mixed)彻底取消最近的提交(hard)只取消提交(soft) 提取提交在cherry-pick，您可以从其他分支复制指定的提交，然后导入到现在的分支。 主要使用的场合： 把弄错分支的提交移动到正确的地方把其他分支的提交添加到现在的分支 改写提交历史记录在rebase指定i选项，您可以改写、替换、删除或合并提交。 主要使用的场合： 在push之前，重新输入正确的提交注解清楚地汇合内容含义相同的提交。添加最近提交时漏掉的档案 汇合分支上的提交，然后一同合并到分支merge的特殊选项：squash用这个选项指定分支的合并，就可以把所有汇合的提交添加到分支上。 主要使用的场合： 汇合主题分支的提交，然后合并提交到目标分支。 改写提交训练commit –amend git commit –amend revert $ git revert HEAD 在git log中会出现–Revert “添加pull的说明” reset $ git reset –hard HEAD~~ 在git中，我们其实可以通过^和~来定位某个具体的commit，而不用每次都去敲繁琐的hash值。“^”代表父提交,当一个提交有多个父提交时，可以通过在”^”后面跟上一个数字，表示第几个父提交，”^”相当于”^1”.~&lt; n&gt;相当于连续的&lt; n&gt;个”^”.在reset之前的提交可以参照ORIG_HEAD。Reset错误的时候，在ORIG_HEAD上reset 就可以还原到reset前的状态。 $ git reset –hard ORIG_HEAD cherry-pick $ git checkout master$ git cherry-pick 99daed2 如果发生冲突，修改冲突的部分之后再提交。 用rebase -i 汇合提交若要汇合过去的提交，请用rebase -i。 $ git rebase -i HEAD~~ 两个提交就合并成一个提交了。 用rebase -i 修改提交merge –squash","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"Git","slug":"Git","permalink":"https://github.com/zdkswd/tags/Git/"}]},{"title":"[猴子都能懂的Git入门]入门篇","slug":"猴子都能懂的Git入门-入门篇","date":"2018-04-06T02:03:47.000Z","updated":"2018-05-16T10:59:40.000Z","comments":true,"path":"2018/04/06/猴子都能懂的Git入门-入门篇/","link":"","permalink":"https://github.com/zdkswd/2018/04/06/猴子都能懂的Git入门-入门篇/","excerpt":"","text":"前言不知道这是第几次学习Git了，每次都是学完过一段就忘了，这次决定自己写出点东西，深入的再把Git再过一遍。写一下自己的东西，真真正正的把Git转化为自己的东西。这次选用的资料是猴子都能懂的Git入门。之所以选用该资料是因为语言比较通俗易懂，而我也正好想把知识总结的通俗易懂一些，算是两重学习。那么话不多说，现在开始吧~~~(写到后面发现这书已经足够通俗，很难再。。。啊，失败。) Git的基础首先git是版本控制工具，用来解决大家对同一文件操作时的协作问题。Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。 管理历史数据的数据库数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。 远程数据库和本地数据库。Git的数据库分为远程数据库和本地数据库的两种。 创建数据库创建本地数据库的方法有两种：一种是创建全新的数据库，另一种是复制远程数据库。 修改记录的提交若要把文件或目录的添加和变更保存到数据库，就需要进行提交。执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也被称为revision）。Tips:不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。执行提交时，系统会要求输入提交信息。请务必输入提交信息，因为在空白的状态下执行提交会失败的。Tips:查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。以下是Git的标准注解： 第1行：提交修改内容的摘要第2行：空行第3行以后：修改的理由 请以这种格式填写提交信息。 工作树和索引在Git管理下，大家实际操作的目录被称为工作树。 在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。 Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。 凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。 教程1 Git基础Git安装略 初期设定安装Git之后，请输入您的用户名和电子邮件地址。该设置操作在安装Git后进行一次就够了。这些信息将作为提交者信息显示在更新历史中。 Git的设定被存放在用户本地目录的.gitconfig档案里。可以直接编辑配置文件。 $ git config –global user.name “&lt;用户名&gt;”$ git config –global user.email “&lt;电子邮件&gt;” $ git config –global color.ui auto //git彩色显示 可以为Git命令设定别名。例如：把「checkout」缩略为「co」，然后就使用「co」来执行命令。 $ git config –global alias.co checkout 如果在Windows使用命令行 (Git Bash), 含非ASCII字符的文件名会显示为 “\\346\\226\\260\\350\\246…”。若设定如下，就可以让含非ASCII字符的文件名正确显示了。 $ git config –global core.quotepath off 若在Windows使用命令行，您只能输入ASCII字符。所以，如果您的提交信息包含非ASCII字符，请不要使用-m选项，而要用外部编辑器输入。 外部编辑器必须能与字符编码UTF-8和换行码LF兼容。 git config –global core.editor “\\”[使用编辑区的路径]\\”” 新建数据库在目录下使用init命令将该目录移动到本地的Git数据库。 $ git init 提交文件对于一个文件，使用status命令确认工作树和索引的状态。 $ git status 将文件加入到索引，要使用add命令。在&lt; file&gt;指定加入索引的文件。用空格分割可以指定多个文件。 $ git add &lt; file&gt;..$ git add . //将所有的文件加入索引 已加入到索引，我们就可以提交文件了。 $ git commit -m “” 使用log命令，我们可以在数据库的提交记录看到新的提交。 $ git log commit ac56e474afbbe1eab9ebce5b3ab48ac4c73ad60eAuthor: eguchi &#101;&#103;&#x75;&#x63;&#x68;&#105;&#64;&#x6e;&#117;&#x6c;&#97;&#x62;&#46;&#x63;&#x6f;&#x2e;&#x6a;&#x70;Date: Thu Jul 12 18:00:21 2012 +0900first commit 安装git的同时会安装名为gitk的工具。使用这个工具，可以在GUI下确认提交记录。 $ gitk 共享数据库push到远端数据库注意：对于别人的项目你只能 pull 不能 push，只有你自己（或有权限）的项目才能 push。或者说只有你把 ssk key 添加到账号里才能无密码 push。如果你想参与别人的开源项目，先建立自己的 github 账号，然后 fork 那个项目到自己的账号里，然后在自己的项目里修改，然后发出 pull request，然后看对方愿不愿意接受你的提交。 作者：Intopass链接：https://www.zhihu.com/question/29894004/answer/45956664来源：知乎 推送为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。所以远程数据库的修改记录就会和本地数据库的修改记录保持同步。 克隆远程数据库克隆执行克隆后，远程数据库的全部内容都会被下载。之后您在另一台机器的本地数据库上进行操作。克隆后的本地数据库的变更履历也会被复制，所以可以像原始的数据库一样进行查看记录或其他操作。 从远程服务器Pull若是共享的远程数据库由多人同时作业，那么作业完毕后所有人都要把修改推送到远程数据库。然后，自己的本地数据库也需要更新其他人推送的变更内容。 Pull进行拉取(Pull) 操作，就是从远程数据库下载最近的变更日志，并覆盖自己本地数据库的相关内容。 clone与pull的区别clone是本地没有repository时，将远程repository整个下载过来。 pull是本地有repository时，将远程repository里新的commit数据(如有的话)下载过来，并且与本地代码merge。 对远程服务器进行操作向远程数据库推送本地数据库的修改记录远程数据库命名为“origin”。 请使用remote指令添加远程数据库。在&lt; name&gt;处输入远程数据库名称，在&lt; url&gt;处指定远程数据库的URL。 $ git remote add &lt; name&gt; &lt; url&gt; TIPS:执行推送或者拉取的时候，如果省略了远程数据库的名称，则默认使用名为”origin“的远程数据库。因此一般都会把远程数据库命名为origin。 使用push命令向数据库推送更改内容。&lt; repository&gt;处输入目标地址，&lt; refspec&gt;处指定推送的分支。 $ git push &lt; repository&gt; &lt; refspec&gt;… 当执行命令时，如果您指定了-u选项，那么下一次推送时就可以省略分支名称了。但是，首次运行指令向空的远程数据库推送时，必须指定远程数据库名称和分支名称。 $ git push -u origin master 使用clone指令可以复制数据库，在&lt; repository&gt;指定远程数据库的URL，在&lt; directory&gt;指定新目录的名称。 $ git clone &lt; repository&gt; &lt; directory&gt;$ git clone https://nulab.backlog.jp/git/BLG/tutorial.git tutorial2 当在克隆的数据库目录执行推送时，您可以省略数据库和分支名称。 $ git push 使用pull指令进行拉取操作。省略数据库名称的话，会在名为origin的数据库进行pull。 $ git pull &lt; repository&gt; &lt; refspec&gt;…$ git pull origin master 合并修改记录合并在执行pull之后，进行下一次push之前，如果其他人进行了推送内容到远程数据库的话，那么你的push将被拒绝。这种情况下，在读取别人push的变更并进行合并操作之前，你的push都将被拒绝。这是因为，如果不进行合并就试图覆盖已有的变更记录的话，其他人push的变更（图中的提交C）就会丢失。 合并的时候，Git会自动合并已有的变更点！不过，也存在不能自动合并的情况。此时需要手动合并。 解决冲突如果远程数据库和本地数据库的同一个地方都发生了修改的情况下，因为无法自动判断要选用哪一个修改，所以就会发生冲突。Git会在发生冲突的地方修改文件的内容 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;这就是发生 》 =======冲突的地方 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ==分割线上方是本地数据库的内容,下方是远程数据库的编辑内容。需要手动的修改。 整合修改记录操作为了把变更内容推送到远程数据库，我们必须手动解决冲突。 $ git pull origin master 导入两方的修改，并删除多余的标示行以解决冲突 Github多人协作的三种方式 Fork 方式pull request是一个request，它的目的是让别人pull你的东西。 组织组织的所有者可以针对不同的代码仓库建立不同访问权限的团队。 合作者代码仓库的所有者可以为单个仓库增加具备只读或者读写权限的协作者。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"Git","slug":"Git","permalink":"https://github.com/zdkswd/tags/Git/"}]},{"title":"新增评论区功能","slug":"新增评论区功能","date":"2018-04-05T09:49:48.000Z","updated":"2018-05-16T11:02:14.000Z","comments":true,"path":"2018/04/05/新增评论区功能/","link":"","permalink":"https://github.com/zdkswd/2018/04/05/新增评论区功能/","excerpt":"","text":"今天算是折腾了一下评论区，不得不佩服评论区作者的脑洞。运用github issues的机制来自己创建评论区，运用插件—传送门。 在此过程中也算踩了一些坑，特别感谢有人能无私分享自己的踩坑经历–踩坑教程 我自己也顺便试着改了下模板的源码，感觉有、收获。 分享出去，如果可以帮助到更多的人，那将将是更大的快乐。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://github.com/zdkswd/tags/个人博客/"},{"name":"Gitment","slug":"Gitment","permalink":"https://github.com/zdkswd/tags/Gitment/"}]},{"title":"Hexo+ github Pages建立个人博客","slug":"Hexo+github-Pages建立个人博客","date":"2018-04-04T09:30:56.000Z","updated":"2018-05-16T11:03:32.000Z","comments":true,"path":"2018/04/04/Hexo+github-Pages建立个人博客/","link":"","permalink":"https://github.com/zdkswd/2018/04/04/Hexo+github-Pages建立个人博客/","excerpt":"","text":"折腾了一段时间，还算顺利的把博客给建立好了，以下是参考链接建立过程这个过程大体上是没有问题的，但是我碰到几个小小的问题，大家也可以参考一下 当打开配置文件时，文中说的是用记事本打开，但是我用记事本打开文本完全没有格式，再用写字板打开时，豁然开朗。 再一个就是当上传以后访问自己的首页时,输入https://zdkswd.github.io 死活打不开，我又检查了好几遍，后来直接输入zdkswd.github.io就成功进去了，之后再输入https://zdkswd.github.io 又可以愉快的访问了，感觉特别神奇，也感觉很费解。 第一篇博客就先到这里吧，这一段时间我会上传一些读书笔记，毕竟砖头书不好啃，这既是分享，又是进一步的学习，也是对我自己的一种激励。希望这个博客真正能起到学习，练习，积累，分享的作用。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://github.com/zdkswd/tags/个人博客/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/zdkswd/tags/Hexo/"}]}]}