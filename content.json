{"meta":{"title":"ZDK's blog","subtitle":null,"description":null,"author":"ZDK","url":"https://github.com/zdkswd"},"pages":[{"title":"categories","date":"2018-05-16T08:57:06.000Z","updated":"2018-05-16T08:58:10.000Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/zdkswd/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-16T07:23:52.000Z","updated":"2018-05-16T08:58:32.000Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/zdkswd/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"松本行弘的程序世界 2 面向对象","slug":"松本行弘的程序世界 2 面向对象","date":"2018-07-05T14:14:32.000Z","updated":"2018-07-06T02:09:57.000Z","comments":true,"path":"2018/07/05/松本行弘的程序世界 2 面向对象/","link":"","permalink":"https://github.com/zdkswd/2018/07/05/松本行弘的程序世界 2 面向对象/","excerpt":"","text":"松本行弘的程序世界 2 面向对象编程和面向对象的关系计算机只会高速运算，到底是最大程度地发挥计算机的能力还是扼杀它的能力都取决于我们编写的程序。 颠倒的构造程序员要夺得主动权。 主宰计算机的武器为了能够主宰计算机，必须以计算机的特性和编程语言作为武器。 怎样写程序编程风格 算法 数据结构 设计模式 开发方法 面向对象的编程方法smalltalk为面向对象编程语言之母。 面向对象的难点面向对象编程语言中最重要的技术是“多态性”。 多态性多态就是可以把不同种类的东西当做相同的东西处理。操作对象是三个箱子，分别是盖着盖子的箱子、加了锁的箱子、系着彩带的箱子。在编程中，“打开箱子”的命令，称之为消息；打开不同箱子的具体操作，称之为方法。 具体的程序调用box_open这个方法，根据参数（箱子的种类）的不同做相应的处理。 屏幕快照 2018-07-04 上午8.11.02 但是如果增加种类代码就要重写，修改的地方越来越多，追加箱子的种类就会变得非常困难。修改程序，实现真正的多态。“.”可以理解为“给前面的式子的值发送一个open消息”。 屏幕快照 2018-07-04 上午8.14.46 多态性的优点首先，各种数据可以统一地处理。关注要处理什么，而不是怎么处理。其次，根据对象选择方法，程序内部不会冲突。减轻程序员的负担。再次，新数据简单的追加可以实现，不需要改动以前程序，具备了扩展性。 数据抽象和继承面向对象编程的三原则：多态性，数据抽象，继承。别称：多态性：动态绑定，数据抽象：信息隐藏或封装。 面向对象的历史simula的“发明”面向对象编程思想起源于瑞典20世纪60年代后期发展起来的模拟编程语言Simula。以前，表示模拟对象的数据和实际的模拟方法是互相独立的，需要分别管理。 Smalltalk的发展smalltalke的开发宗旨是“让儿童也可以使用”，吸收了Simula的面向对象思想，且独居一格。不仅如此，还有一个很好的图形用户界面。使得世人开始了解面向对象编程的概念。 Lisp的发展许多重要的面向对象的概念都是从Lisp的面向对象功能中诞生的。 和c语言的相遇C++是直接受到了simula语言的影响而没有受到smalltalk多大影响。 Java的诞生java语言放弃了和C语言的兼容性，并增加了Lisp语言中一些好的功能。此外，通过Java虚拟机（JVM），java程序可以不用重新编译而在所有操作系统中运行。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 复杂性是面向对象的敌人软件开发的最大敌人是复杂性。人类的大脑无法做台复杂得处理，记忆力和理解力也是有限的。在计算机性能这么高的今天，人们为了找到迅速开发大规模复杂软件的方法，哪怕牺牲一些性能也在所不辞。 结构化编程如果不考虑黑盒内部的处理，系统复杂性就可以降低到人类的可控范围内。针对程序控制流的复杂问题，结构化编程采用看限制和抽象化的武器解决问题。 数据抽象化数据抽象是数据和处理方法结合。对数据内容的处理和操作，必须通过实先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。比如说栈。有了数据抽象，程序处理的数据就不再是单纯的数值或者文字这些概念性的东西，而变成了人脑容易想象的具体事物。而代码的“抽象化”则是把想象的过程“具体化”了。 雏形同样的对象大量存在时，为避免重复，可以采用两种方法管理对象。 原型。用原始对象的副本来作为新的相同的对象，JS用的原型。 模板，称为类。跟原型不同，面向对象编程语言的类和对象有明显区别。对象又称作实例。找出相似的部分来继承类的增多会用到很多性质相似的类。这就违背了我们的DRY（Don’t Repeat Yourself）原则。把这些相似的部分汇总到一起就好了。继承就是这种方法。子类继承父类所有方法，如有需要可以增加新的方法，也可以重写父类方法。Ruby跟多数编程语言一样，一个子类只能有一个父类，即单一继承，C++、Lisp等编程语言中，一个子类可以有多个父类，这称为“多重继承”。多重继承的缺点继承的原本目的实际上是逐步细化。所以为解决抽出类中相似部分的问题并不完全准确。为什么需要多继承一个程序员也可能是一个作家。多重继承和单一继承不可分离单一继承的特点： 继承关系单纯，有利有弊多重继承的特点： 很自然的做到了单一继承的扩展。 可以继承多个类的功能。单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系变得复杂。这是多重继承的一个缺点。goto语句和多重继承比较相似多重继承导致的问题： 结构复杂化 优先顺序模糊 功能冲突解决多重继承的问题继承作为抽象化的手段，是需要实现多重继承功能的，如果一个类只允许抽出一个功能，那么限制就太多了。受限制的多重继承，这个解决或改善多重继承问题的方法出现了，它在Java中被称为接口（interface）,在Lisp或Ruby中是Mix-in。静态语言与动态语言的区别编程语言可以分为静态语言和动态语言两种。像Java这样规定变量和算式类型的语言称为静态语言。在静态语言中，不能给变量赋不同类型的值，会导致编译错误，不通过执行就可以发现类型不匹配是静态语言的一个优点。如果只能给一个变量赋值同类对象，就不可能根据对象的类自动选择合适的处理方式（多态性）。静态语言的特点当给一个类变量赋值时，既可以用这个类的对象来赋值，也可以用这个类的子类对象来赋值。这样就可以实现多态性。但是这时，如果定义了父类变量，赋值子类对象，变量不能调用子类特有的方法。动态语言的特点动态语言允许调用没有继承关系的方法。静态语言中只能调用有继承关系的方法，数组、哈希表和字符串都能调用的方法，只能是在它们共同的父类（恐怕是Object）中定义。在静态语言中，如果要调用类层次中平行类的方法，那么必须要有一个可以表现这些对象的类型。如果没有这个类型，可调用的方法是十分有限的。由此我们看到静态语言中某种形式的多重继承是不可少的。静态语言与动态语言的比较静态语言即使不通过执行也可以检查出类型是否匹配。但是逐个来定义算式和变量的类型又会使程序变得冗长。只有包含继承关系的类才会具有多态性。对于动态语言来说，静态语言显得限制过多，灵活性差。程序中有没有错误只有执行了才会知道。程序中没有类型定义，这样程序会变得很简洁。只要方法名一样，这些对象可以以相同的方式去处理。这样生产效率会大大提高，这种宽松的编程机制称为Duck Typing（鸭子类型检测）继承的两种含义继承包括两种含义，一种是“类都有哪些方法”，也就是说这个类都支持些什么操作，即规格的继承。另一种是“类中都用了什么数据结构什么算法”，也就是实现的继承。静态语言中这两者的区别很重要，动态语言中区别规格的继承和实现的继承意义不大。即使没有继承关系，方法也可以自由地调用。java对两者有很明确的区分，实现的继承用extends来继承父类，规格的继承用implements来指定接口。类是用来指定对象实现的，而接口只是指定对象的外观（都有哪些方法）。类的继承是单一的，implements可以指定多个接口。接口对实现没有任何限制，也就是说，接口可以由跟实现的继承没有任何关系的类来实现。接口的缺点为了解决多重继承的问题，人们允许了规格的多重继承，但是还是不允许实现多重继承。继承实现的方法和静态语言Java不同，动态语言本来就没有继承规格这种概念。动态语言需要解决的就是实现的多重继承。Lisp、Perl和Python都提供了多重继承功能，这样就不存在单一继承的问题了。从多重继承变形而来的Mix-inMix-in是降低多重继承复杂性的一个技术，最初是在Lisp中开始使用的。按以下规则来限制多重继承： 通常的继承用单一继承 第二个以及两个以上的父类必须是Mix-in的抽象类。Mix-in类是具有以下特征的抽象类。 不能单独生成实例 不能继承普通类积极支持Mix-in的Ruby 屏幕快照 2018-07-04 下午5.39.58 12345678我理解的接口的作用：接口是一种协议，满足同一接口实际上是告诉计算机你们是满足了同一样协议，你们是有关系的，java以这种方式间接实现了多态。当然可以实现多个接口，抽象为不同的“种类”，这样就相当于某种意义上的”多继承“。InterA a; a= new B(); a.fun(); a = new C(); a.fun(); bc都实现a的接口 两个误解 对象是对现实世界中具体物体的反应，继承是对物体分类的反应。（误） 多重继承是不好的。Mix-in不错。（误） 澄清：如果多继承用的不好就会出问题，Mix-in只不过是实现多重继承的一个技巧而已。 面向对象的编程不管过去怎样，现在面向对象最好的理解是，面向对象编程是结构化编程的延伸。随着软件的复杂化，开发越来越复杂，Dijkstra提倡把程序控制限制为（1）顺序（2）循环（3）分支 使得程序变得简单且容易理解。面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上对数据的结构化。面向对象编程，封装（黑盒）和多态（减少分支处理）是提高生产率的技术。结构化编程通过整理数据流，提高程序的生成效率和可维护性。同样，面向对象编程通过对数据结构的整理，提高了程序的生产效率和可维护性。 对象的模板=类类是吧数据黑盒化的工具，由于对类内部的操作都是通过类的方法来实现的，所以内部数据结构即使在以后发生变化，对外部也没有影响。 利用模板的手段=继承类是模块，继承就是利用模块的方法。传统的面向对象编程语言是一下子把规格和实现都继承下来，在最近，有的是把这两种继承分开了。比如java里的接口就是规格继承。 多重继承不好吗单一继承的类之间的关系是很单纯的树结构。但是对于多重继承而言，类之间的关系却是复杂得网状结构。静态语言中可以实现多态性只是局限于拥有共通父类的对象。为了解决这个问题，静态面向对象编程语言的代表C++支持多重继承。java也可以通过接口来支持规格的多重继承。1234**静态类型语言**: 是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型，某些具有类型推导能力的现代语言可能能够部分减轻这个要求. **动态类型语言**: 是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 **强类型语言**: 是一旦变量的类型被确定，就不能转化的语言。实际上所谓的貌似转化，都是通过中间变量来达到，原本的变量的类型肯定是没有变化的。 **弱类型语言**: 则反之，一个变量的类型是由其应用上下文确定的。比如语言直接支持字符串和整数可以直接用 + 号搞定。当然，在支持运算符重载的强类型语言中也能通过外部实现的方式在形式上做到这一点，不过这个是完全不一样的内涵 动态编程语言也需要多重继承动态编程语言没有类型检查，从这方面来说没有理由用多重继承，但是动态编程语言肯定需要多重继承。实现共享可以通过多个对象的组合（composition）和委托（delegate）来做到。 驯服多重继承的方法多重继承可能引发的问题： 类关系复杂化 继承功能名字重复最初的问题是因为类关系从简单的树结构变成了复杂的网状结构。 屏幕快照 2018-07-05 上午9.18.30 父类的优先级并不明确，多重继承设计的一个有效的技巧是Mix-in。用Mix-in做多继承设计时，从第2个父类开始的类要满足以下条件。 不能单独生成实例的抽象类。 不能继承Mix-in以外的类。 抽象类和接口的对比 屏幕快照 2018-07-05 上午10.41.50 mix-in的例子 屏幕快照 2018-07-05 上午10.44.57 通过对功能的分离，多重继承就可以由单一继承加上Mix-in类来实现。利用Mix-in就可以同时享有单一继承的单纯性和多重继承的共有性。 对于名字重复问题（如函数名），多重继承编程语言都有自己的应对方法，大致分为以下3种： 给父类定义优先级 把重复的名字替换掉 指定使用类的名字ruby中多重继承的实现方法Mix-injava实现多重继承的方法接口。。Duck Typing诞生之前静态是指程序执行之前，从代码中就可以知道一切。程序静态的部分包括变量、方法的名称和类型以及控制程序的结构等等。相对于静态，动态是指在程序执行之前有些地方是不知道的。程序动态的部分包括变量的值、执行时间和使用的内存等等。通常情况下、程序本来就是不被执行就不知道结果的，所以在一定程度上说程序都具有动态特性。因此，严格说静态和动态之间的界限是很微妙的。为什么需要类型动态的类型是从Lisp中诞生的动态类型在面向对象中发展起来了对象保存着有关自己种类的信息，某个变量可以用各种类型的数据来赋值，这两点是多态这一面向对象重要特性的必要条件。动态类型和静态类型的邂逅20世纪80年代，面向对象编程语言主流是包含动态数据类型的语言，但是在21世纪的今天，使用最广泛的面向对象编程语言是具有静态类型的java和c++。受simula很大影响的c++引入了子类对象可以看成是父类对象这个原则，对象也采用了静态类型。根据这个原则，在编译时就可以知道变量或算式的类型，又可以根据执行时的数据类型自动选择合适的处理，从而同时具备了静态类型的优点和动态类型的多态性。静态类型的优点 最大的优点是在编译时能够发现不匹配的错误。 如果明确指定了数据类型，在编译时可以用到的信息就很多，利用这种信息可以在编译时对程序做优化，提高程序执行速度。 在读程序时提高理解度，IDE也可以自动补充。 问题： 不指定类型就写不了程序，数据类型只是一些辅助信息，并不是程序本质。有的类型声明仅仅是为了满足编译器的要求。程序规模也因为数据类型的定义而变大。 灵活性问题。静态类型本身限制了给某个变量只能赋值某种类型的对象，这种限制可能成为妨碍将来变化的枷锁。 动态类型的优点 源代码简洁，提高生产力。 会不会更难以理解，更突出程序处理的实质，程序函数相差几十倍并不少见，理解起来反而简单。 会不会运行更缓慢，同样的处理，在大多数情况下，静态类型编程语言运行得要快些。这是因为动态类型程序执行时要做类型检查。另外，静态类型的编程语言大都是通过编译把程序源代码转换成可以直接执行的形式，而动态类型的编程语言大多是边解释源代码（转换成内部形式）边执行，这种编译型处理和解释型处理的区别也是影响程序执行速度的愿意之一。 灵活，灵活性的关键是Duck Typing。 最大的缺点是不执行就检测不出错误。 只关心行为的Duck TypingIf it walks like a duck and quacks like a duck,it must be a duck.（走起路来像鸭子，叫起来也像鸭子，那么他就是鸭子）。根本不考虑一个对象属于什么类，只关心它有什么样的行为（它有哪些方法）。动态语言用Duck Typing的概念设计时需要遵循的原则最低限度是避免明确的类型检查。 避免明确的类型检查克服动态类型的缺点 执行时才能发现可以用完备的单元测试来解决，如果能严格实行完备的单元测试的话，即使没有编译时的错误检查，程序的可靠性也不会降低。 读程序时可用到的线索少这一点可以通过完整的文档来解决。可以在源代码中同时写文档，减轻维护文档的负担。 运行速度慢，随着计算机性能的提升已经不再重要，现在的程序开发中，程序的灵活性和生产力更为重要。 动态编程语言现在我们对程序开发生产力的要求越来越高，也就是说，要在更短的时间内开发出更多的功能。尽快着手开发，快速应对需求变更的开发方式变得越来越重要。在这种快速开发模式中，Duck Typing所代表的执行时的灵活性就非常有用。Ruby、Python、Perl和PHP等优秀的动态类型编程语言，因为它们在执行时所具有的灵活性而越来越受到人们的关注。 元编程元编程是对程序进行编程的意思。 元编程利用元编程可以动态生成类的方法，而且重要的是你可以自己编写生成过程，不支持元编程的编程语言实现这样的功能是很麻烦的，要么需要扩展语言的语法，要么用宏定义等预处理方法来实现。 反射元编程的反射（reflection）,在编程语言中它是指在程序执行时取出程序的信息或者改变程序的信息。Ruby彻底实现了对程序的动态操作。 屏幕快照 2018-07-05 下午7.10.21 元编程的例子Ruby使用Delegator这个库实现了委托功能，调用对象d的方法时可以转变为调用a的方法。我们还可以给这个对象增加特意方法来改变它的部分行为，这就大大扩展了它的应用范围。 使用反射功能分布式Ruby的实现Delegator将被调用的方法直接委派到其他对象，这一功能在很多领域都有应用。如dRuby。dRuby是通过网络来调用方法的库。dRuby可以生成服务器上存在的远程对象（Proxy），Proxy的方法调用可以通过网络执行。调用的方法在服务器上的远程对象中执行，执行结果可以通过网络返回。这和java的RMI(Remote Method Invocation)功能比较相似。但是，利用Ruby的元编程功能，不用明确定义接口，也可以通过网络调用任一对象的方法。C++和Java的远程调用是用IDL（Interface Definition Language）等语言来定义接口的，自动生成的存根（stub）必须编译和连接。和这些相比，Ruby的元编程更简单。 数据库的应用在数据库领域，元编程也很有用。web应用程序框架Ruby on Rails(也称为Rails或RoR)中也应用了元编程。具体地说是在与数据库关联的类库（ActiveRecord）中，利用元编程简单的把数据记录定义为对象。由于元编程功能让我们可以获取类名，在执行时增加方法。元编程的功能使得Rails被称赞为生产效率高的Web应用程序框架。 输出xml手工写XML是很麻烦的，利用Ruby块功能则可以很方便的处理。 元编程和小编程语言元编程功能可以运用到DSL领域，DSL是针对特定领域强化了功能的小规模编程语言。通过DSL用户可以强化应用程序的功能或者定制一些功能。 声明的实现Ruby的方法可以读取或改变程序自身的状态，利用普通的方法调用，可以实现其他编程语言中声明所完成的工作。 上下文相关的实现instance_eval方法接受块作为参数，把调用对象置换成self来执行块。 单位的实现词汇的实现针对特定领域，如果用Ruby来定义需要的类和方法，那么就可以认为Ruby是这个领域的专用语言。这些类和方法可以称为这个领域的词汇。 层次数据的实现适合DSL的语言，不适合DSL的语言Ruby是非常适合DSL的语言。首先定义好DSL用的小语言，然后编译成C++、java等目标语言。编译器经常用到Ruby这种具有优秀文本处理的语言。另一种实现DSL方法的例子是解释器。比如开发应用程序时从设计到实现是很复杂的，可以利用固定的语法和类库函数来读取程序。具体方法是用XML、DOM等XML处理类库来解释小语言语法。这是Java应用程序的配置文件曹勇XML的原因之一。通过XML文件，不用每次编译Java程序就可以改变配置，定制程序的行为。这种用法可以把XML称为Java界的DSL，或是Java应用程序的脚本语言。12脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是--解释运行--而非编译。虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"周海宏音乐鉴赏 一 打开你的耳朵","slug":"周海宏音乐鉴赏 一 打开你的耳朵","date":"2018-07-04T14:28:13.000Z","updated":"2018-07-04T14:28:47.000Z","comments":true,"path":"2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/周海宏音乐鉴赏 一 打开你的耳朵/","excerpt":"","text":"周海宏音乐鉴赏 一 打开你的耳朵1.1音乐鉴赏的误区音乐中包含各种内容的表现，说不出来是什么是因为你“听不懂”.专业学生也”听不懂“。音乐两个基本属性1 没有视觉性2 没有语义性“听不懂”–说不出音乐表现的是什么并非听者欣赏水平差，因为音乐不能直接传达视觉性与语义性的内容。 在音乐的欣赏中-不一定非要听出明确的视觉性、语义性内容。-不一定非要用文学化、美术化的内容去解说音乐。 在音乐中追求明确的概念性、视觉性内容，用文学化与美术化的方式欣赏音乐是一个误区。 音乐何须“懂”。 1.2音乐的艺术本质音乐是动态的。音乐是情绪的艺术。1 纯听觉感受2 情绪的感受动态纪实细腻地描摹内心的感受。 1.3 音乐审美的基本概念幸福人生最重要的是丰富多彩，真正的欣赏音乐，就去听最伟大的音乐。世界是这么龌龊这么黑暗，可悲的不是世界这么龌龊这么黑暗，而是不知道世界还有光明。音乐是人类精神的避难所。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"音乐鉴赏","slug":"音乐鉴赏","permalink":"https://github.com/zdkswd/tags/音乐鉴赏/"}]},{"title":"松本行弘的程序世界1 我为什么开发Ruby","slug":"松本行弘的程序世界1 我为什么开发Ruby","date":"2018-07-04T10:38:32.000Z","updated":"2018-07-04T10:38:47.000Z","comments":true,"path":"2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/松本行弘的程序世界1 我为什么开发Ruby/","excerpt":"","text":"松本行弘的程序世界1 我为什么开发Ruby编程语言的重要性程序员由于使用的编程语言不同，思考方法和编写出的代码都会受到很大的影响。 Ruby的原则 简洁性 扩展性 稳定性简洁性随着编程语言的演进，程序员已经可以更简单、更抽象地编程了。面向对象的方法没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序运行开销。现在由于计算机性能大大提高，只要可以提高软件的开发效率，浪费一些计算机资源也无所谓了。ruby的目标是成为开发效率高、能直接运行的伪码式编程语言。省去了不必要的声明。扩展性Ruby看重的不是明哲保身，而是如何最大限度的发挥程序员自身的能力。编程的历史就是因为想当然而失败的历史，ruby对整数范围不做任何限定，尽最大努力排除“想当然”。稳定性虽然ruby非常重视扩展性，但明知道LISP风格的宏能带来巨大的扩展性，仍没有使用。一切皆因兴趣","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"松本行弘的程序世界0 说在前面","slug":"松本行弘的程序世界0 说在前面","date":"2018-07-04T10:35:32.000Z","updated":"2018-07-04T10:36:06.000Z","comments":true,"path":"2018/07/04/松本行弘的程序世界0 说在前面/","link":"","permalink":"https://github.com/zdkswd/2018/07/04/松本行弘的程序世界0 说在前面/","excerpt":"","text":"松本行弘的程序世界0 说在前面vczh如何设计一门语言（一）好的语言，除了库写起来又容易又好用以外，还有两个重要的特点：容易学，容易分析。关于容易学这一点，其实不是说，你随便看一看就能学会，而是说，只要你掌握了门道，很多未知的特性你都可以猜中。这就有一个语法的一致性问题在里面了。 前言ruby code for fun这本书是松本行弘从一个编程语言设计者的角度去看待各种各样的流行编程语言，分析它们有哪些特点以及ruby编程语言如何进行取舍。ruby本身大量参考了一个更古老而著名的面向对象编程方法的开山鼻祖smalltalk以及偷师函数式编程语言鼻祖LISP。程序员社区有种说法：任何现代编程语言都脱胎于smalltalk于LISP。看看Ruby设计师是怎么设计Ruby语言的，则可以高屋建瓴的理解一些主流的编程语言。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"程序语言","slug":"程序语言","permalink":"https://github.com/zdkswd/tags/程序语言/"}]},{"title":"growth全栈","slug":"growth全栈","date":"2018-07-03T01:12:25.000Z","updated":"2018-07-03T03:01:34.000Z","comments":true,"path":"2018/07/03/growth全栈/","link":"","permalink":"https://github.com/zdkswd/2018/07/03/growth全栈/","excerpt":"","text":"基础知识篇环境是生产率的一部分。高效的程序员与低效的程序员间十倍的差距，至少有三倍是因为环境差异。语言和开发软件都是工具，都有相对更合适的情况。 提高效率的工具：快速启动软件windows-&gt; launcy IDEDEBUG工具终端或命令提示符包管理环境搭建OSXHomebrew包管理工具，官方称之为 The missing package manager for OS X。 Homebrew Caskbrew-cask 允许你使用命令行安装 OS X 应用。 iTerm2iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。 ZshZsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:• 更高效• 更好的自动补全• 更好的文件名展开(通配符展开) • 更好的数组处理• 可定制性高 Oh My ZshOh My Zsh 同时提供一套插件和工具，可以简化命令行操作。 MacDownMacDown 是 Markdown 编辑器。 CheatSheetCheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按 。 SourceTreeSourceTree 是 Atlassian 公司出品的一款优秀的 Git 图形化客户端。 AlfredMac 用户不用鼠标键盘的必备神器，配合大量 Workflows，习惯之后可以大 大减少操作时间。上手简单，调教成本在后期自定义 Workflows，不过有大量雷锋使用者提供的现成 扩展，访问这里挑选喜欢的，并可以极其简单地根据自己的需要修改。 VimiumVimium 是一个 Google Chrome 扩展，让你可以纯键盘操作 Chrome。 WindowsChocolateyChocolatey 是一个软件包管理工具，类似于 Ubuntu 下面的 apt-get, 不过是 运行在 Windows 环境下面。 WoxWox 是一个高效的快速启动器工具，通过快捷键呼出，然后输入关键字来搜 索程序进行快速启动，或者搜索本地硬盘的文件，打开百度、Google 进行搜 索，甚至是通过一些插件的功能实现单词翻译、关闭屏幕、查询剪贴板历史、 查询编程文档、查询天气等更多功能。它最大的特点是可以支持中文拼音的 模糊匹配。 PowerShellWindows PowerShell 是微软公司为 Windows 环境所开发的壳程序(shell) 及脚本语言技术，采用的是命令行界面。这项全新的技术提供了丰富的控制 与自动化的系统管理能力。 cmdercmder 把 conemu，msysgit 和 clink 打包在一起，让你无需配置就能使用一 个真正干净的 Linux 终端!她甚至还附带了漂亮的 monokai 配色主题。 Total CommanderTotal Commander 是一款应用于 Windows 平台的文件管理器，它包含两个 并排的窗又，这种设计可以让用户方便地对不同位置的 “文件或文件夹” 进 行操作，例如复制、移动、删除、比较等，相对 Windows 资源管理器而言 方便很多，极大地提高了文件操作的效率，被广大软件爱好者亲切地简称为: TC 。 GNU/LinuxZshZsh 是一款功能强大终端(shell)软件，既可以作为一个交互式终端，也可以作为 一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提 供了很多改进，例如:• 更高效• 更好的自动补全• 更好的文件名展开(通配符展开)• 更好的数组处理• 可定制性高 Oh My ZshOh My Zsh 同时提供一套插件和工具，可以简化命令行操作。 ReTextReText 是一个使用 Markdown 语法和 reStructuredText (reST) 结构的文本 编辑器，编辑的内容支持导出到 PDF、ODT 和 HTML 以及纯文本，支持即 时预览、网页生成以及 HTML 语法高亮、全屏模式，可导出文件到 Google Docs 等。 LaunchyLaunchy 是一款免费开源的协助您摒弃 Windows “运行” 的 Dock 式替代工 具，既方便又实用，自带多款皮肤，作为美化工具也未尝不可。 学习一门语言，输出是最好的输入，实践更是硬道理。 Web编程基础运用HTTP传递数据,浏览器第一步Parser HTML,Paser HTML 实质上就是将其 将解析为 DOM Tree。与此同时，CSS 解析器会解析 CSS 会产生 CSS 规则树。随后会根据生成的 DOM 树和 CSS 规则树来构建 Render Tree，接着生成 Render Tree 的布局，最后就是绘制出 Render Tree。 HTML超文本标记语言 浏览器解析器对中文支持不友好。 浏览器解析器对英文支持友好。 CSS选择器类选择器，id选择器JavaScriptHTML 中插入 JavaScript 的方法，就需要用到 HTML 中的 &lt; script&gt; 标签 完整的 JavaScript 应该由下列三个部分组成:• 核心 (ECMAScript)——核心语言功能• 文档对象模型 (DOM)——访问和操作网页内容的方法和接口• 浏览器对象模型 (BOM)——与浏览器交互的方法和接口 有了 DOM 我们就可以对页面进行操作，可以说我们看到的绝大部分的页面效果都是通过 DOM 操作实现的。 前端与后端后台语言选择javascript只要是 Web 就会有前端,只要有前端就需要有 JavaScript。与此同时 Node.js在后台中的地位已经愈发重要了。对于 JavaScript 来说，它可以做很多类型的应用。这些应用都是基于浏览器来运行 的，有:• Electron + Node.js + JavaScript 做桌面应用• Ionic + JavaScript 做移动应用• Node.js + JavaScript 网站前后台• JavaScript + Tessl 做硬件 PythonJavaphpMVCModel模型用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。View 层只是单纯的一个显示作用，这也是我们推荐的做法。业务逻辑应 该尽可能的放置于业务层。Controller控制器层起到不同层面间的组织作用，用于控制应用程序的流程。 后台即服务移动端应用程序 前端框架选择AngularAngularJS 对于后端人员写前端代码来说，是一个非常不错的选择。Angular 框架 采用并扩展了传统 HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许 模型和视图之间的自动同步。 ReactReact 只是我们在上面章节里说到的 View 层，而这个 View 层需要辅以其他框架才 能完成更多的工作。并且 React 还有一个不错的杀手锏——React Native，虽然这个框架还在有条不紊地 挖坑中，但是这真的是太爽了。以后我们只需要一次开发就可以多处运行了，再也没有 比这更爽的事情发生了。 VueVue.js 是一个轻量级的前端框架。它是一个更加灵活开放的解决方案。它允许你以 希望的方式组织应用程序，你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。 jQuery系jQuery 还是一个不错的选择，不仅仅对于学习来说，而且对于工作来说也是如此。 如果你们不是新起一个项目或者重构旧的项目，那么必然你是没有多少机会去超越 DOM。 前台与后台交互AjaxAJAX 即 “Asynchronous JavaScript And XML”(异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更 新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的 网页如果需要更新内容，必须重载整个网页页面。 JSON WEB TokensJSON Web Token (JWT) 是一种基于 token 的认证方案。在人们大规模地开始 Web 应用的时候，我们在授权的时候遇到了一些问题，而这些 问题不是 Cookie 所能解决的。通过 JWT 我们可以更方便地写出适用于前端应用的认证方案，如登陆、注册这些功能。在使用 JWT 的时候也需要注意安全问题，在允许的情况下应该使用 HTTPS 协议。 WebSocketHTML5 推出了一种 在单个 TCP 连接上进行全双工通讯的协议 WebSocket。WebSocket 可以让客户端和服务器之间存在持久的连接，而且双方都可以随时开始 发送数据。 编码Web 应用的构建系统构建系统 (build system) 是用来从源代码生成用户可以使用的目标的自动化 工具。目标可以包括库、可执行文件、或者生成的脚本等等。 常用的构建工具包括 GNU Make、GNU autotools、CMake、Apache Ant(主要用于 JAVA)。此外，所有的集成开发环境(IDE)比如 Qt Creator、Microsoft Visual Studio 和 Eclipse 都对他们支持的语言添加了自己的构建系统配置工具。通常 IDE 中的构建系 统只是基于控制台的构建系统(比如 Autotool 和 CMake )的前端。对比于 Web 应用开发来说，构建系统应该还包括应用打包 (如 Java 中的 Jar 包，或 者用于部署的 RPM 包、源代码分析、测试覆盖率分析等等。 Web 应用的构建GulpGulp.js是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你 可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务 的 Gulp 文件都是通过 JavaScript(或者 CoffeeScript )源码来实现的。 JSHint最初，lint这个工具用来扫描C源文件并对源程序中不可移植的代码提出警告。但是现在大多数lint实用程序已经变得更加严密，它不但可以检查出可移植性问题，而且可以检查出那些虽然可移植并且完全合乎语法但却很可能是错误的特性。对应于不同的语言都会有不同的 lint 工具，在 JavaScript 中就有JSLint。JavaScript 是一门年轻、语法灵活多变且对格式要求相对松散的语言，因此这样的工具对于这门语 言来说比较重要。• 可配置规则，每个团队可以自己定义自己想要的代码规范。• 对社区非常友好，社区支持度高。• 可定制的结果报表。 自动化测试工具Mocha 是一个可以运行在 Node.js 和浏览器环境里的测试框架。 编译对于静态型语言来说，编译是一个很重要的步骤。不过，对于动态语言来说也存在这样的工具。动态语言的编译:是以我们常见的 JavaScript 为代表。打包,1. DEB 2.RPM 3.压缩文档 tar.gz 如何编写测试TODO测试金字塔 从上到下 ui测试 服务测试 单元测试测试替身 Stub Mock 代码重构TODO重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。 上线HTTP服务器目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。 ApacheApache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广 泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器 端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译 到服务器中。 NginxNginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件(IMAP/ POP3)代理服务器，并在一个 BSD-like 协议下发行。由俄罗斯的程序设计师 Igor Sysoev 所开发，供俄国大型的入又网站及搜索引擎 Rambler(俄文:Рамблер)使用。 其特点是占有内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务 器中表现较好，中国大陆使用 Nginx 网站用户有:百度、新浪、网易、腾讯等。 IISInternet Information Services(IIS，互联网信息服务)，是由微软公司提供的基 于运行 Microsoft Windows 的互联网基本服务。最初是 Windows NT 版本的可选包，随 后内置在 Windows 2000、Windows XP Professional 和 Windows Server 2003 一起发 行，但在 Windows XP Home 版本上并没有 IIS。 代理服务器代理服务器(Proxy Server)是一种重要的服务器安全功能，它的工作主要在 开放系统互联 (OSI) 模型的会话层，从而起到防火墙的作用。代理服务器大 多被用来连接 INTERNET(国际互联网)和 Local Area Network(局域网)。 Web缓存• 数据库端缓存• 应用层缓存• 前端缓存• 客户端缓存 功能开关当我们上线了我们的新功能的时候，这时候如果有个 Bug，那么我们是下线么?要 知道这个版本里面包含了很多的 Bug 修复。Feature Toggle 它是一种允许控制线上功能开启或者关闭的方式 依赖与包仓库数据分析SEO 搜索引擎优化分析工具 google analytics网站性能 Apdex联盟","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"全栈","slug":"全栈","permalink":"https://github.com/zdkswd/tags/全栈/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"[Linux内核设计与实现]中断与中断处理","slug":"【Linux内核设计与实现】中断与中断处理","date":"2018-07-01T11:37:32.000Z","updated":"2018-07-01T11:37:21.000Z","comments":true,"path":"2018/07/01/【Linux内核设计与实现】中断与中断处理/","link":"","permalink":"https://github.com/zdkswd/2018/07/01/【Linux内核设计与实现】中断与中断处理/","excerpt":"","text":"【Linux内核设计与实现】中断与中断处理中断中断处理程序在Linux中，中断处理程序就是普普通通的C函数。 上半部与下半部的对比把中断处理分为两部分。中断处理程序是上半部–接收到一个中断，就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部。 注册中断处理程序中断处理程序是管理硬件的驱动程序的组成部分。每一设备都有相关的驱动程序，如果设备使用中断，则对应的驱动程序就注册一个中断处理程序。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters","slug":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters","date":"2018-06-15T09:49:56.000Z","updated":"2018-06-15T03:55:47.000Z","comments":true,"path":"2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/","link":"","permalink":"https://github.com/zdkswd/2018/06/15/引入module后的问题 ; AsyncTask ;Make Clean Project;abiFilters/","excerpt":"","text":"引入module后的问题 ; AsyncTask ;Make Clean Project;abiFiltersimport module在import module时，如果图标没有变化，不要忘了改setting.gradle AsyncTaskAsyncTask,即异步任务,是Android给我们提供的一个处理异步任务的类.通过此类,可以实现UI线程和后台线程进行通讯,后台线程执行异步任务,并把结果返回给UI线程. AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个泛型参数:Params:启动任务时输入的参数类型.Progress:后台任务执行中返回进度值的类型.Result:后台任务执行完成后返回结果的类型. AsyncTask主要有如下几个方法:doInBackground:必须重写,异步执行后台线程要完成的任务,耗时操作将在此方法中完成.onPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作.onPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.onProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度. Make Project Clean Project Make Project：编译Project下所有Module，一般是自上次编译后Project下有更新的文件，不生成apk。 Make Selected Modules：编译指定的Module，一般是自上次编译后Module下有更新的文件，不生成apk。 Clean Project：删除之前编译后的编译文件，并重新编译整个Project，比较花费时间，不生成apk。 Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成apk，这里效果其实跟Clean Project是一致的，这个不知道Google搞什么鬼～～ Build APK：前面4个选项都是编译，没有生成apk文件，如果想生成apk，需要点击Build APK。 Generate Signed APK：生成有签名的apk。 平时小的改动直接用Make Project就可以，可以看到只有它有快捷方式，表明这个功能要经常用。对于一些大的改动比如更新lib，大功能修改等，用Clean或Rebuild，毕竟这两个编译起来要费时间。如果有的时候死活编译不过，多试试Clean吧，会有意想不到的效果！ 关于abiFilters的使用最近项目中遇到了要使用opencv的情况，涉及到了abi兼容的选择。因为如果全部都适配的话，包很大，这样兼容那些用户数极少的cpu就很不划算，所以我只适配了armeabi-v7a这一个。但是今天在x64-v8a的模拟器上看的时候，提示我的library.so文件找不到，我记得这个应该是向下兼容的，但是出现这种情况很奇怪，于是我就在网上找了找答案。解决方法：abiFilters在app的gradle的defaultConfig里面加上这么一句ndk { abiFilters “armeabi-v7a” // 指定要ndk需要兼容的架构(这样其他依赖包里mips,x86,armeabi,arm-v8之类的so会被过滤掉)} 这句话的意思就是指定ndk需要兼容的架构，把除了v7a以外的兼容包都过滤掉，只剩下一个v7a的文件夹。用了这个方法之后，确实解决了问题。这就是解决方法。具体分析其实这个方法我开始是很奇怪的，我明明没有指定其他的兼容框架，为什么会需要一个过滤。我打来了apk的包，找到了里面的lib目录，发现里面有很多的兼容目录，然后看到里面目录里面的是一个fresco的.so文件。也就是说，fresco做了各个平台的兼容，所以它创建了各个兼容平台的目录。因为只要出现了这个目录，系统就只会在这个目录里找.so文件而不会遍历其他的目录，所以就出现了之前找不到.so文件的情况（因为其他目录没有我的.so文件）。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/zdkswd/tags/AndroidStudio/"}]},{"title":"[Linux内核设计与实现]系统调用","slug":"[Linux内核设计与实现]系统调用","date":"2018-06-15T03:53:32.000Z","updated":"2018-06-18T02:49:58.000Z","comments":true,"path":"2018/06/15/[Linux内核设计与实现]系统调用/","link":"","permalink":"https://github.com/zdkswd/2018/06/15/[Linux内核设计与实现]系统调用/","excerpt":"","text":"[Linux内核设计与实现]系统调用内核提供接口让应用程序调用实现特定功能，避免应用程序肆意妄为。 与内核通信系统调用在用户空间进程和硬件设备间添加了一个中间层。 提供硬件的抽象接口，即无需管磁盘类型，介质等问题。 保证系统的安全。 告知内核自己在使用硬件以实现多任务和虚拟内存。内核知道了才能更好的管理分配。系统调用是用户空间访问内核的唯一手段。 API、POSIX、和C库用户程序在用户空间使用API进行编程。API可以实现零个，一个或多个系统调用。UNIX世界中，最流行的应用程序接口是基于POSIX标准的。在大多数Unix上，根据POSIX定义的API函数和系统调用之间有着直接的关系。这个协议是对操作系统服务接口的标准化，从而保证了应用程序在源码层次的可移植性。具体来说是应用程序调用API，API中包含有系统调用，调用内核。程序员与API打交道，内核与系统调用打交道。 系统调用要访问系统调用（在Linux中常称为syscall）,通常通过C库中定义的函数调用来进行。 系统调用号在Linux中，每个系统调用被赋予一个系统调用号。通过这个独一无二的号可以关联系统调用。系统调用号非常重要，一旦分配就不能变更，否则编译好的应用就会崩溃。Linux中的sys_ni_syscall()系统调用几乎不做任何操作，相当于白板儿，用来替代那些被删除的或不可用的系统调用。内核用sys_call_table记录注册过的系统调用。 系统调用的性能Linux系统调用比其他操作系统执行的快。一是因为Linux有很短的上下文切换时间。二是系统调用处理程序和每个系统调用都很简洁。 系统调用的处理程序应用程序实际在API中调用的系统调用也并不是直接执行内核代码。应用程序以软中断的方式来通知系统执行一个系统的调用。通过引发异常来促使系统切换到内核态去执行异常处理程序。正是系统调用的处理程序。通过int$0x80指令触发中断。 指定恰当的系统调用系统调用号通过eax寄存器传递给内核。 参数传递也可以通过寄存器进行参数的传递。 系统调用的实现实现系统调用Unix格言提供机制而不是策略，当写一个系统调用时，要时刻注意可移植性和健壮性，还要为以后做打算。 参数验证系统调用必须仔细检查参数是否合法有效最重要的检查是用户提供的指针知否有效。内核无论何时都不能轻率接受来自用户空间的指针。 系统调用上下文在Context中，内核可以休眠可以被抢占。 绑定一个系统调用的最后步骤从用户空间访问系统调用","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"implementation 与 compile 的区别 .iml build文件夹 安卓视图","slug":"implementation 与 compile 的区别 .iml build文件夹 安卓视图","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T09:51:21.000Z","comments":true,"path":"2018/05/31/implementation 与 compile 的区别 .iml build文件夹 安卓视图/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/implementation 与 compile 的区别 .iml build文件夹 安卓视图/","excerpt":"","text":"##implement概念 : 将该依赖隐藏在内部，而不对外部公开。理解 : 在 app mudule 中使用 implement 依赖的第三方库, 在其他 mudule 是无法调用的.举例 : 此时项目中有一个 mudule 是 ImageLoader ,其内部用 implement 指令依赖了 glide 这个库, 那么此时我们在 app mudule 中无法调用 glide 库中的方法. ##compile概念: android studio 3.0 版本后废弃该指令 改用 api 代替, api 完全等同于之前的 compile 指令, 也就是普通的依赖, 第三方库在 mudule 中依赖后其他 mudule 都可以使用该库.官方推荐在不影响的前提下优先使用 implement 指令依赖. .iml文件iml是 intellij idea的工程配置文件，里面是当前project的一些配置信息可以配置不输出文件夹。 build文件夹中的generated intermediates成功build后会产生以下文件夹：generated：The “generated“ folder contains java code generated by Android Studio for the module. The primary file here is “R.java“ which assigns symbolic names to each of the items in the “res” directory so they can be referenced in java source code.intermediates：The “intermediates“ folder contains individual files that are created during the build process and which are eventually combined to produce the “apk” file. Android视图与Project视图Project视图：Project视图是真实的文件结构，真实文件就是这么存放的。Android视图:可以说是build成功后根据配置信息，生成的结构。结构与配置信息有关，与build文件夹有关。不是真实文件的存放方式。其项目树的名字也不一定是真实名字，与配置信息有关。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://github.com/zdkswd/tags/AndroidStudio/"}]},{"title":"Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback","slug":"Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T09:51:27.000Z","comments":true,"path":"2018/05/31/Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/Surface、SurfaceView、SurfaceHolder及SurfaceHolder.Callback/","excerpt":"","text":"SurfaceSurface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原生缓冲器以及其它方面的内容。原生缓冲器（rawbuffer）是用于保存当前窗口的像素数据的。通常画图是在一个Canvas对象上面进行的。 SurfaceViewSurfaceView，顾名思义就是Surface的View，通过SurfaceView就可以看到Surface的部分或者全部的内容.也就是说，Surface是用通过SurfaceView才能展示其中的内容。SurfaceView是Android中View的子类。事实上，在Android中所有用于界面展示的类皆为View的子类，包括那些不可见的、各种各样的Layout。 在Android中Surface是从Object派生而来，且实现了Parcelable接口。看到Parcelable就让人能很自然地想到数据容器，SurfaceView就是用来展示Surface中的数据的。在这个层面上而言，Surface就是管理数据的地方，SurfaceView就是展示数据的地方。 这个类的目的之一，就是提供一个可以用另外一个线程（第二个线程）进行屏幕渲染的surface（译注：即UI线程和绘制线程可以分离）。如果你打算这样使用，那么应当注意一些线程方面的语义： 所有SurfaceView和SurfaceHolder.Callback中声明的方法，必须在运行SurfaceView窗口中的线程中调用（典型地，就是应用的主线程。译注：即UI线程），因为它们需要正确地将同时被绘制线程访问的各种状态进行同步。 必须保证，只有在背后的Surface有效的时候 – 在SurfaceHolder.Callback.surfaceCreated()和 SurfaceHolder.Callback.surfaceDestroyed()这两个方法调用之间，访问它。 Android中实现序列化有两个选择：一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。 SurfaceHolderSurfaceHolder是一个接口，其作用就像一个关于Surface的监听器。提供访问和控制SurfaceView背后的Surface 相关的方法.它通过三个回调方法，让我们可以感知到Surface的创建、销毁或者改变。在SurfaceView中有一个方法getHolder，可以很方便地获得SurfaceView所对应的Surface所对应的SurfaceHolder.从设计模式的高度来看，Surface、SurfaceView和SurfaceHolder实质上就是广为人知的MVC，即Model-View-Controller。 SurfaceHolder.Callback前面已经讲到SurfaceHolder是一个接口，它通过回到方法的方式，让我们可以感知到Surface的创建、销毁或者改变。其实这一点是通过其内部的静态子接口SurfaceHolder.Callback来实现的。SurfaceHolder.Callback中定义了三个接口方法： abstract void surfaceChanged(SurfaceHolderholder, int format, int width, int height)当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。 abstract void surfaceCreated(SurfaceHolderholder)当surface对象创建后，该方法就会被立即调用。 abstract void surfaceDestroyed(SurfaceHolderholder)当surface对象在将要销毁前，该方法会被立即调用。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"}]},{"title":"【安卓开发艺术探索】JNI和NDK编程","slug":"【安卓开发艺术探索】JNI和NDK编程","date":"2018-05-31T09:49:56.000Z","updated":"2018-05-31T12:53:11.000Z","comments":true,"path":"2018/05/31/【安卓开发艺术探索】JNI和NDK编程/","link":"","permalink":"https://github.com/zdkswd/2018/05/31/【安卓开发艺术探索】JNI和NDK编程/","excerpt":"","text":"NDK还提供了交叉编译器，开发人员只需要简单地修改mk文件就可以生成特定CPU平台的动态库。 JNI开发流程 在java中声明native方法声明native方法，且在类头部有加载动态库的过程，库的真实名字为加载所用名字加前缀lib，这是加载so库的规范。 编译java源文件得到class文件，然后通过javah命令导出JNI的头文件 javac com/ddd/example.javajavah com.ddd.example 在当前目录会产生一个com_ddd_example.h的头文件，它是javah命令自动生成的。函数名的格式遵循java_包名_类名_方法名 实现JNI方法，JNI方法是指java中声明的native方法，在工程的主目录下创建一个子目录，名称随意，将上一步生成的头文件复制其中，接着创建.cpp文件，include它。实现其中的方法。 编译so库并在java中调用so库这里采用gcc编译，切换到刚刚生成的子目录中，对于cpp编译指令如下： gcc -shared-I /本地jdk的安装路径/include -fPIC .cpp -o libexample.so so库编译完成后，就可以在Java程序中调用so库了，切换至主目录，执行指令 java -Djava.library.path=子目录名 com.ddd.example 其中-Djava.library.path指明了so库的路径。 NDK开发流程 下载并配置NDK 创建一个安卓项目，并声明所需的native方法如： public static native String hello(); 3.实现安卓项目中声明的native方法,在外部创建一个名为jni的目录，然后在jni目录下创建3个文件，.cpp,Android.mk和Application.mk .h中： JNIEXPORT jstring JNICALL Java_com_aiseminar_EasyPR_PlateRecognizer_hello(JNIEnv *, jclass); .cpp中实现其.h中的函数。Android.mk中，LOCAL_MODULE表示模块的名称，LOCAL_SRC_FILES表示需要参与编译的源文件。Application.mk中常用的配置项是APP_ABI,它表示CPU架构平台的类型，默认NDK编译全平台的so库，但可以指定编译特定平台的so库。 切换到jni目录的父目录，然后通过ndk-build命令编译产生so库这时NDK会创建一个和jni平级的目录libs，存放so库的目录。需要注意ndk-build命令默认指定jni目录为本地源码目录。若不是则无法成功编译。然后在app/src/main中创建一个名为jniLibs目录，将生成so库复制过去，通过AndroidStudio编译运行即可。jniLibs目录是AndroidStudio默认目录，也可修改App build.gradle文件，jniLibs.srcDir选项指定了新的存放so库的目录。 也可以通过AndroidStudio来自动编译来产生so库。首先需要在App的build.gradle的defaultConfig区域内添加NDK选项，其中moduleName制定了模块的名称，这个名称指定看打包后的so库文件名。ndk{\u0010 moduleName”example”}接着需要将JNI代码放在app/src/main/jni目录中，注意存JNI必须为jni，也可以通过如下方式指定JNI代码路径，其中jni.srcDirs指定JNI代码路径：jni.srcDirs ‘src/main/lib_src’经过上面的步骤，AndroidStudio就可以自动编译JNI代码了。 JNI的数据类型和类型签名JNI调用Java方法1 找到类名2 找到方法id3 调用方法对于非静态方法要先生成类才行","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"}]},{"title":"Bazel 和Protocol Buffer","slug":"Bazel 和Protocol Buffer","date":"2018-05-25T11:00:56.000Z","updated":"2018-05-25T11:01:05.000Z","comments":true,"path":"2018/05/25/Bazel 和Protocol Buffer/","link":"","permalink":"https://github.com/zdkswd/2018/05/25/Bazel 和Protocol Buffer/","excerpt":"","text":"BazelBazel是一个类似于Make的编译工具，是Google为其内部软件开发的特点量身定制的工具，如今Google使用它来构建内部大多数的软件。Google认为直接用Makefile构建软件速度太慢，结果不可靠，所以构建了一个新的工具叫做Bazel，Bazel的规则层级更高。 Protocol BufferProtocol Buffer是谷歌开发的处理结构化数据的工具。解决结构数据在信息持久化或网络传输时需要进行序列化以及还原数据的问题。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"Tensorflow模型持久化","slug":"Tensorflow模型持久化","date":"2018-05-25T11:00:56.000Z","updated":"2018-05-25T11:10:23.000Z","comments":true,"path":"2018/05/25/Tensorflow模型持久化/","link":"","permalink":"https://github.com/zdkswd/2018/05/25/Tensorflow模型持久化/","excerpt":"","text":"持久化代码实现通过tf.train.Saver类来保存和还原一个神经网络，模型文件目录下会出现三个文件。这是因为Tensorflow会将计算图的结构和图上参数取值分开保存。 model.ckpt.meta,保存了计算图的结构。 model.ckpt,保存程序中每一个变量的取值。 checkpoint,保存了一个目录下所有的模型文件列表。 加载已经保存的Tensorflow模型方法。1.使用和保存模型代码中一样的方法来声明变量。2.加载已经保存的模型。sever.restore(sess,”.ckpt”) 加载模型的程序也是定义了Tensorflow计算图上的所有运算，并声明了一个tf.train.Saver类。区别在于加载模型的代码中没有运行变量的初始化过程而是将变量的值通过已经保存的模型加载了进来。也可以直接加载已经持久化的图saver=tf.train.import_meta_graph(…..meta) 函数tf.get_default_graph().get_tensor_by_name(“add:0”)可以通过张量的名称获取张量。 也可以声明tf.train.Saver类时提供一个列表指定需要保存或者加载的变量。同样可以在保存和加载时使用字典给变量重命名。 使用Saver会保存运行程序所需的全部信息，然而有时不需要某些信息。在测试或者离线预测时，不需要某些辅助节点的信息。且多个文件存储时也并不方便。convert_variables_to_constants将计算图中的变量及其取值通过常亮保存。导出当前计算图的GraphDef部分只需要这一部分就可以完成从输入层到输出层的计算过程。 graph_def=tf.get_default_graph().as_graph_def() 将图中的变量及其取值转化为常量，同时将图中不必要的节点去掉。一些如变量初始化操作的系统运算也会被转化为计算图的节点。可以通过【】指定需要保存的操作。 output_graph_def=graph_util.convert_variables_to_constants(sess,graph_def,[‘add’])//add为节点名 将导出模型存入文件： with tf.gfile.GFile(“…pb”,”wb”) as f: f.write(output_graph_def.SerialzeToString()) 加载模型： with gflie.FastGFile(model_filename//.pb,’rb’) as f: graph_def=tf.GraphDef() graph_def.ParseFromString(f.read())result=tf.import_graph_def(graph_def,return_elements=[“add:0”])//add:0为一个张量sess.run(result) Saver持久化原理及数据格式Tensorflow通过元图（MetaGraph）来记录计算图中节点信息以及运行计算图中节点所需要的元数据。由Protocol Buffer定义，记录了五类信息： meta_info_def属性,记录计算图中的元数据以及所有使用到运算方法的信息。 graph_def属性，记录计算图的节点信息。 saver_def属性，记录了持久化模型时需要用到的一些参数。 collection_def属性维护集合的底层实现是通过collection_def这个属性。5 signature_def属性。 model.ckpt保存所有变量的取值，通过SSTable格式存储，大致为一个（key，value）列表。checkpoint是Saver类自动生成自动维护的。当某个保存的TensorFlow模型文件被删除时，这个模型对应的文件名也会从checkpoint文件中删除。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"Gradle","slug":"Gradle","date":"2018-05-20T09:28:56.000Z","updated":"2018-05-20T09:42:19.000Z","comments":true,"path":"2018/05/20/Gradle/","link":"","permalink":"https://github.com/zdkswd/2018/05/20/Gradle/","excerpt":"","text":"差异管理说到多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说国内某团购网站的Android App有100多个渠道.这里出现了什么?重复,反复的去打包而且这些包之前的差异很小(只是渠道号不同),和写代码一样我们应该复用,通过Gradle可以实现一个命令打出所有的渠道包,一个命令打出指定的渠道包.再复杂一点,你可能需要不同的渠道对应不同的签名文件,不同的icon,不同的服务器地址…这些都可以通过Gradle来方便的实现. 依赖管理:做软件开发你可能需要依赖各种不同的jar,library.你当然可以通过将.jar/library工程下载到本地再copy到你的工程中,但不知你是否听说过国外有个叫中央仓库的东西,在这个仓库里你可以找到所有你能想到以及你从来没听说过的jar,aar…The Central Repository Search Engine 这里可以找到所有你需要的依赖,而你需要的只是指定一个坐标,如下:compile’com.squareup.picasso:picasso:2.3.3剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点: 依赖不会进入到你的版本控制仓库中(默认会缓存到~/.gradle/下) 方便卸载装载依赖(只是一条坐标依赖,不需要删除即可) 方便的版本管理,如上图中的2.3.3既是picasso的版本号,若改为+就表示从中央仓库中下载最新的版本 不同工程的相同依赖不会存在重复副本(只在~/.gradle下存在一份)项目部署这方面我没怎么接触过,但据我所知通过一些插件,可以实现自动将你的输出(.jar,.apk,.war…)上传到指定仓库,自动部署… Gradle概念Gradle，这是一个基于 JVM 的富有突破性构建工具。Gradle不单单是一个配置脚本，它的背后是三门语言。 ◦ Groovy Language ◦ Gradle DSL ◦ Android DSLDSL的全称是Domain Specific Language，即领域特定语言。 The Gradle wrapperGradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。 Gradle构建基础build.gradle一个项目中会有一个project build.gradle。与若干个module build.gradle.你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本。 project与taskGradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等。插件本身就是包含了若干Task的。 Gradle脚本的执行时序 初始化，分析有哪些module将要被构建，为每个module创建对应的 project实例。这个时候settings.gradle文件会被解析。 配置,处理所有的模块的 build 脚本，处理依赖，属性等。这个时候每个模块的build.gradle文件会被解析并配置，这个时候会构建整个task的链表（这里的链表仅仅指存在依赖关系的task的集合，不是数据结构的链表）。先是project build.gradle后是module build.gradle,且从依赖树的叶节点执行。配置完了以后，有一个重要的回调project.afterEvaluate，它表示所有的模块都已经配置完了，可以准备执行task了。 执行，根据task链表来执行某一个特定的task，这个task所依赖的其他task都将会被提前执行。 Groovy基础[原创：任玉刚]Groovy和Java的关系Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。 Groovy的变量和方法声明在Groovy中，通过 def 关键字来声明变量和方法。 def a = 1def b = “hello world”def int c = 1 def hello() { println “hello world” // 方法调用省略括号 1; // 方法返回值省略return}def hello(String msg) { println (msg)} // 方法省略参数类型int hello(msg) { println (msg) return 1} // 方法省略参数类型int hello(msg) { println msg return 1 // 这个return不能省略 println “done”} Groovy的数据类型 String,用于字符串拼接。 闭包，Groovy中有一种特殊的类型，叫做Closure，翻译过来就是闭包，这是一种类似于C语言中函数指针的东西。闭包用起来非常方便，在Groovy中，闭包作为一种特殊的数据类型而存在，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在。 声明闭包 { parameters -&gt; code} List和Map,Groovy加强了Java中的集合类，比如List、Map、Set等.List还有一种看起来很奇怪的操作符&lt;&lt;，表示向List中添加新元素的意思. 加强的IO. 其他特性 所有的Class类型，都可以省略.class 只要有属性就有Getter/Setter，反之亦然。 with操作符 Book bk = new Book()bk.id = 1bk.name = “android art”bk.press = “china press” 可以简写为： Book bk = new Book()bk.with { id = 1 name = “android art” press = “china press”} 等等http://www.jianshu.com/p/ba55dc163dfd 定义Task task myTask { println “config myTask”} 通过上述方式定义的task,括号内部的代码会在配置阶段执行。 要括号内的代码仅仅在执行我们的task的时候才执行，这个时候可以通过doFirst或者doLast来完成。 • doFirst：task执行时，最开始的操作 • doLast：task执行时，最后的操作 myTask.doLast { println “after execute myTask”}myTask.doFirst { println “before execute myTask”} doLast还有一个等价的操作leftShift，leftShift还可以缩写为&lt;&lt; myTask &lt;&lt; { println “after execute myTask”} 剩下的细节还是需要大家查看Gradle文档，其实学习Gradle就是一个查文档的过程。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"软件构筑","slug":"软件构筑","permalink":"https://github.com/zdkswd/tags/软件构筑/"},{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"}]},{"title":"x86 ARM MIPS NDK JNI 交叉编译 ABI","slug":"x86 ARM MIPS NDK JNI 交叉编译 ABI","date":"2018-05-19T13:46:56.000Z","updated":"2018-05-25T10:28:41.000Z","comments":true,"path":"2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/","link":"","permalink":"https://github.com/zdkswd/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/","excerpt":"","text":"X86和ARM,MIPS架构x86架构采用CISC，代表公司Intel。而ARM采用RISC，代表公司ARM。MIPS架构多用在网关、猫、机顶盒等设备。 X86以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。x86为此还必须有复杂的分支预测机构，确保流水线的效率。再加上多级cache，支持超线程、虚拟化等等，x86的复杂度其实相当高ARM（Advanced RISC Machines）一个32位元精简指令集(RISC)处理器架构可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。 扩展性X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行 功耗X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度，考虑其完成复杂操作的能力，功耗很大。ARM则功耗很低。ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场，ARM目前是移动处理器的老大；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 x86是PC端老大。 NDKNative Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C/C++的动态库，并能自动将so和java一起打包成apk。NDK就是帮助我们可以在Android应用中使用C/C++来完成特定功能的一套工具.NDK的作用有很多，我们简单的列举两个:1.首先NDK可以帮助开发者“快速”开发C(或C++)的动态库。2.其次，NDK集成了“交叉编译器”。使用NDK，我们可以将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。 JNIJava Native Interface（JNI）标准是java平台的一部分，JNI是Java语言提供的Java和C/C++相互沟通的机制，其实JNI它就是一种协议,Java可以通过JNI调用C/C++代码，C/C++的代码也可以调用java代码。 交叉编译编译器在将中间代码连接成当前计算机可执行的二进制程序时，连接程序会根据当前计算机的CPU、操作系统的类型来转换。交叉编译就是在一个平台下（比如：CPU架构为X86，操作系统为Windows）编译出在另一个平台上（比如：CPU架构为arm,操作系统为Linux）可以执行的二进制代码。Google提供的NDK就可以完成交叉编译的工作。【Android：基于Linux 内核arm架构的操作系统，装在arm上的linux是需要重新编译内核的 所以和x86上的linux内核是不一样的】 Android 设备的CPU类型(通常称为”ABIs”) armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的部分Android设备都使用它. arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。 armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。 x86: 平板、模拟器用得比较多。 x86_64: 64位的平板。 arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so，那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了，所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，所以要么你别加arm64-v8a,要么armeabi里面有的so库，arm64-v8a里面也必须有。 对策： 为了减小 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中.so数量一致 对只提供 armeabi 版本的第三方 .so，原样复制一份到 armeabi-v7a 文件夹 应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。 当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支持armeabi-v7a和armeabi）。我们往往很容易对.so文件应该放在或者生成到哪里感到困惑，下面是一个总结：Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/zdkswd/tags/Android/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"},{"name":"c/c++","slug":"c-c","permalink":"https://github.com/zdkswd/tags/c-c/"}]},{"title":"lib dll .h .hpp 预编译","slug":"lib,dll,.h,.hpp,预编译","date":"2018-05-17T13:46:56.000Z","updated":"2018-05-17T13:48:13.000Z","comments":true,"path":"2018/05/17/lib,dll,.h,.hpp,预编译/","link":"","permalink":"https://github.com/zdkswd/2018/05/17/lib,dll,.h,.hpp,预编译/","excerpt":"","text":"静态库动态库静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。 这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。 是动态链接有一个缺点就是可移植性太差，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败。 头文件编译时，编译器通过头文件.h找到对应的函数库，预编译时将整个.h文件插入目标文件头部，项目中需要有其对应的.c文件进行编译生成中间文件进行连接。.hpp，本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数 一个头文件被别的源文件重复包含是经常发生的，如何避免某个头文件被重复包含呢？利用条件编译轻松解决。在头文件的开始加入： #ifndef HEADER_NAME#define HEADER_NAME 在头文件的结尾加上： #endif C/C++中的预编译指令程序的编译过程可以分为预处理、编译、汇编三部分，其中预处理是首先执行的过程，预处理过程扫描程序源代码，对其进行初步的转换，产生新的源代码提供给编译器。 #include指令，#include预处理指令的作用是在指令处展开被包含的文件。#include \\&lt;xxx.h&gt;#include “xxx.h”第一种方法将待包含的头文件使用尖括号括起来，预处理程序会在系统默认目录或者括号内的路径查找，通常用于包含系统中自带的公共头文件。第二种方法将待包含的头文件使用双引号引起来，预处理程序会在程序源文件所在目录查找，如果未找到则去系统默认目录查找，通常用于包含程序作者编写的私有头文件。 2.#define、#undef指令,#define指令定义了一个标识符及一个串，标识符称为宏名，源程序中宏名的每次出现都会用其定义的串进行替换，称为宏替换。#undef指令取消一个已定义的宏。 3.#if、#elif、#else、#endif指令，这几个指令称为条件编译指令，可对程序源代码的各部分有选择地进行编译。跟一般的if、else if、else语句类似，如果一个条件上的值为真，则编译它对应的代码，否则提过这些代码，测试下一个条件上的值是否为真。注意，作为条件的表达式是在编译时求值的，它必须仅含常量及已定义过的标识符，不可使用变量，也不可以含有操作符sizeof（sizeof也是编译时求值）。感觉这主要是用来设置一个宏选择性的编译一部分的代码。 4.#ifdef、#ifndef、#endif指令，这几个也是条件编译指令，其检查后面指定的宏是否已经定义，然后根据检查结果选择是否要编译后面语句。其中#ifdef表示”如果有定义“，#ifndef表示”如果没有定义“。这个通常可以用于防止重复包含头文件的问题 #ifndef MYHEAD_H#define MYHEAD_H#include “myHead.h”#endif 5.#line指令,C语言中可以使用FILE表示本行语句所在源文件的文件名，使用LINE表示本行语句在源文件中的位置信息。#line指令可以重新设定这两个变量的值，其语法格式为#line number[“filename”] 6.#error指令,#error指令在编译时输出编译错误信息，可以方便程序员检查出现的错误。 7.#pragma指令,该指令用来来设定编译器的状态或者是指示编译器完成一些特定的动作，它有许多不同的参数。7.1. #pragma once在头文件的最开始加入这条指令可以保证头文件只被编译一次。它可以实现上述使用#ifndef实现不重复包含头文件同样的功能，但可能会有部分编译系统不支持。 7.2.#pragma message该指令能够让编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。 7.3.#pragma warning…等等其他参数","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"},{"name":"c/c++","slug":"c-c","permalink":"https://github.com/zdkswd/tags/c-c/"}]},{"title":"Tensorflow可视化","slug":"Tensorflow可视化","date":"2018-05-17T10:11:41.000Z","updated":"2018-05-25T11:54:26.000Z","comments":true,"path":"2018/05/17/Tensorflow可视化/","link":"","permalink":"https://github.com/zdkswd/2018/05/17/Tensorflow可视化/","excerpt":"","text":"Tensorflow计算模型–计算图计算图的使用tensorflow程序可分为两个阶段，第一阶段定义图中所有的计算。第二阶段为执行阶段。tensorflow中，系统会自动维护一个默认的计算图，通过tf.get_default_graph函数可以获取当前默认的计算图。除了使用默认的计算图，Tensorflow支持通过tf.Graph函数来生成新的计算图。不同计算图上的张量和运算都不会共享。计算图可以通过tf.Graph.device函数来指定运行计算的设备。有效地整理TensorFlow程序的资源也是计算图的一个重要功能。在一个集合（collection）来管理不同类型的资源。 集合名称 集合内容 使用场景 tf.GraphKeys.VARIABLES 所有变量 持久化Tensorflow模型 tf.GraphKeys.TRAINABLE_VARIABLES 可学习的变量（一般指神经网络中的参数） 模型训练、生成模型可视化内容 tf.GraphKeys.SUMMARIES 日志生成的相关的张量 TensorFlow计算可视化 tf.GraphKeys.QUEUE_RUNNERS 处理输入的QueueRunner 输入处理 tf.GraphKeys.MOVING_AVERAGE_VARIABLES 所有计算了滑动平均值的变量 计算变量的滑动平均值 如通过tf.add_to_collection将资源加入一个或多个集合中。通过tf.get_collection获取一个集合里面的所有资源。 TensorBoard可视化TensorBoard简介TensorBoard可以通过TensorFlow程序运行过程中输出的日志文件可视化TensorFlow程序的运行状态。两者跑在不同进程中，TensorBoard会自动读取TensorFlow最新的日志文件。 #运行TensorBoard，将地址执行日志输出地址tensorboard –logdir=/path/to/log 命令启动服务默认端口号6006，localhost:6006可以看到界面。使用–port参数可以改变启动服务的端口。 变量管理TensorFLow提供了通过变量名称来创建或者获取一个变量的机制。通过这个机制在不同的函数中可以直接通过变量的名称来使用变量，而不需要将变量通过参数的形式到处传递。TensorFLow中通过变量名称获取变量的机制主要是通过tf.get_variable和tf.variable_scope函数实现。 v.get_variable和tf.Variable定义等价。区别在于前者变量名称是个必填项，后者是个选填项。v.get_variable会根据这个名字去创建或者获取变量。首先会试图创建一个变量，如有同名则创建失败。如果需要通v.get_variable获取一个已经创建的变量，需要tf.variable_scope函数生成一个上下文管理器。将参数reuse设置为True(获取唯一途径)，v.get_variable将只能获取已经创建过的变量。否则将尝试创建变量。 with v.variable_scope(“name”,reuse=”True”): v=v.get_variable(“var”,[1]) tf.variable_scope会创建一个命名空间。foo/v:0 “:0”表示这个变量是生成变量这个运算的第一个结果。 TensorFlow计算图可视化命名空间与TensorBoard图上节点变量的初始化过程也会产生新的计算节点。为了更好的组织可视化效果图中的计算节点，TensorBoard支持通过TensorFlow命名空间来整理可视化效果图上的节点。在Tensorflow默认视图中同一命名空间计算图为一个节点，只有顶层命名空间的节点显示。除了tf.Variable_scope函数，tf.name_scope函数也提供了命名空间管理的功能，两者大部分情况下等价。唯一的区别是tf.get_Variable不受tf.name_scope函数的影响。即在tf.name_scope域里tf.get_Variable生成变量也不是域内的变量。节点之间有两种不同的边，一种是通过实线表示的，刻画了数据传输，箭头表示传输方向。另一种箭头是双向的，表示会修改，会互相影响。TensorBoard边上标注了张量的维度信息。如100*784说明batch为100，输入节点个数为784，粗细代表维度的总大小。若张量数量大于1时。图上将只显示张量的个数。虚线表示计算之间的依赖关系，如tf.control_dependencies函数指定操作同时进行。则存在虚线。TensorBoard会自动将连接比较多的节点放在辅助图中，可以手动移入主图或移出主图。TensorBoard不会保存用户对计算图可视化结果的手工修改，页面刷新之后计算图可视化结果又会回到最初的样子。 节点信息使用TensorBoard可以非常直观地展现所有Tensorflow计算节点在某一次运行时所消耗的时间和内存。 run_options =tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)// 运行时记录运行信息的proto。run_metadata = tf.RunMetadata() m, loss_value, step = sess.run( [train_op, loss, global_step], feed_dict={x: xs, y_: ys}, options=run_options, run_metadata=run_metadata) //将节点在运行时的信息写入日志文件。 writer.add_run_metadata(run_metadata=run_metadata,tag=(“tag%d” % i),global_step=i) 使用程序输出的日志启动TensorBoard,就可以了。进入GRAPHS栏，选择Session runs,Color会出现Compute time和Memory这两个选项。颜色越深消耗越大。Structure中如果有两个节点结构相同就会涂上相同的颜色。Device中可显示哪些使用了相同的设备（CPU/GPU）。点击节点时弹出的信息卡片也会显示这个节点的各种信息。 监控指标可视化 TensorFlow日志生成函数 TensorBoard界面栏 显示内容 tf.scalar_summary EVENTS TensorFlow中标量（scalar）监控数据随着迭代进行的变化趋势。 tf.image_summary IMAGES TensorFlow中使用的图片数据，这一栏一般用于可视化当前使用的训练/测试图片。 tf.audio_summary AUDIO TensorFlow中使用的音频数据。 tf.histogram_summary HISTOGRAMS TensorFlow中张量分布监控数据随着迭代轮次的变化趋势。 上述生成函数都不会立即执行，需要通过sess.run来明确调用这些函数。tf.merge_all_summaries()可将定义的所有日志文件执行一次。 writer writer=tf.train.SummaryWriter(path,tf.get_default_graph())writer.close() 或者 with tf.Session() as sess: writer=tf.train.SummaryWriter(path,sess.graph) 上述比较过时，若报错则改为writer = tf.summary.FileWriter(“output”, sess.graph)","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://github.com/zdkswd/tags/TensorFlow/"},{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"}]},{"title":"[Linux内核设计与实现]进程调度","slug":"进程调度","date":"2018-05-15T13:39:12.000Z","updated":"2018-05-16T11:00:02.000Z","comments":true,"path":"2018/05/15/进程调度/","link":"","permalink":"https://github.com/zdkswd/2018/05/15/进程调度/","excerpt":"","text":"多任务现代Linux系统也许有100个进程在内存，但是只有一个处于可运行状态。Linux是抢占式多任务模式。 Linux的进程调度Linux2.5内核开始采用O（1）调度程序，对大服务器工作负载很理想但对于交互性桌面系统表现不佳。2.6.23内核后使用RSDL增加了交互性，此时被称为CFS（完全公平调度算法） 策略I/O消耗型和处理器消耗型的进程GUI属于I/O消耗型，多数时间都在等待键鼠交互操作。应当降低处理器消耗型的调度频率，以延长其运行时间。Linux更倾向于IO消耗型进程，也并未忽略处理器消耗型进程。 进程优先级Linux采用了两种不同范围的优先级范围。1：使用nice值，范围【-20，19】，默认0，越大优先级越低。Linux nice代表时间片比例，mac os nice代表时间片的绝对值。2：实时优先级，其值可配。范围【0，99】，越高优先级越大。任何实时进程优先级都高于普通进程。 时间片Linux的CFS调度器并没有直接分配时间片到进程，将处理器的使用比划分给了进程。进程所获处理器的时间和负载密切相关。受nice值得影响。Linux的CFS调度器抢占时机取决于进程的处理器使用比，若大于当前进程则抢占。 调度策略的活动对于一个文字编辑程序和一个视频处理程序，一般操作系统会分配文字编辑器更高的优先级和更多的时间片。Linux则是nice值相同，即平分50%时间，但是当文字编辑程序要使用处理器时，CFS发现其时间没到50%，会抢占视频处理程序执行。 Linux调度算法调度器类Linux调度器是模块方式，可以针对不同类型的进程选择合适的调度算法。完全公平调度（CFS）是针对普通进程的调度类。 Unix系统的进程调度CFS完全摒弃时间片而是分配进程一个处理器的使用比重，这样CFS确保了进程调度有恒定的公平性，将切换频率置于不断变动中。 公平调度CFS的最小粒度（最小时间片长度）为1ms，时间片分配时间根据目标延迟以及nice值决定的比例计算而得。所以说其实如果进程无限大的话，改法并不公平。但是能保证正常情况下是公平的。 Linux调度的实现时间记账 所有的调度器都必须对进程运行时间做记账。 调度器实体结构,CFS不再有时间片的概念，但是它也必须维护每个进程运行时间记账，为了确保每个进程只在公平分配给它的处理器时间运行。CFS使用调度器实体结构struct sched_entity作为名为se的成员变量，嵌入进程描述符struct task_struct内。 虚拟实时，struct sched_entity结构中的vruntime变量存放进程的虚拟运行时间，虚拟时间是以ns为单位的，与定时器节拍不再相关。vruntime可以准确地测量给定进程的运行时间，而且可知道谁应该是下一个被运行的进程。 进程选择当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小的vruntime值的进程。红黑树是一种以树节点形式存储的数据，这些数据都对应一个键值，可通过键值快速检索节点上的数据。 挑选下一个任务，CFS调度器选取待运行的下一个进程，是所有进程中vruntime最小的那一个，对应的便是树最左侧的叶子节点。 向树中加入进程，CFS如何将进程加入rbtree中，以及如何缓存最左叶子节点。这一切发生在进程变为可运行状态（被唤醒）或是通过fork()调用第一次创建进程时。enqueue_entity()函数实现了这一目的。改函数更新运行时间和其他一些统计数据，然后调用_enqueue_entity()进行繁重的插入操作，把数据项真正插入到红黑树中。 从树中删除进程, 删除动作发生在进程堵塞或者终止时。调度器入口进程调度的主要入口点是函数schedule()，它会找到一个最高优先级的调度类，其需要有自己的可运行队列。睡眠和唤醒休眠（被阻塞）进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程刚好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。 等待队列， 等待队列是由等待某些事件发生的进程组成的简单链表。 唤醒， 唤醒指定等待队列上的所有进程。抢占和上下文切换上下文切换，就是从一个可执行进程切换到另一个可执行的进程。由函数context_switch()负责，每当新的进程被选出来准备投入运行时，schedule()就会调用该函数。内核提供了一个need_resched标志表明是否需要重新执行一次调度，内核也就知道什么时候调用schedule()。当某个进程应该被抢占或优先级高的进程进入可执行状态时或中断返回或系统调用返回用户空间，会设置标志位。用户抢占内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。即用户抢占发生在 从系统调用返回用户空间时。 从中断处理程序返回用户空间时。 内核抢占Linux完整地支持内核抢占，只要重新调度是安全的，内核就可以在任何时候抢占正在执行的内核任务。安全即没有持有锁，即preempy_count=0且need_resched被设置，中断返回内核空间时，就可调度。同样若内核阻塞或显式调用schedule()也会显式抢占。 实时调度策略Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的非实时的调度策略是SCHED_NORMAL.这些策略被一个特殊的实时调度器管理。 SCHED_FIFO, 不基于时间片，可以一直执行下去，其比任何SCHED_NORMAL级的进程都先得到调度。更高优先级的SCHED_FIFO或SCHED_RR才能抢占。优先级一样的就轮流执行。 SCHED_RR,带有时间片的SCHED_FIFO，耗尽时间片时，只能调度同一优先级的进程。【 总结】：对于SCHED_FIFO进程，高优先级总是立即抢占低优先级进程，但低优先级决不能抢占SCHED__RR任务，即使它的时间片耗尽。Linux提供的是软实时工作方式，SCHED_RR与SCHED_FIFO优先级范围【0，99】，而SCHED_NORMAL使用nice值。与调度相关的系统调度Linux提供了一个系统调用族，用于管理与调度程序的相关参数。这些系统调用可以用来操作和处理进程优先级、调度策略及处理器绑定，同时还提供了显式地将处理器交给其他进程的机制。与调度策略和优先级相关的系统调用sched_setscheduler()和sched_getscheduler()用于设置和获取进程的调度策略和实时优先级。sched_setparam()和sched_getparam()用于设置和获取进程的实时优先级。与处理器绑定有关的系统调用Linux调度程序提供强制的处理器绑定机制。放弃处理器时间Linux通过sched_yield()系统调用，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"初识makefile_make_cmake","slug":"cmake","date":"2018-04-29T14:11:20.000Z","updated":"2018-05-16T11:02:54.000Z","comments":true,"path":"2018/04/29/cmake/","link":"","permalink":"https://github.com/zdkswd/2018/04/29/cmake/","excerpt":"","text":"初识makefile,make,cmake什么是makefilemake命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。makefile关系到了整个工程的编译规则。makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 什么是makemakefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法（包括链接）。 关于程序的编译和链接在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。Linux中的.so。一个lib文件是obj文件的集合。源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码 文件路径usr文件夹称为是Unix System Resource，即Unix系统资源的缩写。 bin文件夹是一个二进制程序文件夹1.bin是binary的缩写，代表的意思是二进制，二进制数据是用0和1两个数码来表示的数。2.bin这个文件夹里存放的是二进制可执行的文件，比如exe，msi，com等的都是二进制文件，双击就能运行。 GUN下面绝大部分应用的编译系统都是用automake。于是乎，你看到的很多很多应用都安装在了/usr/local/目录下然后通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变/usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件安装好的lib文件存放在“/usr/local/lib”文件夹，h文件存放在“/usr/local/include”（Unix） 什么是cmakeCMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。 dlldll存在于windows中 openCV安装过程 mkdir releasecd releasecmake -D CMAKE_BUILD_TYPE=RELEASE -D 换行CMAKE_INSTALL_PREFIX=usr/local/opencv3.1.0 -G “Unix Makefiles” ..makesudo make install","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"软件构筑","slug":"软件构筑","permalink":"https://github.com/zdkswd/tags/软件构筑/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://github.com/zdkswd/tags/计算机科学/"}]},{"title":"李宏毅2017听课笔记1-Where does the error come from?","slug":"李宏毅error","date":"2018-04-25T14:48:13.000Z","updated":"2018-05-16T11:00:59.000Z","comments":true,"path":"2018/04/25/李宏毅error/","link":"","permalink":"https://github.com/zdkswd/2018/04/25/李宏毅error/","excerpt":"","text":"李宏毅2017听课笔记1-Where does the error come from? 这么多线是多次试验，每次试验拟合出一条红线 在这里直观的解释了为什么简单的模型偏差更大，因为最终是在函数集中选取最佳函数，因为函数简单的话，一开始划定的范围就较小。 正则化会伤害bias，因为只选择更平滑的曲线，相当于划了范围。（其实是让模型更简单了） 分为训练集，验证集，测试集","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"李宏毅","slug":"李宏毅","permalink":"https://github.com/zdkswd/tags/李宏毅/"}]},{"title":"李宏毅2017听课笔记0","slug":"李宏毅2017听课笔记0","date":"2018-04-25T01:26:25.000Z","updated":"2018-07-03T02:34:22.000Z","comments":true,"path":"2018/04/25/李宏毅2017听课笔记0/","link":"","permalink":"https://github.com/zdkswd/2018/04/25/李宏毅2017听课笔记0/","excerpt":"","text":"李宏毅2017听课笔记0前言之前听了吴恩达2014大部分的课以及吴恩达最近在网易云上的CNN课程。听闻李宏毅的课程不错，主要比较系统全面，来听一哈喽。不错的博客 0-1Introduction找出function 准备一个function set (model) 机器决定function们的好坏 找出最好的function Deep Learning：分类，非线性 Learning Map Reinforcement Learning在实际运用中，以上方法并不能解决全部问题，常常会遇到Beyond Classification的情况，比如语音识别，人脸识别，语言翻译等，那么就要通过增强学习来解决问题。增强学习的一个非常知名的应用就是 google 阿法狗。 Reinforcement Learning VS SupervisedSupervised 就像给了机器一个点读机，他听到一句话时可以看到其含义，每一句话都有标签，就像有一个手把手教他的老师。而Reinforcement Learning 就像跟女朋友对话，反复讲来回讲很多句话，直到女朋友觉得你无言以对愤然离去，机器唯一可以知道的就是他做的好还是不好，除此之外没有任何information。而这更像人类现实生活中的学习过程，必须自己像哪里做得好做得不够好，怎么修正。 Learning Map: scenario:学习情景，不受自己控制。意思是你现在有什么类型的 training data。 machine learning scenario Supervised Learning 有标签data Semi-supervised Learning 部分有标签data Unsupervised Learning 无标签data Transfer Learning 一堆不相干data Reinforcement Learning 只有来自外界的评价 task，意思是现在function的output是什么，只体现在supervised中，但其实可以插在以上五种Learning的每一种内。 machine learning task(output) Regression scalar Classification class1、class2…之一 Structured Learning 有结构的内容 Method方法模型，比如在Classification中有Linear模型 or Non-linear模型，我们可以将绿色部分插入任何红色部分中。","categories":[{"name":"听课笔记","slug":"听课笔记","permalink":"https://github.com/zdkswd/categories/听课笔记/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://github.com/zdkswd/tags/机器学习/"},{"name":"李宏毅","slug":"李宏毅","permalink":"https://github.com/zdkswd/tags/李宏毅/"}]},{"title":"[Linux内核设计与实现]进程管理","slug":"进程管理","date":"2018-04-16T10:50:51.000Z","updated":"2018-05-16T11:00:19.000Z","comments":true,"path":"2018/04/16/进程管理/","link":"","permalink":"https://github.com/zdkswd/2018/04/16/进程管理/","excerpt":"","text":"进程内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。父进程调用fork()复制现有进程创建一个全新的进程子进程。 每个线程都有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：它对线程和进程并不特别区分。进程提供两种虚拟机制，虚拟处理器与虚拟内存。一个是进程独享处理器的假象一个是独享内存资源的假象。线程之间共享虚拟内存，各自有虚拟处理器。进程的另一个名字是task，Linux内核通常把进程也叫做任务。 进程描述符及任务结构内核把进程的列表存放在任务列表（task list）的双向循环列表中。链表的每一项都是类型为task_struct称为进程描述符的结构中，该结构相对较大，包含的数据能够完整的描述一个正在运行的程序：打开的文件，进程地址空间，挂起信号，进程状态及其他。 分配进程描述符Linux通过slab分配器分配task_struct结构,这样能够对象复用和缓存着色。使用slab动态生成task_struct需要用到结构thread_info,其task域有指向实际进程描述符的指针。每个任务的thread_info在它的内核栈的尾端分配。 进程描述符的存放内核通过唯一标识符PID（process indentification value）来标识每个进程，PID存放在进程描述符。为了兼容性设置其为short int型，故其最大值为32768.但是对于大型服务器需要更大值。可以不考虑兼容性修改/proc/sys/kernel/pid_max提高上限。 内核访问任务需要获取指向task_struct的指针，故通过宏找到当前正在运行的进程描述符的速度就尤为重要。硬件的结构体系不同，宏的实现不同。例如有的体系结构有专用寄存器用于加快访问task_struct的速度，x86结构寄存器并不富余，就只能通过计算偏移间接查找task_struct。 进程状态task_struct的state域描述当前状态，必为五中之一 TASK_RUNNING(运行)在运行或在运行队列等待 TASK_INTERRUPIBLE(可中断)被阻塞 TASK_UNINTERRUPTIBLE（不可中断）接到信号也不会唤醒 _TASK_TRACED被其他进程跟踪 _TASK_STOPPED停止执行 设置当前的进程状态调整某个进程状态 set_task_state(task,state); 进程上下文可执行代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行，一般在用户空间执行，执行系统调用或触发异常陷入内核空间。对内核的访问必须经过明确定义的接口。 进程家族树Linux和Unix一样所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程读取系统初始化脚本（initscript）并执行其他相关程序最终完成系统启动整个过程。init进程的进程描述符是作为init_task静态分配的。对于当前task_struct，可以通过task_struct类型parent指针访问其父进程（必有一个），还包含一个children的子进程链表。 进程创建许多其他操作系统：首先在新的地址空间创建进程，读入可执行文件，最后开始执行。Unix：首先通过fork（）拷贝当前进程创建一个子进程，父子进程区别仅限于PID，PPID（子进程将其设为父进程PID值）和某些资源统计量。exec（）负责读取可执行文件并将其载入地址空间运行。 写时拷贝Linux的fork（）采用写时拷贝，只有子进程在父进程进行写入时再进行拷贝，其他的时候是只读共享。所以fork（）的实际开销就是复制父进程页表以及创建PID。 fork（）Linux通过clone（）系统调用实现fork（）fork（）-调用-&gt;clone()-调用-&gt;do_fork()（完成创建的大部分工作）-调用-&gt;copy_process()copy_process工作: 调用dup_task_strucr()为新进程创建一个内核栈、thread_info和task_struct，此时，父子进程描述符完全一样。 检查并确保新创建这个进程后进程数目没有超出资源限制。 子进程着手于区别父进程。task_struct的许多成员被清零或设为初始值。 子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行。 copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERRIV标志被清0，表示进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。 调用alloc_pid()为新进程分配一个分配一个有效的PID。 根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信息处理函数、进程地址空间和命名空间等。一般，这些资源会所有线程共享，否则资源对每个进程是不同的，因此拷贝到这里。 最后，copy_process做扫尾工作并返回一个指向子进程的指针。 如果copy_process()成功返回do_fork()，新创进程被唤醒且内核有意让其首先执行。因为一般子进程都会马上调用exec()函数，可以避免父进程首先执行可能的写入造成的额外开销。 vfork（）除了不拷贝父进程的页表项以外，vfork()和fork()功能相同。基本没啥用。 线程在Linux中的实现Linux中，线程具有task_struct,它看起来就是普通进程，只是和其他一些进程共享某些资源，如地址空间。对Linux来说，线程只是进程间共享资源的手段。 创建线程线程创建于进程类似，只是在调用clone时需要传递一些参数标明需要共享的资源。创建Linux进程所花时间和其他操作系统创建线程要少。 内核线程独立运行在内核空间的标准进程，和普通进程区别在于没有独立地址空间。只在内核空间运行，和普通进程一样，可以被调度，也可以被强占。新的任务是由kthread内核进程通过clone()系统调用而创建的。内核线程启动后就一直运行到调用do_exit（）退出或其他部分调用kthread_stop()退出。 进程终结终结时，释放资源并告诉父进程。可以调用exit()主动终结,也可以异常被动终结,但大部分靠do_exit()来完成do_exit(): 将task_struct标志设为PF_EXITING 调用del_time_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器在排队也没有定时器处理程序在运行。 如果BSD的记账功能是开启的，do_exit()调acct_update_integrals()来输入记账信息。 调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是说，这个进程空间没有被共享），就彻底释放它们。 调用sem_exit()函数，如果进程排队等候IPC信号，它则离开队列。 调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为0，那么久代表没有进程在使用相应的资源可以释放。 接着把存放在task_struct和exit_code成员中的任务退出代码置为由exit（）提供的退出代码，或者去完成任何其他由内核机制规定的退出动作，退出代码存放在这里供父进程随时检索。 调用exit_notufy()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或为init进程，并把进程状态（存放在task_struct中的exit_state中）设成EXIT_ZOMBIE。 do_exit()调用schedule（）切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。do_exit()永不返回。 至此进程仅剩的内存就是内核栈，Thread_info 和task_struct结构。此时进程存在的唯一目的数向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关信息后，内存释放。 删除进程描述符进程终结时的清理工作和进程描述符的删除被分开进行，这样做可以让系统有办法在子进程终结后仍能获得它的信息。过程如上段。 孤儿进程造成的进退维谷如果父进程在子进程之前退出，必须有机制来保证子进程能够找到一个新的父亲。解决方法是给子进程在当前线程组内找一个线程做父亲，如果不行，就让init做父进程。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[LINUX内核设计与实现]第二章","slug":"从内核出发","date":"2018-04-13T12:36:32.000Z","updated":"2018-05-16T10:02:54.000Z","comments":true,"path":"2018/04/13/从内核出发/","link":"","permalink":"https://github.com/zdkswd/2018/04/13/从内核出发/","excerpt":"","text":"从内核出发内核源码树内核源码树根目录描述 目录 描述 arch 特定体系结构的源码 block 块设备IO层 crypto 加密API Documentation 内核源码文档 drivers 设备驱动程序 firmware 使用某些驱动程序而需要的设备固件 fs VFS和各种文件系统 include 内核头文件 init 内核引导和初始化 ipc 进程间通信代码 kernel 像调度程序这样的核心子系统 lib 通用内核函数 mm 内存管理子系统和VM net 网络子系统 samples 实例，示范代码 scripts 编译内核所用的脚本 security Linux安全模块 sound 语音子系统 usr 早期用户空间代码（所谓的initramfs） tools 在Linux开发中有用的工具 virt 虚拟化基础结构 在源码根目录还有很多文件值得提及。COPYING文件是内核许可证（GNU GPL v2）。CREDITS是开发了很多内核代码的开发者列表。MAINTAINERS是维护者列表，负责维护内核子系统和驱动程序。Makefile是基本内核的Makefile。 编译内核配置内核在编译前可以把自己的需要的特定功能和驱动程序编译进内核，首先必须先配置，其以CONFIG_FEATURE形式表示。配置选项要么是二选一（yes/no）要么是三选一（yes/no/module）module表示这部分功能的实现代码是以模块的形式生成。驱动程序一般都是三选一选项。配置选项也可以是字符串或整数。这些选项并不控制编译过程，而只是指定内核源码可以访问的值，一般以预处理宏的形式表示。 $ make config 该工具会遍历所有配置项，但耗时过长 $make menuconfig$make gconfig 可破之。以上三种工具将所有配置分门别类的放置。 $make defconfig 创建默认配置。这些配置项被存放在根目录的.config文件中。在进行修改后，你应当验证和更新配置： $ make oldconfig 配置选项CONFIG_IKCONFIG_PROC把完整的压缩内核配置文件放在/proc/config.gz下，在编译新内核时可以克隆配置。 $zcat /proc/config.gz &gt; .config$make oldconfig 衍生多个编译作业make程序能把编译过程拆分成多个并行的作业。极大加快编译的过程。 $make -jn 安装新内核 %make modules_install 内核开发的特点 内核编程时既不能访问c库也不能访问标准c头文件。 内核编程时必须使用GNU C 内核编程时缺乏像用户空间那样的内存保护机制。 内核编程时难以执行浮点运算。 内核给每个进程只有一个很小的定长堆栈。 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。 要考虑可移植性的重要性。 无libc库或无标准头文件因为对内核来说，C库太大太低效了。但是大部分常用的C库函数在内核中都已经得到了实现。内核头文件位于根目录include目录下。&lt; linux/inotify.h&gt;对应内核include/linux/inotify.h体系结构相关的头文件位于源码树arch/&lt; architecture&gt;/include/asm目录下。内核代码通过如&lt; asm/youwant.h&gt;包含。 printk(“Hello world’%s’and ‘%d’”,str,i); 例如内核代码无法调用printf,但它提供printk()。其允许通过一个标志来设置优先级。 GNU Cgcc是多种GNU编译器的集合，它包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其他代码。 内联函数，用于时间要求高，本身长度短的函数。 定义内联函数时需要static 作为关键字，并且用inline限定它。为了类型安全和易读性，优先使用内联函数而不是复杂的宏。 内联汇编，gcc支持C函数嵌入汇编指令，需要知道其体系结构。使用asm()指令嵌入汇编代码。Linux内核混用了C语言和汇编语言。在偏近体系结构底层或对执行时间要求严格的地方，一般使用汇编语言，其他大部分代码是用C语言编写的。 分支声明，对于条件选择语句，gcc内建了优化指令，并封装成了宏。likely()和unlikely()，你的判断正确，性能会得到提升，如果判断错误，性能反而会下降。 没有内存保护机制在内核中不应该去做访问非法的内存地址，引用空指针一类的事，否则可能一声不响的死掉。内核的内存不分页。 不要轻易在内核中使用浮点数内核并不能完美地支持浮点操作，因为它本身不能陷入。在内核使用浮点数时，除了要人工保存和恢复浮点寄存器，还有一些其他的事情要处理。所以不要在内核中使用浮点操作。 容积小而固定的栈同步和并发可移植性的重要性大部分C代码应该与体系结构无关，在不同体系结构的计算机上都能够编译和执行。如保持字节序、64位对齐、不假定字长和页面长度等一系列准则都有助于移植性。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[LINUX内核设计与实现]第一章","slug":"LINUX内核设","date":"2018-04-13T11:45:41.000Z","updated":"2018-05-16T11:04:46.000Z","comments":true,"path":"2018/04/13/LINUX内核设/","link":"","permalink":"https://github.com/zdkswd/2018/04/13/LINUX内核设/","excerpt":"","text":"第一章主要是讲Linux的历史，而我的第一篇纸质书笔记主要是讲一下我的计划。纸质书做读书笔记的话，任务量会远远大于电子版的图书，所以我争取做到不引用原文，因为那样做任务量过于庞大，这就要求我必须以自己理解的方式概括，这样才能达到预期的效果。之后还会出的纸质书笔记预告：深入理解计算机系统 中英两版。深入理解安卓系统。所以说可以看出直到暑假的这一段时间，我的重点是放在c/c++以及操作系统上，之所以这样做是因为希望未来能够为Tensorflow等开源框架贡献自己的力量。希望大家可以共同学习，共同进步。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"纸质书笔记","slug":"纸质书笔记","permalink":"https://github.com/zdkswd/tags/纸质书笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/zdkswd/tags/Linux/"}]},{"title":"[猴子都能懂的Git入门]高级篇","slug":"猴子都能懂的Git入门-高级篇","date":"2018-04-08T03:09:55.000Z","updated":"2018-05-16T10:59:22.000Z","comments":true,"path":"2018/04/08/猴子都能懂的Git入门-高级篇/","link":"","permalink":"https://github.com/zdkswd/2018/04/08/猴子都能懂的Git入门-高级篇/","excerpt":"","text":"分支什么是分支分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。 master分支在数据库进行最初的提交后, Git会创建一个名为master的分支。因此之后的提交，在切换分支之前都会添加到master分支里。 分支的运用merge分支Merge分支是为了可以随时发布release而创建的分支，它还能作为Topic分支的源分支使用。保持分支稳定的状态是很重要的。如果要进行更改，通常先创建Topic分支，而针对该分支，可以使用Jenkins之类的CI工具进行自动化编译以及测试。 通常，大家会将master分支当作Merge分支使用。 Topic分支Topic分支是为了开发新功能或修复Bug等任务而建立的分支。若要同时进行多个的任务，请创建多个的Topic分支。 Topic分支是从稳定的Merge分支创建的。完成作业后，要把Topic分支合并回Merge分支。 分支的切换若要切换作业的分支，就要进行checkout操作。进行checkout时，git会从工作树还原向目标分支提交的修改内容。checkout之后的提交记录将被追加到目标分支 HEADHEAD指向的是现在使用中的分支的最后一次更新。通常默认指向master分支的最后一次更新。通过移动HEAD，就可以变更使用的分支。NOTE:提交时使用~(tilde)和^(caret)就可以指定某个提交的相对位置。最常用的就是相对于HEAD的位置。HEAD后面加上~(tilde）可以指定HEAD之前的提交记录。合并分支会有多个根节点，您可以用^(caret) 来指定使用哪个为根节点。 stashstash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。 分支的合并合并分支有2种方法：使用merge或rebase。使用这2种方法，合并后分支的历史记录会有很大的差别。 merge合并 bugfix分支到master分支时，如果master分支的状态没有被更改过,把master分支的位置移动到bugfix的最新分支上，Git 就会合并。这样的合并被称为fast-forward（快进）合并。HEAD还在原位。master分支的历史记录有可能在bugfix分支分叉出去后有新的更新。这种情况下，要把master分支的修改内容和bugfix分支的修改内容汇合起来。合并两个修改会生成一个提交。这时，master分支的HEAD会移动到该提交上。NOTE:执行合并时，如果设定了non fast-forward选项，即使在能够fast-forward合并的情况下也会生成新的提交并合并。 一个圆圈代表一个提交 rebasetopic分支和merge分支的运用实例分支操作示例建立分支 $ git branch &lt; branchname&gt; 不指定参数直接执行branch命令的话，可以显示分支列表。 前面有*的就是现在的分支。 $ git branch issue1 *master 切换分支执行checkout命令以退出分支。 $ git checkout &lt; branch&gt; NOTE:在checkout命令指定 -b选项执行，可以创建分支并进行切换。 $ git checkout -b &lt; branch&gt; 合并分支执行merge命令以合并分支。 $ git merge &lt; commit&gt; 该命令将指定分支导入到HEAD指定的分支。如当HEAD指向issue1时，先切换到master分支，然后把issue1分支导入到master分支。 $ git checkout master$ git merge issue1 删除分支在branch命令指定-d选项执行，以删除分支。 $ git branch -d &lt; branchname&gt; 用rebase合并切换到issue3分支后，对master执行rebase。 $ git checkout issue3$ git rebase master rebase的时候，修改冲突后的提交不是使用commit命令，而是执行rebase命令指定 –continue选项。若要取消rebase，指定 –abort选项。 $ git add myfile.txt$ git rebase –continue 这样，在master分支的issue3分支就可以fast-forward合并了。切换到master分支后执行合并.看来rebase是将issue3分支消失而生成一个新的提交，就像fast-forward的情形一样。切换到master分支后执行合并。 $ git checkout master$ git merge issue3 上图为rebase图 上图为merge图 Merge和rebase都是合并历史记录，但是各自的特征不同。 merge保持修改内容的历史记录，但是历史记录会很复杂。rebase历史记录简单，是在原有提交的基础上将差异内容反映进去。因此，可能导致原本的提交内容无法正常运行。您可以根据开发团队的需要分别使用merge和rebase。例如，想简化历史记录，在topic分支中更新merge分支的最新代码，请使用rebase。向merge分支导入topic分支的话，先使用rebase，再使用merge。 远端数据库pull首先确认更新的本地数据库分支没有任何的更改。这时只执行fast-forward合并。如果本地数据库的分支有新的历史记录，就需要合并双方的修改。执行pull就可以进行合并。这时，如果没有冲突的修改，就会自动创建合并提交。如果发生冲突的话，要先解决冲突，再手动提交。 fetch执行pull，远程数据库的内容就会自动合并。但是，有时只是想确认本地数据库的内容而不想合并。这种情况下，请使用fetch。执行fetch就可以取得远程数据库的最新历史记录。取得的提交会导入到没有名字的分支，这个分支可以从名为FETCH_HEAD的退出。就相当于在本地数据库建立了一个和远程数据库一样的分支，还没合并。合并后，历史记录会和pull相同。实际上pull的内容是fetch + merge组成的。 push从本地数据库push到远程数据库时，要fast-forward合并push的分支。如果发生冲突，push会被拒绝的。若要共享在本地数据库创建的分支，需要明确的push。因此，没有执行push就不会给远程数据库带来影响，因而可以自由的创建自己的分支。基本上，远程数据库共享的提交是不能修改的。如果修改的话，跟远程数据库同步的其他数据库的历史记录会变得很奇怪的。 标签标签是为了更方便地参考提交而给它标上易懂的名称。Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。轻标签：添加名称注解标签：添加名称 添加注解 添加签名一般情况下，发布标签是采用注解标签来添加注解或签名的。轻标签是为了在本地暂时使用或一次性使用。 使用标签 使用tag命令来添加标签，在&lt; tagname&gt;执行标签的名称。 $ git tag &lt; tagname&gt; 在HEAD指向的提交里添加名为apple的标签，请执行以下的命令。 $ git tag apple 如果没有使用参数而执行tag，可以显示标签列表。 $ git tag 如果在log命令添加 –decorate选项执行，可以显示包含标签资料的历史记录。 $ git log –decorate 添加注解标签若要添加注解标签，可以在tag命令指定 -a选项执行,以指定-m选项来添加注解。 $ git tag -a &lt; tagname&gt; $ git tag -am “连猴子都懂的Git” banana 如果在tag命令指定-n选项执行，可以显示标签的列表和注解。 $ git tag -n 删除标签若要删除标签，在tag命令指定 -d选项执行。 $ git tag -d &lt; tagname&gt; 改写提交修改最近的提交指定amend选项执行提交的话，可以修改同一个分支最近的提交内容和注解。 主要使用的场合：添加最近提交时漏掉的档案修改最近提交的注解 取消过去的提交在revert可以取消指定的提交内容。使用后面要提到的rebase -i或reset也可以删除提交。但是，不能随便删除已经发布的提交，这时需要通过revert创建要否定的提交。 主要使用的场合：安全地取消过去发布的提交 遗弃提交在reset可以遗弃不再使用的提交。执行遗弃时，需要根据影响的范围而指定不同的模式，可以指定是否复原索引或工作树的内容。除了默认的mixed模式，还有soft和hard模式。欲了解受各模式影响的部分，请参照下面的表格。 模式名称 HEAD的位置 索引 工作树 soft 修改 不修改 不修改 mixed 修改 修改 不修改 hard 修改 修改 修改 主要使用的场合： 复原修改过的索引的状态(mixed)彻底取消最近的提交(hard)只取消提交(soft) 提取提交在cherry-pick，您可以从其他分支复制指定的提交，然后导入到现在的分支。 主要使用的场合： 把弄错分支的提交移动到正确的地方把其他分支的提交添加到现在的分支 改写提交历史记录在rebase指定i选项，您可以改写、替换、删除或合并提交。 主要使用的场合： 在push之前，重新输入正确的提交注解清楚地汇合内容含义相同的提交。添加最近提交时漏掉的档案 汇合分支上的提交，然后一同合并到分支merge的特殊选项：squash用这个选项指定分支的合并，就可以把所有汇合的提交添加到分支上。 主要使用的场合： 汇合主题分支的提交，然后合并提交到目标分支。 改写提交训练commit –amend git commit –amend revert $ git revert HEAD 在git log中会出现–Revert “添加pull的说明” reset $ git reset –hard HEAD~~ 在git中，我们其实可以通过^和~来定位某个具体的commit，而不用每次都去敲繁琐的hash值。“^”代表父提交,当一个提交有多个父提交时，可以通过在”^”后面跟上一个数字，表示第几个父提交，”^”相当于”^1”.~&lt; n&gt;相当于连续的&lt; n&gt;个”^”.在reset之前的提交可以参照ORIG_HEAD。Reset错误的时候，在ORIG_HEAD上reset 就可以还原到reset前的状态。 $ git reset –hard ORIG_HEAD cherry-pick $ git checkout master$ git cherry-pick 99daed2 如果发生冲突，修改冲突的部分之后再提交。 用rebase -i 汇合提交若要汇合过去的提交，请用rebase -i。 $ git rebase -i HEAD~~ 两个提交就合并成一个提交了。 用rebase -i 修改提交merge –squash","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"Git","slug":"Git","permalink":"https://github.com/zdkswd/tags/Git/"}]},{"title":"[猴子都能懂的Git入门]入门篇","slug":"猴子都能懂的Git入门-入门篇","date":"2018-04-06T02:03:47.000Z","updated":"2018-05-16T10:59:40.000Z","comments":true,"path":"2018/04/06/猴子都能懂的Git入门-入门篇/","link":"","permalink":"https://github.com/zdkswd/2018/04/06/猴子都能懂的Git入门-入门篇/","excerpt":"","text":"前言不知道这是第几次学习Git了，每次都是学完过一段就忘了，这次决定自己写出点东西，深入的再把Git再过一遍。写一下自己的东西，真真正正的把Git转化为自己的东西。这次选用的资料是猴子都能懂的Git入门。之所以选用该资料是因为语言比较通俗易懂，而我也正好想把知识总结的通俗易懂一些，算是两重学习。那么话不多说，现在开始吧~~~(写到后面发现这书已经足够通俗，很难再。。。啊，失败。) Git的基础首先git是版本控制工具，用来解决大家对同一文件操作时的协作问题。Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。 管理历史数据的数据库数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。 远程数据库和本地数据库。Git的数据库分为远程数据库和本地数据库的两种。 创建数据库创建本地数据库的方法有两种：一种是创建全新的数据库，另一种是复制远程数据库。 修改记录的提交若要把文件或目录的添加和变更保存到数据库，就需要进行提交。执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也被称为revision）。Tips:不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。执行提交时，系统会要求输入提交信息。请务必输入提交信息，因为在空白的状态下执行提交会失败的。Tips:查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。以下是Git的标准注解： 第1行：提交修改内容的摘要第2行：空行第3行以后：修改的理由 请以这种格式填写提交信息。 工作树和索引在Git管理下，大家实际操作的目录被称为工作树。 在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。 Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。 凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。 教程1 Git基础Git安装略 初期设定安装Git之后，请输入您的用户名和电子邮件地址。该设置操作在安装Git后进行一次就够了。这些信息将作为提交者信息显示在更新历史中。 Git的设定被存放在用户本地目录的.gitconfig档案里。可以直接编辑配置文件。 $ git config –global user.name “&lt;用户名&gt;”$ git config –global user.email “&lt;电子邮件&gt;” $ git config –global color.ui auto //git彩色显示 可以为Git命令设定别名。例如：把「checkout」缩略为「co」，然后就使用「co」来执行命令。 $ git config –global alias.co checkout 如果在Windows使用命令行 (Git Bash), 含非ASCII字符的文件名会显示为 “\\346\\226\\260\\350\\246…”。若设定如下，就可以让含非ASCII字符的文件名正确显示了。 $ git config –global core.quotepath off 若在Windows使用命令行，您只能输入ASCII字符。所以，如果您的提交信息包含非ASCII字符，请不要使用-m选项，而要用外部编辑器输入。 外部编辑器必须能与字符编码UTF-8和换行码LF兼容。 git config –global core.editor “\\”[使用编辑区的路径]\\”” 新建数据库在目录下使用init命令将该目录移动到本地的Git数据库。 $ git init 提交文件对于一个文件，使用status命令确认工作树和索引的状态。 $ git status 将文件加入到索引，要使用add命令。在&lt; file&gt;指定加入索引的文件。用空格分割可以指定多个文件。 $ git add &lt; file&gt;..$ git add . //将所有的文件加入索引 已加入到索引，我们就可以提交文件了。 $ git commit -m “” 使用log命令，我们可以在数据库的提交记录看到新的提交。 $ git log commit ac56e474afbbe1eab9ebce5b3ab48ac4c73ad60eAuthor: eguchi &#101;&#103;&#x75;&#x63;&#x68;&#x69;&#x40;&#x6e;&#117;&#108;&#97;&#x62;&#x2e;&#x63;&#111;&#46;&#x6a;&#112;Date: Thu Jul 12 18:00:21 2012 +0900first commit 安装git的同时会安装名为gitk的工具。使用这个工具，可以在GUI下确认提交记录。 $ gitk 共享数据库push到远端数据库注意：对于别人的项目你只能 pull 不能 push，只有你自己（或有权限）的项目才能 push。或者说只有你把 ssk key 添加到账号里才能无密码 push。如果你想参与别人的开源项目，先建立自己的 github 账号，然后 fork 那个项目到自己的账号里，然后在自己的项目里修改，然后发出 pull request，然后看对方愿不愿意接受你的提交。 作者：Intopass链接：https://www.zhihu.com/question/29894004/answer/45956664来源：知乎 推送为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。所以远程数据库的修改记录就会和本地数据库的修改记录保持同步。 克隆远程数据库克隆执行克隆后，远程数据库的全部内容都会被下载。之后您在另一台机器的本地数据库上进行操作。克隆后的本地数据库的变更履历也会被复制，所以可以像原始的数据库一样进行查看记录或其他操作。 从远程服务器Pull若是共享的远程数据库由多人同时作业，那么作业完毕后所有人都要把修改推送到远程数据库。然后，自己的本地数据库也需要更新其他人推送的变更内容。 Pull进行拉取(Pull) 操作，就是从远程数据库下载最近的变更日志，并覆盖自己本地数据库的相关内容。 clone与pull的区别clone是本地没有repository时，将远程repository整个下载过来。 pull是本地有repository时，将远程repository里新的commit数据(如有的话)下载过来，并且与本地代码merge。 对远程服务器进行操作向远程数据库推送本地数据库的修改记录远程数据库命名为“origin”。 请使用remote指令添加远程数据库。在&lt; name&gt;处输入远程数据库名称，在&lt; url&gt;处指定远程数据库的URL。 $ git remote add &lt; name&gt; &lt; url&gt; TIPS:执行推送或者拉取的时候，如果省略了远程数据库的名称，则默认使用名为”origin“的远程数据库。因此一般都会把远程数据库命名为origin。 使用push命令向数据库推送更改内容。&lt; repository&gt;处输入目标地址，&lt; refspec&gt;处指定推送的分支。 $ git push &lt; repository&gt; &lt; refspec&gt;… 当执行命令时，如果您指定了-u选项，那么下一次推送时就可以省略分支名称了。但是，首次运行指令向空的远程数据库推送时，必须指定远程数据库名称和分支名称。 $ git push -u origin master 使用clone指令可以复制数据库，在&lt; repository&gt;指定远程数据库的URL，在&lt; directory&gt;指定新目录的名称。 $ git clone &lt; repository&gt; &lt; directory&gt;$ git clone https://nulab.backlog.jp/git/BLG/tutorial.git tutorial2 当在克隆的数据库目录执行推送时，您可以省略数据库和分支名称。 $ git push 使用pull指令进行拉取操作。省略数据库名称的话，会在名为origin的数据库进行pull。 $ git pull &lt; repository&gt; &lt; refspec&gt;…$ git pull origin master 合并修改记录合并在执行pull之后，进行下一次push之前，如果其他人进行了推送内容到远程数据库的话，那么你的push将被拒绝。这种情况下，在读取别人push的变更并进行合并操作之前，你的push都将被拒绝。这是因为，如果不进行合并就试图覆盖已有的变更记录的话，其他人push的变更（图中的提交C）就会丢失。 合并的时候，Git会自动合并已有的变更点！不过，也存在不能自动合并的情况。此时需要手动合并。 解决冲突如果远程数据库和本地数据库的同一个地方都发生了修改的情况下，因为无法自动判断要选用哪一个修改，所以就会发生冲突。Git会在发生冲突的地方修改文件的内容 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;这就是发生 》 =======冲突的地方 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ==分割线上方是本地数据库的内容,下方是远程数据库的编辑内容。需要手动的修改。 整合修改记录操作为了把变更内容推送到远程数据库，我们必须手动解决冲突。 $ git pull origin master 导入两方的修改，并删除多余的标示行以解决冲突 Github多人协作的三种方式 Fork 方式pull request是一个request，它的目的是让别人pull你的东西。 组织组织的所有者可以针对不同的代码仓库建立不同访问权限的团队。 合作者代码仓库的所有者可以为单个仓库增加具备只读或者读写权限的协作者。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/zdkswd/categories/读书笔记/"}],"tags":[{"name":"电子书笔记","slug":"电子书笔记","permalink":"https://github.com/zdkswd/tags/电子书笔记/"},{"name":"Git","slug":"Git","permalink":"https://github.com/zdkswd/tags/Git/"}]},{"title":"新增评论区功能","slug":"新增评论区功能","date":"2018-04-05T09:49:48.000Z","updated":"2018-05-16T11:02:14.000Z","comments":true,"path":"2018/04/05/新增评论区功能/","link":"","permalink":"https://github.com/zdkswd/2018/04/05/新增评论区功能/","excerpt":"","text":"今天算是折腾了一下评论区，不得不佩服评论区作者的脑洞。运用github issues的机制来自己创建评论区，运用插件—传送门。 在此过程中也算踩了一些坑，特别感谢有人能无私分享自己的踩坑经历–踩坑教程 我自己也顺便试着改了下模板的源码，感觉有、收获。 分享出去，如果可以帮助到更多的人，那将将是更大的快乐。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://github.com/zdkswd/tags/个人博客/"},{"name":"Gitment","slug":"Gitment","permalink":"https://github.com/zdkswd/tags/Gitment/"}]},{"title":"Hexo+ github Pages建立个人博客","slug":"Hexo+github-Pages建立个人博客","date":"2018-04-04T09:30:56.000Z","updated":"2018-05-16T11:03:32.000Z","comments":true,"path":"2018/04/04/Hexo+github-Pages建立个人博客/","link":"","permalink":"https://github.com/zdkswd/2018/04/04/Hexo+github-Pages建立个人博客/","excerpt":"","text":"折腾了一段时间，还算顺利的把博客给建立好了，以下是参考链接建立过程这个过程大体上是没有问题的，但是我碰到几个小小的问题，大家也可以参考一下 当打开配置文件时，文中说的是用记事本打开，但是我用记事本打开文本完全没有格式，再用写字板打开时，豁然开朗。 再一个就是当上传以后访问自己的首页时,输入https://zdkswd.github.io 死活打不开，我又检查了好几遍，后来直接输入zdkswd.github.io就成功进去了，之后再输入https://zdkswd.github.io 又可以愉快的访问了，感觉特别神奇，也感觉很费解。 第一篇博客就先到这里吧，这一段时间我会上传一些读书笔记，毕竟砖头书不好啃，这既是分享，又是进一步的学习，也是对我自己的一种激励。希望这个博客真正能起到学习，练习，积累，分享的作用。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"https://github.com/zdkswd/categories/知识总结/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://github.com/zdkswd/tags/个人博客/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/zdkswd/tags/Hexo/"}]}]}