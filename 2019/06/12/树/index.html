<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>树 | ZDK&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="算法">
    <meta name="description" content="二叉树">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="树">
<meta property="og:url" content="https://github.com/zdkswd/2019/06/12/树/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:description" content="二叉树">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/50f89510ad1f7570791dd12f4e9adeb4.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/18413c6597c2850b75367393b401ad60.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/14eaa820cb89a17a7303e8847a412330.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/08bd43991561ceeb76679fbb77071223.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/ab103822e75b5b15c615b68560cb2416.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%889.13.23.png">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/f3bb11b6d4a18f95aa19e11f22b99bae.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/96b3d86ed9b7c4f399e8357ceed0db2a.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/daa9fb557726ee6183c5b80222cfc5c5.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/299c615bc2e00dc32225f4d9e3490e2c.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/3f59a40e3d927f567022918d89590a5f.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/fb7b320efd59a05469d6d6fcf0c98eff.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/254a4800703d31612c0af63870260517.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/e3d9b2977d350526d2156f01960383d9.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/dd9f5a4525f5029a8339c89ad1c8159b.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/903ee0dcb62bce2f5b47819541f9069a.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/7e6ecc308fe44120f30de809822215ed.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/0e37e597737012593a93105ebbf4591e.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/603cf91f54b5db21bd02c6c5678ecf40.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/4480a314f9d83c343b8adbb28b6782ad.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/04650d9470b1e67899f5b8b7b8e33212.jpg">
<meta property="og:image" content="https://github.com/img/media/%E6%A0%91/a6c4c347b7cbdf57662bab399ed36cc3.jpg">
<meta property="og:updated_time" content="2019-06-12T13:49:29.883Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="树">
<meta name="twitter:description" content="二叉树">
<meta name="twitter:image" content="https://github.com/img/media/%E6%A0%91/50f89510ad1f7570791dd12f4e9adeb4.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="ZDK&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/tmg.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">ZDK</h5>
          <a href="mailto:2822464407@qq.com" title="2822464407@qq.com" class="mail">2822464407@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zdkswd" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">树</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">树</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-06-12T05:46:47.000Z" itemprop="datePublished" class="page-time">
  2019-06-12
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/知识总结/">知识总结</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二叉树"><span class="post-toc-number">1.</span> <span class="post-toc-text">二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#表示（存储）一颗二叉树"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">表示（存储）一颗二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#链式存储法"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">链式存储法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#顺序存储法"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">顺序存储法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉树遍历"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">二叉树遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二叉查找树"><span class="post-toc-number">2.</span> <span class="post-toc-text">二叉查找树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-二叉查找树的查找操作"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">1.二叉查找树的查找操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-二叉查找树的插入操作"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2.二叉查找树的插入操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉查找树的删除操作"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">二叉查找树的删除操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉查找树的其他操作"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">二叉查找树的其他操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#支持重复数据的二叉查找树"><span class="post-toc-number">3.</span> <span class="post-toc-text">支持重复数据的二叉查找树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉查找树的时间复杂度分析"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">二叉查找树的时间复杂度分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#散列表与二叉查找树"><span class="post-toc-number">4.</span> <span class="post-toc-text">散列表与二叉查找树</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#红黑树"><span class="post-toc-number">5.</span> <span class="post-toc-text">红黑树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#平衡二叉查找树"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">平衡二叉查找树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义一颗红黑树"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">定义一颗红黑树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#红黑树是近似平衡的"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">红黑树是近似平衡的</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实现红黑树的基本思想"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">实现红黑树的基本思想</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#插入操作的平衡调整"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">插入操作的平衡调整</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#删除操作的平衡调整"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">删除操作的平衡调整</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#针对删除节点初步调整"><span class="post-toc-number">5.6.1.</span> <span class="post-toc-text">针对删除节点初步调整</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#要求叶子节点为黑的原因"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">要求叶子节点为黑的原因</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#红黑树要点"><span class="post-toc-number">5.8.</span> <span class="post-toc-text">红黑树要点</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-树"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">树</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-06-12 13:46:47" datetime="2019-06-12T05:46:47.000Z"  itemprop="datePublished">2019-06-12</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/知识总结/">知识总结</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/18413c6597c2850b75367393b401ad60.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="表示（存储）一颗二叉树"><a href="#表示（存储）一颗二叉树" class="headerlink" title="表示（存储）一颗二叉树"></a>表示（存储）一颗二叉树</h2><p>两种方法，一种是基于指针或引用的<strong>二叉链式存储法</strong>，一种是基于数组的<strong>顺序存储法</strong>。</p>
<h3 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。</p>
<h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/14eaa820cb89a17a7303e8847a412330.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>基于数组，把根节点存储在下标i=1的位置，节点X存储在数组中下标i的位置，下标为2 <em> i的位置存储的就是左子节点，下标为2 </em> i+1的位置存储的就是右子节点。反过来下标i / 2的位置就是父节点。这样，只要知道根节点的位置（一般为了方便计算，根节点会存储在下标为1的位置）就可以把整颗树串起来。</p>
<p>如果是非完全二叉树，其实会浪费比较多的数组存储空间。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/08bd43991561ceeb76679fbb77071223.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>如果某棵二叉树是一棵完全二叉树，用数组存储是最节省内存的一种方式。因为数组存储不需要像链式存储一样额外存储左右子节点的指针。<strong>这也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</strong></p>
<p><strong>堆其实就是一种完全二叉树，最常用的存储方式就是数组。</strong></p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/ab103822e75b5b15c615b68560cb2416.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>前序是指先遍历该节点，再遍历左，右节点。后序中序同理。<br><strong>二叉树的前中后序遍历就是个递归的过程。</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%889.13.23.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p><strong>二叉树遍历的时间复杂度为：</strong><br>从遍历顺序图可以看出，每个节点最多会被访问两次，所以遍历的时间复杂度跟节点的个数n成正比，也就是二叉树遍历的时间复杂度为O(n)。</p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树最大的特点就是支持动态数据集合的快速插入删除查找操作。</p>
<p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中每个节点的值，都要小于这个节点的值，而右子树节点的值。</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/f3bb11b6d4a18f95aa19e11f22b99bae.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="1-二叉查找树的查找操作"><a href="#1-二叉查找树的查找操作" class="headerlink" title="1.二叉查找树的查找操作"></a>1.二叉查找树的查找操作</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/96b3d86ed9b7c4f399e8357ceed0db2a.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="2-二叉查找树的插入操作"><a href="#2-二叉查找树的插入操作" class="headerlink" title="2.二叉查找树的插入操作"></a>2.二叉查找树的插入操作</h2><p>插入操作类似于查找操作。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/daa9fb557726ee6183c5b80222cfc5c5.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a>二叉查找树的删除操作</h2><p>删除操作比较复杂，针对要删除节点的子节点个数的不同，分为三种情况来处理。</p>
<p><strong>第一种情况</strong>是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为nll。比如图中的删除节点55。</p>
<p><strong>第二种情况</strong>是，如果要删除的节点只有一个子节点(只有左子节点或者右子节点)，我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。</p>
<p><strong>第三种情况</strong>是，如果要删除的节点有两个子节点，这就比较复杂了。<strong>我们需要找到这个节点的右子树中的最小节点</strong>，把它替换到要删除的节点上。<strong>然后再删除掉这个最小节点</strong>，因为最小节点肯定没有左子节点(如果有左子结点，那就不是最小节点了)，所以，我们可以应用上面两条规则（情况一二）来删除这个最小节点。比如图中的删除节点18。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/299c615bc2e00dc32225f4d9e3490e2c.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p>
<h2 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a>二叉查找树的其他操作</h2><p><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)，非常高效。</strong>二叉查找树也叫二叉排序树。</p>
<h1 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h1><p>在实际开发中，二叉查找树中存储的都是对象，利用对象的某个字段作为键值(key)来构建二叉查找树，对象中其他字段叫作卫星数据。</p>
<p>如果存储的两个对象键值相同，有两个解决方法。</p>
<p><strong>第一种方法比较容易</strong>。二又查找树中每一个节点不仅会存储一个数据， 通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
<p><strong>第二种不好理解但是更加优雅。</strong>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/3f59a40e3d927f567022918d89590a5f.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/fb7b320efd59a05469d6d6fcf0c98eff.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/254a4800703d31612c0af63870260517.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/e3d9b2977d350526d2156f01960383d9.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是<strong>平衡二叉查找树</strong>。平衡二叉查找树的高度接近logn,所以插入、删除、查找操作的时间复杂度也比较稳定，是<strong>O(logn)</strong>。</p>
<h1 id="散列表与二叉查找树"><a href="#散列表与二叉查找树" class="headerlink" title="散列表与二叉查找树"></a>散列表与二叉查找树</h1><p>散列表的插入、删除、查找操作的时间复杂度做到常量级O(1),而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)。<br>相比散列表二叉查找树的优势：</p>
<ol>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据序列。</li>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在<strong>O(logn)</strong>。</li>
<li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为<strong>哈希冲突</strong>的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
<li>最后，为了避免过多的散列冲突,散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，会浪费一定的存储空间。</li>
</ol>
<p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><strong>红黑树是一种平衡二叉查找树</strong></p>
<h2 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h2><p><strong>定义：二叉树中任意一个节点的左右子树高度相差不能大于1.</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/dd9f5a4525f5029a8339c89ad1c8159b.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>最先发明出的平衡二叉查找树是<strong>AVL树</strong>，严格符合定义。是一种高度平衡的二叉查找树。</p>
<p>很多平衡二叉查找树其实并没有严格符合上面的定义(树中任意一个节点的左右子树的高度相差不能大于1)。发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。平衡二叉查找树中“<strong>平衡</strong>”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些， 相应的插入、删除、查找等操作的效率高一些。</p>
<h2 id="定义一颗红黑树"><a href="#定义一颗红黑树" class="headerlink" title="定义一颗红黑树"></a>定义一颗红黑树</h2><p>红黑树：</p>
<ol>
<li>根节点是黑色的; </li>
<li>每个叶子节点都是黑色的空节点(NIL)， 也就是说， 叶子节点不存储数据;</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的;</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点;</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/903ee0dcb62bce2f5b47819541f9069a.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>暂时先将黑色的空的叶子节点都省略掉了。</strong></p>
<h2 id="红黑树是近似平衡的"><a href="#红黑树是近似平衡的" class="headerlink" title="红黑树是近似平衡的"></a>红黑树是近似平衡的</h2><p><strong>“平衡” 的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。</strong></p>
<p>红黑树的高度：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/7e6ecc308fe44120f30de809822215ed.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>完全二叉树的高度近似log2n, 这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过logn。</p>
<p>加上红色节点，最长路径不会超过2logn，也就是红黑树的高度近似2logn。</p>
<p>红黑树的高度只比高度平衡的AVL树的高度(logn)仅仅大了一倍,在性能上,下降得并不多。这样推导岀来的结果不够精确,实际上红黑树的性能更好。</p>
<p>Treap、Splay Tree,绝大部分情况下操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说并不适用。<br>AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊, AVL树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。<br>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，更倾向于这种性能稳定的平衡二叉查找树。</p>
<h2 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h2><p>红黑树的平衡过程跟魔方复原非常神似，大致过程就是:<strong>遇到什么样的节点排布，就对应怎么去调整。</strong>只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。</p>
<p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，“平衡调整”,实际上就是要把被破坏的第三、第四点恢复过来。</p>
<p>左旋与右旋：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/0e37e597737012593a93105ebbf4591e.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h2><p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</strong>关于插入操作的平衡调整，有这样两种<strong>特殊情况</strong>。</p>
<ol>
<li>如果插入节点的父节点是黑色的，就什么都不用做，仍然满足红黑树的定义。</li>
<li>如果插入的节点是根节点，则直接改变它的颜色，把它变成黑色就可以了。</li>
</ol>
<p>除此之外，其他情况都会违背红黑树的定义，于是就需要进行调整，调整的过程包含两种基础的操作:<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p>
<p>红黑树的平衡调整过程是一个<strong>迭代</strong>的过程。正在处理的节点叫作<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p>
<p>新节点插入后，如果红黑树平衡被打破，一般会有三种情况，需要根据每种情况的特点不断调整，让红黑树继续符合定义，即继续保持平衡。</p>
<p><strong>case 1:如果关注节点是a，叔叔节点d是红色</strong>，依次执行下面操作：</p>
<ol>
<li>将关注节点a的父节点b、叔叔节点d的颜色都设置成黑色;</li>
<li>将关注节点a的祖父节点c的颜色设置成红色;</li>
<li>关注节点变成a的祖父节点c;</li>
<li>跳到CASE 2或者CASE 3。</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/603cf91f54b5db21bd02c6c5678ecf40.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>case2:如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点</strong>，依次执行下面操作：</p>
<ol>
<li>关注节点变成节点a的父节点b</li>
<li>围绕新的关注节点b左旋</li>
<li>跳到CASE3</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/4480a314f9d83c343b8adbb28b6782ad.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>CASE 3:如果关注节点是a,它的叔叔节点d是黑色，关注节点a是其父节点b的左子节点，</strong>依次执行下面的操作:</p>
<ol>
<li>围绕关注节点a的祖父节点c右旋;</li>
<li>将关注节点a的父节点b、兄弟节点c的颜色互换。</li>
<li>调整结束</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/04650d9470b1e67899f5b8b7b8e33212.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h2><p>删除操作的平衡调整分为两步。<br><strong>第一步是针对删除节点初步调整。</strong>初步调整是保证整颗红黑树在一个节点删除之后，仍然满足最后一条定义的要求，就是每个节点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。<br><strong>第二步是针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p>
<h3 id="针对删除节点初步调整"><a href="#针对删除节点初步调整" class="headerlink" title="针对删除节点初步调整"></a>针对删除节点初步调整</h3><p>经过初步调整后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色。有些节点会被标记成两种颜色，“红黑”或“黑黑”。</p>
<p><strong>case1：如果要删除的节点时a，它只有一个子节点b。</strong>依次进行下面的操作：</p>
<ol>
<li>删除节点a,并且把节点b替换到节点a的位置，这一部分操作跟普通的二叉查找树的删除操作一样。</li>
<li>节点a只能是黑色，节点b也只能是红色，其他情况均不符合红黑树的定义。这种情况下，把节点b改为黑色。</li>
<li>调整结束，不需要进行二次调整。</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/media/%E6%A0%91/a6c4c347b7cbdf57662bab399ed36cc3.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>CASE 2:如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c</strong>。</p>
<p>太多且复杂，有的放矢不记了☺</p>
<h2 id="要求叶子节点为黑的原因"><a href="#要求叶子节点为黑的原因" class="headerlink" title="要求叶子节点为黑的原因"></a>要求叶子节点为黑的原因</h2><p>之所以有这么奇怪的要求就是为了实现起来方便，只要满足这一条要求，在任何时刻，红黑树的平衡操作都可以归结为我们刚刚讲的那几种情况。</p>
<p>给红黑树添加黑色的空的叶子节点，不会比较浪费存储空间。虽然在讲解或者画图的时候，每个黑色的、空的叶子节点都是独立画出来的。实际上，在具体实现的时候，只需要共用一个黑色的、空的叶子节点就行了。</p>
<h2 id="红黑树要点"><a href="#红黑树要点" class="headerlink" title="红黑树要点"></a>红黑树要点</h2><p><strong>第一点，把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。</strong></p>
<p><strong>第二点,找准关注节点,不要搞丢、搞错关注节点。</strong></p>
<p><strong>第三点，插入操作的平衡调整比较简单，但是删除操作就比较复杂</strong>。针对删除操作，有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-06-12T13:49:29.883Z" itemprop="dateUpdated">2019-06-12 21:49:29</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://github.com/zdkswd">
            <img src="/img/tmg.jpg" alt="ZDK">
            ZDK
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2019/06/12/树/&title=《树》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2019/06/12/树/&title=《树》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2019/06/12/树/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《树》 — ZDK's blog&url=https://github.com/zdkswd/2019/06/12/树/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2019/06/12/树/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/06/12/堆/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">堆</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/06/11/哈希算法/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">哈希算法</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz",
            appKey: "gkBx5soQkBREmER84PWbNJeM",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>ZDK &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/zdkswd/2019/06/12/树/&title=《树》 — ZDK's blog&pic=https://github.com/zdkswd/img/tmg.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/zdkswd/2019/06/12/树/&title=《树》 — ZDK's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/zdkswd/2019/06/12/树/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《树》 — ZDK's blog&url=https://github.com/zdkswd/2019/06/12/树/&via=https://github.com/zdkswd" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/zdkswd/2019/06/12/树/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://github.com/zdkswd/2019/06/12/树/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'zdk'blog';
            clearTimeout(titleTime);
        } else {
            document.title = '';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
