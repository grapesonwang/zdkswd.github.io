<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta property="og:type" content="website">
<meta property="og:title" content="ZDK&#39;s blog">
<meta property="og:url" content="https://github.com/zdkswd/page/17/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZDK&#39;s blog">



  <link rel="alternate" href="/atom.xml" title="ZDK's blog" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="https://github.com/zdkswd/page/17/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ZDK's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZDK's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/10/21/JavaScript标准参考教程 DOM 事件模型/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/21/JavaScript标准参考教程 DOM 事件模型/" class="post-title-link" itemprop="url">JavaScript标准参考教程 DOM 事件模型</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-21 14:53:56 / 修改时间：14:55:42" itemprop="dateCreated datePublished" datetime="2018-10-21T14:53:56+08:00">2018-10-21</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/教程/" itemprop="url" rel="index"><span itemprop="name">教程</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/21/JavaScript标准参考教程 DOM 事件模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/21/JavaScript标准参考教程 DOM 事件模型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/10/21/JavaScript标准参考教程 DOM 事件模型/" class="post-meta-item leancloud_visitors" data-flag-title="JavaScript标准参考教程 DOM 事件模型">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件。</p>
<h1 id="EventTarget接口"><a href="#EventTarget接口" class="headerlink" title="EventTarget接口"></a>EventTarget接口</h1><p>DOM 的事件操作（监听和触发），都定义在<strong>EventTarget</strong>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<strong>XMLHttpRequest</strong>、<strong>AudioNode</strong>、<strong>AudioContext</strong>）也部署了这个接口。</p>
<p>该接口主要提供三个实例方法。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.51.27.png" alt=""></p>
<h2 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h2><p>EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.52.13.png" alt=""><br>该方法接受三个参数。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.54.27.png" alt=""><br>例子：<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.56.50.png" alt=""><br>关于参数：</p>
<ol>
<li>第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%889.58.28.png" alt=""></li>
<li>第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.03.24.png" alt=""></li>
</ol>
<p>addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除。</p>
<p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.06.26.png" alt=""><br>监听函数内部的this，指向当前事件所在的那个对象。</p>
<h2 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h2><p>EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.08.15.png" alt=""><br>removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.11.58.png" alt=""></p>
<h2 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h2><p>EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.15.02.png" alt=""><br>dispatchEvent方法的参数是一个Event对象的实例。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.28.58.png" alt=""><br>如果dispatchEvent方法的参数为空，或者不是一个有效的事件对象，将报错。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.32.55.png" alt=""></p>
<h1 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h1><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript有三种方法，可以为事件绑定监听函数。</p>
<h2 id="HTML的on-属性"><a href="#HTML的on-属性" class="headerlink" title="HTML的on-属性"></a>HTML的on-属性</h2><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.34.40.png" alt=""><br>注意，这些属性的值是将会执行的代码，而不是一个函数。一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p>
<p>使用这个方法指定的监听代码，只会在冒泡阶段触发。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.38.02.png" alt=""><br>上面代码中，&lt; button&gt;是&lt; div&gt;的子元素。&lt; button&gt;的click事件，也会触发&lt; div&gt;的click事件。由于on-属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出1，再输出2，即事件从子元素开始冒泡到父元素。</p>
<p>直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.38.53.png" alt=""></p>
<h2 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h2><p>元素节点对象的事件属性，同样可以指定监听函数。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.42.25.png" alt=""><br>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>
<p>注意，这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。</p>
<h2 id="EventTarget-addEventListener-1"><a href="#EventTarget-addEventListener-1" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h2><p>所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.43.49.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</li>
<li>“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。</li>
<li>EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.50.52.png" alt=""><h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1>监听函数内部的this指向触发事件的那个元素节点。<h1 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h1>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.54.01.png" alt=""><br>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.58.42.png" alt=""><br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8810.59.12.png" alt=""><h1 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h1>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8A%E5%8D%8811.00.55.png" alt=""><br>上面代码中，click事件的监听函数定义在&lt; ul&gt;节点，但是实际上，它处理的是子节点&lt; li&gt;的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个&lt; li&gt;节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</li>
</ol>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。</p>
<p>但是，stopPropagation方法只会阻止事件的传播，不会阻止该事件触发&lt; p&gt;节点的其他click事件的监听函数。也就是说，不是彻底取消click事件。</p>
<p>如果想要彻底阻止这个事件的传播，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.31.25.png" alt=""></p>
<h1 id="Event对象概述"><a href="#Event对象概述" class="headerlink" title="Event对象概述"></a>Event对象概述</h1><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。</p>
<p>Event对象本身就是一个构造函数，可以用来生成新的实例。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.35.54.png" alt=""><br>Event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.36.52.png" alt=""><br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.38.52.png" alt=""><br>上面代码新建一个look事件实例，然后使用dispatchEvent方法触发该事件。</p>
<p>注意，如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数。</p>
<h1 id="Event对象的实例属性"><a href="#Event对象的实例属性" class="headerlink" title="Event对象的实例属性"></a>Event对象的实例属性</h1><h2 id="Event-bubbles，Event-eventPhase"><a href="#Event-bubbles，Event-eventPhase" class="headerlink" title="Event.bubbles，Event.eventPhase"></a>Event.bubbles，Event.eventPhase</h2><p>Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，Event构造函数生成的事件，默认是不冒泡的。</p>
<p>Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.51.04.png" alt=""><br>Event.eventPhase的返回值有四种可能。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.51.21.png" alt=""></p>
<h2 id="Event-cancelable，Event-cancelBubble，event-defaultPrevented"><a href="#Event-cancelable，Event-cancelBubble，event-defaultPrevented" class="headerlink" title="Event.cancelable，Event.cancelBubble，event.defaultPrevented"></a>Event.cancelable，Event.cancelBubble，event.defaultPrevented</h2><p>Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p>
<p>大多数浏览器的原生事件是可以取消的。比如，取消click事件，点击链接将无效。但是除非显式声明，Event构造函数生成的事件，默认是不可以取消的。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%881.54.01.png" alt=""><br>当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>
<p>如果事件不能取消，调用Event.preventDefault()会没有任何效果。所以使用这个方法之前，最好用Event.cancelable属性判断一下是否可以取消。</p>
<p>Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。</p>
<h2 id="Event-currentTarget，Event-target"><a href="#Event-currentTarget，Event-target" class="headerlink" title="Event.currentTarget，Event.target"></a>Event.currentTarget，Event.target</h2><p>Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</p>
<p>Event.target属性返回原始触发事件的那个节点。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.07.03.png" alt=""><br>也就是currentTarget—&gt;p节点。&lt; em&gt;子节点上面点击，则e.target指向&lt; em&gt;子节点，导致&lt; em&gt;子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个para都将不可见。</p>
<h2 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h2><p>Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.09.09.png" alt=""></p>
<h2 id="Event-timeStamp"><a href="#Event-timeStamp" class="headerlink" title="Event.timeStamp"></a>Event.timeStamp</h2><p>Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.10.05.png" alt=""><br>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>
<h2 id="Event-isTrusted"><a href="#Event-isTrusted" class="headerlink" title="Event.isTrusted"></a>Event.isTrusted</h2><p>Event.isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个click事件，该事件是用户产生的；Event构造函数生成的事件，则是脚本产生的。</p>
<h2 id="Event-detail"><a href="#Event-detail" class="headerlink" title="Event.detail"></a>Event.detail</h2><p>Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于click和dbclick事件，Event.detail是鼠标按下的次数（1表示单击，2表示双击，3表示三击）；对于鼠标滚轮事件，Event.detail是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>
<h1 id="Event-对象的实例方法"><a href="#Event-对象的实例方法" class="headerlink" title="Event 对象的实例方法"></a>Event 对象的实例方法</h1><h2 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h2><p>Event.preventDefault方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的cancelable属性为true，如果为false，调用该方法没有任何效果。</p>
<p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用stopPropagation()或stopImmediatePropagation()方法。</p>
<h2 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h2><p>stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>
<h2 id="Event-stopImmediatePropagation"><a href="#Event-stopImmediatePropagation" class="headerlink" title="Event.stopImmediatePropagation()"></a>Event.stopImmediatePropagation()</h2><p>Event.stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比Event.stopPropagation()更彻底。</p>
<h2 id="Event-composedPath"><a href="#Event-composedPath" class="headerlink" title="Event.composedPath()"></a>Event.composedPath()</h2><p>Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>
<h1 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h1><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.32.39.png" alt=""><br>CustomEvent()构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。CustomEvent的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.34.04.png" alt=""><br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-21%20%E4%B8%8B%E5%8D%882.35.03.png" alt=""><br>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有detail属性。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/10/15/3Blue1Brown线性代数/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/15/3Blue1Brown线性代数/" class="post-title-link" itemprop="url">3Blue1Brown线性代数</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-15 18:05:32" itemprop="dateCreated datePublished" datetime="2018-10-15T18:05:32+08:00">2018-10-15</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-29 21:41:30" itemprop="dateModified" datetime="2019-03-29T21:41:30+08:00">2019-03-29</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/听课笔记/" itemprop="url" rel="index"><span itemprop="name">听课笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/15/3Blue1Brown线性代数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/15/3Blue1Brown线性代数/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/10/15/3Blue1Brown线性代数/" class="post-meta-item leancloud_visitors" data-flag-title="3Blue1Brown线性代数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="向量究竟是什么"><a href="#向量究竟是什么" class="headerlink" title="向量究竟是什么"></a>向量究竟是什么</h1><p>在数学中向量以原点为起点，在空间中是一个有向的箭头，每一个位置上的数值代表在对应轴上的数值。为了与点区分，所以向量竖着写。</p>
<p>向量的加法<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.07.07.png" alt=""></p>
<p>向量的乘法<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.11.28.png" alt=""></p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.14.09.png" alt=""></p>
<p><strong>线性代数围绕两种基本运算：向量加法与向量数乘。</strong></p>
<h1 id="线性组合、张成的空间与基"><a href="#线性组合、张成的空间与基" class="headerlink" title="线性组合、张成的空间与基"></a>线性组合、张成的空间与基</h1><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.17.56.png" alt=""><br>基向量。</p>
<p><strong>当我们用数字描述向量时，都依赖于我们所选择的基。</strong><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.20.13.png" alt=""><br>在二维空间中，如果<strong>v</strong>,<strong>w</strong>不共线且不为零向量，那么理论上a<strong>v</strong>+b<strong>w</strong>就可以表示二维空间中所有的向量。 </p>
<p>为什么叫线性组合，如果固定其中一个向量那么只能表示部分向量，这些向量的末端构成一条直线。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.28.56.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.30.14.png" alt=""></p>
<p><strong>两个向量张成的空间实际上是问仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么。</strong></p>
<p><strong>向量VS点</strong>：<br><strong>可以用点来代替一个起点为原点，终点在该点上的一个向量。</strong></p>
<p>三维向量：</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.36.58.png" alt=""><br>三个向量的线性组合的张成空间同理。 </p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.46.04.png" alt=""></p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.46.40.png" alt=""><br>线性相关：一个向量在其他向量线性组合的张成空间中，即这个向量没有提高所有向量组成的张成空间的维度。</p>
<p>线性无关：每一个向量都起到了提高张成空间维度的作用。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.49.53.png" alt=""></p>
<h1 id="矩阵与线性变换"><a href="#矩阵与线性变换" class="headerlink" title="矩阵与线性变换"></a>矩阵与线性变换</h1><p>变换只不过是函数的一种花哨说法，它接收输入内容，并输出对应结果。在线性代数中考虑的是向量输入，输出一个向量。那为什么不用函数这个词呢？变换这个词在暗示用<strong>运动</strong>去思考。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%884.55.49.png" alt=""></p>
<p>如果一个变换有以下两条性质，我们就称它是线性的：一是直线在变换后仍然保持为直线，不能有所弯曲。二是原点保持固定。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.30.01.png" alt=""><br>如上不是线性变换。 </p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.30.34.png" alt=""><br>如上为线性变换</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.31.32.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.31.51.png" alt=""></p>
<p>变换后的坐标。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.34.17.png" alt=""></p>
<p>由于线性变换后对于基向量的线性组合的值不变，所以只需要知道基向量的变换就可以算出变换后的任意向量的坐标。<br> 变换后的<strong>i</strong>,<strong>j</strong>。一个在<strong>标准网格</strong>的坐标系中的一个向量(x,y)<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.36.36.png" alt=""></p>
<p>一个二维线性变换仅由四个数字完全确定。变换后i帽的两个坐标与变换后j帽的两个坐标（<strong>标准网格下的坐标</strong>）。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.39.51.png" alt=""></p>
<p> 矩阵在这里只是一个记号，它含有描述一个线性变换的信息。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.44.09.png" alt=""></p>
<h1 id="矩阵乘法与线性变换复合"><a href="#矩阵乘法与线性变换复合" class="headerlink" title="矩阵乘法与线性变换复合"></a>矩阵乘法与线性变换复合</h1><p>两个独立变换可以进行复合变换<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.50.38.png" alt=""><br>先旋转再剪切。</p>
<p>两个矩阵相乘有着几何意义，也就是两个线性变换相继作用</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%886.52.41.png" alt=""><br>之所以能这么做是因为它们都在同一个坐标系下，即标准网格坐标系。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.03.09.png" alt=""><br>三维空间中的线性变换同理。</p>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.14.42.png" alt=""><br>描述一个线性变换是让面积（对二维来说是面积，三维就是体积）拉伸还是挤压了。</p>
<p>也就是说如果一个行列式为0，那就是变换后成了一条线（对二维俩说）。推广就是计算一个矩阵的行列式，我们就能了解这个矩阵代表的变换是否将空间压缩到更小的维度上。</p>
<p>当空间定向改变的情况发生时，原本j在i的左侧，现在j在i的右侧了，行列式为负。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-13%20%E4%B8%8B%E5%8D%887.28.26.png" alt=""></p>
<h1 id="逆矩阵、列空间与零空间"><a href="#逆矩阵、列空间与零空间" class="headerlink" title="逆矩阵、列空间与零空间"></a>逆矩阵、列空间与零空间</h1><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.39.13.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.39.38.png" alt=""></p>
<p>逆矩阵就是逆变换。只要变换不讲空间压缩到更低维度，就有逆变换。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.21.08.png" alt=""><br>即使压缩到更低的维度，解依然有可能存在，当<strong>x</strong>恰好在直线上时，解就存在。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.48.03.png" alt=""></p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%889.53.38.png" alt=""><br>列空间就是矩阵的列所张成的空间。秩的更精确的定义是列空间的维数。满秩是指输入空间的维度等于矩阵的秩。对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身。对于非满秩的变换，将维度压缩到更低的维度，也就是说会有一系列的向量会压缩到原点。在变换后落在原点的向量集合，被称为所选矩阵的<strong>零空间</strong>或<strong>核</strong>。</p>
<h1 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h1><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.40.18.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.50.54.png" alt=""><br>几何意义是将二维空间映射到三维空间上。矩阵有两列表明输入空间有两个基向量，三维是表明变换到了三维空间坐标系中，张成空间为三维空间的一个过原点的二维平面，矩阵依然是满秩的，因为列空间的维数与输入空间的维数相等。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.46.56.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.47.30.png" alt=""></p>
<h1 id="点积与对偶性"><a href="#点积与对偶性" class="headerlink" title="点积与对偶性"></a>点积与对偶性</h1><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.52.35.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8810.53.26.png" alt=""><br>这里可以看做是二维空间压缩到一维的数轴上，由于变换是线性的，所以可以用一个1*2的矩阵来表示变换。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8A%E5%8D%8811.07.02.png" alt=""></p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.19.44.png" alt=""></p>
<h1 id="叉乘的标准介绍"><a href="#叉乘的标准介绍" class="headerlink" title="叉乘的标准介绍"></a>叉乘的标准介绍</h1><p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.08.52.png" alt=""></p>
<p>顺序不同，正负不同。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.11.06.png" alt=""></p>
<p>这里才是真正的叉乘：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.13.41.png" alt=""><br>方向右手定则。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.15.29.png" alt=""></p>
<h1 id="以线性变换的眼光看叉乘"><a href="#以线性变换的眼光看叉乘" class="headerlink" title="以线性变换的眼光看叉乘"></a>以线性变换的眼光看叉乘</h1><p>为什么上述的式子中要用到ijk?下面就来解释。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.22.32.png" alt=""><br>真正的三维向量的叉乘接收两个向量并输出一个向量。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.37.19.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.31.41.png" alt=""><br>这个函数的几何意义在于，对于任一输入的向量（x,y,z),你都考虑它和v,w确定的平行六面体得到它的体积，然后根据取向确定符号。<strong>这个函数是线性的</strong>。</p>
<p>一旦知道它是线性的，就可以知道可以通过矩阵乘法来描述这个函数。具体地说，因为这个函数从三维空间到一维空间，就会存在一个1*3矩阵来代表这个变换。根据对偶性，从多维空间到一维空间的变换的特别之处在于可以将整个变换看做与这个特定向量的点积。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.42.28.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.45.53.png" alt=""></p>
<p>我们要找的就是<strong>P</strong>，使得p与其他任意向量（x,y,z）的点积等于一个3* 3矩阵的行列式。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.51.10.png" alt=""><br>从算数角度上来说<strong>p</strong>就是 （。。。。）i+（。。。。）j+（。。。。）k<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.56.06.png" alt=""></p>
<p>从几何的角度：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.33.14.png" alt=""><br>左边式子，向量p与其他向量的点积的几何解释，是将其他向量投影到p上。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.59.20.png" alt=""><br>右面式子是(x,y,z)的垂直分量*底部面积。和垂直于v,w且长度等于平行四边形面积的向量与（x,y,z）点乘一样。所以p垂直v,w且长度为平行四边形的面积。</p>
<p>所以<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%882.33.43.png" alt=""></p>
<h1 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h1><p>线性变换中一个坐标系中的所有向量都跟着动，变换后的向量仍旧是相同的线性组合，不过使用的是新的基向量。基变换中，一个向量是不动的，动的是坐标系。</p>
<p>詹的坐标系：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.52.23.png" alt=""></p>
<p>一个我们坐标系中的向量：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.53.29.png" alt=""></p>
<p>詹系中对它的描述：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.54.11.png" alt=""></p>
<p>詹的基在我们系中的向量坐标：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.55.53.png" alt=""></p>
<p>詹的基自己的坐标：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.56.30.png" alt=""></p>
<p>不同的坐标系（基）对于空间内同一个向量的描述是不同的，也就是描述的语言不同。</p>
<p>不同的基的坐标原点是重合的。如何在不同的坐标系之间进行转化：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.00.10.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.00.37.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.02.18.png" alt="">式1</p>
<p>就是将（-1，2）进行线性变换后，可以变为黄色的向量。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.10.57.png" alt=""><br>可以把这个式子看作是我们把我们对詹的误解（詹的坐标系下的数值直接拿到标准网格坐标系里）转化为真实的詹的所指，都是在标准网格坐标系下。</p>
<p>同理，如果取逆。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.14.43.png" alt=""><br>这时可以求在标准网格坐标系中的某点，在詹坐标系下的值。可在式一两侧左边同时乘以逆来很好的推出。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%883.43.07.png" alt=""></p>
<p>如果想要旋转90度，詹的基该如何表示？<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.24.13.png" alt=""></p>
<p>开始是一个詹下的向量：<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.24.54.png" alt=""></p>
<p>我们转为我们的语言，在标准网格下的一个向量。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.25.31.png" alt=""></p>
<p>此时再进行旋转操作。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.27.35.png" alt=""></p>
<p>最后左乘一个逆矩阵，将其转换为詹的语言。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.28.35.png" alt=""></p>
<p>这就是詹的语言下旋转的操作。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.29.56.png" alt=""></p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.31.20.png" alt=""></p>
<h1 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h1><p>在线性变换中，有的向量并不改变方向，只是拉伸或者缩小。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.36.01.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.36.17.png" alt=""></p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.37.25.png" alt="">、<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.37.36.png" alt=""></p>
<p>这些向量就叫特征向量，每个特征向量都有一个所属的值，拉伸倍数叫做特征值。</p>
<p>如果在三维变化中找到这个特征向量，那它就是旋转轴</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%20%E4%B8%8B%E5%8D%884.44.15.png" alt=""></p>
<h1 id="抽象空间本质"><a href="#抽象空间本质" class="headerlink" title="抽象空间本质"></a>抽象空间本质</h1><p>向量是什么？</p>
<p>从某种意义上来说函数也是向量。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%884.55.07.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%884.56.24.png" alt=""><br>x,y,z是三个点的纵坐标。</p>
<p>同时也存在另一个函数转换为另一个函数的操作（对应线性变化），例如求导。</p>
<p><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.03.26.png" alt=""><br>可见函数是线性的。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.13.36.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.13.57.png" alt=""><br>抽象性带来的好处是我们能得到一般性的结论。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.16.06.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.16.48.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.17.55.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.19.29.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.21.15.png" alt=""></p>
<p>所以，什么是向量？数学中有许多类似向量的事物，只要你处理的对象集具有合理的数乘和相加概念，线性代数中所有关于向量、线性变换和其他等产生的概念都应该适用于它。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.23.58.png" alt=""></p>
<p>这些类似向量的事物，比如箭头、一组数、函数等，它们构成的集合被称为“向量空间”。<br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.24.40.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.26.16.png" alt=""><br><img src="/img/media/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-15%20%E4%B8%8B%E5%8D%885.28.52.png" alt=""><br>如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足八条公理。这些公理是一个接口，一边连着应用线代的人，另一边是数学家。</p>
<p>只要满足八条公理，就可以将线代应用到你的研究对象上，而数学家则是根据这些公理证明了你的结论。</p>
<p>向量可以是任何东西，只要它满足公理。回答向量是什么，就像回答3是什么一样。</p>
<p><strong>普适的代价是抽象。</strong></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/10/13/机器学习数学基础上/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/13/机器学习数学基础上/" class="post-title-link" itemprop="url">机器学习数学基础上</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-13 19:08:47" itemprop="dateCreated datePublished" datetime="2018-10-13T19:08:47+08:00">2018-10-13</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-06 13:38:12" itemprop="dateModified" datetime="2018-11-06T13:38:12+08:00">2018-11-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/听课笔记/" itemprop="url" rel="index"><span itemprop="name">听课笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/13/机器学习数学基础上/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/13/机器学习数学基础上/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/10/13/机器学习数学基础上/" class="post-meta-item leancloud_visitors" data-flag-title="机器学习数学基础上">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><p>见李宏毅第0课。</p>
<h2 id="得分函数"><a href="#得分函数" class="headerlink" title="得分函数"></a>得分函数</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.09.50.png" alt=""><br>权重需要训练得到。</p>
<h2 id="损失函数最优化"><a href="#损失函数最优化" class="headerlink" title="损失函数最优化"></a>损失函数最优化</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.13.25.png" alt=""><br>左边是非凸函数，右边是凸函数。通过优化损失函数来调整权值。</p>
<h2 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h2><p>琴生不等式<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.45.36.png" alt=""></p>
<h1 id="微积分基础"><a href="#微积分基础" class="headerlink" title="微积分基础"></a>微积分基础</h1><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8A%E5%8D%8810.19.40.png" alt=""><br>梯度是一个点上升最快的方向。<br>梯度下降法。</p>
<h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>通俗语言适合于说给对方听，数学记号适合于写给对方看，精确描述比较啰嗦但是非常精确不会造成误解，主要用于证明。不会出错。</p>
<p>无穷小的阶数。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.17.33.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.18.09.png" alt=""></p>
<h2 id="微分学"><a href="#微分学" class="headerlink" title="微分学"></a>微分学</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.28.02.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.30.08.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.30.51.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.35.52.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.38.27.png" alt=""></p>
<p>求导用链式法则。</p>
<h2 id="积分学"><a href="#积分学" class="headerlink" title="积分学"></a>积分学</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.19.43.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.20.29.png" alt=""></p>
<h2 id="泰勒级数。"><a href="#泰勒级数。" class="headerlink" title="泰勒级数。"></a>泰勒级数。</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.51.28.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%887.56.21.png" alt=""></p>
<h2 id="牛顿法与梯度下降法"><a href="#牛顿法与梯度下降法" class="headerlink" title="牛顿法与梯度下降法"></a>牛顿法与梯度下降法</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.29.48.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.32.10.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.38.35.png" alt=""></p>
<p>为什么不用牛顿法：<br>原因一：牛顿法需要用到梯度和Hessian矩阵，这两个都难以求解。因为很难写出深度神经网络拟合函数的表达式，遑论直接得到其梯度表达式，更不要说得到基于梯度的Hessian矩阵了。<br>原因二：即使可以得到梯度和Hessian矩阵，当输入向量的维度NNN较大时，Hessian矩阵的大小是N×NN×NN\times N，所需要的内存非常大。<br>原因三：在高维非凸优化问题中，鞍点相对于局部最小值的数量非常多，而且鞍点处的损失值相对于局部最小值处也比较大。而二阶优化算法是寻找梯度为0的点，所以很容易陷入鞍点。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.40.10.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.50.40.png" alt=""></p>
<h2 id="为什么研究凸函数，凸优化？"><a href="#为什么研究凸函数，凸优化？" class="headerlink" title="为什么研究凸函数，凸优化？"></a>为什么研究凸函数，凸优化？</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%888.52.47.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%889.21.54.png" alt=""></p>
<h1 id="概率与统计基础"><a href="#概率与统计基础" class="headerlink" title="概率与统计基础"></a>概率与统计基础</h1><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.48.26.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.49.16.png" alt=""></p>
<p>统计问题是概率问题的逆向工程。<br>概率问题是已知总体的情况，求一次的概率。统计问题则是根据样本的情况反推总体的情况。<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.55.36.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%884.57.07.png" alt=""></p>
<h2 id="概率统计与机器学习的关系"><a href="#概率统计与机器学习的关系" class="headerlink" title="概率统计与机器学习的关系"></a>概率统计与机器学习的关系</h2><p><strong>概率统计与机器学习天然相关</strong>，训练的过程可以看做是统计过程，预测过程可以看做是概率过程。预测分类就是选择一个概率最大的分类。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%885.02.03.png" alt=""><br>可以观察各个特征的分布以及标签的分布，筛选出相关性强的特征。</p>
<ul>
<li>可基于各个分布的特性来评估模型和样本。</li>
<li>统计估计的是分布，机器学习训练出来的是模型，模型可能包含了很多的分布。</li>
<li>训练与预测过程的一个核心评价指标就是模型的误差</li>
<li>误差本身就可以使概率形式，与概率紧密相关。</li>
<li>对误差的不同定义方式就演化成了不同损失函数的定义方式。</li>
<li>机器学习是概率与统计的进阶版本。（不严谨的说法）</li>
</ul>
<p>方差<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.40.57.png" alt=""></p>
<p>协方差<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.19.04.png" alt=""></p>
<p>可评估两个分布之间的关系。定义公式几何意义：协方差可以理解成特征进行预处理之后（去均值化，机器学习里比较重要的一个数据预处理的方法）对应的向量的几何的<strong>内积</strong>。协方差是评价两个变量的线性关系。如果是非线性关系，评价不出来。</p>
<p>相关系数是研究变量之间线性相关程度地量。<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.30.08.png" alt=""><br>var是方差。<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.34.23.png" alt=""></p>
<h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.22.10.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.23.09.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.26.24.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.28.30.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.32.42.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-27%20%E4%B8%8B%E5%8D%888.34.31.png" alt=""></p>
<p>先验——根据若干年的统计（经验）或者气候（常识），某地方下雨（因）的概率；</p>
<p>似然/类条件概率——在下雨（因）的情况下，观测到了乌云（果）的概率，即原因已知时，结果出现的概率；</p>
<p>后验——根据天上有乌云（果），得到的下雨（因）的概率，即给定结果估计原因的概率；</p>
<p>x:观察得到的结果。</p>
<p>θ：决定数据分布的原因。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.01.08.png" alt=""><br><strong>矩</strong>：<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%888.54.10.png" alt=""></p>
<p>其中t是一个实数，i是虚数单位，E表示期望值。此乃原点矩。E(（X-0）^n)中心矩就是-μ。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.29.29.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.29.29%202.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.06.34.png" alt=""><br>即大部分都分布在均值周围。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%885.30.54.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.03.56.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.05.47.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%888.55.36.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.00.06.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.13.26.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.16.12.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.20.24.png" alt=""><br>没法研究随机变量就研究其特征函数。</p>
<p>当一个分布不是常见的分布时，根据大数定理，反复做实验就可以得到其期望和方差。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-28%20%E4%B8%8B%E5%8D%889.42.29.png" alt=""></p>
<p>大数定理是告诉我们趋近一个数，中心极限定理是告诉我们以何种方式趋近一个数。一个正态分布。</p>
<h1 id="参数估计（统计学）"><a href="#参数估计（统计学）" class="headerlink" title="参数估计（统计学）"></a>参数估计（统计学）</h1><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.47.10.png" alt=""></p>
<h2 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h2><p>利用样本来估计总体分布，总体分布的参数很多情况下是未知的。如均值μ、方差\sigma ^{2} 、泊松分布的λ、二项分布的比例π，其它分布还会有更多的未知参数，需要通过样本进行相应的估计，这种估计值就是点估计。</p>
<h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.56.07.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%889.58.00.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.03.02.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.10.53.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.13.46.png" alt=""></p>
<h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.16.13.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.17.23.png" alt=""><br>可以把概率密度看作是θ和x的联合概率密度，把x固定，那么概率密度最大的地方就是θ最可能的地方。</p>
<p>不是概率是因为相加起来和不等于1，类似于概率是因为数值大小是有意义的，代表了可能性的大小。<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8810.30.29.png" alt=""><br>如何通俗地理解概率论中的「极大似然估计法」? - 马同学的回答 - 知乎<br><a href="https://www.zhihu.com/question/24124998/answer/242682386" target="_blank" rel="noopener">https://www.zhihu.com/question/24124998/answer/242682386</a></p>
<p>简单来说，极大似然函数就是通过样本来求使得概率（似然）为最大的那个θ值。似然越大，就越有可能是这个θ。所以目的就是让似然函数最大就完事了，然后可以通过对θ的梯度下降法，使得似然函数求最大，也就是损失函数为负的似然函数求最小。</p>
<h3 id="点估计的评判准则"><a href="#点估计的评判准则" class="headerlink" title="点估计的评判准则"></a>点估计的评判准则</h3><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.03.57.png" alt=""></p>
<h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><p>对于未知参数，点估计值只是一个近似值，会存在或大或小误差，这时给一个范围可能是更合适，也是更可信的。比如从北京到张家界旅游5天，你恐怕不能准确说出要花多少钱，但你可以给出一个范围，比如10000—13000，你会觉得比较可信。如果给的范围太大，比如10000—30000，虽然可信度更高一些，但这么大的范围参考意义不大；如果给的范围很小，如10000——10500，则准确性提高了，但可信度就似乎不会很高。找到一个合适的估值范围，这是<strong>置信区间</strong>要解决的问题。</p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.13.45.png" alt=""></p>
<h1 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="线性代数基础"></a>线性代数基础</h1><p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.52.28.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.53.24.png" alt=""></p>
<p><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8A%E5%8D%8811.55.39.png" alt=""><br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%8812.05.34.png" alt=""><br>（1）保持加法（2）保持乘法。<br>线性映射是最简单的研究对象，用线性映射去逼近别的东西。<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-29%20%E4%B8%8B%E5%8D%8812.11.32.png" alt=""><br>线性变换与矩阵的关系，对任何向量x进行线性变换T的结果向量，是一个对基向量组进行线性变换T之后的新向量组的一个线性组合，<strong>系数</strong>没变。</p>
<p>只需要知道两个基向量i向量和j向量转换之后的的结果，而不用知道转换本身，我们就能推导出二维空间中所有向量转换之后的结果。</p>
<h2 id="Ax的几何意义"><a href="#Ax的几何意义" class="headerlink" title="Ax的几何意义"></a>Ax的几何意义</h2><p>矩阵乘向量，列向量的线性组合。<br><img src="/img/media/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-25%20%E4%B8%8B%E5%8D%886.45.03.png" alt=""></p>
<h2 id="svd的几何意义。"><a href="#svd的几何意义。" class="headerlink" title="svd的几何意义。"></a>svd的几何意义。</h2><p>一个很重要的降维算法。</p>
<h2 id="矩阵乘法在计算中的优势"><a href="#矩阵乘法在计算中的优势" class="headerlink" title="矩阵乘法在计算中的优势"></a>矩阵乘法在计算中的优势</h2><ul>
<li>将很多for循环写成矩阵或者向量乘法的方式。</li>
<li>矩阵计算模块在底层有优化。</li>
<li>numpy进行矩阵运算很快。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/" class="post-title-link" itemprop="url">JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-12 21:13:56 / 修改时间：21:13:16" itemprop="dateCreated datePublished" datetime="2018-10-12T21:13:56+08:00">2018-10-12</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/教程/" itemprop="url" rel="index"><span itemprop="name">教程</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/10/12/JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment/" class="post-meta-item leancloud_visitors" data-flag-title="JavaScript标准参考教程 DOM 属性的操作 Text节点和DocumentFragment">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h1><p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p>
<p>属性本身是一个对象（Attr对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（HTMlElement对象）来操作属性。本章介绍如何操作这些属性。</p>
<h2 id="Element-attributes属性"><a href="#Element-attributes属性" class="headerlink" title="Element.attributes属性"></a>Element.attributes属性</h2><p>元素对象有一个attributes属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有attributes属性，但返回的都是null，因此可以把这个属性视为元素对象独有的。</p>
<p>单个属性可以通过序号引用，也可以通过属性名引用。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.41.55.png" alt=""><br>返回的都是属性节点对象，而不是属性值。属性节点对象有name和value属性，对应该属性的属性名和属性值，等同于nodeName属性和nodeValue属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.43.16.png" alt=""></p>
<h2 id="元素的标准属性"><a href="#元素的标准属性" class="headerlink" title="元素的标准属性"></a>元素的标准属性</h2><p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.46.23.png" alt=""><br>这些属性都是可写的。这种修改属性的方法，常常用于添加表单的属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.47.33.png" alt=""><br>上面代码为表单添加提交网址和提交方法。</p>
<p>注意，这种用法虽然可以读写属性，但是无法删除属性，delete运算符在这里不会生效。</p>
<p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如onClick。</p>
<p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改<br>名。主要是以下两个。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.48.37.png" alt=""></p>
<h2 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="headerlink" title="属性操作的标准方法"></a>属性操作的标准方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>元素节点提供四个方法，用来操作属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.49.46.png" alt=""></p>
<ol>
<li>适用性   这四个方法对所有的属性（包括用户自定义的属性）都适用。</li>
<li>返回值    getAttribute()只返回字符串，不会返回其他类型的值。</li>
<li>属性名     这些方法只接受属性的标准名称，不用改写保留字，比如for和class都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</li>
</ol>
<h3 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h3><p>lement.getAttribute方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。</p>
<h3 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h3><p>Element.setAttribute方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。</p>
<h3 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h3><p>Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p>
<h3 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h3><p>Element.removeAttribute方法用于从当前元素节点移除属性。</p>
<h2 id="dataset-属性"><a href="#dataset-属性" class="headerlink" title="dataset 属性"></a>dataset 属性</h2><p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。使用标准提供的data-*属性。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.54.45.png" alt=""></p>
<p>然后，使用元素节点对象的dataset属性，它指向一个对象，可以用来操作 HTML 元素标签的data-*属性。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.55.08.png" alt=""></p>
<p>通过dataset.foo读写data-foo属性。删除一个data-*属性，可以直接使用delete命令。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%882.57.31.png" alt=""></p>
<p>除了dataset属性，也可以用getAttribute(‘data-foo’)、removeAttribute(‘data-foo’)、setAttribute(‘data-foo’)、hasAttribute(‘data-foo’)等方法操作data-*属性。</p>
<h1 id="Text节点和DocumentFragment节点"><a href="#Text节点和DocumentFragment节点" class="headerlink" title="Text节点和DocumentFragment节点"></a>Text节点和DocumentFragment节点</h1><h2 id="Text节点的概念"><a href="#Text节点的概念" class="headerlink" title="Text节点的概念"></a>Text节点的概念</h2><p>文本节点（Text）代表元素节点（Element）和属性节点（Attribute）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p>
<p>通常我们使用父节点的firstChild、nextSibling等属性获取文本节点，或者使用Document节点的createTextNode方法创造一个文本节点。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.29.58.png" alt=""></p>
<p>浏览器原生提供一个Text构造函数。它返回一个文本节点实例。它的参数就是<br>该文本节点的文本内容。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.31.11.png" alt=""></p>
<p>文本节点继承了Node接口，所以属性和方法都和Node一样。</p>
<h2 id="Text节点的属性"><a href="#Text节点的属性" class="headerlink" title="Text节点的属性"></a>Text节点的属性</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data属性等同于nodeValue属性，用来设置或读取文本节点的内容。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.33.16.png" alt=""></p>
<h3 id="wholeText"><a href="#wholeText" class="headerlink" title="wholeText"></a>wholeText</h3><p>wholeText属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，wholeText属性的返回值，与data属性和textContent属性相同。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.36.32.png" alt=""></p>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>length属性返回当前文本节点的文本长度。</p>
<h3 id="nextElementSibling，previousElementSibling"><a href="#nextElementSibling，previousElementSibling" class="headerlink" title="nextElementSibling，previousElementSibling"></a>nextElementSibling，previousElementSibling</h3><p>nextElementSibling属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回null。</p>
<p>previousElementSibling属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回null：。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.38.23.png" alt=""></p>
<h2 id="Text节点的方法"><a href="#Text节点的方法" class="headerlink" title="Text节点的方法"></a>Text节点的方法</h2><h3 id="appendData-，deleteData-，insertData-，replaceData-，subStringData"><a href="#appendData-，deleteData-，insertData-，replaceData-，subStringData" class="headerlink" title="appendData()，deleteData()，insertData()，replaceData()，subStringData()"></a>appendData()，deleteData()，insertData()，replaceData()，subStringData()</h3><p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.52.39.png" alt=""></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>remove方法用于移除当前Text节点。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.53.42.png" alt=""></p>
<h3 id="splitText"><a href="#splitText" class="headerlink" title="splitText()"></a>splitText()</h3><p>splitText方法将Text节点一分为二，变成两个毗邻的Text节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p>
<p>分割后，该方法返回分割位置后方的字符串，而原Text节点变成只包含分割位置前方的字符串。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.55.40.png" alt=""><br>父元素的normalize方法可以实现逆操作，将它们合并。</p>
<p><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.56.39.png" alt=""></p>
<h2 id="DocumentFragment节点"><a href="#DocumentFragment节点" class="headerlink" title="DocumentFragment节点"></a>DocumentFragment节点</h2><p>DocumentFragment节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，parentNode返回null，但是可以插入任意数量的子节点。它不属于当前文档，操作DocumentFragment节点，要比直接操作 DOM 树快得多。</p>
<p>它一般用于构建一个 DOM 结构，然后插入当前文档。document.createDocumentFragment方法，以及浏览器原生的DocumentFragment构造函数，可以创建一个空的DocumentFragment节点。然后再使用其他 DOM 方法，向其添加子节点。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%888.58.53.png" alt=""><br>上面代码创建了一个DocumentFragment节点，然后将一个li节点添加在它里面，最后将DocumentFragment节点移动到原文档。</p>
<p><strong>注意</strong>，DocumentFragment节点本身不能被插入当前文档。当它作为appendChild()、insertBefore()、replaceChild()等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦DocumentFragment节点被添加进当前文档，它自身就变成了空节点（textContent属性为空字符串），可以被再次使用。如果想要保存DocumentFragment节点的内容，可以使用cloneNode方法。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%889.03.54.png" alt=""><br>上面这样添加DocumentFragment节点进入当前文档，不会清空DocumentFragment节点。</p>
<p>DocumentFragment节点对象没有自己的属性和方法，全部继承自Node节点和ParentNode接口。也就是说，DocumentFragment节点比Node节点多出以下四个属性。<br><img src="/img/media/JavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%20DOM%20%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%20Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-12%20%E4%B8%8B%E5%8D%889.04.44.png" alt=""></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/10/11/关于JavaScript的对象的理解/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/11/关于JavaScript的对象的理解/" class="post-title-link" itemprop="url">关于JavaScript的对象的理解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-11 19:26:32 / 修改时间：19:26:54" itemprop="dateCreated datePublished" datetime="2018-10-11T19:26:32+08:00">2018-10-11</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/11/关于JavaScript的对象的理解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/11/关于JavaScript的对象的理解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/10/11/关于JavaScript的对象的理解/" class="post-meta-item leancloud_visitors" data-flag-title="关于JavaScript的对象的理解">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于JavaScript的对象的理解"><a href="#关于JavaScript的对象的理解" class="headerlink" title="关于JavaScript的对象的理解"></a>关于JavaScript的对象的理解</h1><p>JavaScript的对象可以分为狭义的和广义的对象。广义的对象由数组，狭义的对象和函数组成。</p>
<p>狭义的对象就是{}，里面是键值对。广义的对象其实本质也是键值对。只不过声明的方式多了一些。比如new Object()。Object就是一个构造函数，既然是函数，本身也就是一个对象，可以对Object中添加方法，和狭义对象的方法一样。比如Object.test=Function (){};这时候在外部可以调用Object.test()方法，即Object对象的静态方法。</p>
<p>这里Object是构造函数名，但是函数也是对象啊，我估计函数本质上也是一个键值对，函数可以是构造函数Function.prototype的实例对象。所以称为Object对象。</p>
<p>既然是构造函数，里面是有语句的，执行完语句得到一个键值对，这又是一个对象，称为Object.prototype。这时就是一个纯粹的键值对。就是原型对象。Object.prototype也有很多方法可以调用。至于原型链，就是对象与对象之间的一条链。对象都是构造函数.prototype。继承是通过构造函数的继承来实现的，一般就是在子类中要实现父类的方法。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/" class="post-title-link" itemprop="url">JavaScript标准参考教程 DOM模型 实际使用DOM Element节点</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-09 19:42:56 / 修改时间：21:19:32" itemprop="dateCreated datePublished" datetime="2018-10-09T19:42:56+08:00">2018-10-09</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/教程/" itemprop="url" rel="index"><span itemprop="name">教程</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/10/09/JavaScript标准参考教程 DOM模型 实际使用DOM Element节点/" class="post-meta-item leancloud_visitors" data-flag-title="JavaScript标准参考教程 DOM模型 实际使用DOM Element节点">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实战中的使用DOM"><a href="#实战中的使用DOM" class="headerlink" title="实战中的使用DOM"></a>实战中的使用DOM</h1><p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8A%E5%8D%8811.44.53.png" alt=""></p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8A%E5%8D%8811.50.54.png" alt=""></p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8B%E5%8D%883.07.00.png" alt=""></p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-09%20%E4%B8%8B%E5%8D%883.26.06.png" alt=""><br>如果加了括号就会直接执行了。</p>
<h1 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h1><p>Element对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。</p>
<p>元素节点的nodeType属性都是1。</p>
<p>Element对象继承了Node接口，因此Node的属性和方法在Element对象都存在。此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如&lt; a&gt;元素的节点对象由HTMLAnchorElement构造函数生成，&lt; button&gt;元素的节点对象由HTMLButtonElement构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承Element的属性和方法，还有各自构造函数的属性和方法。</p>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="headerlink" title="元素特性的相关属性"></a>元素特性的相关属性</h3><h4 id="Element-id"><a href="#Element-id" class="headerlink" title="Element.id"></a>Element.id</h4><p>Element.id属性返回指定元素的id属性，该属性可读写。</p>
<p>id属性的值是大小写敏感。</p>
<h4 id="Element-tagName"><a href="#Element-tagName" class="headerlink" title="Element.tagName"></a>Element.tagName</h4><p>Element.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。</p>
<h4 id="Element-dir"><a href="#Element-dir" class="headerlink" title="Element.dir"></a>Element.dir</h4><p>Element.dir属性用于读写当前元素的文字方向，可能是从左到右（”ltr”），也可能是从右到左（”rtl”）。</p>
<h4 id="Element-accessKey"><a href="#Element-accessKey" class="headerlink" title="Element.accessKey"></a>Element.accessKey</h4><p>Element.accessKey属性用于读写分配给当前元素的快捷键。<br><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.46.27.png" alt=""></p>
<p>上面代码中，btn元素的快捷键是h，按下Alt + h就能将焦点转移到它上面。</p>
<h4 id="Element-draggable"><a href="#Element-draggable" class="headerlink" title="Element.draggable"></a>Element.draggable</h4><p>Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p>
<h4 id="Element-lang"><a href="#Element-lang" class="headerlink" title="Element.lang"></a>Element.lang</h4><p>Element.lang属性返回当前元素的语言设置。该属性可读写。</p>
<h4 id="Element-tabIndex"><a href="#Element-tabIndex" class="headerlink" title="Element.tabIndex"></a>Element.tabIndex</h4><p>Element.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p>
<p>abIndex属性值如果是负值（通常是-1），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的tabIndex属性的正整数值相同，则按照出现的顺序遍历。遍历完所有tabIndex为正整数的元素以后，再遍历所有tabIndex等于0、或者属性值是非法值、或者没有tabIndex属性的元素，顺序为它们在网页中出现的顺序。</p>
<h4 id="Element-title"><a href="#Element-title" class="headerlink" title="Element.title"></a>Element.title</h4><p>Element.title属性用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p>
<h3 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="headerlink" title="元素状态的相关属性"></a>元素状态的相关属性</h3><h4 id="Element-hidden"><a href="#Element-hidden" class="headerlink" title="Element.hidden"></a>Element.hidden</h4><p>Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。</p>
<p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，Element.hidden并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p>
<p>CSS 的设置高于Element.hidden。如果 CSS 指定了该元素不可见（display: none）或可见（display: hidden），那么Element.hidden并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p>
<h4 id="Element-contentEditable，Element-isContentEditable"><a href="#Element-contentEditable，Element-isContentEditable" class="headerlink" title="Element.contentEditable，Element.isContentEditable"></a>Element.contentEditable，Element.isContentEditable</h4><p>HTML 元素可以设置contentEditable属性，使得元素的内容可以编辑。</p>
<p>Element.contentEditable属性返回一个字符串，表示是否设置了contenteditable属性，有三种可能的值。该属性可写。</p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.49.37.png" alt=""></p>
<p>Element.isContentEditable属性返回一个布尔值，同样表示是否设置了contenteditable属性。该属性只读。</p>
<h3 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h3><p>Element.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。</p>
<h4 id="Element-className，Element-classList"><a href="#Element-className，Element-classList" class="headerlink" title="Element.className，Element.classList"></a>Element.className，Element.classList</h4><p>className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割</p>
<p>classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。</p>
<p>classList对象有下列方法。</p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.52.15.png" alt=""></p>
<p>toggle方法可以接受一个布尔值，作为第二个参数。如果为true，则添加该属性；如果为false，则去除该属性。</p>
<h3 id="Element-dataset"><a href="#Element-dataset" class="headerlink" title="Element.dataset"></a>Element.dataset</h3><p>网页元素可以自定义data-属性，用来添加数据。</p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.53.44.png" alt=""></p>
<p>Element.dataset属性返回一个对象，可以从这个对象读写data-属性。<br><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.54.24.png" alt=""></p>
<p>注意，dataset上面的各个属性返回都是字符串。</p>
<p>HTML 代码中，data-属性的属性名，只能包含英文字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_）。它们转成 JavaScript 对应的dataset属性名，规则如下。<br><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%882.54.51.png" alt=""></p>
<p>因此，data-abc-def对应dataset.abcDef，data-abc-1对应dataset[“abc-1”]。</p>
<p>除了使用dataset读写data-属性，也可以使用Element.getAttribute()和Element.setAttribute()，通过完整的属性名读写这些属性。</p>
<h3 id="Element-innerHTML"><a href="#Element-innerHTML" class="headerlink" title="Element.innerHTML"></a>Element.innerHTML</h3><p>Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<html>和<body>元素。</body></html></p>
<p>如果将innerHTML属性设为空，等于删除所有它包含的所有节点。</p>
<p>注意，读取属性值的时候，如果文本节点包含 \&amp;、小于号（ &lt;）和大于号（ &gt;），innerHTML属性会将它们转为实体形式 \&amp; amp;、\&amp; lt;、\&amp; gt;。如果想得到原文，建议使用element.textContent属性。<br><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%883.53.56.png" alt=""></p>
<p>注意，如果文本之中含有&lt; script&gt;标签，虽然可以生成script节点，但是插入的代码不会执行。</p>
<p>为了安全考虑，如果插入的是文本，最好用textContent属性代替innerHTML。</p>
<h3 id="Element-outerHTML"><a href="#Element-outerHTML" class="headerlink" title="Element.outerHTML"></a>Element.outerHTML</h3><p>Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%883.57.03.png" alt=""></p>
<p>outerHTML属性是可读写的，对它进行赋值，等于替换掉当前元素。</p>
<p>注意，如果一个节点没有父节点，设置outerHTML属性会报错。</p>
<h3 id="Element-clientHeight，Element-clientWidth"><a href="#Element-clientHeight，Element-clientWidth" class="headerlink" title="Element.clientHeight，Element.clientWidth"></a>Element.clientHeight，Element.clientWidth</h3><p>Element.clientHeight属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度。</p>
<p>除了元素本身的高度，它还包括padding部分，但是不包括border、margin。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p>
<p>Element.clientWidth属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p>
<p>document.documentElement的clientHeight属性，返回当前视口的高度（即浏览器窗口的高度），等同于window.innerHeight属性减去水平滚动条的高度（如果有的话）。document.body的高度则是网页的实际高度。一般来说，document.body.clientHeight大于document.documentElement.clientHeight。</p>
<h3 id="Element-clientLeft，Element-clientTop"><a href="#Element-clientLeft，Element-clientTop" class="headerlink" title="Element.clientLeft，Element.clientTop"></a>Element.clientLeft，Element.clientTop</h3><p>Element.clientLeft属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的padding和margin。如果没有设置左边框，或者是行内元素（display: inline），该属性返回0。该属性总是返回整数值，如果是小数，会四舍五入。</p>
<p>Element.clientTop属性等于网页元素顶部边框的宽度（单位像素），其他特点都与clientTop相同。</p>
<h3 id="Element-scrollHeight，Element-scrollWidth"><a href="#Element-scrollHeight，Element-scrollWidth" class="headerlink" title="Element.scrollHeight，Element.scrollWidth"></a>Element.scrollHeight，Element.scrollWidth</h3><p>Element.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。</p>
<p>Element.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读。</p>
<p>整张网页的总高度可以从document.documentElement或document.body上读取。</p>
<p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，scrollHeight属性仍然返回元素的总高度。</p>
<h3 id="Element-scrollLeft，Element-scrollTop"><a href="#Element-scrollLeft，Element-scrollTop" class="headerlink" title="Element.scrollLeft，Element.scrollTop"></a>Element.scrollLeft，Element.scrollTop</h3><p>Element.scrollLeft属性表示当前元素的水平滚动条向右侧滚动的像素数量，Element.scrollTop属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p>
<p>如果要查看整张网页的水平的和垂直的滚动距离，要从document.documentElement元素上读取。</p>
<p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p>
<h3 id="Element-offsetParent"><a href="#Element-offsetParent" class="headerlink" title="Element.offsetParent"></a>Element.offsetParent</h3><p>Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。</p>
<p>该属性主要用于确定子元素位置偏移的计算基准，Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。</p>
<p>如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），则offsetParent属性返回null。</p>
<p>如果某个元素的所有上层节点的position属性都是static，则Element.offsetParent属性指向<body>元素。</body></p>
<h3 id="Element-offsetHeight，Element-offsetWidth"><a href="#Element-offsetHeight，Element-offsetWidth" class="headerlink" title="Element.offsetHeight，Element.offsetWidth"></a>Element.offsetHeight，Element.offsetWidth</h3><p>Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。</p>
<p>Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。</p>
<p>这两个属性都是<strong>只读</strong>属性，只比Element.clientHeight和Element.clientWidth多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如display: none;），则返回0。</p>
<h3 id="Element-offsetLeft，Element-offsetTop"><a href="#Element-offsetLeft，Element-offsetTop" class="headerlink" title="Element.offsetLeft，Element.offsetTop"></a>Element.offsetLeft，Element.offsetTop</h3><p>Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移</p>
<h3 id="Element-style"><a href="#Element-style" class="headerlink" title="Element.style"></a>Element.style</h3><p>每个元素节点都有style用来读写该元素的行内样式信息。</p>
<h3 id="Element-children，Element-childElementCount"><a href="#Element-children，Element-childElementCount" class="headerlink" title="Element.children，Element.childElementCount"></a>Element.children，Element.childElementCount</h3><p>Element.children属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p>
<p>这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p>
<p>Element.childElementCount属性返回当前元素节点包含的子元素节点的个数，与Element.children.length的值相同。</p>
<h3 id="Element-firstElementChild，Element-lastElementChild"><a href="#Element-firstElementChild，Element-lastElementChild" class="headerlink" title="Element.firstElementChild，Element.lastElementChild"></a>Element.firstElementChild，Element.lastElementChild</h3><p>Element.firstElementChild属性返回当前元素的第一个元素子节点，Element.lastElementChild返回最后一个元素子节点。</p>
<p>如果没有元素子节点，这两个属性返回null。</p>
<h3 id="Element-nextElementSibling，Element-previousElementSibling"><a href="#Element-nextElementSibling，Element-previousElementSibling" class="headerlink" title="Element.nextElementSibling，Element.previousElementSibling"></a>Element.nextElementSibling，Element.previousElementSibling</h3><p>Element.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回null。</p>
<p>Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回null。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="属性相关方法"><a href="#属性相关方法" class="headerlink" title="属性相关方法"></a>属性相关方法</h3><h4 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h4><p>Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。</p>
<h4 id="Element-getAttributeNames"><a href="#Element-getAttributeNames" class="headerlink" title="Element.getAttributeNames()"></a>Element.getAttributeNames()</h4><p>Element.getAttributeNames()返回一个<strong>数组</strong>，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用Element.attributes属性，也可以拿到同样的结果，唯一的区别是它返回的是<strong>类似数组</strong>的对象。</p>
<h4 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h4><p>Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。</p>
<p>属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值true就会变成字符串true。</p>
<h4 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h4><p>Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否有指定的属性。</p>
<h4 id="Element-hasAttributes"><a href="#Element-hasAttributes" class="headerlink" title="Element.hasAttributes()"></a>Element.hasAttributes()</h4><p>Element.hasAttributes方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回false，否则返回true。</p>
<h4 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h4><p>Element.removeAttribute方法移除指定属性。该方法没有返回值。</p>
<h3 id="Element-querySelector"><a href="#Element-querySelector" class="headerlink" title="Element.querySelector()"></a>Element.querySelector()</h3><p>Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回null。</p>
<p>注意，这个方法无法选中伪元素。</p>
<p>它可以接受多个选择器，它们之间使用逗号分隔。</p>
<h3 id="Element-querySelectorAll"><a href="#Element-querySelectorAll" class="headerlink" title="Element.querySelectorAll()"></a>Element.querySelectorAll()</h3><p>Element.querySelectorAll方法接受 CSS 选择器作为参数，返回一个NodeList实例，包含所有匹配的子元素。</p>
<p>该方法的执行机制与querySelector方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p>
<p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的NodeList实例。</p>
<h3 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h3><p>Element.getElementsByClassName方法返回一个HTMLCollection实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<p>注意，该方法的参数大小写敏感。</p>
<p>由于HTMLCollection实例是一个活的集合，document对象的任何变化会立刻反应到实例。<br><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%884.59.41.png" alt=""></p>
<p>上面代码中，matches集合的第一个成员，一旦被拿掉 class 里面的foo，就会立刻从matches里面消失，导致出现上面的结果。</p>
<h3 id="Element-getElementsByTagName"><a href="#Element-getElementsByTagName" class="headerlink" title="Element.getElementsByTagName()"></a>Element.getElementsByTagName()</h3><p>Element.getElementsByTagName方法返回一个HTMLCollection实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<p><strong>注意</strong>，该方法的参数是大小写不敏感的。</p>
<h3 id="Element-closest"><a href="#Element-closest" class="headerlink" title="Element.closest()"></a>Element.closest()</h3><p>Element.closest方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回null。</p>
<h3 id="Element-matches"><a href="#Element-matches" class="headerlink" title="Element.matches()"></a>Element.matches()</h3><p>Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p>
<h3 id="事件相关方法"><a href="#事件相关方法" class="headerlink" title="事件相关方法"></a>事件相关方法</h3><p>以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口，<br><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.31.11.png" alt=""></p>
<h3 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="Element.scrollIntoView()"></a>Element.scrollIntoView()</h3><p>Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。</p>
<p>该方法可以接受一个布尔值作为参数。如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为true。</p>
<h3 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h3><p>Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p>
<p>只读。</p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.54.41.png" alt=""></p>
<p>注意，getBoundingClientRect方法的所有属性，都把边框（border属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，width和height包括了元素本身 + padding + border。</p>
<h3 id="Element-getClientRects"><a href="#Element-getClientRects" class="headerlink" title="Element.getClientRects()"></a>Element.getClientRects()</h3><p>Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的Rect用的是复数）。每个矩形都有bottom、height、left、right、top和width六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p>
<p>对于盒状元素（比如&lt; div&gt;和&lt; p&gt;），该方法返回的对象中只有该元素一个成员。对于行内元素（比如&lt; span&gt;、&lt; a&gt;、&lt; em&gt;），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和Element.getBoundingClientRect()方法的主要区别，后者对于行内元素总是返回一个矩形。</p>
<h3 id="Element-insertAdjacentElement"><a href="#Element-insertAdjacentElement" class="headerlink" title="Element.insertAdjacentElement()"></a>Element.insertAdjacentElement()</h3><p>Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回null。</p>
<p>Element.insertAdjacentElement方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%886.12.22.png" alt=""></p>
<p>注意，beforebegin和afterend这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p>
<h3 id="Element-insertAdjacentHTML-，Element-insertAdjacentText"><a href="#Element-insertAdjacentHTML-，Element-insertAdjacentText" class="headerlink" title="Element.insertAdjacentHTML()，Element.insertAdjacentText()"></a>Element.insertAdjacentHTML()，Element.insertAdjacentText()</h3><p>Element.insertAdjacentHTML方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p>
<p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p>
<p><img src="/img/media/1534769900941/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%886.22.41.png" alt=""></p>
<p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比innerHTML方法快得多。</p>
<p>注意，该方法会使 HTML 字符串显示为网页结构，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p>
<h3 id="Element-focus-，Element-blur"><a href="#Element-focus-，Element-blur" class="headerlink" title="Element.focus()，Element.blur()"></a>Element.focus()，Element.blur()</h3><p>Element.focus方法用于将当前页面的焦点，转移到指定元素上。</p>
<p>该方法可以接受一个对象作为参数。参数对象的preventScroll属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p>
<p>Element.blur方法用于将焦点从当前元素移除。</p>
<h3 id="Element-click"><a href="#Element-click" class="headerlink" title="Element.click()"></a>Element.click()</h3><p>Element.click方法用于在当前元素上模拟一次鼠标点击，相当于触发了click事件。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/10/06/CSS/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/06/CSS/" class="post-title-link" itemprop="url">CSS</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-06 21:31:32" itemprop="dateCreated datePublished" datetime="2018-10-06T21:31:32+08:00">2018-10-06</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-20 16:00:46" itemprop="dateModified" datetime="2018-12-20T16:00:46+08:00">2018-12-20</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/听课笔记/" itemprop="url" rel="index"><span itemprop="name">听课笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/10/06/CSS/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/06/CSS/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/10/06/CSS/" class="post-meta-item leancloud_visitors" data-flag-title="CSS">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>层叠样式表。</p>
<h2 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h2><h3 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.48.01.png" alt=""></p>
<p>语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式，其中属性和值的书写规范与CSS样式规范相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。注意是冒号。</p>
<h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.56.46.png" alt=""></p>
<p>语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。</p>
<p>type=“text/CSS”在H5中可以省略，写上也比较符合规范，所以这个地方可以写也可以省略。</p>
<h3 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%883.50.47.png" alt=""></p>
<p>在外部样式中，不用style标签，直接写就完事了。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.14.45.png" alt=""></p>
<h2 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h2><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.22.21.png" alt=""></p>
<h2 id="选择器（重点）"><a href="#选择器（重点）" class="headerlink" title="选择器（重点）"></a>选择器（重点）</h2><h3 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h3><h4 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h4><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.24.56.png" alt=""></p>
<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%884.31.10.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%885.20.47.png" alt=""></p>
<h4 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h4><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.27.18.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.29.45.png" alt=""></p>
<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>id选择器和类选择器最大的不同在于使用次数。<br>id选择器id只能使用一次。<br> 使用‘#’ 定义，使用 id= 调用</p>
<h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.39.22.png" alt=""><br>几乎不用。</p>
<h2 id="CSS字体样式属性"><a href="#CSS字体样式属性" class="headerlink" title="CSS字体样式属性"></a>CSS字体样式属性</h2><h3 id="font-size：字号大小"><a href="#font-size：字号大小" class="headerlink" title="font-size：字号大小"></a>font-size：字号大小</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.44.34.png" alt=""></p>
<p>统一用px</p>
<h3 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family:字体"></a>font-family:字体</h3><p>font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等。</p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.49.56.png" alt=""></p>
<p>如果字体都没有，就使用系统默认的字体。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%888.57.21.png" alt=""><br>为了照顾浏览器的兼容性，可以使用Unicode编码。</p>
<h3 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight:字体粗细"></a>font-weight:字体粗细</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.00.10.png" alt=""><br>bold字体加粗。使用normal也可以让标题不加粗。</p>
<h3 id="font-style：字体风格"><a href="#font-style：字体风格" class="headerlink" title="font-style：字体风格"></a>font-style：字体风格</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.05.27.png" alt=""></p>
<h3 id="综合设置字体样式（重点）"><a href="#综合设置字体样式（重点）" class="headerlink" title="综合设置字体样式（重点）"></a>综合设置字体样式（重点）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.12.57.png" alt=""></p>
<h2 id="CSS外观属性"><a href="#CSS外观属性" class="headerlink" title="CSS外观属性"></a>CSS外观属性</h2><h3 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color:文本颜色"></a>color:文本颜色</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.18.24.png" alt=""><br>十六进制时 # ff0000由于数值一样，可以简写为 # f00。</p>
<h3 id="line-height-行间距"><a href="#line-height-行间距" class="headerlink" title="line-height:行间距"></a>line-height:行间距</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.25.50.png" alt=""></p>
<h3 id="text-align-水平对齐方式"><a href="#text-align-水平对齐方式" class="headerlink" title="text-align:水平对齐方式"></a>text-align:水平对齐方式</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-01%20%E4%B8%8B%E5%8D%889.27.26.png" alt=""></p>
<p>css中没有垂直对齐的方式。</p>
<p>是让盒子里面的内容居中，而不是让盒子居中。</p>
<h3 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent:首行缩进"></a>text-indent:首行缩进</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%8812.45.51.png" alt=""></p>
<h3 id="text-decoration文本的装饰"><a href="#text-decoration文本的装饰" class="headerlink" title="text-decoration文本的装饰"></a>text-decoration文本的装饰</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%8812.52.06.png" alt=""></p>
<h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%881.47.29.png" alt=""></p>
<p>用空格隔开。</p>
<p>是选择所有的后代。</p>
<h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><p>只选亲儿子。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%881.55.37.png" alt=""></p>
<h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.02.04.png" alt=""></p>
<h3 id="并集选择器（重点）"><a href="#并集选择器（重点）" class="headerlink" title="并集选择器（重点）"></a>并集选择器（重点）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.05.50.png" alt=""></p>
<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，比如可以选择第一个，第n个元素。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.27.25.png" alt=""></p>
<h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.27.48.png" alt=""></p>
<p>active是按下鼠标还没弹起的状态。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%882.35.30.png" alt=""></p>
<h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h2><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.24.57.png" alt=""></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.25.36.png" alt=""></p>
<h2 id="标签的显示（display）"><a href="#标签的显示（display）" class="headerlink" title="标签的显示（display）"></a>标签的显示（display）</h2><h3 id="块级元素（block-level）"><a href="#块级元素（block-level）" class="headerlink" title="块级元素（block-level）"></a>块级元素（block-level）</h3><p>每个块元素通常都会<strong>独自占据一整行或者多整行</strong>，<strong>可以对其设置宽度、高度、对齐等属性</strong>，常用于网页布局和网页结构的搭建。</p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.33.03.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.35.02.png" alt=""></p>
<h3 id="行内元素（inline-level）"><a href="#行内元素（inline-level）" class="headerlink" title="行内元素（inline-level）"></a>行内元素（inline-level）</h3><p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.36.59.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.37.25.png" alt=""></p>
<p><strong>a里面可以放块级元素。</strong></p>
<p><strong>注意</strong>：</p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.38.41.png" alt=""></p>
<h3 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.41.54.png" alt=""></p>
<h3 id="显示模式转换"><a href="#显示模式转换" class="headerlink" title="显示模式转换"></a>显示模式转换</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%883.47.14.png" alt=""></p>
<p>每一个标签都是一个小盒子。</p>
<p><strong>如果是行内元素，行内块元素，我们可以看做文本，可以在块级使用text-align:center进行居中对齐。</strong></p>
<p><strong>使行高等于盒子的高度，可以让单行文本垂直居中。</strong></p>
<h2 id="行高的测量"><a href="#行高的测量" class="headerlink" title="行高的测量"></a>行高的测量</h2><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.18.40.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.19.15.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-02%20%E4%B8%8B%E5%8D%884.20.54.png" alt=""></p>
<h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><h3 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a>CSS层叠性</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.40.30.png" alt=""></p>
<h3 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.43.42.png" alt=""></p>
<h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.49.09.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8A%E5%8D%8811.54.36.png" alt=""></p>
<h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><p>CSS可以添加背景颜色和背景图片，以及来进行图片设置。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.06.37.png" alt=""></p>
<h3 id="背景颜色与背景图片"><a href="#背景颜色与背景图片" class="headerlink" title="背景颜色与背景图片"></a>背景颜色与背景图片</h3><p>同时设置的话背景图片会在背景颜色之上。</p>
<h3 id="backgroud-repeat"><a href="#backgroud-repeat" class="headerlink" title="backgroud-repeat"></a>backgroud-repeat</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.33.01.png" alt=""></p>
<h3 id="backgroud-position"><a href="#backgroud-position" class="headerlink" title="backgroud-position"></a>backgroud-position</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.34.49.png" alt=""></p>
<h3 id="backgroud-attachment"><a href="#backgroud-attachment" class="headerlink" title="backgroud-attachment"></a>backgroud-attachment</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.35.45.png" alt=""></p>
<h3 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.28.48.png" alt=""></p>
<h3 id="背景透明（CSS3）"><a href="#背景透明（CSS3）" class="headerlink" title="背景透明（CSS3）"></a>背景透明（CSS3）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%883.49.38.png" alt=""></p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="盒子边框"><a href="#盒子边框" class="headerlink" title="盒子边框"></a>盒子边框</h3><p>盒子边框即border,有border-width,border-style,border-color.<br>可简写为 border: 1px solid red;<br>其中border-style常用值。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.12.44.png" alt=""></p>
<p>border亦可单边进行设置。border-top;border-bottom;border-left;border-right。</p>
<h4 id="合并相邻边框"><a href="#合并相邻边框" class="headerlink" title="合并相邻边框"></a>合并相邻边框</h4><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.13.53.png" alt=""></p>
<h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h3><p>默认贴在左上角。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.16.37.png" alt=""><br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.17.06.png" alt=""></p>
<p>padding和border会<strong>撑开</strong>带有width和height的盒子。对于没有给定的就是盒子大小不变，内容进行了移动。</p>
<h3 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%884.54.40.png" alt=""></p>
<p>margin值的个数表达的意思和padding类似。</p>
<p>使盒子水平居中：<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.20.44.png" alt=""><br>上下是0，左右是auto。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.23.20.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.24.24.png" alt=""></p>
<p>使块中的内容居中：text-align=center。</p>
<h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.33.00.png" alt=""><br>以比较大的为准。</p>
<p>解决方法：避免</p>
<h3 id="垂直外边距嵌套元素合并"><a href="#垂直外边距嵌套元素合并" class="headerlink" title="垂直外边距嵌套元素合并"></a>垂直外边距嵌套元素合并</h3><p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。</p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.40.26.png" alt=""><br>只有垂直会发生这种情况。</p>
<p>解决方案：</p>
<ol>
<li>可以为父元素定义1像素的上外边框或上内边距。</li>
<li>可以为父元素添加overflow:hidden.</li>
</ol>
<h3 id="盒子布局的稳定性"><a href="#盒子布局的稳定性" class="headerlink" title="盒子布局的稳定性"></a>盒子布局的稳定性</h3><p>按照优先使用顺序：width&gt;padding&gt;margin<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.52.49.png" alt=""></p>
<h3 id="插入图片与背景图片"><a href="#插入图片与背景图片" class="headerlink" title="插入图片与背景图片"></a>插入图片与背景图片</h3><p> 插入图片 最多比如产品展示类；背景图片我们一般用于小图标背景或者超大背景图片。</p>
<h3 id="圆角边框（CSS3）"><a href="#圆角边框（CSS3）" class="headerlink" title="圆角边框（CSS3）"></a>圆角边框（CSS3）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%886.54.48.png" alt=""></p>
<p>也可以是px。值越大越圆。<br><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%887.02.04.png" alt=""><br>第一个左上，顺时针。</p>
<h3 id="盒子阴影（CSS3）"><a href="#盒子阴影（CSS3）" class="headerlink" title="盒子阴影（CSS3）"></a>盒子阴影（CSS3）</h3><p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.03.25.png" alt=""></p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.09.08.png" alt=""></p>
<h2 id="浮动（float）"><a href="#浮动（float）" class="headerlink" title="浮动（float）"></a>浮动（float）</h2><h3 id="普通流（normal-flow）"><a href="#普通流（normal-flow）" class="headerlink" title="普通流（normal flow）"></a>普通流（normal flow）</h3><p>也称为标准流，CSS的定位机制有三种：普通流、浮动和定位。</p>
<p>普通流实际就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思。比如块级元素会独占一行，行内元素会按顺序依次前后排列。</p>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>浮动让盒子浮起来，盒子的位置就由其他盒子占据。</p>
<p>浮动有个很有意思的事情：就是让任何盒子可以一行排列，我们就慢慢地利用浮动的特性来布局了。</p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.19.38.png" alt=""></p>
<p>为什么不用inline-block?是有的时候需要右对齐，这时就不好知道具体的位置。需要量出来，不同的屏幕显示的效果不一样。而且块之间有缝隙。这时使用浮动就效果比较好。</p>
<p><img src="/img/media/html+css/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-06%20%E4%B8%8B%E5%8D%888.23.20.png" alt=""></p>
<p>只有<strong>左右</strong>。浮动的和浮动的又符合标准流。</p>
<p>浮动的盒子跨越不了padding值。</p>
<p>一个盒子浮动，会影响后面的位置，影响不了前面的位置，也就是说不会往上面的元素上浮。</p>
<p>浮动有一个隐藏的模式转换，浮动可以让元素默认转换为<strong>行内块元素</strong>，宽度取决于元素的大小。</p>
<p>如果已经给行内元素添加了浮动，此时不需要转换该元素也可以有宽高。</p>
<h2 id="版心和布局流程"><a href="#版心和布局流程" class="headerlink" title="版心和布局流程"></a>版心和布局流程</h2><p>为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下：</p>
<ol>
<li>确定页面的版心（可视区）。</li>
<li>分析页面中的行模块，以及每个行模块中的列模块。</li>
<li>制作HTML结构。</li>
<li>CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。</li>
</ol>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="ZDK"/>
            
              <p class="site-author-name" itemprop="name">ZDK</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">191</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zdkswd" title="GitHub &rarr; https://github.com/zdkswd"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:2822464407@qq.com" title="E-Mail &rarr; mailto:2822464407@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/zdkswd" title="https://github.com/zdkswd">Title</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </div>

      

      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZDK</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  
  

<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz',
    appKey: 'gkBx5soQkBREmER84PWbNJeM',
    placeholder: 'have fun',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('5');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
