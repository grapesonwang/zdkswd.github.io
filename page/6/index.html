<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta property="og:type" content="website">
<meta property="og:title" content="ZDK&#39;s blog">
<meta property="og:url" content="https://github.com/zdkswd/page/6/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZDK&#39;s blog">



  <link rel="alternate" href="/atom.xml" title="ZDK's blog" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="https://github.com/zdkswd/page/6/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ZDK's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZDK's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/04/14/featexp/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/featexp/" class="post-title-link" itemprop="url">featexp</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-14 20:15:32 / 修改时间：20:15:42" itemprop="dateCreated datePublished" datetime="2019-04-14T20:15:32+08:00">2019-04-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/14/featexp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/14/featexp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/14/featexp/" class="post-meta-item leancloud_visitors" data-flag-title="featexp">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="featexp"><a href="#featexp" class="headerlink" title="featexp"></a>featexp</h1><p><a href="https://towardsdatascience.com/my-secret-sauce-to-be-in-top-2-of-a-kaggle-competition-57cff0677d3c" target="_blank" rel="noopener">https://towardsdatascience.com/my-secret-sauce-to-be-in-top-2-of-a-kaggle-competition-57cff0677d3c</a></p>
<h1 id="feature-understanding"><a href="#feature-understanding" class="headerlink" title="feature understanding"></a>feature understanding</h1><p>if target is binary, scatter is not very useful.<br><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%885.41.15.png" alt=""><br>And for continuous target, too many data points make it difficult to understand the target vs. feature trend.</p>
<p><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%885.52.05.png" alt=""><br>use above code,Featexp creates <strong>equal population bins (X-axis)</strong> of a numeric feature.It then calculates target’s <strong>mean</strong> in each bin and plots it in the left-hand side plot above. As you can see the plot on the right shows they are the same number.<br><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%885.54.45.png" alt=""></p>
<h1 id="Identifying-noisy-features"><a href="#Identifying-noisy-features" class="headerlink" title="Identifying noisy features"></a>Identifying noisy features</h1><p>Noisy features lead to overfitting and identifying them isn’t easy. In featexp, you can pass a test set and compare feature trends in train|test to identify noisy ones. This test set is not the actual test set. Its your local test set|validation set for which you know target.</p>
<blockquote>
<p>get_univariate_plots(data=data_train, target_col=’target’, data_test=data_test, features_list=[‘DAYS_EMPLOYED’])  </p>
</blockquote>
<p><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%886.10.12.png" alt=""><br>Featexp calculates two metrics to display on these plots which help with gauging(计量；测量) noisiness:</p>
<p>1.<strong>Trend correlation</strong> (seen in test plot): If a feature doesn’t hold same trend w.r.t. target across train and evaluation sets, it can lead to overfitting. This happens because the model is learning something which is not applicable in test data. Trend correlation helps understand how similar train/test trends are and mean target values for bins in train &amp; test are used to calculate it. Feature above has 99% correlation. Doesn’t seem noisy!<br>2.<strong>Trend changes</strong>: Sudden and repeated changes in trend direction could imply noisiness. But, such trend change can also happen because that bin has a very different value in terms of <strong>other features</strong> and hence, its value can’t really be compared with other bins.</p>
<p>for example the nosiy feature.<br><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%886.37.26.png" alt=""></p>
<p>Dropping low trend-correlation features works well when <strong>there are a lot of features and they are correlated with each other</strong>. It leads to less overfitting and other correlated features avoid information loss. It’s also important to <strong>not drop too many important features</strong> as it might lead to a drop in performance. Also, <strong>you can’t identify these noisy features using feature importance</strong> because they could be fairly important and still be very noisy!</p>
<p><strong>Using test data from a different time period works better because then you would be making sure if feature trend holds over time.</strong></p>
<p><strong>get_trend_stats()</strong> function in featexp returns a dataframe with trend correlation and changes for each feature.</p>
<blockquote>
<p>from featexp import get_trend_stats  stats=get_trend_stats(data=data_train,target_col=’target’,data_test=data_test)  </p>
</blockquote>
<p><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%886.54.44.png" alt=""><br> try dropping features with low trend-correlation in our data and see how results improve.<br><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%886.56.50.png" alt=""><br>We can see that higher the trend-correlation threshold to drop features, higher is the leaderboard (LB) AUC.</p>
<h1 id="Feature-Engineering"><a href="#Feature-Engineering" class="headerlink" title="Feature Engineering"></a>Feature Engineering</h1><p>The insights that you get by looking at these plots help with creating better features. Just having a better understanding of data can lead to better feature engineering. But, in addition to this, it can also help you in improving the existing features. Let’s look at another feature EXT_SOURCE_1:<br><img src="/img/media/featexp/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-14%20%E4%B8%8B%E5%8D%887.10.11.png" alt=""></p>
<h1 id="Feature-importance"><a href="#Feature-importance" class="headerlink" title="Feature importance"></a>Feature importance</h1><p>i choose xgboost this part.</p>
<h1 id="Feature-debugging"><a href="#Feature-debugging" class="headerlink" title="Feature debugging"></a>Feature debugging</h1><p>check the trend is or not as you wish.</p>
<h1 id="Leakage-Detection"><a href="#Leakage-Detection" class="headerlink" title="Leakage Detection"></a>Leakage Detection</h1><h1 id="Model-Monitoring"><a href="#Model-Monitoring" class="headerlink" title="Model Monitoring"></a>Model Monitoring</h1>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/04/14/美团  特征提取/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/美团  特征提取/" class="post-title-link" itemprop="url">美团  特征提取</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-14 16:33:47 / 修改时间：16:33:38" itemprop="dateCreated datePublished" datetime="2019-04-14T16:33:47+08:00">2019-04-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/14/美团  特征提取/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/14/美团  特征提取/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/14/美团  特征提取/" class="post-meta-item leancloud_visitors" data-flag-title="美团  特征提取">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="美团-特征提取"><a href="#美团-特征提取" class="headerlink" title="美团  特征提取"></a>美团  特征提取</h1><p><img src="/img/media/%E7%BE%8E%E5%9B%A2%20%20%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/WechatIMG77.jpeg" alt=""><br><img src="/img/media/%E7%BE%8E%E5%9B%A2%20%20%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/WechatIMG76.jpeg" alt=""></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/04/14/Kaggle竞赛案例一/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/Kaggle竞赛案例一/" class="post-title-link" itemprop="url">Kaggle竞赛案例一</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-14 15:37:47 / 修改时间：15:44:26" itemprop="dateCreated datePublished" datetime="2019-04-14T15:37:47+08:00">2019-04-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/14/Kaggle竞赛案例一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/14/Kaggle竞赛案例一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/14/Kaggle竞赛案例一/" class="post-meta-item leancloud_visitors" data-flag-title="Kaggle竞赛案例一">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kaggle-CrowdFlower"><a href="#Kaggle-CrowdFlower" class="headerlink" title="Kaggle_CrowdFlower"></a>Kaggle_CrowdFlower</h1><p><a href="https://github.com/ChenglongChen/Kaggle_CrowdFlower">GitHub - ChenglongChen/Kaggle_CrowdFlower: 1st Place Solution for Search Results Relevance Competition on Kaggle (https://www.kaggle.com/c/crowdflower-search-relevance)</a><br>1st Place Solution for Search Results Relevance Competition on Kaggle<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/FlowChart.jpg" alt=""><br>问题描述：搜索结果相关挑战，给定搜索结果，搜索出的产品名称，产品描述，建立模型去预测搜索结果的相关得分。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>解决方案分为两部分：特征工程和模型集成。</p>
<p>特征包括三部分的特征：<br>1.计数特征<br>2.距离特征<br>3.TF-IDF特征</p>
<p>在生产特征前，对数据进行拼写检查，同义词替换，词干提取是非常有用的。模型集成包括两个主要的步骤，首先，使用不同种，不同参数设置，不同特征子集去训练模型。然后使用训练的模型进行bagged集成选择。在训练集上使用交叉验证来评估表现。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>进行了几步去清洗文本。</p>
<h2 id="去除HTML标签"><a href="#去除HTML标签" class="headerlink" title="去除HTML标签"></a>去除HTML标签</h2><p>在商品描述中存在html标签的干扰，使用bs4去除之。</p>
<h2 id="单词替换"><a href="#单词替换" class="headerlink" title="单词替换"></a>单词替换</h2><p>在搜索中会出现词义相关的搜索，要考虑到。<br>1.拼写纠正<br>2.同义词替换<br>3.词干提取</p>
<h2 id="特征提取-选择"><a href="#特征提取-选择" class="headerlink" title="特征提取/选择"></a>特征提取/选择</h2><p>$$\left(q_{i}, t_{i}, d_{i}\right)$$是train.csv以及test.csv中的第i个样本，qi是查询，ti是产品名，di是产品描述。使用ri和vi来表示<strong>median_relevance</strong>和<strong>relevance_variance</strong>。使用函数ngram(s,n)去提取句子中的n个词。例如<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%883.09.02.png" alt=""></p>
<h3 id="计数特征"><a href="#计数特征" class="headerlink" title="计数特征"></a>计数特征</h3><p>为$$\left{q_{i}, t_{i}, d_{i}\right}$$生成计数特征。</p>
<h4 id="基础计数特征"><a href="#基础计数特征" class="headerlink" title="基础计数特征"></a>基础计数特征</h4><p><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%883.17.52.png" alt=""></p>
<h4 id="交叉计数特征"><a href="#交叉计数特征" class="headerlink" title="交叉计数特征"></a>交叉计数特征</h4><p><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%883.20.07.png" alt=""></p>
<h4 id="交叉位置特征"><a href="#交叉位置特征" class="headerlink" title="交叉位置特征"></a>交叉位置特征</h4><p><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%883.23.08.png" alt=""></p>
<h3 id="距离特征"><a href="#距离特征" class="headerlink" title="距离特征"></a>距离特征</h3><p><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%883.24.35.png" alt=""></p>
<h3 id="TF-IDF特征"><a href="#TF-IDF特征" class="headerlink" title="TF-IDF特征"></a>TF-IDF特征</h3><h3 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h3><h4 id="查询ID"><a href="#查询ID" class="headerlink" title="查询ID"></a>查询ID</h4><p>将查询id进行独热编码。</p>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>相同的模型经常被用来在特征集上进行交叉验证来测试与之前的特征集合相比是否得分有所提升。对于高维特征，使用XGBoost with linear booster(MSE为目标函数)，对于低维特征使用sklearn中的ExtraTreesRegressor。</p>
<p>值得注意的是，有了集成选择(<strong>ensemble selection</strong>)，我们可以利用不同的特征集合来训练特征库，并且利用集成选择去挑选出最佳的集成。但是特征选择依旧有用。使用上述的特征选择，可以首先明确一些表现好的特征集合，然后使用其去训练模型，这会在一定程度上减少计算负担。</p>
<h2 id="模型技术和训练"><a href="#模型技术和训练" class="headerlink" title="模型技术和训练"></a>模型技术和训练</h2><h3 id="交叉验证方法学"><a href="#交叉验证方法学" class="headerlink" title="交叉验证方法学"></a>交叉验证方法学</h3><h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><p>StratifiedKFold</p>
<h1 id="Kaggle-HomeDepot"><a href="#Kaggle-HomeDepot" class="headerlink" title="Kaggle_HomeDepot"></a>Kaggle_HomeDepot</h1><p><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/FlowChart%202.jpg" alt=""></p>
<h1 id="Kaggle——销售量预测"><a href="#Kaggle——销售量预测" class="headerlink" title="Kaggle——销售量预测"></a>Kaggle——销售量预测</h1><p>比赛地址<a href="https://www.kaggle.com/c/competitive-data-science-predict-future-sales/data" target="_blank" rel="noopener">Predict Future Sales | Kaggle</a><br>这个比赛作为经典的时间序列问题之一，目标是为了预测下个月每种产品和商店的总销售额。</p>
<p>以下为<strong>1st solution</strong>。</p>
<h2 id="part1-hands-on-data"><a href="#part1-hands-on-data" class="headerlink" title="part1 hands on data"></a>part1 hands on data</h2><p><a href="https://www.kaggle.com/kyakovlev/1st-place-solution-part-1-hands-on-data/notebook" target="_blank" rel="noopener">https://www.kaggle.com/kyakovlev/1st-place-solution-part-1-hands-on-data/notebook</a></p>
<h3 id="数据域含义"><a href="#数据域含义" class="headerlink" title="数据域含义"></a>数据域含义</h3><p><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%888.55.03.png" alt=""><br>数据集情况：<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%889.04.04.png" alt=""></p>
<p><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%889.04.46.png" alt=""></p>
<h3 id="trick1"><a href="#trick1" class="headerlink" title="trick1"></a>trick1</h3><p><strong>downcasting DataFrame.</strong> It will save some memory, everyone will need all memory possible.</p>
<p>In this case from 134.4MB to 61.6 MB</p>
<h3 id="trick2"><a href="#trick2" class="headerlink" title="trick2"></a>trick2</h3><p>pd.pivot_table()透视表功能<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-12%20%E4%B8%8B%E5%8D%888.52.35.png" alt=""></p>
<h3 id="trick3"><a href="#trick3" class="headerlink" title="trick3"></a>trick3</h3><p>利用图像去除极端值<br>使用<strong>seaborn</strong>。boxplot</p>
<h3 id="item-id"><a href="#item-id" class="headerlink" title="item_id"></a>item_id</h3><p>以item_id为索引，月份为列名生成表格来观察数据。<br>分析每个月销售的总和的趋势。<br>分析每个平均一个商品销售的趋势（和👆趋势一致）<br>查看有多少6个月来没有销售记录的商品<br>查看测试数据中有多少这样过期的商品<br>查看价格和销售额的离群点</p>
<p>可能的特征：</p>
<ol>
<li>时间间隔</li>
<li>商品放出的日期</li>
<li>上月的销售</li>
<li>销售的日期</li>
<li>临近的商品（id1000与1001的商品可能有所相似）</li>
</ol>
<h3 id="shop-id"><a href="#shop-id" class="headerlink" title="shop_id"></a>shop_id</h3><p>以shop_id为索引，月份为列名生成表格来观察数据。<br>查看最近开张的商店数<br>查看最近倒闭的商店数</p>
<p>可能的特征：</p>
<ol>
<li>时间间隔（shop_id/shp_cnt_mth）</li>
<li>开业月份（可能的开业促销活动）</li>
<li>倒闭月份（可能的清仓大甩卖）<h3 id="price"><a href="#price" class="headerlink" title="price"></a>price</h3>可能的特征：</li>
<li>价格分档（1/10/20/等等），显然，更低价的物品拥有着更大的销量。</li>
<li>打折和打折期间</li>
<li>价格的时间间隔（显示打折）</li>
<li>价格修正</li>
<li>店铺的收入<h3 id="dates"><a href="#dates" class="headerlink" title="dates"></a>dates</h3>可能的日期特征：</li>
<li>周末和假期的销售额（去修正月度的销售）</li>
<li>该月有几天（去修正月度的销售）</li>
<li>是第几个月（与季节性的物品有关）</li>
</ol>
<h3 id="shop-info"><a href="#shop-info" class="headerlink" title="shop info"></a>shop info</h3><p>shop city | shop type | shop name</p>
<p>可能的商店特征：</p>
<ol>
<li>shop city</li>
<li>shop type</li>
</ol>
<h3 id="items-csv"><a href="#items-csv" class="headerlink" title="items.csv"></a>items.csv</h3><p>从items.csv中挖掘特征<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-13%20%E4%B8%8B%E5%8D%883.18.54.png" alt=""><br>可能的特征，1.item name 2.Encoded aditional feature</p>
<h3 id="category-csv"><a href="#category-csv" class="headerlink" title="category.csv"></a>category.csv</h3><p>category.csv中满足的格式<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-13%20%E4%B8%8B%E5%8D%883.25.09.png" alt=""><br>可能的种类特征：</p>
<ol>
<li>部分</li>
<li>主要种类的名字</li>
<li>主要子种类的名字</li>
<li>第二子种类的名字</li>
</ol>
<h3 id="test-set"><a href="#test-set" class="headerlink" title="test set"></a>test set</h3><p>对测试数据集进行分析<br>将测试条目分为三组：</p>
<ol>
<li>Item/shop pairs that are in train</li>
<li>Items without any data</li>
<li>Items that are in train</li>
</ol>
<h1 id="Kaggle——销售量预测-1"><a href="#Kaggle——销售量预测-1" class="headerlink" title="Kaggle——销售量预测"></a>Kaggle——销售量预测</h1><p>没有看错，接下来是另一个solution<br>主要是Feature Engineering，XGBoost<br><a href="https://www.kaggle.com/dlarionov/feature-engineering-xgboost" target="_blank" rel="noopener">https://www.kaggle.com/dlarionov/feature-engineering-xgboost</a></p>
<h2 id="part1-，perfect-features"><a href="#part1-，perfect-features" class="headerlink" title="part1 ，perfect features"></a>part1 ，perfect features</h2><p>同样使用sns 显示后，去除离群点<br>其中有一个物品的价格是负，使用价格中位数来替换之。<br>根据名字来看有些商店id重复出现了，fix it。<br>对于商店，种类，物品进行预处理</p>
<h3 id="Monthly-sales"><a href="#Monthly-sales" class="headerlink" title="Monthly sales"></a>Monthly sales</h3><p>新增特征revenue：<br>train[‘revenue’] = train[‘item_price’] *  train[‘item_cnt_day’]</p>
<p>测试集是34个月中一些商店和一些物品的组合，共有5100 items * 42 shops = 2142400对组合。363个物品在训练集中是没有的。因此，对于大多数测试集中的物品目标值应该是0.另一个方面，训练集只包含过去售出或者退回的对。主要的思路是计算月度的销售将其在当月的对中用0值进行扩展。这样训练数据将会与测试数据相似。</p>
<p>将训练集中的 shop/item对去聚合去计算目标聚合，然后将目标值截取为（0，20），这样训练目标值将会与测试预测相似。</p>
<h3 id="测试集"><a href="#测试集" class="headerlink" title="测试集"></a>测试集</h3><p>将测试集的月份设置为34，并与训练集进行合并</p>
<h3 id="Shops-Items-Cats-features"><a href="#Shops-Items-Cats-features" class="headerlink" title="Shops/Items/Cats features"></a>Shops/Items/Cats features</h3><p>将shop，item，item_category表进行合并</p>
<h3 id="Traget-lags"><a href="#Traget-lags" class="headerlink" title="Traget lags"></a>Traget lags</h3><p>相当于将窗口移动，[0,33]，lags为1则为[1,33]</p>
<h3 id="均值编码特征"><a href="#均值编码特征" class="headerlink" title="均值编码特征"></a>均值编码特征</h3><p>表格的特征的命名形式为  feature1_feature2_avg_feature_cnt<br>意思为选定feature1,feature2,来聚合feature_cnt求均值。<br>求每个月中物品售出的均值数 0.3左右<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-13%20%E4%B8%8B%E5%8D%888.09.49.png" alt=""></p>
<p>求每个月中每个物品所对应的均值（可以理解为平均每家商店售出的值）<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-13%20%E4%B8%8B%E5%8D%888.11.42.png" alt=""></p>
<p>选定date_block_num，shop_id，在item_cnt_month聚合求均值<br>可以理解为一个月一家店销售物品数量的均值数<br><img src="/img/media/Kaggle%E7%AB%9E%E8%B5%9B%E6%A1%88%E4%BE%8B%E4%B8%80/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-13%20%E4%B8%8B%E5%8D%888.27.11.png" alt=""></p>
<p>同理还有：<br>选定date_block_num，item_category_id，在item_cnt_month聚合求均值<br>选定date_block_num，item_category_id，shop_id，在item_cnt_month聚合求均值<br>选定date_block_num，type_code，shop_id，在item_cnt_month聚合求均值<br>选定date_block_num，subtype_code，shop_id，在item_cnt_month聚合求均值<br>选定date_block_num，city_code，在item_cnt_month聚合求均值<br>选定date_block_num，city_code，item_id 在item_cnt_month聚合求均值<br>选定date_block_num，type_code 在item_cnt_month聚合求均值<br>选定date_block_num，subtype_code 在item_cnt_month聚合求均值</p>
<h3 id="trend-features"><a href="#trend-features" class="headerlink" title="trend features"></a>trend features</h3><p>上六个月的价格趋势。<br>上个月的商店的营收趋势。</p>
<h3 id="Special-features"><a href="#Special-features" class="headerlink" title="Special features"></a>Special features</h3><p>将月份中添加上天数</p>
<p>对于每个shop/item对上一笔销售的月，使用编程方法实现：<br>创建HashTable键值等于{shop_id,item_id},值等于date_block_num。对于数据表从上往下迭代。如果{row.shop_id,row.item_id}不在表中，则添加进表中，并将值设为row.date_block_num。如果HashTable中包含值，则计算cached value与row.date_block_num。</p>
<p>Months since the first sale for each shop/item pair and for item only.</p>
<h3 id="最终准备"><a href="#最终准备" class="headerlink" title="最终准备"></a>最终准备</h3><p>Because of the using 12 as lag value drop first 12 months. Also drop all the columns with this month calculated values (other words which can not be calcucated for the test set).</p>
<p>Producing lags brings a lot of nulls.</p>
<h2 id="part2-xgboost"><a href="#part2-xgboost" class="headerlink" title="part2 ,xgboost"></a>part2 ,xgboost</h2>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/04/14/XGBoost调参/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/XGBoost调参/" class="post-title-link" itemprop="url">XGBoost调参</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-14 14:54:47 / 修改时间：15:34:58" itemprop="dateCreated datePublished" datetime="2019-04-14T14:54:47+08:00">2019-04-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/14/XGBoost调参/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/14/XGBoost调参/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/14/XGBoost调参/" class="post-meta-item leancloud_visitors" data-flag-title="XGBoost调参">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="XGBoost调参"><a href="#XGBoost调参" class="headerlink" title="XGBoost调参"></a>XGBoost调参</h1><p><a href="https://www.cnblogs.com/mfryf/p/6293814.html" target="_blank" rel="noopener">XGBoost参数调优完全指南（附Python代码） - 知识天地 - 博客园</a></p>
<h1 id="XGBoost的优势"><a href="#XGBoost的优势" class="headerlink" title="XGBoost的优势"></a>XGBoost的优势</h1><ol>
<li><strong>正则化</strong>，标准GBM的实现没有像XGBoost这样的正则化步骤。正则化对减少过拟合也是有帮助的。</li>
<li><strong>并行处理</strong>，XGBoost可以实现并行处理，相比GBM有了速度的飞跃。主要不是生成树的Boosting阶段，而是计算gain的阶段。</li>
<li><strong>高度的灵活性</strong>，XGBoost 允许用户定义自定义优化目标和评价标准 它对模型增加了一个全新的维度，所以我们的处理不会受到任何限制。</li>
<li><strong>缺失值处理</strong>，XGBoost内置处理缺失值的规则。 用户需要提供一个和其它样本不同的值，然后把它作为一个参数传进去，以此来作为缺失值的取值。XGBoost在不同节点遇到缺失值时采用不同的处理方法，并且会学习未来遇到缺失值时的处理方法。</li>
<li><strong>剪枝</strong>，当分裂时遇到一个负损失时，GBM会停止分裂。因此GBM实际上是一个贪心算法。 XGBoost会一直分裂到指定的最大深度(max_depth)，然后回过头来剪枝。如果某个节点之后不再有正值，它会去除这个分裂。 这种做法的优点，当一个负损失（如-2）后面有个正损失（如+10）的时候，就显现出来了。GBM会在-2处停下来，因为它遇到了一个负值。但是XGBoost会继续分裂，然后发现这两个分裂综合起来会得到+8，因此会保留这两个分裂。</li>
<li><strong>内置交叉验证</strong>，XGBoost允许在每一轮boosting迭代中使用交叉验证。因此，可以方便地获得最优boosting迭代次数。 而GBM使用网格搜索，只能检测有限个值。</li>
<li><strong>在已有的模型基础上继续</strong>，XGBoost可以在上一轮的结果上继续训练。这个特性在某些特定的应用上是一个巨大的优势。 sklearn中的GBM的实现也有这个功能，两种算法在这一点上是一致的。</li>
</ol>
<h1 id="XGBoost的参数"><a href="#XGBoost的参数" class="headerlink" title="XGBoost的参数"></a>XGBoost的参数</h1><h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2><ol>
<li><strong>booster[默认gbtree]</strong>，选择每次迭代的模型，有两种选择：gbtree：基于树的模型，gbliner：线性模型。尽管有两种booster可供选择，这里只介绍tree booster，因为它的表现远远胜过linear booster，所以linear booster很少用到。</li>
<li><strong>silent[默认0]</strong>，当这个参数值为1时，静默模式开启，不会输出任何信息。一般这个参数就保持默认的0，因为这样能帮我们更好地理解模型。</li>
<li><strong>nthread[默认值为最大可能的线程数]</strong>，这个参数用来进行多线程控制，应当输入系统的核数。 如果你希望使用CPU全部的核，那就不要输入这个参数，算法会自动检测它。<h2 id="booster参数"><a href="#booster参数" class="headerlink" title="booster参数"></a>booster参数</h2></li>
<li><strong>eta[默认0.3]</strong>，和GBM中的 learning rate 参数类似。 通过减少每一步的权重，可以提高模型的鲁棒性。 典型值为0.01-0.2。</li>
<li><strong>min_child_weight[默认1]</strong>，决定最小叶子节点样本权重和。 和GBM的 min_child_leaf 参数类似，但不完全一样。XGBoost的这个参数是最小样本权重的和，而GBM参数是最小样本总数。 这个参数用于避免过拟合。当它的值较大时，可以避免模型学习到局部的特殊样本。 但是如果这个值过高，会导致欠拟合。这个参数需要使用CV  (cross_validition) 来调整。</li>
<li><strong>max_depth[默认6]</strong>，和GBM中的参数相同，这个值为树的最大深度。 这个值也是用来避免过拟合的。max_depth越大，模型会学到更具体更局部的样本。 需要使用CV函数来进行调优。 典型值：3-10</li>
<li><strong>max_leaf_nodes</strong>，树上最大的节点或叶子的数量。 可以替代max_depth的作用。因为如果生成的是二叉树，一个深度为n的树最多生成n2个叶子。 如果定义了这个参数，GBM会忽略max_depth参数。</li>
<li><strong>gamma[默认0]</strong>，在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。 这个参数的值越大，算法越保守。这个参数的值和损失函数息息相关，所以是需要调整的。</li>
<li><strong>max_delta_step[默认0]</strong>，这参数限制每棵树权重改变的最大步长。如果这个参数的值为0，那就意味着没有约束。如果它被赋予了某个正值，那么它会让这个算法更加保守。 通常，这个参数不需要设置。但是当各类别的样本十分不平衡时，它对逻辑回归是很有帮助的。 这个参数一般用不到，但是你可以挖掘出来它更多的用处。</li>
<li><strong>subsample[默认1]</strong>，和GBM中的subsample参数一模一样。这个参数控制对于每棵树，随机采样的比例。 减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。 典型值：0.5-1</li>
<li><strong>colsample_bytree[默认1]</strong>，和GBM里面的max_features参数类似。用来控制每棵随机采样的列数的占比(每一列是一个特征)。 典型值：0.5-1</li>
<li><strong>colsample_bylevel[默认1]</strong>,用来控制树的每一级的每一次分裂，对列数的采样的占比。 我个人一般不太用这个参数，因为subsample参数和colsample_bytree参数可以起到相同的作用。但是如果感兴趣，可以挖掘这个参数更多的用处。</li>
<li><strong>lambda[默认1]</strong>,权重的L2正则化项。(和Ridge regression类似)。 这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。</li>
<li><strong>alpha[默认1]</strong>,权重的L1正则化项。(和Lasso regression类似)。 可以应用在很高维度的情况下，使得算法的速度更快。</li>
<li><strong>scale_pos_weight[默认1]</strong>,在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。</li>
</ol>
<h2 id="学习目标参数"><a href="#学习目标参数" class="headerlink" title="学习目标参数"></a>学习目标参数</h2><ol>
<li><strong>objective[默认reg:linear]</strong>，这个参数定义需要被最小化的损失函数。最常用的值有：binary:logistic 二分类的逻辑回归，返回预测的概率(不是类别)。multi:softmax 使用softmax的多分类器，返回预测的类别(不是概率)。在这种情况下，你还需要多设一个参数：num_class(类别数目)。 multi:softprob 和multi:softmax参数一样，但是返回的是每个数据属于各个类别的概率。</li>
<li><strong>eval_metric[默认值取决于objective参数的取值]</strong>，对于有效数据的度量方法。 对于回归问题，默认值是rmse，对于分类问题，默认值是error。 典型值有：rmse 均方根误差，mae 平均绝对误差(∑Ni=1|?|N) logloss 负对数似然函数值 error 二分类错误率(阈值为0.5) merror 多分类错误率 mlogloss 多分类logloss损失函数 auc 曲线下面积。</li>
<li><strong>seed(默认0)</strong>，随机数的种子 设置它可以复现随机数据的结果，也可以用于调整参数。</li>
</ol>
<h1 id="参数调优的一般方法"><a href="#参数调优的一般方法" class="headerlink" title="参数调优的一般方法"></a>参数调优的一般方法</h1><p>我们会使用和GBM中相似的方法。需要进行如下步骤：</p>
<ol>
<li>选择较高的学习速率(learning rate)。一般情况下，学习速率的值为0.1。但是，对于不同的问题，理想的学习速率有时候会在0.05到0.3之间波动。选择对应于此学习速率的理想决策树数量。XGBoost有一个很有用的函数“cv”，这个函数可以在每一次迭代中使用交叉验证，并返回理想的决策树数量。</li>
<li>对于给定的学习速率和决策树数量，进行决策树特定参数调优(max_depth, min_child_weight, gamma, subsample, colsample_bytree)。在确定一棵树的过程中，可以选择不同的参数。</li>
<li>xgboost的正则化参数的调优。(lambda, alpha)。这些参数可以降低模型的复杂度，从而提高模型的表现。</li>
<li>降低学习速率，确定理想参数。<h1 id="用xgboost模型对特征重要性进行排序"><a href="#用xgboost模型对特征重要性进行排序" class="headerlink" title="用xgboost模型对特征重要性进行排序"></a>用xgboost模型对特征重要性进行排序</h1><h2 id="梯度提升算法是如何计算特征重要性的？"><a href="#梯度提升算法是如何计算特征重要性的？" class="headerlink" title="梯度提升算法是如何计算特征重要性的？"></a>梯度提升算法是如何计算特征重要性的？</h2>使用梯度提升算法的好处是在提升树被创建后，可以相对直接地得到每个属性的重要性得分。一般来说，重要性分数，衡量了特征在模型中的提升决策树构建中价值。一个属性越多的被用来在模型中构建决策树，它的重要性就相对越高。</li>
</ol>
<p>属性重要性是通过对数据集中的每个属性进行计算，并进行排序得到。在单个决策树中通过每个属性分裂点改进性能度量的量来计算属性重要性，由节点负责加权和记录次数。也就说一个属性对分裂点改进性能度量越大（越靠近根节点），权值越大；被越多提升树所选择，属性越重要。性能度量可以是选择分裂节点的Gini纯度，也可以是其他度量函数。</p>
<p>最终将一个属性在所有提升树中的结果进行加权求和后然后平均，得到重要性得分。</p>
<h2 id="根据xgboost特征重要性得分进行特征选择"><a href="#根据xgboost特征重要性得分进行特征选择" class="headerlink" title="根据xgboost特征重要性得分进行特征选择"></a>根据xgboost特征重要性得分进行特征选择</h2><p>特征重要性得分，可以用于在scikit-learn中进行特征选择。通过SelectFromModel类实现，该类采用模型并将数据集转换为具有选定特征的子集。这个类可以采取预先训练的模型，例如在整个数据集上训练的模型。然后，它可以阈值来决定选择哪些特征。当在SelectFromModel实例上调用transform()方法时，该阈值被用于在训练集和测试集上一致性选择相同特征。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>1、仅仅靠参数的调整和模型的小幅优化，想要让模型的表现有个大幅度提升是不可能的。GBM的最高得分是0.8487，XGBoost的最高得分是0.8494。确实是有一定的提升，但是没有达到质的飞跃。<br>2、要想让模型的表现有一个质的飞跃，需要依靠其他的手段，诸如，特征工程(feature egineering) ，模型组合(ensemble of model),以及堆叠(stacking)等。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/04/09/特征选择/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/09/特征选择/" class="post-title-link" itemprop="url">特征选择</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-09 10:09:47 / 修改时间：10:10:16" itemprop="dateCreated datePublished" datetime="2019-04-09T10:09:47+08:00">2019-04-09</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/09/特征选择/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/特征选择/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/09/特征选择/" class="post-meta-item leancloud_visitors" data-flag-title="特征选择">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>特征选择是特征工程里的一个重要问题，其目标是寻找最优特征子集。特征选择的目的有如下三个：</p>
<ol>
<li>简化模型，使模型更易于研究人员和用户理解。</li>
<li>改善性能。节省存储和计算开销。</li>
<li>改善通用性，降低过拟合的风险。</li>
</ol>
<p>特征选择的一般流程<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/v2-a69a37aaa14a8040b4d867d7058aafe9_hd.jpg" alt=""><br>主要分为产生过程，评估过程，停止条件和验证过程。</p>
<p><strong>当特征数量很大的时候， 这个搜索空间会很大，如何找最优特征还是需要一些经验结论。</strong></p>
<h1 id="具体特征选择方法"><a href="#具体特征选择方法" class="headerlink" title="具体特征选择方法"></a>具体特征选择方法</h1><p>分为三大类：</p>
<ol>
<li>Filter：过滤法，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</li>
<li>Wrapper：包装法，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</li>
<li>Embedded：嵌入法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小排序选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</li>
</ol>
<h2 id="过滤特征选择"><a href="#过滤特征选择" class="headerlink" title="过滤特征选择"></a>过滤特征选择</h2><p>过滤特征选择法的想法是针对每个特征 x_i ，i 从 1 到 n ，计算 x_i 相对于类别标签 y 的信息量 S(i) ，得到 n 个结果，然后将 n 个 S(i) 按照从大到小排序，输出前 k  个特征。显然，这样复杂度大大降低。那么关键的问题就是使用什么样的方法来度量 S(i) ，我们的目标是选取与 y 关联最密切的一些 特征x_i 。</p>
<h3 id="Pearson相关系数"><a href="#Pearson相关系数" class="headerlink" title="Pearson相关系数"></a>Pearson相关系数</h3><p>皮尔森相关系数是一种最简单的，能帮助理解特征和响应变量之间关系的方法，该方法衡量的是变量之间的线性相关性，结果的取值区间为 [-1,1] ， -1 表示完全的负相关(这个变量下降，那个就会上升)， +1 表示完全的正相关， 0 表示没有线性相关。Pearson Correlation速度快、易于计算，经常在拿到数据(经过清洗和特征提取之后的)之后第一时间就执行。Scipy的pearsonr方法能够同时计算相关系数和p-value，<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8A%E5%8D%8810.03.30.png" alt=""><br>Pearson相关系数的一个<strong>明显缺陷</strong>是，作为特征排序机制，他只对<strong>线性关系敏感</strong>。如果关系是非线性的，即便两个变量具有一一对应的关系，Pearson相关性也可能会接近 0 。</p>
<h3 id="卡方验证"><a href="#卡方验证" class="headerlink" title="卡方验证"></a>卡方验证</h3><p>什么是卡方检验：<br>卡方检验就是检验两个变量之间有没有关系。<br>以运营为例:<br>卡方检验可以检验男性或者女性对线上买生鲜食品有没有区别；<br>不同城市级别的消费者对买SUV车有没有什么区别；<br>如果有显著区别的话，我们会考虑把这些变量放到模型或者分析里去。</p>
<p>注意：<strong>卡方检验针对分类变量。</strong></p>
<p><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8A%E5%8D%8810.42.27.png" alt=""><br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8A%E5%8D%8810.42.41.png" alt=""><br>置信度的话，我们按照我们自己意愿挑选，一般我们会挑90％或者95%。<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8A%E5%8D%8810.47.39.png" alt=""><br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8A%E5%8D%8810.48.01.png" alt=""><br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8A%E5%8D%8811.00.32.png" alt=""><br>卡方检验就是统计样本的实际观测值与理论推断值之间的偏离程度，实际观测值与理论推断值之间的偏离程度就决定卡方值的大小，如果卡方值越大，二者偏差程度越大；反之，二者偏差越小；若两个值完全相等时，卡方值就为0，表明理论值完全符合。</p>
<p>不难发现，这个统计量的含义简而言之就是自变量对因变量的相关性。用sklearn中feature_selection库的SelectKBest类结合卡方检验来选择特征的代码如下：<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8A%E5%8D%8810.31.35.png" alt=""><br>sklearn.feature_selection模块中的类可以用于样本集中的特征选择/维数降低，以提高估计器的准确度分数或提高其在非常高维数据集上的性能</p>
<h3 id="互信息和最大信息系数"><a href="#互信息和最大信息系数" class="headerlink" title="互信息和最大信息系数"></a>互信息和最大信息系数</h3><p>经典的互信息也是评价定性自变量对定性因变量的相关性的，互信息公式如下：<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8B%E5%8D%8812.39.16.png" alt=""><br>当 x_i 是0/1离散值的时候，这个公式如上。很容易推广到 x_i 是多个离散值的情况。这里的 p(x_i,y) , p(x_i) 和 p(y) 都是从训练集上得到的。<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8B%E5%8D%8812.40.00.png" alt=""><br>MI 衡量的是 x_i 和 y 的独立性。如果它俩独立 P(x_i,y)=p(x_i)p(y) ，那么 KL 距离值为0，也就是 x_i 和 y 不相关了，可以去除 x_i 。相反，<strong>如果两者密切相关，那么 MI 值会很大。</strong></p>
<p>在对 MI 进行排名后，最后剩余的问题就是如何选择 k 个值（前 k 个 x_i ）。我们继续使用交叉验证的方法，将 k 从 1 扫描到 n ，取最大的 F 。</p>
<p>想把互信息直接用于特征选择其实不是太方便：1、它不属于度量方式，也没有办法归一化，在不同数据及上的结果无法做比较；2、对于连续变量的计算不是很方便（ X 和 Y 都是集合, x_i, y 都是离散的取值），通常变量需要先离散化，而互信息的结果对离散化的方式很敏感。</p>
<p>最大信息系数克服了这两个问题。它首先寻找一种最优的离散化方式，然后把互信息取值转换成一种度量方式，取值区间在 [0,1] 。minepy提供了MIC功能。</p>
<p> 如y=x^2 这个例子，MIC算出来的互信息值为1(最大的取值)。代码如下：<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-08%20%E4%B8%8B%E5%8D%8812.50.37.png" alt=""></p>
<h3 id="距离相关系数"><a href="#距离相关系数" class="headerlink" title="距离相关系数"></a>距离相关系数</h3><p>距离相关系数是为了克服Pearson相关系数的弱点而生的。在 x 和 x^2 这个例子中，即便Pearson相关系数是 0 ，我们也不能断定这两个变量是独立的（<strong>有可能是非线性相关</strong>）；但如果距离相关系数是 0 ，那么我们就可以说这两个变量是独立的。</p>
<p>尽管有MIC和距离相关系数在了，但当变量之间的关系接近线性相关的时候，Pearson相关系数仍然是不可替代的。第一、Pearson相关系数计算速度快，这在处理大规模数据的时候很重要。第二、Pearson相关系数的取值区间是[-1，1]，而MIC和距离相关系数都是[0，1]。这个特点使得Pearson相关系数能够表征更丰富的关系，符号表示关系的正负，绝对值能够表示强度。当然，Pearson相关性有效的前提是两个变量的变化关系是单调的。</p>
<h3 id="方差选择法"><a href="#方差选择法" class="headerlink" title="方差选择法"></a>方差选择法</h3><p>过滤特征选择法还有一种方法不需要度量特征 x_i 和类别标签 y 的信息量。这种方法先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征。</p>
<p>例如，假设我们有一个具有布尔特征的数据集，并且我们要删所有01特征中出现0的概率超过80%的特征。布尔特征是伯努利随机变量，这些变量的方差由下式给出:<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-09%20%E4%B8%8A%E5%8D%889.06.28.png" alt=""><br>VarianceThreshold是特征选择的简单基线方法。它删除方差不符合某个阈值的所有特征。默认情况下，它会删除所有零差异特征，即所有样本中具有相同值的特征。代码如下：<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-09%20%E4%B8%8A%E5%8D%889.08.42.png" alt=""><br>输出结果：<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-09%20%E4%B8%8A%E5%8D%889.09.21.png" alt=""><br>如预期的那样，VarianceThreshold已经删除了第一列，其具有 p=5/6&gt;0.8 包含零的概率。</p>
<h2 id="包装-wrapper-特征选择"><a href="#包装-wrapper-特征选择" class="headerlink" title="包装(wrapper)特征选择"></a>包装(wrapper)特征选择</h2><p>Wrapper这里指不断地使用不同的特征组合来测试学习算法进行特征选择。先选定特定算法， 一般会选用普遍效果较好的算法， 例如Random Forest， SVM， kNN等等。</p>
<h3 id="前向搜索"><a href="#前向搜索" class="headerlink" title="前向搜索"></a>前向搜索</h3><p>前向搜索说白了就是每次增量地从剩余未选中的特征选出一个加入特征集中，待达到阈值或者 n 时，从所有的 F 中选出错误率最小的。过程如下：</p>
<ol>
<li>初始化特征集 F 为空。</li>
<li>扫描 i 从 1 到 n如果第 i 个特征不在 F 中，那么特征 i 和F 放在一起作为 F_i (即取并集，在只使用 F_i 中特征的情况下，利用交叉验证来得到 F_i 的错误率。</li>
<li>从上步中得到的 n 个 F_i 中选出错误率最小的 F_i ,更新 F 为 F_i 。</li>
<li>如果 F 中的特征数达到了 n 或者预定的阈值（如果有的话），那么输出整个搜索过程中最好的 ；若没达到，则转到 2，继续扫描。</li>
</ol>
<h3 id="后向搜索"><a href="#后向搜索" class="headerlink" title="后向搜索"></a>后向搜索</h3><p>既然有增量加，那么也会有增量减，后者称为后向搜索。先将 F 设置为 {1,2,…,n} ，然后每次删除一个特征，并评价，直到达到阈值或者为空，然后选择最佳的 F 。</p>
<p><strong>这两种算法都可以工作，但是计算复杂度比较大。</strong>时间复杂度为<br>O(n+(n-1)+(n-2)+…+1)=O(n^2)</p>
<h3 id="递归特征消除法"><a href="#递归特征消除法" class="headerlink" title="递归特征消除法"></a>递归特征消除法</h3><p>递归消除特征法使用一个基模型来进行多轮训练，每轮训练后，消除若干权值系数的特征，再基于新的特征集进行下一轮训练。使用feature_selection库的RFE类来选择特征的代码如下：<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-09%20%E4%B8%8A%E5%8D%889.30.05.png" alt=""></p>
<h2 id="嵌入-Embedded-特征选择"><a href="#嵌入-Embedded-特征选择" class="headerlink" title="嵌入(Embedded)特征选择"></a>嵌入(Embedded)特征选择</h2><h3 id="基于惩罚项的特征选择法"><a href="#基于惩罚项的特征选择法" class="headerlink" title="基于惩罚项的特征选择法"></a>基于惩罚项的特征选择法</h3><p>通过L1正则项来选择特征：L1正则方法具有稀疏解的特性，因此天然具备特征选择的特性，但是要注意，L1没有选到的特征不代表不重要，原因是两个具有高相关性的特征可能只保留了一个，如果要确定哪个特征重要应再通过L2正则方法交叉检验。</p>
<h3 id="基于学习模型的特征排序"><a href="#基于学习模型的特征排序" class="headerlink" title="基于学习模型的特征排序"></a>基于学习模型的特征排序</h3><p>这种方法的思路是直接使用你要用的机器学习算法，针对每个单独的特征和响应变量建立预测模型。假如某个特征和响应变量之间的关系是非线性的，可以用基于树的方法（决策树、随机森林）、或者扩展的线性模型等。基于树的方法比较易于使用，因为他们对非线性关系的建模比较好，并且不需要太多的调试。但要注意过拟合问题，因此树的深度最好不要太大，再就是运用交叉验证。通过这种训练对特征进行打分获得相关性后再训练最终模型。</p>
<p>在波士顿房价数据集上使用sklearn的随机森林回归给出一个单变量选择的例子：<br><img src="/img/media/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-09%20%E4%B8%8A%E5%8D%889.52.18.png" alt=""></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/04/04/百面  特征工程/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/04/百面  特征工程/" class="post-title-link" itemprop="url">百面  特征工程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-04 20:00:47 / 修改时间：20:00:50" itemprop="dateCreated datePublished" datetime="2019-04-04T20:00:47+08:00">2019-04-04</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/04/百面  特征工程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/04/百面  特征工程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/04/百面  特征工程/" class="post-meta-item leancloud_visitors" data-flag-title="百面  特征工程">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="百面-特征工程"><a href="#百面-特征工程" class="headerlink" title="百面  特征工程"></a>百面  特征工程</h1><p>Garbage in, garbage out。对于一个机器学习问题，<strong>数据和特征</strong>往往<strong>决定</strong>结果的<strong>上限</strong>，而模型，<strong>算法</strong>的选择及优化是在逐步<strong>接近</strong>这个<strong>上限</strong>。</p>
<p>特征工程，顾名思义，是对原始数据进行一系列工程处理，将其提炼为特征，作为<strong>输入</strong>供算法和模型使用。从本质上来讲，特征工程是一个表示和展现数据的过程。在实际工作中，特征工程旨在去除原始数据中的杂质和冗余，设计更高效的特征以刻画求解的问题与预测模型之间的关系。<strong>特征就是指input的x！</strong></p>
<p>有两种常用的数据类型：<br>(1) 结构化数据。结构化数据类型可以看作关系型数据库的一张表，每列都有清晰的定义，包含了数值型、类别型两种基本类型，每一行数据表示一个样本的信息。</p>
<p>（2）非结构化数据。非结构化数据主要包括文本，图像，音频，视频数据，其包含的信息无法用一个简单的数值表示，也没有清晰的类别定义，并且每条数据的大小各不相同。</p>
<h1 id="特征归一化"><a href="#特征归一化" class="headerlink" title="特征归一化"></a>特征归一化</h1><p>为了消除数据特征之间的量纲影响，我们需要对特征进行归一化处理，使得不同指标之间具有可比性。例如，分析一个人的身高和体重对健康的影响，如果<br>使用米(m)和千克(kg)作为单位，那么身高特征会在1.6~1.8m的数值范围内，体重特征会在50~100kg的范围内，分析出来的结果显然会倾向于数值差别比较大的体重特征。想要得到更为准确的结果，就需要进行特征归一化(Normalization)处理，使各指标处于同一数值量级，以便进行分析。</p>
<h2 id="为什么需要对数值类型的特征做归一化？"><a href="#为什么需要对数值类型的特征做归一化？" class="headerlink" title="为什么需要对数值类型的特征做归一化？"></a>为什么需要对数值类型的特征做归一化？</h2><p>对数值类型的特征做归—化可以将所有的特征都统一到一个大致相同的数值区间内。最常用的方法主要有以下两种。</p>
<p>(1)线性函数归一化(Min-Max Scaling) 。它对原始数据进行线性变换，使结果映射到[0, 1]的范围，实现对原始数据的等比缩放。归一化公式如下<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-03%20%E4%B8%8B%E5%8D%881.35.54.png" alt=""><br>（2）零均值归一化(Z-Score Normalization)。它会将原始数据映射到均值为0、标准差为1的分布上。具体来说，假设原始特征的均值为μ、标准差为δ，那么归一化公式定义为<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-03%20%E4%B8%8B%E5%8D%881.49.37.png" alt=""></p>
<p>对数值型特征做归一化的原因在于，<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/WechatIMG70.jpeg" alt=""></p>
<p>数据归一化不是万能的，在实际应用中，通过<strong>梯度下降法</strong>求解的模型通常是需要归一化的，包括线性回归，逻辑回归，支持向量机，神经网络等模型。但对于决策树模型则并不适用，以C4.5为例，决策树在进行节点分裂时主要依据数据集D关于特征x的信息增益比，而信息增益比跟特征是否经过归一化是无关的，因为归一化不会改变样本在特征x上的信息增益。</p>
<h1 id="类别型特征"><a href="#类别型特征" class="headerlink" title="类别型特征"></a>类别型特征</h1><p>类别型特征(Categorical Feature)主要是指性别(男、女)、血型(A、B、AB、O)等只在有限选项内取值的特征。类别型特征原始输入通常是字符串形式，除了决策树等少数模型能直接处理字符串形式的输入，<strong>对于逻辑回归、支持向量机等模型来说，类别型特征必须经过处理转换成数值型特征才能正确工作。</strong></p>
<h2 id="与处理时如何处理类别型特征？"><a href="#与处理时如何处理类别型特征？" class="headerlink" title="与处理时如何处理类别型特征？"></a>与处理时如何处理类别型特征？</h2><h3 id="序号编码"><a href="#序号编码" class="headerlink" title="序号编码"></a>序号编码</h3><p>序号编码通常用于处理类别间具有大小关系的数据。例如成绩，可以分为低、中、高三档，并且存在“高&gt;中&gt;低”的排序关系。序号编码会按照大小关系对类别型特征赋予一个数值ID,例如高表示为3、中表示为2、低表示为1,转换后依然保留了大小关系。</p>
<h3 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h3><p>独热编码通常用于处理类别间不具有大小关系的特征。例如血型，一共有4个取值(A型血、B型血、AB型血、O型血)，独热编码会把血型变成一个4维稀疏向量，A型血表示为(1,0,0,0) ，B型血表示为(0, 1,0,0)，AB型表示为(0, 0,1,0)，O型血表示为(0,0,0,1)。对于类别取值较多的情况下使用独热编码需要<br>注意以下问题。</p>
<p>(1)使用稀疏向量来节省空间。在独热编码下，特征向量只有某一维取值为1，其他位置取值均为0。因此可以利用向量的稀疏表示有效地节省空间，并且目<br>前大部分的算法均接受稀疏向量形式的输入。</p>
<p>(2)配合特征选择来降低维度。高维度特征会带来几方面的问题。一是在K近邻算法中，高维空间下两点之间的距离很难得到有效的衡量;二是在逻辑回归模型中，参数的数量会随着维度的增高而增加，容易引起过拟合问题;三是通常只有部分维度是对分类、预测有帮助，因此可以考虑配合特征选择来降低维度。</p>
<h3 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h3><p>二进制编码主要分为两步，先用序号编码给每个类别赋予一个类别ID,然后将类别ID对应的二进制编码作为结果。以A、B、AB、O血型为例，A型血的ID为1，二进制表示为001; B型血的ID为2，二进制表示为010;以此类推可以得到AB型血和O型血的二进制表示。可以看出，二进制编码本质上是利用二进制对ID进行哈希映射，最终得到0/1特征向量，且维数少于独热编码，节省了存储空间。</p>
<h1 id="组合特征"><a href="#组合特征" class="headerlink" title="组合特征"></a>组合特征</h1><h2 id="什么是组合特征？如何处理高维组合特征？"><a href="#什么是组合特征？如何处理高维组合特征？" class="headerlink" title="什么是组合特征？如何处理高维组合特征？"></a>什么是组合特征？如何处理高维组合特征？</h2><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。以广告点击预估问题为例，原始数据有语言和类型两种离散特征，表1.2是语言和类型对点击的影响。为了提高拟合能力，语言和类型可以组成二阶特征，表1.3是语言和类型的组合特征对点击的影响。<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/WechatIMG71.jpeg" alt=""><br><strong>表1.3乃组合特征矩阵。</strong><br>以逻辑回归为例，假设数据的特征向量为X=(x1,x2,…,xk)，则有，<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-03%20%E4%B8%8B%E5%8D%889.42.46.png" alt=""><br>其中&lt;xi,xj&gt;表示xi和xj的组合特征,wij的维度等于|xi| * |xj|，|xi|和|xj|分别代表第i个特征和第j个特征不同取值的个数。在上述表中，wij即为表1.3中的0或1。</p>
<p>若是关于用户和物品的矩阵，用户数量为m，物品数量为n，当m，n的数量巨大时，几乎无法学习m•n规模的参数。此时，有效的办法是将用户和物品分别用k维的低维向量表示，k远小于m和n。此时<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/page29image88376.jpg" alt=""><br>分别表示xi和xj对应的低维向量。需要学习的参数规模变为了m•k+n•k。这也就是推荐系统中的矩阵分解。</p>
<p>上述内容即为利用<strong>降维方法来减少两个高维特征组合后需要学习的参数。</strong></p>
<h1 id="组合特征-1"><a href="#组合特征-1" class="headerlink" title="组合特征"></a>组合特征</h1><p>在实际应用中，常常需要面对多种高维特征，简单地两两组合依然容易存在参数过多，过拟合等问题，而且并不是所有的特征组合都是有意义的。可以采用GBDT来构建特征。</p>
<h1 id="文本表示模型"><a href="#文本表示模型" class="headerlink" title="文本表示模型"></a>文本表示模型</h1><p>文本是一类非常重要的非结构化数据,如何表示文本数据一直是机器学习领域的一个重要研究方向。</p>
<h2 id="有哪些文本表示模型？各有什么优缺点？"><a href="#有哪些文本表示模型？各有什么优缺点？" class="headerlink" title="有哪些文本表示模型？各有什么优缺点？"></a>有哪些文本表示模型？各有什么优缺点？</h2><h3 id="词袋模型和N-gram模型"><a href="#词袋模型和N-gram模型" class="headerlink" title="词袋模型和N-gram模型"></a>词袋模型和N-gram模型</h3><p>最基础的文本表示模型是<strong>词袋模型</strong>。顾名思义,就是将每篇文章看成一袋子词,并忽略每个词出现的顺序。具体地说,就是将整段文本以词为单位切分开然后每篇文章可以表示成一个<strong>长向量</strong>,向量中的每一维代表一个单词,而该维对应的权重则反映了这个词在原文章中的重要程度。<strong>常用TF-IDF来计算权重</strong>,公式为<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-04%20%E4%B8%8B%E5%8D%886.43.52.png" alt=""><br>其中TF(t,d)为单词t在文档d中出现的频率,IDF(t)是<strong>逆文档频率</strong>,用来衡量单词t对表达语义所起的重要性,表示为<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-04%20%E4%B8%8B%E5%8D%886.46.07.png" alt=""><br>直观的解释是,如果一个单词在非常多的文章里面都出现,那么它可能是一个比较通用的词汇,对于区分某篇文章特殊语义的贡献较小,因此对权重做一定惩罚。</p>
<p>将文章进行单词级别的划分有时候并不是一种好的做法,比如英文中的natural  language processing(自然语言处理)一词,如果将 natural, language, processing这3个词拆分开来,所表达的含义与三个词连续出现时大相径庭。通常,可以将连续出现的n个词(n≤N)组成的词组(<strong>N-gram</strong>)也作为一个单独的特征放到向量表示中去,构成<strong>N-gram模型</strong>。另外,同一个词可能有多种词性变化,却具有相似的含义。在实际应用中,一般会对单词进行词干抽取(Word Stemming)处理,即将不同词性的单词统一成为同一词干的形式。</p>
<h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>主题模型用于从文本库中发现有代表性的主题，并且能够计算出每篇文章的主题分布。</p>
<h3 id="词嵌入与深度学习模型"><a href="#词嵌入与深度学习模型" class="headerlink" title="词嵌入与深度学习模型"></a>词嵌入与深度学习模型</h3><p>词嵌入是一类将词向量化的模型的统称,核心思想是将每个词都映射成低维空间(通常K=50~300维)上的一个稠密向量(<strong>Dense vector</strong>)。K维空间的每一维也可以看作一个隐含的主题,只不过不像主题模型中的主题那样直观。</p>
<p>由于词嵌入将每个词映射成一个K维的向量,如果一篇文档有N个词,就可以用一个NxK维的矩阵来表示这篇文档,但是这样的表示过于底层。在实际应用中,如果仅仅把这个矩阵作为原文本的表示特征输入到机器学习模型中,通常很难得到令人满意的结果。</p>
<p>因此,还需要在此基础之上加工出更高层的特征。在传统的浅层机器学习模型中,一个好的特征工程往往可以带来算法效果的显著提升。而深度学习模型正好为我们提供了一种自动地进行特征工程的方式,模型中的每个隐层都可以认为对应着不同抽象层次的特征。从这个角度来讲,<strong>深度学习模型</strong>能够打败浅层模型也就顺理成章了。卷积神经网络和循环神经网络的结构在文本表示中取得了很好的效果,主要是由于它们能够更好地对文本进行建模,抽取出一些高层的语义特征。与全连接的网络结构相比,卷积神经网络和循环神经网络一方面很好地抓住了文本的特性,另一方面又减少了网络中待学习的参数,提高了训练速度,并且降低了过拟合的风险。</p>
<p>所以说嵌入加深度模型成为了标配。</p>
<h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><p>谷歌2013年提出的word2vec是目前最常用的词嵌入模型之一。Word2Vec实际是一种<strong>浅层的神经网络模型</strong>,它有两种网络结构,分别是CBOW(Continues Bag of words)和Skip-gram。</p>
<h2 id="word2vec是如何工作的-它和LDA有什么区别与联系"><a href="#word2vec是如何工作的-它和LDA有什么区别与联系" class="headerlink" title="word2vec是如何工作的?它和LDA有什么区别与联系?"></a>word2vec是如何工作的?它和LDA有什么区别与联系?</h2><p><strong>CBOW</strong>的目标是根据上下文出现的词语来预测当前词的生成概率;而Skip-gram是根据当前词来预测上下文中各词的生成概率。<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-04%20%E4%B8%8B%E5%8D%887.15.32.png" alt=""><br>其中w()是当前所关注的词,w(t-2)、w(t-1)、w(t+1)、w(t+2)是上下文中出现的词。这里前后滑动窗口大小均设为2。</p>
<p>CBOW和Skip-gram都可以表示成由输入层(Input)、映射层(Projection)和输出层(Output)组成的神经网络。</p>
<p><strong>输入层</strong>中的每个词由<strong>独热编码</strong>方式表示,即所有词均表示成一个N维向量,其中N为词汇表中单词的总数。</p>
<p><strong>映射层</strong>(又称<strong>隐含层</strong>)中,K个隐含单元(Hidden units)的取值可以由N维输入向量以及连接输入和隐含单元之间的NxK维权重矩阵计算得到。在CBOW中,还需要将各个输入词所计算出的隐含单元求和。</p>
<p>同理,输出层向量的值可以通过隐含层向量(K维),以及连接隐含层和输出层之间的KxN维权重矩阵计算得到。输出层也是一个N维向量,每维与词汇表中的个单词相对应。最后,对输出层向量应用 Softmax激活函数,可以计算出每个单词的生成概率。 Softmax激活函数的定义为<br><img src="/img/media/%E7%99%BE%E9%9D%A2%20%20%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-04%20%E4%B8%8B%E5%8D%887.34.02.png" alt=""><br>其中x代表N维的原始输出向量,xn为在原始输出向量中,与单词wn所对应维度的取值。</p>
<p>接下来的任务就是训练神经网络的权重,使得语料库中所有单词的整体生成概率最大化。从输入层到隐含层需要一个维度为NxK的权重矩阵,从隐含层到输出层又需要一个维度为KxN的权重矩阵,学习权重可以用反向传播算法实现,每次迭代时将权重沿梯度更优的方向进行一小步更新。但是由于Softmax激活函数中存在归一化项的缘故,推导出来的迭代公式需要对词汇表中的所有单词进行遍历,使得每次迭代过程非常缓慢,由此产生了<strong>Hierarchical Softmax</strong>和<strong>Negative Sampling</strong>两种改进方法。</p>
<p>谈到word2Vec与LDA的区别和联系,首先,LDA是利用文档中单词的共现关系来对单词按主题聚类,也可以理解为对“文档-单词”矩阵进行分解,得到“文档主题”和“主题-单词”两个概率分布。而Word2vec其实是对“上下文单词矩阵进行 学习,其中上下文由周围的几个单词组成,由此得到的词向量表示更多地融入了上下文共现的特征。也就是说,如果两个单词所对应的Word2Vec向量相似度较      高,那么它们很可能经常在同样的上下文中出现。需要说明的是,上述分析的是 LDA与Word2veC的不同,不应该作为主题模型和词嵌入两类方法的主要差异。主题模型通过一定的结构调整可以基于“上下文-单词”矩阵进行主题推理。同样地,  词嵌入方法也可以根据“文档-单词”矩阵学习出词的隐含向量表示。主题模型和词嵌入两类方法最大的不同其实在于模型本身,主题模型是一种基于概率图模型的生成式模型,其似然函数可以写成若干条件概率连乘的形式,其中包括需要推测的隐含变量(即主题);而词嵌入模型一般表达为神经网络的形式,似然函数定义在网络的输出之上,需要通过学习网络的权重以得到单词的稠密向量表示。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2019/04/04/Happy Birthday to ZDK’s Blog🎁🎁🎁/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/04/Happy Birthday to ZDK’s Blog🎁🎁🎁/" class="post-title-link" itemprop="url">Happy Birthday to ZDK’s Blog🎁🎁🎁</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-04 14:23:32 / 修改时间：14:23:58" itemprop="dateCreated datePublished" datetime="2019-04-04T14:23:32+08:00">2019-04-04</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/个人总结/" itemprop="url" rel="index"><span itemprop="name">个人总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/04/Happy Birthday to ZDK’s Blog🎁🎁🎁/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/04/Happy Birthday to ZDK’s Blog🎁🎁🎁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/04/Happy Birthday to ZDK’s Blog🎁🎁🎁/" class="post-meta-item leancloud_visitors" data-flag-title="Happy Birthday to ZDK’s Blog🎁🎁🎁">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>去年的今天，ZDK的blog诞生了。</p>
<p>建立这个博客的初衷在于当做一个自己的读书笔记，在线免费云笔记。刚开始时是完全把大部分的内容照搬下来，基本上是读到了什么东西就写下来什么东西。基本上这个阶段主要就是体力劳动。此时博客的用处在于，当我看到一个什么东西时，我会想起来，我好像以前在博客中记录过这个东西，然后打开我的博客查看相关的内容来加深印象。这个阶段我的知识储备还不够多，所以处于知识积累的阶段。所以说博客这个时候更像是一个备忘录，什么知识点记得不太清了，可以翻翻博客加深记忆。</p>
<p>后来，我在《认知天性》这本书中找到了科学的解释，最适合人类大脑习性的学习方法包括三个步骤：<strong>编码，巩固和检索</strong>。使用博客来进行知识的积累貌似正好符合这几个阶段。第一个阶段我将博客当做我大脑的外存，我的大脑只需记忆知识的索引，在需要使用时，迅速从外存中调入我的大脑。随着调入次数的增多以及知识体系的逐渐建立，我对特定知识的印象也更深，很多时候也会在不同时期有着新的理解。知识慢慢地开始可以串联起来。而这个时候，在看到很多知识点时，就会有新的疑问，即为检索问题阶段。随着对问题的解决以及总结，慢慢发现自己对于知识点的理解更加深入了。善用检索，即问题导向。而发现问题更好的途径是对比知识点，以及真实场景。</p>
<p>随着不断的学习，越来越发现参考一本书是远远不够的，所以第二个阶段，这个博客开始出现了针对某个问题的总结，在这个阶段，需要翻阅多样参考文献来针对特定的问题作出总结，慢慢地，我发现，这个阶段大量的东西总结发生在纸上，真正到博客中的可能是经过总结后的。纸上总结有一个好处，就是不用鼠标的滚轮，在一个页面中即可构建知识的网络结构。下一个阶段，要更多的思考问题，更多的输出总结。形成自己的知识表征。<br><img src="/img/media/Happy%20Birthday%20to%20ZDK%E2%80%99s%20Blog%F0%9F%8E%81%F0%9F%8E%81%F0%9F%8E%81/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-04%20%E4%B8%8B%E5%8D%8812.10.28.png" alt=""></p>
<p><strong>主题阅读</strong><br><strong>问题导向</strong><br><strong>真实场景</strong><br><strong>刻意练习</strong></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="ZDK"/>
            
              <p class="site-author-name" itemprop="name">ZDK</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">191</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zdkswd" title="GitHub &rarr; https://github.com/zdkswd"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:2822464407@qq.com" title="E-Mail &rarr; mailto:2822464407@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/zdkswd" title="https://github.com/zdkswd">Title</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </div>

      

      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZDK</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  
  

<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz',
    appKey: 'gkBx5soQkBREmER84PWbNJeM',
    placeholder: 'have fun',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('5');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
