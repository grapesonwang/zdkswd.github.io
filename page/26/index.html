<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta property="og:type" content="website">
<meta property="og:title" content="ZDK&#39;s blog">
<meta property="og:url" content="https://github.com/zdkswd/page/26/index.html">
<meta property="og:site_name" content="ZDK&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZDK&#39;s blog">



  <link rel="alternate" href="/atom.xml" title="ZDK's blog" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="https://github.com/zdkswd/page/26/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ZDK's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZDK's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/05/25/Tensorflow模型持久化/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/25/Tensorflow模型持久化/" class="post-title-link" itemprop="url">Tensorflow模型持久化</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-25 19:00:56 / 修改时间：19:10:24" itemprop="dateCreated datePublished" datetime="2018-05-25T19:00:56+08:00">2018-05-25</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/05/25/Tensorflow模型持久化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/25/Tensorflow模型持久化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/05/25/Tensorflow模型持久化/" class="post-meta-item leancloud_visitors" data-flag-title="Tensorflow模型持久化">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="持久化代码实现"><a href="#持久化代码实现" class="headerlink" title="持久化代码实现"></a>持久化代码实现</h2><p>通过<strong>tf.train.Saver类</strong>来保存和还原一个神经网络，模型文件目录下会出现三个文件。这是因为Tensorflow会将计算图的结构和图上参数取值分开保存。</p>
<ol>
<li><strong>model.ckpt.meta</strong>,保存了计算图的结构。</li>
<li><strong>model.ckpt</strong>,保存程序中每一个变量的取值。</li>
<li><strong>checkpoint</strong>,保存了一个目录下所有的模型文件列表。</li>
</ol>
<p>加载已经保存的Tensorflow模型方法。1.使用和保存模型代码中一样的方法来声明变量。2.加载已经保存的模型。<strong>sever.restore(sess,”.ckpt”)</strong></p>
<p>加载模型的程序也是定义了Tensorflow计算图上的所有运算，并声明了一个tf.train.Saver类。区别在于加载模型的代码中没有运行变量的初始化过程而是将变量的值通过已经保存的模型加载了进来。也可以直接加载已经持久化的图<br><strong>saver=tf.train.import_meta_graph(…..meta)</strong></p>
<p>函数<strong>tf.get_default_graph().get_tensor_by_name(“add:0”)</strong>可以通过张量的名称获取张量。</p>
<p>也可以声明tf.train.Saver类时提供一个列表指定需要保存或者加载的变量。同样可以在保存和加载时使用字典给变量重命名。</p>
<p>使用Saver会保存运行程序所需的全部信息，然而有时不需要某些信息。在测试或者离线预测时，不需要某些辅助节点的信息。且多个文件存储时也并不方便。<strong>convert_variables_to_constants</strong>将计算图中的变量及其取值通过常亮保存。<br>导出当前计算图的GraphDef部分只需要这一部分就可以完成从输入层到输出层的计算过程。</p>
<blockquote>
<p>graph_def=tf.get_default_graph().as_graph_def()</p>
</blockquote>
<p>将图中的变量及其取值转化为常量，同时将图中不必要的节点去掉。一些如变量初始化操作的系统运算也会被转化为计算图的节点。可以通过【】指定需要保存的操作。</p>
<blockquote>
<p>output_graph_def=graph_util.convert_variables_to_constants(sess,graph_def,[‘add’])//add为节点名</p>
</blockquote>
<p>将导出模型存入文件：</p>
<blockquote>
<p>with tf.gfile.GFile(“…pb”,”wb”) as f:<br>　　f.write(output_graph_def.SerialzeToString())</p>
</blockquote>
<p>加载模型：</p>
<blockquote>
<p>with gflie.FastGFile(model_filename//.pb,’rb’) as f:<br>　　graph_def=tf.GraphDef()<br>　　graph_def.ParseFromString(f.read())<br>result=tf.import_graph_def(graph_def,return_elements=[“add:0”])//add:0为一个张量<br>sess.run(result)</p>
</blockquote>
<h2 id="Saver持久化原理及数据格式"><a href="#Saver持久化原理及数据格式" class="headerlink" title="Saver持久化原理及数据格式"></a>Saver持久化原理及数据格式</h2><p>Tensorflow通过元图（<strong>MetaGraph</strong>）来记录计算图中节点信息以及运行计算图中节点所需要的元数据。<br>由Protocol Buffer定义，记录了五类信息：</p>
<ol>
<li><strong>meta_info_def</strong>属性,记录计算图中的元数据以及所有使用到运算方法的信息。</li>
<li><strong>graph_def</strong>属性，记录计算图的节点信息。</li>
<li><strong>saver_def</strong>属性，记录了持久化模型时需要用到的一些参数。</li>
<li><strong>collection_def</strong>属性维护集合的底层实现是通过collection_def这个属性。<br>5 <strong>signature_def</strong>属性。</li>
</ol>
<p><strong>model.ckpt</strong>保存所有变量的取值，通过SSTable格式存储，大致为一个（key，value）列表。<br><strong>checkpoint</strong>是Saver类自动生成自动维护的。当某个保存的TensorFlow模型文件被删除时，这个模型对应的文件名也会从checkpoint文件中删除。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/05/20/Gradle/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/20/Gradle/" class="post-title-link" itemprop="url">Gradle</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-20 17:28:56 / 修改时间：17:42:20" itemprop="dateCreated datePublished" datetime="2018-05-20T17:28:56+08:00">2018-05-20</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/05/20/Gradle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/20/Gradle/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/05/20/Gradle/" class="post-meta-item leancloud_visitors" data-flag-title="Gradle">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="差异管理"><a href="#差异管理" class="headerlink" title="差异管理"></a>差异管理</h2><p>说到多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说国内某团购网站的Android App有100多个渠道.这里出现了什么?重复,反复的去打包而且这些包之前的差异很小(只是渠道号不同),和写代码一样我们应该复用,通过Gradle可以实现一个命令打出所有的渠道包,一个命令打出指定的渠道包.再复杂一点,你可能需要不同的渠道对应不同的签名文件,不同的icon,不同的服务器地址…这些都可以通过Gradle来方便的实现.</p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理:"></a>依赖管理:</h2><p>做软件开发你可能需要依赖各种不同的jar,library.你当然可以通过将.jar/library工程下载到本地再copy到你的工程中,但不知你是否听说过国外有个叫中央仓库的东西,在这个仓库里你可以找到所有你能想到以及你从来没听说过的jar,aar…The Central Repository Search Engine 这里可以找到所有你需要的依赖,而你需要的只是指定一个坐标,如下:<br>compile’com.squareup.picasso:picasso:2.3.3<br>剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:<br>剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:</p>
<ol>
<li>依赖不会进入到你的版本控制仓库中(默认会缓存到~/.gradle/下)</li>
<li>方便卸载装载依赖(只是一条坐标依赖,不需要删除即可)</li>
<li>方便的版本管理,如上图中的2.3.3既是picasso的版本号,若改为+就表示从中央仓库中下载最新的版本</li>
<li>不同工程的相同依赖不会存在重复副本(只在~/.gradle下存在一份)<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2>这方面我没怎么接触过,但据我所知通过一些插件,可以实现自动将你的输出(.jar,.apk,.war…)上传到指定仓库,自动部署…</li>
</ol>
<h2 id="Gradle概念"><a href="#Gradle概念" class="headerlink" title="Gradle概念"></a>Gradle概念</h2><p>Gradle，这是一个基于 JVM 的富有突破性<strong>构建工具</strong>。<br>Gradle不单单是一个配置脚本，它的背后是三门语言。<br>    ◦    Groovy Language<br>    ◦    Gradle DSL<br>    ◦    Android DSL<br><strong>DSL</strong>的全称是Domain Specific Language，即领域特定语言。</p>
<h2 id="The-Gradle-wrapper"><a href="#The-Gradle-wrapper" class="headerlink" title="The Gradle wrapper"></a>The Gradle wrapper</h2><p>Gradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。</p>
<h2 id="Gradle构建基础"><a href="#Gradle构建基础" class="headerlink" title="Gradle构建基础"></a>Gradle构建基础</h2><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><p>一个项目中会有一个project build.gradle。与若干个module build.gradle.<br>你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本。</p>
<h3 id="project与task"><a href="#project与task" class="headerlink" title="project与task"></a>project与task</h3><p>Gradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等。插件本身就是包含了若干Task的。</p>
<h2 id="Gradle脚本的执行时序"><a href="#Gradle脚本的执行时序" class="headerlink" title="Gradle脚本的执行时序"></a>Gradle脚本的执行时序</h2><ol>
<li><p><strong>初始化</strong>，分析有哪些module将要被构建，为每个module创建对应的 project实例。这个时候settings.gradle文件会被解析。</p>
</li>
<li><p><strong>配置</strong>,处理所有的模块的 build 脚本，处理依赖，属性等。这个时候每个模块的build.gradle文件会被解析并配置，这个时候会构建整个task的链表（这里的链表仅仅指存在依赖关系的task的集合，不是数据结构的链表）。先是project build.gradle后是module build.gradle,且从依赖树的叶节点执行。<strong>配置完了以后，有一个重要的回调project.afterEvaluate，它表示所有的模块都已经配置完了，可以准备执行task了。</strong></p>
</li>
<li><p><strong>执行</strong>，根据task链表来执行某一个特定的task，这个task所依赖的其他task都将会被提前执行。</p>
</li>
</ol>
<h2 id="Groovy基础-原创：任玉刚"><a href="#Groovy基础-原创：任玉刚" class="headerlink" title="Groovy基础[原创：任玉刚]"></a>Groovy基础[原创：任玉刚]</h2><h3 id="Groovy和Java的关系"><a href="#Groovy和Java的关系" class="headerlink" title="Groovy和Java的关系"></a>Groovy和Java的关系</h3><p>Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。</p>
<h3 id="Groovy的变量和方法声明"><a href="#Groovy的变量和方法声明" class="headerlink" title="Groovy的变量和方法声明"></a>Groovy的变量和方法声明</h3><p>在Groovy中，通过 def 关键字来声明变量和方法。</p>
<blockquote>
<p>def a = 1<br>def b = “hello world”<br>def int c = 1</p>
</blockquote>
<blockquote>
<p>def hello() {<br>    println “hello world” // 方法调用省略括号<br>    1;                    // 方法返回值省略return<br>}<br>def hello(String msg) {<br>    println (msg)<br>}</p>
</blockquote>
<blockquote>
<p>// 方法省略参数类型<br>int hello(msg) {<br>    println (msg)<br>    return 1<br>}</p>
</blockquote>
<blockquote>
<p>// 方法省略参数类型<br>int hello(msg) {<br>    println msg<br>    return 1 // 这个return不能省略<br>    println “done”<br>}</p>
</blockquote>
<h3 id="Groovy的数据类型"><a href="#Groovy的数据类型" class="headerlink" title="Groovy的数据类型"></a>Groovy的数据类型</h3><ol>
<li><p><strong>String</strong>,用于字符串拼接。</p>
</li>
<li><p><strong>闭包</strong>，Groovy中有一种特殊的<strong>类型</strong>，叫做<strong>Closure</strong>，翻译过来就是闭包，这是一种类似于C语言中函数指针的东西。闭包用起来非常方便，在Groovy中，闭包作为一种特殊的数据类型而存在，闭包可以作为方法的参数和返回值，也可以作为一个变量而存在。</p>
</li>
</ol>
<p>声明闭包</p>
<blockquote>
<p>{ parameters -&gt;<br>    code<br>}</p>
</blockquote>
<ol start="3">
<li><p><strong>List和Map</strong>,Groovy加强了Java中的集合类，比如List、Map、Set等.List还有一种看起来很奇怪的操作符&lt;&lt;，表示向List中添加新元素的意思.</p>
</li>
<li><p><strong>加强的IO</strong>.</p>
</li>
</ol>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul>
<li>所有的Class类型，都可以省略.class</li>
<li>只要有属性就有Getter/Setter，反之亦然。</li>
<li>with操作符<blockquote>
<p>Book bk = new Book()<br>bk.id = 1<br>bk.name = “android art”<br>bk.press = “china press”</p>
</blockquote>
</li>
</ul>
<p>可以简写为：</p>
<blockquote>
<p>Book bk = new Book()<br>bk.with {<br>    id = 1<br>    name = “android art”<br>    press = “china press”<br>}</p>
</blockquote>
<p>等等<a href="http://www.jianshu.com/p/ba55dc163dfd" target="_blank" rel="noopener">http://www.jianshu.com/p/ba55dc163dfd</a></p>
<h2 id="定义Task"><a href="#定义Task" class="headerlink" title="定义Task"></a>定义Task</h2><blockquote>
<p>task myTask {<br>    println “config myTask”<br>}</p>
</blockquote>
<p>通过上述方式定义的task,括号内部的代码会在配置阶段执行。</p>
<p>要括号内的代码仅仅在执行我们的task的时候才执行，这个时候可以通过doFirst或者doLast来完成。<br>    •    doFirst：task执行时，最开始的操作<br>    •    doLast：task执行时，最后的操作</p>
<blockquote>
<p>myTask.doLast {<br>    println “after execute myTask”<br>}<br>myTask.doFirst {<br>    println “before execute myTask”<br>}</p>
</blockquote>
<p>doLast还有一个等价的操作leftShift，leftShift还可以缩写为&lt;&lt;</p>
<blockquote>
<p>myTask &lt;&lt; {<br>    println “after execute myTask”<br>}</p>
</blockquote>
<p>剩下的细节还是需要大家查看Gradle文档，其实学习Gradle就是一个查文档的过程。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/" class="post-title-link" itemprop="url">x86 ARM MIPS NDK JNI 交叉编译 ABI</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-19 21:46:56" itemprop="dateCreated datePublished" datetime="2018-05-19T21:46:56+08:00">2018-05-19</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-25 18:28:42" itemprop="dateModified" datetime="2018-05-25T18:28:42+08:00">2018-05-25</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/05/19/x86 ARM MIPS NDK JNI 交叉编译 ABI/" class="post-meta-item leancloud_visitors" data-flag-title="x86 ARM MIPS NDK JNI 交叉编译 ABI">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="X86和ARM-MIPS架构"><a href="#X86和ARM-MIPS架构" class="headerlink" title="X86和ARM,MIPS架构"></a>X86和ARM,MIPS架构</h2><p>x86架构采用CISC，代表公司Intel。而ARM采用RISC，代表公司ARM。MIPS架构多用在网关、猫、机顶盒等设备。</p>
<p><strong>X86</strong>以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。x86为此还必须有复杂的分支预测机构，确保流水线的效率。再加上多级cache，支持超线程、虚拟化等等，x86的复杂度其实相当高<br><strong>ARM</strong>（Advanced RISC Machines）一个32位元精简指令集(RISC)处理器架构<br>可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。<br>但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。 </p>
<p><strong>扩展性</strong><br>X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，<br>x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。<br>ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行</p>
<p><strong>功耗</strong><br>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度，考虑其完成复杂操作的能力，功耗很大。<br>ARM则功耗很低。<br>ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场，<strong>ARM目前是移动处理器的老大</strong>；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 <strong>x86是PC端老大</strong>。</p>
<h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><p>Native Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C/C++的动态库，并能自动将so和java一起打包成apk。<strong>NDK就是帮助我们可以在Android应用中使用C/C++来完成特定功能的一套工具.</strong>NDK的作用有很多，我们简单的列举两个:<br>1.首先NDK可以帮助开发者“快速”开发C(或C++)的动态库。<br>2.其次，NDK集成了“<strong>交叉编译器</strong>”。使用NDK，我们可以将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。</p>
<h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>Java Native Interface（JNI）标准是java平台的一部分，JNI是Java语言提供的Java和C/C++相互沟通的机制，其实JNI它就是一种<strong>协议</strong>,Java可以通过JNI调用C/C++代码，C/C++的代码也可以调用java代码。</p>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>编译器在将中间代码连接成当前计算机可执行的二进制程序时，连接程序会根据当前计算机的CPU、操作系统的类型来转换。<br><strong>交叉编译</strong>就是在一个平台下（比如：CPU架构为X86，操作系统为Windows）编译出在另一个平台上（比如：CPU架构为arm,操作系统为Linux）可以执行的二进制代码。Google提供的NDK就可以完成交叉编译的工作。【Android：基于Linux 内核arm架构的操作系统，装在arm上的linux是需要重新编译内核的 所以和x86上的linux内核是不一样的】</p>
<h2 id="Android-设备的CPU类型-通常称为”ABIs”"><a href="#Android-设备的CPU类型-通常称为”ABIs”" class="headerlink" title="Android 设备的CPU类型(通常称为”ABIs”)"></a>Android 设备的CPU类型(通常称为”ABIs”)</h2><ol>
<li>armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的部分Android设备都使用它.</li>
<li>arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。</li>
<li>armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。</li>
<li>x86: 平板、模拟器用得比较多。</li>
<li>x86_64: 64位的平板。  </li>
</ol>
<p>arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so，那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了，所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，所以要么你别加arm64-v8a,要么armeabi里面有的so库，arm64-v8a里面也必须有。</p>
<p><strong>对策</strong>：</p>
<ul>
<li>为了减小 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中.so数量一致   </li>
<li>对只提供 armeabi 版本的第三方 .so，原样复制一份到 armeabi-v7a 文件夹   </li>
</ul>
<p>应用程序二进制接口（<strong>A</strong>pplication <strong>B</strong>inary <strong>I</strong>nterface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。 </p>
<p>当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支持armeabi-v7a和armeabi）。<br>我们往往很容易对.so文件<strong>应该放在或者生成到哪里</strong>感到困惑，下面是一个总结：Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）  </p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/05/17/lib,dll,.h,.hpp,预编译/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/17/lib,dll,.h,.hpp,预编译/" class="post-title-link" itemprop="url">lib dll .h .hpp 预编译</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-17 21:46:56 / 修改时间：21:48:14" itemprop="dateCreated datePublished" datetime="2018-05-17T21:46:56+08:00">2018-05-17</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/05/17/lib,dll,.h,.hpp,预编译/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/17/lib,dll,.h,.hpp,预编译/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/05/17/lib,dll,.h,.hpp,预编译/" class="post-meta-item leancloud_visitors" data-flag-title="lib dll .h .hpp 预编译">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="静态库动态库"><a href="#静态库动态库" class="headerlink" title="静态库动态库"></a>静态库动态库</h2><p>静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。<img src="/img/media/15265538206394/15265538778964.jpg" alt=""><br>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。<br><img src="/img/media/15265538206394/15265538810589.jpg" alt=""><br>是动态链接有一个缺点就是可移植性太差，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>编译时，编译器通过头文件.h找到对应的函数库，预编译时将整个.h文件插入目标文件头部，项目中需要有其对应的.c文件进行编译生成中间文件进行连接。<br>.hpp，本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数</p>
<p>一个头文件被别的源文件重复包含是经常发生的，如何避免某个头文件被重复包含呢？利用条件编译轻松解决。在头文件的开始加入：</p>
<blockquote>
<p>#ifndef HEADER_NAME<br>#define HEADER_NAME </p>
</blockquote>
<p>在头文件的结尾加上：</p>
<blockquote>
<p>#endif</p>
</blockquote>
<h2 id="C-C-中的预编译指令"><a href="#C-C-中的预编译指令" class="headerlink" title="C/C++中的预编译指令"></a>C/C++中的预编译指令</h2><p>程序的编译过程可以分为预处理、编译、汇编三部分，其中预处理是首先执行的过程，预处理过程扫描程序源代码，对其进行初步的转换，产生新的源代码提供给编译器。</p>
<ol>
<li><strong>#include</strong>指令，#include预处理指令的作用是在指令处展开被包含的文件。<br>#include \&lt;xxx.h&gt;<br>#include “xxx.h”<br>第一种方法将待包含的头文件使用尖括号括起来，预处理程序会在系统默认目录或者括号内的路径查找，通常用于包含系统中自带的公共头文件。<br>第二种方法将待包含的头文件使用双引号引起来，预处理程序会在程序源文件所在目录查找，如果未找到则去系统默认目录查找，通常用于包含程序作者编写的私有头文件。  </li>
</ol>
<p>2.<strong>#define、#undef</strong>指令,#define指令定义了一个标识符及一个串，标识符称为宏名，源程序中宏名的每次出现都会用其定义的串进行替换，称为宏替换。<br>#undef指令取消一个已定义的宏。  </p>
<p>3.<strong>#if、#elif、#else、#endif</strong>指令，这几个指令称为条件编译指令，可对程序源代码的各部分有选择地进行编译。<br>跟一般的if、else if、else语句类似，如果一个条件上的值为真，则编译它对应的代码，否则提过这些代码，测试下一个条件上的值是否为真。注意，作为条件的表达式是在编译时求值的，它必须仅含常量及已定义过的标识符，不可使用变量，也不可以含有操作符sizeof（sizeof也是编译时求值）。<br>感觉这主要是用来设置一个宏选择性的编译一部分的代码。  </p>
<p>4.<strong>#ifdef、#ifndef、#endif</strong>指令，这几个也是条件编译指令，其检查后面指定的宏是否已经定义，然后根据检查结果选择是否要编译后面语句。其中#ifdef表示”如果有定义“，#ifndef表示”如果没有定义“。这个通常可以用于防止重复包含头文件的问题</p>
<blockquote>
<p>#ifndef MYHEAD_H<br>#define MYHEAD_H<br>#include “myHead.h”<br>#endif  </p>
</blockquote>
<p>5.<strong>#line</strong>指令,C语言中可以使用<strong>FILE</strong>表示本行语句所在源文件的文件名，使用<strong>LINE</strong>表示本行语句在源文件中的位置信息。#line指令可以重新设定这两个变量的值，其语法格式为<br>#line number[“filename”] </p>
<p>6.<strong>#error</strong>指令,#error指令在编译时输出编译错误信息，可以方便程序员检查出现的错误。</p>
<p>7.<strong>#pragma</strong>指令,该指令用来来设定编译器的状态或者是指示编译器完成一些特定的动作，它有许多不同的参数。<br>7.1. #pragma once<br>在头文件的最开始加入这条指令可以保证头文件只被编译一次。它可以实现上述使用#ifndef实现不重复包含头文件同样的功能，但可能会有部分编译系统不支持。</p>
<p>7.2.#pragma message<br>该指令能够让编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。</p>
<p>7.3.#pragma warning<br>…等等其他参数</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/05/17/Tensorflow可视化/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/17/Tensorflow可视化/" class="post-title-link" itemprop="url">Tensorflow可视化</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-17 18:11:41" itemprop="dateCreated datePublished" datetime="2018-05-17T18:11:41+08:00">2018-05-17</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-05 19:50:44" itemprop="dateModified" datetime="2018-11-05T19:50:44+08:00">2018-11-05</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/05/17/Tensorflow可视化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/17/Tensorflow可视化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/05/17/Tensorflow可视化/" class="post-meta-item leancloud_visitors" data-flag-title="Tensorflow可视化">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tensorflow计算模型–计算图"><a href="#Tensorflow计算模型–计算图" class="headerlink" title="Tensorflow计算模型–计算图"></a>Tensorflow计算模型–计算图</h2><h3 id="计算图的使用"><a href="#计算图的使用" class="headerlink" title="计算图的使用"></a>计算图的使用</h3><p>tensorflow程序可分为两个阶段，第一阶段定义图中所有的计算。第二阶段为执行阶段。<br>tensorflow中，系统会自动维护一个默认的计算图，通过<strong>tf.get_default_graph</strong>函数可以获取当前默认的计算图。<br>除了使用默认的计算图，Tensorflow支持通过<strong>tf.Graph</strong>函数来生成新的计算图。不同计算图上的张量和运算都不会共享。<br>计算图可以通过<strong>tf.Graph.device</strong>函数来指定运行计算的设备。<br>有效地整理TensorFlow程序的资源也是计算图的一个重要功能。在一个集合（collection）来管理不同类型的资源。</p>
<table>
<thead>
<tr>
<th>集合名称</th>
<th>集合内容</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>tf.GraphKeys.VARIABLES</td>
<td>所有变量</td>
<td>持久化Tensorflow模型</td>
</tr>
<tr>
<td>tf.GraphKeys.TRAINABLE_VARIABLES</td>
<td>可学习的变量（一般指神经网络中的参数）</td>
<td>模型训练、生成模型可视化内容</td>
</tr>
<tr>
<td>tf.GraphKeys.SUMMARIES</td>
<td>日志生成的相关的张量</td>
<td>TensorFlow计算可视化</td>
</tr>
<tr>
<td>tf.GraphKeys.QUEUE_RUNNERS</td>
<td>处理输入的QueueRunner</td>
<td>输入处理</td>
</tr>
<tr>
<td>tf.GraphKeys.MOVING_AVERAGE_VARIABLES</td>
<td>所有计算了滑动平均值的变量</td>
<td>计算变量的滑动平均值</td>
</tr>
</tbody>
</table>
<p>如通过<strong>tf.add_to_collection</strong>将资源加入一个或多个集合中。通过<strong>tf.get_collection</strong>获取一个集合里面的所有资源。<br>tf.add_to_collection(‘losses’,regularizer(var_weights)):将数值regularizer(var_weights)添加到集合‘losses’中<br>tf.get_collection(‘losses’):获取集合“losses”中的所有元素，生成一个列表并返回该列表</p>
<h2 id="TensorBoard可视化"><a href="#TensorBoard可视化" class="headerlink" title="TensorBoard可视化"></a>TensorBoard可视化</h2><h3 id="TensorBoard简介"><a href="#TensorBoard简介" class="headerlink" title="TensorBoard简介"></a>TensorBoard简介</h3><p>TensorBoard可以通过TensorFlow程序运行过程中输出的日志文件可视化TensorFlow程序的运行状态。两者跑在不同进程中，TensorBoard会自动读取TensorFlow最新的日志文件。</p>
<blockquote>
<p>#运行TensorBoard，将地址执行日志输出地址<br>tensorboard –logdir=/path/to/log</p>
</blockquote>
<p>命令启动服务默认端口号6006，localhost:6006可以看到界面。使用–port参数可以改变启动服务的端口。</p>
<h2 id="变量管理"><a href="#变量管理" class="headerlink" title="变量管理"></a>变量管理</h2><p>TensorFLow提供了通过变量名称来创建或者获取一个变量的机制。通过这个机制在不同的函数中可以直接通过变量的名称来使用变量，而不需要将变量通过参数的形式到处传递。TensorFLow中通过变量名称获取变量的机制主要是通过<strong>tf.get_variable</strong>和<strong>tf.variable_scope</strong>函数实现。</p>
<p>v.get_variable和tf.Variable定义等价。区别在于前者变量名称是个必填项，后者是个选填项。v.get_variable会根据这个名字去创建或者获取变量。首先会试图创建一个变量，如有同名则创建失败。如果需要通v.get_variable获取一个已经创建的变量，<strong>需要tf.variable_scope函数生成一个上下文管理器。将参数reuse设置为True</strong>(获取唯一途径)，v.get_variable将<strong>只能</strong>获取已经创建过的变量。否则将尝试创建变量。</p>
<blockquote>
<p>with tf.variable_scope(“name”,reuse=”True”):<br>      v=v.get_variable(“var”,[1])</p>
</blockquote>
<p><strong>tf.variable_scope会创建一个命名空间。</strong>foo/v:0 “:0”表示这个变量是生成变量这个运算的第一个结果。</p>
<h2 id="TensorFlow计算图可视化"><a href="#TensorFlow计算图可视化" class="headerlink" title="TensorFlow计算图可视化"></a>TensorFlow计算图可视化</h2><h3 id="命名空间与TensorBoard图上节点"><a href="#命名空间与TensorBoard图上节点" class="headerlink" title="命名空间与TensorBoard图上节点"></a>命名空间与TensorBoard图上节点</h3><p>变量的初始化过程也会产生新的计算节点。为了更好的组织可视化效果图中的计算节点，TensorBoard支持通过TensorFlow命名空间来整理可视化效果图上的节点。在Tensorflow默认视图中同一命名空间计算图为一个节点，只有顶层命名空间的节点显示。<br>除了tf.Variable_scope函数，tf.name_scope函数也提供了命名空间管理的功能，两者大部分情况下等价。唯一的区别是tf.get_Variable不受tf.name_scope函数的影响。即在tf.name_scope域里tf.get_Variable生成变量也不是域内的变量。<br>节点之间有两种不同的边，一种是通过实线表示的，刻画了数据传输，箭头表示传输方向。另一种箭头是双向的，表示会修改，会互相影响。<br>TensorBoard边上标注了张量的维度信息。如100*784说明batch为100，输入节点个数为784，粗细代表维度的总大小。若张量数量大于1时。图上将只显示张量的个数。<br>虚线表示计算之间的依赖关系，如tf.control_dependencies函数指定操作同时进行。则存在虚线。<br>TensorBoard会自动将连接比较多的节点放在辅助图中，可以手动移入主图或移出主图。TensorBoard不会保存用户对计算图可视化结果的手工修改，页面刷新之后计算图可视化结果又会回到最初的样子。</p>
<h3 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h3><p>使用TensorBoard可以非常直观地展现所有Tensorflow计算节点在某一次运行时所消耗的时间和内存。</p>
<blockquote>
<p>run_options =tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)<br>// 运行时记录运行信息的proto。<br>run_metadata = tf.RunMetadata()<br>   m, loss_value, step = sess.run(<br>                    [train_op, loss, global_step], feed_dict={x: xs, y_: ys},<br>                    options=run_options, run_metadata=run_metadata)<br>                    //将节点在运行时的信息写入日志文件。          writer.add_run_metadata(run_metadata=run_metadata,tag=(“tag%d” % i),global_step=i)</p>
</blockquote>
<p>使用程序输出的日志启动TensorBoard,就可以了。进入GRAPHS栏，选择Session runs,Color会出现Compute time和Memory这两个选项。颜色越深消耗越大。Structure中如果有两个节点结构相同就会涂上相同的颜色。Device中可显示哪些使用了相同的设备（CPU/GPU）。<br>点击节点时弹出的信息卡片也会显示这个节点的各种信息。</p>
<h2 id="监控指标可视化"><a href="#监控指标可视化" class="headerlink" title="监控指标可视化"></a>监控指标可视化</h2><table>
<thead>
<tr>
<th>TensorFlow日志生成函数</th>
<th>TensorBoard界面栏</th>
<th>显示内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>tf.scalar_summary</td>
<td>EVENTS</td>
<td>TensorFlow中标量（scalar）监控数据随着迭代进行的变化趋势。</td>
</tr>
<tr>
<td>tf.image_summary</td>
<td>IMAGES</td>
<td>TensorFlow中使用的图片数据，这一栏一般用于可视化当前使用的训练/测试图片。</td>
</tr>
<tr>
<td>tf.audio_summary</td>
<td>AUDIO</td>
<td>TensorFlow中使用的音频数据。</td>
</tr>
<tr>
<td>tf.histogram_summary</td>
<td>HISTOGRAMS</td>
<td>TensorFlow中张量分布监控数据随着迭代轮次的变化趋势。</td>
</tr>
</tbody>
</table>
<p>上述生成函数都不会立即执行，需要通过sess.run来明确调用这些函数。tf.merge_all_summaries()可将定义的所有日志文件执行一次。</p>
<h2 id="writer"><a href="#writer" class="headerlink" title="writer"></a>writer</h2><blockquote>
<p>writer=tf.train.SummaryWriter(path,tf.get_default_graph())<br>writer.close()　　</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>with tf.Session() as sess:<br>　　writer=tf.train.SummaryWriter(path,sess.graph)</p>
</blockquote>
<p><strong>上述比较过时，若报错则改为writer = tf.summary.FileWriter(“output”, sess.graph)</strong> </p>
<p>可视化时，需要在程序中给必要的节点添加摘要（summary）,摘要会收集该节点的数据，并标记上第几步、时间戳等标识，写入事件文件（event file）中。tf.summary.FileWriter类用于在目录中创建事件文件，并且向文件中添加摘要和事件，用来在TensorBoard中展示。</p>
<p><img src="/img/media/101/1.png" alt=""></p>
<p><img src="/img/media/101/2.png" alt=""></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/05/15/【Linux】进程调度/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/15/【Linux】进程调度/" class="post-title-link" itemprop="url">[Linux内核设计与实现]进程调度</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-15 21:39:12" itemprop="dateCreated datePublished" datetime="2018-05-15T21:39:12+08:00">2018-05-15</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-29 21:41:02" itemprop="dateModified" datetime="2019-03-29T21:41:02+08:00">2019-03-29</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/05/15/【Linux】进程调度/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/15/【Linux】进程调度/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/05/15/【Linux】进程调度/" class="post-meta-item leancloud_visitors" data-flag-title="[Linux内核设计与实现]进程调度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>现代Linux系统也许有100个进程在内存，但是只有一个处于可运行状态。<br>Linux是抢占式多任务模式。</p>
<h2 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h2><p>Linux2.5内核开始采用O（1）调度程序，对大服务器工作负载很理想但对于交互性桌面系统表现不佳。<br>2.6.23内核后使用RSDL增加了交互性，此时被称为CFS（完全公平调度算法）</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="I-O消耗型和处理器消耗型的进程"><a href="#I-O消耗型和处理器消耗型的进程" class="headerlink" title="I/O消耗型和处理器消耗型的进程"></a>I/O消耗型和处理器消耗型的进程</h3><p>GUI属于I/O消耗型，多数时间都在等待键鼠交互操作。<br>应当降低处理器消耗型的调度频率，以延长其运行时间。<br>Linux更倾向于IO消耗型进程，也并未忽略处理器消耗型进程。</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>Linux采用了两种不同范围的优先级范围。<br>1：使用nice值，范围【-20，19】，默认0，越大优先级越低。Linux nice代表时间片比例，mac os nice代表时间片的绝对值。<br>2：实时优先级，其值可配。范围【0，99】，越高优先级越大。任何实时进程优先级都高于普通进程。</p>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>Linux的CFS调度器并没有直接分配时间片到进程，将处理器的使用比划分给了进程。进程所获处理器的时间和负载密切相关。受nice值得影响。<br>Linux的CFS调度器抢占时机取决于进程的处理器使用比，若大于当前进程则抢占。</p>
<h3 id="调度策略的活动"><a href="#调度策略的活动" class="headerlink" title="调度策略的活动"></a>调度策略的活动</h3><p>对于一个文字编辑程序和一个视频处理程序，一般操作系统会分配文字编辑器更高的优先级和更多的时间片。Linux则是nice值相同，即平分50%时间，但是当文字编辑程序要使用处理器时，CFS发现其时间没到50%，会抢占视频处理程序执行。</p>
<h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><h3 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h3><p>Linux调度器是模块方式，可以针对不同类型的进程选择合适的调度算法。<br>完全公平调度（CFS）是针对普通进程的调度类。</p>
<h3 id="Unix系统的进程调度"><a href="#Unix系统的进程调度" class="headerlink" title="Unix系统的进程调度"></a>Unix系统的进程调度</h3><p>CFS完全摒弃时间片而是分配进程一个处理器的使用比重，这样CFS确保了进程调度有恒定的公平性，将切换频率置于不断变动中。</p>
<h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p>CFS的最小粒度（最小时间片长度）为1ms，时间片分配时间根据目标延迟以及nice值决定的比例计算而得。所以说其实如果进程无限大的话，改法并不公平。但是能保证正常情况下是公平的。</p>
<h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h3><p> 所有的调度器都必须对进程运行时间做记账。</p>
<ol>
<li><strong>调度器实体结构</strong>,CFS不再有时间片的概念，但是它也必须维护每个进程运行时间记账，为了确保每个进程只在公平分配给它的处理器时间运行。CFS使用调度器实体结构struct sched_entity作为名为se的成员变量，嵌入进程描述符struct task_struct内。  </li>
<li><strong>虚拟实时</strong>，struct sched_entity结构中的vruntime变量存放进程的虚拟运行时间，虚拟时间是以ns为单位的，与定时器节拍不再相关。vruntime可以准确地测量给定进程的运行时间，而且可知道谁应该是下一个被运行的进程。</li>
</ol>
<h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h3><p>当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。<br>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小的vruntime值的进程。红黑树是一种以树节点形式存储的数据，这些数据都对应一个键值，可通过键值快速检索节点上的数据。</p>
<ol>
<li><strong>挑选下一个任务</strong>，CFS调度器选取待运行的下一个进程，是所有进程中vruntime最小的那一个，对应的便是树最左侧的叶子节点。   </li>
<li><strong>向树中加入进程</strong>，CFS如何将进程加入rbtree中，以及如何缓存最左叶子节点。这一切发生在进程变为可运行状态（被唤醒）或是通过fork()调用第一次创建进程时。enqueue_entity()函数实现了这一目的。改函数更新运行时间和其他一些统计数据，然后调用_enqueue_entity()进行繁重的插入操作，把数据项真正插入到红黑树中。</li>
<li><strong>从树中删除进程</strong>, 删除动作发生在进程堵塞或者终止时。<h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h3>进程调度的主要入口点是函数schedule()，它会找到一个最高优先级的调度类，其需要有自己的可运行队列。<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3>休眠（被阻塞）进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程刚好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。</li>
<li><strong>等待队列</strong>， 等待队列是由等待某些事件发生的进程组成的简单链表。</li>
<li><strong>唤醒</strong>， 唤醒指定等待队列上的所有进程。<h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2>上下文切换，就是从一个可执行进程切换到另一个可执行的进程。由函数context_switch()负责，每当新的进程被选出来准备投入运行时，schedule()就会调用该函数。内核提供了一个need_resched标志表明是否需要重新执行一次调度，内核也就知道什么时候调用schedule()。当某个进程应该被抢占或优先级高的进程进入可执行状态时或中断返回或系统调用返回用户空间，会设置标志位。<h3 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h3>内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。即用户抢占发生在</li>
</ol>
<ul>
<li>从系统调用返回用户空间时。     </li>
<li>从中断处理程序返回用户空间时。  </li>
</ul>
<h3 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h3><p>Linux完整地支持内核抢占，只要重新调度是安全的，内核就可以在任何时候抢占正在执行的内核任务。安全即没有持有锁，即preempy_count=0且need_resched被设置，中断返回内核空间时，就可调度。同样若内核阻塞或显式调用schedule()也会显式抢占。</p>
<h2 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h2><p>Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的非实时的调度策略是SCHED_NORMAL.这些策略被一个特殊的实时调度器管理。</p>
<ol>
<li><strong>SCHED_FIFO</strong>, 不基于时间片，可以一直执行下去，其比任何SCHED_NORMAL级的进程都先得到调度。更高优先级的SCHED_FIFO或SCHED_RR才能抢占。优先级一样的就轮流执行。</li>
<li><strong>SCHED_RR</strong>,带有时间片的SCHED_FIFO，耗尽时间片时，只能调度同一优先级的进程。<br>【 <strong>总结</strong>】：对于SCHED_FIFO进程，高优先级总是立即抢占低优先级进程，但低优先级决不能抢占SCHED__RR任务，即使它的时间片耗尽。<br>Linux提供的是软实时工作方式，SCHED_RR与SCHED_FIFO优先级范围【0，99】，而SCHED_NORMAL使用nice值。<h2 id="与调度相关的系统调度"><a href="#与调度相关的系统调度" class="headerlink" title="与调度相关的系统调度"></a>与调度相关的系统调度</h2>Linux提供了一个系统调用族，用于管理与调度程序的相关<strong>参数</strong>。这些系统调用可以用来操作和处理进程优先级、调度策略及处理器绑定，同时还提供了显式地将处理器交给其他进程的机制。<h3 id="与调度策略和优先级相关的系统调用"><a href="#与调度策略和优先级相关的系统调用" class="headerlink" title="与调度策略和优先级相关的系统调用"></a>与调度策略和优先级相关的系统调用</h3>sched_setscheduler()和sched_getscheduler()用于设置和获取进程的调度策略和实时优先级。sched_setparam()和sched_getparam()用于设置和获取进程的实时优先级。<h3 id="与处理器绑定有关的系统调用"><a href="#与处理器绑定有关的系统调用" class="headerlink" title="与处理器绑定有关的系统调用"></a>与处理器绑定有关的系统调用</h3>Linux调度程序提供强制的处理器绑定机制。<h3 id="放弃处理器时间"><a href="#放弃处理器时间" class="headerlink" title="放弃处理器时间"></a>放弃处理器时间</h3>Linux通过sched_yield()系统调用，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。 </li>
</ol>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/zdkswd/2018/04/29/cmake/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZDK"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZDK's blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/29/cmake/" class="post-title-link" itemprop="url">初识makefile_make_cmake</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-29 22:11:20" itemprop="dateCreated datePublished" datetime="2018-04-29T22:11:20+08:00">2018-04-29</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-16 19:02:54" itemprop="dateModified" datetime="2018-05-16T19:02:54+08:00">2018-05-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/知识总结/" itemprop="url" rel="index"><span itemprop="name">知识总结</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2018/04/29/cmake/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/29/cmake/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2018/04/29/cmake/" class="post-meta-item leancloud_visitors" data-flag-title="初识makefile_make_cmake">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识makefile-make-cmake"><a href="#初识makefile-make-cmake" class="headerlink" title="初识makefile,make,cmake"></a>初识makefile,make,cmake</h1><h2 id="什么是makefile"><a href="#什么是makefile" class="headerlink" title="什么是makefile"></a>什么是makefile</h2><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去<strong>编译</strong>和<strong>链接</strong>程序。<br>makefile关系到了整个工程的编译规则。makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h2 id="什么是make"><a href="#什么是make" class="headerlink" title="什么是make"></a>什么是make</h2><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<p>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法（包括链接）。</p>
<h2 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="关于程序的编译和链接"></a>关于程序的编译和链接</h2><p>在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。Linux中的.so。<br>一个lib文件是obj文件的集合。<br>源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码</p>
<h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p><strong>usr</strong>文件夹称为是Unix System Resource，即Unix系统资源的缩写。  </p>
<p><strong>bin文件夹</strong>是一个二进制程序文件夹<br>1.bin是binary的缩写，代表的意思是二进制，二进制数据是用0和1两个数码来表示的数。<br>2.bin这个文件夹里存放的是二进制可执行的文件，比如exe，msi，com等的都是二进制文件，双击就能运行。  </p>
<p>GUN下面绝大部分应用的编译系统都是用<strong>automake</strong>。<br>于是乎，你看到的很多很多应用都安装在了/usr/local/目录下<br>然后通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变<br>/usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件<br>安装好的lib文件存放在“/usr/local/lib”文件夹，h文件存放在“/usr/local/include”（Unix）</p>
<h2 id="什么是cmake"><a href="#什么是cmake" class="headerlink" title="什么是cmake"></a>什么是cmake</h2><p>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。<br>cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。</p>
<p><img src="/img/media/15249996372857/15250008307496.jpg" alt=""></p>
<h2 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h2><p>dll存在于windows中</p>
<h2 id="openCV安装过程"><a href="#openCV安装过程" class="headerlink" title="openCV安装过程"></a>openCV安装过程</h2><blockquote>
<p>mkdir release<br>cd release<br>cmake -D CMAKE_BUILD_TYPE=RELEASE -D 换行CMAKE_INSTALL_PREFIX=usr/local/opencv3.1.0  -G “Unix Makefiles” ..<br>make<br>sudo make install</p>
</blockquote>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="ZDK"/>
            
              <p class="site-author-name" itemprop="name">ZDK</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">191</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zdkswd" title="GitHub &rarr; https://github.com/zdkswd"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:2822464407@qq.com" title="E-Mail &rarr; mailto:2822464407@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/zdkswd" title="https://github.com/zdkswd">Title</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </div>

      

      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZDK</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  
  

<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'QiU7UFIdgTTauFTk89N47mQS-gzGzoHsz',
    appKey: 'gkBx5soQkBREmER84PWbNJeM',
    placeholder: 'have fun',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('5');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
